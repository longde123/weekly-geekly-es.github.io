<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçü§ù‚Äçüë®üèª üåµ ‚ûï Sistemas operacionais: tr√™s pe√ßas f√°ceis. Parte 4: Introdu√ß√£o ao Agendador (tradu√ß√£o) üéôÔ∏è üñ≤Ô∏è üà∑Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introdu√ß√£o aos sistemas operacionais 
 Ol√° Habr! Quero chamar sua aten√ß√£o para uma s√©rie de artigos - tradu√ß√µes de uma literatura interessante em minh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistemas operacionais: tr√™s pe√ßas f√°ceis. Parte 4: Introdu√ß√£o ao Agendador (tradu√ß√£o)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449026/"><h1>  Introdu√ß√£o aos sistemas operacionais </h1><br>  Ol√° Habr!  Quero chamar sua aten√ß√£o para uma s√©rie de artigos - tradu√ß√µes de uma literatura interessante em minha opini√£o - OSTEP.  Este artigo discute profundamente o trabalho de sistemas operacionais semelhantes a unix, ou seja, trabalha com processos, v√°rios agendadores, mem√≥ria e outros componentes similares que comp√µem o sistema operacional moderno.  O original de todos os materiais que voc√™ pode ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Observe que a tradu√ß√£o foi feita de maneira n√£o profissional (muito livremente), mas espero ter mantido o significado geral. <br><br>  O trabalho de laborat√≥rio sobre este assunto pode ser encontrado aqui: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o original</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o original</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">minha adapta√ß√£o pessoal</a> </li></ul><br>  Outras partes: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1: Introdu√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2: Abstra√ß√£o: o processo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3: Introdu√ß√£o √† API do Processo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 4: Introdu√ß√£o ao Agendador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 5: MLFQ Scheduler</a> </li></ul><br>  E voc√™ pode olhar para o meu canal no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">telegrama</a> =) <br><a name="habracut"></a><br><h2>  Introdu√ß√£o ao Agendador </h2><br>  <u>A ess√™ncia do problema: como desenvolver uma pol√≠tica de planejamento</u> <u><br></u>  <u>Como as estruturas de pol√≠ticas b√°sicas do planejador devem ser desenvolvidas?</u>  <u>Quais devem ser as principais premissas?</u>  <u>Quais m√©tricas s√£o importantes?</u>  <u>Quais t√©cnicas b√°sicas foram usadas na computa√ß√£o inicial?</u> <br><br><h3>  Pressupostos da carga de trabalho </h3><br>  Antes de discutir poss√≠veis pol√≠ticas, faremos algumas digress√µes simplificadoras sobre os processos em execu√ß√£o no sistema, que s√£o coletivamente chamados de <b>carga de trabalho</b> .  Ao definir uma carga de trabalho como uma parte cr√≠tica da cria√ß√£o de pol√≠ticas e quanto mais voc√™ souber sobre a carga de trabalho, melhor a pol√≠tica que voc√™ pode escrever. <br><br>  Fazemos as seguintes suposi√ß√µes sobre os processos em execu√ß√£o no sistema, √†s vezes tamb√©m chamados de <b>tarefas</b> (tarefas).  Quase todas essas suposi√ß√µes n√£o s√£o realistas, mas necess√°rias para o desenvolvimento do pensamento. <br><br><ol><li>  Cada tarefa executa a mesma quantidade de tempo, </li><li>  Todas as tarefas s√£o definidas ao mesmo tempo, </li><li>  A tarefa em quest√£o at√© sua conclus√£o, </li><li>  Todas as tarefas usam apenas a CPU, </li><li>  O tempo de execu√ß√£o de cada tarefa √© conhecido. </li></ol><br><h3>  M√©tricas do agendador </h3><br>  Al√©m de algumas suposi√ß√µes sobre a carga, ainda √© necess√°ria alguma ferramenta para comparar v√°rias pol√≠ticas de planejamento: m√©tricas do planejador.  Uma m√©trica √© apenas uma medida de algo.  H√° v√°rias m√©tricas que podem ser usadas para comparar planejadores. <br><br>  Por exemplo, usaremos uma m√©trica chamada tempo de resposta.  O tempo de resposta de uma tarefa √© definido como a diferen√ßa entre o tempo necess√°rio para concluir a tarefa e o tempo em que a tarefa entra no sistema. <br><br>  <u>Tturnaround = Conclus√£o - Tarrival</u> <br><br>  Como assumimos que todas as tarefas chegaram ao mesmo tempo, Ta = 0 e, portanto, Tt = Tc.  Esse valor mudar√° naturalmente quando alterarmos as premissas acima. <br><br>  Outra m√©trica √© a <b>justi√ßa</b> (justi√ßa, honestidade).  Produtividade e honestidade s√£o frequentemente caracter√≠sticas opostas no planejamento.  Por exemplo, um planejador pode otimizar o desempenho, mas com o custo de aguardar a execu√ß√£o de outras tarefas, reduzindo a integridade. <br><br><h3>  PRIMEIRO EM PRIMEIRO OUT (FIFO) </h3><br>  O algoritmo mais b√°sico que podemos implementar √© chamado FIFO ou <b>primeiro a chegar (entrar), primeiro a ser servido (sair)</b> .  Esse algoritmo tem v√°rias vantagens: √© muito simples de implementar e se encaixa em todas as nossas suposi√ß√µes, fazendo o trabalho muito bem. <br><br>  Considere um exemplo simples.  Suponha que 3 tarefas foram definidas ao mesmo tempo.  Mas suponha que a tarefa A tenha chegado um pouco mais cedo do que todos os outros, portanto ela estar√° na lista de execu√ß√£o antes das outras, assim como B em rela√ß√£o a C. Suponha que cada uma delas leve 10 segundos para ser conclu√≠da.  Qual ser√° o tempo m√©dio para concluir essas tarefas? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1b4/a43/acd/1b4a43acd8a0f18c24bbdd831529bbda.jpg" alt="imagem"><br><br>  Contando os valores - 10 + 20 + 30 e dividindo por 3, obtemos o tempo m√©dio de execu√ß√£o do programa igual a 20 segundos. <br><br>  Agora vamos tentar mudar nossas suposi√ß√µes.  Em particular, suposi√ß√£o 1 e, portanto, n√£o assumiremos mais que cada tarefa leva a mesma quantidade de tempo.  Como o FIFO se mostrar√° desta vez? <br><br>  Como se v√™, diferentes tempos de execu√ß√£o das tarefas t√™m um impacto extremamente negativo na produtividade do algoritmo FIFO.  Suponha que a tarefa A ser√° executada por 100 segundos, enquanto B e C ainda ser√£o 10 cada. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7a/bee/3fe/a7abee3fefd7a0cf481d0322f40e732f.jpg" alt="imagem"><br><br>  Como pode ser visto na figura, o tempo m√©dio para o sistema √© (100 + 110 + 120) / 3 = 110.  Esse efeito √© chamado de <b>efeito comboio</b> , quando alguns consumidores de curto prazo de um recurso estar√£o alinhados ap√≥s um consumidor pesado.  Parece uma linha de supermercado quando um cliente com um carrinho cheio est√° na sua frente.  A melhor solu√ß√£o para o problema √© tentar trocar o caixa ou relaxar e respirar profundamente. <br><br><h3>  Primeiro trabalho mais curto </h3><br>  √â poss√≠vel resolver de alguma forma uma situa√ß√£o semelhante com processos pesados?  Claro.  Outro tipo de agendamento √© chamado <b>Shortest Job First</b> (SJF).  Seu algoritmo tamb√©m √© bastante primitivo - como o nome indica, as tarefas mais curtas ser√£o iniciadas uma ap√≥s a outra. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/778/feb/207/778feb20723fa2d019620b97d27f2830.jpg" alt="imagem"><br><br>  Neste exemplo, o resultado do in√≠cio dos mesmos processos ser√° uma melhoria no tempo m√©dio de resposta dos programas e ser√° <b>50 em vez de 110</b> , o que √© quase duas vezes melhor. <br><br>  Assim, para a suposi√ß√£o de que todas as tarefas chegam ao mesmo tempo, o algoritmo SJF parece ser o algoritmo mais ideal.  No entanto, nossas suposi√ß√µes ainda n√£o parecem realistas.  Desta vez, alteramos a suposi√ß√£o 2 e, desta vez, imaginamos que as tarefas podem permanecer a qualquer momento, e n√£o todas ao mesmo tempo.  A que problemas isso pode levar? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/484/6df/332/4846df332de36b42bf891e167ef3f751.jpg" alt="imagem"><br><br>  Imagine que a tarefa A (100s) chegue primeiro e comece a ser executada.  No momento t = 10, as tarefas B, C chegam, cada uma levando 10 segundos.  Portanto, o tempo m√©dio de execu√ß√£o √© (100+ (110-10) + (120-10)) \ 3 = 103. O que o planejador poderia fazer para melhorar a situa√ß√£o? <br><br><h3>  Menor tempo at√© a conclus√£o primeiro (STCF) </h3><br>  Para melhorar a situa√ß√£o, omitimos a suposi√ß√£o 3 de que o programa est√° em funcionamento at√© a conclus√£o.  Al√©m disso, precisaremos de suporte de hardware e, como voc√™ deve ter adivinhado, usaremos um <b>timer</b> para interromper uma tarefa de trabalho e <b>alternar contextos</b> .  Assim, o planejador pode fazer algo no momento em que as tarefas B e C chegam - interromper a execu√ß√£o da tarefa A e colocar as tarefas B e C em processamento e, ap√≥s a conclus√£o, continuar o processo A. Esse planejador √© chamado <b>STCF</b> ou <b>Primeiro Trabalho Preemptivo</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0eb/900/a1f/0eb900a1f8b96a0952061727037faf4f.jpg" alt="imagem"><br><br>  O resultado deste planejador ser√° este resultado: ((120-0) + (20-10) + (30-10)) / 3 = 50.  Assim, esse agendador se torna ainda mais ideal para nossas tarefas. <br><br><h3>  Tempo de resposta da m√©trica </h3><br>  Portanto, se soubermos o tempo de execu√ß√£o das tarefas e se essas tarefas usam apenas a CPU, o STCF ser√° a melhor solu√ß√£o.  E uma vez nos primeiros dias, esses algoritmos funcionavam muito bem.  No entanto, agora o usu√°rio passa a maior parte do tempo no terminal e espera intera√ß√£o produtiva e interativa.  Ent√£o nasceu uma nova m√©trica - <b>tempo de</b> resposta (resposta). <br><br>  O tempo de resposta √© calculado da seguinte maneira: <br><br>  <u>Tresponse = Tfirstrun - Tarrival</u> <br><br>  Assim, para o exemplo anterior, o tempo de resposta ser√° o seguinte: A = 0, B = 0, B = 10 (abg = 3,33). <br><br>  E acontece que o algoritmo STCF n√£o √© t√£o bom em uma situa√ß√£o em que tr√™s tarefas chegam ao mesmo tempo - ele ter√° que esperar at√© que as pequenas tarefas sejam completamente conclu√≠das.  Portanto, o algoritmo √© bom para a m√©trica de tempo de resposta, mas ruim para a m√©trica de interatividade.  Imagine sentado no terminal, na tentativa de digitar caracteres no editor, voc√™ teria que esperar mais de 10 segundos, porque alguma outra tarefa √© ocupada pelo processador.  Isso n√£o √© muito agrad√°vel. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bed/aed/2e2/bedaed2e2491a426eb3fe137ed5b467e.jpg" alt="imagem"><br><br>  Portanto, estamos diante de outro problema - como podemos criar um agendador sens√≠vel ao tempo de resposta? <br><br><h3>  Pisco de peito vermelho redondo </h3><br>  Para resolver esse problema, o algoritmo <b>Round Robin</b> (RR) foi desenvolvido.  A id√©ia b√°sica √© bastante simples: em vez de iniciar tarefas at√© a conclus√£o, iniciaremos a tarefa por um determinado per√≠odo de tempo (chamado quantum de tempo) e, em seguida, mudaremos para outra tarefa da fila.  O algoritmo repete seu trabalho at√© que todas as tarefas sejam conclu√≠das.  Nesse caso, o tempo de execu√ß√£o do programa deve ser m√∫ltiplo do tempo ap√≥s o qual o timer interrompe o processo.  Por exemplo, se o cron√¥metro interromper o processo a cada x = 10ms, o tamanho da janela de execu√ß√£o do processo deve ser um m√∫ltiplo de 10 e ser 10,20 ou x * 10. <br><br>  Vejamos um exemplo: as tarefas do ABV chegam simultaneamente ao sistema e cada uma delas deseja trabalhar por 5 segundos.  O algoritmo SJF concluir√° cada tarefa at√© o fim antes de iniciar outra.  Por outro lado, o algoritmo RR com a janela de inicializa√ß√£o = 1s executar√° as tarefas da seguinte maneira (Fig. 4.3): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bed/aed/2e2/bedaed2e2491a426eb3fe137ed5b467e.jpg" alt="imagem"><br>  <i>(SJF novamente (ruim para o tempo de resposta)</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e40/351/12e/e4035112ea5d27958b0e099ed19a6c41.jpg" alt="imagem"><br>  <i>(Round Robin (bom para tempo de resposta)</i> <br><br>  O tempo m√©dio de resposta para o algoritmo √© RR (0 + 1 + 2) / 3 = 1, enquanto para SJF (0 + 5 + 10) / 3 = 5. <br><br>  √â l√≥gico supor que a janela de tempo √© um par√¢metro muito importante para RR, quanto menor, maior o tempo de resposta.  No entanto, voc√™ n√£o pode torn√°-lo muito pequeno, porque o tempo para mudar de contexto tamb√©m desempenhar√° um papel no desempenho geral.  Portanto, o tempo da janela de execu√ß√£o √© definido pelo arquiteto do SO e depende das tarefas planejadas para serem executadas nele.  Mudar o contexto n√£o √© a √∫nica opera√ß√£o de servi√ßo que gasta tempo - o programa em execu√ß√£o opera com muito mais, por exemplo, v√°rios caches, e cada vez √© necess√°rio salvar e restaurar esse ambiente, o que tamb√©m pode levar muito tempo. <br><br>  O RR √© um √≥timo planejador se for apenas uma m√©trica de tempo de resposta.  Mas como a m√©trica do tempo de resposta da tarefa se comportar√° com esse algoritmo?  Considere o exemplo acima, quando o tempo de opera√ß√£o A, B, C = 5s e chegar ao mesmo tempo.  A tarefa A terminar√° em 13, B em 14, C em 15s e o tempo m√©dio de resposta ser√° de 14s.  Portanto, o RR √© o pior algoritmo para m√©tricas de rotatividade. <br><br>  De maneira mais geral, qualquer algoritmo como o RR √© honesto, divide o tempo gasto na CPU igualmente entre todos os processos.  E assim, essas m√©tricas conflitam constantemente entre si. <br><br>  Assim, temos v√°rios algoritmos opostos e, ao mesmo tempo, v√°rias suposi√ß√µes permanecem - que o tempo da tarefa √© conhecido e que a tarefa usa apenas a CPU. <br><br><h3>  Misturando com E / S </h3><br>  Primeiro, removemos a suposi√ß√£o 4 de que o processo usa apenas a CPU, √© claro que n√£o √© assim, e os processos podem se voltar para outros equipamentos. <br><br>  No momento em que um processo solicita uma opera√ß√£o de E / S, o processo entra em um estado bloqueado, aguardando a conclus√£o da E / S.  Se a E / S for enviada para o disco r√≠gido, essa opera√ß√£o poder√° demorar v√°rios ms ou mais e o processador ficar√° inativo nesse momento.  No momento, o agendador pode assumir o controle do processador por qualquer outro processo.  A pr√≥xima decis√£o que o planejador ter√° que tomar √© quando o processo concluir sua E / S.  Quando isso acontece, ocorre uma interrup√ß√£o e o sistema operacional coloca o processo de chamada de E / S no estado pronto. <br><br>  Considere um exemplo de v√°rias tarefas.  Cada um deles precisa de 50ms de tempo do processador.  No entanto, o primeiro acessar√° a E / S a cada 10ms (que tamb√©m ser√° executado por 10ms).  E o processo B simplesmente usa um processador de 50ms sem E / S. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/50a/488/cae/50a488cae4476f65002df9ea966f9ef7.jpg" alt="imagem"><br><br>  Neste exemplo, usaremos o planejador STCF.  Como o agendador se comporta se voc√™ executa um processo como A nele?  Ele proceder√° da seguinte maneira - primeiro processe totalmente A e depois o processo B. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/151/f5e/326/151f5e326437859d65d29541dbe0e94f.jpg" alt="imagem"><br><br>  A abordagem tradicional para resolver esse problema √© interpretar cada subtarefa de 10 ms do processo A como uma tarefa separada.  Assim, ao iniciar com o algoritmo STJF, a escolha entre uma tarefa de 50 ms e uma tarefa de 10 ms √© √≥bvia.  Em seguida, quando a subtarefa A for conclu√≠da, o processo B e a E / S ser√£o iniciados.  Ap√≥s a conclus√£o da E / S, ser√° habitual iniciar o processo A de 10 ms novamente em vez do processo B. Portanto, √© poss√≠vel realizar sobreposi√ß√£o quando a CPU for usada por outro processo enquanto o primeiro estiver aguardando a E / S.  E, como resultado, o sistema √© melhor utilizado - no momento em que processos interativos aguardam E / S, outros processos podem ser executados no processador. <br><br><h3>  Oracle n√£o √© mais </h3><br>  Agora vamos tentar nos livrar da suposi√ß√£o de que a hora da tarefa √© conhecida.  Essa √© geralmente a pior e mais irrealista suposi√ß√£o de toda a lista.  De fato, em sistemas operacionais padr√£o comuns, o sistema operacional em si geralmente sabe muito pouco sobre o tempo necess√°rio para concluir as tarefas, ent√£o como voc√™ pode criar um agendador sem saber quanto tempo a tarefa levar√°?  Talvez possamos usar alguns dos princ√≠pios do RR para resolver esse problema? <br><br><h3>  Sum√°rio </h3><br>  Examinamos as id√©ias b√°sicas do planejamento de tarefas e revisamos duas fam√≠lias de planejadores.  O primeiro inicia a tarefa mais curta no in√≠cio e, portanto, aumenta o tempo de resposta, o segundo √© dividido entre todas as tarefas igualmente, aumentando o tempo de resposta.  Ambos os algoritmos s√£o ruins, enquanto outros da fam√≠lia s√£o bons.  Tamb√©m vimos como o uso paralelo da CPU e da E / S pode melhorar o desempenho, mas n√£o resolvemos o problema com a clarivid√™ncia do sistema operacional.  E na pr√≥xima li√ß√£o, consideraremos um planejador que olha para o passado pr√≥ximo e tenta prever o futuro.  E isso √© chamado de fila de feedback de v√°rios n√≠veis. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt449026/">https://habr.com/ru/post/pt449026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt449014/index.html">Advance Ethereum DAPP</a></li>
<li><a href="../pt449016/index.html">Esteganografia no sistema de arquivos de disco √≥ptico</a></li>
<li><a href="../pt449020/index.html">Analisando o c√≥digo da plataforma CUBA com o PVS-Studio</a></li>
<li><a href="../pt449022/index.html">An√°lise de c√≥digo da plataforma CUBA usando o PVS-Studio</a></li>
<li><a href="../pt449024/index.html">"O Segredo do Terceiro Planeta" com gr√°ficos aprimorados de redes neurais</a></li>
<li><a href="../pt449028/index.html">Raiva, barganha e depress√£o ao trabalhar com o InfluxDB</a></li>
<li><a href="../pt449032/index.html">Projetamos um sistema de extin√ß√£o de inc√™ndios por aspers√£o</a></li>
<li><a href="../pt449034/index.html">Citymobil - um manual para melhorar a disponibilidade em meio ao crescimento dos neg√≥cios para startups. Parte 1</a></li>
<li><a href="../pt449036/index.html">E novamente o lobo em pele de cordeiro</a></li>
<li><a href="../pt449038/index.html">Gerenciando cont√™ineres do Docker no Go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>