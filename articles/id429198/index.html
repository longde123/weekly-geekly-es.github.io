<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚡 ❕ 🌊 Kerangka Kernel-Bridge: Jembatan di Ring0 🎡 👨🏻‍🏫 🏌️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pernahkah Anda ingin melihat di bawah kap sistem operasi, melihat struktur internal mekanismenya, memutar sekrup dan melihat peluang yang telah terbuk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kerangka Kernel-Bridge: Jembatan di Ring0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429198/">  Pernahkah Anda ingin melihat di bawah kap sistem operasi, melihat struktur internal mekanismenya, memutar sekrup dan melihat peluang yang telah terbuka?  Mungkin mereka bahkan ingin bekerja secara langsung dengan perangkat keras, tetapi mengira drivernya adalah rocketscience? <br><br>  Saya mengusulkan untuk berjalan di sepanjang jembatan ke inti dan melihat seberapa dalam lubang kelinci itu. <br><br>  Jadi, saya menyajikan kerangka kerja driver untuk peretasan kernel, yang ditulis dalam C ++ 17, dan dirancang, jika mungkin, untuk menghilangkan hambatan antara mode kernel dan pengguna atau untuk memuluskan kehadiran mereka sebanyak mungkin.  Dan juga, satu set mode pengguna dan API kernel dan pembungkus untuk pengembangan cepat dan nyaman di Ring0 untuk pemula dan pemrogram tingkat lanjut. <br><br>  Fitur utama: <br><br><ul><li>  Akses ke port I / O, serta instruksi penerusan <i>masuk</i> , <i>keluar</i> , <i>cli</i> dan <i>sti</i> ke mode pengguna melalui IOPL </li><li>  Membungkus Sistem Tweeter </li><li>  Akses <i>MSR</i> (Register Khusus Model) </li><li> Serangkaian fungsi untuk mengakses memori mode pengguna dari proses lain dan memori kernel </li><li>  Bekerja dengan memori fisik, <i>DMI / SMBIOS</i> </li><li>  Pembuatan mode pengguna dan aliran nuklir, pengiriman APC </li><li>  Mode pengguna <i>Ob ***</i> dan <i>Ps ***</i> callback dan filter sistem file </li><li>  Unduh pustaka driver dan kernel yang tidak ditandatangani </li></ul><br>  ... dan banyak lagi. <br><a name="habracut"></a><br>  Dan kita akan mulai dengan memuat dan menghubungkan kerangka kerja ke proyek C ++ kami. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Github</b></a> <br><br>  Untuk perakitan, sangat disarankan untuk menggunakan Visual Studio versi terbaru dan WDK (Windows Driver Kit) terbaru yang tersedia, yang dapat diunduh dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web resmi Microsoft</a> . <br><br>  Untuk pengujian, VMware Player gratis dengan Windows terpasang, tidak lebih rendah dari Windows 7, dengan kapasitas berapa pun sempurna. <br><br>  Majelis itu sepele dan tidak akan menimbulkan pertanyaan: <br><br><ol><li>  Buka <i>Kernel-Bridge.sln</i> </li><li>  Pilih kedalaman bit yang diperlukan </li><li>  Ctrl + Shift + B </li></ol><br>  Sebagai hasilnya, kami mendapatkan driver, pustaka mode pengguna, serta file utilitas terkait ( <i>* .inf</i> untuk instalasi manual, <i>* .cab</i> untuk menandatangani driver pada Penerbit Sertifikasi Perangkat Keras Microsoft, dll.). <br><br>  Untuk menginstal driver (jika tidak ada tanda tangan digital yang diperlukan untuk x64 - sertifikat EV yang sesuai), Anda perlu memasukkan sistem ke mode uji coba, mengabaikan tanda tangan digital driver.  Untuk melakukan ini, jalankan baris perintah sebagai administrator: <br><br> <code>bcdedit.exe /set loadoptions DISABLE_INTEGRITY_CHECKS <br> bcdedit.exe /set TESTSIGNING ON <br></code> <br>  ... dan reboot mesin.  Jika semuanya dilakukan dengan benar, sebuah tulisan akan muncul di sudut kanan bawah Windows dalam mode uji. <br><br>  Menyiapkan lingkungan pengujian selesai, mari kita mulai menggunakan API di proyek kami. <br><br>  Kerangka kerja memiliki hierarki berikut: <br><br>  <i>/ Kernel-Bridge / API</i> - satu set fungsi untuk digunakan dalam driver dan modul <i>kernel</i> , tidak memiliki dependensi eksternal dan dapat digunakan secara bebas dalam proyek pihak ketiga <br>  <i>/ User-Bridge / API</i> - satu set pembungkus mode pengguna di atas fungsi driver dan utilitas untuk bekerja dengan file-PE, karakter-PDB, dll. <br>  <i>/ SharedTypes /</i> - baik mode pengguna dan header nuklir berisi jenis umum yang diperlukan <br><br>  Driver dapat dimuat dalam dua cara: sebagai driver biasa dan sebagai minifilter.  Metode kedua lebih disukai, karena  memberikan akses ke fungsi lanjutan dari filter dan panggilan balik mode pengguna untuk peristiwa sistem. <br><br>  Jadi, buat proyek konsol di C ++, sambungkan file header yang diperlukan dan muat driver: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Windows.h&gt; #include "WdkTypes.h" //    x32/x64    WDK #include "CtlTypes.h" //   IOCTL-   #include "User-Bridge.h" // API,   int main() { using namespace KbLoader; BOOL Status = KbLoadAsFilter( L"X:\\Folder\\Path\\To\\Kernel-Bridge.sys", L"260000" //       ); if (!Status) return 0; //   ! //     API ... // : KbUnload(); return 0; }</span></span></span></span></code> </pre><br>  Hebat!  Sekarang kita dapat menggunakan API dan berinteraksi dengan kernel. <br>  Mari kita mulai dengan fungsi paling populer di lingkungan pengembang cheat - membaca dan menulis memori dari proses lain: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Processes::MemoryManagement; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Size = <span class="hljs-number"><span class="hljs-number">64</span></span>; BYTE Buffer[Size] = {}; BOOL Status = KbReadProcessMemory( <span class="hljs-comment"><span class="hljs-comment">//  KbWriteProcessMemory,   ProcessId, 0x7FFF0000, //     ProcessId &amp;Buffer, Size );</span></span></code> </pre><br>  Tidak ada yang rumit!  Mari kita turun satu tingkat - membaca dan menulis memori nuklir: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> VirtualMemory; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Size = <span class="hljs-number"><span class="hljs-number">64</span></span>; BYTE Buffer[Size]; <span class="hljs-comment"><span class="hljs-comment">//  "",  ""    , //       : BOOL Status = KbCopyMoveMemory( reinterpret_cast&lt;WdkTypes::PVOID&gt;(Buffer), //  0xFFFFF80000C00000, //  Size, FALSE //  ,     );</span></span></code> </pre><br>  Bagaimana dengan fungsi untuk berinteraksi dengan besi?  Misalnya, port I / O. <br><br>  Kami akan meneruskannya ke mode pengguna dengan memiringkan 2 bit IOPL dalam register EFlags, yang bertanggung jawab atas tingkat privilege di mana instruksi <i>in</i> / <i>out</i> / <i>cli</i> / <i>sti</i> tersedia. <br><br>  Dengan demikian, kita akan dapat menjalankannya dalam mode pengguna tanpa kesalahan Instruksi Privileged: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;intrin.h&gt; using namespace IO::Iopl; //  ,   ! KbRaiseIopl(); //  in/out/cli/sti   ! ULONG Frequency = 1000; // 1 kHz ULONG Divider = 1193182 / Frequency; __outbyte(0x43, 0xB6); //     //      : __outbyte(0x42, static_cast&lt;unsigned char&gt;(Divider)); __outbyte(0x42, static_cast&lt;unsigned char&gt;(Divider &gt;&gt; 8)); __outbyte(0x61, __inbyte(0x61) | 3); //   (   ) for (int i = 0; i &lt; 5000; i++); //   Sleep(),  IOPL      ! __outbyte(0x61, __inbyte(0x61) &amp; 252); //   KbResetIopl();</span></span></span></span></code> </pre><br>  Tetapi bagaimana dengan kebebasan sejati?  Lagi pula, orang sering ingin mengeksekusi kode arbitrer dengan hak istimewa kernel.  Kami menulis semua kode kernel dalam mode pengguna dan mentransfer kontrol ke sana dari kernel (SMEP dimatikan secara otomatis, sebelum memanggil driver menyimpan konteks FPU dan panggilan itu sendiri terjadi di dalam blok <i>try..except</i> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> KernelShells; <span class="hljs-comment"><span class="hljs-comment">//    KeStallExecutionProcessor: ULONG Result = 1337; KbExecuteShellCode( []( _GetKernelProcAddress GetKernelProcAddress, PVOID Argument ) -&gt; ULONG { //      Ring0 //     : using _KeStallExecutionProcessor = VOID(WINAPI*)(ULONG Microseconds); auto Stall = reinterpret_cast&lt;_KeStallExecutionProcessor&gt;( GetKernelProcAddress(L"KeStallExecutionProcessor") ); Stall(1000 * 1000); //      ULONG Value = *static_cast&lt;PULONG&gt;(Argument); return Value == 1337 ? 0x1EE7C0DE : 0; }, &amp;Result, // Argument &amp;Result // Result ); //   Result = 0x1EE7C0DE</span></span></code> </pre><br>  Tapi selain memanjakan kerang, ada juga fungsi serius yang memungkinkan Anda untuk membuat DLP sederhana berdasarkan subsistem file, objek dan filter proses. <br><br>  Kerangka kerja ini memungkinkan pemfilteran <i>CreateFile</i> / <i>ReadFile</i> / <i>WriteFile</i> / <i>DeviceIoControl</i> , serta acara pembukaan / duplikasi pegangan ( <i>ObRegisterCallbacks</i> ) dan acara memulai proses / utas dan memuat modul ( <i>PsSet *** NotifyRoutine</i> ).  Ini akan memungkinkan, misalnya, untuk memblokir akses ke file sewenang-wenang atau untuk mengganti informasi tentang nomor seri hard disk. <br><br>  Prinsip kerja: <br><br><ol><li>  Pengemudi mendaftarkan filter file dan menginstal panggilan balik <i>Ob ***</i> / <i>Ps ***</i> </li><li>  Pengemudi membuka port <i>Komunikasi di</i> mana klien ingin berlangganan ke acara terhubung </li><li>  Aplikasi mode pengguna melampirkan ke port dan menerima data dari driver tentang peristiwa yang terjadi, melakukan pemfilteran (memotong hak dalam menangani, memblokir akses ke file, dll) dan mengembalikan acara ke kernel </li><li>  Pengemudi menerapkan perubahan yang diterima. </li></ol><br>  Contoh berlangganan <i>ObRegisterCallbacks</i> dan memotong akses ke proses saat ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Windows.h&gt; #include &lt;fltUser.h&gt; #include "CommPort.h" #include "WdkTypes.h" #include "FltTypes.h" #include "Flt-Bridge.h" ... //   ObRegisterCallbacks: CommPortListener&lt;KB_FLT_OB_CALLBACK_INFO, KbObCallbacks&gt; ObCallbacks; //        PROCESS_VM_READ: Status = ObCallbacks.Subscribe([]( CommPort&amp; Port, MessagePacket&lt;KB_FLT_OB_CALLBACK_INFO&gt;&amp; Message ) -&gt; VOID { auto Data = static_cast&lt;PKB_FLT_OB_CALLBACK_INFO&gt;(Message.GetData()); if (Data-&gt;Target.ProcessId == GetCurrentProcessId()) { Data-&gt;CreateResultAccess &amp;= ~PROCESS_VM_READ; Data-&gt;DuplicateResultAccess &amp;= ~PROCESS_VM_READ; } ReplyPacket&lt;KB_FLT_OB_CALLBACK_INFO&gt; Reply(Message, ERROR_SUCCESS, *Data); Port.Reply(Reply); //   });</span></span></span></span></code> </pre><br>  Jadi, kami secara singkat membahas poin-poin utama dari bagian mode pengguna kerangka kerja, tetapi API inti tetap ada di belakang layar. <br><br>  Semua API dan pembungkus terletak di folder yang sesuai: <i>/ Kernel-Bridge / API /</i> <br>  Mereka termasuk bekerja dengan memori, dengan proses, dengan string dan kunci, dan banyak lagi, sangat menyederhanakan pengembangan driver mereka sendiri.  API dan pembungkus hanya bergantung pada diri mereka sendiri dan tidak bergantung pada lingkungan eksternal: Anda dapat dengan bebas menggunakannya dalam driver Anda sendiri. <br><br>  Contoh bekerja dengan string di kernel adalah batu sandungan bagi semua pemula: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wdm.h&gt; #include &lt;ntstrsafe.h&gt; #include &lt;stdarg.h&gt; #include "StringsAPI.h" WideString wString = L"Some string"; AnsiString aString = wString.GetAnsi().GetLowerCase() + " and another string!"; if (aString.Matches("*another*")) DbgPrint("%s\r\n", aString.GetData());</span></span></span></span></code> </pre><br>  Jika Anda ingin menerapkan handler Anda sendiri untuk kode IOCTL Anda, Anda dapat dengan mudah melakukan ini sesuai dengan skema berikut: <br><br><ol><li>  Tulis handler di <i>/Kernel-Bridge/Kernel-Bridge/IOCTLHandlers.cpp</i> </li><li>  Dalam file yang sama, tambahkan handler ke akhir array <i>Handlers</i> dalam fungsi <i>DispatchIOCTL</i> </li><li>  Tambahkan indeks permintaan ke <i>enumerasi Ctls :: KbCtlIndices</i> di <i>CtlTypes.h</i> dalam POSISI SAMA seperti dalam array <i>Penangan</i> dalam item 2 </li><li>  Panggil handler Anda dari mode pengguna dengan menulis pembungkus di <i>User-Bridge.cpp</i> , melakukan panggilan menggunakan fungsi <i>KbSendRequest</i> </li></ol><br>  Ketiga jenis I / O didukung (METHOD_BUFFERED, METHOD_NEITHER dan METHOD_IN_DIRECT / METHOD_OUT_DIRECT), secara default, METHOD_NEITHER digunakan. <br><br>  Itu saja!  Artikel ini hanya mencakup sebagian kecil dari semua kemungkinan.  Saya harap framework ini akan bermanfaat bagi pengembang pemula dari komponen kernel, reverse engineer, pengembang cheat, anti-cheat dan perlindungan. <br><br>  Dan juga, semua orang diundang untuk mengambil bagian dalam pengembangan.  Dalam rencana masa depan: <br><br><ul><li>  Pembungkus untuk manipulasi langsung catatan PTE dan penerusan memori nuklir ke mode pengguna </li><li>  Injector berdasarkan pada fitur pembuatan dan pengiriman aliran APC yang ada </li><li>  Platform GUI untuk live reverse engineering dan riset kernel Windows </li><li>  Mesin skrip untuk mengeksekusi potongan kode kernel </li><li>  Dukungan untuk SEH dalam modul yang dimuat secara dinamis </li><li>  Lulus tes HLK </li></ul><br>  Terima kasih atas perhatian anda! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429198/">https://habr.com/ru/post/id429198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429188/index.html">Gambaran umum PICASO 3D Designer XL</a></li>
<li><a href="../id429190/index.html">Membuat implan sendiri untuk elektronik</a></li>
<li><a href="../id429192/index.html">Trik baru ini masih mampu mengakali video Deepfake.</a></li>
<li><a href="../id429194/index.html">7 perpustakaan untuk pengembangan Android di Kotlin</a></li>
<li><a href="../id429196/index.html">Eksplorasi seluler runtime iOS dengan Keberatan, atau Retas aplikasi kita sendiri</a></li>
<li><a href="../id429202/index.html">Kursus mahal: apakah itu layak?</a></li>
<li><a href="../id429204/index.html">Kesalahpahaman paling penting tentang pengembangan game</a></li>
<li><a href="../id429210/index.html">Kenyataan pahit: pemangku kepentingan Anda tidak menginginkan analisis bisnis</a></li>
<li><a href="../id429212/index.html">Microsoft mengonfirmasi keberadaan (massa) masalah dengan aktivasi Windows 10</a></li>
<li><a href="../id429214/index.html">Fitur Middleware dan Pipeline di Laravel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>