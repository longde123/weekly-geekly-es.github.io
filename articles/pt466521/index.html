<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé∞ üòì ‚¨úÔ∏è C for Metal - metal precioso para computa√ß√£o em placas gr√°ficas Intel üçµ üîí üëë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quantos n√∫cleos de processador Intel voc√™ possui no seu computador? Se voc√™ usa um sistema baseado na Intel, na grande maioria dos casos, precisar√° ad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C for Metal - metal precioso para computa√ß√£o em placas gr√°ficas Intel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intel/blog/466521/">  Quantos n√∫cleos de processador Intel voc√™ possui no seu computador?  Se voc√™ usa um sistema baseado na Intel, na grande maioria dos casos, precisar√° adicionar um √† sua resposta.  A composi√ß√£o de quase todos os processadores Intel - do Atom ao Xeon E3, √© claro, sem perder o Core, j√° h√° muitos anos inclui o n√∫cleo gr√°fico integrado Intel Graphics, que √© essencialmente um processador completo e, portanto, capaz de n√£o apenas mostrar fotos na tela e acelerar o v√≠deo, mas tamb√©m realize c√°lculos de uso geral "comuns".  Como isso pode ser usado efetivamente?  Olhe por baixo do corte. <br><br><img src="https://habrastorage.org/webt/od/zy/qg/odzyqgwdoyvgvhlbsvulnty_doo.jpeg"><br><a name="habracut"></a><br>  Primeiro, explicaremos brevemente por que vale a pena confiar em uma GPU Intel.  Obviamente, o desempenho da CPU no sistema quase sempre excede significativamente a GPU, por isso tamb√©m √© o Processador Central. <br><br>  Mas √© interessante notar que o desempenho das GPUs integradas da Intel na √∫ltima d√©cada cresceu muito mais do que o da CPU em termos percentuais, e essa tend√™ncia certamente continuar√° com o advento de novas placas gr√°ficas Intel discretas.  Al√©m disso, a GPU, em virtude de sua arquitetura (muitos dispositivos de execu√ß√£o de vetores), √© muito mais adequada para a execu√ß√£o de um certo tipo de tarefas - o processamento de imagens, que √©, de fato, realizar quaisquer opera√ß√µes do mesmo tipo em matrizes de dados.  A GPU faz isso com total paraleliza√ß√£o interna, gasta menos energia do que a CPU e, em alguns casos, at√© supera em velocidade absoluta.  Finalmente, a GPU e a CPU podem trabalhar em paralelo, cada uma em suas pr√≥prias tarefas, fornecendo desempenho m√°ximo e / ou consumo m√≠nimo de energia de todo o sistema. <br><br>  Ok, Intel.  Decidimos usar a GPU Intel para c√°lculos de uso geral, como fazer isso? <br>  - A maneira mais simples que n√£o requer nenhum conhecimento especial em gr√°ficos (shaders Direct3D e OpenGL) √© o OpenCL. <br><br>  Os kernels OpenCL s√£o independentes de plataforma e ser√£o executados automaticamente em todos os dispositivos de computa√ß√£o dispon√≠veis no sistema - CPU, GPU, FPGA, etc.  Mas a taxa por essa versatilidade est√° longe do desempenho m√°ximo poss√≠vel em cada tipo de dispositivo, e especialmente na GPU Intel integrada.  Aqui podemos dar um exemplo: ao executar c√≥digo em qualquer GPU Intel que transponha uma matriz de 16x16 bytes, a vantagem de desempenho da programa√ß√£o direta da GPU Intel ser√° 8 vezes maior do que na vers√£o OpenCL! <br><br>  Al√©m disso, algumas das funcionalidades necess√°rias para implementar algoritmos comuns (por exemplo, "filtros amplos" que usam dados de um grande grupo de pixels em uma √∫nica transforma√ß√£o), o OpenCL simplesmente n√£o suporta. <br><br>  Portanto, se voc√™ precisar de velocidade m√°xima na GPU e / ou algo mais complicado do que trabalhar independentemente com cada elemento da matriz e seus vizinhos mais pr√≥ximos, o Intel C for Metal (ICM) o ajudar√° - uma ferramenta para o desenvolvimento de aplicativos em execu√ß√£o nos gr√°ficos Intel . <br><br><h2>  <font color="#0071c5">ICM - bem-vindo √† forja!</font> </h2><br>  Do ponto de vista de desempenho e funcionalidade, o ICM pode ser considerado "montador de placas gr√°ficas Intel" e, em termos de circuitos e usabilidade - "an√°logo do OpenCL para placas gr√°ficas Intel". <br><br>  Por muitos anos, o ICM tem sido usado internamente pela Intel no desenvolvimento de produtos de processamento de m√≠dia na GPU Intel.  Mas em 2018, o ICM foi lan√ßado ao p√∫blico, e mesmo com c√≥digo aberto! <br><br>  O Intel C for Metal ganhou seu nome atual h√° alguns meses, antes de ser chamado Intel C for Media (o mesmo acr√¥nimo ICM ou apenas CM ou mesmo Cm) e, ainda mais cedo - o Media Development Framework (MDF).  Portanto, se em algum lugar no nome do componente, na documenta√ß√£o ou nos coment√°rios de c√≥digo aberto, os nomes antigos se encontrarem - n√£o se assuste, esse √© um valor hist√≥rico. <br><br>  Portanto, o c√≥digo do aplicativo ICM, assim como no OpenCL, cont√©m duas partes: a ‚Äúadministrativa‚Äù, executada no processador, e o kernel, executado na GPU.  N√£o √© de surpreender que a primeira parte seja chamada de host e a segunda seja o kernel. <br><br>  Os kernels s√£o uma fun√ß√£o do processamento de um determinado bloco de pixels (ou apenas dados), s√£o escritos na linguagem Intel C for Metal e compilados no conjunto de instru√ß√µes da GPU Intel (ISA) usando o compilador ICM. <br><br>  O host √© uma esp√©cie de "gerenciador de equipe do kernel", administra o processo de transfer√™ncia de dados entre a CPU e a GPU e realiza outros "trabalhos gerenciais" por meio da biblioteca de tempo de execu√ß√£o do ICM Runtime e do driver de m√≠dia da GPU da Intel. <br>  Um fluxo de trabalho detalhado do ICM se parece com isso: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/a1/q4/ola1q4zotlteitoqxvmttsuulu0.png"></div><br><ul><li>  O c√≥digo do host ICM √© compilado por qualquer compilador x86 C / C ++ junto com o aplicativo inteiro; </li><li>  O c√≥digo do kernel do ICM √© compilado pelo compilador do ICM em um arquivo bin√°rio com algum conjunto de instru√ß√µes comum (ISA comum); </li><li>  Em tempo de execu√ß√£o, esse conjunto geral de instru√ß√µes JIT se traduz em uma GPU Intel espec√≠fica; </li><li>  O host ICM chama a biblioteca de tempo de execu√ß√£o ICM para se comunicar com a GPU e o sistema operacional. </li></ul><br>  Mais alguns pontos importantes e √∫teis: <br><br><ul><li>  As superf√≠cies usadas no ICM para representar / armazenar dados podem ser compartilhadas com o DirectX 11 e 9 (DXVA no Linux). </li><li>  A GPU pode pegar e gravar dados da mem√≥ria de v√≠deo e da mem√≥ria do sistema compartilhada com a CPU.  O ICM inclui fun√ß√µes especiais para ambos os casos de transfer√™ncia de dados em ambas as dire√ß√µes.  Ao mesmo tempo, a mem√≥ria do sistema √© exatamente compartilhada e a c√≥pia real n√£o √© necess√°ria - para isso, a chamada c√≥pia zero √© fornecida no ICM. </li></ul><br><h2>  <font color="#0071c5">ICM - na abertura do vulc√£o!</font> </h2><br>  J√° a partir do nome "C for Iron", o dispositivo de idioma corresponde ao dispositivo gr√°fico interno da Intel.  Ou seja, leva em considera√ß√£o o fato de que o c√≥digo ser√° executado em v√°rias dezenas de unidades de execu√ß√£o (Unidade de Execu√ß√£o) da placa de v√≠deo, cada uma delas um processador totalmente vetorial capaz de executar v√°rios threads simultaneamente. <br><br>  A linguagem ICM em si √© C ++ com algumas limita√ß√µes e extens√µes.  Comparado ao C ++, o ICM n√£o possui ... ponteiros, aloca√ß√£o de mem√≥ria e vari√°veis ‚Äã‚Äãest√°ticas.  Sob a proibi√ß√£o tamb√©m fun√ß√µes recursivas.  Mas h√° uma programa√ß√£o de modelo vetorial expl√≠cito (SIMD): tipos de dados vetoriais - vetor, matriz e superf√≠cie;  opera√ß√µes de vetor nesses tipos de dados, condi√ß√µes de vetor se / else, executadas independentemente para cada elemento do vetor;  bem como fun√ß√µes internas para acessar a funcionalidade fixa do hardware da GPU Intel. <br><br>  O trabalho com vetores, matrizes e superf√≠cies em tarefas reais √© facilitado por objetos de "subconjuntos" - a partir dos objetos b√°sicos correspondentes, voc√™ pode escolher apenas os blocos de "refer√™ncia" que lhe interessam ou, como um caso especial, elementos individuais por m√°scara. <br><br>  Por exemplo, vejamos o c√≥digo ICM que implementa um filtro linear - substituindo um valor <br>  Cores RGB de cada pixel por seu valor m√©dio e 8 vizinhos na imagem: <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/webt/0q/xk/of/0qxkofxlflf0p_pxmtzgvcd7aze.png"></td><td>  <b>I (x, y) = [I (x-1, y-1) + I (x-1, y) + I (x-1, y + 1) + I (x, y-1) +</b> <b><br></b>  <b>+ I (x, y) + I (x, y + 1) + I (x + 1, y-1) + I (x + 1, y) + I (x + 1, y + 1)] / 9</b> <br></td></tr></tbody></table></div><br>  Se as cores (dados) na matriz estiverem localizadas como <b>R8G8B8</b> , o c√°lculo com a divis√£o da imagem de entrada em blocos de 6x8 pixels (elementos de dados de 6x24 bytes) ser√° o seguinte: <br><br><pre><code class="cpp hljs">_<span class="hljs-function"><span class="hljs-function">GENX_MAIN_ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">linear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SurfaceIndex inBuf, SurfaceIndex outBuf, uint h_pos, uint v_pos)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    8x32 matrix&lt;uchar, 8, 32&gt; in; //   6x24 matrix&lt;uchar, 6, 24&gt; out; matrix&lt;float, 6, 24&gt; m; //    read(inBuf h_pos*24, v_pos*6, in); //    -  m = in.select&lt;6,1,24,1&gt;(1,3); m += in.select&lt;6,1,24,1&gt;(0,0); m += in.select&lt;6,1,24,1&gt;(0,3); m += in.select&lt;6,1,24,1&gt;(0,6); m += in.select&lt;6,1,24,1&gt;(1,0); m += in.select&lt;6,1,24,1&gt;(1,6); m += in.select&lt;6,1,24,1&gt;(2,0); m += in.select&lt;6,1,24,1&gt;(2,3); m += in.select&lt;6,1,24,1&gt;(2,6); //  -   9   * 0.111f; out = m * 0.111f; //   write(outBuf, h_pos*24, v_pos*6, out); }</span></span></code> </pre> <br><ul><li>  O tamanho das matrizes √© definido no formato &lt;tipo de dados, altura, largura&gt;; </li><li>  o <i>operador select &lt;v_size, v_stride, h_size, h_stride&gt; (i, j)</i> retorna a submatriz come√ßando com o elemento <i>(i, j)</i> , <i>v_size</i> mostra o n√∫mero de linhas selecionadas, <i>v_stride</i> - a dist√¢ncia entre as linhas selecionadas <i>h_size</i> - o n√∫mero de colunas selecionadas <i>h_size</i> - o n√∫mero de colunas selecionadas, <i>h_stride</i> - a dist√¢ncia entre elas . </li></ul><br>  Observe que o tamanho da matriz de entrada 8x32 √© escolhido porque, embora o bloco 8x30 seja algoritmicamente suficiente para calcular os valores de todos os pixels no bloco 6x24, o bloco de dados √© lido no ICM, n√£o em bytes, mas por elementos dword de 32 bits. <br><br>  O c√≥digo acima √©, de fato, um n√∫cleo completo do ICM.  Como mencionado, ele ser√° compilado pelo compilador ICM em dois est√°gios (pr√©-compila√ß√£o e tradu√ß√£o posterior do JIT).  O compilador ICM √© constru√≠do com base no LLVM e, se desejado, pode ser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estudado nas fontes e constru√≠do por voc√™</a> . <br><br>  Mas o que o host ICM faz?  Invoca as fun√ß√µes da biblioteca de tempo de execu√ß√£o do ICM Runtime que: <br><br><ul><li>  Crie, inicialize e exclua depois de usar o dispositivo GPU (CmDevice), bem como superf√≠cies contendo dados do usu√°rio usados ‚Äã‚Äãnos kernels (CmSurface); </li><li>  Trabalhar com kernels - fa√ßa o download dos arquivos <i>.isa</i> pr√©-compilados, prepare seus argumentos, indicando a parte dos dados com os quais cada kernel trabalhar√°; </li><li>  Crie e gerencie a fila de execu√ß√£o do kernel; </li><li>  Eles controlam a opera√ß√£o dos threads que executam cada kernel na GPU; </li><li>  Gerenciar eventos (CmEvent) - objetos de sincroniza√ß√£o da GPU e da CPU; </li><li>  Transfira dados entre a GPU e a CPU, ou melhor, entre o sistema e a mem√≥ria de v√≠deo; </li><li>  Relatar erros, medir o tempo de opera√ß√£o dos kernels. </li></ul><br>  O c√≥digo do host mais simples √© assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  CmDevice cm_result_check(::CreateCmDevice(p_cm_device, version)); //  hello_world_genx.isa std::string isa_code = isa::loadFile("hello_world_genx.isa"); //    isa  CmProgram CmProgram *p_program = nullptr; cm_result_check(p_cm_device-&gt;LoadProgram(const_cast&lt;char* &gt;(isa_code.data()),isa_code.size(), p_program)); //  hello_world . CmKernel *p_kernel = nullptr; cm_result_check(p_cm_device-&gt;CreateKernel(p_program, "hello_world", p_kernel)); //       CmKernel CmThreadSpace *p_thread_space = nullptr; cm_result_check(p_cm_device-&gt;CreateThreadSpace(thread_width, thread_height, p_thread_space)); //   . cm_result_check(p_kernel-&gt;SetKernelArg(0, sizeof(thread_width), &amp;thread_width)); //  CmTask ‚Äì      //         //     . CmTask *p_task = nullptr; cm_result_check(p_cm_device-&gt;CreateTask(p_task)); cm_result_check(p_task-&gt;AddKernel(p_kernel)); //   CmQueue *p_queue = nullptr; cm_result_check(p_cm_device-&gt;CreateQueue(p_queue)); //    GPU (    ). CmEvent *p_event = nullptr; cm_result_check(p_queue-&gt;Enqueue(p_task, p_event, p_thread_space)); //   . cm_result_check(p_event-&gt;WaitForTaskFinished());</span></span></code> </pre> <br>  Como voc√™ pode ver, n√£o h√° nada complicado em criar e usar kernels e um host.  Tudo √© simples! <br><br>  A √∫nica dificuldade a alertar para retornar ao mundo real: atualmente, na vers√£o publicamente dispon√≠vel do ICM, a √∫nica maneira de depurar kernels s√£o as mensagens printf.  Como us√°-los corretamente pode ser visto no exemplo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hello, World</a> . <br><br><h2>  <font color="#0071c5">ICM - n√£o metal pesado!</font> </h2><br>  Agora vamos ver como isso funciona na pr√°tica.  O ICM Developer Kit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">est√° dispon√≠vel para Windows e Linux e</a> , para ambos os sistemas operacionais, cont√©m os casos de uso do ICM Compiler, da documenta√ß√£o e do tutorial.  Uma descri√ß√£o detalhada desses exemplos de treinamento √© <a href="">baixada separadamente</a> . <br><br>  Para Linux, o pacote tamb√©m inclui um driver de m√≠dia no modo usu√°rio para VAAPI com uma biblioteca de tempo de execu√ß√£o ICM Runtime integrada.  Para Windows, o driver de gr√°ficos Intel usual para Windows funcionar√° com o ICM.  A biblioteca de tempo de execu√ß√£o do ICM Runtime est√° inclu√≠da no conjunto de DLL deste driver.  O pacote ICM inclui apenas o arquivo .lib do link para ele.  Se o driver estiver ausente no sistema por algum motivo, ele ser√° baixado do site da Intel e a opera√ß√£o correta do ICM nos drivers ser√° garantida, a partir da vers√£o 15.60 - 2017). <br><br>  O c√≥digo fonte dos componentes pode ser encontrado aqui: <br><br><ul><li>  Driver de m√≠dia Intel para VAAPI e Intel C para Media Runtime: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/intel/media-driver</a> </li><li>  Intel C para Media Compiler e exemplos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/intel/cm-compiler</a> </li><li>  Compilador de gr√°ficos da Intel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/intel/intel-graphics-compiler</a> </li></ul><br>  O conte√∫do adicional desta se√ß√£o se aplica exclusivamente ao Windows, mas os princ√≠pios gerais de trabalho com o ICM tamb√©m s√£o aplic√°veis ‚Äã‚Äãao Linux. <br><br>  Para o trabalho "regular" com o pacote ICM, voc√™ precisar√° do Visual Studio a partir de 2015 e do Cmake a partir da vers√£o 3.2.  Ao mesmo tempo, os arquivos de configura√ß√£o e script dos exemplos de treinamento foram projetados para o VS 2015. Para usar vers√µes mais recentes dos arquivos do VS, voc√™ precisar√° estudar e editar os caminhos dos componentes do VS. <br><br>  Ent√£o, conhecendo o ICM para Windows: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fa√ßa o download do arquivo</a> ; </li><li>  Descompacte-o; </li><li>  Iniciamos (preferencialmente na linha de comando do VS) o script de configura√ß√£o do ambiente setupenv.bat com tr√™s par√¢metros - a gera√ß√£o da GPU Intel (correspondente ao processador no qual a GPU est√° integrada, pode ser deixada por padr√£o: gen9), a plataforma de compila√ß√£o: x86 \ x64 e a vers√£o DirectX para compartilhando com o ICM: dx9 / dx11. </li></ul><br>  Depois disso, voc√™ pode simplesmente criar todos os exemplos de treinamento - na pasta de exemplos, o script <i>build_all.bat</i> far√° <i>isso</i> ou gerar√° projetos para o Microsoft Visual Studio - isso <i>criar√° o</i> script <i>create_vs.bat</i> com o nome de um exemplo espec√≠fico como par√¢metro. <br><br>  Como voc√™ pode ver, o aplicativo ICM ser√° um arquivo .exe com a parte do host e um arquivo .isa com a parte da GPU pr√©-compilada correspondente. <br><br>  V√°rios exemplos est√£o inclu√≠dos no pacote ICM - do Hello, World, mais simples, que mostra os princ√≠pios b√°sicos da opera√ß√£o do ICM, ao mais complicado - a implementa√ß√£o do algoritmo para encontrar o "fluxo m√°ximo - corte m√≠nimo" do gr√°fico (problema de corte m√≠nimo do fluxo m√°ximo) usado na segmenta√ß√£o e costura de imagens . <br><br>  Todos os estudos de caso do ICM est√£o bem documentados no c√≥digo e na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descri√ß√£o separada</a> j√° mencionada.  Recomenda-se mergulhar no ICM com precis√£o - estudando e executando exemplos sequencialmente e depois modificando-os para atender √†s suas necessidades. <br><br>  Para uma compreens√£o geral de todos os recursos existentes do ICM, √© altamente recomend√°vel que voc√™ estude a ‚Äúespecifica√ß√£o‚Äù - a descri√ß√£o do ICM <i>cmlangspec.html</i> na <i>pasta</i> <i>\ documents \ compiler \ html \ cmlangspec</i> . <br><br>  Em particular, descreve a API das fun√ß√µes ICM implementadas no hardware - acesso aos chamados sampler de textura (Sampler) - um mecanismo para filtrar imagens de diferentes formatos, bem como avaliar o movimento (estimativa de movimento) entre os quadros de v√≠deo e alguns recursos de an√°lise de v√≠deo. <br><br><h2>  <font color="#0071c5">ICM - ataque enquanto est√° quente!</font> </h2><br>  Falando sobre o desempenho dos aplicativos ICM, deve-se observar que os estudos de caso incluem a medi√ß√£o do tempo de seu trabalho, para execut√°-los no sistema de destino e compar√°-los com suas tarefas, voc√™ pode avaliar a adequa√ß√£o do uso do ICM para eles. <br><br>  E considera√ß√µes gerais sobre o desempenho do ICM s√£o bastante simples: <br><br><ul><li>  Ao descarregar c√°lculos em uma GPU, lembre-se da sobrecarga de transfer√™ncia de dados da CPU &lt;-&gt; GPU e sincroniza√ß√£o desses dispositivos.  Portanto, um exemplo como Hello, World n√£o √© um bom candidato para uma implementa√ß√£o de ICM.  Mas os algoritmos de vis√£o computacional, IA e qualquer processamento n√£o trivial de matrizes de dados, especialmente com uma altera√ß√£o na ordem desses dados no processo ou na sa√≠da, √© o que o ICM precisa. </li><li>  Al√©m disso, ao projetar um c√≥digo ICM, √© necess√°rio levar em considera√ß√£o o dispositivo interno da GPU, ou seja, √© recomend√°vel criar um n√∫mero suficiente (&gt; 1000) de threads da GPU e carreg√°-los todos com trabalho.  Nesse caso, √© uma boa id√©ia dividir as imagens para processamento em pequenos blocos.  Mas a maneira espec√≠fica de particionar, bem como a escolha de um algoritmo de processamento espec√≠fico para obter o m√°ximo desempenho, n√£o √© uma tarefa trivial.  No entanto, isso se aplica a qualquer maneira de trabalhar com qualquer GPU (e CPU). </li></ul><br>  Voc√™ tem c√≥digo OpenCL, mas seu desempenho n√£o lhe agrada?  Ou c√≥digo CUDA, mas voc√™ deseja trabalhar em um n√∫mero muito maior de plataformas?  Ent√£o vale a pena dar uma olhada no ICM. <br><br>  O ICM √© um produto vivo e em evolu√ß√£o.  Voc√™ pode participar de seu uso e desenvolvimento - os reposit√≥rios correspondentes no github est√£o aguardando seus commits.  Todas as informa√ß√µes necess√°rias para os dois processos est√£o neste artigo e nos arquivos leia-me no github.  E se algo estiver faltando, ele aparecer√° ap√≥s suas perguntas nos coment√°rios. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466521/">https://habr.com/ru/post/pt466521/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466505/index.html">YIMP - Painel de Controle para o Yii 2 no Bootstrap 4</a></li>
<li><a href="../pt466509/index.html">Um olhar para dentro: o processo do dispositivo para trabalhar e adapta√ß√£o no Google</a></li>
<li><a href="../pt466515/index.html">Entrevista O que um engenheiro deve esperar de trabalhar em uma startup europ√©ia, como s√£o feitas as entrevistas e √© dif√≠cil se adaptar</a></li>
<li><a href="../pt466517/index.html">Treinamento de localiza√ß√£o da Universidade de Washington</a></li>
<li><a href="../pt466519/index.html">An√°lise detalhada do AWS Lambda</a></li>
<li><a href="../pt466525/index.html">O que √© um layout de iPhone para PSD e como us√°-lo?</a></li>
<li><a href="../pt466527/index.html">Testando a funcionalidade do usu√°rio do site com objetos de p√°gina da Capybara</a></li>
<li><a href="../pt466529/index.html">Tipos de compila√ß√£o na JVM: expondo a sess√£o de magia negra</a></li>
<li><a href="../pt466533/index.html">Pastilda: resultados</a></li>
<li><a href="../pt466535/index.html">Repensando deepClone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>