<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™ğŸ¾ ğŸ›¢ï¸ ğŸ‘©ğŸ¿â€ğŸ« Tes publik: solusi untuk privasi dan skalabilitas dalam Ethereum ğŸ’‚ ğŸ“˜ ğŸ”‰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Blockchain adalah teknologi inovatif yang menjanjikan untuk meningkatkan banyak bidang kehidupan manusia. Ini mentransfer proses dan produk nyata ke r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tes publik: solusi untuk privasi dan skalabilitas dalam Ethereum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471096/">  <b>Blockchain</b> adalah teknologi inovatif yang menjanjikan untuk meningkatkan banyak bidang kehidupan manusia.  Ini mentransfer proses dan produk nyata ke ruang digital, memastikan kecepatan dan keandalan transaksi keuangan, mengurangi biaya mereka, dan juga memungkinkan Anda untuk membuat aplikasi DAPP modern menggunakan kontrak pintar dalam jaringan desentralisasi. <br><br>  Mengingat banyak keuntungan dan beragam penggunaan blockchain, mungkin aneh bahwa teknologi yang menjanjikan ini belum menembus semua sektor.  Masalahnya adalah bahwa blockchain modern yang terdesentralisasi tidak memiliki skalabilitas.  Ethereum memproses sekitar 20 transaksi per detik, yang tidak cukup untuk memenuhi kebutuhan bisnis yang dinamis saat ini.  Pada saat yang sama, perusahaan yang menggunakan teknologi blockchain tidak berani meninggalkan Ethereum karena tingkat perlindungan yang tinggi terhadap peretasan dan kegagalan jaringan. <br><br>  Untuk memastikan desentralisasi, keamanan, dan skalabilitas pada blockchain, sehingga menyelesaikan Skalabilitas Trilemma, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tim</a> pengembangan Opporty menciptakan Plasma Cash - rantai anak yang terdiri dari kontrak pintar dan jaringan pribadi berdasarkan Node.js, yang secara berkala memindahkan negara ke rantai akar ( Ethereum). <br><br><img src="https://habrastorage.org/webt/tc/kv/lg/tckvlgw0bbppuvkdlaght7jdwfa.jpeg"><br><a name="habracut"></a><br><h2>  Proses utama di Plasma Cash </h2><br>  <b>1.</b> Pengguna memanggil fungsi kontrak pintar `setoran`, mentransfer jumlah dalam ETH ke dalamnya, yang ingin dimasukkan ke dalam token Kas Plasma.  Fungsi kontrak pintar membuat token dan menghasilkan acara tentang hal itu. <br><br>  <b>2.</b> Node tunai Plasma yang dilanggankan pada peristiwa-peristiwa dalam kontrak pintar menerima peristiwa tentang penciptaan setoran dan menambahkan transaksi tentang pembuatan token ke kumpulan. <br><br>  <b>3.</b> Secara berkala, simpul Cash Plasma khusus mengambil semua transaksi dari kumpulan (hingga 1 juta) dan membentuk blok darinya, menghitung pohon Merkle dan, dengan demikian, hash.  Blok ini dikirim ke node lain untuk verifikasi.  Node memeriksa apakah hasle Merkle valid, apakah transaksi valid (misalnya, jika pengirim token adalah pemiliknya).  Setelah memverifikasi blok, node memanggil fungsi `submitBlock` dari kontrak pintar, yang menyimpan nomor dan hash Merkle dari blok dalam rantai jejak.  Kontrak yang cerdas menghasilkan acara tentang penambahan blok yang berhasil.  Transaksi dihapus dari kumpulan. <br><br>  <b>4.</b> Node yang menerima acara tentang penyerahan blok mulai menerapkan transaksi yang ditambahkan ke blok. <br><br>  <b>5.</b> Pada titik tertentu, pemilik (atau bukan pemilik) token ingin menariknya dari Plasma Cash.  Untuk melakukan ini, ia memanggil fungsi `startExit`, menyampaikan informasi tentang 2 transaksi terakhir pada token ke dalamnya, yang mengkonfirmasi bahwa ia adalah pemilik token.  Kontrak pintar, menggunakan hasle Merkle, memeriksa transaksi dalam blok dan mengirimkan token ke output, yang akan terjadi dalam dua minggu. <br><br>  <b>6.</b> Jika operasi penarikan token telah terjadi dengan pelanggaran (token dihabiskan setelah dimulainya prosedur penarikan atau token sudah menjadi orang asing sebelum penarikan), pemilik token dapat menyangkal penarikan dalam waktu dua minggu. <br><br><img src="https://habrastorage.org/webt/xm/hy/ks/xmhyksifhph5pfmw5ibsnoh_keq.jpeg"><br><br><h2>  Privasi dicapai dengan dua cara. </h2><br>  <b>1.</b> Rantai root tidak tahu apa-apa tentang transaksi yang dibentuk dan diteruskan di dalam rantai anak.  Informasi tetap mengenai siapa yang memulai dan menarik ETH ke / dari Plasma Cash. <br><br>  <b>2.</b> Rantai anak memungkinkan Anda untuk mengatur transaksi anonim menggunakan zk-SNARKs. <br><br><h2>  Tumpukan teknologi </h2><br><ul><li>  NodeJS </li><li>  Redis </li><li>  Ethereum </li><li>  Soild </li></ul><br><h2>  Pengujian </h2><br>  Ketika mengembangkan Plasma Cash, kami menguji kecepatan sistem dan mendapatkan hasil berikut: <br><br><ul><li>  hingga 35.000 transaksi per detik ditambahkan ke kumpulan; </li><li>  hingga 1.000.000 transaksi dapat disimpan di blok. </li></ul><br>  Pengujian dilakukan pada 3 server berikut: <br><br>  <i>1. Intel Core i7-6700 Quad-Core Skylake termasuk.</i>  <i>NVMe SSD - 512 GB, 64 GB DDR4 RAM</i> <br>  3 simpul Cash Plasma yang divalidasi dimunculkan. <br><br>  <i>2. AMD Ryzen 7 1700X Octa-Core "Summit Ridge" (Zen), SSD SATA - 500 GB, RAM DDR4 64 GB</i> <br>  Simpul ETH testop Ropsten dinaikkan. <br>  3 simpul Cash Plasma yang divalidasi dimunculkan. <br><br>  <i>3. Intel Core i9-9900K Octa-Core termasuk.</i>  <i>NVMe SSD - 1 TB, RAM DDR4 64 GB</i> <br>  1 Kirim Plasma Kas simpul dinaikkan. <br>  3 simpul Cash Plasma yang divalidasi dimunculkan. <br>  Tes diluncurkan untuk menambahkan transaksi ke jaringan Kas Plasma. <br><br>  <b>Total:</b> 10 Node tunai Plasma dalam jaringan pribadi. <br><br><h3>  Tes 1 </h3><br>  Ada batas 1 juta transaksi per blok.  Oleh karena itu, 1 juta transaksi terbagi dalam 2 blok (karena sistem berhasil mengambil bagian dari transaksi dan mengajukan sementara mereka dikirim). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VhJAtRlmXVE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Status awal: blok terakhir # 7;  1 juta transaksi dan token disimpan dalam basis data. <br><br>  00:00 - mulai skrip pembuatan transaksi <br>  01:37 - 1 juta transaksi telah dibuat dan pengiriman ke node dimulai <br>  01:46 - node kirim mengambil 240k transaksi dari pool dan membentuk blok # 8.  Kami juga melihat bahwa transaksi 320k ditambahkan ke kumpulan dalam 10 detik <br>  01:58 - blok # 8 ditandatangani dan dikirim untuk validasi <br>  02:03 - blok # 8 divalidasi dan fungsi `submitBlock` dari kontrak pintar dengan hash dan nomor blok Merkle disebut <br>  02:10 - skrip demo selesai bekerja, yang mengirim 1 juta transaksi dalam 32 detik <br>  02:33 - node mulai menerima informasi bahwa blok # 8 ditambahkan ke rantai root, dan mulai melakukan 240k transaksi <br>  02:40 - 240k transaksi dihapus dari kumpulan, yang sudah ada di blok # 8 <br>  02:56 - submit node mengambil sisa transaksi 760k dari pool dan mulai menghitung hash Merkle dan menandatangani blok # 9 <br>  03:20 - semua node berisi 1mln 240r transaksi dan token <br>  03:35 - blok # 9 ditandatangani dan dikirim untuk validasi ke node lain <br>  03:41 - kesalahan jaringan telah terjadi <br>  04:40 - oleh batas waktu, menunggu validasi blok # 9 telah berhenti <br>  04:54 - node kirim mengambil sisa transaksi 760k dari pool dan mulai menghitung hash Merkle dan menandatangani blok # 9 <br>  05:32 - blok # 9 ditandatangani dan dikirim untuk validasi ke node lain <br>  05:53 - blok # 9 divalidasi dan dikirim ke rantai root <br>  06:17 - node mulai menerima informasi bahwa blok # 9 ditambahkan ke rantai root dan mulai melakukan transaksi 760k <br>  06:47 - kumpulan dibersihkan dari transaksi yang ada di blok # 9 <br>  09:06 - semua node berisi 2 juta transaksi dan token <br><br><h3>  Tes 2 </h3><br>  Ada batas 350rb per blok.  Hasilnya, kami memiliki 3 blok. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4BNpSYkwRvE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Status awal: blok terakhir # 9;  2 juta transaksi dan token disimpan dalam database <br><br>  00:00 - skrip pembuatan transaksi sudah berjalan <br>  00:44 - 1 juta transaksi telah dibuat dan pengiriman ke node dimulai <br>  00:56 - node kirim mengambil 320k transaksi dari pool dan membentuk blok # 10.  Kami juga melihat bahwa transaksi 320k ditambahkan ke kumpulan dalam 10 detik <br>  01:12 - blok # 10 ditandatangani dan dikirim ke node lain untuk validasi <br>  01:18 - skrip demo selesai bekerja, yang mengirim 1 juta transaksi dalam 34 detik <br>  01:20 - blok # 10 divalidasi dan dikirim ke rantai root <br>  01:51 - semua node menerima informasi dari rantai root yang memblokir # 10 telah ditambahkan, dan mereka mulai menerapkan transaksi 320k <br>  02:01 - kumpulan itu dihapus untuk transaksi 320k yang ditambahkan ke blok # 10 <br>  02:15 - kirim node mengambil 350 ribu transaksi dari pool dan membentuk blok # 11 <br>  02:34 - blok # 11 ditandatangani dan dikirim ke node lain untuk validasi <br>  02:51 - blok # 11 divalidasi dan dikirim ke rantai root <br>  02:55 - simpul terakhir melakukan transaksi dari blok # 10 <br>  10:59 - waktu yang sangat lama dalam rantai root transaksi dieksekusi dengan pengiriman blok # 9, tetapi selesai dan semua node menerima informasi tentang ini dan mulai menjalankan 350k transaksi <br>  11:05 - kumpulan itu dihapus untuk transaksi 320k yang ditambahkan ke blok # 11 <br>  12:10 - semua node berisi 1 juta 670 ribu transaksi dan token <br>  12:17 - kirim node mengambil 330k transaksi dari pool dan membentuk blok # 12 <br>  12:32 - blok # 12 ditandatangani dan dikirim ke node lain untuk validasi <br>  12:39 - blok # 12 divalidasi dan dikirim ke rantai root <br>  13:44 - semua node menerima informasi dari rantai root yang memblokir # 12 telah ditambahkan dan mulai menerapkan transaksi 330k <br>  14:50 - semua node berisi 2 juta transaksi dan token <br><br><h3>  Tes 3 </h3><br>  Di server pertama dan kedua, satu simpul validasi diganti dengan simpul pengiriman. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/w5QHab3heIc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Status awal: blok terakhir # 84;  0 transaksi dan token disimpan dalam basis data <br><br>  00:00 - 3 skrip diluncurkan yang menghasilkan dan mengirim 1 juta transaksi <br>  01:38 - 1 juta transaksi telah dibuat dan pengiriman untuk mengirimkan simpul # 3 dimulai <br>  01:50 - kirim simpul # 3 mengambil 330k transaksi dari kumpulan dan membentuk blok # 85 (f21).  Kami juga melihat bahwa transaksi 350 ribu ditambahkan ke kumpulan dalam 10 detik <br>  01:53 - 1 juta transaksi telah dibuat dan pengiriman untuk mengirimkan simpul # 1 dimulai <br>  01:50 - kirim simpul # 3 mengambil 330k transaksi dari kumpulan dan membentuk blok # 85 (f21).  Kami juga melihat bahwa transaksi 350 ribu ditambahkan ke kumpulan dalam 10 detik <br>  02:01 - kirim node # 1 mengambil 250k transaksi dari pool dan membentuk blok # 85 (65e) <br>  02:06 - blok # 85 (f21) ditandatangani dan dikirim ke node lain untuk divalidasi <br>  02:08 - skrip demo server # 3 telah selesai berfungsi, yang mengirim transaksi 1mln dalam 30 detik <br>  02:14 - blok # 85 (f21) divalidasi dan dikirim ke rantai root <br>  02:19 - blok # 85 (65e) ditandatangani dan dikirim ke node lain untuk divalidasi <br>  02:22 - 1 juta transaksi telah dibuat dan pengiriman untuk mengirimkan simpul # 2 dimulai <br>  02:27 - blok # 85 (65e) divalidasi dan dikirim ke rantai root <br>  02:29 - kirimkan simpul # 2 dari transaksi pool 111855 dan bentuk blok # 85 (256). <br>  02:36 - blok # 85 (256) ditandatangani dan dikirim ke node lain untuk divalidasi <br>  02:36 - skrip demo server # 1 selesai bekerja, yang mengirim transaksi 1mln dalam 42,5 detik <br>  02:38 - blok # 85 (256) divalidasi dan dikirim ke rantai root <br>  03:08 - skrip server # 2, yang mengirim 1 juta transaksi dalam 47 detik, selesai bekerja <br>  03:38 - semua node menerima informasi dari rantai root bahwa blok # 85 (f21), # 86 (65e), # 87 (256) telah ditambahkan dan mulai menerapkan transaksi 330k, 250k, 111855 <br>  03:49 - kolam dibersihkan pada 330k, 250k, 111855 transaksi yang ditambahkan ke blok # 85 (f21), # 86 (65e), # 87 (256) <br>  03:59 - kirim simpul # 1 ambil dari pool 888145 transaksi dan bentuk blok # 88 (214), kirim simpul # 2 ambil dari pool 750k transaksi dan bentuk blok # 88 (50a), kirim simpul # 3 ambil dari pool 670k transaksi dan formulir blok # 88 (d3b) <br>  04:44 - blok # 88 (d3b) ditandatangani dan dikirim ke node lain untuk validasi <br>  04:58 - blok # 88 (214) ditandatangani dan dikirim ke node lain untuk divalidasi <br>  05:11 - blok # 88 (50a) ditandatangani dan dikirim ke node lain untuk validasi <br>  05:11 - blok # 85 (d3b) divalidasi dan dikirim ke rantai root <br>  05:36 - blok # 85 (214) divalidasi dan dikirim ke rantai root <br>  05:43 - semua node menerima informasi dari rantai root yang memblokir # 88 (d3b), # 89 (214) ditambahkan dan mulai menerapkan transaksi 670k, 750k <br>  06:50 - karena pemutusan, blok # 85 (50a) tidak divalidasi <br>  06:55 - kirim node # 2 mengambil 888145 transaksi dari pool dan membentuk blok # 90 (50a) <br>  08:14 - blok # 90 (50a) ditandatangani dan dikirim ke node lain untuk divalidasi <br>  09:04 - blok # 90 (50a) divalidasi dan dikirim ke rantai root <br>  11:23 - semua node menerima informasi dari rantai root yang memblokir # 90 (50a) ditambahkan, dan 888145 transaksi mulai diterapkan.  Pada saat yang sama, server # 3 telah lama menerapkan transaksi dari blok # 88 (d3b), # 89 (214) <br>  12:11 - semua kolam kosong <br>  13:41 - semua node server # 3 berisi 3 juta transaksi dan token <br>  14:35 - semua node server # 1 berisi 3 juta transaksi dan token <br>  19:24 - semua node server # 2 berisi 3 juta transaksi dan token <br><br><h2>  Rintangan </h2><br>  Selama pengembangan Plasma Cash, kami menghadapi masalah berikut, yang secara bertahap kami pecahkan dan selesaikan: <br><br>  <b>1.</b> Konflik interaksi berbagai fungsi sistem.  Misalnya, fungsi menambahkan transaksi ke kumpulan memblokir pengiriman dan validasi blok, dan sebaliknya, yang menyebabkan penurunan kecepatan. <br><br>  <b>2.</b> Tidak segera jelas cara mengirim sejumlah besar transaksi dan pada saat yang sama meminimalkan biaya transfer data. <br><br>  <b>3.</b> Tidak jelas bagaimana dan di mana menyimpan data untuk mencapai hasil yang tinggi. <br><br>  <b>4.</b> Tidak jelas bagaimana mengatur jaringan antar node, karena ukuran blok dengan 1 juta transaksi membutuhkan sekitar 100 MB. <br><br>  <b>5.</b> Bekerja dalam mode single-threaded memutus koneksi antara node ketika perhitungan panjang terjadi (misalnya, membangun pohon Merkle dan menghitung hash-nya). <br><br><h2>  Bagaimana kita menangani semua ini? </h2><br>  Versi pertama dari simpul Plasma Cash adalah sejenis gabungan yang dapat melakukan semuanya pada saat yang sama: menerima transaksi, mengirim dan memvalidasi blok, menyediakan API untuk mengakses data.  Karena NodeJS pada mulanya single-threaded, fungsi perhitungan Merkle tree yang berat memblokir fungsi add transaksi.  Kami melihat dua opsi untuk menyelesaikan masalah ini: <br><br>  <b>1.</b> Jalankan beberapa proses NodeJS, yang masing-masing menjalankan fungsi tertentu. <br><br>  <b>2.</b> Gunakan pekerja_lebar dan letakkan eksekusi kode ke utas. <br><br>  Sebagai hasilnya, kami menggunakan kedua opsi pada saat yang sama: secara logis membagi satu simpul menjadi 3 bagian, yang dapat bekerja secara terpisah, tetapi pada saat yang sama secara serempak <br><br>  <b>1.</b> Kirim simpul yang menerima transaksi ke kumpulan dan membuat blok. <br><br>  <b>2.</b> Memvalidasi node yang memverifikasi validitas node. <br><br>  <b>3.</b> Node API - menyediakan API untuk mengakses data. <br><br>  Pada saat yang sama, Anda dapat terhubung ke setiap node melalui soket unix menggunakan cli. <br><br>  Operasi berat, seperti perhitungan pohon Merkle, kami lakukan dalam aliran terpisah. <br><br>  Dengan demikian, kami mencapai operasi normal semua fungsi Cash Plasma secara bersamaan dan tanpa kegagalan. <br><br>  Segera setelah sistem berfungsi, kami mulai menguji kecepatan dan, sayangnya, mendapat hasil yang tidak memuaskan: 5.000 transaksi per detik dan hingga 50.000 transaksi dalam satu blok.  Saya harus mencari tahu apa yang diterapkan dengan tidak benar. <br><br>  Untuk mulai dengan, kami mulai menguji mekanisme komunikasi dengan Plasma Cash untuk mengetahui kemampuan puncak sistem.  Sebelumnya kami menulis bahwa simpul Plasma Cash menyediakan antarmuka soket unix.  Itu awalnya tekstual.  objek json dikirim menggunakan `JSON.parse ()` dan `JSON.stringify ()`. <br><br><pre><code class="plaintext hljs">```json { "action": "sendTransaction", "payload":{ "prevHash": "0x8a88cc4217745fd0b4eb161f6923235da10593be66b841d47da86b9cd95d93e0", "prevBlock": 41, "tokenId": "57570139642005649136210751546585740989890521125187435281313126554130572876445", "newOwner": "0x200eabe5b26e547446ae5821622892291632d4f4", "type": "pay", "data": "", "signature": "0xd1107d0c6df15e01e168e631a386363c72206cb75b233f8f3cf883134854967e1cd9b3306cc5c0ce58f0a7397ae9b2487501b56695fe3a3c90ec0f61c7ea4a721c" } } ```</code> </pre> <br>  Kami mengukur kecepatan transfer objek tersebut dan menerima ~ 130k per detik.  Mereka mencoba mengganti fungsi standar dengan json, tetapi kinerjanya tidak membaik.  Harus ada mesin V8 yang dioptimalkan dengan baik untuk operasi ini. <br><br>  Bekerja dengan transaksi, token, blok dilakukan melalui kelas.  Saat membuat kelas seperti itu, kinerja turun 2 kali lipat, yang menunjukkan: OOP tidak cocok untuk kita.  Saya harus menulis ulang semuanya dengan pendekatan fungsional murni. <br><br><h2>  Menulis ke basis data </h2><br>  Awalnya, Redis dipilih untuk penyimpanan data sebagai salah satu solusi paling produktif yang memenuhi persyaratan kami: penyimpanan nilai kunci, bekerja dengan tabel hash, dan banyak lagi.  Kami meluncurkan redis-benchmark dan mendapat ~ 80k operasi per detik dalam 1 mode pipelining. <br><br>  Untuk kinerja tinggi, kami menyetel Redis lebih halus: <br><br><ul><li>  Membuat koneksi soket unix. </li><li>  Nonaktifkan status penyimpanan ke disk (untuk keandalan, Anda dapat mengonfigurasi replika dan sudah menyimpan ke disk dalam Redis terpisah). </li></ul><br>  Di Redis, kumpulan adalah tabel hash, karena kita memerlukan kemampuan untuk menerima semua transaksi dalam satu permintaan dan menghapus transaksi satu per satu.  Kami mencoba menggunakan daftar reguler, tetapi ia bekerja lebih lambat ketika membongkar seluruh daftar. <br><br>  Menggunakan perpustakaan NodeJS standar, perpustakaan Redis mencapai 18k transaksi per kinerja kedua.  Kecepatan turun 9 kali. <br><br>  Karena tolok ukur menunjukkan kepada kami kemungkinan dengan jelas 5 kali lebih banyak, mereka mulai mengoptimalkan.  Kami mengubah perpustakaan menjadi ioredis dan mendapatkan kinerja 25k per detik.  Kami menambahkan transaksi satu per satu menggunakan perintah `hset`.  Jadi, kami menghasilkan banyak permintaan di Redis.  Ada ide untuk menggabungkan transaksi menjadi bundel dan mengirimkannya dengan satu perintah hmset.  Hasilnya adalah 32rb per detik. <br><br>  Karena beberapa alasan, yang akan dijelaskan di bawah ini, kami bekerja dengan data menggunakan `Buffer` dan, ternyata, jika Anda menerjemahkannya ke dalam teks (` buffer.toString ('hex') `) sebelum menulis, Anda bisa mendapatkan kinerja tambahan.  Dengan demikian, kecepatannya ditingkatkan menjadi 35k per detik.  Saat ini, kami memutuskan untuk menunda pengoptimalan lebih lanjut. <br><br>  Kami harus beralih ke protokol biner karena: <br><br>  <b>1.</b> Sistem sering menghitung hash, tanda tangan, dll., Dan untuk ini diperlukan data dalam `Buffer. <br><br>  <b>2.</b> Saat mentransfer antar layanan, data biner memiliki berat kurang dari teks.  Misalnya, saat mengirim blok dengan 1 juta transaksi, data dalam teks dapat menempati lebih dari 300 megabita. <br><br>  <b>3.</b> Konversi data berkelanjutan mempengaruhi kinerja. <br><br>  Oleh karena itu, kami menggunakan protokol biner kami sendiri untuk menyimpan dan mentransmisikan data, yang dikembangkan atas dasar perpustakaan data biner yang luar biasa. <br><br>  Akibatnya, kami memiliki struktur data berikut: <br><br><h3>  - Transaksi </h3><br><pre> <code class="plaintext hljs"> ```json { prevHash: BD.types.buffer(20), prevBlock: BD.types.uint24le, tokenId: BD.types.string(null), type: BD.types.uint8, newOwner: BD.types.buffer(20), dataLength: BD.types.uint24le, data: BD.types.buffer(({current}) =&gt; current.dataLength), signature: BD.types.buffer(65), hash: BD.types.buffer(32), blockNumber: BD.types.uint24le, timestamp: BD.types.uint48le, } ```</code> </pre><br><h3>  - Token </h3><br><pre> <code class="plaintext hljs"> ```json { id: BD.types.string(null), owner: BD.types.buffer(20), block: BD.types.uint24le, amount: BD.types.string(null), } ```</code> </pre><br><h3>  - Blokir </h3><br><pre> <code class="plaintext hljs"> ```json { number: BD.types.uint24le, merkleRootHash: BD.types.buffer(32), signature: BD.types.buffer(65), countTx: BD.types.uint24le, transactions: BD.types.array(Transaction.Protocol, ({current}) =&gt; current.countTx), timestamp: BD.types.uint48le, } ```</code> </pre><br>  Dengan perintah biasa `BD.encode (blok, Protokol) .slice ();` dan `BD.decode (buffer, Protocol)`, kami mengonversi data menjadi `Buffer` untuk menyimpannya ke Redis atau mentransfernya ke simpul lain dan mengambil data kembali. <br><br>  Kami juga memiliki 2 protokol biner untuk mentransfer data antar layanan: <br><br>  <i>- Protokol untuk berinteraksi dengan Plasma Node melalui soket unix</i> <br><br><pre> <code class="plaintext hljs"> ```json { type: BD.types.uint8, messageId: BD.types.uint24le, error: BD.types.uint8, length: BD.types.uint24le, payload: BD.types.buffer(({node}) =&gt; node.length) } ```</code> </pre><br>  dimana: <br><br><ul><li>  <b>`type`</b> - tindakan yang harus dilakukan, misalnya, 1 - sendTransaction, 2 - getTransaction; </li><li>  <b>`payload`</b> - data yang akan ditransfer ke fungsi yang sesuai; </li><li>  <b>`messageId`</b> - id pesan sehingga respons dapat diidentifikasi. </li></ul><br>  <i>- Protokol interaksi antar node</i> <br><br><pre> <code class="plaintext hljs"> ```json { code: BD.types.uint8, versionProtocol: BD.types.uint24le, seq: BD.types.uint8, countChunk: BD.types.uint24le, chunkNumber: BD.types.uint24le, length: BD.types.uint24le, payload: BD.types.buffer(({node}) =&gt; node.length) } ```</code> </pre><br>  dimana: <br><br><ul><li>  <b>`code`</b> - kode pesan, misalnya 6 - PREPARE_NEW_BLOCK, 7 - BLOCK_VALID, 8 - BLOCK_COMMIT; </li><li>  <b>`versionProtocol`</b> - versi protokol, karena node dengan versi yang berbeda dapat dimunculkan di jaringan dan mereka dapat bekerja dengan cara yang berbeda; </li><li>  <b>`seq`</b> - pengidentifikasi pesan; </li><li>  <b>Diperlukan `countChunk` dan`</b> <b>chunkNumber`</b> untuk membagi pesan-pesan besar; </li><li>  <b>`length` dan`</b> <b>payload`</b> panjang dan data itu sendiri. </li></ul><br>  Karena kita mengetik data sebelumnya, sistem final jauh lebih cepat daripada perpustakaan `rlp` dari Ethereum.  Sayangnya, kami belum bisa menolaknya, karena itu perlu untuk menyelesaikan kontrak pintar, yang kami rencanakan untuk dilakukan di masa depan. <br><br>  Jika kami berhasil mencapai kecepatan <b>35.000</b> transaksi per detik, kami juga perlu memprosesnya dalam waktu yang optimal.  Karena perkiraan waktu pembentukan blok memakan waktu 30 detik, kami perlu memasukkan <b>1.000.000</b> transaksi di blok tersebut, yang berarti mengirim lebih dari <b>100</b> mb data. <br><br>  Awalnya, kami menggunakan pustaka `ethereumjs-devp2p` untuk mengkomunikasikan node, tetapi tidak bisa mengatasi begitu banyak data.  Sebagai hasilnya, kami menggunakan pustaka `ws` dan mengatur transfer data biner di websocket.  Tentu saja, kami juga mengalami masalah saat mengirim paket data besar, tetapi kami membaginya menjadi beberapa bagian dan sekarang tidak ada masalah seperti itu. <br><br>  Juga, pembentukan pohon Merkle dan perhitungan hash <b>dari 1.000.000</b> transaksi membutuhkan sekitar <b>10</b> detik perhitungan berkelanjutan.  Selama waktu ini, koneksi dengan semua node berhasil terputus.  Diputuskan untuk mentransfer perhitungan ini ke utas terpisah. <br><br><h2>  Kesimpulan: </h2><br>  Faktanya, temuan kami bukanlah hal baru, tetapi karena beberapa alasan, banyak ahli melupakannya selama pengembangan. <br><br><ul><li>  Menggunakan Pemrograman Fungsional bukan Pemrograman Berorientasi Objek meningkatkan kinerja. </li><li>  Monolith lebih buruk daripada arsitektur layanan untuk sistem produksi di NodeJS. </li><li>  Menggunakan `worker_threads` untuk komputasi berat meningkatkan responsif sistem, terutama ketika bekerja dengan operasi i / o. </li><li>  soket unix lebih stabil dan lebih cepat dari permintaan http. </li><li>  Jika Anda perlu dengan cepat mentransfer data besar melalui jaringan, lebih baik menggunakan soket web dan mengirim data biner, dipecah menjadi beberapa bagian, yang dapat diteruskan jika tidak mencapai, dan kemudian digabung menjadi satu pesan. </li></ul><br>  Kami mengundang Anda untuk mengunjungi proyek <b>GitHub</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/opporty-com/Plasma-Cash/tree/new-version</a> <br><br>  Artikel ini ditulis bersama oleh <i>Alexander Nashivan</i> , pengembang senior <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Clever Solution Inc.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471096/">https://habr.com/ru/post/id471096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471086/index.html">Generator penutup musik Python di Blender</a></li>
<li><a href="../id471088/index.html">Burn Out IT-specialists: 4 cerita dari manajer, pengembang, produk dan admin. Dan resep dari Southbridge</a></li>
<li><a href="../id471090/index.html">[Jangan] gunakan CDN</a></li>
<li><a href="../id471092/index.html">Perintah Cp: menyalin folder file ke * nix dengan benar</a></li>
<li><a href="../id471094/index.html">Tutu.ru dan Moscow Club of Programmer diundang ke pertemuan backend pada 17 Oktober</a></li>
<li><a href="../id471098/index.html">Terobosan Digital - Bagaimana Itu</a></li>
<li><a href="../id471100/index.html">Interaksi antara komponen sudut menggunakan RxJS</a></li>
<li><a href="../id471102/index.html">DNS Dinamis Kustom dengan CloudFlare</a></li>
<li><a href="../id471104/index.html">Oktober Intisari Acara TI (Bagian Dua)</a></li>
<li><a href="../id471112/index.html">Alasan bodoh mengapa aplikasi penglihatan mesin Anda yang licik tidak berfungsi: orientasi di EXIF</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>