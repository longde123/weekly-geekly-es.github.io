<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒ¬ï¸ ğŸ¥” ğŸ“  Verifikasi sirkuit digital. Ulasan ğŸ” ğŸ‘©ğŸ¾â€ğŸ“ ğŸ‘©ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya akan mencoba berbicara secara umum tentang verifikasi sirkuit digital. 


 Verifikasi di bidang ini adalah proses penting yang membutuhkan keterl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verifikasi sirkuit digital. Ulasan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481542/"><p><img src="https://habrastorage.org/getpro/habr/post_images/889/a75/78e/889a7578e7d0f02194ae18361e06f056.jpg" alt="gambar"></p><br><p>  Saya akan mencoba berbicara secara umum tentang verifikasi sirkuit digital. </p><br><p>  Verifikasi di bidang ini adalah proses penting yang membutuhkan keterlibatan insinyur berpengalaman.  Misalnya, spesialis verifikasi yang bekerja pada sistem dengan CPU, sebagai aturan, harus memiliki bahasa scripting dan bahasa shell perintah (Tcl, bash, Makefile, dll.), Bahasa pemrograman (C, C ++, assembler), HDL / HDVL (SystemVerilog [10, Lampiran C - Sejarah Bahasa] [11], Verilog, VHDL), metodologi dan kerangka kerja modern (UVM). </p><br><p>  Proporsi waktu yang dihabiskan untuk verifikasi mencapai 70-80% dari total waktu proyek.  Salah satu alasan utama untuk perhatian tersebut adalah bahwa Anda tidak dapat melepaskan "tambalan" ke chip setelah dimasukkan ke dalam produksi, Anda hanya dapat melepaskan "silikon errata" (ini tidak berlaku untuk proyek FPGA / FPGA). </p><br><p>  Dengan sirkuit digital, maksud saya: </p><br><ul><li>  blok fungsional kompleks / properti intelektual (SFB / IP); </li><li>  Chip khusus sirkuit khusus aplikasi (ASIC) khusus aplikasi </li><li>  logika yang dapat diprogram sirkuit terpadu / field-programmable gate array (FPGA); </li><li>  sistem pada chip / sistem pada kristal (SoC / SoC); </li><li>  dll. </li></ul><a name="habracut"></a><br><h2 id="aktualnye-problemy-verifikacii">  Masalah verifikasi aktual </h2><br><p>  Keadaan saat ini dan tren di bidang verifikasi dapat dinilai dengan tantangan dan masalah berikut yang dihadapinya [6]: </p><br><ul><li>  Ukuran objek verifikasi (OB) terus bertambah.  Bahkan tipe IC mikrokontroler kecil adalah sekumpulan puluhan submodul, sangat sering dengan fungsi yang kompleks.  IC besar adalah kompleks di mana mungkin ada hingga miliaran transistor, dan skema manajemen daya saja dapat melebihi beberapa prosesor dalam kompleksitas [8]; </li><li>  tidak mungkin untuk membuat spesifikasi untuk IMS pada awal proyek dan hanya mengikutinya di masa depan, itu terus berubah sepanjang proses pengembangan (pelanggan mengubah persyaratan, masalah teknis atau penemuan solusi yang lebih optimal memaksa kita untuk mempertimbangkan kembali pendekatan, dll).  Berdasarkan hal ini, semua proses harus memahami dinamika perubahan spesifikasi dan dimodifikasi sesuai dengan persyaratan; </li><li>  seringkali, beberapa tim yang terpisah satu sama lain mengerjakan verifikasi proyek, yang jumlahnya dapat mencapai puluhan orang; </li><li>  jumlah tes individu dan jenisnya mencapai jumlah yang sangat besar, hasilnya harus dikumpulkan dan dianalisis; </li><li>  pemodelan bahkan sistem digital memerlukan banyak waktu komputer; </li><li>  kelengkapan target kesiapan yang ditetapkan untuk proyek sangat tergantung pada kompetensi dan intuisi spesialis verifikasi; </li><li>  Terlepas dari adanya indikator cakupan proyek dengan tes (metrik), satu-satunya cara untuk menyelesaikan verifikasi adalah memutuskan untuk menangguhkannya, terutama berdasarkan pada kesimpulan berikut: uang atau waktu yang dihabiskan pada tahap proyek harus dimasukkan ke dalam produksi, sepertinya mereka mencapai cakupan kode 100 %, kami telah menguji selama seminggu dan belum menemukan kesalahan, dll. </li></ul><br><h2 id="tipy-verifikacii">  Jenis Verifikasi </h2><br><p>  Verifikasi sirkuit digital dapat dibagi menjadi beberapa tipe utama berikut: </p><br><ol><li>  <strong>fungsional</strong> (verifikasi fungsional) - nama berbicara sendiri, Anda memeriksa apakah sistem Anda menjalankan fungsinya dengan benar; </li><li>  verifikasi formal - dengan verifikasi ini, kesetaraan representasi sistem Anda pada berbagai tahapan rute desain atau pemenuhan pernyataan yang ditempatkan dalam kode sumber ditetapkan: <br><ul><li>  Pemeriksaan Kesetaraan (mis. RTL-ke-RTL, RTL-ke-Gerbang, Gerbang-ke-Gerbang); </li><li>  Pemeriksaan Properti (Pemeriksaan Model) (memeriksa properti (pernyataan) yang ditentukan dalam kode menggunakan SVA (misalnya)). </li></ul></li><li>  analisis kode statis - memeriksa kode sumber sesuai dengan kriteria formal untuk kepatuhan dengan aturan untuk menggunakan bahasa dan konstruksinya.  Sangat sering, aturan verifikasi yang dikonfigurasi dikirim ke RMM [4].  Program untuk verifikasi semacam itu biasanya disebut dengan lint atau linter; </li><li>  <strong>verifikasi fisik</strong> - pada dasarnya menyiratkan pemeriksaan DRC, LVS, PERC, dll., representasi fisik sistem diperiksa untuk kesesuaian dengan standar teknologi dan kesesuaian representasi fisik dan logis, dll.  Komposisi cek sangat bergantung pada teknologi.  Biasanya, verifikasi fisik dilakukan oleh insinyur atau tim desain topologi. </li><li>  <strong>prototyping</strong> - penggunaan FPGA untuk verifikasi fungsional [18]. </li></ol><br><p>  Verifikasi fungsional dalam lingkup semua pekerjaan paling signifikan dan membutuhkan keterlibatan manusia secara langsung. </p><br><p>  Analisis kode statis hanya memerlukan konfigurasi awal alat, yang sesuai dengan aturan desain internal yang diadopsi oleh perusahaan, maka alat tersebut terlibat dalam fakta bahwa alat ini menyediakan "panduan berharga" bagi pengembang dan tidak memerlukan pengawasan terus-menerus. </p><br><p>  Alat verifikasi formal seringkali juga sangat independen, hanya memerlukan analisis yang cermat atas laporan yang dihasilkannya.  Mereka juga cocok untuk rekayasa terbalik, ketika karena alasan tertentu Anda tahu Anda harus mengembalikan kode dari daftar sirkuit. </p><br><h2 id="primery-instrumentov-verifikacii">  Contoh Alat Verifikasi </h2><br><p>  Contoh alat verifikasi sirkuit digital (rute digital-on-top): </p><br><ul><li>  alat manajemen verifikasi <br><ul><li>  Grafik Mentor - Manajemen Verifikasi Questa </li><li>  Irama - vManager </li><li>  Sinopsis - Verdi, Manajer Eksekusi VC (â€œExecManâ€) </li></ul></li><li>  fungsional - biasanya simulator <br><ul><li>  Mentor Graphics - ModelSim, QuestaSim </li><li>  Cadence - Incisive, Xcelium </li><li>  Sinopsis - VCS </li><li>  Perangkat lunak bebas dari pengembang independen - simulator Verilator, Icarus [5] </li></ul></li><li>  formal <br><ul><li>  Grafik Mentor - Pro Resmi, Verifikasi Formal Questa </li><li>  Cadence - JasperGold, LEC Konformal, Platform Verifikasi Formal yang Tajam </li><li>  Sinopsis - Formalitas, VC Formal </li></ul></li><li>  analisis kode statis <br><ul><li>  Mentor Graphics - Questa AutoCheck </li><li>  Cadence - HAL, JasperGold </li><li>  Synopsys - SpyGlass Lint </li></ul></li><li>  verifikasi fisik <br><ul><li>  Mentor Graphics - Calibre </li><li>  Cadence - Pegasus, Sistem Verifikasi Fisik, </li><li>  Sinopsis - Hercules, IC Validator </li></ul></li></ul><br><h2 id="metody-funkcionalnoy-verifikacii">  Metode Verifikasi Fungsional </h2><br><p>  Verifikasi fungsional - adalah serangkaian tes, saya akan secara kondisional membiarkan diri saya dibagi menjadi tiga kelompok (ini bukan dogma, ini dari pengalaman pribadi): </p><br><ol><li>  <strong>Cabang positif</strong> - verifikasi perilaku dalam situasi normal, diatur oleh spesifikasi untuk perangkat atau standar, dll.  Yaitu  Kami memeriksa situasi ketika semuanya berjalan dengan baik. </li><li>  <strong>Cabang negatif</strong> - memeriksa penyimpangan dari situasi standar, tetapi dalam kerangka spesifikasi atau standar, misalnya - ketidakcocokan checksum, jumlah data yang diterima, dll.  Yaitu  ketika ada yang tidak beres, tetapi kami tahu bahwa ini bisa terjadi dan kami tahu cara bekerja dalam situasi ini. </li><li>  <strong>Situasi non-standar</strong> - segala situasi acak mulai dari pelanggaran protokol komunikasi, urutan data, hingga benturan fisik di antarmuka, perubahan acak dalam keadaan elemen logika, dll.  Yaitu  ini adalah saat apa pun bisa terjadi dan Anda perlu memastikan bahwa OB akan keluar setelah ini dalam kondisi kerja. </li></ol><br><p>  Dua tahap pertama dapat diotomatisasi menggunakan UVC / VIP (Komponen Verifikasi Universal / Verifikasi IP) dan cukup cepat di sana Anda dapat meningkatkan volume berbagai tes, termasuk yang dihasilkan secara otomatis.  Tahap ketiga adalah "karya besar" dalam verifikasi, tahap ini membutuhkan pendekatan dan pengalaman yang luar biasa, sangat sulit untuk diotomatisasi, karena  kebanyakan situasi adalah algoritma yang terpisah, mungkin skrip untuk CAD atau instruksi untuk pemeriksaan "manual". </p><br><h3 id="tipy-metrik-funkcionalnoy-verifikacii">  Jenis metrik verifikasi fungsional </h3><br><p>  Metrik adalah indikator dari cakupan uji proyek.  Mereka diperlukan untuk memahami tes lain apa yang perlu dikembangkan untuk memverifikasi situasi yang mungkin dan berapa banyak waktu yang diperlukan verifikasi [16]. </p><br><p>  Sayangnya, hanya satu jenis metrik yang dievaluasi berdasarkan kode sumber proyek, definisi kriteria untuk jenis yang tersisa adalah hasil karya intelektual. </p><br><p>  Selain itu, harus diingat bahwa pencapaian indikator yang diinginkan oleh satu jenis metrik tidak berarti kemampuan kerja secara umum, selalu diperlukan untuk mengevaluasi kompleks. </p><br><p>  Jenis metrik [3]: </p><br><ul><li>  <strong>lapisan fungsional</strong> .  Menunjukkan seberapa banyak fungsi OB telah diuji.  Kriteria untuk cakupan ini dapat ditentukan oleh rencana pengujian dan pengenalan konstruksi khusus (covergroup [1]) di lingkungan pengujian dan / atau OM, yang memantau apakah fungsi / tindakan ini atau itu dilakukan atau tidak, apakah data diubah dengan cara tertentu, dll.  Informasi dari desain yang disematkan dalam kode sumber dapat dikumpulkan secara otomatis oleh CAD. </li><li>  <strong>cakupan kode</strong> - mengubah status konstruksi kode sumber selama pengujian.  Ia dikumpulkan secara otomatis oleh CAD, tidak memerlukan pengenalan struktur apa pun dalam kode sumber.  Sebagai contoh: <br><ul><li>  switching register (Toggle Coverage); </li><li>  aktivitas setiap baris kode (Line Coverage); </li><li>  aktivitas ekspresi (Pernyataan Cakupan), pada kenyataannya - ini adalah Cakupan Line, tetapi dapat melacak ekspresi yang lebih dari satu baris di editor; </li><li>  aktivitas segmen kode di dalam pernyataan atau prosedur bersyarat (Cakupan Blok), variasi dari Cakupan Pernyataan; </li><li>  aktivitas semua cabang pernyataan bersyarat seperti jika, kasus, sementara, ulangi, selamanya, untuk, loop (Branch Coverage); </li><li>  perubahan semua status (benar, salah) dari ekspresi logis komponen (Cakupan Ekspresi); </li><li>  keadaan mesin negara (Cakupan Mesin Hingga-Status). </li></ul></li><li>  <strong>klaim menutupi</strong> .  Pernyataan adalah konstruksi bahasa khusus yang melacak berbagai peristiwa dan urutan, dan menurut kriteria yang ditentukan menentukan legalitas kejadiannya. </li></ul><br><h3 id="metody-funkcionalnoy-verifikacii-1">  Metode Verifikasi Fungsional </h3><br><h4 id="directed-tests-method-dtm">  Metode Tes Langsung (DTM) </h4><br><p>  Tes langsung dan bermakna.  Jika metode ini diadopsi dalam proyek, maka rencana verifikasi terdiri dari tes yang bertujuan untuk memeriksa perilaku bahan organik di tempat-tempat menarik tertentu (negara bagian).  Memeriksa semua situasi yang mungkin terjadi, terutama dalam proyek yang kompleks, hampir tidak mungkin. <br>  Pada saat yang sama, masalah yang mungkin timbul dalam situasi yang tidak tercakup oleh pengujian tidak terdeteksi sebelum perangkat mulai digunakan dalam kondisi nyata.  Biasanya, tes ini menggunakan metrik cakupan fungsional. </p><br><h4 id="coverage-driven-verification-metric-driven-verification-cdv-mdv-17">  Verifikasi Berbasis Drive, Verifikasi Berbasis Metrik (CDV, MDV) [17] </h4><br><p>  Konsep membuat tes yang bertujuan untuk mencapai "cakupan uji" tertentu dari zat organik.  Mereka mengandalkan metrik untuk memahami tes apa yang perlu ditambahkan ke rencana verifikasi untuk mencapai target kesiapan proyek. <br>  Anda perlu menggunakan alat analisis cakupan untuk melihat apa lagi yang akan ditambahkan ke rencana verifikasi.  Bahkan, jika kita mulai menyesuaikan rencana verifikasi dalam DTM, dengan mengandalkan setidaknya pada "cakupan kode", maka kita sudah dapat berasumsi bahwa kita dengan lancar beralih dari DTM ke CDV. </p><br><h4 id="constrained-random-verification-crv">  Verifikasi Acak Terkendali (CRV) </h4><br><p>  Verifikasi dengan mengirimkan pengaruh acak.  Ini adalah tes yang benar-benar otomatis dengan generasi efek acak pada OM, tetapi sulit membayangkannya tanpa simbiosis dengan ABV. <br>  Metode ini sangat mahal pada awalnya, karena  Butuh waktu lama untuk menyiapkan alat.  Setelah tahap persiapan awal selesai, pengujian dapat dimulai secara otomatis, berulang kali dengan data awal yang berbeda.  Jika ketidakcocokan pernyataan terdeteksi, tim pengembangan dan verifikasi mulai menganalisis kesalahan yang terdeteksi. <br>  Dalam proyek nyata, seseorang tidak dapat membatasi diri hanya untuk metode ini, karena  Dengan menggunakan metode ini, Anda dapat mengumpulkan cakupan kode dan cakupan pernyataan, dan mereka tidak dapat mengatakan apa-apa tentang operasi OS yang benar, yaitu.  kesesuaian dengan spesifikasi.  Itu harus dilengkapi dengan tes fungsional. <br>  Untuk mengimplementasikan metodologi ini dibutuhkan: </p><br><ol><li>  menerapkan "pernyataan" di semua poin penting dari kode sumber OB dan lingkungan pengujian; </li><li>  untuk mengembangkan generator dari efek dan skenario acak dari pekerjaan mereka, yaitu  dampaknya acak, tetapi memiliki batasan jangkauan (kami tidak punya waktu untuk memilah-milah semuanya), urutan pengarsipan, dll. </li></ol><br><h4 id="assertion-based-verification9-abv">  Verifikasi Berbasis Pernyataan [9] (ABV) </h4><br><p>  Verifikasi dengan pernyataan.  Mungkin, ini bahkan bukan metode independen, tetapi beberapa komponen atau komponen dasar di atas. </p><br><p>  Masalah penting dengan ABV adalah bagaimana mendistribusikan pernyataan, mana yang paling baik ditempatkan dalam kode sumber OB, mana yang harus di lingkungan pengujian. </p><br><p>  Harus segera dicatat bahwa bahasa Verilog tidak memiliki asersi dalam standarnya (mereka dapat dibuat menggunakan konstruksi bahasa dasar, tetapi arahan diperlukan untuk synthesizer sehingga tidak berurusan dengan konversi mereka).  Pernyataan hanya muncul dalam standar SystemVerilog, dan mereka juga awalnya dalam standar bahasa VHDL dan e. </p><br><p>  Saya menyarankan agar Anda membiasakan diri dengan rekomendasi para spesialis, termasuk Clifford Cummings [12, artikel tentang SVA] tentang distribusi karya pada tulisan mereka, serta materi tentang ABV di situs web Verification Academy [13]. </p><br><h2 id="spisok-literatury">  Referensi </h2><br><ol><li>  IEEE Std 1800TM-2012.  Standar IEEE untuk SystemVerilog - Desain Perangkat Keras, Spesifikasi, dan Bahasa Verifikasi </li><li>  Clive Maxfield.  Desain FPGA.  Arsitektur, alat dan metode.  Kursus pejuang muda.  ISBN 978-5-94120-147-1 (RUS), ISBN 0-7506-7604-3 (ENG) </li><li>  <a href="https://verificationacademy.com/cookbook/coverage" rel="nofollow">Akademi Verifikasi.</a>  <a href="https://verificationacademy.com/cookbook/coverage" rel="nofollow">Cakupan Cookbook.</a>  <a href="https://verificationacademy.com/cookbook/coverage" rel="nofollow">Cakupan uji pro</a> </li><li>  Michael Keating, Pierre Bricaud.  Gunakan kembali manual metodologi untuk desain sistem-pada-chip.  Cetak ISBN 1-4020-7141-8, eBuku ISBN 0-306-47640-1 </li><li>  <a href="https://en.wikipedia.org/wiki/List_of_HDL_simulators" rel="nofollow">Daftar CAD berlisensi dan didistribusikan secara gratis</a> </li><li>  <a href="https://www.mentor.com/products/fv/resources/overview/trends-in-functional-verification-a-2016-industry-study-72f652de-b0a2-4c8e-97de-b1efbf457a36" rel="nofollow">Grafik Mentor.</a>  <a href="https://www.mentor.com/products/fv/resources/overview/trends-in-functional-verification-a-2016-industry-study-72f652de-b0a2-4c8e-97de-b1efbf457a36" rel="nofollow">Contoh statistik tentang kondisi saat ini dan ruang lingkup verifikasi</a> </li><li>  <a href="https://en.wikichip.org/wiki/WikiChip" rel="nofollow">WikiChip.</a>  <a href="https://en.wikichip.org/wiki/WikiChip" rel="nofollow">Keripik Wikipedia</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Transistor_count" rel="nofollow">Wikipedia</a>  <a href="https://en.wikipedia.org/wiki/Transistor_count" rel="nofollow">Data umum tentang jumlah transistor di IC</a> </li><li>  Harry Foster, Adam Krolnik, David Lacey.  Desain berbasis pernyataan. Cetak ISBN 1-4020-8027-1, eBuku ISBN 1-4020-8028-X </li><li>  Stuart Sutherland, Simon Davidmann, Peter Flake.  SystemVerilog untuk Desain.  Cetak ISBN-10: 0-387-33399-1, eBuku ISBN-10: 0-387-36495-1 </li><li>  Chris Spear, Greg Tumbush.  SystemVerilog untuk Verifikasi.  Cetak ISBN: 978-1-4614-0714-0, eBuku ISBN: 978-1-4614-0715-7 </li><li>  <a href="http://www.sunburst-design.com/papers/" rel="nofollow">Desain Sunburst.</a>  <a href="http://www.sunburst-design.com/papers/" rel="nofollow">Makalah</a> </li><li>  <a href="https://verificationacademy.com/courses/assertion-based-verification" rel="nofollow">Akademi Verifikasi.</a>  <a href="https://verificationacademy.com/courses/assertion-based-verification" rel="nofollow">Tentu saja ABV</a> </li><li>  <a href="https://www.doulos.com/" rel="nofollow">Doulos.</a>  <a href="https://www.doulos.com/" rel="nofollow">Materi yang berguna on-line dan buku referensi</a> </li><li>  Prakash Rashinkar, Peter Paterson, Leena Singh.  Verifikasi chip sistem-on-a.  metodologi dan teknik.  Cetak ISBN: 0-792-37279-4, ISBN eBuku: 0-306-46995-2 </li><li>  <a href="https://verificationacademy.com/courses/metrics-soc-verification" rel="nofollow">Akademi Verifikasi.</a>  <a href="https://verificationacademy.com/courses/metrics-soc-verification" rel="nofollow">Metrik dalam Verifikasi SoC</a> </li><li>  <a href="https://www.doulos.com/knowhow/sysverilog/uvm/easier_uvm_guidelines/coverage-driven/" rel="nofollow">Doulos.</a>  <a href="https://www.doulos.com/knowhow/sysverilog/uvm/easier_uvm_guidelines/coverage-driven/" rel="nofollow">Metodologi verifikasi berdasarkan cakupan</a> </li><li>  Doug Amos, Austin Lesea, Rene Richter.  Manual Metodologi Prototip Berbasis FPGA: Praktik terbaik dalam Desain-untuk-Prototipe (FPMM).  Cetak ISBN: 978-1617300042.  <a href="https://www.synopsys.com/company/resources/synopsys-press/fpga-based-prototyping-methodology-manual.html" rel="nofollow">Unduh secara gratis dari situs web Synopsys</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481542/">https://habr.com/ru/post/id481542/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481532/index.html">Forensik memori, Bebek Karet dan kata sandi GPO. Pemecahan masalah dengan r0ot-mi. Bagian 2</a></li>
<li><a href="../id481534/index.html">Is Delphi Dying - False</a></li>
<li><a href="../id481536/index.html">Sejarah sistem nama domain: protokol "perang"</a></li>
<li><a href="../id481538/index.html">20 mitos SEO untuk mati pada tahun 2020</a></li>
<li><a href="../id481540/index.html">Memuat ulang tekstur OpenGLESv2 melalui DMABUF</a></li>
<li><a href="../id481544/index.html">Menggunakan jaringan saraf convolutional untuk memainkan Life (on Keras)</a></li>
<li><a href="../id481546/index.html">Sejarah mikroprosesor dan komputer pribadi: 1947-1974</a></li>
<li><a href="../id481548/index.html">Symbol.iterator dalam Javascript</a></li>
<li><a href="../id481550/index.html">Inmarsat: menerima dan mendekode sinyal satelit di rumah</a></li>
<li><a href="../id481552/index.html">PGConf.Russia 2020 Segera Hadir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>