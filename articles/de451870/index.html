<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüåæ üöô ü§¥üèΩ Moderne C ++ - Funktionen, die alle Programmierer kennen m√ºssen ‚úÖ üõÄüèª üë¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Autor des Materials, dessen √úbersetzung wir heute ver√∂ffentlichen, sagt, dass sich C ++ in seiner modernen Form im Vergleich zu dieser Sprache vor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Moderne C ++ - Funktionen, die alle Programmierer kennen m√ºssen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/451870/">  Der Autor des Materials, dessen √úbersetzung wir heute ver√∂ffentlichen, sagt, dass sich C ++ in seiner modernen Form im Vergleich zu dieser Sprache vor einigen Jahren erheblich zum Besseren ver√§ndert hat.  Nat√ºrlich sind diese √Ñnderungen nicht sofort eingetreten.  In fr√ºheren Zeiten fehlte C ++ beispielsweise die Dynamik.  Es war nicht leicht, eine Person zu finden, die sagen konnte, dass sie z√§rtliche Gef√ºhle f√ºr diese Sprache hat.  Alles √§nderte sich, als diejenigen, die f√ºr die Standardisierung der Sprache verantwortlich sind, beschlossen, Innovationen Platz zu machen.  Im Jahr 2011 wurde C ++ eine dynamische Sprache, eine Sprache, die sich st√§ndig weiterentwickelt und Programmierer viel positivere Emotionen hervorruft. <br><br>  Denken Sie nicht, dass die Sprache einfacher geworden ist.  Es kann immer noch als eine der komplexesten, weit verbreiteten Programmiersprachen bezeichnet werden, wenn nicht sogar als die komplexeste.  Aber modernes C ++ ist viel freundlicher geworden als zuvor. <br><br><img src="https://habrastorage.org/webt/qk/ii/cx/qkiicxclyr6agfsxlcplndrkpd8.jpeg"><br><br>  Heute werden wir √ºber einige der neuen Funktionen der Sprache sprechen (beginnend mit C ++ 11, das √ºbrigens bereits 8 Jahre alt ist), die f√ºr jeden Programmierer n√ºtzlich sein werden. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Auto-Schl√ºsselwort</font> </h2><br>  Seit das <code>auto</code> Schl√ºsselwort in C ++ 11 vorkommt, ist das Leben von Programmierern einfacher geworden.  Dank dieses Schl√ºsselworts kann der Compiler zur Kompilierungszeit Variablentypen ausgeben, sodass wir nicht immer selbst Typen angeben m√ºssen.  Dies hat sich beispielsweise in F√§llen als sehr praktisch erwiesen, in denen Sie mit Datentypen wie <code>map&lt;string,vector&lt;pair&lt;int,int&gt;&gt;&gt;</code> .  Bei der Verwendung des Schl√ºsselworts <code>auto</code> sind einige Dinge zu beachten.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> an_int = <span class="hljs-number"><span class="hljs-number">26</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,     - int auto a_bool = false; //   bool auto a_float = 26.04; //   float auto ptr = &amp;a_float; //       auto data; // #1     ?    - .</span></span></code> </pre> <br>  Achten Sie auf die letzte Zeile in diesem Beispiel, deren Kommentar als <code>#1</code> markiert ist (im Folgenden werden wir auf √§hnliche Weise die Zeilen markieren, die wir nach den Beispielen analysieren werden).  In dieser Zeile befindet sich kein Initialisierer. Sie k√∂nnen dies nicht tun.  Der Code in dieser Zeile verhindert, dass der Compiler den Typ der entsprechenden Variablen kennt. <br><br>  Anfangs war das <code>auto</code> Schl√ºsselwort in C ++ ziemlich begrenzt.  In neueren Versionen der Sprache wurden dann <code>auto</code> Funktionen hinzugef√ºgt.  Hier ist ein weiteres Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//            auto! {   std::vector&lt;int&gt; c = do_something(a, b);   return c; } std::vector&lt;int&gt; a = { ... }; // #1 -  std::vector&lt;int&gt; b = { ... }; // #2  -  auto c = merge(a,b); //      </span></span></span></span></code> </pre> <br>  Die Zeilen <code>#1</code> und <code>#2</code> wenden die Variableninitialisierung mit geschweiften Klammern an - eine weitere neue Funktion in C ++ 11. <br><br>  Denken Sie daran, dass der Compiler bei Verwendung des Schl√ºsselworts <code>auto</code> eine M√∂glichkeit haben muss, auf den Typ der Variablen zu schlie√üen. <br><br>  Nun eine interessante Frage.  Was passiert, wenn Sie ein Design wie <code>auto a = {1, 2, 3}</code> ?  Was ist das?  Vektor oder Ursache f√ºr Kompilierungsfehler? <br><br>  Tats√§chlich wurde in C ++ 11 eine Konstruktion der Form <code>std::initializer_list&lt;type&gt;</code> angezeigt.  Die Liste der Initialisierungswerte in Klammern wird mit dem Schl√ºsselwort <code>auto</code> als Container behandelt. <br><br>  Und schlie√ülich kann, wie bereits erw√§hnt, die Typinferenz durch den Compiler √§u√üerst n√ºtzlich sein, wenn Sie mit komplexen Datenstrukturen arbeiten m√ºssen.  Hier ist ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">populate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    !   data.insert({"a",{1,4}});   data.insert({"b",{3,1}});   data.insert({"c",{2,3}}); } auto merge(auto data, auto upcoming_data) { //         auto result = data;   for(auto it: upcoming_data) {       result.insert(it);   }   return result; } int main() {   std::map&lt;std::string, std::pair&lt;int,int&gt;&gt; data;   populate(data);   std::map&lt;std::string, std::pair&lt;int,int&gt;&gt; upcoming_data;   upcoming_data.insert({"d",{5,3}});   auto final_data = merge(data,upcoming_data);   for(auto itr: final_data) {       auto [v1, v2] = itr.second; // #1               std::cout &lt;&lt; itr.first &lt;&lt; " " &lt;&lt; v1 &lt;&lt; " " &lt;&lt; v2 &lt;&lt; std:endl;   }   return 0; }</span></span></code> </pre> <br>  Schauen Sie sich Zeile <code>#1</code> .  Der Ausdruck <code>auto [v1,v2] = itr.second</code> stellt eine neue Funktion von C ++ 17 dar. Dies ist die sogenannte Zerlegung beim Deklarieren von Variablen.  In fr√ºheren Versionen der Sprache musste jeder Wert einzeln extrahiert werden.  Dank dieses Mechanismus ist das Ausf√ºhren solcher Operationen viel bequemer geworden. <br><br>  Wenn Sie mit Daten √ºber Links arbeiten m√ºssen, reicht es au√üerdem aus, dieser Konstruktion nur ein Zeichen hinzuzuf√ºgen und es in die folgende Form zu konvertieren: <code>auto &amp;[v1,v2] = itr.second</code> . <br><br><h2>  <font color="#3AC1EF">Lambda-Ausdr√ºcke</font> </h2><br>  C ++ 11 bietet Unterst√ºtzung f√ºr Lambda-Ausdr√ºcke.  Sie √§hneln anonymen Funktionen in JavaScript und k√∂nnen mit Funktionsobjekten ohne Namen verglichen werden.  Sie erfassen Variablen in verschiedenen Bereichen, abh√§ngig von ihrer Beschreibung, f√ºr die kompakte syntaktische Konstruktionen verwendet werden.  Au√üerdem k√∂nnen sie Variablen zugeordnet werden. <br><br>  Lambda-Ausdr√ºcke sind ein sehr n√ºtzliches Werkzeug f√ºr F√§lle, in denen Sie eine kleine Operation im Code ausf√ºhren m√ºssen, aber keine separate Funktion daf√ºr schreiben m√∂chten.  Ein weiteres h√§ufiges Beispiel f√ºr ihre Verwendung ist die Erstellung von Funktionen zum Vergleichen von Werten.  Zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; data = {{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>}, {<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}}; <span class="hljs-comment"><span class="hljs-comment">//        std::sort(begin(data), end(data), [](auto a, auto b) { //   - auto!   return a.second &lt; b.second; });</span></span></code> </pre> <br>  In diesem kurzen Beispiel finden Sie viele interessante Dinge. <br><br>  Achten Sie zun√§chst darauf, wie bequem es ist, die variable Initialisierung mit geschweiften Klammern zu verwenden.  Als n√§chstes sehen wir die Standardkonstruktionen <code>begin()</code> und <code>end()</code> , die auch in C ++ 11 erschienen sind. Dann kommt die Lambda-Funktion, die als Mechanismus zum Vergleichen von Daten verwendet wird.  Die Parameter dieser Funktion werden mit dem Schl√ºsselwort <code>auto</code> deklariert. Diese Funktion wurde in C ++ 14 angezeigt. Bisher konnte dieses Schl√ºsselwort nicht zur Beschreibung der Funktionsparameter verwendet werden. <br><br>  Beachten Sie nun, dass der Lambda-Ausdruck mit eckigen Klammern beginnt - <code>[]</code> .  Dies ist die sogenannte Variablenmaske.  Es bestimmt den Umfang des Ausdrucks, dh Sie k√∂nnen die Beziehung des Lambda-Ausdrucks zu lokalen Variablen und Objekten steuern. <br><br>  Hier ist ein Auszug aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> Repository, das modernen C ++ - Funktionen gewidmet ist: <br><br><ul><li>  <code>[]</code> - Der Ausdruck erfasst nichts.  Dies bedeutet, dass es in einem Lambda-Ausdruck unm√∂glich ist, lokale Variablen aus dem externen Bereich zu verwenden.  Im Ausdruck k√∂nnen nur Parameter verwendet werden. </li><li>  <code>[=]</code> - Der Ausdruck erfasst die Werte lokaler Objekte (dh lokaler Variablen, Parameter).  Dies bedeutet, dass sie verwendet, aber nicht ge√§ndert werden k√∂nnen. </li><li>  <code>[&amp;]</code> - Der Ausdruck erfasst Verweise auf lokale Objekte.  Sie k√∂nnen wie im folgenden Beispiel gezeigt ge√§ndert werden. </li><li>  <code>[this]</code> - Der Ausdruck erfasst den Wert <code>this</code> Zeigers. </li><li>  <code>[a, &amp;b]</code> - Der Ausdruck erfasst den Wert von Objekt <code>a</code> und einen Verweis auf Objekt <code>b</code> . </li></ul><br>  Wenn Sie innerhalb der Lambda-Funktion die Daten in ein anderes Format konvertieren m√ºssen, k√∂nnen Sie die oben genannten Mechanismen verwenden.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; data = {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> factor = <span class="hljs-number"><span class="hljs-number">7</span></span>; for_each(begin(data), end(data), [&amp;factor](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;val) { <span class="hljs-comment"><span class="hljs-comment">//    factor     val = val * factor;   factor--; // #1   - ,  -    factor   }); for(int val: data) {   std::cout &lt;&lt; val &lt;&lt; ' '; // 14 24 20 4 3 6 9 }</span></span></code> </pre> <br>  Wenn hier auf die <code>factor</code> nach Wert zugegriffen wurde (dann w√ºrde die Variablenmaske <code>[factor]</code> verwendet, um den Lambda-Ausdruck zu beschreiben), konnte der <code>factor</code> in Zeile <code>#1</code> nicht ge√§ndert werden - einfach, weil wir keine Rechte dazu h√§tten Durchf√ºhren einer solchen Operation.  In diesem Beispiel haben wir das Recht auf solche Aktionen.  In solchen Situationen ist es wichtig, die Funktionen, die Zugriffsvariablen als Referenz bereitstellen, nicht zu missbrauchen. <br><br>  Beachten Sie au√üerdem, dass auf <code>val</code> auch als Referenz zugegriffen wird.  Dies stellt sicher, dass Daten√§nderungen, die in der Lambda-Funktion auftreten, den <code>vector</code> beeinflussen. <br><br><h2>  <font color="#3AC1EF">Variable Initialisierungsausdr√ºcke in if- und switch-Konstrukten</font> </h2><br>  Diese C ++ 17-Innovation hat mir sehr gut gefallen, nachdem ich davon erfahren hatte.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; input = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = input.find(<span class="hljs-number"><span class="hljs-number">7</span></span>); it==input.end()){ <span class="hljs-comment"><span class="hljs-comment">//   - ,  -    std::cout &lt;&lt; 7 &lt;&lt; " not found" &lt;&lt; std:endl; } else {   //    else      it   std::cout &lt;&lt; 7 &lt;&lt; " is there!" &lt;&lt; std::endl; }</span></span></code> </pre> <br>  Es stellt sich heraus, dass Sie jetzt die Variablen initialisieren und mit ihrer Verwendung in einem <code>if</code> oder <code>switch</code> Block vergleichen k√∂nnen.  Dies hilft, genauen Code zu schreiben.  Hier ist eine schematische Beschreibung der betrachteten Struktur: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( init-statement(x); condition(x)) {   <span class="hljs-comment"><span class="hljs-comment">//    } else {   //     x   //    }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Durchf√ºhren von Berechnungen zur Kompilierungszeit mit constexpr</font> </h2><br>  Das <code>constexpr</code> bietet uns gro√üartige M√∂glichkeiten.  Angenommen, wir haben eine Art Ausdruck, der berechnet werden muss, w√§hrend sich sein Wert nach dem Initialisieren mit der entsprechenden Variablen nicht √§ndert.  Ein solcher Ausdruck kann im Voraus berechnet und als Makro verwendet werden.  Oder, was in C ++ 11 m√∂glich wurde, verwenden Sie das <code>constexpr</code> . <br><br>  Programmierer bem√ºhen sich, den Rechenaufwand w√§hrend der Programmausf√ºhrung zu minimieren.  Wenn bestimmte Vorg√§nge w√§hrend des Kompilierungsprozesses ausgef√ºhrt werden k√∂nnen und dadurch die Last aus dem System w√§hrend der Programmausf√ºhrung entfernt wird, hat dies einen guten Einfluss auf das Verhalten des Programms w√§hrend der Ausf√ºhrung.  Hier ist ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; constexpr long long fact(long long n) { //       constexpr return n == 1 ? 1 : (fact(n-1) * n); } int main() { const long long bigval = fact(20); std::cout&lt;&lt;bigval&lt;&lt;std::endl; }</span></span></span></span></code> </pre> <br>  Dies ist ein sehr h√§ufiges Beispiel f√ºr die Verwendung von <code>constexpr</code> . <br><br>  Da wir die Funktion zur Berechnung der Fakult√§t als <code>constexpr</code> , kann der Compiler den <code>constexpr</code> <code>fact(20)</code> zum Zeitpunkt der Kompilierung des Programms vorberechnen.  Infolgedessen ist nach der Kompilierung der String <code>const long long bigval = fact(20);</code>  kann durch <code>const long long bigval = 2432902008176640000;</code>  . <br><br>  Beachten Sie, dass das an die Funktion √ºbergebene Argument durch eine Konstante dargestellt wird.  Dies ist eine wichtige Funktion bei der Verwendung von Funktionen, die mit dem <code>constexpr</code> .  Die an sie √ºbergebenen Argumente m√ºssen auch mit dem <code>constexpr</code> oder mit dem Schl√ºsselwort <code>const</code> deklariert werden.  Andernfalls verhalten sich solche Funktionen wie normale Funktionen, dh, w√§hrend der Kompilierung werden ihre Werte nicht im Voraus berechnet. <br><br>  Variablen k√∂nnen auch mit dem <code>constexpr</code> .  In diesem Fall m√ºssen die Werte dieser Variablen zur Kompilierungszeit berechnet werden.  Ist dies nicht m√∂glich, wird eine Kompilierungsfehlermeldung angezeigt. <br><br>  Es ist interessant festzustellen, dass sp√§ter in C ++ 17 die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konstrukte constexpr-if</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">constexpr-lambda</a> erschienen. <br><br><h2>  <font color="#3AC1EF">Tupel-Datenstrukturen</font> </h2><br>  Wie die <code>pair</code> ist die <code>tuple</code> (Tupel) eine Sammlung von Werten verschiedener Typen einer festen Gr√∂√üe.  Hier ist ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-string"><span class="hljs-string">"Chowdhury"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  auto     //    std::get&lt;0&gt;(user_info); std::get&lt;1&gt;(user_info); std::get&lt;2&gt;(user_info); //  C++ 11     tie std::string first_name, last_name, age; std::tie(first_name, last_name, age) = user_info; //  C++ 17, ,       auto [first_name, last_name, age] = user_info;</span></span></code> </pre> <br>  Manchmal ist es bequemer, <code>std::array</code> anstelle einer <code>tuple</code> verwenden.  Diese Datenstruktur √§hnelt den einfachen Arrays, die in der C-Sprache verwendet werden und mit zus√§tzlichen Funktionen aus der C ++ - Standardbibliothek ausgestattet sind.  Diese Datenstruktur wurde in C ++ 11 angezeigt. <br><br><h2>  <font color="#3AC1EF">Automatischer R√ºckschluss auf den Argumenttyp der Klassenvorlage</font> </h2><br>  Der Name dieser Funktion sieht ziemlich lang und komplex aus, aber tats√§chlich gibt es hier nichts Kompliziertes.  Die Hauptidee hierbei ist, dass in C ++ 17 Typargumentargumente auch f√ºr Standardklassenvorlagen ausgegeben werden.  Bisher wurde dies nur f√ºr Funktionsvorlagen unterst√ºtzt.  Als Ergebnis stellt sich heraus, dass sie fr√ºher so geschrieben haben: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; user = {<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>};</code> </pre> <br>  Mit der Ver√∂ffentlichung von C ++ 17 kann diese Konstruktion nun durch folgende ersetzt werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair user = {<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>};</code> </pre> <br>  Die Typinferenz erfolgt implizit.  Dieser Mechanismus ist noch praktischer, wenn es um Tupel geht.  N√§mlich bevor ich folgendes schreiben musste: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; user (<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-string"><span class="hljs-string">"Chy"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>);</code> </pre> <br>  Jetzt sieht das gleiche so aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">tuple </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"M"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Chy"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">25</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br>  Es ist erw√§hnenswert, dass diese Funktionen f√ºr diejenigen, die mit C ++ - Vorlagen nicht besonders vertraut sind, nicht besonders hervorzuheben sind. <br><br><h2>  <font color="#3AC1EF">Intelligente Zeiger</font> </h2><br>  Das Arbeiten mit Zeigern in C ++ kann ein wahrer Albtraum sein.  Dank der Freiheit, die die Sprache dem Programmierer gibt, ist es f√ºr ihn manchmal sehr schwierig, "sich nicht in den Fu√ü zu schie√üen".  In vielen F√§llen dr√§ngen Zeiger auf einen solchen ‚ÄûSchuss‚Äú des Programmierers. <br><br>  Gl√ºcklicherweise hat C ++ 11 intelligente Zeiger eingef√ºhrt, die viel praktischer sind als normale Zeiger.  Sie helfen dem Programmierer, Speicherlecks zu vermeiden, indem sie nach M√∂glichkeit Ressourcen freisetzen.  Dar√ºber hinaus bieten sie eine Sicherheitsgarantie f√ºr Ausnahmen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist ein</a> gutes Repository, das unserer Meinung nach f√ºr diejenigen interessant sein wird, die den Innovationen von C ++ folgen.  In dieser Sprache taucht st√§ndig etwas Neues auf.  Hier haben wir nur einige moderne Merkmale der Sprache angesprochen.  In der Tat gibt es viele von ihnen.  Es ist m√∂glich, dass wir noch √ºber sie sprechen. <br><br>  <b>Liebe Leser!</b>  Welche modernen C ++ - Funktionen finden Sie am interessantesten und n√ºtzlichsten? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451870/">https://habr.com/ru/post/de451870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451858/index.html">Erstellen eines einfachen Cache-basierten Leistungsschalters im Fr√ºhjahr</a></li>
<li><a href="../de451860/index.html">Mathematiker haben den perfekten Weg gefunden, um Zahlen zu multiplizieren</a></li>
<li><a href="../de451862/index.html">Joe Diprims musikalischer Blitz: Ein Autodidakt stellt Tesla-Spulen zur Unterhaltung und zum Verdienen her</a></li>
<li><a href="../de451864/index.html">Kritische RCE-Sicherheitsanf√§lligkeit der EternalBlue-Ebene unter Windows erkannt</a></li>
<li><a href="../de451866/index.html">W√§hlen Sie die n√§chsten Knoten im Netzwerk</a></li>
<li><a href="../de451872/index.html">Python ist ein Assistent bei der Suche nach g√ºnstigen Fl√ºgen f√ºr diejenigen, die gerne reisen</a></li>
<li><a href="../de451874/index.html">Top SEO Trends bei Google</a></li>
<li><a href="../de451876/index.html">Rechenzentrum Frankfurt: Rechenzentrum Telehouse</a></li>
<li><a href="../de451878/index.html">Live-Streaming von Stereovideos auf VR-Brillen (Oculus Go)</a></li>
<li><a href="../de451880/index.html">DevPRO'19: Blick vom Wrike-Stand</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>