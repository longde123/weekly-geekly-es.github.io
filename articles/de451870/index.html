<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🌾 🚙 🤴🏽 Moderne C ++ - Funktionen, die alle Programmierer kennen müssen ✅ 🛀🏻 👢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Autor des Materials, dessen Übersetzung wir heute veröffentlichen, sagt, dass sich C ++ in seiner modernen Form im Vergleich zu dieser Sprache vor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Moderne C ++ - Funktionen, die alle Programmierer kennen müssen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/451870/">  Der Autor des Materials, dessen Übersetzung wir heute veröffentlichen, sagt, dass sich C ++ in seiner modernen Form im Vergleich zu dieser Sprache vor einigen Jahren erheblich zum Besseren verändert hat.  Natürlich sind diese Änderungen nicht sofort eingetreten.  In früheren Zeiten fehlte C ++ beispielsweise die Dynamik.  Es war nicht leicht, eine Person zu finden, die sagen konnte, dass sie zärtliche Gefühle für diese Sprache hat.  Alles änderte sich, als diejenigen, die für die Standardisierung der Sprache verantwortlich sind, beschlossen, Innovationen Platz zu machen.  Im Jahr 2011 wurde C ++ eine dynamische Sprache, eine Sprache, die sich ständig weiterentwickelt und Programmierer viel positivere Emotionen hervorruft. <br><br>  Denken Sie nicht, dass die Sprache einfacher geworden ist.  Es kann immer noch als eine der komplexesten, weit verbreiteten Programmiersprachen bezeichnet werden, wenn nicht sogar als die komplexeste.  Aber modernes C ++ ist viel freundlicher geworden als zuvor. <br><br><img src="https://habrastorage.org/webt/qk/ii/cx/qkiicxclyr6agfsxlcplndrkpd8.jpeg"><br><br>  Heute werden wir über einige der neuen Funktionen der Sprache sprechen (beginnend mit C ++ 11, das übrigens bereits 8 Jahre alt ist), die für jeden Programmierer nützlich sein werden. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Auto-Schlüsselwort</font> </h2><br>  Seit das <code>auto</code> Schlüsselwort in C ++ 11 vorkommt, ist das Leben von Programmierern einfacher geworden.  Dank dieses Schlüsselworts kann der Compiler zur Kompilierungszeit Variablentypen ausgeben, sodass wir nicht immer selbst Typen angeben müssen.  Dies hat sich beispielsweise in Fällen als sehr praktisch erwiesen, in denen Sie mit Datentypen wie <code>map&lt;string,vector&lt;pair&lt;int,int&gt;&gt;&gt;</code> .  Bei der Verwendung des Schlüsselworts <code>auto</code> sind einige Dinge zu beachten.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> an_int = <span class="hljs-number"><span class="hljs-number">26</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,     - int auto a_bool = false; //   bool auto a_float = 26.04; //   float auto ptr = &amp;a_float; //       auto data; // #1     ?    - .</span></span></code> </pre> <br>  Achten Sie auf die letzte Zeile in diesem Beispiel, deren Kommentar als <code>#1</code> markiert ist (im Folgenden werden wir auf ähnliche Weise die Zeilen markieren, die wir nach den Beispielen analysieren werden).  In dieser Zeile befindet sich kein Initialisierer. Sie können dies nicht tun.  Der Code in dieser Zeile verhindert, dass der Compiler den Typ der entsprechenden Variablen kennt. <br><br>  Anfangs war das <code>auto</code> Schlüsselwort in C ++ ziemlich begrenzt.  In neueren Versionen der Sprache wurden dann <code>auto</code> Funktionen hinzugefügt.  Hier ist ein weiteres Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//            auto! {   std::vector&lt;int&gt; c = do_something(a, b);   return c; } std::vector&lt;int&gt; a = { ... }; // #1 -  std::vector&lt;int&gt; b = { ... }; // #2  -  auto c = merge(a,b); //      </span></span></span></span></code> </pre> <br>  Die Zeilen <code>#1</code> und <code>#2</code> wenden die Variableninitialisierung mit geschweiften Klammern an - eine weitere neue Funktion in C ++ 11. <br><br>  Denken Sie daran, dass der Compiler bei Verwendung des Schlüsselworts <code>auto</code> eine Möglichkeit haben muss, auf den Typ der Variablen zu schließen. <br><br>  Nun eine interessante Frage.  Was passiert, wenn Sie ein Design wie <code>auto a = {1, 2, 3}</code> ?  Was ist das?  Vektor oder Ursache für Kompilierungsfehler? <br><br>  Tatsächlich wurde in C ++ 11 eine Konstruktion der Form <code>std::initializer_list&lt;type&gt;</code> angezeigt.  Die Liste der Initialisierungswerte in Klammern wird mit dem Schlüsselwort <code>auto</code> als Container behandelt. <br><br>  Und schließlich kann, wie bereits erwähnt, die Typinferenz durch den Compiler äußerst nützlich sein, wenn Sie mit komplexen Datenstrukturen arbeiten müssen.  Hier ist ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">populate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    !   data.insert({"a",{1,4}});   data.insert({"b",{3,1}});   data.insert({"c",{2,3}}); } auto merge(auto data, auto upcoming_data) { //         auto result = data;   for(auto it: upcoming_data) {       result.insert(it);   }   return result; } int main() {   std::map&lt;std::string, std::pair&lt;int,int&gt;&gt; data;   populate(data);   std::map&lt;std::string, std::pair&lt;int,int&gt;&gt; upcoming_data;   upcoming_data.insert({"d",{5,3}});   auto final_data = merge(data,upcoming_data);   for(auto itr: final_data) {       auto [v1, v2] = itr.second; // #1               std::cout &lt;&lt; itr.first &lt;&lt; " " &lt;&lt; v1 &lt;&lt; " " &lt;&lt; v2 &lt;&lt; std:endl;   }   return 0; }</span></span></code> </pre> <br>  Schauen Sie sich Zeile <code>#1</code> .  Der Ausdruck <code>auto [v1,v2] = itr.second</code> stellt eine neue Funktion von C ++ 17 dar. Dies ist die sogenannte Zerlegung beim Deklarieren von Variablen.  In früheren Versionen der Sprache musste jeder Wert einzeln extrahiert werden.  Dank dieses Mechanismus ist das Ausführen solcher Operationen viel bequemer geworden. <br><br>  Wenn Sie mit Daten über Links arbeiten müssen, reicht es außerdem aus, dieser Konstruktion nur ein Zeichen hinzuzufügen und es in die folgende Form zu konvertieren: <code>auto &amp;[v1,v2] = itr.second</code> . <br><br><h2>  <font color="#3AC1EF">Lambda-Ausdrücke</font> </h2><br>  C ++ 11 bietet Unterstützung für Lambda-Ausdrücke.  Sie ähneln anonymen Funktionen in JavaScript und können mit Funktionsobjekten ohne Namen verglichen werden.  Sie erfassen Variablen in verschiedenen Bereichen, abhängig von ihrer Beschreibung, für die kompakte syntaktische Konstruktionen verwendet werden.  Außerdem können sie Variablen zugeordnet werden. <br><br>  Lambda-Ausdrücke sind ein sehr nützliches Werkzeug für Fälle, in denen Sie eine kleine Operation im Code ausführen müssen, aber keine separate Funktion dafür schreiben möchten.  Ein weiteres häufiges Beispiel für ihre Verwendung ist die Erstellung von Funktionen zum Vergleichen von Werten.  Zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; data = {{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>}, {<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}}; <span class="hljs-comment"><span class="hljs-comment">//        std::sort(begin(data), end(data), [](auto a, auto b) { //   - auto!   return a.second &lt; b.second; });</span></span></code> </pre> <br>  In diesem kurzen Beispiel finden Sie viele interessante Dinge. <br><br>  Achten Sie zunächst darauf, wie bequem es ist, die variable Initialisierung mit geschweiften Klammern zu verwenden.  Als nächstes sehen wir die Standardkonstruktionen <code>begin()</code> und <code>end()</code> , die auch in C ++ 11 erschienen sind. Dann kommt die Lambda-Funktion, die als Mechanismus zum Vergleichen von Daten verwendet wird.  Die Parameter dieser Funktion werden mit dem Schlüsselwort <code>auto</code> deklariert. Diese Funktion wurde in C ++ 14 angezeigt. Bisher konnte dieses Schlüsselwort nicht zur Beschreibung der Funktionsparameter verwendet werden. <br><br>  Beachten Sie nun, dass der Lambda-Ausdruck mit eckigen Klammern beginnt - <code>[]</code> .  Dies ist die sogenannte Variablenmaske.  Es bestimmt den Umfang des Ausdrucks, dh Sie können die Beziehung des Lambda-Ausdrucks zu lokalen Variablen und Objekten steuern. <br><br>  Hier ist ein Auszug aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> Repository, das modernen C ++ - Funktionen gewidmet ist: <br><br><ul><li>  <code>[]</code> - Der Ausdruck erfasst nichts.  Dies bedeutet, dass es in einem Lambda-Ausdruck unmöglich ist, lokale Variablen aus dem externen Bereich zu verwenden.  Im Ausdruck können nur Parameter verwendet werden. </li><li>  <code>[=]</code> - Der Ausdruck erfasst die Werte lokaler Objekte (dh lokaler Variablen, Parameter).  Dies bedeutet, dass sie verwendet, aber nicht geändert werden können. </li><li>  <code>[&amp;]</code> - Der Ausdruck erfasst Verweise auf lokale Objekte.  Sie können wie im folgenden Beispiel gezeigt geändert werden. </li><li>  <code>[this]</code> - Der Ausdruck erfasst den Wert <code>this</code> Zeigers. </li><li>  <code>[a, &amp;b]</code> - Der Ausdruck erfasst den Wert von Objekt <code>a</code> und einen Verweis auf Objekt <code>b</code> . </li></ul><br>  Wenn Sie innerhalb der Lambda-Funktion die Daten in ein anderes Format konvertieren müssen, können Sie die oben genannten Mechanismen verwenden.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; data = {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> factor = <span class="hljs-number"><span class="hljs-number">7</span></span>; for_each(begin(data), end(data), [&amp;factor](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;val) { <span class="hljs-comment"><span class="hljs-comment">//    factor     val = val * factor;   factor--; // #1   - ,  -    factor   }); for(int val: data) {   std::cout &lt;&lt; val &lt;&lt; ' '; // 14 24 20 4 3 6 9 }</span></span></code> </pre> <br>  Wenn hier auf die <code>factor</code> nach Wert zugegriffen wurde (dann würde die Variablenmaske <code>[factor]</code> verwendet, um den Lambda-Ausdruck zu beschreiben), konnte der <code>factor</code> in Zeile <code>#1</code> nicht geändert werden - einfach, weil wir keine Rechte dazu hätten Durchführen einer solchen Operation.  In diesem Beispiel haben wir das Recht auf solche Aktionen.  In solchen Situationen ist es wichtig, die Funktionen, die Zugriffsvariablen als Referenz bereitstellen, nicht zu missbrauchen. <br><br>  Beachten Sie außerdem, dass auf <code>val</code> auch als Referenz zugegriffen wird.  Dies stellt sicher, dass Datenänderungen, die in der Lambda-Funktion auftreten, den <code>vector</code> beeinflussen. <br><br><h2>  <font color="#3AC1EF">Variable Initialisierungsausdrücke in if- und switch-Konstrukten</font> </h2><br>  Diese C ++ 17-Innovation hat mir sehr gut gefallen, nachdem ich davon erfahren hatte.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; input = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = input.find(<span class="hljs-number"><span class="hljs-number">7</span></span>); it==input.end()){ <span class="hljs-comment"><span class="hljs-comment">//   - ,  -    std::cout &lt;&lt; 7 &lt;&lt; " not found" &lt;&lt; std:endl; } else {   //    else      it   std::cout &lt;&lt; 7 &lt;&lt; " is there!" &lt;&lt; std::endl; }</span></span></code> </pre> <br>  Es stellt sich heraus, dass Sie jetzt die Variablen initialisieren und mit ihrer Verwendung in einem <code>if</code> oder <code>switch</code> Block vergleichen können.  Dies hilft, genauen Code zu schreiben.  Hier ist eine schematische Beschreibung der betrachteten Struktur: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( init-statement(x); condition(x)) {   <span class="hljs-comment"><span class="hljs-comment">//    } else {   //     x   //    }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Durchführen von Berechnungen zur Kompilierungszeit mit constexpr</font> </h2><br>  Das <code>constexpr</code> bietet uns großartige Möglichkeiten.  Angenommen, wir haben eine Art Ausdruck, der berechnet werden muss, während sich sein Wert nach dem Initialisieren mit der entsprechenden Variablen nicht ändert.  Ein solcher Ausdruck kann im Voraus berechnet und als Makro verwendet werden.  Oder, was in C ++ 11 möglich wurde, verwenden Sie das <code>constexpr</code> . <br><br>  Programmierer bemühen sich, den Rechenaufwand während der Programmausführung zu minimieren.  Wenn bestimmte Vorgänge während des Kompilierungsprozesses ausgeführt werden können und dadurch die Last aus dem System während der Programmausführung entfernt wird, hat dies einen guten Einfluss auf das Verhalten des Programms während der Ausführung.  Hier ist ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; constexpr long long fact(long long n) { //       constexpr return n == 1 ? 1 : (fact(n-1) * n); } int main() { const long long bigval = fact(20); std::cout&lt;&lt;bigval&lt;&lt;std::endl; }</span></span></span></span></code> </pre> <br>  Dies ist ein sehr häufiges Beispiel für die Verwendung von <code>constexpr</code> . <br><br>  Da wir die Funktion zur Berechnung der Fakultät als <code>constexpr</code> , kann der Compiler den <code>constexpr</code> <code>fact(20)</code> zum Zeitpunkt der Kompilierung des Programms vorberechnen.  Infolgedessen ist nach der Kompilierung der String <code>const long long bigval = fact(20);</code>  kann durch <code>const long long bigval = 2432902008176640000;</code>  . <br><br>  Beachten Sie, dass das an die Funktion übergebene Argument durch eine Konstante dargestellt wird.  Dies ist eine wichtige Funktion bei der Verwendung von Funktionen, die mit dem <code>constexpr</code> .  Die an sie übergebenen Argumente müssen auch mit dem <code>constexpr</code> oder mit dem Schlüsselwort <code>const</code> deklariert werden.  Andernfalls verhalten sich solche Funktionen wie normale Funktionen, dh, während der Kompilierung werden ihre Werte nicht im Voraus berechnet. <br><br>  Variablen können auch mit dem <code>constexpr</code> .  In diesem Fall müssen die Werte dieser Variablen zur Kompilierungszeit berechnet werden.  Ist dies nicht möglich, wird eine Kompilierungsfehlermeldung angezeigt. <br><br>  Es ist interessant festzustellen, dass später in C ++ 17 die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konstrukte constexpr-if</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">constexpr-lambda</a> erschienen. <br><br><h2>  <font color="#3AC1EF">Tupel-Datenstrukturen</font> </h2><br>  Wie die <code>pair</code> ist die <code>tuple</code> (Tupel) eine Sammlung von Werten verschiedener Typen einer festen Größe.  Hier ist ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-string"><span class="hljs-string">"Chowdhury"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  auto     //    std::get&lt;0&gt;(user_info); std::get&lt;1&gt;(user_info); std::get&lt;2&gt;(user_info); //  C++ 11     tie std::string first_name, last_name, age; std::tie(first_name, last_name, age) = user_info; //  C++ 17, ,       auto [first_name, last_name, age] = user_info;</span></span></code> </pre> <br>  Manchmal ist es bequemer, <code>std::array</code> anstelle einer <code>tuple</code> verwenden.  Diese Datenstruktur ähnelt den einfachen Arrays, die in der C-Sprache verwendet werden und mit zusätzlichen Funktionen aus der C ++ - Standardbibliothek ausgestattet sind.  Diese Datenstruktur wurde in C ++ 11 angezeigt. <br><br><h2>  <font color="#3AC1EF">Automatischer Rückschluss auf den Argumenttyp der Klassenvorlage</font> </h2><br>  Der Name dieser Funktion sieht ziemlich lang und komplex aus, aber tatsächlich gibt es hier nichts Kompliziertes.  Die Hauptidee hierbei ist, dass in C ++ 17 Typargumentargumente auch für Standardklassenvorlagen ausgegeben werden.  Bisher wurde dies nur für Funktionsvorlagen unterstützt.  Als Ergebnis stellt sich heraus, dass sie früher so geschrieben haben: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; user = {<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>};</code> </pre> <br>  Mit der Veröffentlichung von C ++ 17 kann diese Konstruktion nun durch folgende ersetzt werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair user = {<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>};</code> </pre> <br>  Die Typinferenz erfolgt implizit.  Dieser Mechanismus ist noch praktischer, wenn es um Tupel geht.  Nämlich bevor ich folgendes schreiben musste: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; user (<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-string"><span class="hljs-string">"Chy"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>);</code> </pre> <br>  Jetzt sieht das gleiche so aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">tuple </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"M"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Chy"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">25</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br>  Es ist erwähnenswert, dass diese Funktionen für diejenigen, die mit C ++ - Vorlagen nicht besonders vertraut sind, nicht besonders hervorzuheben sind. <br><br><h2>  <font color="#3AC1EF">Intelligente Zeiger</font> </h2><br>  Das Arbeiten mit Zeigern in C ++ kann ein wahrer Albtraum sein.  Dank der Freiheit, die die Sprache dem Programmierer gibt, ist es für ihn manchmal sehr schwierig, "sich nicht in den Fuß zu schießen".  In vielen Fällen drängen Zeiger auf einen solchen „Schuss“ des Programmierers. <br><br>  Glücklicherweise hat C ++ 11 intelligente Zeiger eingeführt, die viel praktischer sind als normale Zeiger.  Sie helfen dem Programmierer, Speicherlecks zu vermeiden, indem sie nach Möglichkeit Ressourcen freisetzen.  Darüber hinaus bieten sie eine Sicherheitsgarantie für Ausnahmen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist ein</a> gutes Repository, das unserer Meinung nach für diejenigen interessant sein wird, die den Innovationen von C ++ folgen.  In dieser Sprache taucht ständig etwas Neues auf.  Hier haben wir nur einige moderne Merkmale der Sprache angesprochen.  In der Tat gibt es viele von ihnen.  Es ist möglich, dass wir noch über sie sprechen. <br><br>  <b>Liebe Leser!</b>  Welche modernen C ++ - Funktionen finden Sie am interessantesten und nützlichsten? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451870/">https://habr.com/ru/post/de451870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451858/index.html">Erstellen eines einfachen Cache-basierten Leistungsschalters im Frühjahr</a></li>
<li><a href="../de451860/index.html">Mathematiker haben den perfekten Weg gefunden, um Zahlen zu multiplizieren</a></li>
<li><a href="../de451862/index.html">Joe Diprims musikalischer Blitz: Ein Autodidakt stellt Tesla-Spulen zur Unterhaltung und zum Verdienen her</a></li>
<li><a href="../de451864/index.html">Kritische RCE-Sicherheitsanfälligkeit der EternalBlue-Ebene unter Windows erkannt</a></li>
<li><a href="../de451866/index.html">Wählen Sie die nächsten Knoten im Netzwerk</a></li>
<li><a href="../de451872/index.html">Python ist ein Assistent bei der Suche nach günstigen Flügen für diejenigen, die gerne reisen</a></li>
<li><a href="../de451874/index.html">Top SEO Trends bei Google</a></li>
<li><a href="../de451876/index.html">Rechenzentrum Frankfurt: Rechenzentrum Telehouse</a></li>
<li><a href="../de451878/index.html">Live-Streaming von Stereovideos auf VR-Brillen (Oculus Go)</a></li>
<li><a href="../de451880/index.html">DevPRO'19: Blick vom Wrike-Stand</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>