<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤üèª üàöÔ∏è üçã Eintauchen in Linux-Namespaces, Teil 2 ü§üüèª üêΩ üëäüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im vorherigen Teil haben wir nur unsere Zehen in die Gew√§sser des Namespace getaucht und gleichzeitig gesehen, wie einfach es war, den Prozess in eine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eintauchen in Linux-Namespaces, Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459574/"><p>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Teil haben</a> wir nur unsere Zehen in die Gew√§sser des Namespace getaucht und gleichzeitig gesehen, wie einfach es war, den Prozess in einem isolierten UTS-Namespace zu starten.  In diesem Beitrag werden wir den Benutzernamensraum behandeln. </p><br><p>  Neben anderen sicherheitsrelevanten Ressourcen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">isolieren Benutzernamensr√§ume</a> die Kennungen von Benutzern und Gruppen im System.  In diesem Beitrag konzentrieren wir uns ausschlie√ülich auf Benutzer- und Gruppen-ID-Ressourcen (UID bzw. GID), da diese eine grundlegende Rolle bei der Durchf√ºhrung von Berechtigungspr√ºfungen und anderen sicherheitsrelevanten Aktivit√§ten im gesamten System spielen. </p><br><p>  Unter Linux sind diese IDs einfach Ganzzahlen, die Benutzer und Gruppen im System identifizieren.  Einige von ihnen werden jedem Prozess zugewiesen, um festzulegen, auf welche Vorg√§nge / Ressourcen dieser Prozess zugreifen kann und auf welche nicht.  Die F√§higkeit eines Prozesses, Schaden zu verursachen, h√§ngt von den Berechtigungen ab, die den zugewiesenen IDs zugeordnet sind. <a name="habracut"></a></p><br><h2 id="user-namespaces">  Benutzernamensr√§ume </h2><br><blockquote>  <em>Wir werden die Funktionen von Benutzernamensr√§umen nur anhand von Benutzer-IDs veranschaulichen.</em>  <em>Genau die gleichen Aktionen gelten f√ºr Gruppen-IDs, auf die wir sp√§ter in diesem Beitrag eingehen werden.</em> </blockquote><p> Der Benutzernamensraum verf√ºgt √ºber eine eigene Kopie der Benutzer- und Gruppenkennungen.  Durch die Isolation k√∂nnen Sie den Prozess abh√§ngig vom aktuellen Benutzernamensraum, zu dem er derzeit geh√∂rt, einem anderen Satz von IDs zuordnen.  Beispielsweise kann der <code>$pid</code> Prozess von <code>root</code> (UID 0) im Benutzernamensraum <strong>P ausgef√ºhrt werden</strong> und wird pl√∂tzlich vom <code>proxy</code> (UID 13) weiter ausgef√ºhrt, nachdem zu einem anderen Benutzernamensraum <strong>Q</strong> gewechselt wurde <strong>.</strong> </p><br><p>  Benutzerbereiche k√∂nnen verschachtelt werden!  Dies bedeutet, dass eine Instanz eines benutzerdefinierten Namespace (√ºbergeordnetes Element) null oder mehr untergeordnete Namespaces haben kann und jeder untergeordnete Namespace wiederum seine eigenen untergeordneten Namespaces usw. haben kann (bis das Limit von 32 Verschachtelungsebenen erreicht ist).  Wenn ein neuer Namespace <strong>C</strong> erstellt wird, legt Linux den aktuellen Benutzernamensraum des Prozesses <strong>P fest</strong> , der <strong>C</strong> als √ºbergeordnetes Element f√ºr <strong>C erstellt.</strong> Dies kann sp√§ter nicht mehr ge√§ndert werden.  Infolgedessen haben alle Benutzernamensr√§ume genau ein √ºbergeordnetes Element und bilden eine baumartige Struktur von Namespaces.  Und wie bei B√§umen befindet sich eine Ausnahme von dieser Regel oben, wo wir den Stamm- (oder anf√§nglichen, Standard-) Namespace haben.  Dies ist h√∂chstwahrscheinlich der Benutzernamensraum, zu dem alle Ihre Prozesse geh√∂ren, da dies nicht der einzige Benutzernamensraum seit dem Start des Systems ist, wenn Sie noch keine Art von Containermagie ausf√ºhren. </p><br><blockquote>  <em>In diesem Beitrag verwenden wir die Eingabeaufforderungen P $ und C $, um die Shell anzugeben, die derzeit im √ºbergeordneten <strong>P-</strong> bzw. untergeordneten <strong>C-</strong> Benutzernamensraum ausgef√ºhrt wird.</em> </blockquote><br><h2 id="mappingi-user-id">  Benutzer-ID-Zuordnungen </h2><br><p>  Der Benutzernamensraum enth√§lt tats√§chlich eine Reihe von Kennungen und einige Informationen, die diese IDs mit einer Reihe von IDs eines anderen Benutzernamensraums verbinden. Dieses Duett definiert eine vollst√§ndige Vorstellung der IDs der im System verf√ºgbaren Prozesse.  Mal sehen, wie es aussehen k√∂nnte: </p><br><pre> <code class="bash hljs">P$ whoami iffy P$ id uid=1000(iffy) gid=1000(iffy)</code> </pre> <br><p>  In einem anderen Terminalfenster starten wir die Shell mit <code>unshare</code> (das Flag <code>-U</code> erstellt einen Prozess im neuen Benutzernamensraum): </p><br><pre> <code class="bash hljs">P$ whoami iffy P$ unshare -U bash <span class="hljs-comment"><span class="hljs-comment">#    ,     user namespace C$ whoami nobody C$ id uid=65534(nobody) gid=65534(nogroup) C$ ls -l my_file -rw-r--r-- 1 nobody nogroup 0 May 18 16:00 my_file</span></span></code> </pre> <br><p>  Moment mal, wer?  Jetzt, wo wir uns in einer verschachtelten Shell in <strong>C befinden</strong> , wird der aktuelle Benutzer zu niemandem?  Wir haben m√∂glicherweise vermutet, dass der Prozess eine andere Art von ID hat, da <strong>C</strong> ein neuer Benutzernamensraum ist.  Deshalb haben wir wahrscheinlich nicht erwartet, dass er <code>iffy</code> bleibt, aber <code>nobody</code> ist nicht lustig.  Auf der anderen Seite ist es gro√üartig, weil wir die Isolation haben, die wir wollten.  Unser Prozess hat jetzt eine andere (wenn auch fehlerhafte) ID-Ersetzung im System - derzeit sieht er jeden als <code>nobody</code> und jede Gruppe als <code>nogroup</code> . </p><br><p>  Informationen, die eine UID von einem Benutzernamensraum mit einem anderen verkn√ºpfen, werden als <strong>Benutzer-ID-Zuordnung bezeichnet</strong> .  Es handelt sich um eine Nachschlagetabelle f√ºr √ºbereinstimmende IDs im aktuellen Benutzernamensraum f√ºr IDs in einem anderen Namespace. Jeder Benutzernamensraum ist genau einer UID-Zuordnung zugeordnet (zus√§tzlich zu einer anderen GID-Zuordnung f√ºr die Gruppen-ID). </p><br><p>  Diese Zuordnung ist das, was in unserer <code>unshare</code> Shell <code>unshare</code> .  Es stellt sich heraus, dass neue Benutzernamensr√§ume mit einer leeren Zuordnung beginnen. Infolgedessen verwendet Linux standardm√§√üig den schrecklichen Benutzer, den <code>nobody</code> .  Wir m√ºssen dies beheben, bevor wir n√ºtzliche Arbeiten in unserem neuen Namespace ausf√ºhren k√∂nnen.  Derzeit <code>setuid</code> beispielsweise Systemaufrufe (z. B. <code>setuid</code> ) fehl, die versuchen, mit der UID zu arbeiten.  Aber keine Angst!  Gem√§√ü der <em>All-is-File-</em> Tradition pr√§sentiert Linux diese Zuordnung mithilfe des Dateisystems <code>/proc</code> in <code>/proc/$pid/uid_map</code> (in <code>/proc/$pid/gid_map</code> f√ºr die GID), wobei <code>$pid</code> die Prozess-ID ist.  Wir werden diese beiden Dateien als <em>Map-Dateien bezeichnen.</em> </p><br><h2 id="map-fayly">  Kartendateien </h2><br><p>  Kartendateien sind spezielle Dateien im System.  Was ist das Besondere?  Nun, indem Sie jedes Mal, wenn Sie daraus lesen, unterschiedliche Inhalte zur√ºckgeben, je nachdem, was Ihr Prozess liest.  Beispielsweise gibt die Map-Datei <code>/proc/$pid/uid_maps</code> die Zuordnung von UIDs aus dem Benutzernamensraum zur√ºck, zu dem der <code>$pid</code> Prozess geh√∂rt, UIDs im Benutzernamensraum des Leseprozesses.  Infolgedessen kann der an Prozess <strong>X</strong> zur√ºckgegebene Inhalt von dem an Prozess <strong>Y zur√ºckgegebenen</strong> Inhalt abweichen, selbst wenn dieselbe Zuordnungsdatei gleichzeitig gelesen wird. </p><br><p>  Insbesondere Prozess <strong>X</strong> , der die UID-Zuordnungsdatei <code>/proc/$pid/uid_map</code> , empf√§ngt eine Reihe von Zeichenfolgen.  Jede Zeile ordnet dem Benutzernamenraum <strong>C des</strong> <code>$pid</code> Prozesses einen fortlaufenden Bereich von UIDs zu, der einem Bereich von UIDs in einem anderen Namespace entspricht. </p><br><p>  Jede Zeile hat das Format <code>$fromID $toID $length</code> , wobei: </p><br><ul><li>  <code>$fromID</code> ist die Start-UID des Bereichs f√ºr den Benutzernamensraum des <code>$pid</code> Prozesses </li><li>  <code>$lenght</code> ist die L√§nge des Bereichs. </li><li>  Die √úbersetzung von <code>$toID</code> h√§ngt vom Lesevorgang <strong>X ab.</strong>  Wenn <strong>X</strong> zu einem anderen Benutzernamensraum <strong>U geh√∂rt</strong> , ist <code>$toID</code> die Start-UID des Bereichs in <strong>U</strong> , der von <code>$fromID</code> .  Andernfalls ist <code>$toID</code> die Start-UID des Bereichs in <strong>P</strong> , dem √ºbergeordneten Benutzernamensraum von Prozess <strong>C.</strong> </li></ul><br><p>  Wenn ein Prozess beispielsweise die Datei <code>/proc/1409/uid_map</code> und unter den empfangenen Zeilen <code>15 22 5</code> <code>/proc/1409/uid_map</code> die <code>/proc/1409/uid_map</code> 15 bis 19 im Benutzernamensraum des Prozesses <code>1409</code> UIDs 22-26 eines separaten Benutzernamensraums des Leseprozesses zugeordnet. </p><br><p>  Wenn andererseits ein Prozess aus der Datei <code>/proc/$$/uid_map</code> (oder einer Zuordnungsdatei eines Prozesses, der zum selben Benutzernamensraum wie der Lesevorgang geh√∂rt) liest und <code>15 22 5</code> empf√§ngt, werden UIDs von 15 bis 19 in Der Benutzernamensraum <strong>C</strong> wird UIDs von 22 bis 26 des √ºbergeordneten <strong>C-</strong> Benutzernamens zugeordnet. </p><br><p>  Probieren wir es aus: </p><br><pre> <code class="bash hljs">P$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ 1442 <span class="hljs-comment"><span class="hljs-comment">#   user namespace... C$ echo $$ 1409 # C      ,     C$ cat /proc/1409/uid_map #  #   namespace P      # UIDs    UID    P$ cat /proc/1442/uid_map 0 0 4294967295 # UIDs  0  4294967294  P  #  4294967295 -  ID no user -  C. C$ cat /proc/1409/uid_map 0 4294967295 4294967295</span></span></code> </pre> <br><p>  Nun, das war nicht sehr aufregend, da dies zwei Extremf√§lle waren, aber das sagt ein paar Dinge aus: </p><br><ol><li>  Der neu erstellte Benutzernamensraum enth√§lt tats√§chlich leere Kartendateien. </li><li>  Die UID 4294967295 ist nicht abbildbar und auch f√ºr die Verwendung im <code>root</code> Benutzernamensraum ungeeignet.  Linux verwendet diese UID speziell, um das <strong>Fehlen einer Benutzer-ID</strong> anzuzeigen. </li></ol><br><h2 id="napisanie-uid-map-faylov">  Schreiben von UID-Map-Dateien </h2><br><p>  Um unseren neu erstellten Benutzernamensraum <strong>C</strong> zu reparieren, m√ºssen wir nur die erforderlichen Zuordnungen bereitstellen, indem wir deren Inhalt in Zuordnungsdateien f√ºr jeden Prozess schreiben, der zu <strong>C geh√∂rt</strong> (wir k√∂nnen diese Datei nach dem Schreiben nicht aktualisieren).  Das Schreiben in diese Datei sagt Linux zwei Dinge: </p><br><ol><li>  Welche UIDs sind f√ºr Prozesse verf√ºgbar, die sich auf den Zielbenutzernamensraum <strong>C</strong> beziehen? </li><li>  Welche UIDs im aktuellen Benutzernamensraum entsprechen den UIDs in <strong>C.</strong> </li></ol><br><p>  Wenn wir beispielsweise Folgendes aus dem √ºbergeordneten Benutzernamensraum <strong>P</strong> in die Zuordnungsdatei f√ºr den untergeordneten <strong>C-</strong> Namespace schreiben: </p><br><pre> <code class="plaintext hljs">0 1000 1 3 0 1</code> </pre> <br><p>  Wir sagen Linux im Wesentlichen, dass: </p><br><ol><li>  F√ºr Prozesse in <strong>C</strong> sind die einzigen im System vorhandenen UIDs die UIDs <code>0</code> und <code>3</code> .  Beispielsweise endet der Systemaufruf <code>setuid(9)</code> immer mit einer <em>ung√ºltigen Benutzer-ID</em> . </li><li>  Die UIDs <code>1000</code> und <code>0</code> in <strong>P</strong> entsprechen den UIDs <code>0</code> und <code>3</code> in <strong>C.</strong>  Wenn beispielsweise ein Prozess, der mit UID <code>1000</code> in <strong>P ausgef√ºhrt wird,</strong> auf <strong>C</strong> umschaltet, stellt er fest, dass seine UID nach dem Umschalten zu <code>root</code> <code>0</code> . </li></ol><br><h2 id="vladelec-prostranstv-imyon-i-privilegii">  Namespace und Berechtigungsinhaber </h2><br><p>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Beitrag haben</a> wir erw√§hnt, dass beim Erstellen neuer Namespaces ein Zugriff mit Superuser-Ebene erforderlich ist.  Benutzernamensr√§ume stellen diese Anforderung nicht.  Ein weiteres Merkmal ist, dass sie andere Namespaces besitzen k√∂nnen. </p><br><p>  Immer wenn ein Nichtbenutzernamensraum <strong>N erstellt wird</strong> , weist Linux den aktuellen Benutzernamensraum <strong>P des</strong> Prozesses, der <strong>N</strong> erstellt <strong>,</strong> als <em>Eigent√ºmer des</em> Namespace <strong>N zu.</strong>  Wenn <strong>P</strong> zusammen mit anderen Namespaces im selben <code>clone</code> wird, stellt Linux sicher, dass <strong>P</strong> zuerst erstellt und zum Eigent√ºmer anderer Namespaces gemacht wird. </p><br><p>  Der Eigent√ºmer von Namespaces ist wichtig, da bei einem Prozess, der eine privilegierte Aktion f√ºr eine Ressource anfordert, die kein Benutzernamensraum ist, die UID-Berechtigungen gegen den Eigent√ºmer dieses Benutzernamensraums und nicht gegen den Stammbenutzernamensraum gepr√ºft werden.  Angenommen, <strong>P</strong> ist der √ºbergeordnete Benutzernamensraum des untergeordneten <strong>C</strong> , und <strong>P</strong> und <strong>C</strong> besitzen ihren eigenen Netzwerk-Namespace <strong>M</strong> bzw. <strong>N.</strong>  Ein Prozess verf√ºgt m√∂glicherweise nicht √ºber Berechtigungen zum Erstellen der in <strong>M</strong> enthaltenen Netzwerkger√§te, kann dies jedoch m√∂glicherweise f√ºr <strong>N</strong> tun <strong>.</strong> </p><br><p>  Die Konsequenz eines Namespace-Besitzers f√ºr uns ist, dass wir die <code>sudo</code> Anforderung <code>unshare</code> <code>isolate</code> wenn Befehle mit <code>unshare</code> oder <code>isolate</code> wenn wir auch die Erstellung eines Benutzernamensraums anfordern.  Zum Beispiel erfordert <code>unshare -u bash</code> <code>sudo</code> , aber <code>unshare -Uu bash</code> ist nicht mehr: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># UID 1000 --      user namespace P. P$ id uid=1000(iffy) gid=1000(iffy) #           # network namespace. P$ ip link add type veth RTNETLINK answers: Operation not permitted #     ,     #  user  network namespace P$ unshare -nU bash # :  sudo C$ ip link add type veth RTNETLINK answers: Operation not permitted # ,  . ,  # UID 0 (root)    ,  #     nobody.   . C$ echo $$ 13294 #   P,   UID 1000  P  UID 0  C P$ echo "0 1000 1" &gt; /proc/13294/uid_map #   ? C$ id uid=0(root) gid=65534(nogroup) C$ ip link add type veth # !</span></span></code> </pre> <br><blockquote>  <em>Leider werden wir die Superuser-Anforderung im n√§chsten Beitrag erneut anwenden, da <code>isolate</code> <code>root</code> Berechtigungen im Root-Benutzernamensraum ben√∂tigt, um den Mount- und Netzwerk-Namespace korrekt zu konfigurieren.</em>  <em>Aber wir werden sicherlich die Berechtigungen des Teamprozesses fallen lassen, um sicherzustellen, dass das Team nicht √ºber unn√∂tige Berechtigungen verf√ºgt.</em> </blockquote><br><h2 id="kak-razreshayutsya-id">  Wie IDs aufgel√∂st werden </h2><br><p>  Wir haben gerade einen Prozess gesehen, der ausgef√ºhrt wurde, als ein regul√§rer Benutzer <code>1000</code> pl√∂tzlich zu <code>root</code> .  Keine Sorge, es gab keine Eskalation der Privilegien.  Denken Sie daran, dass dies nur eine <em>Zuordnungs-</em> ID ist: W√§hrend unser Prozess <em>denkt,</em> dass es sich um den <code>root</code> auf dem System handelt, wei√ü Linux, dass <code>root</code> in seinem Fall die √ºbliche UID <code>1000</code> (dank unserer Zuordnung).  Zu einer Zeit, in der Namespaces, die zu seinem neuen Benutzernamensraum geh√∂ren (wie der Netzwerknamespace in <strong>C</strong> ), seine Rechte als <code>root</code> , tun dies andere (wie der Netzwerknamespace in <strong>P</strong> ) nicht.  Daher kann der Prozess nichts tun, was der Benutzer <code>1000</code> nicht k√∂nnte. </p><br><p>  Wenn ein Prozess in einem verschachtelten Benutzernamensraum eine Operation ausf√ºhrt, f√ºr die eine Berechtigungspr√ºfung erforderlich ist, z. B. das Erstellen einer Datei, wird seine UID in diesem Benutzernamensraum mit der entsprechenden Benutzer-ID im Stammbenutzernamensraum verglichen, indem die Zuordnungen im Namespace-Baum zum Stamm √ºbertragen werden.  Es gibt eine Bewegung in die entgegengesetzte Richtung, zum Beispiel wenn er Benutzer-IDs liest, wie wir es mit <code>ls -l my_file</code> .  Die UID des Besitzers <code>my_file</code> vom <code>my_file</code> dem aktuellen zugeordnet, und die endg√ºltige entsprechende ID (oder niemand, wenn die Zuordnung irgendwo im gesamten Baum fehlte) wird dem Lesevorgang √ºbergeben. </p><br><h2 id="gruppovye-id">  Gruppen-ID </h2><br><p>  Selbst wenn wir in <strong>C</strong> verwurzelt waren, sind wir immer noch mit der schrecklichen <code>nogroup</code> als Gruppen-ID verbunden.  Wir m√ºssen dasselbe f√ºr die entsprechende <code>/proc/$pid/gid_map</code> .  Bevor wir dies tun k√∂nnen, m√ºssen wir den <code>setgroups</code> deaktivieren (dies ist nicht erforderlich, wenn unser Benutzer bereits √ºber eine <code>CAP_SETGID</code> Funktion in <strong>P</strong> verf√ºgt, dies wird jedoch nicht angenommen, da dies normalerweise mit Superuser-Berechtigungen verbunden ist), indem wir "verweigern" schreiben "zur Datei <code>proc/$pid/setgroups</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  13294 -- pid  unshared  C$ id uid=0(root) gid=65534(nogroup) P$ echo deny &gt; /proc/13294/setgroups P$ echo "0 1000 1" &gt; /proc/13294/gid_map #  group ID   C$ id uid=0(root) gid=0(root)</span></span></code> </pre> <br><h2 id="realizaciya">  Implementierung </h2><br><blockquote>  <em>Den Quellcode f√ºr diesen Beitrag finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .</em> </blockquote><p>  Wie Sie sehen, gibt es viele Schwierigkeiten bei der Verwaltung von Benutzernamensr√§umen, aber die Implementierung ist recht einfach.  Wir m√ºssen nur ein paar Zeilen in eine Datei schreiben - es war trostlos herauszufinden, was und wo wir schreiben sollen.  Hier sind ohne weiteres unsere Ziele: </p><br><ol><li>  Klonen Sie einen Teamprozess in einem eigenen Benutzernamensraum. </li><li>  Schreiben Sie in die UID- und GID-Map-Dateien des Teamprozesses. </li><li>  Setzen Sie alle Superuser-Berechtigungen zur√ºck, bevor Sie den Befehl ausf√ºhren. </li></ol><br><p>  <code>1</code> erreicht, indem einfach das <code>CLONE_NEWUSER</code> Flag zu unserem <code>CLONE_NEWUSER</code> hinzugef√ºgt wird. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> clone_flags = SIGCHLD | CLONE_NEWUTS | CLONE_NEWUSER;</code> </pre> <br><p>  F√ºr <code>2</code> f√ºgen wir die Funktion <code>prepare_user_ns</code> , die sorgf√§ltig einen regul√§ren Benutzer <code>1000</code> als <code>root</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare_userns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> path[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> line[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> uid = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/uid_map"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"0 %d 1\n"</span></span>, uid); write_file(path, line); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/setgroups"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"deny"</span></span>); write_file(path, line); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/gid_map"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"0 %d 1\n"</span></span>, uid); write_file(path, line); }</code> </pre> <br><p>  Und wir werden es vom Hauptprozess im √ºbergeordneten Benutzernamensraum aufrufen, bevor wir den Befehlsprozess signalisieren. </p><br><pre> <code class="cpp hljs"> ... <span class="hljs-comment"><span class="hljs-comment">//      . int pipe = params.fd[1]; //      namespace ... prepare_userns(cmd_pid); //   ,     . ...</span></span></code> </pre> <br><p>  In Schritt <code>3</code> aktualisieren wir die Funktion <code>cmd_exec</code> , um sicherzustellen, dass der Befehl von dem √ºblichen nicht privilegierten Benutzer <code>1000</code> , den wir in der Zuordnung angegeben haben (denken Sie daran, dass der <code>cmd_exec</code> <code>0</code> im Benutzernamensraum des Teamprozesses Benutzer <code>1000</code> ): </p><br><pre> <code class="cpp hljs"> ... <span class="hljs-comment"><span class="hljs-comment">//   ' '   . await_setup(params-&gt;fd[0]); if (setgid(0) == -1) die("Failed to setgid: %m\n"); if (setuid(0) == -1) die("Failed to setuid: %m\n"); ...</span></span></code> </pre> <br><p>  Und das ist alles!  <code>isolate</code> startet den Prozess jetzt in einem isolierten Benutzernamensraum. </p><br><pre> <code class="bash hljs">$ ./isolate sh ===========sh============ $ id uid=0(root) gid=0(root)</code> </pre> <br><p>  In diesem Beitrag gab es einige Details zur Funktionsweise von Benutzernamensr√§umen, aber am Ende war das Einrichten der Instanz relativ schmerzlos.  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">n√§chsten Beitrag werden</a> wir die M√∂glichkeit untersuchen, einen Befehl in unserem eigenen Mount-Namespace mit <code>isolate</code> <code>Dockerfile</code> (das Geheimnis hinter der <code>FROM</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anweisung</a> aus der <code>Dockerfile</code> ).  Dort m√ºssen wir Linux ein bisschen mehr helfen, um die Instanz richtig zu konfigurieren. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459574/">https://habr.com/ru/post/de459574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459560/index.html">Funktionen von Container-Rechenzentren: Fertige Vermittlungsstelle in Myanmar in 50 Tagen</a></li>
<li><a href="../de459562/index.html">Differenzierbare Programmierung</a></li>
<li><a href="../de459564/index.html">Was Entwickler √ºber das Gesch√§ft wissen m√ºssen</a></li>
<li><a href="../de459568/index.html">Vertikaler Buchstabe in der modernen IT</a></li>
<li><a href="../de459570/index.html">Beeline zeigt Anzeigen f√ºr Google Bot. Bot ungl√ºcklich</a></li>
<li><a href="../de459576/index.html">N√ºtzliche Google Chrome-Erweiterungen f√ºr den Programmierer</a></li>
<li><a href="../de459578/index.html">√ñffentliches Sektor Offenes Projektmanagementsystem</a></li>
<li><a href="../de459580/index.html">Virtuelle Telefonsysteme</a></li>
<li><a href="../de459582/index.html">√úberblick: Wie kaufe ich Aktien amerikanischer Unternehmen aus Russland?</a></li>
<li><a href="../de459584/index.html">Ich habe einen gro√üartigen Programmierer namens Steve Wozniak gefunden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>