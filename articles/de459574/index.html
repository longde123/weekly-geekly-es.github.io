<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏻 🈚️ 🍋 Eintauchen in Linux-Namespaces, Teil 2 🤟🏻 🐽 👊🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im vorherigen Teil haben wir nur unsere Zehen in die Gewässer des Namespace getaucht und gleichzeitig gesehen, wie einfach es war, den Prozess in eine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eintauchen in Linux-Namespaces, Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459574/"><p>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Teil haben</a> wir nur unsere Zehen in die Gewässer des Namespace getaucht und gleichzeitig gesehen, wie einfach es war, den Prozess in einem isolierten UTS-Namespace zu starten.  In diesem Beitrag werden wir den Benutzernamensraum behandeln. </p><br><p>  Neben anderen sicherheitsrelevanten Ressourcen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">isolieren Benutzernamensräume</a> die Kennungen von Benutzern und Gruppen im System.  In diesem Beitrag konzentrieren wir uns ausschließlich auf Benutzer- und Gruppen-ID-Ressourcen (UID bzw. GID), da diese eine grundlegende Rolle bei der Durchführung von Berechtigungsprüfungen und anderen sicherheitsrelevanten Aktivitäten im gesamten System spielen. </p><br><p>  Unter Linux sind diese IDs einfach Ganzzahlen, die Benutzer und Gruppen im System identifizieren.  Einige von ihnen werden jedem Prozess zugewiesen, um festzulegen, auf welche Vorgänge / Ressourcen dieser Prozess zugreifen kann und auf welche nicht.  Die Fähigkeit eines Prozesses, Schaden zu verursachen, hängt von den Berechtigungen ab, die den zugewiesenen IDs zugeordnet sind. <a name="habracut"></a></p><br><h2 id="user-namespaces">  Benutzernamensräume </h2><br><blockquote>  <em>Wir werden die Funktionen von Benutzernamensräumen nur anhand von Benutzer-IDs veranschaulichen.</em>  <em>Genau die gleichen Aktionen gelten für Gruppen-IDs, auf die wir später in diesem Beitrag eingehen werden.</em> </blockquote><p> Der Benutzernamensraum verfügt über eine eigene Kopie der Benutzer- und Gruppenkennungen.  Durch die Isolation können Sie den Prozess abhängig vom aktuellen Benutzernamensraum, zu dem er derzeit gehört, einem anderen Satz von IDs zuordnen.  Beispielsweise kann der <code>$pid</code> Prozess von <code>root</code> (UID 0) im Benutzernamensraum <strong>P ausgeführt werden</strong> und wird plötzlich vom <code>proxy</code> (UID 13) weiter ausgeführt, nachdem zu einem anderen Benutzernamensraum <strong>Q</strong> gewechselt wurde <strong>.</strong> </p><br><p>  Benutzerbereiche können verschachtelt werden!  Dies bedeutet, dass eine Instanz eines benutzerdefinierten Namespace (übergeordnetes Element) null oder mehr untergeordnete Namespaces haben kann und jeder untergeordnete Namespace wiederum seine eigenen untergeordneten Namespaces usw. haben kann (bis das Limit von 32 Verschachtelungsebenen erreicht ist).  Wenn ein neuer Namespace <strong>C</strong> erstellt wird, legt Linux den aktuellen Benutzernamensraum des Prozesses <strong>P fest</strong> , der <strong>C</strong> als übergeordnetes Element für <strong>C erstellt.</strong> Dies kann später nicht mehr geändert werden.  Infolgedessen haben alle Benutzernamensräume genau ein übergeordnetes Element und bilden eine baumartige Struktur von Namespaces.  Und wie bei Bäumen befindet sich eine Ausnahme von dieser Regel oben, wo wir den Stamm- (oder anfänglichen, Standard-) Namespace haben.  Dies ist höchstwahrscheinlich der Benutzernamensraum, zu dem alle Ihre Prozesse gehören, da dies nicht der einzige Benutzernamensraum seit dem Start des Systems ist, wenn Sie noch keine Art von Containermagie ausführen. </p><br><blockquote>  <em>In diesem Beitrag verwenden wir die Eingabeaufforderungen P $ und C $, um die Shell anzugeben, die derzeit im übergeordneten <strong>P-</strong> bzw. untergeordneten <strong>C-</strong> Benutzernamensraum ausgeführt wird.</em> </blockquote><br><h2 id="mappingi-user-id">  Benutzer-ID-Zuordnungen </h2><br><p>  Der Benutzernamensraum enthält tatsächlich eine Reihe von Kennungen und einige Informationen, die diese IDs mit einer Reihe von IDs eines anderen Benutzernamensraums verbinden. Dieses Duett definiert eine vollständige Vorstellung der IDs der im System verfügbaren Prozesse.  Mal sehen, wie es aussehen könnte: </p><br><pre> <code class="bash hljs">P$ whoami iffy P$ id uid=1000(iffy) gid=1000(iffy)</code> </pre> <br><p>  In einem anderen Terminalfenster starten wir die Shell mit <code>unshare</code> (das Flag <code>-U</code> erstellt einen Prozess im neuen Benutzernamensraum): </p><br><pre> <code class="bash hljs">P$ whoami iffy P$ unshare -U bash <span class="hljs-comment"><span class="hljs-comment">#    ,     user namespace C$ whoami nobody C$ id uid=65534(nobody) gid=65534(nogroup) C$ ls -l my_file -rw-r--r-- 1 nobody nogroup 0 May 18 16:00 my_file</span></span></code> </pre> <br><p>  Moment mal, wer?  Jetzt, wo wir uns in einer verschachtelten Shell in <strong>C befinden</strong> , wird der aktuelle Benutzer zu niemandem?  Wir haben möglicherweise vermutet, dass der Prozess eine andere Art von ID hat, da <strong>C</strong> ein neuer Benutzernamensraum ist.  Deshalb haben wir wahrscheinlich nicht erwartet, dass er <code>iffy</code> bleibt, aber <code>nobody</code> ist nicht lustig.  Auf der anderen Seite ist es großartig, weil wir die Isolation haben, die wir wollten.  Unser Prozess hat jetzt eine andere (wenn auch fehlerhafte) ID-Ersetzung im System - derzeit sieht er jeden als <code>nobody</code> und jede Gruppe als <code>nogroup</code> . </p><br><p>  Informationen, die eine UID von einem Benutzernamensraum mit einem anderen verknüpfen, werden als <strong>Benutzer-ID-Zuordnung bezeichnet</strong> .  Es handelt sich um eine Nachschlagetabelle für übereinstimmende IDs im aktuellen Benutzernamensraum für IDs in einem anderen Namespace. Jeder Benutzernamensraum ist genau einer UID-Zuordnung zugeordnet (zusätzlich zu einer anderen GID-Zuordnung für die Gruppen-ID). </p><br><p>  Diese Zuordnung ist das, was in unserer <code>unshare</code> Shell <code>unshare</code> .  Es stellt sich heraus, dass neue Benutzernamensräume mit einer leeren Zuordnung beginnen. Infolgedessen verwendet Linux standardmäßig den schrecklichen Benutzer, den <code>nobody</code> .  Wir müssen dies beheben, bevor wir nützliche Arbeiten in unserem neuen Namespace ausführen können.  Derzeit <code>setuid</code> beispielsweise Systemaufrufe (z. B. <code>setuid</code> ) fehl, die versuchen, mit der UID zu arbeiten.  Aber keine Angst!  Gemäß der <em>All-is-File-</em> Tradition präsentiert Linux diese Zuordnung mithilfe des Dateisystems <code>/proc</code> in <code>/proc/$pid/uid_map</code> (in <code>/proc/$pid/gid_map</code> für die GID), wobei <code>$pid</code> die Prozess-ID ist.  Wir werden diese beiden Dateien als <em>Map-Dateien bezeichnen.</em> </p><br><h2 id="map-fayly">  Kartendateien </h2><br><p>  Kartendateien sind spezielle Dateien im System.  Was ist das Besondere?  Nun, indem Sie jedes Mal, wenn Sie daraus lesen, unterschiedliche Inhalte zurückgeben, je nachdem, was Ihr Prozess liest.  Beispielsweise gibt die Map-Datei <code>/proc/$pid/uid_maps</code> die Zuordnung von UIDs aus dem Benutzernamensraum zurück, zu dem der <code>$pid</code> Prozess gehört, UIDs im Benutzernamensraum des Leseprozesses.  Infolgedessen kann der an Prozess <strong>X</strong> zurückgegebene Inhalt von dem an Prozess <strong>Y zurückgegebenen</strong> Inhalt abweichen, selbst wenn dieselbe Zuordnungsdatei gleichzeitig gelesen wird. </p><br><p>  Insbesondere Prozess <strong>X</strong> , der die UID-Zuordnungsdatei <code>/proc/$pid/uid_map</code> , empfängt eine Reihe von Zeichenfolgen.  Jede Zeile ordnet dem Benutzernamenraum <strong>C des</strong> <code>$pid</code> Prozesses einen fortlaufenden Bereich von UIDs zu, der einem Bereich von UIDs in einem anderen Namespace entspricht. </p><br><p>  Jede Zeile hat das Format <code>$fromID $toID $length</code> , wobei: </p><br><ul><li>  <code>$fromID</code> ist die Start-UID des Bereichs für den Benutzernamensraum des <code>$pid</code> Prozesses </li><li>  <code>$lenght</code> ist die Länge des Bereichs. </li><li>  Die Übersetzung von <code>$toID</code> hängt vom Lesevorgang <strong>X ab.</strong>  Wenn <strong>X</strong> zu einem anderen Benutzernamensraum <strong>U gehört</strong> , ist <code>$toID</code> die Start-UID des Bereichs in <strong>U</strong> , der von <code>$fromID</code> .  Andernfalls ist <code>$toID</code> die Start-UID des Bereichs in <strong>P</strong> , dem übergeordneten Benutzernamensraum von Prozess <strong>C.</strong> </li></ul><br><p>  Wenn ein Prozess beispielsweise die Datei <code>/proc/1409/uid_map</code> und unter den empfangenen Zeilen <code>15 22 5</code> <code>/proc/1409/uid_map</code> die <code>/proc/1409/uid_map</code> 15 bis 19 im Benutzernamensraum des Prozesses <code>1409</code> UIDs 22-26 eines separaten Benutzernamensraums des Leseprozesses zugeordnet. </p><br><p>  Wenn andererseits ein Prozess aus der Datei <code>/proc/$$/uid_map</code> (oder einer Zuordnungsdatei eines Prozesses, der zum selben Benutzernamensraum wie der Lesevorgang gehört) liest und <code>15 22 5</code> empfängt, werden UIDs von 15 bis 19 in Der Benutzernamensraum <strong>C</strong> wird UIDs von 22 bis 26 des übergeordneten <strong>C-</strong> Benutzernamens zugeordnet. </p><br><p>  Probieren wir es aus: </p><br><pre> <code class="bash hljs">P$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ 1442 <span class="hljs-comment"><span class="hljs-comment">#   user namespace... C$ echo $$ 1409 # C      ,     C$ cat /proc/1409/uid_map #  #   namespace P      # UIDs    UID    P$ cat /proc/1442/uid_map 0 0 4294967295 # UIDs  0  4294967294  P  #  4294967295 -  ID no user -  C. C$ cat /proc/1409/uid_map 0 4294967295 4294967295</span></span></code> </pre> <br><p>  Nun, das war nicht sehr aufregend, da dies zwei Extremfälle waren, aber das sagt ein paar Dinge aus: </p><br><ol><li>  Der neu erstellte Benutzernamensraum enthält tatsächlich leere Kartendateien. </li><li>  Die UID 4294967295 ist nicht abbildbar und auch für die Verwendung im <code>root</code> Benutzernamensraum ungeeignet.  Linux verwendet diese UID speziell, um das <strong>Fehlen einer Benutzer-ID</strong> anzuzeigen. </li></ol><br><h2 id="napisanie-uid-map-faylov">  Schreiben von UID-Map-Dateien </h2><br><p>  Um unseren neu erstellten Benutzernamensraum <strong>C</strong> zu reparieren, müssen wir nur die erforderlichen Zuordnungen bereitstellen, indem wir deren Inhalt in Zuordnungsdateien für jeden Prozess schreiben, der zu <strong>C gehört</strong> (wir können diese Datei nach dem Schreiben nicht aktualisieren).  Das Schreiben in diese Datei sagt Linux zwei Dinge: </p><br><ol><li>  Welche UIDs sind für Prozesse verfügbar, die sich auf den Zielbenutzernamensraum <strong>C</strong> beziehen? </li><li>  Welche UIDs im aktuellen Benutzernamensraum entsprechen den UIDs in <strong>C.</strong> </li></ol><br><p>  Wenn wir beispielsweise Folgendes aus dem übergeordneten Benutzernamensraum <strong>P</strong> in die Zuordnungsdatei für den untergeordneten <strong>C-</strong> Namespace schreiben: </p><br><pre> <code class="plaintext hljs">0 1000 1 3 0 1</code> </pre> <br><p>  Wir sagen Linux im Wesentlichen, dass: </p><br><ol><li>  Für Prozesse in <strong>C</strong> sind die einzigen im System vorhandenen UIDs die UIDs <code>0</code> und <code>3</code> .  Beispielsweise endet der Systemaufruf <code>setuid(9)</code> immer mit einer <em>ungültigen Benutzer-ID</em> . </li><li>  Die UIDs <code>1000</code> und <code>0</code> in <strong>P</strong> entsprechen den UIDs <code>0</code> und <code>3</code> in <strong>C.</strong>  Wenn beispielsweise ein Prozess, der mit UID <code>1000</code> in <strong>P ausgeführt wird,</strong> auf <strong>C</strong> umschaltet, stellt er fest, dass seine UID nach dem Umschalten zu <code>root</code> <code>0</code> . </li></ol><br><h2 id="vladelec-prostranstv-imyon-i-privilegii">  Namespace und Berechtigungsinhaber </h2><br><p>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Beitrag haben</a> wir erwähnt, dass beim Erstellen neuer Namespaces ein Zugriff mit Superuser-Ebene erforderlich ist.  Benutzernamensräume stellen diese Anforderung nicht.  Ein weiteres Merkmal ist, dass sie andere Namespaces besitzen können. </p><br><p>  Immer wenn ein Nichtbenutzernamensraum <strong>N erstellt wird</strong> , weist Linux den aktuellen Benutzernamensraum <strong>P des</strong> Prozesses, der <strong>N</strong> erstellt <strong>,</strong> als <em>Eigentümer des</em> Namespace <strong>N zu.</strong>  Wenn <strong>P</strong> zusammen mit anderen Namespaces im selben <code>clone</code> wird, stellt Linux sicher, dass <strong>P</strong> zuerst erstellt und zum Eigentümer anderer Namespaces gemacht wird. </p><br><p>  Der Eigentümer von Namespaces ist wichtig, da bei einem Prozess, der eine privilegierte Aktion für eine Ressource anfordert, die kein Benutzernamensraum ist, die UID-Berechtigungen gegen den Eigentümer dieses Benutzernamensraums und nicht gegen den Stammbenutzernamensraum geprüft werden.  Angenommen, <strong>P</strong> ist der übergeordnete Benutzernamensraum des untergeordneten <strong>C</strong> , und <strong>P</strong> und <strong>C</strong> besitzen ihren eigenen Netzwerk-Namespace <strong>M</strong> bzw. <strong>N.</strong>  Ein Prozess verfügt möglicherweise nicht über Berechtigungen zum Erstellen der in <strong>M</strong> enthaltenen Netzwerkgeräte, kann dies jedoch möglicherweise für <strong>N</strong> tun <strong>.</strong> </p><br><p>  Die Konsequenz eines Namespace-Besitzers für uns ist, dass wir die <code>sudo</code> Anforderung <code>unshare</code> <code>isolate</code> wenn Befehle mit <code>unshare</code> oder <code>isolate</code> wenn wir auch die Erstellung eines Benutzernamensraums anfordern.  Zum Beispiel erfordert <code>unshare -u bash</code> <code>sudo</code> , aber <code>unshare -Uu bash</code> ist nicht mehr: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># UID 1000 --      user namespace P. P$ id uid=1000(iffy) gid=1000(iffy) #           # network namespace. P$ ip link add type veth RTNETLINK answers: Operation not permitted #     ,     #  user  network namespace P$ unshare -nU bash # :  sudo C$ ip link add type veth RTNETLINK answers: Operation not permitted # ,  . ,  # UID 0 (root)    ,  #     nobody.   . C$ echo $$ 13294 #   P,   UID 1000  P  UID 0  C P$ echo "0 1000 1" &gt; /proc/13294/uid_map #   ? C$ id uid=0(root) gid=65534(nogroup) C$ ip link add type veth # !</span></span></code> </pre> <br><blockquote>  <em>Leider werden wir die Superuser-Anforderung im nächsten Beitrag erneut anwenden, da <code>isolate</code> <code>root</code> Berechtigungen im Root-Benutzernamensraum benötigt, um den Mount- und Netzwerk-Namespace korrekt zu konfigurieren.</em>  <em>Aber wir werden sicherlich die Berechtigungen des Teamprozesses fallen lassen, um sicherzustellen, dass das Team nicht über unnötige Berechtigungen verfügt.</em> </blockquote><br><h2 id="kak-razreshayutsya-id">  Wie IDs aufgelöst werden </h2><br><p>  Wir haben gerade einen Prozess gesehen, der ausgeführt wurde, als ein regulärer Benutzer <code>1000</code> plötzlich zu <code>root</code> .  Keine Sorge, es gab keine Eskalation der Privilegien.  Denken Sie daran, dass dies nur eine <em>Zuordnungs-</em> ID ist: Während unser Prozess <em>denkt,</em> dass es sich um den <code>root</code> auf dem System handelt, weiß Linux, dass <code>root</code> in seinem Fall die übliche UID <code>1000</code> (dank unserer Zuordnung).  Zu einer Zeit, in der Namespaces, die zu seinem neuen Benutzernamensraum gehören (wie der Netzwerknamespace in <strong>C</strong> ), seine Rechte als <code>root</code> , tun dies andere (wie der Netzwerknamespace in <strong>P</strong> ) nicht.  Daher kann der Prozess nichts tun, was der Benutzer <code>1000</code> nicht könnte. </p><br><p>  Wenn ein Prozess in einem verschachtelten Benutzernamensraum eine Operation ausführt, für die eine Berechtigungsprüfung erforderlich ist, z. B. das Erstellen einer Datei, wird seine UID in diesem Benutzernamensraum mit der entsprechenden Benutzer-ID im Stammbenutzernamensraum verglichen, indem die Zuordnungen im Namespace-Baum zum Stamm übertragen werden.  Es gibt eine Bewegung in die entgegengesetzte Richtung, zum Beispiel wenn er Benutzer-IDs liest, wie wir es mit <code>ls -l my_file</code> .  Die UID des Besitzers <code>my_file</code> vom <code>my_file</code> dem aktuellen zugeordnet, und die endgültige entsprechende ID (oder niemand, wenn die Zuordnung irgendwo im gesamten Baum fehlte) wird dem Lesevorgang übergeben. </p><br><h2 id="gruppovye-id">  Gruppen-ID </h2><br><p>  Selbst wenn wir in <strong>C</strong> verwurzelt waren, sind wir immer noch mit der schrecklichen <code>nogroup</code> als Gruppen-ID verbunden.  Wir müssen dasselbe für die entsprechende <code>/proc/$pid/gid_map</code> .  Bevor wir dies tun können, müssen wir den <code>setgroups</code> deaktivieren (dies ist nicht erforderlich, wenn unser Benutzer bereits über eine <code>CAP_SETGID</code> Funktion in <strong>P</strong> verfügt, dies wird jedoch nicht angenommen, da dies normalerweise mit Superuser-Berechtigungen verbunden ist), indem wir "verweigern" schreiben "zur Datei <code>proc/$pid/setgroups</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  13294 -- pid  unshared  C$ id uid=0(root) gid=65534(nogroup) P$ echo deny &gt; /proc/13294/setgroups P$ echo "0 1000 1" &gt; /proc/13294/gid_map #  group ID   C$ id uid=0(root) gid=0(root)</span></span></code> </pre> <br><h2 id="realizaciya">  Implementierung </h2><br><blockquote>  <em>Den Quellcode für diesen Beitrag finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .</em> </blockquote><p>  Wie Sie sehen, gibt es viele Schwierigkeiten bei der Verwaltung von Benutzernamensräumen, aber die Implementierung ist recht einfach.  Wir müssen nur ein paar Zeilen in eine Datei schreiben - es war trostlos herauszufinden, was und wo wir schreiben sollen.  Hier sind ohne weiteres unsere Ziele: </p><br><ol><li>  Klonen Sie einen Teamprozess in einem eigenen Benutzernamensraum. </li><li>  Schreiben Sie in die UID- und GID-Map-Dateien des Teamprozesses. </li><li>  Setzen Sie alle Superuser-Berechtigungen zurück, bevor Sie den Befehl ausführen. </li></ol><br><p>  <code>1</code> erreicht, indem einfach das <code>CLONE_NEWUSER</code> Flag zu unserem <code>CLONE_NEWUSER</code> hinzugefügt wird. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> clone_flags = SIGCHLD | CLONE_NEWUTS | CLONE_NEWUSER;</code> </pre> <br><p>  Für <code>2</code> fügen wir die Funktion <code>prepare_user_ns</code> , die sorgfältig einen regulären Benutzer <code>1000</code> als <code>root</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare_userns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> path[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> line[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> uid = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/uid_map"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"0 %d 1\n"</span></span>, uid); write_file(path, line); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/setgroups"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"deny"</span></span>); write_file(path, line); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/gid_map"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"0 %d 1\n"</span></span>, uid); write_file(path, line); }</code> </pre> <br><p>  Und wir werden es vom Hauptprozess im übergeordneten Benutzernamensraum aufrufen, bevor wir den Befehlsprozess signalisieren. </p><br><pre> <code class="cpp hljs"> ... <span class="hljs-comment"><span class="hljs-comment">//      . int pipe = params.fd[1]; //      namespace ... prepare_userns(cmd_pid); //   ,     . ...</span></span></code> </pre> <br><p>  In Schritt <code>3</code> aktualisieren wir die Funktion <code>cmd_exec</code> , um sicherzustellen, dass der Befehl von dem üblichen nicht privilegierten Benutzer <code>1000</code> , den wir in der Zuordnung angegeben haben (denken Sie daran, dass der <code>cmd_exec</code> <code>0</code> im Benutzernamensraum des Teamprozesses Benutzer <code>1000</code> ): </p><br><pre> <code class="cpp hljs"> ... <span class="hljs-comment"><span class="hljs-comment">//   ' '   . await_setup(params-&gt;fd[0]); if (setgid(0) == -1) die("Failed to setgid: %m\n"); if (setuid(0) == -1) die("Failed to setuid: %m\n"); ...</span></span></code> </pre> <br><p>  Und das ist alles!  <code>isolate</code> startet den Prozess jetzt in einem isolierten Benutzernamensraum. </p><br><pre> <code class="bash hljs">$ ./isolate sh ===========sh============ $ id uid=0(root) gid=0(root)</code> </pre> <br><p>  In diesem Beitrag gab es einige Details zur Funktionsweise von Benutzernamensräumen, aber am Ende war das Einrichten der Instanz relativ schmerzlos.  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nächsten Beitrag werden</a> wir die Möglichkeit untersuchen, einen Befehl in unserem eigenen Mount-Namespace mit <code>isolate</code> <code>Dockerfile</code> (das Geheimnis hinter der <code>FROM</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anweisung</a> aus der <code>Dockerfile</code> ).  Dort müssen wir Linux ein bisschen mehr helfen, um die Instanz richtig zu konfigurieren. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459574/">https://habr.com/ru/post/de459574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459560/index.html">Funktionen von Container-Rechenzentren: Fertige Vermittlungsstelle in Myanmar in 50 Tagen</a></li>
<li><a href="../de459562/index.html">Differenzierbare Programmierung</a></li>
<li><a href="../de459564/index.html">Was Entwickler über das Geschäft wissen müssen</a></li>
<li><a href="../de459568/index.html">Vertikaler Buchstabe in der modernen IT</a></li>
<li><a href="../de459570/index.html">Beeline zeigt Anzeigen für Google Bot. Bot unglücklich</a></li>
<li><a href="../de459576/index.html">Nützliche Google Chrome-Erweiterungen für den Programmierer</a></li>
<li><a href="../de459578/index.html">Öffentliches Sektor Offenes Projektmanagementsystem</a></li>
<li><a href="../de459580/index.html">Virtuelle Telefonsysteme</a></li>
<li><a href="../de459582/index.html">Überblick: Wie kaufe ich Aktien amerikanischer Unternehmen aus Russland?</a></li>
<li><a href="../de459584/index.html">Ich habe einen großartigen Programmierer namens Steve Wozniak gefunden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>