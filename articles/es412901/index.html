<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦇 ⚛️ 🕘 Monitoreo y Kubernetes (revisión y video informe) 👶 🤴🏾 😍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El 28 de mayo, en la conferencia RootConf 2018, que tuvo lugar como parte del festival RIT ++ 2018, en la sección "Registro y monitoreo", se entregó u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Monitoreo y Kubernetes (revisión y video informe)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/412901/">  El 28 de mayo, en la conferencia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RootConf</a> 2018, que tuvo lugar como parte del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">festival</a> RIT ++ 2018, en la sección "Registro y monitoreo", se entregó un informe "Monitoreo y Kubernetes".  Cuenta sobre la experiencia de la configuración de monitoreo con Prometheus, que fue obtenida por Flant como resultado de la operación de docenas de proyectos de Kubernetes en producción. <br><br><img src="https://habrastorage.org/webt/pm/o9/dm/pmo9dmnz9jf7b-yhej9shmir92q.jpeg"><br><br>  Por tradición, nos complace presentar un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>video con un informe</b></a> (aproximadamente una hora, <b>mucho más</b> informativo <b>que el</b> artículo) y la compresión principal en forma de texto.  Vamos! <a name="habracut"></a><br><br><h2>  ¿Qué es el monitoreo? </h2><br>  Existen muchos sistemas de monitoreo: <br><br><img src="https://habrastorage.org/webt/pa/07/i0/pa07i0ojuohdqwxbk6lvf86lgls.png"><br><br>  Parece que tomar e instalar uno de ellos, eso es todo, la pregunta está cerrada.  Pero la práctica muestra que esto no es así.  Y aquí está el por qué: <br><br><ol><li>  <b>Velocímetro muestra la velocidad</b> .  Si medimos la velocidad una vez por minuto con el velocímetro, entonces la velocidad promedio, que calculamos sobre la base de estos datos, no coincidirá con los datos del odómetro.  Y si en el caso de un automóvil esto es obvio, cuando se trata de muchos indicadores para el servidor, a menudo nos olvidamos de él. <br><img src="https://habrastorage.org/webt/s9/13/fv/s913fvrbguhqbp3iuuobwrmazt8.png"><br>  <i>Qué medimos y cómo viajamos realmente</i> </li><li>  <b>Más medidas</b>  Cuantos más indicadores <i>diferentes</i> obtengamos, más preciso será el diagnóstico de problemas ... pero solo con la condición de que estos sean indicadores realmente útiles, y no solo todo lo que logró reunir. </li><li>  <b>Alertas</b>  No hay nada complicado en enviar alertas.  Sin embargo, dos problemas típicos: a) las falsas alarmas ocurren con tanta frecuencia que dejamos de responder a las alertas, b) las alertas llegan en un momento en que es demasiado tarde (todo ya ha explotado).  ¡Y lograr en el monitoreo que estos problemas no surgieron es un arte genuino! </li></ol><br>  El monitoreo es un pastel de tres capas, cada una de las cuales es crítica: <br><br><ol><li>  En primer lugar, este es un sistema que le permite <b>evitar accidentes</b> , <b>notificar sobre accidentes</b> (si no pueden evitarse) y realizar un <b>diagnóstico rápido de</b> problemas. </li><li>  ¿Qué se necesita para esto?  <b>Datos precisos</b> , <b>gráficos útiles</b> (mírelos y comprenda dónde está el problema), <b>alertas relevantes</b> (lleguen en el momento adecuado y contengan información clara). </li><li>  Y para que todo esto funcione, <b>se</b> necesita un <b>sistema de monitoreo</b> . </li></ol><br>  La configuración adecuada de un sistema de monitoreo que realmente funcione no es una tarea fácil, ya que requiere un enfoque cuidadoso para la implementación incluso sin Kubernetes.  ¿Pero qué pasa con su apariencia? <br><br><h2>  Datos de monitoreo de Kubernetes </h2><br><h3>  No 1.  Más grande y más rápido </h3><br>  Kubernetes está cambiando mucho porque la infraestructura se está haciendo más grande y más rápida.  Anteriormente, con los servidores de hierro normales, su número era muy limitado y el proceso de adición era muy largo (tomaba días o semanas), luego, con las máquinas virtuales, el número de entidades aumentaba significativamente y el tiempo de su introducción en la batalla se reducía a segundos. <br><br>  Con Kubernetes, el número de entidades ha crecido en un orden de magnitud, su adición es completamente automática (la gestión de la configuración es necesaria, porque sin una descripción simplemente no se puede crear un nuevo pod), toda la infraestructura se ha vuelto muy dinámica (por ejemplo, con cada despliegue, los pod se eliminan y se crean de nuevo). <br><br><img src="https://habrastorage.org/webt/01/fv/cf/01fvcfbc_i2roepw7nh0q6womsk.png"><br><br>  ¿Qué cambia eso? <br><br><ol><li>  En principio, dejamos de mirar contenedores o contenedores individuales; ahora <b>solo nos</b> interesan los <b>grupos de objetos</b> . </li><li>  <b>Service Discovery se vuelve estrictamente obligatorio</b> , porque las "velocidades" ya son tales que, en principio, no podemos iniciar / eliminar nuevas entidades manualmente, como era antes, cuando se compraron nuevos servidores. </li><li>  <b>La cantidad de datos está creciendo significativamente</b> .  Si se recopilaron métricas anteriores de servidores o máquinas virtuales, ahora de pods, cuyo número es mucho mayor. </li><li>  El cambio más interesante lo llamé el " <b>flujo de metadatos</b> " y le contaré más al respecto. </li></ol><br>  Comenzaré con esta comparación: <br><br><ul><li>  Cuando envíe a su hijo al jardín de infantes, se le dará una caja personal, que se le asignará para el próximo año (o más) y en la que se indica su nombre. </li><li>  Cuando vienes al grupo, tu casillero no está firmado y se te envía para una "sesión". </li></ul><br>  Entonces, <b>los sistemas de monitoreo clásicos piensan que son un jardín de infantes</b> , no un grupo: suponen que el objeto de monitoreo les llegó para siempre o durante mucho tiempo, y les dan casilleros en consecuencia.  Pero las realidades en Kubernetes son diferentes: la cápsula llegó al grupo (es decir, fue creada), nadó en ella (antes del nuevo despliegue) y se fue (fue destruida); todo esto sucede rápida y regularmente.  Por lo tanto, el sistema de monitoreo debe comprender que los objetos que monitorea tienen una vida corta y debe poder olvidarlo por completo en el momento adecuado. <br><br><h3>  No 2.  La realidad paralela existe </h3><br>  Otro punto importante: con el advenimiento de Kubernetes, simultáneamente tenemos dos "realidades": <br><br><ol><li>  Mundo de Kubernetes en el que hay espacios de nombres, implementaciones, pods, contenedores.  Este es un mundo complejo, pero es lógico, estructurado. </li><li>  El mundo "físico", que consiste en muchos (literalmente - montones) de contenedores en cada nodo. </li></ol><br><img src="https://habrastorage.org/webt/1p/wc/xj/1pwcxjjt1xbgwqufldfm1upua10.png"><br>  <i>El mismo contenedor en la "realidad virtual" de Kubernetes (arriba) y el mundo físico de los nodos (abajo)</i> <br><br>  Y en el proceso de monitoreo, necesitamos <b>comparar</b> constantemente <b>el mundo físico de los contenedores con la realidad de Kubernetes</b> .  Por ejemplo, cuando miramos algún espacio de nombres, queremos saber dónde están ubicados todos sus contenedores (o los contenedores de uno de sus hogares).  Sin esto, las alertas no serán visuales y cómodas de usar, porque es importante que comprendamos qué objetos están informando. <br><br><img src="https://habrastorage.org/webt/2p/n7/3t/2pn73tojozunuxdnjiba8yqw7-y.png"><br>  <i>Diferentes tipos de alertas: esta última es más visual y conveniente en el trabajo que el resto</i> <br><br>  <b>Las conclusiones</b> aquí son: <br><br><ol><li>  El sistema de monitoreo debe usar primitivas integradas de Kubernetes. </li><li>  Hay más de una realidad: a menudo los problemas no ocurren con el hogar, sino con un nodo en particular, y necesitamos entender constantemente en qué tipo de "realidad" se encuentran. </li><li>  En un clúster, por regla general, hay varios entornos (además de la producción), lo que significa que esto debe tenerse en cuenta (por ejemplo, no recibir alertas por la noche sobre problemas en el desarrollo). </li></ol><br>  Entonces, tenemos tres condiciones necesarias para que todo funcione: <br><br><ol><li>  Entendemos bien qué es el monitoreo. </li><li>  Conocemos sus características, que aparecen con Kubernetes. </li><li>  Adoptamos el Prometeo. </li></ol><br>  Y así, para realmente trabajar, ¡solo queda hacer <i>un gran</i> esfuerzo!  Por cierto, ¿por qué exactamente Prometeo? .. <br><br><h2>  Prometeo </h2><br>  Hay dos formas de responder la pregunta sobre la elección de Prometeo: <br><br><ol><li>  Vea quién y qué se usa generalmente para monitorear Kubernetes. </li><li>  Considere sus ventajas técnicas. </li></ol><br>  Para el primero, utilicé los datos de la encuesta de The New Stack (del libro electrónico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El estado del ecosistema de Kubernetes</a> ), según el cual Prometheus es al menos más popular que otras soluciones (tanto de código abierto como SaaS), y si nos fijamos, tiene una ventaja estadística quíntuple . <br><br>  Ahora veamos cómo funciona Prometheus, en paralelo con cómo sus capacidades se combinan con Kubernetes y resuelven desafíos relacionados. <br><br><h2>  ¿Cómo se estructura Prometeo? </h2><br>  Prometheus está escrito en Go y distribuido como un solo archivo binario, en el que todo está integrado.  El algoritmo básico para su funcionamiento es el siguiente: <br><br><img src="https://habrastorage.org/webt/nh/xt/hp/nhxthp-dm3wveymrgbejbanainw.png"><br><br><ul><li>  <b>Collector</b> lee la <b>tabla de objetivos</b> , es decir  Una lista de los objetos a ser monitoreados y la frecuencia de su sondeo (por defecto - 60 segundos). </li><li>  Después de eso, el recopilador envía una solicitud HTTP a cada pod que <b>necesita</b> y recibe una respuesta con un conjunto de métricas: puede haber cien, mil, diez mil ... Cada métrica tiene un nombre, valor y <b>etiquetas</b> . </li><li>  La respuesta recibida se <b>almacena</b> en la <b>base de</b> datos de <b>TSDB</b> , donde la marca de tiempo de su recibo y las etiquetas del objeto del que se tomó se agregan a los datos métricos recibidos. <br><br><div class="spoiler">  <b class="spoiler_title">Brevemente sobre TSDB</b> <div class="spoiler_text">  <i>TSDB: base de datos de series de tiempo (DB para series de tiempo) en Go, que le permite almacenar datos durante un número específico de días y lo hace de manera muy eficiente (en tamaño, memoria y entrada / salida).</i>  <i>Los datos se almacenan solo localmente, sin agrupamiento y replicación, lo cual es un plus (funciona de manera simple y garantizada) y un menos (no hay escala horizontal del almacenamiento), pero en el caso de Prometheus el fragmentación está bien hecho, federación - más sobre esto más adelante.</i> <br></div></div></li><li>  Presentado en el esquema, <b>Service Discovery</b> es un motor de descubrimiento de servicios integrado en Prometheus que le permite recibir datos "de la caja" (a través de la API de Kubernetes) para crear una tabla de objetivos. </li></ul><br>  ¿Cómo se ve esta mesa?  Para cada entrada, almacena la URL que se utiliza para obtener métricas, la frecuencia de las llamadas y las etiquetas. <br><br><img src="https://habrastorage.org/webt/xu/9m/c_/xu9mc_ikwk-sdzkrs_fjt6lsfj0.png"><br><br>  Las etiquetas se usan para la yuxtaposición de los "mundos" de Kubernetes con lo físico.  Por ejemplo, para encontrar un pod con Redis necesitamos tener el espacio de nombres de valores, el servicio (utilizado en lugar de la implementación debido a las características técnicas para un caso particular) y el pod real.  En consecuencia, estas 3 etiquetas se almacenan en las entradas de la tabla de objetivos para las métricas de Redis. <br><br>  Estas entradas en la tabla se forman sobre la base de la <code>scrape_configs</code> Prometheus en la que se describen los objetos de monitoreo: en la sección <code>scrape_configs</code> , los <code>scrape_configs</code> definen, lo que indica por qué etiquetas buscar objetos para monitorear, cómo filtrarlos y qué etiquetas registrar. <br><br><h2>  ¿Qué datos recopila Kubernetes? </h2><br><ul><li>  En primer lugar, el <b>asistente</b> en Kubernetes es bastante complicado, y es crítico monitorear el estado de su trabajo (kube-apiserver, kube-controller-manager, kube-Scheduler, kube-etcd3 ...), además, está vinculado al nodo del clúster. </li><li>  En segundo lugar, es importante saber qué sucede <b>dentro de Kubernetes</b> . Para ello, obtenemos datos de: <br><ul><li>  <i>kubelet</i> : este componente de Kubernetes se ejecuta en cada nodo del clúster (y se conecta al asistente K8s);  cAdvisor está integrado en él (todas las métricas por contenedores) y también almacena información sobre volúmenes persistentes conectados; </li><li>  <i>kube-state-metrics</i> : de hecho, este es el Prometheus Exporter para la API de Kubernetes (le permite obtener <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">información sobre los objetos</a> almacenados en Kubernetes: pods, servicios, implementaciones, etc., por ejemplo, no lo sabremos sin él estado del contenedor o hogar); </li><li>  <i>exportador de nodos</i> : proporciona información sobre el propio nodo, métricas básicas en el sistema Linux (cpu, diskstats, meminfo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">etc.</a> ). </li></ul></li><li>  Los siguientes son <b>componentes de Kubernetes</b> , como kube-dns, kube-prometheus-operator y kube-prometheus, ingress-nginx-controller, etc. </li><li>  La siguiente categoría de objetos a monitorear es en realidad el <b>software</b> lanzado en Kubernetes.  Estos son servicios de servidor típicos como nginx, php-fpm, Redis, MongoDB, RabbitMQ ... Lo hacemos nosotros mismos para que cuando agreguemos ciertas etiquetas al servicio, automáticamente comience a recopilar los datos necesarios, lo que crea el tablero actual en Grafana. </li><li>  Finalmente, la categoría para todo lo demás es <b>personalizada</b> .  Las herramientas de Prometheus le permiten automatizar la recopilación de métricas arbitrarias (por ejemplo, el número de pedidos) simplemente agregando una etiqueta <code>prometheus-custom-target</code> a la descripción del servicio. </li></ul><br><img src="https://habrastorage.org/webt/0s/e6/c3/0se6c3ygspys909x3ju6m9aq7uu.gif"><br><h2>  Gráficos </h2><br>  Los datos recibidos <i>(descritos anteriormente) se</i> utilizan para enviar alertas y crear gráficos.  Dibujamos gráficos usando <b>Grafana</b> .  Y un "detalle" importante aquí es <b>PromQL</b> , el lenguaje de consulta de Prometheus que se integra perfectamente con Grafana. <br><br><img src="https://habrastorage.org/webt/_a/sl/7w/_asl7wbfscz1eyxstacdij_liio.png"><br><br>  Es bastante simple y conveniente para la mayoría de las tareas <i>(pero, por ejemplo, unirlas ya es un inconveniente, pero aún debe hacerlo)</i> .  PromQL le permite resolver todas las tareas necesarias: seleccione rápidamente las métricas necesarias, compare valores, realice operaciones aritméticas en ellas, agrupe, trabaje con intervalos de tiempo y mucho más.  Por ejemplo: <br><br><img src="https://habrastorage.org/webt/3h/1d/0v/3h1d0vskm__dosoxpx1rzd5jis8.png"><br><br>  Además, Prometheus tiene un <b>Evaluador</b> , que, utilizando el mismo PromQL, puede acceder a TSDB con la frecuencia especificada.  ¿Por qué es esto?  Ejemplo: comience a enviar alertas en los casos en que, según las métricas disponibles, haya un error 500 en el servidor web en los últimos 5 minutos.  Además de las etiquetas que estaban en la solicitud, Evaluator agrega etiquetas adicionales a los datos para las alertas (según lo configuramos), después de lo cual se envían en formato JSON a otro componente de Prometheus: <b>Alertmanager</b> . <br><br>  Prometheus periódicamente (una vez cada 30 segundos) envía alertas a Alertmanager, que las deduplica (después de recibir la primera alerta, la enviará y las siguientes no se enviarán nuevamente). <br><br><img src="https://habrastorage.org/webt/ju/0e/lg/ju0elg1u57wtxfjopy6wz38vtfg.png"><br><br>  <i><b>Nota</b> : No utilizamos Alertmanager en casa, sino que enviamos datos de Prometheus directamente a nuestro sistema, con el que trabajan nuestros asistentes, pero esto no importa en el esquema general.</i> <br><br><h2>  Prometeo en Kubernetes: el panorama general </h2><br>  Veamos ahora cómo funciona todo este paquete Prometheus dentro de Kubernetes: <br><br><img src="https://habrastorage.org/webt/w-/gu/ue/w-guue_2b8q12romg-qv7uw2hpi.png"><br><br><ul><li>  Kubernetes tiene su propio espacio de nombres para Prometeo <i>(tenemos <code>kube-prometheus</code> en la ilustración)</i> . </li><li>  Este espacio de nombres aloja el pod con la instalación de Prometheus, que cada 30 segundos recopila métricas de todos los destinos recibidos a través de Service Discovery en el clúster. </li><li>  También alberga un pod con Alertmanager, que recibe datos de Prometheus y envía alertas <i>(por correo, Slack, PagerDuty, WeChat, integración de terceros, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">etc.</a> )</i> . </li><li>  Prometheus se enfrenta a un equilibrador de carga, un servicio regular en Kubernetes, y Grafana accede a Prometheus a través de él.  Para <b>garantizar la tolerancia a fallos, Prometheus</b> utiliza varios pods con instalaciones de Prometheus, cada uno de los cuales recopila todos los datos y los almacena en su TSDB.  A través del equilibrador, Grafana golpea a uno de ellos. </li><li>  El número de pods con Prometheus está controlado por la configuración <i>StatefulSet</i> : generalmente no hacemos más de dos pods, pero puede aumentar este número.  Del mismo modo, Alertmanager se implementa a través de StatefulSet, para cuya tolerancia a fallas ya se requieren al menos 3 pods (ya que se necesita un quórum para tomar decisiones sobre el envío de alertas). <br></li></ul><br>  ¿Qué falta aquí? <br><br><h2>  Federación para Prometeo </h2><br>  Cuando los datos se recopilan cada 30 (o 60) segundos, el lugar para almacenarlos termina muy rápidamente y, lo que es peor, requiere muchos recursos informáticos (al recibir y procesar una cantidad tan grande de puntos de TSDB).  Pero queremos almacenar y tener la capacidad de descargar información para <b>grandes intervalos de tiempo</b> .  ¿Cómo lograr esto? <br><br>  Es suficiente agregar <b>una instalación más de Prometheus</b> (lo llamamos a <i>largo plazo</i> ) al esquema general, en el que Service Discovery está deshabilitado, y en la tabla de objetivos hay el único registro estático que conduce al Prometheus <i>principal</i> ( <i>main</i> ).  <b>Esto es posible gracias a la <a href="">federación</a></b> : Prometheus le permite devolver los últimos valores de todas las métricas en una sola consulta.  Por lo tanto, la primera instalación de Prometheus todavía funciona (accede cada 60 o, por ejemplo, 30 segundos) a todos los objetivos en el clúster de Kubernetes, y la segunda, una vez cada 5 minutos, recibe datos del primero y los almacena para poder ver los datos durante un período prolongado ( pero sin detalles profundos). <br><br><img src="https://habrastorage.org/webt/zc/uj/k3/zcujk3s5oxler1lhwaaswadmiyy.png"><br>  <i>La segunda instalación de Prometheus no necesita Service Discovery, y la tabla de objetivos constará de una línea</i> <br><br><img src="https://habrastorage.org/webt/od/zr/ow/odzrowlvdyq3qmhfldvy085naou.png"><br>  <i>La imagen completa con instalaciones de Prometheus de dos tipos: principal (superior) y a largo plazo</i> <br><br>  El toque final es <b>conectar Grafana</b> a las instalaciones de Prometheus y crear paneles de una manera especial para que pueda cambiar entre las fuentes de datos ( <i>principal</i> o a <i>largo plazo</i> ).  Para hacer esto, utilizando el motor de plantillas, sustituya la variable <code>$prometheus</code> lugar de la fuente de datos en todos los paneles. <br><br><img src="https://habrastorage.org/webt/ju/v3/9u/juv39un0v2qdtwegrt07qpg-1yi.png"><br><br><h2>  ¿Qué más es importante en los gráficos? </h2><br>  Dos puntos clave a considerar al organizar los horarios son el soporte para las primitivas de Kubernetes y la capacidad de <b>profundizar</b> rápidamente desde la imagen general (o una "vista" inferior) a un servicio específico y viceversa. <br><br>  Ya se ha mencionado el soporte para primitivas (espacios de nombres, pods, etc.): esta es una condición necesaria en principio para un trabajo cómodo en las realidades de Kubernetes.  Y aquí hay un ejemplo sobre profundizar: <br><br><ul><li>  Observamos los gráficos del consumo de recursos por tres proyectos (es decir, tres espacios de nombres); vemos que la parte principal de la CPU (o memoria, o red, ...) recae en el proyecto A. </li><li>  Observamos los mismos gráficos, pero ya para los servicios del Proyecto A: ¿cuál de ellos consume más CPU? </li><li>  Pasamos a los gráficos del servicio deseado: ¿qué pod es "culpable"? </li><li>  Pasamos a los gráficos de la cápsula deseada: ¿qué contenedor es el "culpable"?  Este es el objetivo deseado! </li></ul><br><img src="https://habrastorage.org/webt/fq/vb/ly/fqvblyn0wdnoqqzqgwi0ublftjy.png"><br><h2>  Resumen </h2><br><ul><li>  Indique con precisión qué es el monitoreo.  <i>(Deje que el "pastel de tres capas" sirva de recordatorio de esto ... ¡así como del hecho de que hornearlo de manera competente no es fácil incluso sin Kubernetes!)</i> </li><li>  Recuerde que Kubernetes agrega detalles obligatorios: agrupación de objetivos, descubrimiento de servicios, grandes cantidades de datos, flujo de metadatos.  Por otra parte: <br><ul><li>  sí, algunos de ellos están resueltos mágicamente ("fuera de la caja") en Prometeo; </li><li>  sin embargo, queda otra parte que necesita ser monitoreada de manera independiente y cuidadosa. </li></ul></li></ul><br>  Y recuerde que el <b>contenido es más importante que un sistema</b> , es decir  los gráficos y alertas correctos son primarios, y no Prometheus (o cualquier otro software similar) como tal. <br><br><img src="https://habrastorage.org/webt/ml/61/ou/ml61oub7wmavnyfdmjepkm7bd-y.png"><br><br><h2>  Videos y diapositivas </h2><br>  Video de la actuación (aproximadamente una hora): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zj6SlzzBRaA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Presentación del informe: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  PS </h2><br>  Otros informes en nuestro blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bases de datos y Kubernetes</a> ";  <i>(Dmitry Stolyarov; 8 de noviembre de 2018 en HighLoad ++)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mejores prácticas de CI / CD con Kubernetes y GitLab</a> ";  <i>(Dmitry Stolyarov; 7 de noviembre de 2017 en HighLoad ++)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nuestra experiencia con Kubernetes en pequeños proyectos</a> ";  <i>(Dmitry Stolyarov; 6 de junio de 2017 en RootConf)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Recopilamos imágenes de Docker para CI / CD de forma rápida y conveniente con dapp</a> " <i>(Dmitry Stolyarov; 8 de noviembre de 2016 en HighLoad ++)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prácticas de entrega continua con Docker</a> " <i>(Dmitry Stolyarov; 31 de mayo de 2016 en RootConf)</i> . </li></ul><br>  También te pueden interesar las siguientes publicaciones: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El dispositivo y mecanismo de operación del operador Prometheus en Kubernetes</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Monitoreo con Prometeo en Kubernetes en 15 minutos</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Infraestructura con Kubernetes como un servicio asequible</a> ". </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es412901/">https://habr.com/ru/post/es412901/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es412891/index.html">Citrix XenServer 7.0 I / O no optimizado Management Agent no instalado</a></li>
<li><a href="../es412893/index.html">Para llegar a un programador senior en cuatro años: el método "Escuela 21"</a></li>
<li><a href="../es412895/index.html">Vesta Matveeva: la lucha contra el cibercrimen es una elección moral</a></li>
<li><a href="../es412897/index.html">Monitoreo de productos Atlassian con Prometheus</a></li>
<li><a href="../es412899/index.html">Lectura de fin de semana: 30 materiales sobre sonido, la historia de las marcas de audio y la industria del cine.</a></li>
<li><a href="../es412903/index.html">Como pintamos a Habr</a></li>
<li><a href="../es412905/index.html">Acerca de LL Parsing: un enfoque para analizar a través del concepto de corte de cuerdas</a></li>
<li><a href="../es412911/index.html">Los desarrolladores hablan sobre características cortadas de los juegos</a></li>
<li><a href="../es412913/index.html">"Baikal-T1" salió a la venta por 3990 rublos</a></li>
<li><a href="../es412915/index.html">Determinación de la densidad del gas a partir de los resultados de medición de presión y temperatura con sensores Arduino</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>