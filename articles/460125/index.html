<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😨 🔼 🙆🏿 Node.js o Java: rendimiento, recursos, control de flujo, popularidad y experiencia personal. 🧕🏾 👝 🐌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mis colegas y yo discutimos recientemente la popularidad de algunas tecnologías, en particular, Java y node.js. Después de una breve navegación por In...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js o Java: rendimiento, recursos, control de flujo, popularidad y experiencia personal.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460125/"> Mis colegas y yo discutimos recientemente la popularidad de algunas tecnologías, en particular, Java y node.js.  Después de una breve navegación por Internet, resultó que eran estas tecnologías las que utilizan muchos gigantes de la información para desarrollar y mantener sus sitios en la red.  A continuación, daré solo una pequeña parte. <br><br>  <i>Empresas que utilizan Java:</i> <br><br><img src="https://www.intexsoft.com/images/intexsoft/blog/java-vs-node/companies-using-java.png" alt="imagen"><br><br>  <i>Empresas que utilizan node.js:</i> <br><br><img src="https://www.intexsoft.com/images/intexsoft/blog/java-vs-node/companies-using-node.png" alt="imagen"><br><br>  También es menos interesante que, de acuerdo con una búsqueda en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Indeed.com</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">28/06/2019</a> ) a solicitud de Java Developer (30272 vacantes) y node.js developer (7401 vacantes), los especialistas en estas tecnologías tienen mucha demanda. <br><br><img src="https://www.intexsoft.com/images/intexsoft/blog/java-vs-node/node-vs-java-jobs.png" alt="imagen"><br><br>  Pero todo esto es solo información general sobre la popularidad.  La información que me llevó a profundizar en el tema y especular sobre el tema de las características técnicas, lo que llevó a la redacción de este artículo. <br><a name="habracut"></a><br><h3>  ¿Por qué vale la pena compararlos? </h3><br>  Java es un lenguaje, node.js puede llamarse un ecosistema construido sobre la base de JS y, en primer lugar, basado en V8, un motor de Google. <br><br>  Sin embargo, cuando hablamos de Java, estamos hablando no solo del lenguaje, sino también de la máquina virtual Java, así como de todo el ecosistema y la infraestructura construidos alrededor de esta máquina.  Como mínimo, se pueden comparar sobre esta base, como resultado, <i>en ambos casos, tenemos un tiempo de ejecución</i> .  En el caso de Java, es una máquina virtual.  En el caso de node.js, es un motor V8 que está disponible en la mayoría de los sistemas operativos, como Windows, Linux, MacOS y otros menos conocidos. <br><br>  Los desarrolladores pueden escribir código usando el mismo lenguaje, y esto funcionará más o menos de la misma manera en diferentes sistemas operativos debido al hecho de que hay un tiempo de ejecución.  El entorno de tiempo de ejecución afecta la forma en que se produce la interacción con el sistema operativo.  Además, se pueden comparar desde  Se <i>utilizan para resolver una gama similar de problemas</i> . <br><br><h3>  V8 y JVM </h3><br>  Cuando el código JS entra en v8, justo a tiempo se realiza la compilación en el código de bytes que se utiliza en la máquina virtual, el código JS se ejecuta cada vez más rápido. <br>  El código de bytes es un lenguaje intermedio de alto nivel, por lo que en una máquina virtual Java escriben no solo en Java, sino también en Scala y Kotlin. <br><br>  Hay requisitos previos que en el futuro cercano para V8 será posible usar no solo JS sino también TypeScript u otros.  Por el momento, hay una traducción de estos idiomas en JS.  En el futuro, probablemente serán compatibles de inmediato, y todo funcionará mucho más rápido. <br><br>  Ahora hay un desarrollo continuo de V8 y, en general, la aparición de nuevas versiones de node.js está asociada con el advenimiento de una nueva versión del motor V8.  Están directamente interconectados. <br><br><h3>  Node.js: ventajas y desventajas </h3><br>  Node.js fue creado por Ryan Dahl en 2009. <br><br>  Node.js en sí incluye varios componentes principales: <br><br><ul><li>  Motor V8 </li><li>  biblioteca libuv, que es responsable de la parte central del nodo: un bucle de eventos, que interactúa con el sistema operativo, así como de entrada / salida asincrónica (E / S); </li><li>  de un conjunto de varias bibliotecas JS y directamente el lenguaje JS mismo. </li></ul><br>  Pasemos a sus pros y sus contras. <br><br>  <b>Pros:</b> <br><br><ul><li>  facilidad y velocidad de escritura </li><li>  ligereza </li><li>  relativa simplicidad (en comparación con java) </li><li>  npm (administrador de paquetes de nodos (una gran cantidad de bibliotecas que se pueden instalar en una línea) </li><li>  cada biblioteca cae en el árbol de dependencias y todo esto se hace fácilmente </li><li>  desarrollo continuo (TypeScript se está desarrollando activamente (lo que trae mecanografía, decoradores a JS y se usa, por ejemplo, para Angular) </li></ul><br>  <b>Contras:</b> <br><br><ul><li>  La flexibilidad y el rápido desarrollo también generan desventajas ya que  necesita monitorear constantemente las actualizaciones, algunas cosas salen insuficientemente probadas; </li><li>  hubo un caso cuando un desarrollador eliminó su biblioteca de NPM y muchas aplicaciones que la usaron dejaron de funcionar; </li></ul><br><h3>  Ventajas y desventajas de Java </h3><br>  Por el contrario, considere inmediatamente las características principales de Java. <br><br>  <b>Pros:</b> <br><br><ul><li>  velocidad de trabajo </li><li>  prevalencia (en universidades de muchos países estudian Java, también es conveniente estudiar POO en Java), </li><li>  Gran conjunto de bibliotecas. </li></ul><br>  <b>Contras:</b> <br><br><ul><li>  pesadez </li><li>  algunos paradigmas de Java se crearon hace mucho tiempo y están desactualizados, </li><li>  JDK es propietario, por lo que Java se está desarrollando lentamente. </li></ul><br>  Recientemente, JS ha comenzado a superar a Java (y cuanto más, más). <br>  Java también abandona el mundo de Android, está siendo reemplazado por Kotlin que, aunque utiliza la JVM, sigue siendo un idioma diferente. <br><br><h3>  Conflicto de Oracle y Google </h3><br><img src="https://www.intexsoft.com/images/intexsoft/blog/java-vs-node/java-vs-node.gif" alt="imagen"><br><br>  Sun fue creado por Sun, que luego fue adquirido por Oracle y aún es propiedad de él.  Por esta razón, para muchas compañías que usan Java crea algunos problemas. <br><br>  Google tenía problemas cuando Oracle inició una demanda con ellos por usar Java en Android.  Debido a esto, Google adoptó muy activamente Kotlin, que apareció de forma independiente.  Java es propietario.  Pero hay una máquina virtual Oracle, así como una máquina virtual Java abierta (JVM abierta), que se usa en Linux y se escribe en código abierto.  A veces hay algunas incompatibilidades, pero recientemente son cada vez menos. <br><br>  Por cierto, Google no pudo abandonar completamente Java.  En Dalvik, que se usa como núcleo en Android, la JVM está integrada.  Quizás dejarán esto, pero será muy difícil hacerlo porque  Casi todo el ecosistema de Android se basa en Java, principalmente en el uso de una JVM modernizada.  Y eso, en algún momento, también fue la razón del conflicto entre Oracle y Google, porque Oracle prohíbe simplemente actualizar la JVM.  Esta es la parte más importante de Java.  Y el lenguaje en sí se puede usar casi sin restricciones. <br><br><h3>  Java vs node.js: rendimiento y consumo de recursos </h3><br>  En primer lugar, vale la pena señalar que el rendimiento de Java es mucho mayor que el de JS y, en consecuencia, node.js. <br><br><img src="https://www.intexsoft.com/images/intexsoft/blog/java-vs-node/node-vs-java-diagram.png" alt="imagen"><br>  <i>Node.js y rendimiento de Java</i> <br><br>  Si ejecuta una tarea simple, como la cuadratura, los indicadores pueden variar hasta 10 veces en las pruebas.  Si ejecuta bucles en millones de tareas de cálculo, Java casi siempre superará node.js.  Además, la gran diferencia entre Java y node.js es que el nodo tiene un solo subproceso, lo que es una ventaja y una desventaja, por otro lado. <br><br>  Java puede trabajar con secuencias compatibles con el nivel del sistema operativo, y resulta que un programa escrito en Java aprovecha al máximo las capacidades del sistema operativo.  Y si necesita escribir una aplicación altamente cargada que utilizará una gran cantidad de cálculos, entonces Java definitivamente será mejor para esto.  El problema es que incluso un servidor pequeño escrito en Java ocupará mucha memoria, tanto en disco como en línea. <br><br>  Node.js es ligero debido a su arquitectura basada en eventos.  Está diseñado para funcionar como un servidor web y hace un muy buen trabajo al atender tareas livianas.  Por ejemplo, una consulta simple como calcular algo o escribir en una base de datos ocurre muy rápidamente.  Y si hay muchas solicitudes y queremos escalar el sistema en el nodo, puede usar el servidor web Nginx o Apache.  Puede tener muchas instancias de nodo idénticas.  Entonces todo se distribuirá a través del balanceo de carga round-robin.  Si ejecutamos instancias de 8 nodos en 16 núcleos, respectivamente, el sistema operativo distribuirá las instancias entre los núcleos.  El nodo no controla esto, tendrá un hilo. <br><br><h3>  Control de flujo en Java y node.js </h3><br>  En Java, podemos crear una aplicación y ejecutar 8 hilos en ella.  Debido al hecho de que existe una interacción más estrecha con el sistema operativo, puede distribuir la carga. <br><br>  Como sabes, uno de los servidores web escritos en Java es Tomcat.  Allí puede ver claramente que cuando el usuario realiza una solicitud, se inician hilos adicionales.  Y cuando la solicitud llega al nodo, el bucle de eventos se procesará y se enviará de regreso, luego vendrá la siguiente solicitud.  Y debido al hecho de que no esperamos los resultados del primero, también será recogido.  Si bien las solicitudes son ligeras, todo está bien.  Sin embargo, cuando se realiza un cálculo pesado, si hay una instancia, el nodo se detiene y se produce un tiempo de espera. <br><br><img src="https://www.intexsoft.com/images/intexsoft/blog/java-vs-node/java-thread-control.png" alt="imagen"><br>  <i>Gestión de hilos Java</i> <br><br>  En el nodo, puede escribir unas pocas líneas de código y obtener el servidor web más simple.  Naturalmente, para una funcionalidad más amplia, donde habrá notificaciones, autorizaciones, registros, etc.  es más difícil de implementar, pero existen marcos que le permiten resolver tales problemas. <br><br><img src="https://www.intexsoft.com/images/intexsoft/blog/java-vs-node/node-thread-control.png" alt="imagen"><br>  <i>Control de flujo en node.js</i> <br><br>  Java tiene una API desarrollada: API de concurrencia, que le permite trabajar con hilos competitivos.  Pero al mismo tiempo, este es uno de los problemas desde  la competitividad es algo muy complicado y no todos los desarrolladores están bien versados ​​en esto. <br><br>  La web, la API REST es el elemento del nodo, y a veces lo usan.  Pero si estamos tratando con cálculos complejos, aún es mejor usar Java. <br><br><h3>  Mi java proyecto </h3><br>  En Java, tenía un proyecto interesante: una aplicación distribuida, cuya tarea principal era procesar grandes cantidades de información gráfica para su uso posterior en directorios.  Al crear un catálogo, debe preparar conjuntos de una gran cantidad de imágenes de varias resoluciones que se utilizarán para crear el catálogo.  En pocas palabras, esta es una aplicación para automatizar la preparación del catálogo de preimpresión. <br><br>  Los fotógrafos solían tener que hacer todo manualmente.  Primero tenía que usar alguna pequeña aplicación para cargar sus imágenes.  Además, el especialista que creó el directorio tuvo que desarrollar la estructura del directorio a través de otra aplicación.  Luego, en otra aplicación, se creó un flujo de trabajo que arrojó imágenes a la estructura que se creó.  En general, el proceso fue bastante difícil.  Usó ImageMagick que está en Linux, Windows, MacOS.  Estábamos lidiando con Linux. <br><br>  Por ejemplo, se cargó una imagen .tiff de 200-300 mb de tamaño en la aplicación, y a partir de ella fue necesario tomar imágenes de varias resoluciones, cortar algo o hacer un sustrato. <br>  La primera versión de la aplicación no podía hacer frente a la gran carga, incluso faltaba un servidor con procesadores de 16 núcleos.  Hemos mejorado la arquitectura de la aplicación para usar varias instancias al mismo tiempo para no cambiar fundamentalmente la aplicación.  Se lanzaron muchas instancias que interactuaban entre sí y cada una de ellas procesó una parte de la tarea.  Fue difícil, pero pudimos implementar todo con éxito en solo un par de meses.  Y el sistema aún funciona.  En el proceso, tuvimos que lidiar con la competencia y varios aspectos de la interacción. <br><br>  Algo de este proyecto todavía podría ser portado al nodo, pero algunas cosas aún tendrían que hacerse en Java, porque  Hubo muchos cálculos diferentes.  Básicamente, podríamos hacer partes en el nodo que invocarían ciertas partes en Java y usar una arquitectura de microservicio.  Podrías usar una versión mixta.  Pero este enfoque no siempre funciona, porque  un desarrollador especializado en nodo puede no ser un especialista en Java y viceversa.  Y encontrar desarrolladores universales es mucho más difícil. <br><br><h3>  Por experiencia en node.js </h3><br>  Hubo un proyecto para organizar una gran cantidad de datos.  Algo similar al proyecto descrito anteriormente.  Solo aquí cargamos un archivo que contiene un gran conjunto de información y está sujeto a validación a través de un servicio de terceros (escrito en Java), varias veces y de acuerdo con diferentes reglas.  Era necesario procesar cientos de gigabytes de información, y el nodo no estaba destinado a esto. <br><br>  Fue especialmente interesante diseñar la arquitectura del sistema, ya que  La aplicación constaba de varios microservicios, incluidos los de terceros.  Cuando trabajamos con un servicio de terceros que realizó la validación, utilizamos el agente de mensajes RabbitMQ.  Dimos la información necesaria a un servidor de terceros y recibimos un mensaje de RabbitMQ después de que finalizó la validación, luego los datos se procesaron en partes para evitar la falta de memoria. <br><br>  Y si inicialmente la aplicación procesó un archivo que contiene 10,000 registros, ahora puede procesar hasta un millón.  Aún logramos resolver este problema usando node.js, aunque en Java podría resolverse más fácilmente, sin embargo, el cliente quería usar exactamente el nodo, porque  Necesitaba una infraestructura y arquitectura unificadas con microservicios escritos en JS.  Usar node para resolver el problema fue mucho más complicado y requirió más tiempo, pero node.js gana debido a la escalabilidad.  Es por eso que ahora podemos aumentar el número de trabajadores y procesar más y más datos.  En Java, esto sería más complicado. <br><br>  De hecho, cualquier problema puede resolverse de una forma u otra, pero vale la pena repetirlo aquí: si hay muchos cálculos, es mejor usar Java, si no hay muchos cálculos, puede usar el nodo de forma segura. <br><br><h3>  Resumen y perspectivas: ¿podrá node.js superar a Java? </h3><br>  Ahora se trata del hecho de que node.js a menudo se usará como envoltorio, y el relleno se escribirá en otros idiomas.  Sus defectos se conocen desde hace mucho tiempo.  Por ejemplo, un defecto condicional como un solo subproceso ya se ha solucionado.  La última versión del nodo introduce la capacidad de usar múltiples hilos. <br><br>  Java se creó originalmente como una solución ligera que reemplaza a C ++, y ahora se ha convertido en un peso pesado.  Es como la evolución.  Tal vez algún día habrá algo que reemplace al nodo. <br><br><img src="https://www.intexsoft.com/images/intexsoft/blog/java-vs-node/modules-count.png" alt="imagen"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Módulos</a> - Desarrollo de Java vs node.js</i> <br><br>  Ahora, de acuerdo con el número de órdenes, y de acuerdo con mis sentimientos, node.js ya está por delante de Java. <br>  JS se está desarrollando activamente y cambiará, tal vez algo vendrá a reemplazarlo. <br>  Ahora no hay un competidor potencial que pueda reemplazar a Java y node.js. <br><br>  El problema es que el desarrollo de Java ha sido bastante lento últimamente, y node.js se está desarrollando a una velocidad tal que no es posible reemplazarlo en el futuro cercano. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460125/">https://habr.com/ru/post/460125/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460115/index.html">Diez años de programación en Erlang</a></li>
<li><a href="../460117/index.html">¿Son los clientes más grandes de Rusia un gran premio o un dolor de cabeza? Experiencia AGIMA</a></li>
<li><a href="../460119/index.html">Errores que el análisis de código estático no encuentra porque no se usa</a></li>
<li><a href="../460121/index.html">Errores que el análisis de código estático no encuentra porque no se usa</a></li>
<li><a href="../460123/index.html">¿Una tubería de procesamiento de datos declarativa sobre los actores? Por que no</a></li>
<li><a href="../460129/index.html">Robots y fresas: cómo la IA aumenta los rendimientos de campo</a></li>
<li><a href="../460131/index.html">Sophos XG Firewall: de ME clásico a NGFW con respuesta automática a incidentes de seguridad de la información</a></li>
<li><a href="../460133/index.html">Kotlin / Everywhere - Práctica de escaparate: 31 de julio</a></li>
<li><a href="../460135/index.html">Semana de la seguridad 29: vulnerabilidad de zoom, seguridad y drama</a></li>
<li><a href="../460137/index.html">Fujitsu LIFEBOOK U939X Review: peso ligero y rendimiento 2 en 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>