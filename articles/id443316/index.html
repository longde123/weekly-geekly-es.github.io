<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏾 🏭 👩🏿‍🤝‍👩🏻 Pengujian ReactJS: Seberapa Dalam Lubang Kelinci itu 😼 ‼️ 🤓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya, nama saya Yaroslav Astafiev, dan hari ini saya ingin melakukan tur berpemandu dalam menguji ReactJS. Saya tidak akan menyelidiki komple...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengujian ReactJS: Seberapa Dalam Lubang Kelinci itu</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/443316/">  Halo semuanya, nama saya Yaroslav Astafiev, dan hari ini saya ingin melakukan tur berpemandu dalam menguji ReactJS.  Saya tidak akan menyelidiki kompleksitas pengujian aplikasi web menggunakan perpustakaan tertentu (dipandu oleh pendekatan "sulit untuk menguji hanya kode buruk"), sebagai imbalannya saya akan mencoba untuk mendiversifikasi cakrawala Anda.  Jadi dalam artikel ini, React lebih merupakan kesempatan untuk mengumpulkan pendekatan pengujian, titik awal yang menggabungkan hipsters dan teknologi.  Akan lebih benar untuk bahkan mengatakan bahwa kita akan berbicara tentang prinsip-prinsip pengujian secara umum dengan ilustrasi tentang ReactJS (dan tidak hanya). <br><br>  Jika Anda menganggap diri Anda seorang guru pengujian - <b>lewati bagian pertama artikel</b> , ini tentang prinsip dasar pengujian.  Jika bagian kedua tidak mengungkapkan sesuatu yang baru untuk Anda, datanglah kepada kami untuk bekerja dan mengajarkan caranya. <br><br><img src="https://habrastorage.org/webt/lt/qq/2o/ltqq2o5vf7uhre_tu8ylepblije.jpeg"><br><br>  Jika pendahuluan tidak menyebabkan serangan sinestesia, selamat datang di kucing. <br><a name="habracut"></a><br><h2>  Tes unit </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unit Jest</a> adalah perpustakaan untuk menguji JavaScript.  Jangan suka ini - ambil yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lain</a> , tapi kemudian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ava</a> lebih baik.  Semuanya sederhana di sini: klik tombol ajaib dan pastikan bahwa nilai tertentu dari "0" telah berubah menjadi "1": <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { MyButton } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../src/components/dummy/myButton"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> renderer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-test-renderer"</span></span> test(<span class="hljs-string"><span class="hljs-string">"MyButton has onPress fn"</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> instance = renderer .create(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MyButton</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onPress</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> x++} /&gt;) .getInstance() expect(instance.handlePress).toBeDefined() expect(x).toBe(0) instance.props.handlePress() expect(x).toBe(1) })</span></span></code> </pre> <br>  <b>Sekarang Anda memiliki semua keterampilan yang diperlukan</b> untuk menguji tombol ajaib.  Sayangnya, keterampilan ini tidak terkait dengan kehidupan nyata.  Komponen Bereaksi tidak dapat terisolasi dengan baik, dan isolasi adalah salah satu prinsip utama pengujian unit.  Entah bagaimana, perlu untuk menghapus semua komponen yang entah bagaimana berpartisipasi dalam metode render, kecuali yang diuji.  Dan ada solusinya: orang pintar datang dengan mockAPI untuk ini. <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// initJest.jsx file global.fetch = require('jest-fetch-mock') //custom mock const API = require('mockAPI') //static mock describe("Date() Tests", () =&gt; { beforeEach(() =&gt; { MockDate.set("2011-09-11T00:00:00.000Z") }) afterEach(() =&gt; { MockDate.reset() }) //smth ... })</span></span></code> </pre><br>  Inti dari Mock sederhana: semua yang bukan milik kita adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mock / Stub / Fake / Dummy / Spy</a> dll.  Kami "meniru" cara kami membutuhkan perilaku nyata dari suatu komponen, yang dapat memiliki logika yang kompleks, pada data uji yang disiapkan sebelumnya dan membawanya dengan keyakinan bahwa semua komponen yang ditiru bekerja dengan sempurna jika parameter yang benar dimasukkan ke dalamnya. <br><br>  Ada pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jest-fetch-mock</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jest</a> , di dalamnya Anda dapat mendefinisikan moki secara global.  Jika Anda tidak menyukai opsi ini, Anda dapat "membasahi" setiap komponen yang Anda butuhkan dalam pengujian secara terpisah. <br><br>  <b>Fungsi murni</b> pada input yang sama selalu mengembalikan jawaban yang sama.  Oleh karena itu, jika dalam logika bisnis kita komponen memiliki fungsi / komponen “tidak bersih”, maka dalam pengujian unit mereka juga perlu “dibersihkan” (tetapi untuk pengujian unit aturan ini tidak selalu benar).  Contoh klasik adalah komponen reaksi yang menampilkan tanggal dan waktu saat ini dalam format yang Anda butuhkan, tanggal akan berbeda setiap kali Anda menjalankan tes, dan Anda tidak akan bisa menulis tes unit yang benar.  Untuk semua yang tidak setuju, Anda dapat menyulitkan contoh di mana komponen Anda harus menampilkan tanggal dalam format relatif dan menyoroti tanggal yang lebih tua dari satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tahun dari</a> tanggal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saat</a> ini dengan warna merah. <br><br>  Dengan demikian, jika Anda memiliki hal-hal dinamis yang bergantung pada waktu / cuaca / tekanan, maka mock akan mendefinisikan ulang panggilan yang Anda butuhkan sehingga tidak ada ketergantungan pada faktor pihak ketiga.  Dengan demikian, Anda tidak perlu menunggu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada tanggal 29 Februari</a> untuk mendapatkan tes jatuh. <br><br><h2>  Aturan Uji Unit </h2><br>  Masalah yang dijelaskan di atas dan metode untuk menyelesaikannya adalah upaya pendekatan informal untuk pengujian: setiap tes berjalan seperti yang diinginkan.  Menurut pendapat saya, kepatuhan terhadap <b>tiga aturan penting pengujian unit sudah</b> cukup: <br><br><ul><li>  Determinisme </li><li>  Isolasi </li><li>  Bebas dari faktor eksternal </li><li>  Akal sehat </li></ul><br>  Aturan satu: semua tes harus deterministik.  Jika saya menulis tes pada Windows, maka pada Mac itu juga harus memulai dan menghasilkan hasil yang sama.  Pengembang Windows senang lupa bahwa nama file pada sistem * nix peka terhadap huruf besar-kecil.  Dan Anda beruntung jika <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tes berada dalam kerangka CI, dan bukan aplikasi dalam produksi</a> . <br><br>  Aturan selanjutnya adalah isolasi.  Kami membasahi semua komponen yang tidak diuji.  Jika ini sulit dilakukan, maka sudah waktunya untuk refactor. <br><br>  Last but not least: jika ada data yang diterima aplikasi Anda dalam runtime, mereka juga harus dipaku.  Ini bisa berupa lokal, ukuran jendela, format tanggal, format angka titik mengambang, dll. <br><br><h2>  Tes integrasi </h2><br>  <b>Kapan mulai menulis tes integrasi</b> , menurut pendapat saya, adalah pertanyaan terbuka, dan di setiap tim / produk individu keputusan harus dibuat dengan mempertimbangkan faktor internal. <br><br>  Anda dapat mengambil pendekatan formal: mencapai cakupan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">unit tes 80%</a> (tes tertulis yang buruk tidak boleh ditinjau / memerlukan kode baru atau yang diubah untuk dicakup oleh tes), kemudian melakukan audit penuh dan refactoring semua tes tertulis dengan analisis kesalahan khas, memformalkan aturan internal untuk menulis tes dan melakukan penggerebekan seperti itu per tahun.  Jika setelah semua tindakan yang dijelaskan di atas unit Anda, cakupan kode tes masih 80% +, maka Anda memiliki tim yang matang, atau Anda sama sekali tidak kritis terhadap kode / tes Anda.  Jika cakupan kode menjadi kurang, maka Anda perlu mencapai cakupan 80% lagi dan melanjutkan untuk menulis tes integrasi.  Anda dapat tampil kurang formal dan hanya dipandu oleh akal sehat: misalnya, untuk setiap bug yang telah diputar n kali, menulis tes atau membuat sesuatu yang lain, misalnya, melemparkan koin. <br><br>  Pertanyaan terbuka kedua: <b>tes apa yang dianggap integrasi</b> ?  Mungkin tidak dijawab. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e2b/79e/50e/e2b79e50e0d707af61b1dd1f5a6ab654.png"><br><br>  Dalam tes integrasi, kami menguji pekerjaan tidak satu komponen, tetapi beberapa komponen dalam banyak.  Tidak ada aturan, tetapi akal sehat memberi tahu Anda: <br><br><ul><li>  Jangan menguji bagaimana itu diberikan, di mana ia dipanggil, dan kapan semuanya akan berakhir; <br></li><li>  Jangan menguji pekerjaan ReactJS, jika tidak berhasil, tidak ada yang akan membantu Anda; <br></li><li>  Jangan menguji bagaimana mesin negara Bereaksi bekerja; <br></li><li>  uji logika bisnis / model data / situasi batas / sesuatu yang sering rusak. <br></li></ul><br>  Dalam tes semacam itu, Anda tidak harus memerinci.  Mereka berjalan jauh lebih lama dan juga lebih sulit untuk menulisnya, jadi Anda tidak boleh terbawa dan membahas setiap kasus kecil dalam logika aplikasi.  Ini mahal dalam hal penyewaan infrastruktur, dan lama dalam hal pengembangan dan waktu pelaksanaan skrip.  Seseorang akan menghabiskan hidup mereka pada rutin ini, dan <b>manajer pengguna akan sedih</b> , dan menunggu fitur baru, dan ... <br><br>  Alasan lain mengapa Anda tidak boleh mencoba semuanya adalah Keamanan Palsu (Saya telah mencoba untuk menulis poin paling penting di atas).  Setiap tim harus membaca tentang kesalahan jenis pertama dan kedua, lemma Neumann-Pearson dan menilai risiko mereka dalam hal uang, burung beo atau ukuran kebenaran lainnya yang diterima dalam tim. <br><br>  Tetapi ada pengecualian untuk aturan ini, serta yang lainnya.  <b>Lupakan semua yang dikatakan di atas</b> : <br><br><ul><li>  Saat menguji dependensi dinamis.  Ketika Anda tidak tahu komponen mana yang akan runtuh, Anda merendernya, tetapi itu mungkin tidak datang.  Anda juga perlu menulis tes untuk ini, tidak ada yang membatalkan sirkuit bracker.  Entah komponen yang salah yang Anda harapkan, atau komponen yang rusak akan datang.  Oleh karena itu, dalam hal ini, kami menulis tes integrasi dan render.  Kami memeriksa apakah semuanya berfungsi, jika tidak ada yang jatuh. <br></li><li>  Dengan pixel sempurna (well, Anda mengerti), pengembangan harus membuat dan membedakan tangkapan layar, dan setiap kali perpustakaan komponen diperbarui ke versi baru - perbarui tangkapan layar referensi.  Karena lebih mudah <s>untuk merekrut desainer baru</s> untuk direkonsiliasi daripada memperbaikinya. <br></li></ul><br><h2>  Tes foto </h2><br>  Tes integrasi paling sederhana adalah snapshot: <br><br><ol><li>  Kami mengambil komponen, merendernya </li><li>  Di render kita menulis console.log (ini) </li><li>  Salin data referensi dari konsol </li><li>  Bandingkan </li></ol><br>  Jika Anda ingin sedikit bingung, maka saya menyarankan Anda untuk bermain-main dengan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StoryBook</a> .  Ini adalah perpustakaan untuk tes snapshot, yang secara tidak sengaja membungkus ide <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StyleGuidist</a> - membuat sistem desain Anda sendiri berdasarkan komponen Bereaksi. <br><br>  Aturan pertama dari tes snapshot: <b>jangan pernah <s>katakan,</s> cobalah untuk menguji data</b> .  Mereka harus selalu statis, "terkunci" dan independen.  Aturan kedua: <b>tes snapshot yang rusak tidak berarti semuanya buruk</b> .  Jika dia merah - bukan fakta bahwa semuanya berjalan.  Ada banyak opsi untuk membuat tata letak yang sama, tetapi pohon DOM berbeda.  Jadi kami mengabaikan spasi, atribut, kunci, atau kami tidak menguji apa yang membutuhkan begitu banyak waktu dukungan.  Atau kita tandai dengan tangan kita apa yang rusak, apa yang tidak.  Kami memperbaiki tes yang rusak dan memulai kembali StoryBook dalam mode pembaruan tiruan - mode di mana tes akan membuat komponen dan memasukkan Snapshot sebagai nilai referensi dalam kondisi yang diharapkan. <br><br><h2>  xState dan React Automata </h2><br>  ReactJS adalah hal yang sulit.  Tampaknya perpustakaan itu keren.  Saya membuat tiga komponen - sebuah kelas: dan mesin negara sepertinya berfungsi dan kodenya indah.  Kemudian Anda menulis di ReactJS selama enam bulan, Anda melihat kode - semacam omong kosong.  Anda tidak mengerti di mana kruk, di mana rute, di mana keadaan, di mana cache ... Lalu Anda berpikir: baik, saya akan melakukan seperti yang disarankan Facebook: Saya akan memasang "hokeys", "hooks", sesuatu yang lain dan tiba-tiba melihat diri Anda berpikir bagaimana Anda melakukannya. ru dalam upaya untuk menemukan proyek dengan pengembangan pada reaksi dari awal, sehingga pasti <b>akan melakukan semuanya dengan indah</b> ... <br><br>  Semuanya sangat rumit sehingga umumnya mustahil untuk memahami cara kerjanya.  Dan itu bekerja sampai seseorang mengeluh.  Kami memperbaikinya - dan itu diperbaiki, tetapi rusak ... Salah satu output adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin</a> negara, satu set negara aplikasi deterministik dan memungkinkan transisi di antara mereka.  Dan, seperti yang mereka katakan dalam lingkaran sempit, Anda tidak menulis reaksi jika Anda tidak menghancurkan mesin negara Anda. <br><br>  Perlu mengingat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">xState</a> .  Ini adalah mesin keadaan deterministik untuk JavaScript.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda</a> dapat membuat UI yang sangat keren di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">xState</a> - tautan ke laporan terkait dapat ditemukan dalam dokumentasi perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">React Automata</a> .  Pada gilirannya, React Automata adalah perpustakaan di mana xState diadaptasi dalam ReactJS.  Selain itu, ia dapat <b>membuat tes untuk kondisi mesin negara</b> . <br><br>  Jika kita memiliki centang pertama benar - lampu hijau menyala.  Jika yang kedua salah, maka anjing abu-abu ditarik, dan Bereaksi Automata menghasilkan tes untuk keempat kombinasi parameter ini dan memvalidasi anjing dan umbi.  Benar, pada titik tertentu Anda akan ingin mengurangi setengah dari tes, tetapi pada awalnya Anda akan sangat senang ... Dalam hal apapun, ini adalah pandangan yang nyaman pada tes Anda dari samping, itu mengingatkan saya pada gagasan pengujian dengan kekacauan deterministik. <br><br><h2>  Cypress </h2><br>  Dengan snapshot, kami kira-kira tahu, Anda bisa menuju ke end2end.  Kami memiliki semua produk internal, sehingga solusi di tempat adalah satu-satunya pilihan kami.  Saya harap Anda memiliki kesempatan untuk menggunakan solusi cloud, maka hal seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cypress</a> akan berguna. <br><img src="https://habrastorage.org/getpro/habr/post_images/5fc/c22/6c9/5fcc226c9c4808510f9fdd5d1aed6b9a.png"><br><br>  Sebelumnya, Anda memilih kerangka kerja pengujian, mengambil perpustakaan untuk pernyataan, perpustakaan untuk membandingkan XML yang kompleks.  Kemudian kami memilih driver dan browser untuk memulai semuanya.  Mereka mulai dan menulis banyak tes.  Semua ini memakan infrastruktur, Anda perlu memasukkan semuanya ke buruh pelabuhan, lalu mengacaukan beberapa hal yang melihat tes dalam dinamika, menganalisisnya, menunjukkan apa yang salah ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/84b/6f1/7ff/84b6f17ffbc1b6af51164429d4503f7b.png"><br><br>  Orang-orang Cypress melakukan semuanya untuk Anda.  Mereka memecahkan beberapa masalah: <b>menyiapkan lingkungan kerja, menulis kode, menjalankan dan menulis tes.</b>  Jika tes rusak, Anda dapat menampilkan tangkapan layar yang menyoroti apa yang rusak.  Benar, ini tidak berfungsi untuk ponsel, tetapi di sana, misalnya, adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Detox</a> .  Ini, tentu saja, sulit dari sudut pandang ambang masuk: Anda harus menyesuaikan aplikasi Anda untuk itu, menulis ulang banyak file, dll.  Tetapi jika Anda mau, itu mungkin. <br><br><h2>  Tes lunak </h2><br>  Ada beberapa jenis tes alternatif yang tidak bisa disebut tes yang baik.  Saya menyebutnya tes lunak.  Misalnya, linter.  Mereka terutama digunakan oleh front-end (dan bahkan, kadang-kadang, inspirasi turun ke javists).  Ada banyak linter: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ESLint</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSHint</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prettier</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Standard</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Clinton</a> .  Saya menyarankan <b>Prettier: cepat, murah, ceria, mudah dikonfigurasi, bekerja di luar kotak</b> . <br><br>  Jika Anda ingin menjadi bingung, Anda dapat mengkonfigurasi ESLint.  Biarkan saya memberi Anda sebuah contoh klasik dari sebuah plugin untuknya: ketika seorang pelanggan menemukan komentar dengan ekspresi cabul dalam kode Anda, ia biasanya bersumpah.  Pengembang rumit membuat komentar dalam bahasa Rusia sehingga pelanggan tidak menebak.  Tetapi pelanggan menebak ... menggunakan penerjemah Google dan menemukan segala sesuatu yang dipikirkan pengembang tentangnya.  Jalan keluar dari situasi tidak menyenangkan, mungkin dengan kehilangan uang atau pelanggan.  Untuk kasus ini, <b>Anda selalu dapat mengembangkan plugin untuk ESLint</b> , yang menemukan kata-kata "asli Rusia" dalam kode sumber Anda dan mengatakan: "Oh, maaf, tolak komit Anda." <br><br>  Keindahan linter dalam JavaScript adalah bahwa mereka <b>dapat dimasukkan ke dalam kait pre commit</b> .  Secara pribadi, saya tidak suka Prettier tidak menyimpan sejarah (walaupun, di sisi lain, Prettier juga tidak mengakumulasi hutang teknis).  Dari sudut pandang analisis statistik kode, pengujian semacam itu sangat buruk, karena Anda tidak dapat melihat dinamika proyek, melihat berapa banyak kesalahan yang terjadi kemarin, sehari sebelum kemarin.  Pada prinsipnya, masalah ini diselesaikan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SonarQube</a> , itu juga dalam solusi cloud.  Ini adalah penganalisa kode statistik yang menyimpan sejarah proses, dapat bekerja dengan dua lusin bahasa, termasuk bahkan PHP (siapa lagi yang tidak memerlukan analisis statis? :)).  Di dalamnya, Anda dapat menonton dinamika kerentanan, bug, utang teknis, dan lainnya. <br><br><h3>  Tes kompleksitas </h3><br>  <b>Frontenders</b> menggunakan <b>linter karena mereka menginginkan lekukan yang indah</b> .  Kompleksitas juga merupakan tes lunak yang dapat digunakan untuk memeriksa kualitas kode Anda. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/048/c14/9ef/048c149ef0834000a3ce62a1f7a1a434.png"><br>  <i>Gambar menunjukkan bagaimana saya mencoba mengikuti pemikiran junior yang mengajukan permintaan.</i>  <i>Dalam kasus seperti itu, saya sarankan menghancurkan segalanya dan membangun jalan langsung.</i> <br><br>  Tes kompleksitas mengikuti prinsip yang sangat sederhana: mereka menghitung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kompleksitas siklomatik dari</a> algoritma.  Misalnya, mereka membaca suatu fungsi, menemukan 10 variabel di dalamnya.  Jika 10 - mungkin sulit.  Mari kita tentukan kompleksitas 1. Untuk setiap siklus kita akan memberikan 3 poin, untuk satu siklus dalam satu siklus - 9, untuk setiap siklus dalam satu siklus - 27. Kami menambahkan semuanya dan berkata: kompleksitas siklomatik 120, dan seseorang hanya dapat memahami 6. Arti dari penilaian ini adalah untuk mengatakan secara subyektif ketika Anda perlu memperbaiki kode sumber Anda, pisahkan menjadi beberapa bagian, sorot fungsi baru, dan sejenisnya.  Dan ya, SonarQube juga bisa melakukannya. <br><br><h2>  Tes alternatif </h2><br>  Di dunia saya, tes alternatif juga berlaku untuk tes lunak.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solidaritas</a> adalah hal yang sangat berguna untuk orientasi.  Dan tidak hanya untuk front-end, meskipun ditulis dalam JavaScript.  Ini memungkinkan Anda untuk <b>menguji lingkungan kerja</b> .  Sebelumnya, perlu untuk menyusun instruksi besar, menunjukkan versi bahasa pemrograman, perpustakaan, daftar perangkat lunak yang diperlukan untuk hanya memulai, menjaga semuanya tetap terbaru dll.  Sekarang kita dapat mengatakan ini: “Ini komputer Anda, ini kode sumbernya.  Sampai <b>Solidaritas berlalu</b> , jangan datang. "  Pada saat yang sama, ambang entri rendah.  Solidaritas dapat membuat sidik jari dari lingkungan kerja yang disesuaikan dan memungkinkan Anda untuk menambahkan aturan yang sangat sederhana untuk memvalidasi tidak hanya perangkat lunak yang diinstal.  Dan itu membuat Anda marah ketika mereka datang dengan kata-kata: "Oh, maaf, ada sesuatu yang tidak berhasil bagi saya di sana, dapatkah Anda membantu?" <br><br>  Kasus penggunaan kedua (ini yang utama) adalah <b>menguji lingkungan produksi</b> dengan kata-kata: "Tes unit untuk CI tentu saja berlalu, tetapi konfigurasi CI dan PROD sangat bervariasi.  Jadi tidak ada jaminan ... ".  Tujuan perpustakaan sangat sederhana: untuk memenuhi aturan pertama integrasi berkelanjutan: "semua orang harus memiliki lingkungan yang sama."  Bersih, terisolasi sehingga tidak ada efek samping, baik, atau setidaknya sehingga ada lebih sedikit dari mereka ... yang saya coba untuk menipu? <br><br><h3>  Panggilan API </h3><br>  Kebetulan pengembang dibagi menjadi beberapa tim - beberapa menulis frontend, yang lain menulis backend.  Situasi fiktif yang tidak bisa berada di tim nyata: semuanya bekerja kemarin, dan hari ini setelah dua rilis - depan dan belakang - semuanya pecah.  Siapa yang harus disalahkan?  Saya, sebagai orang dengan pengalaman backend awalnya, selalu mengatakan: front-end.  <b>Sederhana saja, mereka mengacaukan suatu tempat, seperti biasa.</b>  Pada satu titik, vendor front-end datang dan berkata: "Di sini kita membaca posting dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">referensi</a> , membaca panduan ini dan <b>belajar cara melemparkan REST API Anda</b> .  Dan Anda tidak akan percaya itu telah berubah ... "  Secara umum, jika backend Anda bukan teman Swagger, openAPI, atau solusi serupa lainnya - ada baiknya mencatat. <br><br><h2>  Kinerja js </h2><br>  Dan akhirnya, tes kinerja JS.  <b>Tidak ada yang menguji kinerja JS</b> kecuali pembuat browser.  Sebagai aturan, mereka semua menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Benchmark.js</a> .  "Oh, dan kami telah mengasah Explorer kami selama 18 tahun sehingga menampilkan satu miliar tablet lebih cepat daripada di Chrome."  Siapa yang butuh tablet seperti itu? <br><br>  Jika Anda ingin melakukan tes kinerja, lebih baik lanjut dengan cara lain: uji end-to-end dan perhatikan cara kerjanya.  Pengguna membentuk persepsi tentang bagaimana aplikasi bekerja secara keseluruhan, <b>pengguna tidak peduli bahwa ini adalah masalah di sisi backend.</b> <br><br><h3>  Kisah perang # 1 </h3><br>  Sekarang contoh dari kehidupan.  Entah bagaimana bos datang kepada kami dan berkata: "Front Anda bekerja sangat buruk, hampir tidak memuat.  Sesuatu harus dilakukan dengan pertunjukan, orang-orang mengeluh. "  Kami pikir: sekarang kita akan memiliki dua minggu untuk melakukan tuning, mengambil log <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengapa Anda memperbarui</a> , memilih pohon bergetar, memotong semuanya menjadi potongan dengan memuat dinamis ... Bagaimana jika itu tidak terbakar, maka kita akan memecah semuanya atau hanya memperburuknya?  Solusi alternatif perlu dibuat.  <b>Kami membuka browser, lihat: 7,5 MB, 2 detik, semuanya baik-baik saja.</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2c2/b3f/605/2c2b3f605dad87faa6c415fd4f040924.png"><br><br>  Masukkan Nginx GZip: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d78/4b1/679/d784b167908a696379bfda0f6d05a3c3.png"><br><br>  Nginx memiliki kemampuan untuk menyesuaikan rasio kompresi, mari kita coba: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a1/737/09a/4a173709a2eb86d979b08688c702c443.png"><br><br>  Pertumbuhan - 25% dari produktivitas.  Berhenti lebih awal.  Lihatlah logo desainer kecil di sudut.  Itu tetap sangat indah, bahkan jika itu diregangkan, tetapi mengapa kita membutuhkannya? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e3/622/cab/3e3622cab11cec8808352f625bd77cf1.png"><br><br>  Inilah yang Anda dapatkan setelah mengoptimalkan satu gambar.  Anda dapat mengevaluasi sendiri berat logo.  Akhirnya, kami mendatangi pelanggan dan berkata: “unduhan pertama tidak sepenting yang kedua.  Dan, aktifkan caching paksa: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dfd/23a/7ef/dfd23a7ef03ae587a32349959a57f3a7.png"><br><br>  ... Semua orang senang, semua orang gembira! "  Kecuali untuk pengguna, tentu saja. <br><br>  Akibatnya, kami memutuskan untuk melakukan audit ukuran lebih sering.  <b>Gzip, font, gambar, gaya</b> - tempat-tempat yang jarang dilihat orang, tetapi ada banyak manfaatnya. <br><br><h3>  Madge dan updtrJS </h3><br>  Langkah selanjutnya: <b>audit ketergantungan</b> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Madge</a> adalah sesuatu yang menganalisis kode dan mengatakan: ini adalah kelas yang begitu dan begitu terkait dengan ini dan itu, dll.  Jika semuanya melewati satu komponen dan rusak, maka akan ada sedikit kesenangan.  Madge adalah alat visualisasi yang hebat, tetapi hanya cocok untuk eksplorasi manual.  Ini memiliki opsi, melingkar, yang mencari semua <b>dependensi siklik di proyek Anda</b> .  Jika ada, itu buruk, jika tidak, maka mereka belum menulis. <br><br>  Rasa sakit kerangka kerja lama dan perpustakaan hampir diselesaikan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">updtrJS</a> . <br>  Apakah Anda memiliki 70 ribu baris kode?  Apakah Anda mencoba untuk beralih dari Reaksi ke-13 ke ke-16?  <b>Updtr tidak akan membantu Anda</b> pindah, tetapi itu akan membantu Anda mengetahui versi perpustakaan mana yang dapat Anda pindahkan tanpa <b>konsekuensi serius</b> .  Selain itu, ini memungkinkan pengembang untuk tetap dalam tren, membantu menjaga dependensi terbaru.  Jika Anda memiliki cakupan tes yang baik, saya sarankan. <br><br><h3>  Jenis statis </h3><br>  <b>Gunakan pengetikan statis JS</b> , karena pengetikan dinamis <b>JS</b> bukan fitur sama sekali, ini adalah jurang maut.  Flow, typeScript, reasonML itu saja ... <br><br><h3>  Pengujian kekacauan </h3><br>  Inti dari pengujian kekacauan ini sederhana: mulai browser dan mulai menusuk semua yang menusuk, masukkan semua yang dimasukkan ke semua bidang, dan seterusnya.  Sampai rusak.        Amazon,      exceptions  . , «     ,       ».   ,   . : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gremlin.com</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chaos Monkey</a> . <br><br>  React     —   16- ,    componentDidCatch.    ,  exception,      .         . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Naughty String</a> <b>    </b>    ,         ,      . ,     «  »,   internal server error,        ? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/61f/8de/dec/61f8dedec36090e260265ba91468d8c9.gif"><br><br><h3> War Story #2 </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/711/976/e33/711976e3398070d51f30a3105c516da4.png"><br> <i>      –  .    .</i> <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateRandomPostfix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String prefix)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prefix + <span class="hljs-string"><span class="hljs-string">"-"</span></span> + Math.abs(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random().nextInt()).toString() } def <span class="hljs-string"><span class="hljs-string">"testCorrectRandomPostfix"</span></span>(){ given: def prefix = <span class="hljs-string"><span class="hljs-string">"ASD"</span></span> when: def result = generateRandomPostfix(prefix) then: result?.matches(/[a-zA-Z]++-[<span class="hljs-number"><span class="hljs-number">0</span></span>-<span class="hljs-number"><span class="hljs-number">9</span></span>]++/) }</code> </pre><br>      .         .     ,    . <br><br>   .     ASD,  ,          .      .        ( ,     groovy).  Java   integer  1      integer.      integer    integer —      . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/24a/c00/c7b/24ac00c7b3369f13708d8f891f588a0d.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca2/536/74d/ca253674d47f7172f8c7e993ea6a2e71.png"><br><br>  ,   .  .     ?  «+»  fromX.   ,   -    , XML   . <br><br>     . <br><br><h3>   </h3><br>      . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TestCheck.JS</a> —         .  , ,    .   — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flow-To-Gen</a> :     Flow  ,       . <br><br><pre> <code class="javascript hljs">check( property( gen.int, gen.int, (a, b) =&gt; a + b &gt;= a &amp;&amp; a + b &gt;= b ) )</code> </pre><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">result</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">failingSize</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">numTests</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">fail</span></span>: [ <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> ], <span class="hljs-attr"><span class="hljs-attr">shrunk</span></span>: { <span class="hljs-attr"><span class="hljs-attr">totalNodesVisited</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">depth</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">result</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">smallest</span></span>: [ <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> ] } }</code> </pre><br>  TestCheck    « »,     .   ,         . ,  ,  : 0  -1.       2  -1,        ,      .  ! <br><br><h2>   </h2><br> <b>   .</b>    .     ,       .  ,        ?     -?  permission'?   ?    , , ,  ,     . <br><br>      <b>3rd party failures</b> . „     “ —    . <br><br><h3> Production- </h3><br>  production  16- React     : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ErrorCeption</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HoneyBadger</a> (   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sentry</a> ).  ,     <b>    .</b> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Optimizely</a>  <b>/-.</b>   ,      ,  , ,  ,      . <br><br><h2> Out of the box </h2><br> JS —  .    ,       JavaScript.    — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">validator.w3.org/checklink</a> .  ,      , ,     ,    . <br><br>      ,   ,      . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Achecker.ca/checker</a>  . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Webpagetest.org</a> — ,     . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tools.pingdom.com</a> —    .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.w3.org/WAI/ER/tools</a>       . <br><br>         .      .  ,      Jenkins Multibranch Plugin,    -   -.  -,   («  ,     »), nightly-, - regress, full regress, smart regress  .. <br><br>  — ,  ,       ,  ,          .    ,    ,          ,     . <br><br>     , , .      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443316/">https://habr.com/ru/post/id443316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443302/index.html">Bagaimana Apple mempersiapkan era setelah iPhone</a></li>
<li><a href="../id443306/index.html">Delapan Hukum Penamaan dalam Desain UX (Bagian 1)</a></li>
<li><a href="../id443308/index.html">Mitos fisika modern. Hukum konservasi</a></li>
<li><a href="../id443310/index.html">Ulasan Gadget Kesehatan Wanita Bellabeat</a></li>
<li><a href="../id443312/index.html">Manajemen memori python</a></li>
<li><a href="../id443318/index.html">Menulis loader wasm untuk Ghidra. Bagian 1: Pernyataan masalah dan pengaturan lingkungan</a></li>
<li><a href="../id443320/index.html">Sistem manajemen dokumen elektronik "Wazir"</a></li>
<li><a href="../id443322/index.html">GitLab 11.8 dirilis dengan SAST untuk JavaScript, GitLab Pages untuk subkelompok dan pelacakan bug</a></li>
<li><a href="../id443324/index.html">Python vs. Scala for Apache Spark - benchmark yang diharapkan dengan hasil yang tidak terduga</a></li>
<li><a href="../id443326/index.html">Python & Arduino. Sederhana, cepat dan cantik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>