<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñï ‚õ∫Ô∏è üë∞üèΩ Wir besch√§ftigen uns mit Schnittstellen in Go üï• üë®üèæ‚Äç‚úàÔ∏è üñêüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten Monaten habe ich eine Studie durchgef√ºhrt, in der Menschen gefragt wurden, was f√ºr sie in Go schwer zu verstehen ist. Und mir ist aufge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir besch√§ftigen uns mit Schnittstellen in Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/463063/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_f/w7/1l/_fw71luza3o_kj1bh6t015wlp4c.jpeg"></div><br>  In den letzten Monaten habe ich eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Studie durchgef√ºhrt,</a> in der Menschen gefragt wurden, was f√ºr sie in Go schwer zu verstehen ist.  Und mir ist aufgefallen, dass das Konzept der Schnittstellen in den Antworten regelm√§√üig erw√§hnt wurde.  Go war die erste Schnittstellensprache, die ich verwendet habe, und ich erinnere mich, dass dieses Konzept zu dieser Zeit sehr verwirrend schien.  Und in diesem Handbuch m√∂chte ich Folgendes tun: <br><br><ol><li>  In menschlicher Sprache erkl√§ren, was Schnittstellen sind. </li><li>  Erkl√§ren Sie, wie n√ºtzlich sie sind und wie Sie sie in Ihrem Code verwenden k√∂nnen. </li><li> Sprechen Sie dar√ºber, was <code>interface{}</code> (eine leere Schnittstelle). </li><li>  Gehen Sie einige n√ºtzliche Schnittstellentypen durch, die Sie in der Standardbibliothek finden. </li></ol><a name="habracut"></a><br><h2>  Was ist eine Schnittstelle? </h2><br>  Der Schnittstellentyp in Go ist eine Art <i>Definition</i> .  Es definiert und beschreibt die spezifischen Methoden, die <i>ein anderer Typ haben sollte</i> . <br><br>  Einer der Schnittstellentypen aus der Standardbibliothek ist die Schnittstelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fmt.Stringer</a> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Stringer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { String() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br>  Wir sagen, dass etwas <i>diese Schnittstelle erf√ºllt</i> (oder <i>diese Schnittstelle implementiert</i> ), wenn dieses ‚ÄûEtwas‚Äú eine Methode mit einem bestimmten Signaturzeichenfolgenwert <code>String()</code> . <br><br>  Beispielsweise erf√ºllt der Buchtyp die Schnittstelle, da er √ºber die <code>String()</code> String-Methode verf√ºgt: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Book <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Author <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b Book)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">String</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"Book: %s - %s"</span></span>, b.Title, b.Author) }</code> </pre> <br>  Es spielt keine Rolle, welcher Typ das <code>Book</code> oder was es tut.  Alles was z√§hlt ist, dass es eine Methode namens <code>String()</code> gibt, die einen String-Wert zur√ºckgibt. <br><br>  Hier ist ein weiteres Beispiel.  Der <code>Count</code> Typ <i>erf√ºllt auch die Schnittstelle</i> <code>fmt.Stringer</code> <i>,</i> da er √ºber eine Methode mit demselben Signaturzeichenfolgenwert <code>String()</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Count <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c Count)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">String</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strconv.Itoa(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(c)) }</code> </pre> <br>  Es ist wichtig zu verstehen, dass wir zwei verschiedene Arten von <code>Book</code> und <code>Count</code> , die unterschiedlich wirken.  Sie sind sich jedoch dadurch einig, dass beide die <code>fmt.Stringer</code> Schnittstelle erf√ºllen. <br><br>  Sie k√∂nnen es von der anderen Seite betrachten.  Wenn Sie wissen, dass das Objekt die Schnittstelle <code>fmt.Stringer</code> erf√ºllt, k√∂nnen Sie davon ausgehen, dass es eine Methode mit dem Signaturzeichenfolgenwert <code>String()</code> , den Sie aufrufen k√∂nnen. <br><br>  Und jetzt das Wichtigste. <br><br>  <i>Wenn in Go eine Deklaration (einer Variablen, eines Funktionsparameters oder eines Strukturfelds) mit einem Schnittstellentyp angezeigt wird, k√∂nnen Sie ein Objekt eines beliebigen Typs verwenden, solange es die Schnittstelle erf√ºllt.</i> <br><br>  Nehmen wir an, wir haben eine Funktion: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s fmt.Stringer)</span></span></span></span> { log.Println(s.String()) }</code> </pre> <br>  Da <code>WriteLog()</code> in der Parameterdeklaration den Schnittstellentyp <code>fmt.Stringer</code> , k√∂nnen wir jedes Objekt √ºbergeben, das die Schnittstelle <code>fmt.Stringer</code> erf√ºllt.  Beispielsweise k√∂nnen wir die zuvor in der <code>WriteLog()</code> -Methode erstellten <code>WriteLog()</code> und <code>Count</code> Typen √ºbergeben, und der Code funktioniert <code>WriteLog()</code> . <br><br>  Da das √ºbergebene Objekt die Schnittstelle <code>fmt.Stringer</code> erf√ºllt, <i>wissen</i> wir au√üerdem <i>,</i> dass es eine <code>String()</code> -Methode hat, die von der <code>WriteLog()</code> -Funktion sicher aufgerufen werden kann. <br><br>  Lassen Sie uns alles in einem Beispiel zusammenfassen und die Leistungsf√§higkeit von Schnittstellen demonstrieren. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//   Book,    fmt.Stringer. type Book struct { Title string Author string } func (b Book) String() string { return fmt.Sprintf("Book: %s - %s", b.Title, b.Author) } //   Count,    fmt.Stringer. type Count int func (c Count) String() string { return strconv.Itoa(int(c)) } //   WriteLog(),    , //   fmt.Stringer   . func WriteLog(s fmt.Stringer) { log.Println(s.String()) } func main() { //   Book    WriteLog(). book := Book{"Alice in Wonderland", "Lewis Carrol"} WriteLog(book) //   Count    WriteLog(). count := Count(3) WriteLog(count) }</span></span></code> </pre> <br>  Das ist cool.  In der Hauptfunktion haben wir verschiedene Arten von <code>Book</code> und <code>Count</code> , diese jedoch an <i>dieselbe</i> <code>WriteLog()</code> Funktion √ºbergeben.  Und sie rief die entsprechenden <code>String()</code> -Funktionen auf und schrieb die Ergebnisse in das Protokoll. <br><br>  Wenn Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Code ausf√ºhren</a> , erhalten Sie ein √§hnliches Ergebnis: <br><br><pre> <code class="plaintext hljs">2009/11/10 23:00:00 Book: Alice in Wonderland - Lewis Carrol 2009/11/10 23:00:00 3</code> </pre> <br>  Wir werden nicht im Detail darauf eingehen.  Das Wichtigste, das Sie <code>WriteLog()</code> : Mit dem Schnittstellentyp in der Deklaration der <code>WriteLog()</code> -Funktion haben wir die Funktion f√ºr den <i>Typ des</i> empfangenen Objekts gleichg√ºltig (oder flexibel) gemacht.  Was z√§hlt, ist, <i>welche Methoden er hat</i> . <br><br><h2>  Was sind n√ºtzliche Schnittstellen? </h2><br>  Es gibt eine Reihe von Gr√ºnden, warum Sie Schnittstellen in Go verwenden k√∂nnen.  Und meiner Erfahrung nach sind die wichtigsten: <br><br><ol><li>  Schnittstellen helfen dabei, Doppelarbeit zu reduzieren, dh die Menge an Boilerplate-Code. </li><li>  Sie erleichtern die Verwendung von Stubs in Komponententests anstelle von realen Objekten. </li><li>  Als Architekturwerkzeug helfen Schnittstellen dabei, Teile Ihrer Codebasis zu l√∂sen. </li></ol><br>  Schauen wir uns diese M√∂glichkeiten der Verwendung von Schnittstellen genauer an. <br><br><h3>  Reduzieren Sie die Menge des Boilerplate-Codes </h3><br>  Angenommen, wir haben eine <code>Customer</code> , die Kundendaten enth√§lt.  In einem Teil des Codes m√∂chten wir diese Informationen in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bytes.Buffer</a> schreiben, und im anderen Teil m√∂chten wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clientdaten</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">os.File</a> auf der Festplatte schreiben.  In beiden F√§llen m√∂chten wir jedoch zuerst die <code>ustomer</code> Struktur in JSON serialisieren. <br><br>  In diesem Szenario k√∂nnen wir die Menge an Boilerplate-Code mithilfe von Go-Schnittstellen reduzieren. <br><br>  Go hat einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">io.Writer-</a> Schnittstellentyp: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Writer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Write(p []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (n <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, err error) }</code> </pre> <br>  Und wir k√∂nnen die Tatsache ausnutzen, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bytes.Buffer</a> und der Typ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">os.File</a> diese Schnittstelle erf√ºllen, da sie √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Methoden bytes.Buffer.Write ()</a> bzw. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">os.File.Write ()</a> verf√ºgen. <br><br>  Einfache Implementierung: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//   Customer. type Customer struct { Name string Age int } //   WriteJSON,   io.Writer   . //    ustomer  JSON,     // ,     Write()  io.Writer. func (c *Customer) WriteJSON(w io.Writer) error { js, err := json.Marshal(c) if err != nil { return err } _, err = w.Write(js) return err } func main() { //   Customer. c := &amp;Customer{Name: "Alice", Age: 21} //    Buffer    WriteJSON var buf bytes.Buffer err := c.WriteJSON(buf) if err != nil { log.Fatal(err) } //   . f, err := os.Create("/tmp/customer") if err != nil { log.Fatal(err) } defer f.Close() err = c.WriteJSON(f) if err != nil { log.Fatal(err) } }</span></span></code> </pre> <br>  Dies ist nat√ºrlich nur ein fiktives Beispiel (wir k√∂nnen den Code unterschiedlich strukturieren, um das gleiche Ergebnis zu erzielen).  Die Vorteile der Verwendung von Schnittstellen werden jedoch gut veranschaulicht: Wir k√∂nnen die <code>Customer.WriteJSON()</code> -Methode einmal erstellen und jedes Mal aufrufen, wenn wir auf etwas schreiben m√ºssen, das die <code>io.Writer</code> Schnittstelle erf√ºllt. <br><br>  Wenn Sie Go noch nicht kennen, werden Sie einige Fragen haben: ‚Äû <i>Woher wei√ü ich, ob die io.Writer-Oberfl√§che √ºberhaupt vorhanden ist?</i>  <i>Und woher wei√üt du im Voraus, dass er zufrieden ist <code>bytes.Buffer</code> und <code>os.File</code> ?</i>  "" <br><br>  Ich f√ºrchte, es gibt keine einfache L√∂sung.  Sie m√ºssen nur Erfahrungen sammeln, sich mit den Schnittstellen und verschiedenen Typen aus der Standardbibliothek vertraut machen.  Dies hilft beim Lesen der Dokumentation f√ºr diese Bibliothek und beim Anzeigen des Codes einer anderen Person.  Zum schnellen Nachschlagen habe ich am Ende des Artikels die n√ºtzlichsten Arten von Schnittstellentypen hinzugef√ºgt. <br><br>  Aber selbst wenn Sie keine Schnittstellen aus der Standardbibliothek verwenden, hindert Sie nichts daran, <i>eigene Schnittstellentypen zu</i> erstellen und zu verwenden.  Wir werden weiter unten dar√ºber sprechen. <br><br><h3>  Unit Testing und Stubs </h3><br>  Schauen wir uns ein komplexeres Beispiel an, um zu verstehen, wie Schnittstellen beim Testen von Einheiten helfen. <br><br>  Angenommen, Sie haben ein Gesch√§ft und Gesch√§ftsinformationen √ºber Verk√§ufe und die Anzahl der Kunden in PostgreSQL.  Sie m√∂chten einen Code schreiben, der den Umsatzanteil (bestimmte Anzahl der Verk√§ufe pro Kunde) f√ºr den letzten Tag berechnet und auf zwei Dezimalstellen gerundet wird. <br><br>  Eine minimale Implementierung w√ºrde folgenderma√üen aussehen: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// : main.go package main import ( "fmt" "log" "time" "database/sql" _ "github.com/lib/pq" ) type ShopDB struct { *sql.DB } func (sdb *ShopDB) CountCustomers(since time.Time) (int, error) { var count int err := sdb.QueryRow("SELECT count(*) FROM customers WHERE timestamp &gt; $1", since).Scan(&amp;count) return count, err } func (sdb *ShopDB) CountSales(since time.Time) (int, error) { var count int err := sdb.QueryRow("SELECT count(*) FROM sales WHERE timestamp &gt; $1", since).Scan(&amp;count) return count, err } func main() { db, err := sql.Open("postgres", "postgres://user:pass@localhost/db") if err != nil { log.Fatal(err) } defer db.Close() shopDB := &amp;ShopDB{db} sr, err := calculateSalesRate(shopDB) if err != nil { log.Fatal(err) } fmt.Printf(sr) } func calculateSalesRate(sdb *ShopDB) (string, error) { since := time.Now().Sub(24 * time.Hour) sales, err := sdb.CountSales(since) if err != nil { return "", err } customers, err := sdb.CountCustomers(since) if err != nil { return "", err } rate := float64(sales) / float64(customers) return fmt.Sprintf("%.2f", rate), nil }</span></span></code> </pre> <br>  Jetzt m√∂chten wir einen Komponententest f√ºr die Funktion <code>calculateSalesRate()</code> erstellen, um zu √ºberpr√ºfen, ob die Berechnungen korrekt sind. <br><br>  Jetzt ist es problematisch.  Wir m√ºssen eine Testinstanz von PostgreSQL konfigurieren sowie Skripte erstellen und l√∂schen, um die Datenbank mit gef√§lschten Daten zu f√ºllen.  Wir haben viel zu tun, wenn wir unsere Berechnungen wirklich testen wollen. <br><br>  Und die Schnittstellen kommen zur Rettung! <br><br>  Wir werden unseren eigenen Schnittstellentyp erstellen, der die Methoden <code>CountSales()</code> und <code>CountCustomers()</code> , auf die sich die Funktion <code>calculateSalesRate()</code> st√ºtzt.  Aktualisieren Sie dann die Signatur <code>calculateSalesRate()</code> , um diesen Schnittstellentyp als Parameter anstelle des vorgeschriebenen <code>*ShopDB</code> Typs zu verwenden. <br><br>  So: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// : main.go package main import ( "fmt" "log" "time" "database/sql" _ "github.com/lib/pq" ) //    ShopModel.     //     ,     //  -,     . type ShopModel interface { CountCustomers(time.Time) (int, error) CountSales(time.Time) (int, error) } //  ShopDB    ShopModel,   //       -- CountCustomers()  CountSales(). type ShopDB struct { *sql.DB } func (sdb *ShopDB) CountCustomers(since time.Time) (int, error) { var count int err := sdb.QueryRow("SELECT count(*) FROM customers WHERE timestamp &gt; $1", since).Scan(&amp;count) return count, err } func (sdb *ShopDB) CountSales(since time.Time) (int, error) { var count int err := sdb.QueryRow("SELECT count(*) FROM sales WHERE timestamp &gt; $1", since).Scan(&amp;count) return count, err } func main() { db, err := sql.Open("postgres", "postgres://user:pass@localhost/db") if err != nil { log.Fatal(err) } defer db.Close() shopDB := &amp;ShopDB{db} sr := calculateSalesRate(shopDB) fmt.Printf(sr) } //       ShopModel    //    *ShopDB. func calculateSalesRate(sm ShopModel) string { since := time.Now().Sub(24 * time.Hour) sales, err := sm.CountSales(since) if err != nil { return "", err } customers, err := sm.CountCustomers(since) if err != nil { return "", err } rate := float64(sales) / float64(customers) return fmt.Sprintf("%.2f", rate), nil }</span></span></code> </pre> <br>  Nachdem wir dies getan haben, erstellen wir einfach einen Stub, der die <code>ShopModel</code> Oberfl√§che erf√ºllt.  Dann k√∂nnen Sie es w√§hrend des Unit-Tests der korrekten Funktionsweise der mathematischen Logik in der Funktion <code>calculateSalesRate()</code> .  So: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// : main_test.go package main import ( "testing" ) type MockShopDB struct{} func (m *MockShopDB) CountCustomers() (int, error) { return 1000, nil } func (m *MockShopDB) CountSales() (int, error) { return 333, nil } func TestCalculateSalesRate(t *testing.T) { //  . m := &amp;MockShopDB{} //     calculateSalesRate(). sr := calculateSalesRate(m) // ,        //   . exp := "0.33" if sr != exp { t.Fatalf("got %v; expected %v", sr, exp) } }</span></span></code> </pre> <br>  F√ºhren Sie nun den Test aus und alles funktioniert einwandfrei. <br><br><h3>  Anwendungsarchitektur </h3><br>  Im vorherigen Beispiel haben wir gesehen, wie Sie mithilfe von Schnittstellen bestimmte Teile des Codes von der Verwendung bestimmter Typen entkoppeln k√∂nnen.  Beispielsweise spielt die Funktion <code>calculateSalesRate()</code> keine Rolle, was Sie an sie √ºbergeben, solange sie die <code>ShopModel</code> Oberfl√§che erf√ºllt. <br><br>  Sie k√∂nnen diese Idee erweitern und in gro√üen Projekten ganze ‚Äûungebundene‚Äú Ebenen erstellen. <br>  Angenommen, Sie erstellen eine Webanwendung, die mit einer Datenbank interagiert.  Wenn Sie eine Schnittstelle erstellen, die bestimmte Methoden f√ºr die Interaktion mit der Datenbank beschreibt, k√∂nnen Sie √ºber HTTP-Handler auf diese anstelle eines bestimmten Typs verweisen.  Da sich HTTP-Handler nur auf die Schnittstelle beziehen, k√∂nnen Sie die HTTP-Ebene und die Interaktionsebene mit der Datenbank voneinander entkoppeln.  Es wird einfacher sein, unabh√§ngig mit Ebenen zu arbeiten, und in Zukunft k√∂nnen Sie einige Ebenen ersetzen, ohne die Arbeit anderer zu beeintr√§chtigen. <br><br>  Ich habe in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem der vorherigen Beitr√§ge</a> √ºber dieses Muster geschrieben, es gibt weitere Details und praktische Beispiele. <br><br><h2>  Was ist eine leere Schnittstelle? </h2><br>  Wenn Sie schon l√§nger auf Go programmiert haben, sind Sie wahrscheinlich auf eine <i>leere Schnittstelle vom Typ</i> <code>interface{}</code> .  Ich werde versuchen zu erkl√§ren, was es ist.  Am Anfang dieses Artikels schrieb ich: <br><br><blockquote>  Der Schnittstellentyp in Go ist eine Art <i>Definition</i> .  Es definiert und beschreibt die spezifischen Methoden, die <i>ein anderer Typ haben sollte</i> . </blockquote><br>  Ein leerer Schnittstellentyp <i>beschreibt keine Methoden</i> .  Er hat keine Regeln.  Und so erf√ºllt jedes Objekt eine leere Schnittstelle. <br><br>  Im Wesentlichen ist der leere Schnittstellentyp <code>interface{}</code> eine Art Joker.  Wenn Sie es in einer Deklaration (Variable, Funktionsparameter oder Strukturfeld) getroffen haben, k√∂nnen Sie ein Objekt eines <i>beliebigen Typs verwenden</i> . <br><br>  Betrachten Sie den Code: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { person := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, <span class="hljs-number"><span class="hljs-number">0</span></span>) person[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"Alice"</span></span> person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = <span class="hljs-number"><span class="hljs-number">21</span></span> person[<span class="hljs-string"><span class="hljs-string">"height"</span></span>] = <span class="hljs-number"><span class="hljs-number">167.64</span></span> fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%+v"</span></span>, person) }</code> </pre> <br>  Hier initialisieren wir die Zuordnung zur <code>person</code> , die einen Zeichenfolgentyp f√ºr Schl√ºssel und einen leeren Schnittstellentyp <code>interface{}</code> f√ºr Werte verwendet.  Wir haben drei verschiedene Typen als Map-Werte zugewiesen (String, Integer und Float32), und das ist kein Problem.  Da Objekte jeglicher Art die leere Schnittstelle erf√ºllen, funktioniert der Code hervorragend. <br><br>  Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Code hier ausf√ºhren</a> . Sie sehen ein √§hnliches Ergebnis: <br><br><pre> <code class="plaintext hljs">map[age:21 height:167.64 name:Alice]</code> </pre> <br>  Wenn Sie Werte aus einer Karte extrahieren und verwenden m√∂chten, ist es wichtig, dies zu ber√ºcksichtigen.  Angenommen, Sie m√∂chten den <code>age</code> abrufen und um 1 erh√∂hen. Wenn Sie einen √§hnlichen Code schreiben, wird dieser nicht kompiliert: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { person := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, <span class="hljs-number"><span class="hljs-number">0</span></span>) person[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"Alice"</span></span> person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = <span class="hljs-number"><span class="hljs-number">21</span></span> person[<span class="hljs-string"><span class="hljs-string">"height"</span></span>] = <span class="hljs-number"><span class="hljs-number">167.64</span></span> person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span> fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%+v"</span></span>, person) }</code> </pre> <br>  Sie erhalten eine Fehlermeldung: <br><br><pre> <code class="plaintext hljs">invalid operation: person["age"] + 1 (mismatched types interface {} and int)</code> </pre> <br>  Der Grund daf√ºr ist, dass der in map gespeicherte Wert den Typ <code>interface{}</code> annimmt und seinen urspr√ºnglichen Basis-Int-Typ verliert.  Und da der Wert nicht mehr ganzzahlig ist, k√∂nnen wir ihm keine 1 hinzuf√ºgen. <br><br>  Um dies zu umgehen, m√ºssen Sie den Wert erneut ganzzahlig machen und ihn erst dann verwenden: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { person := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, <span class="hljs-number"><span class="hljs-number">0</span></span>) person[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"Alice"</span></span> person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = <span class="hljs-number"><span class="hljs-number">21</span></span> person[<span class="hljs-string"><span class="hljs-string">"height"</span></span>] = <span class="hljs-number"><span class="hljs-number">167.64</span></span> age, ok := person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>].(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { log.Fatal(<span class="hljs-string"><span class="hljs-string">"could not assert value to int"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = age + <span class="hljs-number"><span class="hljs-number">1</span></span> log.Printf(<span class="hljs-string"><span class="hljs-string">"%+v"</span></span>, person) }</code> </pre> <br>  Wenn Sie dies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausf√ºhren</a> , funktioniert alles wie erwartet: <br><br><pre> <code class="plaintext hljs">2009/11/10 23:00:00 map[age:22 height:167.64 name:Alice]</code> </pre> <br>  Wann sollten Sie einen leeren Schnittstellentyp verwenden? <br><br>  Vielleicht <i>nicht zu oft</i> .  Wenn Sie dazu kommen, h√∂ren Sie auf und √ºberlegen Sie, ob es richtig ist, die <code>interface{}</code> .  Als allgemeinen Rat kann ich sagen, dass es verst√§ndlicher, sicherer und produktiver ist, bestimmte Typen zu verwenden, dh nicht leere Schnittstellentypen.  Im obigen Beispiel war es besser, eine <code>Person</code> mit entsprechend eingegebenen Feldern zu definieren: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Age <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Height <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> }</code> </pre> <br>  Eine leere Oberfl√§che ist dagegen n√ºtzlich, wenn Sie auf unvorhersehbare oder benutzerdefinierte Typen zugreifen und mit diesen arbeiten m√ºssen.  Aus irgendeinem Grund werden solche Schnittstellen an verschiedenen Stellen in der Standardbibliothek verwendet, z. B. in den Funktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gob.Encode</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fmt.Print</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">template.Execute</a> . <br><br><h2>  N√ºtzliche Schnittstellentypen </h2><br>  Hier ist eine kurze Liste der am h√§ufigsten nachgefragten und n√ºtzlichen Schnittstellentypen aus der Standardbibliothek.  Wenn Sie noch nicht mit ihnen vertraut sind, empfehle ich, die entsprechende Dokumentation zu lesen. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">builtin.Error</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fmt.Stringer</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">io.Reader</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">io.Writer</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">io.ReadWriteCloser</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://golang.org/pkg/net/">http.ResponseWriter</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://golang.org/pkg/net/">http.Handler</a> <br></li></ul><br>  Eine l√§ngere Liste der Standardbibliotheken finden Sie auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463063/">https://habr.com/ru/post/de463063/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463045/index.html">Erkennen Sie Emotionen automatisch in Textkonversationen mithilfe neuronaler Netze</a></li>
<li><a href="../de463055/index.html">√úber Administratoren, Entwickler, endlose Verwirrung und DevOps-Transformation innerhalb des Unternehmens</a></li>
<li><a href="../de463057/index.html">Benutzerdefinierte Rechte f√ºr Yii Framework 2</a></li>
<li><a href="../de463059/index.html">Drei leben in der IT und nicht nur</a></li>
<li><a href="../de463061/index.html">Regeln f√ºr die Erstellung von Layouts in Figma</a></li>
<li><a href="../de463067/index.html">Zuerst die Vorderseite und dann die R√ºckseite (eines Tages)</a></li>
<li><a href="../de463069/index.html">Reagieren Sie auf den animierten Leitfaden</a></li>
<li><a href="../de463071/index.html">Welche Auswirkungen haben Internetausf√§lle?</a></li>
<li><a href="../de463073/index.html">QUIC in Aktion: Wie Uber es implementiert hat, um die Leistung zu optimieren</a></li>
<li><a href="../de463075/index.html">Neue Open Source-Lizenzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>