<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕 ⛺️ 👰🏽 Wir beschäftigen uns mit Schnittstellen in Go 🕥 👨🏾‍✈️ 🖐🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten Monaten habe ich eine Studie durchgeführt, in der Menschen gefragt wurden, was für sie in Go schwer zu verstehen ist. Und mir ist aufge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir beschäftigen uns mit Schnittstellen in Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/463063/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_f/w7/1l/_fw71luza3o_kj1bh6t015wlp4c.jpeg"></div><br>  In den letzten Monaten habe ich eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Studie durchgeführt,</a> in der Menschen gefragt wurden, was für sie in Go schwer zu verstehen ist.  Und mir ist aufgefallen, dass das Konzept der Schnittstellen in den Antworten regelmäßig erwähnt wurde.  Go war die erste Schnittstellensprache, die ich verwendet habe, und ich erinnere mich, dass dieses Konzept zu dieser Zeit sehr verwirrend schien.  Und in diesem Handbuch möchte ich Folgendes tun: <br><br><ol><li>  In menschlicher Sprache erklären, was Schnittstellen sind. </li><li>  Erklären Sie, wie nützlich sie sind und wie Sie sie in Ihrem Code verwenden können. </li><li> Sprechen Sie darüber, was <code>interface{}</code> (eine leere Schnittstelle). </li><li>  Gehen Sie einige nützliche Schnittstellentypen durch, die Sie in der Standardbibliothek finden. </li></ol><a name="habracut"></a><br><h2>  Was ist eine Schnittstelle? </h2><br>  Der Schnittstellentyp in Go ist eine Art <i>Definition</i> .  Es definiert und beschreibt die spezifischen Methoden, die <i>ein anderer Typ haben sollte</i> . <br><br>  Einer der Schnittstellentypen aus der Standardbibliothek ist die Schnittstelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fmt.Stringer</a> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Stringer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { String() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br>  Wir sagen, dass etwas <i>diese Schnittstelle erfüllt</i> (oder <i>diese Schnittstelle implementiert</i> ), wenn dieses „Etwas“ eine Methode mit einem bestimmten Signaturzeichenfolgenwert <code>String()</code> . <br><br>  Beispielsweise erfüllt der Buchtyp die Schnittstelle, da er über die <code>String()</code> String-Methode verfügt: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Book <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Author <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b Book)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">String</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"Book: %s - %s"</span></span>, b.Title, b.Author) }</code> </pre> <br>  Es spielt keine Rolle, welcher Typ das <code>Book</code> oder was es tut.  Alles was zählt ist, dass es eine Methode namens <code>String()</code> gibt, die einen String-Wert zurückgibt. <br><br>  Hier ist ein weiteres Beispiel.  Der <code>Count</code> Typ <i>erfüllt auch die Schnittstelle</i> <code>fmt.Stringer</code> <i>,</i> da er über eine Methode mit demselben Signaturzeichenfolgenwert <code>String()</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Count <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c Count)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">String</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strconv.Itoa(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(c)) }</code> </pre> <br>  Es ist wichtig zu verstehen, dass wir zwei verschiedene Arten von <code>Book</code> und <code>Count</code> , die unterschiedlich wirken.  Sie sind sich jedoch dadurch einig, dass beide die <code>fmt.Stringer</code> Schnittstelle erfüllen. <br><br>  Sie können es von der anderen Seite betrachten.  Wenn Sie wissen, dass das Objekt die Schnittstelle <code>fmt.Stringer</code> erfüllt, können Sie davon ausgehen, dass es eine Methode mit dem Signaturzeichenfolgenwert <code>String()</code> , den Sie aufrufen können. <br><br>  Und jetzt das Wichtigste. <br><br>  <i>Wenn in Go eine Deklaration (einer Variablen, eines Funktionsparameters oder eines Strukturfelds) mit einem Schnittstellentyp angezeigt wird, können Sie ein Objekt eines beliebigen Typs verwenden, solange es die Schnittstelle erfüllt.</i> <br><br>  Nehmen wir an, wir haben eine Funktion: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s fmt.Stringer)</span></span></span></span> { log.Println(s.String()) }</code> </pre> <br>  Da <code>WriteLog()</code> in der Parameterdeklaration den Schnittstellentyp <code>fmt.Stringer</code> , können wir jedes Objekt übergeben, das die Schnittstelle <code>fmt.Stringer</code> erfüllt.  Beispielsweise können wir die zuvor in der <code>WriteLog()</code> -Methode erstellten <code>WriteLog()</code> und <code>Count</code> Typen übergeben, und der Code funktioniert <code>WriteLog()</code> . <br><br>  Da das übergebene Objekt die Schnittstelle <code>fmt.Stringer</code> erfüllt, <i>wissen</i> wir außerdem <i>,</i> dass es eine <code>String()</code> -Methode hat, die von der <code>WriteLog()</code> -Funktion sicher aufgerufen werden kann. <br><br>  Lassen Sie uns alles in einem Beispiel zusammenfassen und die Leistungsfähigkeit von Schnittstellen demonstrieren. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//   Book,    fmt.Stringer. type Book struct { Title string Author string } func (b Book) String() string { return fmt.Sprintf("Book: %s - %s", b.Title, b.Author) } //   Count,    fmt.Stringer. type Count int func (c Count) String() string { return strconv.Itoa(int(c)) } //   WriteLog(),    , //   fmt.Stringer   . func WriteLog(s fmt.Stringer) { log.Println(s.String()) } func main() { //   Book    WriteLog(). book := Book{"Alice in Wonderland", "Lewis Carrol"} WriteLog(book) //   Count    WriteLog(). count := Count(3) WriteLog(count) }</span></span></code> </pre> <br>  Das ist cool.  In der Hauptfunktion haben wir verschiedene Arten von <code>Book</code> und <code>Count</code> , diese jedoch an <i>dieselbe</i> <code>WriteLog()</code> Funktion übergeben.  Und sie rief die entsprechenden <code>String()</code> -Funktionen auf und schrieb die Ergebnisse in das Protokoll. <br><br>  Wenn Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Code ausführen</a> , erhalten Sie ein ähnliches Ergebnis: <br><br><pre> <code class="plaintext hljs">2009/11/10 23:00:00 Book: Alice in Wonderland - Lewis Carrol 2009/11/10 23:00:00 3</code> </pre> <br>  Wir werden nicht im Detail darauf eingehen.  Das Wichtigste, das Sie <code>WriteLog()</code> : Mit dem Schnittstellentyp in der Deklaration der <code>WriteLog()</code> -Funktion haben wir die Funktion für den <i>Typ des</i> empfangenen Objekts gleichgültig (oder flexibel) gemacht.  Was zählt, ist, <i>welche Methoden er hat</i> . <br><br><h2>  Was sind nützliche Schnittstellen? </h2><br>  Es gibt eine Reihe von Gründen, warum Sie Schnittstellen in Go verwenden können.  Und meiner Erfahrung nach sind die wichtigsten: <br><br><ol><li>  Schnittstellen helfen dabei, Doppelarbeit zu reduzieren, dh die Menge an Boilerplate-Code. </li><li>  Sie erleichtern die Verwendung von Stubs in Komponententests anstelle von realen Objekten. </li><li>  Als Architekturwerkzeug helfen Schnittstellen dabei, Teile Ihrer Codebasis zu lösen. </li></ol><br>  Schauen wir uns diese Möglichkeiten der Verwendung von Schnittstellen genauer an. <br><br><h3>  Reduzieren Sie die Menge des Boilerplate-Codes </h3><br>  Angenommen, wir haben eine <code>Customer</code> , die Kundendaten enthält.  In einem Teil des Codes möchten wir diese Informationen in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bytes.Buffer</a> schreiben, und im anderen Teil möchten wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clientdaten</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">os.File</a> auf der Festplatte schreiben.  In beiden Fällen möchten wir jedoch zuerst die <code>ustomer</code> Struktur in JSON serialisieren. <br><br>  In diesem Szenario können wir die Menge an Boilerplate-Code mithilfe von Go-Schnittstellen reduzieren. <br><br>  Go hat einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">io.Writer-</a> Schnittstellentyp: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Writer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Write(p []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (n <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, err error) }</code> </pre> <br>  Und wir können die Tatsache ausnutzen, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bytes.Buffer</a> und der Typ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">os.File</a> diese Schnittstelle erfüllen, da sie über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Methoden bytes.Buffer.Write ()</a> bzw. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">os.File.Write ()</a> verfügen. <br><br>  Einfache Implementierung: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//   Customer. type Customer struct { Name string Age int } //   WriteJSON,   io.Writer   . //    ustomer  JSON,     // ,     Write()  io.Writer. func (c *Customer) WriteJSON(w io.Writer) error { js, err := json.Marshal(c) if err != nil { return err } _, err = w.Write(js) return err } func main() { //   Customer. c := &amp;Customer{Name: "Alice", Age: 21} //    Buffer    WriteJSON var buf bytes.Buffer err := c.WriteJSON(buf) if err != nil { log.Fatal(err) } //   . f, err := os.Create("/tmp/customer") if err != nil { log.Fatal(err) } defer f.Close() err = c.WriteJSON(f) if err != nil { log.Fatal(err) } }</span></span></code> </pre> <br>  Dies ist natürlich nur ein fiktives Beispiel (wir können den Code unterschiedlich strukturieren, um das gleiche Ergebnis zu erzielen).  Die Vorteile der Verwendung von Schnittstellen werden jedoch gut veranschaulicht: Wir können die <code>Customer.WriteJSON()</code> -Methode einmal erstellen und jedes Mal aufrufen, wenn wir auf etwas schreiben müssen, das die <code>io.Writer</code> Schnittstelle erfüllt. <br><br>  Wenn Sie Go noch nicht kennen, werden Sie einige Fragen haben: „ <i>Woher weiß ich, ob die io.Writer-Oberfläche überhaupt vorhanden ist?</i>  <i>Und woher weißt du im Voraus, dass er zufrieden ist <code>bytes.Buffer</code> und <code>os.File</code> ?</i>  "" <br><br>  Ich fürchte, es gibt keine einfache Lösung.  Sie müssen nur Erfahrungen sammeln, sich mit den Schnittstellen und verschiedenen Typen aus der Standardbibliothek vertraut machen.  Dies hilft beim Lesen der Dokumentation für diese Bibliothek und beim Anzeigen des Codes einer anderen Person.  Zum schnellen Nachschlagen habe ich am Ende des Artikels die nützlichsten Arten von Schnittstellentypen hinzugefügt. <br><br>  Aber selbst wenn Sie keine Schnittstellen aus der Standardbibliothek verwenden, hindert Sie nichts daran, <i>eigene Schnittstellentypen zu</i> erstellen und zu verwenden.  Wir werden weiter unten darüber sprechen. <br><br><h3>  Unit Testing und Stubs </h3><br>  Schauen wir uns ein komplexeres Beispiel an, um zu verstehen, wie Schnittstellen beim Testen von Einheiten helfen. <br><br>  Angenommen, Sie haben ein Geschäft und Geschäftsinformationen über Verkäufe und die Anzahl der Kunden in PostgreSQL.  Sie möchten einen Code schreiben, der den Umsatzanteil (bestimmte Anzahl der Verkäufe pro Kunde) für den letzten Tag berechnet und auf zwei Dezimalstellen gerundet wird. <br><br>  Eine minimale Implementierung würde folgendermaßen aussehen: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// : main.go package main import ( "fmt" "log" "time" "database/sql" _ "github.com/lib/pq" ) type ShopDB struct { *sql.DB } func (sdb *ShopDB) CountCustomers(since time.Time) (int, error) { var count int err := sdb.QueryRow("SELECT count(*) FROM customers WHERE timestamp &gt; $1", since).Scan(&amp;count) return count, err } func (sdb *ShopDB) CountSales(since time.Time) (int, error) { var count int err := sdb.QueryRow("SELECT count(*) FROM sales WHERE timestamp &gt; $1", since).Scan(&amp;count) return count, err } func main() { db, err := sql.Open("postgres", "postgres://user:pass@localhost/db") if err != nil { log.Fatal(err) } defer db.Close() shopDB := &amp;ShopDB{db} sr, err := calculateSalesRate(shopDB) if err != nil { log.Fatal(err) } fmt.Printf(sr) } func calculateSalesRate(sdb *ShopDB) (string, error) { since := time.Now().Sub(24 * time.Hour) sales, err := sdb.CountSales(since) if err != nil { return "", err } customers, err := sdb.CountCustomers(since) if err != nil { return "", err } rate := float64(sales) / float64(customers) return fmt.Sprintf("%.2f", rate), nil }</span></span></code> </pre> <br>  Jetzt möchten wir einen Komponententest für die Funktion <code>calculateSalesRate()</code> erstellen, um zu überprüfen, ob die Berechnungen korrekt sind. <br><br>  Jetzt ist es problematisch.  Wir müssen eine Testinstanz von PostgreSQL konfigurieren sowie Skripte erstellen und löschen, um die Datenbank mit gefälschten Daten zu füllen.  Wir haben viel zu tun, wenn wir unsere Berechnungen wirklich testen wollen. <br><br>  Und die Schnittstellen kommen zur Rettung! <br><br>  Wir werden unseren eigenen Schnittstellentyp erstellen, der die Methoden <code>CountSales()</code> und <code>CountCustomers()</code> , auf die sich die Funktion <code>calculateSalesRate()</code> stützt.  Aktualisieren Sie dann die Signatur <code>calculateSalesRate()</code> , um diesen Schnittstellentyp als Parameter anstelle des vorgeschriebenen <code>*ShopDB</code> Typs zu verwenden. <br><br>  So: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// : main.go package main import ( "fmt" "log" "time" "database/sql" _ "github.com/lib/pq" ) //    ShopModel.     //     ,     //  -,     . type ShopModel interface { CountCustomers(time.Time) (int, error) CountSales(time.Time) (int, error) } //  ShopDB    ShopModel,   //       -- CountCustomers()  CountSales(). type ShopDB struct { *sql.DB } func (sdb *ShopDB) CountCustomers(since time.Time) (int, error) { var count int err := sdb.QueryRow("SELECT count(*) FROM customers WHERE timestamp &gt; $1", since).Scan(&amp;count) return count, err } func (sdb *ShopDB) CountSales(since time.Time) (int, error) { var count int err := sdb.QueryRow("SELECT count(*) FROM sales WHERE timestamp &gt; $1", since).Scan(&amp;count) return count, err } func main() { db, err := sql.Open("postgres", "postgres://user:pass@localhost/db") if err != nil { log.Fatal(err) } defer db.Close() shopDB := &amp;ShopDB{db} sr := calculateSalesRate(shopDB) fmt.Printf(sr) } //       ShopModel    //    *ShopDB. func calculateSalesRate(sm ShopModel) string { since := time.Now().Sub(24 * time.Hour) sales, err := sm.CountSales(since) if err != nil { return "", err } customers, err := sm.CountCustomers(since) if err != nil { return "", err } rate := float64(sales) / float64(customers) return fmt.Sprintf("%.2f", rate), nil }</span></span></code> </pre> <br>  Nachdem wir dies getan haben, erstellen wir einfach einen Stub, der die <code>ShopModel</code> Oberfläche erfüllt.  Dann können Sie es während des Unit-Tests der korrekten Funktionsweise der mathematischen Logik in der Funktion <code>calculateSalesRate()</code> .  So: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// : main_test.go package main import ( "testing" ) type MockShopDB struct{} func (m *MockShopDB) CountCustomers() (int, error) { return 1000, nil } func (m *MockShopDB) CountSales() (int, error) { return 333, nil } func TestCalculateSalesRate(t *testing.T) { //  . m := &amp;MockShopDB{} //     calculateSalesRate(). sr := calculateSalesRate(m) // ,        //   . exp := "0.33" if sr != exp { t.Fatalf("got %v; expected %v", sr, exp) } }</span></span></code> </pre> <br>  Führen Sie nun den Test aus und alles funktioniert einwandfrei. <br><br><h3>  Anwendungsarchitektur </h3><br>  Im vorherigen Beispiel haben wir gesehen, wie Sie mithilfe von Schnittstellen bestimmte Teile des Codes von der Verwendung bestimmter Typen entkoppeln können.  Beispielsweise spielt die Funktion <code>calculateSalesRate()</code> keine Rolle, was Sie an sie übergeben, solange sie die <code>ShopModel</code> Oberfläche erfüllt. <br><br>  Sie können diese Idee erweitern und in großen Projekten ganze „ungebundene“ Ebenen erstellen. <br>  Angenommen, Sie erstellen eine Webanwendung, die mit einer Datenbank interagiert.  Wenn Sie eine Schnittstelle erstellen, die bestimmte Methoden für die Interaktion mit der Datenbank beschreibt, können Sie über HTTP-Handler auf diese anstelle eines bestimmten Typs verweisen.  Da sich HTTP-Handler nur auf die Schnittstelle beziehen, können Sie die HTTP-Ebene und die Interaktionsebene mit der Datenbank voneinander entkoppeln.  Es wird einfacher sein, unabhängig mit Ebenen zu arbeiten, und in Zukunft können Sie einige Ebenen ersetzen, ohne die Arbeit anderer zu beeinträchtigen. <br><br>  Ich habe in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem der vorherigen Beiträge</a> über dieses Muster geschrieben, es gibt weitere Details und praktische Beispiele. <br><br><h2>  Was ist eine leere Schnittstelle? </h2><br>  Wenn Sie schon länger auf Go programmiert haben, sind Sie wahrscheinlich auf eine <i>leere Schnittstelle vom Typ</i> <code>interface{}</code> .  Ich werde versuchen zu erklären, was es ist.  Am Anfang dieses Artikels schrieb ich: <br><br><blockquote>  Der Schnittstellentyp in Go ist eine Art <i>Definition</i> .  Es definiert und beschreibt die spezifischen Methoden, die <i>ein anderer Typ haben sollte</i> . </blockquote><br>  Ein leerer Schnittstellentyp <i>beschreibt keine Methoden</i> .  Er hat keine Regeln.  Und so erfüllt jedes Objekt eine leere Schnittstelle. <br><br>  Im Wesentlichen ist der leere Schnittstellentyp <code>interface{}</code> eine Art Joker.  Wenn Sie es in einer Deklaration (Variable, Funktionsparameter oder Strukturfeld) getroffen haben, können Sie ein Objekt eines <i>beliebigen Typs verwenden</i> . <br><br>  Betrachten Sie den Code: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { person := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, <span class="hljs-number"><span class="hljs-number">0</span></span>) person[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"Alice"</span></span> person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = <span class="hljs-number"><span class="hljs-number">21</span></span> person[<span class="hljs-string"><span class="hljs-string">"height"</span></span>] = <span class="hljs-number"><span class="hljs-number">167.64</span></span> fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%+v"</span></span>, person) }</code> </pre> <br>  Hier initialisieren wir die Zuordnung zur <code>person</code> , die einen Zeichenfolgentyp für Schlüssel und einen leeren Schnittstellentyp <code>interface{}</code> für Werte verwendet.  Wir haben drei verschiedene Typen als Map-Werte zugewiesen (String, Integer und Float32), und das ist kein Problem.  Da Objekte jeglicher Art die leere Schnittstelle erfüllen, funktioniert der Code hervorragend. <br><br>  Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Code hier ausführen</a> . Sie sehen ein ähnliches Ergebnis: <br><br><pre> <code class="plaintext hljs">map[age:21 height:167.64 name:Alice]</code> </pre> <br>  Wenn Sie Werte aus einer Karte extrahieren und verwenden möchten, ist es wichtig, dies zu berücksichtigen.  Angenommen, Sie möchten den <code>age</code> abrufen und um 1 erhöhen. Wenn Sie einen ähnlichen Code schreiben, wird dieser nicht kompiliert: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { person := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, <span class="hljs-number"><span class="hljs-number">0</span></span>) person[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"Alice"</span></span> person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = <span class="hljs-number"><span class="hljs-number">21</span></span> person[<span class="hljs-string"><span class="hljs-string">"height"</span></span>] = <span class="hljs-number"><span class="hljs-number">167.64</span></span> person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span> fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%+v"</span></span>, person) }</code> </pre> <br>  Sie erhalten eine Fehlermeldung: <br><br><pre> <code class="plaintext hljs">invalid operation: person["age"] + 1 (mismatched types interface {} and int)</code> </pre> <br>  Der Grund dafür ist, dass der in map gespeicherte Wert den Typ <code>interface{}</code> annimmt und seinen ursprünglichen Basis-Int-Typ verliert.  Und da der Wert nicht mehr ganzzahlig ist, können wir ihm keine 1 hinzufügen. <br><br>  Um dies zu umgehen, müssen Sie den Wert erneut ganzzahlig machen und ihn erst dann verwenden: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { person := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, <span class="hljs-number"><span class="hljs-number">0</span></span>) person[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"Alice"</span></span> person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = <span class="hljs-number"><span class="hljs-number">21</span></span> person[<span class="hljs-string"><span class="hljs-string">"height"</span></span>] = <span class="hljs-number"><span class="hljs-number">167.64</span></span> age, ok := person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>].(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { log.Fatal(<span class="hljs-string"><span class="hljs-string">"could not assert value to int"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = age + <span class="hljs-number"><span class="hljs-number">1</span></span> log.Printf(<span class="hljs-string"><span class="hljs-string">"%+v"</span></span>, person) }</code> </pre> <br>  Wenn Sie dies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausführen</a> , funktioniert alles wie erwartet: <br><br><pre> <code class="plaintext hljs">2009/11/10 23:00:00 map[age:22 height:167.64 name:Alice]</code> </pre> <br>  Wann sollten Sie einen leeren Schnittstellentyp verwenden? <br><br>  Vielleicht <i>nicht zu oft</i> .  Wenn Sie dazu kommen, hören Sie auf und überlegen Sie, ob es richtig ist, die <code>interface{}</code> .  Als allgemeinen Rat kann ich sagen, dass es verständlicher, sicherer und produktiver ist, bestimmte Typen zu verwenden, dh nicht leere Schnittstellentypen.  Im obigen Beispiel war es besser, eine <code>Person</code> mit entsprechend eingegebenen Feldern zu definieren: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Age <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Height <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> }</code> </pre> <br>  Eine leere Oberfläche ist dagegen nützlich, wenn Sie auf unvorhersehbare oder benutzerdefinierte Typen zugreifen und mit diesen arbeiten müssen.  Aus irgendeinem Grund werden solche Schnittstellen an verschiedenen Stellen in der Standardbibliothek verwendet, z. B. in den Funktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gob.Encode</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fmt.Print</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">template.Execute</a> . <br><br><h2>  Nützliche Schnittstellentypen </h2><br>  Hier ist eine kurze Liste der am häufigsten nachgefragten und nützlichen Schnittstellentypen aus der Standardbibliothek.  Wenn Sie noch nicht mit ihnen vertraut sind, empfehle ich, die entsprechende Dokumentation zu lesen. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">builtin.Error</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fmt.Stringer</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">io.Reader</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">io.Writer</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">io.ReadWriteCloser</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://golang.org/pkg/net/">http.ResponseWriter</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://golang.org/pkg/net/">http.Handler</a> <br></li></ul><br>  Eine längere Liste der Standardbibliotheken finden Sie auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463063/">https://habr.com/ru/post/de463063/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463045/index.html">Erkennen Sie Emotionen automatisch in Textkonversationen mithilfe neuronaler Netze</a></li>
<li><a href="../de463055/index.html">Über Administratoren, Entwickler, endlose Verwirrung und DevOps-Transformation innerhalb des Unternehmens</a></li>
<li><a href="../de463057/index.html">Benutzerdefinierte Rechte für Yii Framework 2</a></li>
<li><a href="../de463059/index.html">Drei leben in der IT und nicht nur</a></li>
<li><a href="../de463061/index.html">Regeln für die Erstellung von Layouts in Figma</a></li>
<li><a href="../de463067/index.html">Zuerst die Vorderseite und dann die Rückseite (eines Tages)</a></li>
<li><a href="../de463069/index.html">Reagieren Sie auf den animierten Leitfaden</a></li>
<li><a href="../de463071/index.html">Welche Auswirkungen haben Internetausfälle?</a></li>
<li><a href="../de463073/index.html">QUIC in Aktion: Wie Uber es implementiert hat, um die Leistung zu optimieren</a></li>
<li><a href="../de463075/index.html">Neue Open Source-Lizenzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>