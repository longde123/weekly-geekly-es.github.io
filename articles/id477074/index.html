<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🎓 🦀 🏼 Utas Ariadne: bagaimana jatuh cinta dengan JSR-133. Laporan Yandex 👩🏿‍🎨 👨🏾‍🤝‍👨🏽 🈶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prosesor multi-inti adalah hal biasa. Cepat atau lambat, setiap programmer praktis harus pergi ke labirin pemrograman multi-threaded dan bertemu denga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utas Ariadne: bagaimana jatuh cinta dengan JSR-133. Laporan Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/477074/">  Prosesor multi-inti adalah hal biasa.  Cepat atau lambat, setiap programmer praktis harus pergi ke labirin pemrograman multi-threaded dan bertemu dengan "monster" yang menghuninya.  Mari kita bicara tentang di mana memulai dengan cara ini dan alat dan pendekatan apa yang akan membantu untuk menang  Saya membuat laporan ini untuk para peserta masa depan dalam <a href="https://ya.cc/7w_Dq">magang sepanjang tahun</a> Yandex. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/veYXsOlYb2A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Nama saya Seva Minkov.  Saya bekerja di departemen infrastruktur cloud departemen pencarian.  Saya terutama berurusan dengan backend.  Saya menulis dalam berbagai bahasa, tetapi yang paling sering adalah Java dan bahasa yang berjalan di Java Virtual Machine (JVM). <br><a name="habracut"></a><br>  Tim kami sedang mengembangkan cloud internal di mana hampir semua layanan Yandex diluncurkan - keduanya dikenal publik seperti Search, Mail dan Alice, serta berbagai layanan internal, mesin virtual, serta tugas MapReduce yang berumur pendek dan tugas pembelajaran mesin. <br><br>  Cloud kami tidak statis: perusahaan berkembang, jumlah layanan dan sumber daya yang mereka konsumsi meningkat.  Dan tim kami sangat sering menghadapi tantangan peningkatan dan peningkatan kinerja.  Kami mencapai ini dengan menggunakan semua alat yang tersedia, termasuk penskalaan vertikal - yaitu, dengan mempercepat komponen individu sistem hingga menulis ulang beberapa algoritma berulir tunggal sehingga mereka bekerja lebih cepat.  Kami melakukan penskalaan horizontal: memecah sistem menjadi bagian-bagian kecil untuk mencapai kinerja yang lebih baik dengan menambahkan server, prosesor, inti, dll. <br><br>  Dan pemrograman multi-threaded banyak membantu kita dalam hal ini.  Kami akan membicarakannya hari ini - dari mana asalnya, mengapa itu relevan;  apa model memori, dan bagaimana itu umumnya diwakili di Jawa.  Kami akan menyentuh beberapa aspek praktis tentang cara menguji aplikasi Anda dan memverifikasi kebenarannya. <br><br><img src="https://habrastorage.org/webt/me/f6/9z/mef69z0p-acv-chewvn7tuhphpk.jpeg"><br><br>  Untuk memulai, mari kita lihat pada grafik yang menarik ini, yang menunjukkan tren karakteristik mikroprosesor selama 40 tahun terakhir.  Sekitar 10-15 tahun yang lalu, ketika rumput lebih hijau dan prosesornya single-threaded, seorang programmer biasa bisa sekali menulis program single-threaded yang benar, dan kemudian mengandalkan hukum empiris Moore.  Dia mengatakan bahwa prosesor dua kali lebih cepat setiap dua tahun.  Seperti yang Anda lihat, sekitar tahun 2005, karena berbagai alasan, produsen mikroprosesor beralih ke arsitektur multi-core dan mulai meningkatkan jumlah core logis.  Dan perolehan kinerja satu inti berhenti mematuhi hukum Moore, dan kekuatan pemrosesan satu inti mulai tumbuh lebih lambat.  Ini membuat revolusi, dan programmer biasa harus menggunakan pemrograman paralel untuk menggunakan keuntungan kinerja yang sangat ini. <br><br>  Karena kami sedang berlatih, kami akan mencoba menulis program multi-utas sederhana dan melihat sendiri bagaimana kerjanya. <br><br><img src="https://habrastorage.org/webt/rl/tv/gz/rltvgzwhsnhczo7tlpu5otwekuw.jpeg"><br><br>  Sebagai contoh, mari kita ambil tugas yang cukup sederhana untuk membaca catatan silang.  Mari kita memiliki dua variabel bersama X dan Y, pertama diinisialisasi dengan nilai default (nol), dan dua aliran.  Setiap utas menulis ke satu variabel dan membaca yang lain.  Dalam kasus ini, Thread1 menulis unit dalam X dan membaca Y. Thread kedua melakukan hal yang sama, hanya mundur. <br><br>  Implementasi Java sederhana mungkin terlihat seperti ini. <br><br><img src="https://habrastorage.org/webt/xz/dw/8g/xzdw8gsz8vr8f2p-0dvtdr1y6qw.jpeg"><br><br>  Kami akan menulis kelas ReadWriteTest, ia akan memiliki dua variabel statis X dan Y. Langsung dalam metode utama, kami membangun dua thread Thread1 dan Thread2, memberikan masing-masing dari mereka input beberapa fungsi lambda yang akan dieksekusi pada saat thread dijalankan.  Letakkan kode dari slide sebelumnya di sana dan mulai dua utas. <br><br>  Urutan awal utas, dalam beberapa hal, tidak dapat diprediksi.  Itu tergantung pada bagaimana sistem operasi memasang benang.  Dengan demikian, kita dapat memiliki berbagai versi.  Tampaknya mengerti bagaimana ini semua bekerja, kita harus menjalankan program ini berkali-kali, kemudian mengagregasikan hasilnya dan melihat seberapa sering jawaban ini atau itu akan ditemukan dalam program. <br><br><img src="https://habrastorage.org/webt/ij/os/e3/ijose3q1hdbyts7brwd31pujhou.jpeg"><br><h5>  <sup><sub><a href="https://openjdk.java.net/projects/code-tools/jcstress/">Tautan dari slide</a></sub></sup> </h5><br>  Agar tidak menemukan kembali roda, kita dapat menggunakan alat yang sudah jadi.  Ini disebut jcstress, Java Concurrency Stress menguji utilitas yang merupakan bagian dari proyek OpenJDK. <br><br>  Utilitas ini menyediakan beberapa kerangka kerja untuk menulis tes stres.  Dalam hal ini, kode dari slide sebelumnya cukup mudah ditulis ulang.  Pertama-tama, kita akan menggantung anotasi Tes jcstress di kelas, yang hanya membuat skrip uji kita terlihat oleh utilitas.  Kami juga menandainya dengan kelas State, yang mengatakan bahwa kelas tersebut berisi data yang dapat berubah: keduanya dimodifikasi dan dibaca dari aliran yang berbeda.  Kami mendeklarasikan dua metode, thread1 dan thread2, dan menandainya dengan anotasi Aktor.  Aktor anotasi berarti bahwa metode tersebut harus dieksekusi di utas terpisah.  jcstress menjamin bahwa setiap metode tersebut akan dieksekusi dalam utas terpisah pada tepat satu instance dari kelas State.  Urutan peluncurannya tidak ditentukan secara spesifik.  Dan hasilnya akan ditulis ke beberapa objek II_Result yang ditampilkan pada slide.  Kita dapat berasumsi bahwa ini adalah dua nilai numerik, yang disajikan hanya dengan metode Injeksi Ketergantungan, yang dibicarakan Cyril dalam laporan sebelumnya. <br><br>  Sebelum memulai tes ini, mari kita pikirkan kesimpulan apa yang bisa diberikan oleh perintah dan nilai apa yang bisa kita tambahkan di r1 dan di r2. <br><br><img src="https://habrastorage.org/webt/na/ik/dn/naikdng1aeysfm7tc0fe7drjbfs.jpeg"><br><br>  Untuk melakukan ini, kami menggunakan model alternatif yang disebut.  Satu atau lain cara, masing-masing operasi: membaca atau menulis, dilakukan dalam beberapa urutan.  Cukup hanya dengan menggabungkan semua opsi ini dan melihat hasil apa yang kita miliki. <br><br><img src="https://habrastorage.org/webt/i5/4y/fk/i54yfklqj0mjn1jjhkwhqs8vna0.jpeg"><br><br>  Misalkan salah satu varian acara yang mungkin adalah thread satu benar-benar dieksekusi sebelum thread kedua.  Pertama, kami menambahkan satu ke X, baca nol dari Y, karena tidak ada entri.  Kemudian mereka menulis satu ke Y dan membaca satu dari X, karena aliran pertama sudah berhasil melakukan ini. <br><br>  Jawaban pertama adalah nol satu. <br><br><img src="https://habrastorage.org/webt/ot/7p/ax/ot7paxx6szikzgwp9xjiusgnfny.jpeg"><br><br>  Varian kedua dari pengembangan acara justru sebaliknya: stream dua dieksekusi di depan stream satu. <br><br><img src="https://habrastorage.org/webt/_r/b5/sg/_rb5sgbawfh8cczgwyz9yzomji8.jpeg"><br><br>  Dengan demikian, kita mendapatkan hasil mirror satu-nol. <br><br><img src="https://habrastorage.org/webt/ja/ft/fi/jaftfi3gbc6cwnliw1nufl66x50.jpeg"><br><br>  Ada sekitar empat opsi lagi yang memberikan hasil yang sama ketika kita memiliki eksekusi thread yang benar-benar bingung.  Misalnya, kami mencatat unit dalam satu aliran di X, di aliran kedua kami berhasil memiliki unit di Y, dan kami menghitung satu-satu.  Anda kemudian dapat melihat opsi lain apa yang ada sebagai latihan di rumah. <br><br><img src="https://habrastorage.org/webt/w2/bf/tr/w2bftrexoxplrdq_v81fuxeoxic.jpeg"><br><br>  Tampaknya kami telah membahas semua opsi yang mungkin, tidak ada lagi.  Mari kita jalankan utilitas dan lihat apa kesimpulannya. <br><br><img src="https://habrastorage.org/webt/8-/2k/p7/8-2kp79h_iv-0il5eo9ftko91ye.jpeg"><br><h5>  <sup><sub><a href="https://openjdk.java.net/projects/code-tools/jcstress/">Tautan dari slide</a></sub></sup> </h5><br>  Outputnya terlihat seperti tabel.  Kolom pertama berisi daftar hasil yang kami tambahkan di II_Result - utilitas menjalankan kode ini jutaan kali - dan jumlah kasus ketika hasil tertentu ditemukan sama sekali.  Tetapi mungkin laporan ini tidak akan terjadi jika semuanya begitu sederhana. <br><br>  Bahkan, dalam kesimpulan ini kita juga bisa melihat hasil nol-nol, yang sulit dijelaskan dengan model pergantian.  Tampaknya salah satu opsi yang mungkin adalah seseorang secara langsung dalam kode aliran mengambil dan mengatur ulang baris. <br><br>  Mari kita pikirkan mengapa itu terjadi dan bagaimana kita bisa hidup dengannya.  Saya juga meminta Anda untuk memperhatikan fakta bahwa opsi satu-satu ditemukan secara khusus pada mesin saya sangat jarang.  Dari 130 juta pertunjukan, hanya 154 pertunjukan yang menghasilkan satu-satu.  Dan sebaliknya, nol-nol terjadi sangat sering, dalam hampir 30% kasus. <br><br><img src="https://habrastorage.org/webt/kw/sb/24/kwsb24gow4nmkjkdtmhzxnnvreo.jpeg"><br><br>  Jadi, untuk meringkas beberapa hasil antara yang kami semua lihat bersama Anda.  Pertama-tama, kita dapat memahami bahwa interaksi aliran melalui memori tidak bersifat trivial.  Model rotasi yang kami gunakan tidak berfungsi.  Kami melihat penataan ulang.  Itu bisa terjadi karena berbagai alasan. <br><br>  Misalnya, kita bisa melihat "efek relativistik" dari besi.  Ini dapat dipikirkan dalam uraian berikut: dalam satu siklus clock dari prosesor 3-GHz, cahaya bergerak sekitar 10 cm dalam ruang hampa. Protokol untuk membaca dan menulis ke memori prosesor adalah rumit dan kadang-kadang dibutuhkan ratusan siklus clock untuk mentransfer nilai dari satu inti ke inti lainnya.  Dengan demikian, satu inti tampaknya dapat melihat masa lalu.  Hasil setelah rekaman terjadi, tetapi kami melihat nilai lama.  Selain itu, prosesor juga tidak tinggal diam dan dapat mengubah instruksi di tempat. <br><br>  Kompiler pengoptimal modern dapat mengarah ke permutasi yang sama.  Untuk mencapai kinerja single-threaded maksimum, mereka juga dapat bertukar instruksi sehingga ini tidak merusak kebenaran dari program single-threaded.  Namun dalam program multi-utas dapat menimbulkan efek menarik yang telah kita lihat. <br><br>  Dan yang kedua - mungkin kesimpulan utama: kami melihat bahwa program multithread secara fundamental tidak ditentukan.  Program single-threaded terutama mengandalkan beberapa invarian pada input dan output, dan bersifat deterministik;  mengingat bahwa generator angka acak dan input pengguna adalah parameter input. <br><br>  Ini membuat segalanya menjadi sangat rumit: sulit untuk memahami apa yang dilakukan oleh program, dan sulit untuk mengujinya. <br><br>  Tentang kerumitan pengujian, kami dapat menambahkan bahwa hasil yang sama ditemukan hanya 154 kali dari 130 juta panggilan.  Peluang terjadinya hasil ini adalah sepersejuta.  Dalam produksi, ini berarti bug semacam itu dapat direproduksi setelah berminggu-minggu.  Dan itu pasti akan terjadi di suatu tempat pada Minggu malam, ketika Anda tidak mengharapkan ini sama sekali. <br><br><img src="https://habrastorage.org/webt/sd/u8/hg/sdu8hgj5xiqhrnnganz3ltxzyp0.jpeg"><br><br>  Mari kita pikirkan bagaimana kita seharusnya dan apa yang umumnya kita inginkan dari lidah kita untuk tidur nyenyak pada Minggu malam.  Pertama, kita membutuhkan alat yang memungkinkan kita untuk memprediksi perilaku program dan membuat penilaian tentang pelaksanaannya.  Kedua, kita membutuhkan alat bahasa yang akan memungkinkan kita untuk mempengaruhi permutasi dan efek - mereka dapat dari perangkat keras, kompiler, dll. Saya ingin tahu lebih sedikit tentang cara kerja prosesor tertentu, optimasi apa yang dapat dilakukan oleh kompiler, dan menggunakan singkatan yang datang dari dunia Jawa.  Write Once, Run Anywhere - tulis kode multi-thread yang benar sehingga bisa digunakan di semua platform. <br><br><img src="https://habrastorage.org/webt/tx/lr/du/txlrdugf3x6nxzxnraij4qn9yzq.jpeg"><br><br>  Pertanyaan dan persyaratan ini yang telah kami daftarkan, mereka muncul di benak pengembang untuk waktu yang sangat lama dan para ahli teori dan praktisi.  Seperti halnya tugas rumit dengan tingkat kerumitan yang tinggi, itu diselesaikan dengan memperkenalkan konsep beberapa mesin abstrak.  Kita semua, pengembang dalam bahasa pemrograman tingkat tinggi, tidak menulis untuk perangkat keras tertentu, tidak untuk model prosesor seperti itu, tetapi menulis beberapa mesin abstrak.  Dan spesifikasi bahasa dirancang untuk menggambarkan perilakunya sedemikian rupa untuk merekonsiliasi tiga dunia ini.  Di satu sisi, biarkan pengembang kompiler dan prosesor melakukan optimisasi dan dengan ringan meniupkan otak mereka kepada kami, programmer yang sudah menulis dalam bahasa tertentu. <br><br>  Model memori menempati posisi sentral dalam mesin abstrak ini.  Dia harus menjawab satu pertanyaan: jika saya membaca variabel X dalam aliran tertentu, hasil entri mana yang bisa saya lihat di sana?  Upaya memformalkan model memori dilakukan untuk pertama kalinya dalam bahasa Java, semua model memori lain muncul kemudian.  Katakanlah C ++ 11 hampir merupakan copy paste dari model memori Java dengan beberapa perubahan. <br><br>  Ada beberapa model memori di Jawa.  Awalnya, model memori yang disebut "lonceng-berbentuk", itu diakui sebagai tidak berhasil, karena menghambat pekerjaan programmer yang menulis di Jawa, dan melarang beberapa optimasi ke kompiler, yang cukup sesuai untuk diri mereka sendiri.  Dengan demikian, sebagai bagian dari proses komunitas JSR-133, model memori modern ditulis. <br><br>  Karena kita memiliki tulisan suci dalam bentuk spesifikasi, mari kita coba melihat ke dalamnya dan memahami apa yang sebenarnya terjadi di dalam. <br><br><img src="https://habrastorage.org/webt/3f/w6/qi/3fw6qiwjhoeqgtrdn3jngdqntfs.jpeg"><br><br>  Ada beberapa masalah.  Angkat tangan Anda, yang membuka spesifikasi bahasa dan membaca apa yang terjadi di sana.  Dan berapa banyak dari Anda yang telah membaca hingga model memori paragraf 17.4?  Kejutan kecil menanti Anda.  Spesifikasi bahasa pada dasarnya dijelaskan dalam bahasa yang cukup dimengerti.  Tetapi model memori penuh, katakanlah, beberapa hardcore matematika.  Ada inklusi dalam bahasa Yunani, banyak istilah matematika dari seri transitif closure, penyatuan dua perintah, dll. <br><br>  Sayangnya, tidak ada cara lain.  Satu-satunya hal yang dapat Anda andalkan saat menulis program multithread adalah spesifikasinya.  Dia harus membaca dan mengerti.  Saya sangat merekomendasikan Anda.  Terlebih lagi, ketika saya pertama kali membaca spesifikasinya, saya memiliki kesan seperti itu. <br><br>  Mengapa begitu sulit?  Saya salah jalan dan saya memperingatkan Anda untuk bertindak seperti saya. <br><br>  Saya mengambilnya, mencari di internet apa model memori.  Menemukan sebuah buku berjudul JSR-133 Cookbook for Compiler Writers.  Dia menjelaskan bagaimana pengembang kompiler dapat mengimplementasikan model memori ini dengan cara yang sederhana.  Masalahnya adalah ini adalah satu implementasi spesifik, dan tidak dapat digunakan untuk menilai keseluruhan model memori secara umum. <br><br>  Pokoknya, mari kita mencoba membuat usaha kecil pada kesimpulan utama yang dapat dipahami dari model memori Java. <br><br><img src="https://habrastorage.org/webt/ii/tn/by/iitnbypnfohtdb0y3gyxuhv1fea.jpeg"><br><br>  Mungkin ada banyak eksekusi program multithreaded Anda.  Kami sendiri melihat ini pada contoh program kami sebelumnya.  Dalam contoh paling sederhana, kami sudah memiliki empat hasil penerapannya.  Dan tugas model memori Java adalah mengatakan eksekusi mana yang benar, dan mana yang harus dilarang.  Dan mendalilkan tiga hal.  Yang pertama adalah bahwa dalam kerangka satu utas tugas Anda dieksekusi pseudo-berurutan.  Ini menyiratkan bahwa kompiler dapat menukar operasi, prosesor juga dapat menjalankan instruksi secara paralel, menukar mereka.  Tetapi mereka harus melakukan ini agar efek yang terlihat dari eksekusi program Anda sama seperti jika dieksekusi secara langsung secara berurutan. <br><br>  Kedua, apa yang disebut makna udara tipis yang diambil entah dari mana dilarang dalam bahasa ini.  Sayangnya, kami tidak punya waktu untuk menunjukkannya, tetapi ada kasus ketika kompiler benar-benar dapat melakukan konversi sehingga semuanya akan benar dalam program berulir tunggal, dan Anda mungkin memiliki catatan dalam program multi-utas yang tidak Anda lakukan. <br><br>  Dengan demikian, model memori mengatakan bahwa membaca variabel apa pun akan mengembalikan nilai default, atau beberapa hasil rekaman yang pernah dilakukan oleh perintah lain.  Dan tindakan yang tersisa dapat ditafsirkan sebagai berurutan, jika mereka dihubungkan oleh hubungan urutan parsial terjadi sebelumnya.  Dan sekarang ini adalah satu-satunya tempat di mana kita membutuhkan matematika.  Hubungan parsial, ini karena tidak semua membaca, menulis operasi variabel, mereka terhubung oleh relasi.  Ini memiliki sifat refleksifitas, transitivitas, dan antisimetri. <br><br><img src="https://habrastorage.org/webt/vq/vp/11/vqvp11dmptcgzyedx4hazndvmeo.jpeg"><br><br>  Mari kita bicara lebih detail tentang yang terjadi sebelum itu sendiri.  Aturan pertama adalah bahwa ia menautkan semua operasi dalam satu utas.  Jika Anda telah menulis di dalam satu utas bahwa X sama dengan satu, Y sama dengan satu;  dinyatakan bahwa operasi penulisan dalam X terkait dengan terjadi-sebelum Y. Yaitu, X terjadi-sebelum Y. Dan juga mengikat beberapa tindakan khusus, yang disebut tindakan sinkronisasi.  Baca lebih lanjut dalam spesifikasi.  Misalnya, ini menulis dan membaca dari variabel volatil, mengunci / membuka kunci pada satu monitor, memasuki blok yang disinkronkan dan keluar dari blok yang disinkronkan.  Poin yang sangat penting adalah bahwa semua tindakan sinkronisasi dalam program Anda melihat utas dalam urutan yang persis sama, seolah-olah itu dijalankan satu per satu. <br><br>  Dan terjadi - sebelum menghubungkan beberapa pasang tindakan ini.  Tidak masalah di mana tindakan sinkronisasi utas berlangsung.  Penting bahwa mereka lulus, misalnya, lebih dari satu variabel volatil.  Spesifikasi mengatakan, katakanlah, menulis ke variabel volatil terjadi sebelum tindakan berikutnya.  Ini merujuk persis pada cara kami melakukan tindakan sinkronisasi. <br><br>  Dan yang paling penting dari semua ini adalah aturan terjadi-sebelum konsistensi, yang hanya menjawab pertanyaan paling penting tentang model memori.  Itu bisa diartikan sebagai berikut.  Jika ada rantai operasi baca / tulis dalam variabel dan mereka terhubung oleh rantai hubungan sebelum terjadi, maka membaca pasti akan melihat catatan terakhir dalam rantai ini.  Jika tidak ada di sana, Anda dapat melihat nilai lain, catatan lain, atau nilai default.  Sekarang Anda dapat menghembuskan napas, dengan definisi dasar kami selesai. <br><br><img src="https://habrastorage.org/webt/q6/jv/qq/q6jvqqzesul_tjyflrgcuy8s__4.jpeg"><br><br>  Mari kita coba menguji teori dalam praktik?  Mari kita ambil contoh dengan pembacaan silang catatan dan tambahkan saja pengubah volatil ke variabel X dan Y. Mari kita coba buktikan hipotesis bahwa kita tidak akan melihat nilai nol-nol lagi.  Untuk melakukan ini, cukup gunakan aturan yang saya katakan di atas. <br><br>  Kami akan mengatur yang terjadi sebelumnya dalam satu utas.  Menulis ke X terjadi sebelum membaca dari Y dan di utas kedua.  Menulis ke Y terjadi - sebelum membaca dari X. <br><br>  Dan kemudian kita memiliki empat tindakan sinkronisasi: menulis ke X, menulis ke Y, membaca dari X, membaca dari Y. Mereka dapat muncul dalam beberapa urutan, dan sepasang dapat terjadi dalam dua kasus. <br><br><img src="https://habrastorage.org/webt/yz/mu/vr/yzmuvrfkneks1-usipllgsgxanc.jpeg"><br><br>  Misalnya, menulis ke X dalam aliran satu terjadi lebih awal daripada membaca dari X dalam aliran dua (terjadi-sebelum terjadi).  Seperti yang Anda lihat di sini, hubungan tersebut tidak terkait dengan Y. Hasil pembacaan dari Y hanya dapat kembali kepada kami baik nilai default atau nilai yang dicatat oleh stream kedua.  Pembacaan dari X harus selalu melihat unit.  Dengan demikian, opsi kami mungkin nol-satu, satu-satu. <br><br><img src="https://habrastorage.org/webt/yc/zi/rm/yczirmhlmh3r0c2whc-g8dpxtvu.jpeg"><br><br>  Kasus kedua adalah ketika koneksi muncul.  Ini adalah hal yang sama - menulis ke Y terjadi sebelum membaca dari Y. Juga tidak ada hubungan antara X. Dengan demikian, hasilnya sama, hanya di sana Anda mendapatkan satu-nol, nol-satu.  Secara teoritis, kita dapat membuktikan perilaku program baru kita. <br><br><img src="https://habrastorage.org/webt/ui/zs/7o/uizs7ojlz4smbqktuvisojvjxte.jpeg"><br><br>  Anda dapat memeriksanya dalam praktik.  Ambil dan tambahkan kata kunci yang tidak stabil dalam pengujian kami.  Jalankan dan lihat bahwa, di negara kita, nilai ini tidak akan pernah direproduksi.   happens-before —        .         . <br><br><img src="https://habrastorage.org/webt/p8/xp/ao/p8xpaoj1prrfkwto0t3w7unlsli.jpeg"><br><br> ,        .  volatile     Z  volatile,  .   ,        Z;   ,  ,     ,     Z.        happens-before       .  ,     Z   ,        .           . <br><br>  , ,        —       put value.    —   get value    .   happens-before   ,       ,  put value happens-before get value.           ,        happens-before   ,   volatile,     .      ,    ,  — put  happens-before get. <br><br><img src="https://habrastorage.org/webt/m6/br/hd/m6brhdf3iyak436nje-p-fyrq2a.jpeg"><br><br> ,    . -,  .  ,    ,    .         ,     .  ,     ,     .  ,         .    ,      ,      ,     ,       . <br><br> -,     ,  jcstress.       :     ,   JVM   .      ,        . <br><br>    ,   .  — «The Art of Multiprocessor Programming»  .        ,   happens-before,  ,   . .     — «Java Concurrency in Practice»  .     ,       .     ,   ,    . .    .       <a href="https://shipilev.net/"> </a> ,   performance-  Oracle,     Red Hat.      ,  Java-  ,   .        JMM. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat membaca blog </font></font><a href="https://elizarov.livejournal.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roman Elizarov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dia mengajarkan, menurut saya, pemrograman multithreaded ITMO. </font><font style="vertical-align: inherit;">Dia memiliki blog yang sedikit ditinggalkan, tetapi Anda dapat membaca, mencari ceramah dan pidatonya di YouTube. </font><font style="vertical-align: inherit;">Secara umum, sangat cocok, saya sarankan. </font><font style="vertical-align: inherit;">Terima kasih semuanya.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477074/">https://habr.com/ru/post/id477074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477054/index.html">Webasto Mengumumkan Sistem Baterai Otomotif Modular</a></li>
<li><a href="../id477058/index.html">Enterprise Agile Russia di Raiffeisenbank 26/11 + Broadcast</a></li>
<li><a href="../id477060/index.html">DataArt akan menyelenggarakan kuliah terbuka oleh Andrei Terekhov, Kepala Departemen Pemrograman Sistem, Matmekh, Universitas Negeri St. Petersburg</a></li>
<li><a href="../id477062/index.html">Cara kerja kompiler yang mengoptimalkan</a></li>
<li><a href="../id477072/index.html">Pengembangan Pelanggan atau bagaimana meluncurkan produk tanpa kegagalan?</a></li>
<li><a href="../id477078/index.html">WebStorm 2019.3: peluncuran lebih cepat, peningkatan dukungan untuk Vue.js dan peningkatan lainnya</a></li>
<li><a href="../id477082/index.html">Kongres A.S. vs. Zuckerberg: apa yang dilakukan pembuat kebijakan terhadap libra stabil dari Facebook</a></li>
<li><a href="../id477084/index.html">Otak perusahaan. Bagian 2</a></li>
<li><a href="../id477092/index.html">Gambaran Umum Alat Keamanan Repositori GitHub</a></li>
<li><a href="../id477096/index.html">Akankah 5G membahayakan kesehatan kita?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>