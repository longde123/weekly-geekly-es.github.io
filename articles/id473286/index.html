<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏻 ♿️ 👨‍👧‍👦 Kami menulis perlindungan terhadap serangan DDoS pada XDP. Bagian nuklir 📴 👫 🤽🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teknologi EXpress Data Path (XDP) memungkinkan pemrosesan lalu lintas yang sewenang-wenang pada antarmuka Linux sebelum paket tiba di tumpukan jaringa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menulis perlindungan terhadap serangan DDoS pada XDP. Bagian nuklir</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473286/"><p>  Teknologi EXpress Data Path (XDP) memungkinkan pemrosesan lalu lintas yang sewenang-wenang pada antarmuka Linux sebelum paket tiba di tumpukan jaringan kernel.  Penerapan XDP - perlindungan terhadap serangan DDoS (CloudFlare), filter canggih, pengumpulan statistik (Netflix).  Program XDP dijalankan oleh mesin virtual eBPF, oleh karena itu, mereka memiliki batasan pada kode mereka dan pada fungsi kernel yang tersedia, tergantung pada jenis filter. </p><br><p>  Artikel ini dimaksudkan untuk mengisi kekurangan berbagai materi XDP.  Pertama, mereka menyediakan kode siap pakai yang segera mem-bypass fitur XDP: disiapkan untuk verifikasi atau terlalu sederhana untuk menyebabkan masalah.  Ketika Anda mencoba menulis kode Anda dari awal dari awal, tidak ada pemahaman tentang apa yang harus dilakukan dengan kesalahan umum.  Kedua, metode untuk menguji XDP secara lokal tanpa VM dan perangkat keras tidak tercakup, meskipun faktanya mereka memiliki perangkap sendiri.  Teks ini ditujukan untuk pemrogram yang mengenal jaringan dan Linux yang tertarik pada XDP dan eBPF. </p><a name="habracut"></a><br><p> Pada bagian ini, kita akan memeriksa secara rinci bagaimana filter XDP dirakit dan bagaimana mengujinya, kemudian kita akan menulis versi sederhana dari mekanisme cookie SYN yang terkenal di tingkat pemrosesan paket.  Meskipun kami tidak akan membentuk "daftar putih" <br>  pelanggan yang diverifikasi, simpan penghitung dan kelola filter - log yang cukup. </p><br><p>  Kami akan menulis dalam C - ini tidak modis, tetapi praktis.  Semua kode tersedia di GitHub melalui tautan di bagian akhir dan dibagi menjadi komit sesuai dengan tahapan yang dijelaskan dalam artikel. </p><br><p>  <strong>Penafian.</strong>  Selama artikel, solusi-mini akan dikembangkan untuk memukul mundur dari serangan DDoS, karena ini adalah tugas yang realistis untuk XDP dan area saya.  Namun, tujuan utamanya adalah untuk berurusan dengan teknologi, ini bukan panduan untuk menciptakan perlindungan yang sudah jadi.  Kode pelatihan tidak dioptimalkan dan menghilangkan beberapa nuansa. </p><br><h2 id="kratkiy-obzor-xdp">  Sekilas tentang XDP </h2><br><p>  Saya hanya akan menguraikan poin-poin utama agar tidak menduplikasi dokumentasi dan artikel yang ada. </p><br><p> Jadi, kode filter dimuat ke dalam kernel.  Paket masuk dikirim ke filter.  Akibatnya, filter harus membuat keputusan: lewati paket ke kernel ( <code>XDP_PASS</code> ), buang paket ( <code>XDP_DROP</code> ) atau kirim kembali ( <code>XDP_TX</code> ).  Filter dapat mengubah paket, ini terutama berlaku untuk <code>XDP_TX</code> .  Anda juga dapat menghentikan program ( <code>XDP_ABORTED</code> ) dan membuang paket, tetapi ini adalah analog dari pernyataan <code>assert(0)</code> untuk debugging. </p><br><p>  Mesin virtual eBPF (extended Berkley Packet Filter) secara khusus dibuat sederhana sehingga kernel dapat memverifikasi bahwa kode tidak berulang dan tidak merusak memori orang lain.  Pembatasan agregat dan pemeriksaan: </p><br><ul><li>  Siklus terlarang (melompat kembali). </li><li>  Ada tumpukan untuk data, tetapi tidak ada fungsi (semua fungsi C harus diuraikan). </li><li>  Akses ke memori di luar tumpukan dan buffer paket dilarang. </li><li>  Ukuran kode terbatas, tetapi dalam praktiknya ini tidak terlalu signifikan. </li><li>  Panggilan hanya diizinkan untuk fungsi kernel khusus (pembantu eBPF). </li></ul><br><p>  Desain dan pemasangan filter terlihat seperti ini: </p><br><ol><li>  Kode sumber (misalnya, <code>kernel.c</code> ) dikompilasi ke objek ( <code>kernel.o</code> ) di bawah arsitektur mesin virtual eBPF.  Pada Oktober 2019, kompilasi dalam eBPF didukung oleh Dentang dan dijanjikan dalam GCC 10.1. </li><li>  Jika dalam kode objek ini ada panggilan ke struktur kernel (misalnya, tabel dan penghitung), nol digunakan sebagai pengganti ID mereka, yaitu kode tersebut tidak dapat dieksekusi.  Sebelum memuat ke dalam kernel, Anda perlu mengganti nol ini dengan ID objek tertentu yang dibuat melalui panggilan kernel (kode tautan).  Anda dapat melakukan ini dengan utilitas eksternal, atau Anda dapat menulis sebuah program yang akan menautkan dan memuat filter tertentu. </li><li>  Kernel memverifikasi program yang dimuat.  Tidak adanya loop dan absensi di luar batas paket dan stack diperiksa.  Jika pemverifikasi tidak dapat membuktikan bahwa kode tersebut benar, program ditolak - Anda harus dapat menyenangkannya. </li><li>  Setelah verifikasi berhasil, kernel mengkompilasi kode objek arsitektur eBPF ke dalam kode mesin arsitektur sistem (just-in-time). </li><li>  Program menempel pada antarmuka dan mulai memproses paket. </li></ol><br><p>  Karena XDP bekerja di kernel, debugging dilakukan dengan melacak log dan, pada kenyataannya, dengan paket yang disaring atau dihasilkan oleh program.  Namun, eBPF memberikan keamanan untuk kode yang dimuat untuk sistem, sehingga Anda dapat bereksperimen dengan XDP langsung di Linux lokal. </p><br><h2 id="podgotovka-okruzheniya">  Persiapan lingkungan </h2><br><h3 id="sborka">  Majelis </h3><br><p>  Dentang tidak bisa langsung mengeluarkan kode objek untuk arsitektur eBPF, jadi prosesnya terdiri dari dua langkah: </p><br><ol><li>  Kompilasi kode C menjadi bytecode LLVM ( <code>clang -emit-llvm</code> ). </li><li>  Konversi bytecode ke kode objek eBPF ( <code>llc -march=bpf -filetype=obj</code> ). </li></ol><br><p>  Saat menulis filter, beberapa file dengan fungsi tambahan dan makro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari pengujian kernel</a> sangat berguna.  Adalah penting bahwa mereka cocok dengan versi kernel ( <code>KVER</code> ).  Unduh di <code>helpers/</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> KVER=v5.3.7 <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> BASE=https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/plain/tools/testing/selftests/bpf wget -P helpers --content-disposition <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${BASE}</span></span></span><span class="hljs-string">/bpf_helpers.h?h=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${KVER}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${BASE}</span></span></span><span class="hljs-string">/bpf_endian.h?h=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${KVER}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">unset</span></span> KVER BASE</code> </pre> <br><p>  Makefile untuk Arch Linux (kernel 5.3.7): </p><br><pre> <code class="plaintext hljs">CLANG ?= clang LLC ?= llc KDIR ?= /lib/modules/$(shell uname -r)/build ARCH ?= $(subst x86_64,x86,$(shell uname -m)) CFLAGS = \ -Ihelpers \ \ -I$(KDIR)/include \ -I$(KDIR)/include/uapi \ -I$(KDIR)/include/generated/uapi \ -I$(KDIR)/arch/$(ARCH)/include \ -I$(KDIR)/arch/$(ARCH)/include/generated \ -I$(KDIR)/arch/$(ARCH)/include/uapi \ -I$(KDIR)/arch/$(ARCH)/include/generated/uapi \ -D__KERNEL__ \ \ -fno-stack-protector -O2 -g xdp_%.o: xdp_%.c Makefile $(CLANG) -c -emit-llvm $(CFLAGS) $&lt; -o - | \ $(LLC) -march=bpf -filetype=obj -o $@ .PHONY: all clean all: xdp_filter.o clean: rm -f ./*.o</code> </pre> <br><p>  <code>KDIR</code> berisi path ke header kernel, <code>ARCH</code> - arsitektur sistem.  Jalur dan alat mungkin sedikit berbeda antar distribusi. </p><br><div class="spoiler">  <b class="spoiler_title">Contoh perbedaan untuk Debian 10 (kernel 4.19.67)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#   CLANG ?= clang LLC ?= llc-7 #   KDIR ?= /usr/src/linux-headers-$(shell uname -r) ARCH ?= $(subst x86_64,x86,$(shell uname -m)) #    -I CFLAGS = \ -Ihelpers \ \ -I/usr/src/linux-headers-4.19.0-6-common/include \ -I/usr/src/linux-headers-4.19.0-6-common/arch/$(ARCH)/include \ #   </code> </pre> </div></div><br><p>  <code>CFLAGS</code> termasuk direktori dengan header tambahan dan beberapa direktori dengan header kernel.  Simbol <code>__KERNEL__</code> berarti bahwa header UAPI (userspace APIs) didefinisikan untuk kode kernel, karena filter berjalan di kernel. </p><br><p>  Perlindungan tumpukan dapat dinonaktifkan ( <code>-fno-stack-protector</code> ), karena pemverifikasi kode eBPF masih memeriksa jalan keluar dari tumpukan.  Optimasi harus dimasukkan segera karena ukuran bytecode eBPF terbatas. </p><br><p>  Mari kita mulai dengan filter yang melewatkan semua paket dan tidak melakukan apa pun: </p><br><pre> <code class="plaintext hljs">#include &lt;uapi/linux/bpf.h&gt; #include &lt;bpf_helpers.h&gt; SEC("prog") int xdp_main(struct xdp_md* ctx) { return XDP_PASS; } char _license[] SEC("license") = "GPL";</code> </pre> <br><p>  Perintah <code>make</code> <code>xdp_filter.o</code> .  Di mana mengujinya sekarang? </p><br><h3 id="testovyy-stend">  Test stand </h3><br><p>  Stand harus mencakup dua antarmuka: di mana akan ada filter dan dari mana paket akan dikirim.  Ini harus perangkat Linux lengkap dengan IP mereka untuk memeriksa bagaimana aplikasi reguler bekerja dengan filter kami. </p><br><p>  Perangkat seperti veth (virtual Ethernet) cocok untuk kita: mereka adalah sepasang antarmuka jaringan virtual yang "terhubung" secara langsung satu sama lain.  Anda dapat membuatnya seperti ini (di bagian ini, semua perintah <code>ip</code> dijalankan sebagai <code>root</code> ): </p><br><pre> <code class="bash hljs">ip link add xdp-remote <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> veth peer name xdp-local</code> </pre> <br><p>  Di sini <code>xdp-remote</code> dan <code>xdp-local</code> adalah nama perangkat.  Filter akan dilampirkan ke <code>xdp-local</code> (192.0.2.1/24), dan lalu lintas masuk akan dikirim dari <code>xdp-remote</code> (192.0.2.2/24).  Namun, ada masalah: antarmuka berada di mesin yang sama, dan Linux tidak akan mengirimkan lalu lintas ke salah satu dari mereka melalui yang lain.  Anda dapat menyelesaikan ini dengan aturan <code>iptables</code> rumit, tetapi mereka harus mengubah paketnya, yang tidak nyaman saat debugging.  Lebih baik menggunakan ruang nama jaringan (ruang nama jaringan, selanjutnya jaring). </p><br><p>  Namespace jaringan berisi seperangkat antarmuka, tabel perutean, dan aturan NetFilter, terisolasi dari objek serupa di jaringan lain.  Setiap proses berjalan dalam namespace, dan hanya objek-objek dari jaring ini yang dapat diakses.  Secara default, sistem memiliki satu namespace jaringan untuk semua objek, sehingga Anda dapat bekerja di Linux dan tidak tahu tentang jaringan. </p><br><p>  Buat namespace <code>xdp-test</code> dan pindahkan <code>xdp-remote</code> . </p><br><pre> <code class="bash hljs">ip netns add xdp-test ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev xdp-remote netns xdp-test</code> </pre> <br><p>  Maka proses yang berjalan di <code>xdp-test</code> tidak akan “melihat” <code>xdp-local</code> (ini akan tetap dalam jaringan secara default) dan akan mengirimkannya melalui <code>xdp-remote</code> ketika mengirim paket ke 192.0.2.1, karena ini adalah satu-satunya antarmuka di 192.0.2.0/ 24 tersedia untuk proses ini.  Ini juga bekerja berlawanan arah. </p><br><p>  Saat berpindah antar jaringan, antarmuka menjatuhkan dan kehilangan alamat.  Untuk mengkonfigurasi antarmuka di netns, Anda perlu menjalankan <code>ip ...</code> di <code>ip netns exec</code> namespace <code>ip netns exec</code> command: </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test \ ip address add 192.0.2.2/24 dev xdp-remote ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test \ ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> xdp-remote up</code> </pre> <br><p>  Seperti yang Anda lihat, ini tidak berbeda dari pengaturan <code>xdp-local</code> di namespace default: </p><br><pre> <code class="bash hljs"> ip address add 192.0.2.1/24 dev xdp-local ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> xdp-local up</code> </pre> <br><p>  Jika Anda menjalankan <code>tcpdump -tnevi xdp-local</code> , Anda dapat melihat bahwa paket yang dikirim dari <code>xdp-test</code> dikirimkan ke antarmuka ini: </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test ping 192.0.2.1</code> </pre> <br><p>  Lebih mudah untuk menjalankan shell di <code>xdp-test</code> .  Ada skrip di repositori yang mengotomatiskan pekerjaan dengan dudukan, misalnya, Anda dapat mengonfigurasi dudukan dengan perintah <code>sudo ./stand up</code> dan menghapusnya dengan perintah <code>sudo ./stand down</code> . </p><br><h3 id="trassirovka">  Jejak </h3><br><p>  Filter terpasang ke perangkat sebagai berikut: </p><br><pre> <code class="bash hljs">ip -force link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev xdp-local xdp object xdp_filter.o verbose</code> </pre> <br><p>  <code>-force</code> diperlukan untuk mengikat program baru jika yang lain sudah terikat.  "Tidak ada berita adalah kabar baik" bukan tentang perintah ini, kesimpulannya produktif.  <code>verbose</code> opsional, tetapi dengan itu laporan muncul pada karya verifikasi kode dengan daftar perakitan: </p><br><pre> <code class="plaintext hljs">Verifier analysis: 0: (b7) r0 = 2 1: (95) exit</code> </pre> <br><p>  Lepaskan program dari antarmuka: </p><br><pre> <code class="bash hljs">ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev xdp-local xdp off</code> </pre> <br><p>  Dalam skrip, ini adalah perintah <code>sudo ./stand attach</code> dan <code>sudo ./stand detach</code> . </p><br><p>  Dengan melampirkan filter, Anda dapat memverifikasi bahwa <code>ping</code> terus berfungsi, tetapi apakah program ini bekerja?  Tambahkan log.  Fungsi <a href=""><code>bpf_trace_printk()</code></a> mirip dengan <code>printf()</code> , tetapi hanya mendukung hingga tiga argumen, kecuali untuk templat, dan daftar kualifikasi yang terbatas.  <code>bpf_printk()</code> menyederhanakan panggilan. </p><br><pre> <code class="diff hljs"> SEC("prog") int xdp_main(struct xdp_md* ctx) { + bpf_printk("got packet: %p\n", ctx); return XDP_PASS; }</code> </pre> <br><p>  Outputnya pergi ke saluran jejak kernel, yang harus Anda aktifkan: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -n 1 | sudo tee /sys/kernel/debug/tracing/options/trace_printk</code> </pre> <br><p>  Lihat aliran pesan: </p><br><pre> <code class="bash hljs">cat /sys/kernel/debug/tracing/trace_pipe</code> </pre> <br><p>  Kedua perintah ini melakukan panggilan ke <code>sudo ./stand log</code> . </p><br><p>  Ping sekarang seharusnya memicu pesan-pesan berikut di dalamnya: </p><br><pre> <code class="plaintext hljs">&lt;...&gt;-110930 [004] ..s1 78803.244967: 0: got packet: 00000000ac510377</code> </pre> <br><p>  Jika Anda melihat dengan seksama pada keluaran verifier, Anda akan melihat perhitungan aneh: </p><br><pre> <code class="plaintext hljs">0: (bf) r3 = r1 1: (18) r1 = 0xa7025203a7465 3: (7b) *(u64 *)(r10 -8) = r1 4: (18) r1 = 0x6b63617020746f67 6: (7b) *(u64 *)(r10 -16) = r1 7: (bf) r1 = r10 8: (07) r1 += -16 9: (b7) r2 = 16 10: (85) call bpf_trace_printk#6 &lt;...&gt;</code> </pre> <br><p>  Faktanya adalah bahwa program eBPF tidak memiliki bagian data, jadi satu-satunya cara untuk menyandikan string format adalah dengan argumen langsung dari perintah VM: </p><br><pre> <code class="bash hljs">$ python -c <span class="hljs-string"><span class="hljs-string">"import binascii; print(bytes(reversed(binascii.unhexlify('0a7025203a74656b63617020746f67'))))"</span></span> b<span class="hljs-string"><span class="hljs-string">'got packet: %p\n'</span></span></code> </pre> <br><p>  Karena alasan ini, output debug sangat mengembang kode yang dihasilkan. </p><br><h3 id="otpravka-paketov-xdp">  Mengirim Paket XDP </h3><br><p>  Mari kita ubah filter: biarkan mengirim semua paket masuk kembali.  Ini tidak benar dari sudut pandang jaringan, karena akan perlu untuk mengubah alamat di header, tetapi pada prinsipnya pekerjaan saat ini penting. </p><br><pre> <code class="diff hljs"> bpf_printk("got packet: %p\n", ctx); - return XDP_PASS; + return XDP_TX; }</code> </pre> <br><p>  Jalankan <code>tcpdump</code> di <code>xdp-remote</code> .  Itu harus memperlihatkan ICMP Echo Request keluar dan masuk yang identik dan berhenti menampilkan ICMP Echo Reply.  Tetapi tidak muncul.  Ternyata agar <code>XDP_TX</code> dapat berfungsi dalam program di <code>xdp-local</code> <a href="">perlu</a> bahwa antarmuka <code>xdp-remote</code> antarmuka <code>xdp-remote</code> , bahkan jika itu kosong, dan <a href="">harus</a> dinaikkan. </p><br><div class="spoiler">  <b class="spoiler_title">Bagaimana saya mengetahuinya?</b> <div class="spoiler_text"><p>  Omong-omong, mekanisme perf events, menggunakan mesin virtual yang sama memungkinkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melacak jalur paket di kernel</a> , yaitu, eBPF digunakan untuk membongkar dengan eBPF. </p><br><blockquote>  Anda harus berbuat baik dari kejahatan, karena tidak ada lagi yang bisa dilakukan darinya. </blockquote><br><pre> <code class="bash hljs">$ sudo perf trace --call-graph dwarf -e <span class="hljs-string"><span class="hljs-string">'xdp:*'</span></span> 0.000 ping/123455 xdp:xdp_bulk_tx:ifindex=19 action=TX sent=0 drops=1 err=-6 veth_xdp_flush_bq ([veth]) veth_xdp_flush_bq ([veth]) veth_poll ([veth]) &lt;...&gt;</code> </pre> <br><p>  Apa itu kode 6? </p><br><pre> <code class="bash hljs">$ errno 6 ENXIO 6 No such device or address</code> </pre> <br><p>  Fungsi <code>veth_xdp_flush_bq()</code> menerima kode kesalahan dari <code>veth_xdp_xmit()</code> , di mana kami mencari dengan <code>ENXIO</code> dan menemukan komentar. </p></div></div><br><p>  Kembalikan filter minimum ( <code>XDP_PASS</code> ) dalam file <code>xdp_dummy.c</code> , tambahkan ke Makefile, lampirkan ke <code>xdp-remote</code> : </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> remote \ ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev int xdp object dummy.o</code> </pre> <br><p>  Sekarang <code>tcpdump</code> menunjukkan apa yang diharapkan: </p><br><pre> <code class="plaintext hljs">62:57:8e:70:44:64 &gt; 26:0e:25:37:8f:96, ethertype IPv4 (0x0800), length 98: (tos 0x0, ttl 64, id 13762, offset 0, flags [DF], proto ICMP (1), length 84) 192.0.2.2 &gt; 192.0.2.1: ICMP echo request, id 46966, seq 1, length 64 62:57:8e:70:44:64 &gt; 26:0e:25:37:8f:96, ethertype IPv4 (0x0800), length 98: (tos 0x0, ttl 64, id 13762, offset 0, flags [DF], proto ICMP (1), length 84) 192.0.2.2 &gt; 192.0.2.1: ICMP echo request, id 46966, seq 1, length 64</code> </pre> <br><p>  Jika hanya ARP yang ditampilkan, Anda harus menghapus filter (ini dilakukan dengan <code>sudo ./stand detach</code> ), mulai <code>ping</code> , lalu atur filter dan coba lagi.  Masalahnya adalah bahwa filter <code>XDP_TX</code> memengaruhi ARP dan jika stack <br>  <code>xdp-test</code> namespace berhasil "melupakan" alamat MAC 192.0.2.1, itu tidak akan dapat menyelesaikan IP ini. </p><br><h2 id="postanovka-zadachi">  Pernyataan masalah </h2><br><p>  Mari kita beralih ke tugas yang disebutkan: tulis mekanisme cookie SYN di XDP. </p><br><p>  Sampai sekarang, SYN flood tetap menjadi serangan DDoS yang populer, intinya adalah sebagai berikut.  Saat membuat koneksi (jabat tangan TCP), server menerima SYN, mengalokasikan sumber daya untuk koneksi di masa depan, merespons dengan paket SYNACK, dan menunggu ACK.  Penyerang hanya mengirim paket SYN dari alamat palsu dalam jumlah ribuan per detik dari setiap host dari botnet multi-ribu.  Server dipaksa untuk mengalokasikan sumber daya segera setelah kedatangan paket, dan membebaskan oleh batas waktu yang besar, sebagai akibatnya, memori atau batas habis, koneksi baru tidak diterima, layanan tidak tersedia. </p><br><p>  Jika Anda tidak mengalokasikan sumber daya untuk paket SYN, tetapi hanya merespons dengan paket SYNACK, lalu bagaimana server dapat memahami bahwa paket ACK yang datang kemudian merujuk ke paket SYN yang tidak disimpan?  Bagaimanapun, penyerang juga dapat menghasilkan ACK palsu.  Inti dari cookie SYN adalah untuk menyandikan parameter <code>seqnum</code> di <code>seqnum</code> sebagai hash dari alamat, port dan mengganti garam.  Jika ACK berhasil tiba sebelum perubahan garam, Anda dapat sekali lagi menghitung hash dan membandingkannya dengan <code>acknum</code> .  Penyerang tidak dapat memalsukan <code>acknum</code> , karena garam termasuk rahasia, dan tidak akan punya waktu untuk memilah karena saluran terbatas. </p><br><p>  Cookie SYN telah lama diimplementasikan dalam kernel Linux dan bahkan dapat secara otomatis hidup jika SYN tiba terlalu cepat dan secara massal. </p><br><div class="spoiler">  <b class="spoiler_title">Program pendidikan tentang jabat tangan TCP</b> <div class="spoiler_text"><p>  TCP menyediakan transfer data sebagai aliran byte, misalnya, permintaan HTTP dikirim melalui TCP.  Aliran ditransmisikan dalam bentuk paket.  Semua paket TCP memiliki flag logis dan nomor urut 32-bit: </p><br><ul><li><p>  Kombinasi bendera menentukan peran paket tertentu.  Bendera SYN berarti bahwa ini adalah paket pengirim pertama dalam koneksi.  Bendera ACK berarti bahwa pengirim menerima semua data koneksi sebelum byte <code>acknum</code> .  Paket dapat memiliki beberapa flag dan dipanggil dengan kombinasi mereka, misalnya, paket SYNACK. </p><br></li><li><p>  Sequence number (seqnum) mendefinisikan offset dalam aliran data untuk byte pertama yang dikirimkan dalam paket ini.  Misalnya, jika dalam paket pertama dengan data X byte angka ini adalah N, dalam paket berikutnya dengan data baru akan menjadi N + X.  Di awal koneksi, masing-masing pihak memilih nomor ini secara sewenang-wenang. </p><br></li><li><p>  Pengakuan nomor (acknum) - offset yang sama dengan seqnum, tetapi tidak menentukan jumlah byte yang akan dikirim, tetapi jumlah byte pertama dari penerima yang tidak dilihat pengirim. </p><br></li></ul><br><p>  Di awal koneksi, para pihak harus menyetujui <code>seqnum</code> dan <code>acknum</code> .  Klien mengirim paket SYN dengan <code>seqnum = X</code>  Server merespons dengan paket SYNACK, di mana ia menulis <code>seqnum = Y</code> dan menetapkan <code>acknum = X + 1</code> .  Klien merespon SYNACK dengan paket ACK, di mana <code>seqnum = X + 1</code> , <code>acknum = Y + 1</code> .  Setelah itu, transfer data aktual dimulai. </p><br><p>  Jika teman bicara tidak mengkonfirmasi penerimaan paket, TCP mengirimkannya lagi oleh batas waktu. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Mengapa cookie SYN tidak selalu digunakan?</b> <div class="spoiler_text"><p>  Pertama, jika SYNACK atau ACK hilang, Anda harus menunggu pengiriman ulang - koneksi melambat.  Kedua, dalam paket SYN - dan hanya di dalamnya!  - sejumlah opsi dikirimkan yang mempengaruhi operasi koneksi selanjutnya.  Tanpa mengingat paket SYN yang masuk, server mengabaikan opsi-opsi ini, pada paket selanjutnya klien tidak akan mengirimnya lagi.  Dalam hal ini, TCP dapat berfungsi, tetapi setidaknya pada tahap awal, kualitas koneksi akan menurun. </p></div></div><br><p>  Dalam hal paket, program XDP harus melakukan hal berikut: </p><br><ul><li>  SYNACK dengan cookie untuk menanggapi SYN; </li><li>  menanggapi ACK RST (putuskan); </li><li>  buang paket lain. </li></ul><br><p>  Algoritma pseudocode dan parsing paket: </p><br><pre> <code class="plaintext hljs">   Ethernet,  .    IPv4,  .     , (*)    ,  .    TCP,  . (**)   SYN,  SYN-ACK  cookie.   ACK,   acknum   cookie,  .      N  . (*)  RST. (**)     .</code> </pre> <br><p>  Satu <code>(*)</code> menunjukkan titik-titik di mana untuk mengontrol keadaan sistem - pada tahap pertama, Anda dapat melakukannya tanpa mereka dengan hanya menerapkan jabat tangan TCP dengan menghasilkan cookie SYN sebagai seqnum. </p><br><p>  Di tempat <code>(**)</code> , sementara kami tidak memiliki tabel, kami akan melewatkan paket. </p><br><h2 id="realizaciya-tcp-handshake">  Implementasi handshake TCP </h2><br><h3 id="razbor-paketa-i-verifikaciya-koda">  Parsing paket dan verifikasi kodenya </h3><br><p>  Kami membutuhkan struktur tajuk jaringan: Ethernet ( <code>uapi/linux/if_ether.h</code> ), IPv4 ( <code>uapi/linux/ip.h</code> ) dan TCP ( <code>uapi/linux/tcp.h</code> ).  Yang terakhir saya tidak bisa terhubung karena kesalahan terkait dengan <code>atomic64_t</code> , saya harus menyalin definisi yang diperlukan ke dalam kode. </p><br><p>  Semua fungsi yang dialokasikan dalam C untuk keterbacaan harus built-in di tempat panggilan, karena verifikasi eBPF di kernel melarang transisi kembali, yaitu, pada kenyataannya, loop dan panggilan fungsi. </p><br><pre> <code class="plaintext hljs">#define INTERNAL static __attribute__((always_inline))</code> </pre> <br><p>  Makro <code>LOG()</code> menonaktifkan pencetakan di rilis rilis. </p><br><p>  Program ini merupakan konveyor fungsi.  Setiap menerima paket di mana tajuk dari tingkat yang sesuai disorot, misalnya, <code>process_ether()</code> mengharapkan <code>ether</code> menjadi penuh.  Berdasarkan hasil analisis lapangan, fungsi tersebut dapat mentransfer paket ke tingkat yang lebih tinggi.  Hasil dari fungsi adalah tindakan XDP.  Sejauh ini, penangan SYN dan ACK melewati semua paket. </p><br><pre> <code class="plaintext hljs">struct Packet { struct xdp_md* ctx; struct ethhdr* ether; struct iphdr* ip; struct tcphdr* tcp; }; INTERNAL int process_tcp_syn(struct Packet* packet) { return XDP_PASS; } INTERNAL int process_tcp_ack(struct Packet* packet) { return XDP_PASS; } INTERNAL int process_tcp(struct Packet* packet) { ... } INTERNAL int process_ip(struct Packet* packet) { ... } INTERNAL int process_ether(struct Packet* packet) { struct ethhdr* ether = packet-&gt;ether; LOG("Ether(proto=0x%x)", bpf_ntohs(ether-&gt;h_proto)); if (ether-&gt;h_proto != bpf_ntohs(ETH_P_IP)) { return XDP_PASS; } // B struct iphdr* ip = (struct iphdr*)(ether + 1); if ((void*)(ip + 1) &gt; (void*)packet-&gt;ctx-&gt;data_end) { return XDP_DROP; /* malformed packet */ } packet-&gt;ip = ip; return process_ip(packet); } SEC("prog") int xdp_main(struct xdp_md* ctx) { struct Packet packet; packet.ctx = ctx; // A struct ethhdr* ether = (struct ethhdr*)(void*)ctx-&gt;data; if ((void*)(ether + 1) &gt; (void*)ctx-&gt;data_end) { return XDP_PASS; } packet.ether = ether; return process_ether(&amp;packet); }</code> </pre> <br><p>  Saya menarik perhatian pada cek bertanda A dan B. Jika Anda mengomentari A, program akan berkumpul, tetapi akan ada kesalahan verifikasi saat memuat: </p><br><pre> <code class="plaintext hljs">Verifier analysis: &lt;...&gt; 11: (7b) *(u64 *)(r10 -48) = r1 12: (71) r3 = *(u8 *)(r7 +13) invalid access to packet, off=13 size=1, R7(id=0,off=0,r=0) R7 offset is outside of the packet processed 11 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0 Error fetching program/map!</code> </pre> <br><p>  Garis kuncinya adalah <code>invalid access to packet, off=13 size=1, R7(id=0,off=0,r=0)</code> : ada jalur eksekusi ketika byte ketiga belas dari awal buffer berada di luar paket.  Menurut daftar, sulit untuk memahami baris mana yang sedang kita bicarakan, tetapi ada nomor instruksi (12) dan disassembler yang menunjukkan baris kode sumber: </p><br><pre> <code class="bash hljs">llvm-objdump -S xdp_filter.o | less</code> </pre> <br><p>  Dalam hal ini, itu menunjuk ke sebuah string </p><br><pre> <code class="plaintext hljs">LOG("Ether(proto=0x%x)", bpf_ntohs(ether-&gt;h_proto));</code> </pre> <br><p>  dimana jelas bahwa masalahnya ada di <code>ether</code> .  Akan selalu begitu. </p><br><h3 id="otvet-na-syn">  Balas ke SYN </h3><br><p>  Tujuan pada tahap ini adalah untuk membentuk paket SYNACK yang benar dengan <code>seqnum</code> tetap, yang akan digantikan oleh cookie SYN di masa mendatang.  Semua perubahan terjadi di <code>process_tcp_syn()</code> dan area sekitarnya. </p><br><h4 id="proverka-paketa">  Paket cek </h4><br><p>  Anehnya, inilah garis yang paling luar biasa, lebih tepatnya, komentar tentang itu: </p><br><pre> <code class="plaintext hljs">/* Required to verify checksum calculation */ const void* data_end = (const void*)ctx-&gt;data_end;</code> </pre> <br><p>  Saat menulis versi pertama dari kode, kernel 5.1 digunakan, untuk verifikasi yang ada perbedaan antara <code>data_end</code> dan <code>(const void*)ctx-&gt;data_end</code> .  Saat menulis artikel, kernel 5.3.1 tidak memiliki masalah seperti itu.  Mungkin kompiler mengakses variabel lokal berbeda dari bidang.  Moral - kode yang disederhanakan dapat membantu dengan banyak sarang. </p><br><p>  Pemeriksaan rutin lebih lanjut untuk menghormati verifikasi;  tentang <code>MAX_CSUM_BYTES</code> bawah. </p><br><pre> <code class="plaintext hljs">const u32 ip_len = ip-&gt;ihl * 4; if ((void*)ip + ip_len &gt; data_end) { return XDP_DROP; /* malformed packet */ } if (ip_len &gt; MAX_CSUM_BYTES) { return XDP_ABORTED; /* implementation limitation */ } const u32 tcp_len = tcp-&gt;doff * 4; if ((void*)tcp + tcp_len &gt; (void*)ctx-&gt;data_end) { return XDP_DROP; /* malformed packet */ } if (tcp_len &gt; MAX_CSUM_BYTES) { return XDP_ABORTED; /* implementation limitation */ }</code> </pre> <br><h4 id="razvorot-paketa">  Paket menyebar </h4><br><p>  Isi <code>seqnum</code> dan <code>acknum</code> , atur ACK (SYN sudah diatur): </p><br><pre> <code class="plaintext hljs">const u32 cookie = 42; tcp-&gt;ack_seq = bpf_htonl(bpf_ntohl(tcp-&gt;seq) + 1); tcp-&gt;seq = bpf_htonl(cookie); tcp-&gt;ack = 1;</code> </pre> <br><p>  Tukar port TCP, alamat IP, dan alamat MAC.  Pustaka standar tidak dapat diakses dari program XDP, jadi <code>memcpy()</code> adalah makro yang menyembunyikan intrinsik Dentang. </p><br><pre> <code class="plaintext hljs">const u16 temp_port = tcp-&gt;source; tcp-&gt;source = tcp-&gt;dest; tcp-&gt;dest = temp_port; const u32 temp_ip = ip-&gt;saddr; ip-&gt;saddr = ip-&gt;daddr; ip-&gt;daddr = temp_ip; struct ethhdr temp_ether = *ether; memcpy(ether-&gt;h_dest, temp_ether.h_source, ETH_ALEN); memcpy(ether-&gt;h_source, temp_ether.h_dest, ETH_ALEN);</code> </pre> <br><h4 id="pereschet-kontrolnyh-summ">  Perhitungan ulang checksum </h4><br><p>  Checksum IPv4 dan TCP memerlukan penambahan semua kata 16-bit dalam header, dan ukuran header ditulis di dalamnya, yaitu, pada saat kompilasi tidak diketahui.  Ini merupakan masalah karena verifier tidak akan melewatkan loop reguler ke batas variabel.  Tetapi ukuran header terbatas: masing-masing hingga 64 byte.  Anda dapat membuat lingkaran dengan sejumlah iterasi, yang dapat berakhir lebih cepat dari jadwal. </p><br><p>  Saya perhatikan bahwa ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC 1624</a> tentang cara menghitung ulang checksum sebagian jika hanya kata-kata paket tetap yang diubah.  Namun, metode ini tidak universal, dan implementasi akan lebih sulit untuk dipertahankan. </p><br><p>  Fungsi perhitungan Checksum: </p><br><pre> <code class="plaintext hljs">#define MAX_CSUM_WORDS 32 #define MAX_CSUM_BYTES (MAX_CSUM_WORDS * 2) INTERNAL u32 sum16(const void* data, u32 size, const void* data_end) { u32 s = 0; #pragma unroll for (u32 i = 0; i &lt; MAX_CSUM_WORDS; i++) { if (2*i &gt;= size) { return s; /* normal exit */ } if (data + 2*i + 1 + 1 &gt; data_end) { return 0; /* should be unreachable */ } s += ((const u16*)data)[i]; } return s; }</code> </pre> <br><p>   ,  <code>size</code>   ,    ,      . </p><br><p>  32-     : </p><br><pre> <code class="plaintext hljs">INTERNAL u32 sum16_32(u32 v) { return (v &gt;&gt; 16) + (v &amp; 0xffff); }</code> </pre> <br><p>        : </p><br><pre> <code class="plaintext hljs">ip-&gt;check = 0; ip-&gt;check = carry(sum16(ip, ip_len, data_end)); u32 tcp_csum = 0; tcp_csum += sum16_32(ip-&gt;saddr); tcp_csum += sum16_32(ip-&gt;daddr); tcp_csum += 0x0600; tcp_csum += tcp_len &lt;&lt; 8; tcp-&gt;check = 0; tcp_csum += sum16(tcp, tcp_len, data_end); tcp-&gt;check = carry(tcp_csum); return XDP_TX;</code> </pre> <br><p>  <code>carry()</code>   32-  16-   ,  RFC 791. </p><br><h4 id="proverka-rukopozhatiya-tcp">   TCP </h4><br><p>      <code>netcat</code> ,   ACK,   Linux  RST-,       SYN —     SYNACK    -       ,     . </p><br><pre> <code class="bash hljs">$ sudo ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test nc -nv 192.0.2.1 6666 192.0.2.1 6666: Connection reset by peer</code> </pre> <br><p>        <code>tcpdump</code>  <code>xdp-remote</code>  , , <code>hping3</code>      . </p><br><h3 id="syn-cookie"> SYN cookie </h3><br><p>    XDP   .    , ,    .  Linux, ,   SipHash,     XDP     . </p><br><p>    TODO,    : </p><br><ul><li><p> XDP-    <code>cookie_seed</code> (  )   ,    ,         . </p><br></li><li><p>   SYN cookie  ACK-    ,   IP  ,     . </p><br></li></ul><br><p>   : </p><br><pre> <code class="bash hljs">$ sudoip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test nc -nv 192.0.2.1 6666 192.0.2.1 6666: Connection reset by peer</code> </pre> <br><p>      ( <code>flags=0x2</code> —  SYN, <code>flags=0x10</code> —  ACK): </p><br><pre> <code class="plaintext hljs">Ether(proto=0x800) IP(src=0x20e6e11a dst=0x20e6e11e proto=6) TCP(sport=50836 dport=6666 flags=0x2) Ether(proto=0x800) IP(src=0xfe2cb11a dst=0xfe2cb11e proto=6) TCP(sport=50836 dport=6666 flags=0x10) cookie matches for client 20200c0</code> </pre> <br><p>     IP,    SYN flood  ,     ACK flood,   : </p><br><pre> <code class="bash hljs">sudo ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test hping3 --flood -A -s 1111 -p 2222 192.0.2.1</code> </pre> <br><p>   : </p><br><pre> <code class="plaintext hljs">Ether(proto=0x800) IP(src=0x15bd11a dst=0x15bd11e proto=6) TCP(sport=3236 dport=2222 flags=0x10) cookie mismatch</code> </pre> <br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  eBPF   XDP        ,     . , XDP —      ,     ,  DPDK    kernel bypass.   , XDP     , ,   ,       .     ,          userspace-. </p><br><p>   ,   ,       ,     userspace-   . </p><br><p>  Referensi: </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>   GitHub</strong></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bpftrace Cheat Sheet</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BPF and XDP Reference Guide</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">XDP Tutorial</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PoC: compiling to eBPF from Rust</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473286/">https://habr.com/ru/post/id473286/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473274/index.html">Acara digital di Moskow dari 28 Oktober hingga 3 November</a></li>
<li><a href="../id473276/index.html">Acara digital di St. Petersburg dari 28 Oktober hingga 3 November</a></li>
<li><a href="../id473278/index.html">Pembaruan Terminal Windows: Pratinjau 1910</a></li>
<li><a href="../id473282/index.html">Parthenon. Miliarder Slumdog: bagaimana saudara-saudara Bukhman menjadi miliarder, dan Vologda online - global</a></li>
<li><a href="../id473284/index.html">Senior, TechLead, Arsitek - apa selanjutnya? Bagaimana cara menghadapi rutinitas kerja dan ke mana harus pindah?</a></li>
<li><a href="../id473288/index.html">Buat kode Anda dari awal, ini akan memompa level Anda</a></li>
<li><a href="../id473290/index.html">Julia. Di mana memulai proyek? ...</a></li>
<li><a href="../id473292/index.html">Intisari materi menarik untuk pengembang ponsel # 319 (pada 21-27 Oktober)</a></li>
<li><a href="../id473294/index.html">Manajemen memori atau kurang sering menembak diri sendiri di kaki</a></li>
<li><a href="../id473296/index.html">Memulai tanpa uang. Pengalaman pribadi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>