<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌴 🎉 🖼️ Introdução ao teste de unidade no Unity 👨🏿‍🏫 👐🏿 ⛏️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Você está curioso para saber como o teste de unidade funciona no Unity? Não sabe ao certo o que é o teste de unidade? Se você respondeu positivamente ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introdução ao teste de unidade no Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456090/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b63/9d9/71f/b639d971f3e2a10105d91bb3c94fdbb1.jpg" alt="imagem"></div><br>  Você está curioso para saber como o teste de unidade funciona no Unity?  Não sabe ao certo o que é o teste de unidade?  Se você respondeu positivamente a essas perguntas, este tutorial será útil para você.  Com isso, você aprenderá o seguinte sobre o teste de unidade: <br><br><ul><li>  O que é isso </li><li>  Seu benefício </li><li>  Vantagens e desvantagens </li><li>  Como funciona no Unity usando o Test Runner </li><li>  Como escrever e executar testes de unidade que serão testados </li></ul><br><blockquote>  <em>Nota</em> : este tutorial pressupõe que você esteja familiarizado com a linguagem C # e os conceitos básicos de desenvolvimento no Unity.  Se você é novo no Unity, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">verifique primeiro os outros tutoriais neste mecanismo</a> . </blockquote><h2>  O que é um teste de unidade? </h2><br>  Antes de se aprofundar no código, é importante entender claramente o que é o teste de unidade.  Simplificando, o teste de unidade está testando ... unidades. <br><br>  <em>O teste de unidade</em> (idealmente) foi projetado para testar uma unidade de código separada.  A composição de uma "unidade" pode variar, mas é importante lembrar que o teste de unidade deve testar exatamente um "elemento" de cada vez. <br><a name="habracut"></a><br>  Testes de unidade precisam ser criados para verificar se um pequeno trecho de código lógico em um cenário específico é executado exatamente como o esperado.  Isso pode ser difícil de entender antes de você começar a escrever seus próprios testes de unidade, então vamos ver um exemplo: <br><br>  Você escreveu um método que permite ao usuário inserir um nome.  O método é escrito para que os números não sejam permitidos no nome e o próprio nome possa consistir em apenas dez ou menos caracteres.  Seu método intercepta o pressionamento de tecla de cada tecla e adiciona o caractere correspondente ao campo de <code>name</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateNameWithCharacter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">: character</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 if (!Char.IsLetter(char)) { return; } // 2 if (name.Length &gt; 10) { return; } // 3 name += character; }</span></span></code> </pre> <br>  O que está acontecendo aqui: <br><br><ol><li>  Se o caractere não for uma letra, o código sairá da função previamente e não o adicionará à string. </li><li>  Se o nome tiver dez ou mais caracteres, o código não permitirá que o usuário adicione outro caractere. </li><li>  Se essas duas verificações forem aprovadas, o código adicionará um caractere ao final do nome. </li></ol><br>  Esta unidade pode ser testada, porque é um "módulo" do trabalho realizado.  Os testes de unidade <i>aplicam a</i> lógica do método. <br><br><h2>  Exemplo de teste de unidade </h2><br>  Como escrevemos testes de unidade para o método <code>UpdateNameWithCharacter</code> ? <br><br>  Antes de começar a implementar esses testes de unidade, precisamos considerar cuidadosamente o que esses testes fazem e criar nomes para eles. <br><br>  Dê uma olhada nos exemplos de nome de teste de unidade abaixo.  Dos nomes, deve ficar claro que eles verificam: <br><br> <code>UpdateNameDoesntAllowCharacterAddingToNameIfNameIsTenOrMoreCharactersInLength</code> <br> <br> <code>UpdateNameAllowsLettersToBeAddedToName</code> <br> <br> <code>UpdateNameDoesntAllowNonLettersToBeAddedToName</code> <br> <br>  A partir desses nomes de métodos de teste, vemos que realmente verificamos se a "unidade" de trabalho é <code>UpdateNameWithCharacter</code> pelo método <code>UpdateNameWithCharacter</code> .  Esses nomes de teste podem parecer muito longos e detalhados, mas são bons para nós. <br><br>  Cada teste de unidade que você escreve faz parte de um conjunto de testes.  <em>O conjunto de testes</em> contém todos os testes de unidade relacionados ao grupo lógico funcional (por exemplo, "testes de unidade de batalha").  Se algum teste do kit falhar, todo o conjunto de testes falhará. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20d/1e7/0ed/20d1e70ed7231be0c0cfd5f6f082751c.png"></div><br><h2>  Lançamento do jogo </h2><br>  Abra o <em>projeto Crashteroids Starter</em> (você pode baixá-lo <a href="">aqui</a> ) e abra a cena do <em>jogo</em> na pasta <em>Assets / RW / Scenes</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/029/6fd/316/0296fd31696c7e75eeea4ec626709277.jpg"></div><br>  Clique em <em>Play</em> para iniciar o Crashteroids e, em seguida, clique no botão <em>Start Game</em> .  Mova a nave espacial com as setas <em>esquerda</em> e <em>direita</em> do teclado. <br><br>  Para disparar um raio laser, pressione a <em>barra de espaço</em> .  Se o feixe atingir o asteróide, a pontuação aumentará em um.  Se um asteróide colidir com um navio, o navio explode e o jogo termina (com a capacidade de começar de novo). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/cea/c40/c2fceac408455035e41f3c9c268ff448.jpg"></div><br>  Tente jogar um pouco e certifique-se de que após a colisão do asteróide com o navio apareça a inscrição Game Over. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b5/55f/fa6/0b555ffa69f33fb09fb17204197af889.jpg"></div><br><h2>  Introdução ao Unity Test Runner </h2><br>  Agora que sabemos como o jogo funciona, é hora de escrever testes de unidade para verificar se tudo funciona como deveria.  Portanto, se você (ou outra pessoa) decidir atualizar o jogo, você terá certeza de que a atualização não quebrará nada que funcionou antes. <br><br>  Para escrever testes, você primeiro precisa aprender sobre o Unity Test Runner.  <em>O Test Runner</em> permite executar testes e verificar se eles são aprovados com êxito.  Para abrir o Unity Test Runner, selecione <em>Janela ▸ Geral ▸ Test Runner</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f48/f31/aa4/f48f31aa4fc16c486b2161c75ba772af.jpg"></div><br>  Depois que o Test Runner abrir em uma nova janela, você poderá simplificar sua vida clicando na janela Test Runner e <em>arrastando</em> -a para o local próximo à janela Scene. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e10/25b/408/e1025b408f785453827a962ce33aff67.gif"></div><br><h2>  Preparando NUnit e pastas de teste </h2><br>  O Test Runner é um recurso de teste de unidade fornecido pelo Unity, mas usa a estrutura do <em>NUnit</em> .  Quando você começar a trabalhar com testes de unidade com mais seriedade, recomendo estudar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wiki no NUnit</a> para saber mais.  Sobre tudo o que você precisa pela primeira vez será discutido neste artigo. <br><br>  Para executar os testes, primeiro precisamos criar uma pasta de teste na qual as classes de teste serão armazenadas. <br><br>  Na janela <em>Projeto,</em> selecione a pasta <em>RW</em> .  Dê uma olhada na janela <em>Test Runner</em> e verifique se <em>PlayMode está</em> selecionado. <br><br>  Clique no botão chamado <em>Criar pasta de montagem de teste do PlayMode</em> .  Você verá uma nova pasta aparecer na pasta RW.  Estamos satisfeitos com o nome padrão de <em>testes</em> , para que você possa simplesmente pressionar <em>Enter</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f5/be4/df3/5f5be4df386c8f262c4a3c257b55319f.gif"></div><br>  Você pode estar se perguntando o que essas duas guias diferentes estão dentro do Test Runner. <br><br>  A guia <em>PlayMode é</em> usada para testes realizados no modo Play (quando o jogo está sendo executado em tempo real).  Os testes na guia <em>EditMode são</em> executados fora do modo Play, o que é conveniente para testar itens como comportamentos personalizados no Inspector. <br><br>  Neste tutorial, abordaremos os testes do PlayMode.  Mas quando você se sentir confortável, tente experimentar os testes no EditMode.  <em>Ao trabalhar com o Test Runner neste tutorial, sempre verifique se a guia PlayMode está selecionada</em> . <br><br><h2>  O que há na suíte de testes? </h2><br>  Como aprendemos acima, um teste de unidade é uma função que testa o comportamento de um pequeno pedaço específico de código.  Como o teste de unidade é um método, para executá-lo, ele deve estar no arquivo de classe. <br><br>  O Test Runner ignora todos os arquivos de classe de teste e executa testes de unidade a partir deles.  Um arquivo de classe contendo testes de unidade é chamado de suíte de testes. <br><br>  No conjunto de testes, subdividimos logicamente nossos testes.  Devemos separar o código de teste em conjuntos lógicos separados (por exemplo, um conjunto de testes para a física e um conjunto separado para a batalha).  Neste tutorial, precisamos de apenas um conjunto de testes e é hora de criar um. <br><br><h2>  Preparando um Conjunto de Testes e um Conjunto de Testes </h2><br>  Selecione a pasta <em>Testes</em> e, na janela <em>Test Runner</em> , clique no botão <em>Criar Script de Teste na pasta atual</em> .  Nome do novo arquivo <em>TestSuite</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/0ab/968/c640ab968dfd79a3c72e2a99bc5daa2c.gif"></div><br>  Além do novo arquivo C #, o mecanismo do Unity também cria outro arquivo chamado <em>Tests.asmdef</em> .  Este é o <em>arquivo de definição de montagem</em> , usado para mostrar ao Unity onde estão as dependências do arquivo de teste.  Isso é necessário porque o código final do aplicativo está contido separadamente do código de teste. <br><br>  Se você tiver uma situação em que o Unity não possa encontrar arquivos ou testes de teste, verifique se há um arquivo de definição de montagem que inclua seu conjunto de testes.  O próximo passo é configurá-lo. <br><br>  Para que o código de teste tenha acesso às classes de jogo, criaremos uma montagem do código de classe e definiremos o link na montagem Testes.  Clique na pasta <em>Scripts</em> para selecioná-la.  Clique com o botão direito nessa pasta e selecione <em>Criar Definition Definição de montagem</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b8/24c/84a/5b824c84ad6686493c41951751030b8d.jpg"></div><br>  Nomeie o arquivo <em>GameAssembly</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/bd6/c96/21bbd6c968426c23ea7839dd9f747355.png"></div><br>  Clique na pasta <em>Testes</em> e, em seguida, no arquivo de definição de criação <em>Testes</em> .  No <em>Inspetor,</em> clique no botão de <em>adição</em> sob o cabeçalho <em>Referências de definição de montagem</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/fc3/d13/4befc3d13ea67e5ec94b707d04582a3d.png"></div><br>  Você verá o campo <em>Referência ausente</em> .  Clique no <em>ponto</em> ao lado deste campo para abrir a janela de seleção.  Selecione o arquivo <em>GameAssembly</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/727/990/57f/72799057fe5ff62ba5c997d5ec2a7563.jpg"></div><br>  Você deve ver o arquivo de montagem do GameAssembly na seção de links.  Clique no botão <em>Aplicar</em> para salvar essas alterações. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a16/bf5/259/a16bf525984f2f23b819d9b2d0e37a2b.png"></div><br>  Se você não seguir estas etapas, não poderá fazer referência aos arquivos de classe do jogo dentro dos arquivos de teste de unidade.  Depois de lidar com isso, você pode prosseguir para o código. <br><br><h2>  Escrevemos o primeiro teste de unidade </h2><br>  Clique duas vezes no script <em>TestSuite</em> para abri-lo no editor de código.  Substitua todo o código por este: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.TestTools; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> NUnit.Framework; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TestSuite</span></span> { }</code> </pre> <br>  Quais testes precisamos escrever?  Honestamente, mesmo em um jogo minúsculo como o Crashteroids, você pode escrever alguns testes para verificar se tudo está funcionando como deveria.  Neste tutorial, nos restringimos a apenas áreas-chave: reconhecimento de colisão e mecânica básica de jogo. <br><br><blockquote>  <em>Nota</em> : quando se trata de escrever testes de unidade de um produto em um nível de produção, você deve dedicar tempo suficiente para levar em consideração todos os casos de fronteira que precisam ser testados em todas as áreas do código. </blockquote><br>  Como primeiro teste, é bom verificar se os asteróides estão realmente se movendo para baixo.  Será difícil para eles colidirem com o navio se afastarem dele!  Adicione o seguinte método e variável privada ao script <em>TestSuite</em> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Game game; <span class="hljs-comment"><span class="hljs-comment">// 1 [UnityTest] public IEnumerator AsteroidsMoveDown() { // 2 GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;("Prefabs/Game")); game = gameGameObject.GetComponent&lt;Game&gt;(); // 3 GameObject asteroid = game.GetSpawner().SpawnAsteroid(); // 4 float initialYPos = asteroid.transform.position.y; // 5 yield return new WaitForSeconds(0.1f); // 6 Assert.Less(asteroid.transform.position.y, initialYPos); // 7 Object.Destroy(game.gameObject); }</span></span></code> </pre> <br>  Existem apenas algumas linhas de código, mas elas fazem muitas coisas.  Então, vamos parar e lidar com cada parte: <br><br><ol><li>  Este é <em>um atributo</em> .  Os atributos definem comportamentos específicos do compilador.  Este atributo informa ao compilador Unity que o código é um teste de unidade.  Devido a isso, ele aparecerá no Test Runner ao iniciar os testes. </li><li>  Crie uma instância do jogo.  Todo o resto está incorporado no jogo, portanto, quando o criarmos, ele conterá tudo o que precisa ser testado.  Em um ambiente de produção, provavelmente todos os elementos não estarão dentro da mesma pré-fabricada.  Portanto, você precisará recriar todos os objetos necessários na cena. </li><li>  Aqui criamos um asteróide para que possamos monitorar se ele está se movendo.  O método <code>SpawnAsteroid</code> retorna uma instância do asteróide criado.  O componente Asteroid possui um método <code>Move</code> (se você estiver curioso para saber como o movimento funciona, consulte o script <em>Asteroid</em> em <em>RW / Scripts</em> ). </li><li>  O rastreamento da posição inicial é necessário para garantir que o asteróide tenha descido. </li><li>  Todos os testes de unidade do Unity são corotinas, portanto, é necessário adicionar um retorno suave.  Também adicionamos um intervalo de tempo de 0,1 segundos para simular a passagem de tempo pela qual o asteróide deveria descer.  Se você não precisar simular uma etapa do tempo, poderá retornar nulo. </li><li>  Este é o estágio de <em>afirmação</em> , no qual afirmamos que a posição do asteróide é menor que a posição inicial (ou seja, ele se moveu para baixo).  Compreender asserções é uma parte importante do teste de unidade, e o NUnit fornece vários métodos de asserção.  Passar ou não passar no teste é determinado por esta linha. </li><li>  Obviamente, ninguém o repreenderá pela bagunça deixada após a conclusão dos testes, mas outros testes poderão falhar devido a isso.  É sempre importante limpar (excluir ou redefinir) o código após o teste de unidade, para que, ao executar o próximo teste de unidade, não haja artefatos restantes que possam afetar esse teste.  Basta que excluamos o objeto do jogo, pois para cada teste criamos uma instância completamente nova do jogo. </li></ol><br><h2>  Passando nos testes </h2><br>  Bem, você escreveu seu primeiro teste de unidade, mas como você sabe se funciona?  Claro, com o Test Runner!  Na janela Test Runner, expanda todas as linhas com setas.  Você deve ver o teste <code>AsteroidsMoveDown</code> na lista com círculos em cinza: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4c/5d4/05a/d4c5d405a1aa5aded204806790a07233.jpg"></div><br>  Um círculo cinza indica que o teste ainda não foi concluído.  Se o teste foi iniciado e passou, uma seta verde é exibida ao lado.  Se o teste falhar, um X vermelho será exibido próximo a ele. Execute o teste clicando no botão <em>RunAll</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d45/da5/8c9/d45da58c99e0db679578aabab6e5601b.jpg"></div><br>  Isso criará uma cena temporária e executará o teste.  Após a conclusão, você deve ver que o teste foi aprovado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/640/16b/19e/64016b19e01a68544a1644b61ffb5c57.jpg"></div><br>  Você escreveu com sucesso seu primeiro teste de unidade, declarando que os asteróides criados estão se movendo para baixo. <br><br><blockquote>  <em>Nota</em> : antes de começar a escrever seus próprios testes de unidade, você precisa entender a implementação que está testando.  Se você estiver curioso para saber como a lógica que está testando está funcionando, estude o código na pasta <em>RW / Scripts</em> . </blockquote><br><h2>  Usando testes de integração </h2><br>  Antes de avançar mais fundo na toca do coelho dos testes de unidade, é hora de dizer o que são os testes de integração e como eles diferem dos testes de unidade. <br><br>  <em>Testes de integração</em> são testes que verificam como os "módulos" do código funcionam juntos.  "Módulo" é outro termo confuso.  Uma diferença importante é que os testes de integração devem testar a operação do software na produção real (ou seja, quando um jogador realmente joga um jogo). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f01/824/6f3/f018246f3658664a77104a1fa1dc045b.png"></div><br>  Digamos que você fez um jogo de batalha em que um jogador mata monstros.  Você pode criar um teste de integração para garantir que, quando um jogador mate 100 inimigos, uma conquista seja aberta ("Realização"). <br><br>  Este teste afetará vários módulos de código.  O mais provável é que ele se refira ao mecanismo físico (reconhecimento de colisão), despachantes inimigos (rastreando a saúde do inimigo e processando danos, bem como passando para outros eventos relacionados) e um rastreador de eventos que rastreia todos os eventos desencadeados (por exemplo, "o monstro está morto").  Então, quando for a hora de desbloquear a conquista, ele poderá ligar para o gerente de conquista. <br><br>  O teste de integração simulará o jogador matando 100 monstros e verificará se a conquista está desbloqueada.  É muito diferente do teste de unidade porque testa componentes de código grandes que trabalham juntos. <br><br>  Neste tutorial, não estudaremos testes de integração, mas isso deve mostrar a diferença entre a unidade de trabalho (e por que está sendo testada) e o módulo do código (e por que está sendo testada). <br><br><h2>  Adicionando um teste a um conjunto de testes </h2><br>  O próximo teste testará o final do jogo quando o navio colidir com um asteróide.  Com o <em>TestSuite</em> aberto no <em>editor de</em> código, adicione o teste mostrado abaixo no primeiro teste de unidade e salve o arquivo: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameOverOccursOnAsteroidCollision</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); Game game = gameGameObject.GetComponent&lt;Game&gt;(); GameObject asteroid = game.GetSpawner().SpawnAsteroid(); <span class="hljs-comment"><span class="hljs-comment">//1 asteroid.transform.position = game.GetShip().transform.position; //2 yield return new WaitForSeconds(0.1f); //3 Assert.True(game.isGameOver); Object.Destroy(game.gameObject); }</span></span></code> </pre> <br>  Já vimos a maior parte desse código no teste anterior, mas existem algumas diferenças: <br><br><ol><li>  Forçamos o asteróide e a nave a colidir, dando claramente ao asteróide a mesma posição que a nave.  Isso criará uma colisão de seus hitboxes e levará ao final do jogo.  Se você estiver curioso para saber como esse código funciona, consulte os arquivos <em>Navio</em> , <em>Jogo</em> e <em>Asteróide</em> na pasta Scripts. </li><li>  Uma etapa de tempo é necessária para que o evento Collision do mecanismo físico seja acionado, portanto, um atraso de 0,1 segundos é retornado. </li><li>  Essa afirmação é verdadeira e verifica se o sinalizador <code>gameOver</code> no script Game é verdadeiro.  A bandeira é verdadeira durante a operação do jogo, quando a nave é destruída, ou seja, testamos para garantir que ela seja verdadeira após a destruição da nave. </li></ol><br>  Volte à janela Test Runner e você verá que um novo teste de unidade apareceu lá. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a8/f52/b28/4a8f52b2875ca90a37b74348435e3da5.jpg"></div><br>  Desta vez, executaremos este em vez de todo o conjunto de testes.  Clique em <em>GameOverOccursOnAsteroidCollision</em> e, em seguida, no botão <em>Executar Selecionado</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e2/0f5/fbd/7e20f5fbd8b4a8a6ff849fea66c90ed1.jpg"></div><br>  E pronto, passamos em outro teste. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/966/02f/869/96602f869c59d8218407a7ce2e57df7d.jpg"></div><br><h2>  Estágios de sintonia e destruição </h2><br>  Você deve ter notado que em nossos dois testes há um código repetido: onde o objeto Game é criado e onde um link para o script Game é definido: <br><br><pre> <code class="cs hljs">GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); game = gameGameObject.GetComponent&lt;Game&gt;();</code> </pre> <br>  Você também notará que há uma repetição na destruição do objeto Jogo: <br><br><pre> <code class="cs hljs">Object.Destroy(game.gameObject);</code> </pre> <br>  Ao testar isso acontece com muita frequência.  Quando se trata de executar testes de unidade, na verdade existem duas fases: a fase <em>Setup</em> e a fase <em>Tear Down</em> . <br><br>  Todo o código dentro do método Setup será executado antes do teste de unidade (neste conjunto) e todo código dentro do método Tear Down será executado após o teste de unidade (neste conjunto). <br><br>  É hora de simplificar nossas vidas, movendo a configuração e o código de detalhamento para métodos especiais.  Abra o editor de código e adicione o seguinte código no início do arquivo <em>TestSuite</em> , logo antes do primeiro atributo [UnityTest]: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SetUp</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); game = gameGameObject.GetComponent&lt;Game&gt;(); }</code> </pre> <br>  O atributo <code>SetUp</code> indica que esse método é chamado antes da <code>SetUp</code> cada teste. <br><br>  Em seguida, adicione o seguinte método e salve o arquivo: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TearDown</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Teardown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Object.Destroy(game.gameObject); }</code> </pre> <br>  O atributo <code>TearDown</code> indica que esse método é chamado após a <code>TearDown</code> cada teste. <br><br>  Depois de preparar o código de configuração e destruição, exclua as linhas de código presentes nesses métodos e substitua-as por chamadas aos métodos correspondentes.  Depois disso, o código ficará assim: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TestSuite</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Game game; [SetUp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); game = gameGameObject.GetComponent&lt;Game&gt;(); } [TearDown] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Teardown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Object.Destroy(game.gameObject); } [UnityTest] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsteroidsMoveDown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject asteroid = game.GetSpawner().SpawnAsteroid(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> initialYPos = asteroid.transform.position.y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForSeconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.1f</span></span></span></span></span><span class="hljs-function">)</span></span>; Assert.Less(asteroid.transform.position.y, initialYPos); } [UnityTest] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameOverOccursOnAsteroidCollision</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject asteroid = game.GetSpawner().SpawnAsteroid(); asteroid.transform.position = game.GetShip().transform.position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForSeconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.1f</span></span></span></span></span><span class="hljs-function">)</span></span>; Assert.True(game.isGameOver); } }</code> </pre> <br><h2>  Teste de game over e tiro a laser </h2><br>  Tendo preparado os métodos de ajuste e destruição que simplificam nossas vidas, podemos começar a adicionar novos testes nos quais eles são usados.  O próximo teste é verificar se, quando um jogador clica em <em>Novo jogo</em> , o valor do <em>gameOver bool</em> não <em>é</em> verdadeiro.  Adicione esse teste ao final do arquivo e salve-o: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewGameRestartsGame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 game.isGameOver = true; game.NewGame(); //2 Assert.False(game.isGameOver); yield return null; }</span></span></code> </pre> <br>  Isso já deve lhe parecer familiar, mas vale a pena mencionar o seguinte: <br><br><ol><li>  Este trecho de código prepara esse teste para que o <code>gameOver</code> booleano <code>gameOver</code> seja verdadeiro.  Ao chamar o método <code>NewGame</code> , ele deve novamente definir o sinalizador como <code>false</code> . </li><li>  Aqui argumentamos que o bool <code>isGameOver</code> é <code>false</code> , o que deve ser verdadeiro ao invocar um novo jogo. </li></ol><br>  Retorne ao Test Runner e você verá que há um novo teste <em>NewGameRestartsGame</em> .  Execute este teste, como fizemos anteriormente, e você verá que ele é executado com êxito: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b63/9d9/71f/b639d971f3e2a10105d91bb3c94fdbb1.jpg"></div><br><h2>  Declaração do raio laser </h2><br>  O próximo teste é adicionar o teste de que o raio laser disparado pelo navio está voando (semelhante ao primeiro teste de unidade que escrevemos).  Abra o arquivo <em>TestSuite</em> no editor.  Adicione o seguinte método e salve o arquivo: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LaserMovesUp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 GameObject laser = game.GetShip().SpawnLaser(); // 2 float initialYPos = laser.transform.position.y; yield return new WaitForSeconds(0.1f); // 3 Assert.Greater(laser.transform.position.y, initialYPos); }</span></span></code> </pre> <br>  Aqui está o que esse código faz: <br><br><ol><li>  Obtém um link para o raio laser gerado emitido pelo navio. </li><li>  A posição inicial é registrada para que possamos verificar se está subindo. </li><li>  Essa afirmação é consistente com a afirmação do teste de unidade <code>AsteroidsMoveDown</code> , mas agora afirmamos que o valor é maior (ou seja, o laser sobe). </li></ol><br>      Test Runner.   <em>LaserMovesUp</em>     : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ce/a15/242/2cea152426f82ea491345ead3f0eaa94.jpg"></div><br>      ,   ,          . <br><br><h2>  ,     </h2><br>   ,      .       <em>TestSuite</em>  ,    : <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LaserDestroysAsteroid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 GameObject asteroid = game.GetSpawner().SpawnAsteroid(); asteroid.transform.position = Vector3.zero; GameObject laser = game.GetShip().SpawnLaser(); laser.transform.position = Vector3.zero; yield return new WaitForSeconds(0.1f); // 2 UnityEngine.Assertions.Assert.IsNull(asteroid); }</span></span></code> </pre> <br>    : <br><br><ol><li>      ,        . </li><li>      . ,         <em>UnityEngine.Assertions</em> ?   ,   Unity    <em>Null</em> ,   «»  Null.   NUnit <code>Assert.IsNull()</code> <i>  </i>   Unity  null.    null  Unity,     UnityEngine.Assertions.Assert,   Assert  NUnit. </li></ol><br>   Test Runner    .      . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/275/80f/1b2/27580f1b206647e0a2fd09c43577ee8f.jpg"></div><br><h2>     —     </h2><br>   - —  ,       .      .    ,  <em>  </em> (Test Driven Development, TDD). <br><br>    TDD,        .    , ,     ,     ,    .       ,   ,        . <br><br>   ,       .      -,    ,     . <br><br><blockquote> <em></em> :    —    ,    .   ,           .    «» ,   ,      .   ,             .        ,        .       ,     ,            . </blockquote><br>      ,        -   : <br><br><h2>  - </h2><br>  -    ,     : <br><br><ul><li>   ,     ,  . </li><li>     ,    (-    ). </li><li>      . </li><li>      . </li><li>            (   ). </li></ul><br><h2>  - </h2><br>            -.      : <br><br><ul><li>      ,   . </li><li>       . </li><li>      . </li><li> ,        . </li><li>         ,    -. </li><li>     (       ),       . </li><li> -    . </li><li> UI  . </li><li>           . </li><li>              . </li></ul><br><h2>  ,       </h2><br>     .   ,        <em>TestSuite</em>   : <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyedAsteroidRaisesScore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 GameObject asteroid = game.GetSpawner().SpawnAsteroid(); asteroid.transform.position = Vector3.zero; GameObject laser = game.GetShip().SpawnLaser(); laser.transform.position = Vector3.zero; yield return new WaitForSeconds(0.1f); // 2 Assert.AreEqual(game.score, 1); }</span></span></code> </pre> <br>   , ,     ,  .     : <br><br><ol><li>      ,      .    ,    . </li><li> ,  game.score   1 (  0,    ). </li></ol><br>      Test Runner,       ,    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5d/d4c/0ee/e5dd4c0ee4ad72e21a180621c65c11ba.jpg"></div><br>  Awesome!   . <br><br><h2>  Para onde ir a seguir? </h2><br>       .         ,     <a href=""></a> ,        . <br><br>     ,   -      Unity.  ,    -,    ,         -. <br><br>   ?      .        -    .       : <br><br><ul><li>          . </li><li>     . </li><li>        . </li></ul><br>         -,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">    mock-</a> .      . <br><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> NUnit</a> ,      NUnit. <br><br>          . <br><br>  ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt456090/">https://habr.com/ru/post/pt456090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt456078/index.html">Projeção de conflito corporativo na conectividade de rede</a></li>
<li><a href="../pt456082/index.html">Como desenvolvemos recomendações personalizadas de produtos</a></li>
<li><a href="../pt456084/index.html">Kubernetes 1.15: Visão geral dos destaques</a></li>
<li><a href="../pt456086/index.html">Storyboards para iOS: análise dos prós e contras, melhores práticas</a></li>
<li><a href="../pt456088/index.html">Problemas de análise de big data</a></li>
<li><a href="../pt456092/index.html">Sete sinais preocupantes de que você depende do clima, mesmo que você não pense</a></li>
<li><a href="../pt456094/index.html">Lemos as fichas técnicas 2: SPI no STM32; Temporizadores PWM e interrupções no STM8</a></li>
<li><a href="../pt456096/index.html">O que o leitor comum de tempos de nerd faz enquanto paira nas nuvens</a></li>
<li><a href="../pt456100/index.html">Agora na nova embalagem - o Kingston A400 no formato M.2 chega ao mercado</a></li>
<li><a href="../pt456102/index.html">Relatórios fáceis em C / C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>