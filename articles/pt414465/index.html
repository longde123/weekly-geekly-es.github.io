<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💊 👨‍🏭 👩🏻‍💼 Meta Crush Saga: jogo em tempo de compilação ✌🏿 🤷 👇🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No processo de mudança para o tão esperado título de Lead Senior C ++ Over-Engineer , no ano passado, decidi reescrever o jogo que estou desenvolvendo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meta Crush Saga: jogo em tempo de compilação</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414465/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/f40/952/a5bf40952c8280e1f9c41e965600816f.gif" alt="imagem"></div><br>  No processo de mudança para o tão esperado título de <strong>Lead Senior C ++ Over-Engineer</strong> , no ano passado, decidi reescrever o jogo que estou desenvolvendo durante o horário de trabalho (Candy Crush Saga), usando a quintessência do C ++ moderno (C ++ 17).  E assim nasceu a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Meta Crush Saga</a> : um <strong>jogo que é executado na fase de compilação</strong> .  Fiquei muito inspirado pelo jogo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nibbler de</a> Matt Birner, que usou pura metaprogramação em modelos para recriar a famosa Snake com o Nokia 3310. <br><br>  “Que tipo de <strong>jogo está sendo executado no estágio de compilação</strong> ?”, “Como ele se parece?”, “Que funcionalidade do <strong>C ++ 17</strong> você usou neste projeto?”, “O que você aprendeu?”  - Perguntas semelhantes podem vir à sua mente.  Para respondê-las, você terá que ler a postagem inteira ou aguentar sua preguiça interior e assistir a uma versão em vídeo da publicação - meu relatório do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">evento Meetup</a> em Estocolmo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XV1lXtB3sqg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Nota: para o bem da sua saúde mental e porque <em>errare humanum est</em> , são apresentados alguns fatos alternativos neste artigo. <br><a name="habracut"></a><br><h2>  Um jogo que roda em tempo de compilação? </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61c/1ab/166/61c1ab166775d7f49e32620b72abb6e4.png"></div><br>  Penso que, para entender o que quero dizer com o "conceito" de um <strong>jogo executado na fase de compilação</strong> , você precisa comparar o ciclo de vida de um jogo com o ciclo de vida de um jogo comum. <br><br><h3>  O ciclo de vida de um jogo regular: </h3><br>  Como um desenvolvedor regular de jogos com uma vida normal, trabalhando em um trabalho regular com um nível normal de saúde mental, você geralmente começa escrevendo a <strong>lógica do jogo</strong> no seu idioma favorito (em C ++, é claro!) E depois executa o <strong>compilador</strong> para convertê-lo, muitas vezes como espaguete lógica em um <strong>arquivo executável</strong> .  Após clicar duas vezes no <strong>arquivo executável</strong> (ou iniciar no console), o sistema operacional gera um <strong>processo</strong> .  Esse <strong>processo</strong> executará a <strong>lógica</strong> do <strong>jogo</strong> , que consiste em um <strong>ciclo de jogo</strong> em 99,42% do tempo.  <strong>O ciclo do jogo</strong> <strong>atualiza o</strong> estado do jogo de acordo com certas regras e informações do <strong>usuário</strong> , <strong>renderiza o</strong> novo estado calculado do jogo em pixels, novamente, novamente e novamente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/e6c/3b2/7bce6c3b238299f98b6c16e339aa5b10.png"></div><br><h3>  O ciclo de vida de um jogo em execução durante o processo de compilação: </h3><br>  Como um engenheiro em excesso que cria seu novo jogo legal de compilação, você ainda usa sua linguagem favorita (ainda em C ++, é claro!) Para escrever a <strong>lógica do jogo</strong> .  Então, como antes, <strong>a fase de compilação</strong> continua, mas há uma reviravolta na trama: você <strong>executa</strong> a <strong>lógica do jogo</strong> na fase de compilação.  Você pode chamá-lo de "execução" (compilação).  E aqui C ++ é muito útil;  possui recursos como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teta</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">(Template Meta Programming)</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">constexpr</a> que permitem realizar <strong>cálculos</strong> na <strong>fase de compilação</strong> .  Mais tarde, consideraremos a funcionalidade que pode ser usada para isso.  Como nesta fase executamos a <strong>lógica do</strong> jogo, nesse momento também precisamos inserir a <strong>entrada do jogador</strong> .  Obviamente, nosso compilador ainda criará um <strong>arquivo executável</strong> na saída.  Para que ele pode ser usado?  O arquivo executável não conterá mais <strong>o loop do jogo</strong> , mas possui uma missão muito simples: exibir um novo <strong>estado calculado</strong> .  Vamos chamar esse <strong>arquivo executável de</strong> <strong>renderizador</strong> e <strong>os dados</strong> <strong>renderizados</strong> são <strong>renderizados</strong> .  Em nossa <strong>renderização,</strong> nem belos efeitos de partículas nem sombras de oclusão ambiental serão contidas, será ASCII.  A <strong>renderização</strong> ASCII <strong>do</strong> novo <strong>estado</strong> calculado é uma propriedade conveniente que pode ser facilmente demonstrada ao player, mas, além disso, a copiamos para um arquivo de texto.  Por que um arquivo de texto?  Obviamente, porque ele pode de alguma forma ser combinado com o <strong>código</strong> e executar novamente todas as etapas anteriores, obtendo assim um <strong>loop</strong> . <br><br>  Como você já pode entender, o jogo <strong>executado durante o processo de compilação</strong> consiste em um <strong>ciclo de jogo</strong> no qual cada <strong>quadro do</strong> jogo é um <strong>estágio de compilação</strong> .  Cada <strong>estágio da compilação</strong> calcula um novo <strong>estado do</strong> jogo, que pode ser mostrado ao jogador e inserido no próximo <strong>quadro</strong> / <strong>estágio da compilação</strong> . <br><br>  Você pode contemplar esse diagrama magnífico o quanto quiser até entender o que acabei de escrever: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/2b8/d88/95c2b8d88aa04173139e82f9b4410cd9.png"></div><br>  Antes de entrarmos nos detalhes da implementação desse ciclo, tenho certeza de que deseja me fazer a única pergunta ... <br><br><h3>  "Por que se preocupar em fazer isso?" </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/695/1db/ec8/6951dbec8feeb002a132f801ea6866ed.png"></div><br>  Você realmente acha que arruinar meu idílio de metaprogramação em C ++ é uma questão tão fundamental?  Sim, por nada na vida! <br><br><ul><li>  A primeira e mais importante é <strong>que o jogo executado na fase de compilação</strong> terá uma incrível velocidade de tempo de execução, porque a maior parte dos cálculos é realizada na <strong>fase de compilação</strong> .  A velocidade do tempo de execução é a chave para o sucesso do nosso jogo AAA com gráficos ASCII! </li><li>  Você reduz a probabilidade de aparecer algum crustáceo em seu repositório e solicita que você reescreva o jogo no <strong>Rust</strong> .  Seu discurso bem preparado desmoronará assim que você lhe explicar que um ponteiro inválido não pode existir no momento da compilação.  <strong>Os</strong> programadores autoconfiantes de <strong>Haskell</strong> podem até confirmar a <strong>segurança do tipo</strong> no seu código. </li><li>  Você ganhará o respeito do reino moderno do <strong>Javascript</strong> , no qual qualquer estrutura reprojetada com uma forte síndrome do NIH pode governar, desde que tenha um nome interessante. </li><li>  Um amigo meu costumava dizer que qualquer linha de código Perl pode ser usada de fato como uma senha muito forte.  Estou certo de que ele nunca tentou gerar senhas no <strong>tempo de compilação</strong> do <strong>C ++</strong> . </li></ul><br>  Como  Você está satisfeito com minhas respostas?  Então talvez sua pergunta deva ser: "Como você consegue fazer isso?" <br><br>  Na verdade, eu realmente queria experimentar a funcionalidade adicionada no <strong>C ++ 17</strong> .  Alguns recursos visam aumentar a eficácia da linguagem, bem como a metaprogramação (principalmente constexpr).  Eu pensei que, em vez de escrever pequenos exemplos de código, seria muito mais interessante transformar tudo isso em um jogo.  Projetos de animais de estimação são uma ótima maneira de aprender conceitos que você não precisa usar frequentemente em seu trabalho.  A capacidade de executar lógica de jogo básica em tempo de compilação novamente prova que modelos e constepxr são subconjuntos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">completos de Turing</a> da linguagem C ++. <br><br><h2>  Revisão do jogo Meta Crush Saga </h2><br><h3>  Jogo de combinação 3: </h3><br>  <strong>Meta Crush Saga</strong> é um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jogo</a> de <strong>combinação</strong> de <strong>peças</strong> semelhante ao <strong>Bejeweled</strong> e <strong>Candy Crush Saga</strong> .  O núcleo das regras do jogo é conectar três peças com o mesmo padrão para obter pontos.  Aqui está uma rápida olhada no <strong>estado do jogo</strong> que eu "despejei" (despejar no ASCII é muito fácil de obter): <br><br><pre>  R "(
     Meta crush saga      
 ------------------------  
 |  | 
 |  RBGBBYGR 
 |  | 
 |  | 
 |  YYGRBGBR 
 |  | 
 |  | 
 |  RBYRGRYG 
 |  | 
 |  | 
 |  RYBY (R) YGY 
 |  | 
 |  | 
 |  BGYRYGGR 
 |  | 
 |  | 
 |  RYBGYBBG 
 |  | 
 ------------------------  
 &gt; pontuação: 9009
 &gt; movimentos: 27
 ) " </pre><br><br>  A jogabilidade deste jogo Match-3 em si não é particularmente interessante, mas e a arquitetura na qual tudo funciona?  Para que você entenda, tentarei explicar todas as partes do ciclo de vida desse jogo em <strong>tempo de compilação</strong> em termos de código. <br><br><h3>  Injeção do estado do jogo: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/20f/ffa/94220fffabe5eca432d47b90491fe7e7.png"></div><br>  Se você é um apaixonado ou pedante apaixonado por C ++, pode ter notado que o despejo de estado do jogo anterior começa com o seguinte padrão: <strong>R "(</strong> . Na verdade, esse é um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">literal de cadeia de caracteres C ++ 11 bruto</a> , o que significa que não preciso escapar de caracteres especiais, por exemplo, <strong>tradução strings</strong> : o literal da string bruta é armazenado em um arquivo chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">current_state.txt</a> . <br><br>  Como injetamos esse estado atual do jogo em um estado de compilação?  Vamos adicioná-lo às entradas de loop! <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// loop_inputs.hpp constexpr KeyboardInput keyboard_input = KeyboardInput::KEYBOARD_INPUT; //       constexpr auto get_game_state_string = []() constexpr { auto game_state_string = constexpr_string( //       #include "current_state.txt" ); return game_state_string; };</span></span></code> </pre> <br>  Seja um arquivo <em>.txt</em> ou um arquivo <em>.h</em> , a diretiva de <strong>inclusão</strong> do pré-processador C funcionará da mesma maneira: copia o conteúdo do arquivo para seu local.  Aqui eu copio a string bruta literal do estado do jogo em ASCII para uma variável chamada <strong>game_state_string</strong> . <br><br>  Observe que o <a href="">arquivo de</a> cabeçalho <a href="">loop_inputs.hpp</a> também expande a entrada do teclado para a etapa atual do quadro / compilação.  Ao contrário do estado do jogo, o estado do teclado é bastante pequeno e pode ser facilmente obtido como uma definição de pré-processador. <br><br><h3>  Computando um novo estado em tempo de compilação: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1a/adb/e44/b1aadbe44035019fdc8bdb89a02b31b1.png"></div><br>  Agora que coletamos dados suficientes, podemos calcular o novo estado.  Finalmente, chegamos ao ponto em que precisamos escrever o arquivo <a href="">main.cpp</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// main.cpp #include "loop_inputs.hpp" //   ,   . // :    . constexpr auto current_state = parse_game_state(get_game_state_string); //      . constexpr auto new_state = game_engine(current_state) //    , .update(keyboard_input); //  ,    . constexpr auto array = print_game_state(new_state); //      std::array&lt;char&gt;. // :    . //  :   . for (const char&amp; c : array) { std::cout &lt;&lt; c; }</span></span></code> </pre> <br>  Estranho, mas esse código C ++ não parece tão confuso, considerando o que faz.  A maior parte do código é executada na fase de compilação, no entanto, segue os paradigmas tradicionais de programação processual e POO.  Somente a última linha - renderização - é um obstáculo para realizar cálculos completos em tempo de compilação.  Como veremos abaixo, lançando um pouco de consexpr nos lugares certos, podemos obter uma metaprogramação bastante elegante no C ++ 17.  Acho deliciosa a liberdade que o C ++ nos dá quando se trata de execução mista em tempo de execução e compilação. <br><br>  Você também notará que esse código executa apenas um quadro, não há <strong>loop de jogo</strong> .  Vamos resolver esse problema! <br><br><h3>  Colamos tudo juntos: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d0/c65/870/8d0c65870264bfff26fde91c230bb8db.png"></div><br>  Se você repugna meus truques com <strong>C ++</strong> , espero que não se importe em ver minhas habilidades em <strong>Bash</strong> .  De fato, meu <strong>loop de jogo</strong> nada mais é do que um <a href="">script bash</a> que é compilado constantemente. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  !  ,    !!! while; do : #      G++ g++ -o renderer main.cpp -DKEYBOARD_INPUT="$keypressed" keypressed=get_key_pressed() #  . clear #   current_state=$(./renderer) echo $current_state #    #     current_state.txt file       . echo "R\"(" &gt; current_state.txt echo $current_state &gt;&gt; current_state.txt echo ")\"" &gt;&gt; current_state.txt done</span></span></code> </pre> <br>  Na verdade, eu estava tendo um pouco de dificuldade em obter a entrada do teclado no console.  Inicialmente, eu queria entrar em paralelo com a compilação.  Depois de muitas tentativas e erros, consegui trabalhar mais ou menos com o comando <code>read</code> do <strong>Bash</strong> .  Eu nunca ouso lutar contra o bruxo <strong>Bash</strong> em um duelo - essa linguagem é muito sinistra! <br><br>  Portanto, devo admitir que, para gerenciar o ciclo do jogo, tive que recorrer a outro idioma.  Embora tecnicamente nada me impedisse de escrever esta parte do código em C ++.  Além disso, isso não nega o fato de que 90% da lógica do meu jogo é executada dentro da equipe de compilação do <strong>g ++</strong> , o que é incrível! <br><br><h3>  Um pouco de jogabilidade para descansar os olhos: </h3><br>  Agora que você experimentou o tormento de explicar a arquitetura do jogo, chegou a hora de pinturas atraentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/f40/952/a5bf40952c8280e1f9c41e965600816f.gif"></div><br>  Este gif pixelizado é um registro de como eu jogo <strong>Meta Crush Saga</strong> .  Como você pode ver, o jogo funciona sem problemas o suficiente para ser jogado em tempo real.  Obviamente, ela não é tão atraente que eu possa transmitir seu Twitch e me tornar a nova Pewdiepie, mas ela funciona! <br><br>  Um dos aspectos divertidos de armazenar o <strong>estado de um jogo</strong> em um arquivo <em>.txt</em> é a capacidade de enganar ou testar casos extremos de maneira muito conveniente. <br><br>  Agora que apresentei brevemente a arquitetura, vamos nos aprofundar na funcionalidade C ++ 17 usada neste projeto.  Não considerarei a lógica do jogo em detalhes, porque se refere exclusivamente ao Match-3; em vez disso, falarei sobre aspectos do C ++ que podem ser aplicados em outros projetos. <br><br><h2>  Meus tutoriais sobre C ++ 17: </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3f/325/d96/c3f325d9618c2a89dadb2873c61a7921.png"></div><br>  Ao contrário do C ++ 14, que continha principalmente pequenas correções, o novo padrão C ++ 17 pode nos oferecer muito.  Havia esperanças de que finalmente os recursos esperados (módulos, corotinas, conceitos ...) finalmente aparecessem, mas ... em geral ... eles não apareciam;  isso incomodou muitos de nós.  Mas, depois de remover o luto, encontramos muitos pequenos tesouros inesperados que, no entanto, caíram no padrão. <br><br>  Ouso dizer que as crianças que amam metaprogramação são muito mimadas este ano!  Agora, pequenas alterações e adições separadas ao idioma permitem que você escreva um código que funciona muito em tempo de compilação e depois em tempo de execução. <br><br><h3>  Constepxr em todos os campos: </h3><br>  Como Ben Dean e Jason Turner previram em seu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relatório sobre o C ++ 14</a> , o C ++ permite melhorar rapidamente a compilação de valores em tempo de compilação com a palavra-chave onipotente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">constexpr</a> .  Ao localizar essa palavra-chave nos lugares certos, você pode informar ao compilador que a expressão é constante e <strong>pode ser</strong> avaliada diretamente no momento da compilação.  No <strong>C ++ 11,</strong> já poderíamos escrever este código: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//    constexpr       . { return n &lt;= 1? 1 : (n * factorial(n - 1)); } int i = factorial(5); //  constexpr-. //      : // int i = 120;</span></span></span></span></code> </pre> <br>  Embora a palavra-chave <strong>constexpr</strong> seja muito poderosa, ela possui algumas restrições de uso, dificultando a gravação de código expressivo dessa maneira. <br><br>  <strong>O C ++ 14</strong> reduziu bastante os requisitos para o <strong>constexpr</strong> e tornou-se muito mais natural de usar.  Nossa função fatorial anterior pode ser reescrita da seguinte forma: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  <strong>O C ++ 14</strong> se livrou da regra de que uma <strong>função constexpr</strong> deveria consistir em apenas uma declaração de retorno, o que nos forçou a usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">operador ternário</a> como o principal componente.  Agora, o <strong>C ++ 17</strong> traz ainda mais aplicativos de palavras-chave <strong>constexpr</strong> que podemos explorar! <br><br><h4>  Ramificação em tempo de compilação: </h4><br>  Você já esteve em uma situação em que precisa ter um comportamento diferente, dependendo do parâmetro do modelo que está manipulando?  Suponha que precisamos de uma função parametrizada <code>serialize</code> , que chamará <code>.serialize()</code> se o objeto fornecer, caso contrário, ele recorrerá à chamada <code>to_string</code> .  Como explicado em mais detalhes neste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">post sobre SFINAE</a> , provavelmente você precisará escrever um código alienígena: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;has_serialize_v&lt;T&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; serialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.serialize(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!has_serialize_v&lt;T&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; serialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(obj); }</code> </pre> <br>  Somente em um sonho você poderia reescrever esse <strong>truque</strong> feio do <strong>truque do SFINAE</strong> para o <strong>C ++ 14</strong> em um código tão magnífico: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// has_serialize -  constexpr-,  serialize  . // .    SFINAE,  ,    . template &lt;class T&gt; constexpr bool has_serialize(const T&amp; /*t*/); template &lt;class T&gt; std::string serialize(const T&amp; obj) { //  ,  constexpr    . if (has_serialize(obj)) { return obj.serialize(); } else { return std::to_string(obj); } }</span></span></code> </pre> <br>  Infelizmente, quando você acordou e começou a escrever <strong>código C ++ 14</strong> real, seu compilador emitiu uma mensagem desagradável sobre a chamada <code>serialize(42);</code>  .  Ele explicou que um <code>obj</code> tipo <code>int</code> não possui uma função de membro <code>serialize()</code> .  Não importa como isso o enfurece, o compilador está certo!  Com esse código, ele sempre tentará compilar os dois ramos - <code>return obj.serialize();</code>  e <br> <code>return std::to_string(obj);</code>  .  Para <code>int</code> branch <code>return obj.serialize();</code>  Pode muito bem ser algum tipo de código morto, porque <code>has_serialize(obj)</code> sempre retornará <code>false</code> , mas o compilador ainda precisará compilá-lo. <br><br>  Como você provavelmente adivinhou, o <strong>C ++ 17</strong> nos salva de uma situação tão desagradável, porque tornou possível adicionar <strong>constexpr</strong> após a instrução if para "forçar" a ramificação no tempo de compilação e descartar construções não utilizadas: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// has_serialize... // ... template &lt;class T&gt; std::string serialize(const T&amp; obj) if constexpr (has_serialize(obj)) { //     constexpr   'if'. return obj.serialize(); //    ,    ,  obj  int. } else { return std::to_string(obj);branch } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6de/ae3/4d8/6deae34d807b14eb8ac178647abce09d.png"></div><br>  Obviamente, essa é uma grande melhoria em <strong>relação ao truque da SFINAE</strong> que tínhamos que aplicar antes.  Depois disso, começamos a ter o mesmo vício de Ben e Jason - começamos a usar <strong>constexpr em</strong> todos os lugares e sempre.  Infelizmente, há outro local onde a palavra-chave <strong>constexpr</strong> se ajustaria, mas ainda não foi usada: <strong>parâmetros constexpr</strong> . <br><br><h4>  Parâmetros Constexpr: </h4><br>  Se você for cuidadoso, poderá observar um padrão estranho no exemplo de código anterior.  Eu estou falando sobre entradas de loop: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// loop_inputs.hpp constexpr auto get_game_state_string = []() constexpr // ? { auto game_state_string = constexpr_string( //       #include "current_state.txt" ); return game_state_string; };</span></span></code> </pre> <br>  Por que a variável <strong>game_state_string está</strong> encapsulada em um lambda constexpr?  Por que ela não a torna uma <strong>variável global constexpr</strong> ? <br><br>  Eu queria passar essa variável e seu conteúdo para algumas funções.  Por exemplo, <strong>você</strong> precisa passá-lo para meu <strong>parse_board</strong> e usá-lo em algumas expressões constantes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_board_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* game_state_string)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_board</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* game_state_string)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;GemType, parse_board_size(game_state_string)&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ^ 'game_state_string' -   - // ... } parse_board(“...something...”);</span></span></code> </pre> <br>  Se <strong>seguirmos</strong> esse caminho, o compilador ranzinza reclamará que o parâmetro <strong>game_state_string</strong> não <strong>é</strong> uma expressão constante.  Ao criar minha matriz de blocos, preciso calcular diretamente sua capacidade fixa (não podemos usar vetores em tempo de compilação porque eles exigem alocação de memória) e passá-la como argumento para o modelo de valor em <strong>std :: array</strong> .  Portanto, a <strong>expressão parse_board_size (game_state_string)</strong> deve ser uma expressão constante.  Embora <strong>parse_board_size esteja</strong> explicitamente marcado como <strong>constexpr</strong> , <strong>game_state_string</strong> não é e não pode ser!  Nesse caso, duas regras interferem conosco: <br><br><ul><li>  Argumentos de uma função constexpr não são constexpr! </li><li>  E não podemos adicionar constexpr na frente deles! </li></ul><br>  Tudo isso se resume ao fato de que <strong>as funções constexpr</strong> DEVEM ser aplicáveis ​​ao cálculo do tempo de execução e do tempo de compilação.  Assumindo a existência de <strong>parâmetros constexpr</strong> , isso não permitirá que eles sejam usados ​​em tempo de execução. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/9a7/1be/02f9a71be0409a96415fd5b4a542e70d.jpg"></div><br>  Felizmente, existe uma maneira de nivelar esse problema.  Em vez de aceitar o valor como parâmetro regular de uma função, podemos encapsular esse valor em um tipo e passar esse tipo como parâmetro de modelo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameStringType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse_board</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameStringType</span></span></span><span class="hljs-class">&amp;&amp;) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;CellType, parse_board_size(GameStringType::value())&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ... } struct GameString { static constexpr auto value() { return "...something..."; } }; parse_board(GameString{});</span></span></code> </pre> <br>  Neste exemplo de código, estou criando um tipo estrutural de <strong>GameString</strong> que possui uma função de membro estática constexpr <strong>value ()</strong> que retorna a literal de cadeia de caracteres que eu quero passar para <strong>parse_board</strong> .  Em <strong>parse_board,</strong> eu recebo esse tipo através do <strong>parâmetro do</strong> modelo <strong>GameStringType</strong> , usando as regras para extrair argumentos do modelo.  Tendo um <strong>GameStringType</strong> , devido ao fato de que <strong>value ()</strong> é constexpr, posso simplesmente chamar a função de membro estático <strong>value ()</strong> no momento certo para obter uma literal de string mesmo em locais onde são necessárias expressões constantes. <br><br>  Conseguimos encapsular o literal para, de alguma forma, passá-lo para <strong>parse_board</strong> usando constexpr.  No entanto, é muito chato precisar definir um novo tipo toda vez que você precisar enviar um novo literal <strong>parse_board</strong> : "... alguma <strong>coisa1</strong> ...", "... alguma <strong>coisa2</strong> ...".  Para resolver esse problema no <strong>C ++ 11</strong> , você pode aplicar alguns endereços macro e indiretos feios usando união anônima e lambda.  Michael Park explicou bem esse tópico em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma de suas postagens</a> . <br><br>  No <strong>C ++ 17, a</strong> situação é ainda melhor.  Se listarmos os requisitos para passar nossa literal de string, obtemos o seguinte: <br><br><ul><li>  Função gerada </li><li>  Isso é constexpr </li><li>  Com um nome exclusivo ou anônimo </li></ul><br>  Esses requisitos devem fornecer uma dica.  O que precisamos é <strong>constexpr lambda</strong> !  E no <strong>C ++ 17, eles</strong> adicionaram completamente a capacidade de usar a <strong>palavra</strong> - <strong>chave constexpr</strong> para funções lambda.  Podemos reescrever nosso código de exemplo da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse_board</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaType</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_game_state_string</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;CellType, parse_board_size(get_game_state_string())&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ^      constexpr-. } parse_board([]() constexpr -&gt; { return “...something...”; }); // ^    constexpr.</span></span></code> </pre> <br>  Acredite, isso já parece muito mais conveniente do que o hacking anterior no <strong>C ++ 11</strong> usando macros.  Descobri esse truque incrível graças a <strong>Bjorn Fahler</strong> , membro do grupo de mitap do C ++ em que participo.  Leia mais sobre esse truque em seu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">blog</a> .  Também vale a pena considerar que, de fato, a palavra-chave <strong>constexpr</strong> é opcional neste caso: todas as <strong>lambdas</strong> com a capacidade de se tornar <strong>constexpr</strong> serão por padrão.  A adição explícita de <strong>constexpr</strong> é uma assinatura que simplifica nossa solução de problemas. <br><br>  Agora você deve entender por que fui forçado a usar um <strong>constexpr</strong> lambda para transmitir uma string que representa o estado do jogo.  Veja esta função lambda e você terá outra pergunta.  O que é esse tipo <strong>constexpr_string</strong> que eu também uso para quebrar o literal do estoque? <br><br><h5>  constexpr_string e constexpr_string_view: </h5><br>  Ao trabalhar com strings, você não deve processá-las no estilo C. Você precisa esquecer todos esses algoritmos irritantes que executam iterações brutas e verificam se a conclusão é zero!  A alternativa oferecida pelo <strong>C ++</strong> é o onipotente <strong>std :: string</strong> e os <strong>algoritmos STL</strong> .  Infelizmente, <strong>std :: string</strong> pode exigir alocação de memória no heap (mesmo com a Small String Optimization) para armazenar seu conteúdo.  Um ou dois padrões anteriores, poderíamos usar <strong>constexpr new / delete</strong> ou passar os <strong>alocadores constexpr</strong> para <strong>std :: string</strong> , mas agora precisamos encontrar outra solução. <br><br>  Minha abordagem foi escrever uma classe <strong>constexpr_string</strong> com uma capacidade fixa.  Essa capacidade é passada como um parâmetro para o modelo de valor.  Aqui está uma breve visão geral da minha turma: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">// N -    . class constexpr_string { private: std::array&lt;char, N&gt; data_; //  N char   -. std::size_t size_; //   . public: constexpr constexpr_string(const char(&amp;a)[N]): data_{}, size_(N -1) { //   data_ } // ... constexpr iterator begin() { return data_; } //    . constexpr iterator end() { return data_ + size_; } //     . // ... };</span></span></code> </pre> <br>  Minha classe <a href="">constexpr_string</a> procura imitar a interface <strong>std :: string o</strong> mais próximo possível (para as operações que preciso): podemos solicitar <strong>iteradores do início e do fim</strong> , obter o <strong>tamanho (tamanho)</strong> , acessar os <strong>dados (dados)</strong> , <strong>excluir (apagar)</strong> parte deles, obter substring usando <strong>substr</strong> e assim por diante.  Isso facilita a conversão de um pedaço de código de <strong>std :: string</strong> para <strong>constexpr_string</strong> .  Você pode se perguntar o que acontece quando precisamos usar operações que geralmente exigem destaque em <strong>std :: string</strong> .  Nesses casos, fui forçado a convertê-los em <strong>operações imutáveis</strong> que criam uma nova instância de <strong>constexpr_string</strong> . <br><br>  Vamos dar uma olhada na operação de <strong>acréscimo</strong> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">// N -    . class constexpr_string { // ... template &lt;std::size_t M&gt; // M -    . constexpr auto append(const constexpr_string&lt;M&gt;&amp; other) { constexpr_string&lt;N + M&gt; output(*this, size() + other.size()); // ^    . ^     output. for (std::size_t i = 0; i &lt; other.size(); ++i) { output[size() + i] = other[i]; ^     output. } return output; } // ... };</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/481/745/1d0/4817451d03f8a4214afad8896e71b2b3.jpg"></div><br>  Você não precisa ter um prêmio Fields para assumir que, se tivermos uma sequência de tamanho <strong>N</strong> e uma sequência de tamanho <strong>M</strong> , uma sequência de tamanho <strong>N + M</strong> será suficiente para armazenar sua concatenação.  Podemos desperdiçar parte do "repositório em tempo de compilação", pois as duas linhas podem não usar toda a capacidade, mas esse é um preço bastante pequeno por conveniência.  Obviamente, também escrevi uma duplicata do <strong>std :: string_view</strong> , que chamava <a href="">constexpr_string_view</a> . <br><br>  Com essas duas classes, eu estava pronto para escrever um código elegante para analisar meu <strong>estado de jogo</strong> .  Pense em algo como isto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> game_state = constexpr_string(“...something...”); <span class="hljs-comment"><span class="hljs-comment">//          : constexpr auto blue_gem = find_if(game_state.begin(), game_state.end(), [](char c) constexpr -&gt; { return c == 'B'; } );</span></span></code> </pre> <br>  Era muito fácil percorrer as joias no campo de jogo - a propósito, você notou outro recurso precioso do <strong>C ++ 17</strong> neste exemplo de código? <br><br>  Sim  Não tive que especificar explicitamente a capacidade de <strong>constexpr_string</strong> ao construí-lo.  Anteriormente, ao usar um <strong>modelo de classe</strong> , tínhamos que indicar explicitamente seus argumentos.  Para evitar essas dores, criamos funções <em>make_xxx</em> porque os parâmetros <strong>dos modelos de função</strong> podem ser rastreados.  Veja como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">acompanhar os argumentos do modelo de classe</a> muda nossas vidas para melhor: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr_string</span></span></span><span class="hljs-class"> {</span></span> constexpr_string(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>(&amp;a)[N]) {} <span class="hljs-comment"><span class="hljs-comment">// .. }; // ****  C++17 **** template &lt;int N&gt; constexpr_string&lt;N&gt; make_constexpr_string(const char(&amp;a)[N]) { //      N ^   return constexpr_string&lt;N&gt;(a); // ^    . } auto test2 = make_constexpr_string("blablabla"); // ^      . constexpr_string&lt;7&gt; test("blabla"); // ^      ,    . // ****  C++17 **** constexpr_string test("blabla"); // ^    ,  .</span></span></code> </pre> <br>  Em algumas situações difíceis, você precisará ajudar o compilador a calcular corretamente os argumentos.  Se você encontrar esse problema, estude os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">manuais para cálculos de argumentos definidos pelo usuário</a> . <br><br><h4>  Comida grátis da STL: </h4><br>  Bem, sempre podemos reescrever tudo por conta própria.  Mas talvez os membros do comitê tenham generosamente preparado algo para nós na biblioteca padrão? <br><br><h5>  Novos tipos de auxiliar: </h5><br>  No <strong>C ++ 17</strong> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">std :: variant</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">std :: optional são</a> adicionados aos tipos de dicionário padrão, com base no <strong>constexpr</strong> .  O primeiro é muito interessante porque nos permite expressar associações de tipo seguro, mas a implementação na <strong>biblioteca libstdc ++</strong> com o <strong>GCC 7.2</strong> tem problemas ao usar expressões constantes.  Portanto, abandonei a ideia de adicionar <strong>std :: variant</strong> ao meu código e use apenas <strong>std :: optional</strong> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com o tipo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T, o</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tipo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: optional</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nos permite criar um novo tipo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: optional &lt;T&gt;</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que pode conter um valor do tipo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou nada. Isso é bastante semelhante aos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipos significativos que permitem valor indefinido</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C #</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Vejamos a função </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_in_board</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que retorna a posição do primeiro elemento em um campo que confirma que o predicado está correto. Pode não haver esse elemento no campo. Para lidar com essa situação, o tipo de posição deve ser opcional:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Predicate</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; find_in_board(GameBoard&amp;&amp; g, Predicate&amp;&amp; p) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> item : g.items()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p(item)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {item.x, item.y}; } <span class="hljs-comment"><span class="hljs-comment">//   ,     . } return std::nullopt; //      . } auto item = find_in_board(g, [](const auto&amp; item) { return true; }); if (item) { // ,   optional. do_something(*item); //    optional, ""   *. /* ... */ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente, tínhamos que recorrer à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semântica dos ponteiros</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ou adicionar um "estado vazio" diretamente ao tipo de posição, ou retornar um booleano e pegar o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parâmetro de saída</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . É certo que isso foi bastante estranho! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alguns tipos pré-existentes também receberam suporte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tupla</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Não explicarei em detalhes seu uso, porque muito já foi escrito sobre eles, mas compartilharei uma de minhas decepções. O comitê adicionou </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">açúcar sintático</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ao </font><font style="vertical-align: inherit;">padrão </font><font style="vertical-align: inherit;">para extrair os valores contidos em uma </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tupla</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esse novo tipo de declaração chamado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ligação estruturada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, usa parênteses para especificar em quais variáveis ​​armazenar a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tupla</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dividido </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">1337</span></span>}; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [x, y] = foo(); <span class="hljs-comment"><span class="hljs-comment">// x = 42, y = 1337.</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muito esperto! </font><font style="vertical-align: inherit;">Mas é uma pena que os membros do comitê [não pudessem, não quisessem, não encontrassem tempo, se esquecessem] de torná-los amigáveis ​​para se </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expressar</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Eu esperaria algo assim:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [x, y] = foo(); <span class="hljs-comment"><span class="hljs-comment">// OR auto [x, y] constexpr = foo();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora temos contêineres complexos e tipos auxiliares, mas como os manipulamos convenientemente? </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritmos: </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atualizar um contêiner para processar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é uma tarefa bastante monótona. </font><font style="vertical-align: inherit;">Comparado a isso, portar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que </font><strong><font style="vertical-align: inherit;">não </font></strong><strong><font style="vertical-align: inherit;">modificam</font></strong><font style="vertical-align: inherit;"> parece bastante simples. </font><font style="vertical-align: inherit;">Mas é bastante estranho que no </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não vimos progresso nessa área, ele aparecerá apenas no </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 20</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por exemplo, os maravilhosos algoritmos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: find</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não receberam assinaturas </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas não tenha medo! </font><font style="vertical-align: inherit;">Como Ben e Jason explicaram, você pode facilmente transformar o algoritmo em </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simplesmente copiando a implementação atual (mas não se esqueça dos direitos autorais); </font><font style="vertical-align: inherit;">cppreference é bom. </font><font style="vertical-align: inherit;">Senhoras e senhores, apresento a sua atenção</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr std :: find</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">find</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">) // ^ !!!    </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class">. {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; first != last; ++first) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*first == value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> last; } <span class="hljs-comment"><span class="hljs-comment">//  http://en.cppreference.com/w/cpp/algorithm/find</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Já posso ouvir dos estandes os gritos dos fãs de otimização! </font><font style="vertical-align: inherit;">Sim, apenas adicionar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na frente do código de amostra gentilmente fornecido pelo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cppreference</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode não nos dar a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">velocidade</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ideal </font><strong><font style="vertical-align: inherit;">em tempo de execução</font></strong><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mas se precisarmos melhorar esse algoritmo, será necessário obter </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">velocidade no tempo de compilação</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tanto quanto eu sei, quando se trata de velocidade de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compilação</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , soluções simples são as melhores.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Velocidade e bugs: </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Os desenvolvedores de qualquer jogo AAA devem investir na solução desses problemas, certo? </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Velocidade: </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando consegui criar uma versão semi-funcional do </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o trabalho foi mais suave. Na verdade, consegui obter um pouco mais de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 FPS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (quadros por segundo) no meu laptop antigo com o i5 com overclock para 1,80 GHz (a frequência é importante neste caso). Como em qualquer projeto, percebi rapidamente que o código escrito anteriormente era nojento e comecei a reescrever a análise do estado do jogo usando </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr_string</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e algoritmos padrão. Embora isso tenha tornado o código muito mais conveniente de manter, as alterações afetaram seriamente a velocidade; o novo teto é de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5 FPS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apesar do velho ditado sobre C ++, "abstrações sem cabeçalho" não são aplicáveis ​​a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cálculos em tempo de compilação</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso é bastante lógico se considerarmos o compilador como um intérprete de algum "código de tempo de compilação". </font><font style="vertical-align: inherit;">Melhorias para vários compiladores ainda são possíveis, mas também existem oportunidades de crescimento para nós, os autores desse código. </font><font style="vertical-align: inherit;">Aqui está uma lista incompleta de observações e dicas que encontrei, possivelmente específicas do GCC:</font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matrizes C</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funcionam muito melhor do que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O std :: array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é um pouco de cosméticos C ++ modernos em cima </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de um array no estilo C</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e você precisa pagar um preço por usá-lo nessas condições.</font></font></li><li>  ,  <strong> </strong>   (   )     <strong>  </strong> .  ,   ,          ,    .    :  ,         ,     ,    ,   (  )      ,        . </li><li>      ,      .        ,        . </li><li>         .            GCC.  ,     «». </li></ul><br><h4> : </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78c/000/4e9/78c0004e91d753a658fa8190626c3be9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muitas vezes, meu compilador gerou terríveis erros de compilação e minha lógica de código sofreu. Mas como encontrar o lugar onde o bug está escondido? Sem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depurador</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf, as</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coisas ficam mais complicadas. Se sua "barba metafórica do programador" ainda não se ajoelhou (tanto a barba metafórica quanto a barba real ainda estão longe dessas expectativas), então talvez você não tenha motivação para usar a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">luz direta</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou depurar o compilador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nosso primeiro amigo será </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_assert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o que nos dá a oportunidade de verificar o valor booleano do tempo de compilação. Nosso segundo amigo será uma macro que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habilita</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e desabilita o </font><strong><font style="vertical-align: inherit;">constexpr</font></strong><font style="vertical-align: inherit;"> sempre que possível:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONSTEXPR constexpr </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      //  #define CONSTEXPR //    </span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Com essa macro, podemos fazer a lógica funcionar em tempo de execução, o que significa que podemos anexar um depurador a ela. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meta Crush Saga II - lute pela jogabilidade completamente em tempo de execução: </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não ganhará o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Game Awards</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> este ano </font><font style="vertical-align: inherit;">. Tem um grande potencial, mas a jogabilidade não é totalmente executada </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em tempo de compilação</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Isso pode incomodar os jogadores hardcore ... Não consigo me livrar do script bash, a menos que alguém adicione </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entrada do teclado</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e lógica suja na fase de compilação (e isso é loucura!). Mas acredito que um dia poderei abandonar completamente o arquivo executável do </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renderizador</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e exibir o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estado do jogo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tempo de compilação</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/661/efc/26d/661efc26dbb41f0b8800916058993a56.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O maluco com o pseudônimo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saarraz </font></font></strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estendeu o GCC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para adicionar a construção </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_print</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ao idioma </font><font style="vertical-align: inherit;">. Essa construção deve pegar várias expressões constantes ou literais de string e produzi-las no estágio de compilação. Eu ficaria feliz se uma ferramenta desse tipo fosse adicionada ao padrão ou, pelo menos, estendida </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_assert</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que ela </font><strong><font style="vertical-align: inherit;">aceite</font></strong><font style="vertical-align: inherit;"> expressões constantes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, no </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode haver uma maneira de alcançar esse resultado. Os compiladores já produzem duas coisas - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erros</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avisos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! Se, de alguma maneira, pudermos gerenciar ou alterar os </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avisos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para nossas necessidades, já receberemos uma conclusão digna. Eu tentei várias soluções, em particular</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atributo obsoleto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... words&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">useless</span></span></span><span class="hljs-class"> {</span></span> [[deprecated]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// Will trigger a warning. }; template &lt;char... words&gt; void output_as_warning() { useless&lt;words...&gt;().call(); } output_as_warning&lt;'a', 'b', 'c'&gt;(); // warning: 'void useless&lt;words&gt;::call() [with char ...words = {'a', 'b', 'c'}]' is deprecated // [-Wdeprecated-declarations]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora a saída esteja obviamente presente e possa ser analisada, infelizmente, o código não pode ser reproduzido! </font><font style="vertical-align: inherit;">Se, por pura coincidência, você for membro de uma sociedade secreta de programadores em C ++ que pode executar resultados durante a compilação, ficarei feliz em contratá-lo em minha equipe para criar a perfeita </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga II</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusões: </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acabei vendendo o meu </font><font style="vertical-align: inherit;">jogo de </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fraude</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Espero que você ache este post curioso e aprenda algo novo no processo de lê-lo. </font><font style="vertical-align: inherit;">Se você encontrar erros ou maneiras de melhorar o artigo, entre em contato comigo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quero agradecer </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à equipe do SwedenCpp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> por me </font><strong><font style="vertical-align: inherit;">permitir</font></strong><font style="vertical-align: inherit;"> conduzir meu relatório de projeto em um de seus eventos. </font><font style="vertical-align: inherit;">Além disso, quero expressar minha </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">profunda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gratidão a </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Alexander Gurdeev</font></a><font style="vertical-align: inherit;"> , que me ajudou a melhorar os aspectos significativos da </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saga Meta Crush</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414465/">https://habr.com/ru/post/pt414465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414451/index.html">"Calendário do testador" para junho. O testador deve pegar o erro, ler Caner e organizar a mudança.</a></li>
<li><a href="../pt414453/index.html">Implementar o Path Finder para agentes de IA com o NavMesh</a></li>
<li><a href="../pt414455/index.html">Algoritmo de geração de paleta de cores</a></li>
<li><a href="../pt414459/index.html">Detectores e descritores de pontos singulares FAST, BREVE, ORB</a></li>
<li><a href="../pt414463/index.html">A própria IA aprendeu a construir um cubo de Rubik</a></li>
<li><a href="../pt414467/index.html">Artigos da Conferência Minsk C ++ CoreHard Spring 2018</a></li>
<li><a href="../pt414469/index.html">Semana 22 de segurança: bloqueios inteligentes de dois segundos</a></li>
<li><a href="../pt414471/index.html">11 círculos do inferno para quem não tem experiência em um novo emprego</a></li>
<li><a href="../pt414473/index.html">Ninja DVR: Neoline G-Tech X27 revisão dupla</a></li>
<li><a href="../pt414475/index.html">“Usuários finais - estamos com você”: sobre o desenvolvimento do Android na CFT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>