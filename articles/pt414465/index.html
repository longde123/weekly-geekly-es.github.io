<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíä üë®‚Äçüè≠ üë©üèª‚Äçüíº Meta Crush Saga: jogo em tempo de compila√ß√£o ‚úåüèø ü§∑ üëáüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No processo de mudan√ßa para o t√£o esperado t√≠tulo de Lead Senior C ++ Over-Engineer , no ano passado, decidi reescrever o jogo que estou desenvolvendo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meta Crush Saga: jogo em tempo de compila√ß√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414465/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/f40/952/a5bf40952c8280e1f9c41e965600816f.gif" alt="imagem"></div><br>  No processo de mudan√ßa para o t√£o esperado t√≠tulo de <strong>Lead Senior C ++ Over-Engineer</strong> , no ano passado, decidi reescrever o jogo que estou desenvolvendo durante o hor√°rio de trabalho (Candy Crush Saga), usando a quintess√™ncia do C ++ moderno (C ++ 17).  E assim nasceu a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Meta Crush Saga</a> : um <strong>jogo que √© executado na fase de compila√ß√£o</strong> .  Fiquei muito inspirado pelo jogo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nibbler de</a> Matt Birner, que usou pura metaprograma√ß√£o em modelos para recriar a famosa Snake com o Nokia 3310. <br><br>  ‚ÄúQue tipo de <strong>jogo est√° sendo executado no est√°gio de compila√ß√£o</strong> ?‚Äù, ‚ÄúComo ele se parece?‚Äù, ‚ÄúQue funcionalidade do <strong>C ++ 17</strong> voc√™ usou neste projeto?‚Äù, ‚ÄúO que voc√™ aprendeu?‚Äù  - Perguntas semelhantes podem vir √† sua mente.  Para respond√™-las, voc√™ ter√° que ler a postagem inteira ou aguentar sua pregui√ßa interior e assistir a uma vers√£o em v√≠deo da publica√ß√£o - meu relat√≥rio do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">evento Meetup</a> em Estocolmo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XV1lXtB3sqg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Nota: para o bem da sua sa√∫de mental e porque <em>errare humanum est</em> , s√£o apresentados alguns fatos alternativos neste artigo. <br><a name="habracut"></a><br><h2>  Um jogo que roda em tempo de compila√ß√£o? </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61c/1ab/166/61c1ab166775d7f49e32620b72abb6e4.png"></div><br>  Penso que, para entender o que quero dizer com o "conceito" de um <strong>jogo executado na fase de compila√ß√£o</strong> , voc√™ precisa comparar o ciclo de vida de um jogo com o ciclo de vida de um jogo comum. <br><br><h3>  O ciclo de vida de um jogo regular: </h3><br>  Como um desenvolvedor regular de jogos com uma vida normal, trabalhando em um trabalho regular com um n√≠vel normal de sa√∫de mental, voc√™ geralmente come√ßa escrevendo a <strong>l√≥gica do jogo</strong> no seu idioma favorito (em C ++, √© claro!) E depois executa o <strong>compilador</strong> para convert√™-lo, muitas vezes como espaguete l√≥gica em um <strong>arquivo execut√°vel</strong> .  Ap√≥s clicar duas vezes no <strong>arquivo execut√°vel</strong> (ou iniciar no console), o sistema operacional gera um <strong>processo</strong> .  Esse <strong>processo</strong> executar√° a <strong>l√≥gica</strong> do <strong>jogo</strong> , que consiste em um <strong>ciclo de jogo</strong> em 99,42% do tempo.  <strong>O ciclo do jogo</strong> <strong>atualiza o</strong> estado do jogo de acordo com certas regras e informa√ß√µes do <strong>usu√°rio</strong> , <strong>renderiza o</strong> novo estado calculado do jogo em pixels, novamente, novamente e novamente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/e6c/3b2/7bce6c3b238299f98b6c16e339aa5b10.png"></div><br><h3>  O ciclo de vida de um jogo em execu√ß√£o durante o processo de compila√ß√£o: </h3><br>  Como um engenheiro em excesso que cria seu novo jogo legal de compila√ß√£o, voc√™ ainda usa sua linguagem favorita (ainda em C ++, √© claro!) Para escrever a <strong>l√≥gica do jogo</strong> .  Ent√£o, como antes, <strong>a fase de compila√ß√£o</strong> continua, mas h√° uma reviravolta na trama: voc√™ <strong>executa</strong> a <strong>l√≥gica do jogo</strong> na fase de compila√ß√£o.  Voc√™ pode cham√°-lo de "execu√ß√£o" (compila√ß√£o).  E aqui C ++ √© muito √∫til;  possui recursos como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teta</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">(Template Meta Programming)</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">constexpr</a> que permitem realizar <strong>c√°lculos</strong> na <strong>fase de compila√ß√£o</strong> .  Mais tarde, consideraremos a funcionalidade que pode ser usada para isso.  Como nesta fase executamos a <strong>l√≥gica do</strong> jogo, nesse momento tamb√©m precisamos inserir a <strong>entrada do jogador</strong> .  Obviamente, nosso compilador ainda criar√° um <strong>arquivo execut√°vel</strong> na sa√≠da.  Para que ele pode ser usado?  O arquivo execut√°vel n√£o conter√° mais <strong>o loop do jogo</strong> , mas possui uma miss√£o muito simples: exibir um novo <strong>estado calculado</strong> .  Vamos chamar esse <strong>arquivo execut√°vel de</strong> <strong>renderizador</strong> e <strong>os dados</strong> <strong>renderizados</strong> s√£o <strong>renderizados</strong> .  Em nossa <strong>renderiza√ß√£o,</strong> nem belos efeitos de part√≠culas nem sombras de oclus√£o ambiental ser√£o contidas, ser√° ASCII.  A <strong>renderiza√ß√£o</strong> ASCII <strong>do</strong> novo <strong>estado</strong> calculado √© uma propriedade conveniente que pode ser facilmente demonstrada ao player, mas, al√©m disso, a copiamos para um arquivo de texto.  Por que um arquivo de texto?  Obviamente, porque ele pode de alguma forma ser combinado com o <strong>c√≥digo</strong> e executar novamente todas as etapas anteriores, obtendo assim um <strong>loop</strong> . <br><br>  Como voc√™ j√° pode entender, o jogo <strong>executado durante o processo de compila√ß√£o</strong> consiste em um <strong>ciclo de jogo</strong> no qual cada <strong>quadro do</strong> jogo √© um <strong>est√°gio de compila√ß√£o</strong> .  Cada <strong>est√°gio da compila√ß√£o</strong> calcula um novo <strong>estado do</strong> jogo, que pode ser mostrado ao jogador e inserido no pr√≥ximo <strong>quadro</strong> / <strong>est√°gio da compila√ß√£o</strong> . <br><br>  Voc√™ pode contemplar esse diagrama magn√≠fico o quanto quiser at√© entender o que acabei de escrever: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/2b8/d88/95c2b8d88aa04173139e82f9b4410cd9.png"></div><br>  Antes de entrarmos nos detalhes da implementa√ß√£o desse ciclo, tenho certeza de que deseja me fazer a √∫nica pergunta ... <br><br><h3>  "Por que se preocupar em fazer isso?" </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/695/1db/ec8/6951dbec8feeb002a132f801ea6866ed.png"></div><br>  Voc√™ realmente acha que arruinar meu id√≠lio de metaprograma√ß√£o em C ++ √© uma quest√£o t√£o fundamental?  Sim, por nada na vida! <br><br><ul><li>  A primeira e mais importante √© <strong>que o jogo executado na fase de compila√ß√£o</strong> ter√° uma incr√≠vel velocidade de tempo de execu√ß√£o, porque a maior parte dos c√°lculos √© realizada na <strong>fase de compila√ß√£o</strong> .  A velocidade do tempo de execu√ß√£o √© a chave para o sucesso do nosso jogo AAA com gr√°ficos ASCII! </li><li>  Voc√™ reduz a probabilidade de aparecer algum crust√°ceo em seu reposit√≥rio e solicita que voc√™ reescreva o jogo no <strong>Rust</strong> .  Seu discurso bem preparado desmoronar√° assim que voc√™ lhe explicar que um ponteiro inv√°lido n√£o pode existir no momento da compila√ß√£o.  <strong>Os</strong> programadores autoconfiantes de <strong>Haskell</strong> podem at√© confirmar a <strong>seguran√ßa do tipo</strong> no seu c√≥digo. </li><li>  Voc√™ ganhar√° o respeito do reino moderno do <strong>Javascript</strong> , no qual qualquer estrutura reprojetada com uma forte s√≠ndrome do NIH pode governar, desde que tenha um nome interessante. </li><li>  Um amigo meu costumava dizer que qualquer linha de c√≥digo Perl pode ser usada de fato como uma senha muito forte.  Estou certo de que ele nunca tentou gerar senhas no <strong>tempo de compila√ß√£o</strong> do <strong>C ++</strong> . </li></ul><br>  Como  Voc√™ est√° satisfeito com minhas respostas?  Ent√£o talvez sua pergunta deva ser: "Como voc√™ consegue fazer isso?" <br><br>  Na verdade, eu realmente queria experimentar a funcionalidade adicionada no <strong>C ++ 17</strong> .  Alguns recursos visam aumentar a efic√°cia da linguagem, bem como a metaprograma√ß√£o (principalmente constexpr).  Eu pensei que, em vez de escrever pequenos exemplos de c√≥digo, seria muito mais interessante transformar tudo isso em um jogo.  Projetos de animais de estima√ß√£o s√£o uma √≥tima maneira de aprender conceitos que voc√™ n√£o precisa usar frequentemente em seu trabalho.  A capacidade de executar l√≥gica de jogo b√°sica em tempo de compila√ß√£o novamente prova que modelos e constepxr s√£o subconjuntos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">completos de Turing</a> da linguagem C ++. <br><br><h2>  Revis√£o do jogo Meta Crush Saga </h2><br><h3>  Jogo de combina√ß√£o 3: </h3><br>  <strong>Meta Crush Saga</strong> √© um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jogo</a> de <strong>combina√ß√£o</strong> de <strong>pe√ßas</strong> semelhante ao <strong>Bejeweled</strong> e <strong>Candy Crush Saga</strong> .  O n√∫cleo das regras do jogo √© conectar tr√™s pe√ßas com o mesmo padr√£o para obter pontos.  Aqui est√° uma r√°pida olhada no <strong>estado do jogo</strong> que eu "despejei" (despejar no ASCII √© muito f√°cil de obter): <br><br><pre>  R "(
     Meta crush saga      
 ------------------------  
 |  | 
 |  RBGBBYGR 
 |  | 
 |  | 
 |  YYGRBGBR 
 |  | 
 |  | 
 |  RBYRGRYG 
 |  | 
 |  | 
 |  RYBY (R) YGY 
 |  | 
 |  | 
 |  BGYRYGGR 
 |  | 
 |  | 
 |  RYBGYBBG 
 |  | 
 ------------------------  
 &gt; pontua√ß√£o: 9009
 &gt; movimentos: 27
 ) " </pre><br><br>  A jogabilidade deste jogo Match-3 em si n√£o √© particularmente interessante, mas e a arquitetura na qual tudo funciona?  Para que voc√™ entenda, tentarei explicar todas as partes do ciclo de vida desse jogo em <strong>tempo de compila√ß√£o</strong> em termos de c√≥digo. <br><br><h3>  Inje√ß√£o do estado do jogo: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/20f/ffa/94220fffabe5eca432d47b90491fe7e7.png"></div><br>  Se voc√™ √© um apaixonado ou pedante apaixonado por C ++, pode ter notado que o despejo de estado do jogo anterior come√ßa com o seguinte padr√£o: <strong>R "(</strong> . Na verdade, esse √© um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">literal de cadeia de caracteres C ++ 11 bruto</a> , o que significa que n√£o preciso escapar de caracteres especiais, por exemplo, <strong>tradu√ß√£o strings</strong> : o literal da string bruta √© armazenado em um arquivo chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">current_state.txt</a> . <br><br>  Como injetamos esse estado atual do jogo em um estado de compila√ß√£o?  Vamos adicion√°-lo √†s entradas de loop! <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// loop_inputs.hpp constexpr KeyboardInput keyboard_input = KeyboardInput::KEYBOARD_INPUT; //       constexpr auto get_game_state_string = []() constexpr { auto game_state_string = constexpr_string( //       #include "current_state.txt" ); return game_state_string; };</span></span></code> </pre> <br>  Seja um arquivo <em>.txt</em> ou um arquivo <em>.h</em> , a diretiva de <strong>inclus√£o</strong> do pr√©-processador C funcionar√° da mesma maneira: copia o conte√∫do do arquivo para seu local.  Aqui eu copio a string bruta literal do estado do jogo em ASCII para uma vari√°vel chamada <strong>game_state_string</strong> . <br><br>  Observe que o <a href="">arquivo de</a> cabe√ßalho <a href="">loop_inputs.hpp</a> tamb√©m expande a entrada do teclado para a etapa atual do quadro / compila√ß√£o.  Ao contr√°rio do estado do jogo, o estado do teclado √© bastante pequeno e pode ser facilmente obtido como uma defini√ß√£o de pr√©-processador. <br><br><h3>  Computando um novo estado em tempo de compila√ß√£o: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1a/adb/e44/b1aadbe44035019fdc8bdb89a02b31b1.png"></div><br>  Agora que coletamos dados suficientes, podemos calcular o novo estado.  Finalmente, chegamos ao ponto em que precisamos escrever o arquivo <a href="">main.cpp</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// main.cpp #include "loop_inputs.hpp" //   ,   . // :    . constexpr auto current_state = parse_game_state(get_game_state_string); //      . constexpr auto new_state = game_engine(current_state) //    , .update(keyboard_input); //  ,    . constexpr auto array = print_game_state(new_state); //      std::array&lt;char&gt;. // :    . //  :   . for (const char&amp; c : array) { std::cout &lt;&lt; c; }</span></span></code> </pre> <br>  Estranho, mas esse c√≥digo C ++ n√£o parece t√£o confuso, considerando o que faz.  A maior parte do c√≥digo √© executada na fase de compila√ß√£o, no entanto, segue os paradigmas tradicionais de programa√ß√£o processual e POO.  Somente a √∫ltima linha - renderiza√ß√£o - √© um obst√°culo para realizar c√°lculos completos em tempo de compila√ß√£o.  Como veremos abaixo, lan√ßando um pouco de consexpr nos lugares certos, podemos obter uma metaprograma√ß√£o bastante elegante no C ++ 17.  Acho deliciosa a liberdade que o C ++ nos d√° quando se trata de execu√ß√£o mista em tempo de execu√ß√£o e compila√ß√£o. <br><br>  Voc√™ tamb√©m notar√° que esse c√≥digo executa apenas um quadro, n√£o h√° <strong>loop de jogo</strong> .  Vamos resolver esse problema! <br><br><h3>  Colamos tudo juntos: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d0/c65/870/8d0c65870264bfff26fde91c230bb8db.png"></div><br>  Se voc√™ repugna meus truques com <strong>C ++</strong> , espero que n√£o se importe em ver minhas habilidades em <strong>Bash</strong> .  De fato, meu <strong>loop de jogo</strong> nada mais √© do que um <a href="">script bash</a> que √© compilado constantemente. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  !  ,    !!! while; do : #      G++ g++ -o renderer main.cpp -DKEYBOARD_INPUT="$keypressed" keypressed=get_key_pressed() #  . clear #   current_state=$(./renderer) echo $current_state #    #     current_state.txt file       . echo "R\"(" &gt; current_state.txt echo $current_state &gt;&gt; current_state.txt echo ")\"" &gt;&gt; current_state.txt done</span></span></code> </pre> <br>  Na verdade, eu estava tendo um pouco de dificuldade em obter a entrada do teclado no console.  Inicialmente, eu queria entrar em paralelo com a compila√ß√£o.  Depois de muitas tentativas e erros, consegui trabalhar mais ou menos com o comando <code>read</code> do <strong>Bash</strong> .  Eu nunca ouso lutar contra o bruxo <strong>Bash</strong> em um duelo - essa linguagem √© muito sinistra! <br><br>  Portanto, devo admitir que, para gerenciar o ciclo do jogo, tive que recorrer a outro idioma.  Embora tecnicamente nada me impedisse de escrever esta parte do c√≥digo em C ++.  Al√©m disso, isso n√£o nega o fato de que 90% da l√≥gica do meu jogo √© executada dentro da equipe de compila√ß√£o do <strong>g ++</strong> , o que √© incr√≠vel! <br><br><h3>  Um pouco de jogabilidade para descansar os olhos: </h3><br>  Agora que voc√™ experimentou o tormento de explicar a arquitetura do jogo, chegou a hora de pinturas atraentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/f40/952/a5bf40952c8280e1f9c41e965600816f.gif"></div><br>  Este gif pixelizado √© um registro de como eu jogo <strong>Meta Crush Saga</strong> .  Como voc√™ pode ver, o jogo funciona sem problemas o suficiente para ser jogado em tempo real.  Obviamente, ela n√£o √© t√£o atraente que eu possa transmitir seu Twitch e me tornar a nova Pewdiepie, mas ela funciona! <br><br>  Um dos aspectos divertidos de armazenar o <strong>estado de um jogo</strong> em um arquivo <em>.txt</em> √© a capacidade de enganar ou testar casos extremos de maneira muito conveniente. <br><br>  Agora que apresentei brevemente a arquitetura, vamos nos aprofundar na funcionalidade C ++ 17 usada neste projeto.  N√£o considerarei a l√≥gica do jogo em detalhes, porque se refere exclusivamente ao Match-3; em vez disso, falarei sobre aspectos do C ++ que podem ser aplicados em outros projetos. <br><br><h2>  Meus tutoriais sobre C ++ 17: </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3f/325/d96/c3f325d9618c2a89dadb2873c61a7921.png"></div><br>  Ao contr√°rio do C ++ 14, que continha principalmente pequenas corre√ß√µes, o novo padr√£o C ++ 17 pode nos oferecer muito.  Havia esperan√ßas de que finalmente os recursos esperados (m√≥dulos, corotinas, conceitos ...) finalmente aparecessem, mas ... em geral ... eles n√£o apareciam;  isso incomodou muitos de n√≥s.  Mas, depois de remover o luto, encontramos muitos pequenos tesouros inesperados que, no entanto, ca√≠ram no padr√£o. <br><br>  Ouso dizer que as crian√ßas que amam metaprograma√ß√£o s√£o muito mimadas este ano!  Agora, pequenas altera√ß√µes e adi√ß√µes separadas ao idioma permitem que voc√™ escreva um c√≥digo que funciona muito em tempo de compila√ß√£o e depois em tempo de execu√ß√£o. <br><br><h3>  Constepxr em todos os campos: </h3><br>  Como Ben Dean e Jason Turner previram em seu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rio sobre o C ++ 14</a> , o C ++ permite melhorar rapidamente a compila√ß√£o de valores em tempo de compila√ß√£o com a palavra-chave onipotente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">constexpr</a> .  Ao localizar essa palavra-chave nos lugares certos, voc√™ pode informar ao compilador que a express√£o √© constante e <strong>pode ser</strong> avaliada diretamente no momento da compila√ß√£o.  No <strong>C ++ 11,</strong> j√° poder√≠amos escrever este c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//    constexpr       . { return n &lt;= 1? 1 : (n * factorial(n - 1)); } int i = factorial(5); //  constexpr-. //      : // int i = 120;</span></span></span></span></code> </pre> <br>  Embora a palavra-chave <strong>constexpr</strong> seja muito poderosa, ela possui algumas restri√ß√µes de uso, dificultando a grava√ß√£o de c√≥digo expressivo dessa maneira. <br><br>  <strong>O C ++ 14</strong> reduziu bastante os requisitos para o <strong>constexpr</strong> e tornou-se muito mais natural de usar.  Nossa fun√ß√£o fatorial anterior pode ser reescrita da seguinte forma: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  <strong>O C ++ 14</strong> se livrou da regra de que uma <strong>fun√ß√£o constexpr</strong> deveria consistir em apenas uma declara√ß√£o de retorno, o que nos for√ßou a usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">operador tern√°rio</a> como o principal componente.  Agora, o <strong>C ++ 17</strong> traz ainda mais aplicativos de palavras-chave <strong>constexpr</strong> que podemos explorar! <br><br><h4>  Ramifica√ß√£o em tempo de compila√ß√£o: </h4><br>  Voc√™ j√° esteve em uma situa√ß√£o em que precisa ter um comportamento diferente, dependendo do par√¢metro do modelo que est√° manipulando?  Suponha que precisamos de uma fun√ß√£o parametrizada <code>serialize</code> , que chamar√° <code>.serialize()</code> se o objeto fornecer, caso contr√°rio, ele recorrer√° √† chamada <code>to_string</code> .  Como explicado em mais detalhes neste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">post sobre SFINAE</a> , provavelmente voc√™ precisar√° escrever um c√≥digo alien√≠gena: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;has_serialize_v&lt;T&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; serialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.serialize(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!has_serialize_v&lt;T&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; serialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(obj); }</code> </pre> <br>  Somente em um sonho voc√™ poderia reescrever esse <strong>truque</strong> feio do <strong>truque do SFINAE</strong> para o <strong>C ++ 14</strong> em um c√≥digo t√£o magn√≠fico: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// has_serialize -  constexpr-,  serialize  . // .    SFINAE,  ,    . template &lt;class T&gt; constexpr bool has_serialize(const T&amp; /*t*/); template &lt;class T&gt; std::string serialize(const T&amp; obj) { //  ,  constexpr    . if (has_serialize(obj)) { return obj.serialize(); } else { return std::to_string(obj); } }</span></span></code> </pre> <br>  Infelizmente, quando voc√™ acordou e come√ßou a escrever <strong>c√≥digo C ++ 14</strong> real, seu compilador emitiu uma mensagem desagrad√°vel sobre a chamada <code>serialize(42);</code>  .  Ele explicou que um <code>obj</code> tipo <code>int</code> n√£o possui uma fun√ß√£o de membro <code>serialize()</code> .  N√£o importa como isso o enfurece, o compilador est√° certo!  Com esse c√≥digo, ele sempre tentar√° compilar os dois ramos - <code>return obj.serialize();</code>  e <br> <code>return std::to_string(obj);</code>  .  Para <code>int</code> branch <code>return obj.serialize();</code>  Pode muito bem ser algum tipo de c√≥digo morto, porque <code>has_serialize(obj)</code> sempre retornar√° <code>false</code> , mas o compilador ainda precisar√° compil√°-lo. <br><br>  Como voc√™ provavelmente adivinhou, o <strong>C ++ 17</strong> nos salva de uma situa√ß√£o t√£o desagrad√°vel, porque tornou poss√≠vel adicionar <strong>constexpr</strong> ap√≥s a instru√ß√£o if para "for√ßar" a ramifica√ß√£o no tempo de compila√ß√£o e descartar constru√ß√µes n√£o utilizadas: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// has_serialize... // ... template &lt;class T&gt; std::string serialize(const T&amp; obj) if constexpr (has_serialize(obj)) { //     constexpr   'if'. return obj.serialize(); //    ,    ,  obj  int. } else { return std::to_string(obj);branch } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6de/ae3/4d8/6deae34d807b14eb8ac178647abce09d.png"></div><br>  Obviamente, essa √© uma grande melhoria em <strong>rela√ß√£o ao truque da SFINAE</strong> que t√≠nhamos que aplicar antes.  Depois disso, come√ßamos a ter o mesmo v√≠cio de Ben e Jason - come√ßamos a usar <strong>constexpr em</strong> todos os lugares e sempre.  Infelizmente, h√° outro local onde a palavra-chave <strong>constexpr</strong> se ajustaria, mas ainda n√£o foi usada: <strong>par√¢metros constexpr</strong> . <br><br><h4>  Par√¢metros Constexpr: </h4><br>  Se voc√™ for cuidadoso, poder√° observar um padr√£o estranho no exemplo de c√≥digo anterior.  Eu estou falando sobre entradas de loop: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// loop_inputs.hpp constexpr auto get_game_state_string = []() constexpr // ? { auto game_state_string = constexpr_string( //       #include "current_state.txt" ); return game_state_string; };</span></span></code> </pre> <br>  Por que a vari√°vel <strong>game_state_string est√°</strong> encapsulada em um lambda constexpr?  Por que ela n√£o a torna uma <strong>vari√°vel global constexpr</strong> ? <br><br>  Eu queria passar essa vari√°vel e seu conte√∫do para algumas fun√ß√µes.  Por exemplo, <strong>voc√™</strong> precisa pass√°-lo para meu <strong>parse_board</strong> e us√°-lo em algumas express√µes constantes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_board_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* game_state_string)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_board</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* game_state_string)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;GemType, parse_board_size(game_state_string)&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ^ 'game_state_string' -   - // ... } parse_board(‚Äú...something...‚Äù);</span></span></code> </pre> <br>  Se <strong>seguirmos</strong> esse caminho, o compilador ranzinza reclamar√° que o par√¢metro <strong>game_state_string</strong> n√£o <strong>√©</strong> uma express√£o constante.  Ao criar minha matriz de blocos, preciso calcular diretamente sua capacidade fixa (n√£o podemos usar vetores em tempo de compila√ß√£o porque eles exigem aloca√ß√£o de mem√≥ria) e pass√°-la como argumento para o modelo de valor em <strong>std :: array</strong> .  Portanto, a <strong>express√£o parse_board_size (game_state_string)</strong> deve ser uma express√£o constante.  Embora <strong>parse_board_size esteja</strong> explicitamente marcado como <strong>constexpr</strong> , <strong>game_state_string</strong> n√£o √© e n√£o pode ser!  Nesse caso, duas regras interferem conosco: <br><br><ul><li>  Argumentos de uma fun√ß√£o constexpr n√£o s√£o constexpr! </li><li>  E n√£o podemos adicionar constexpr na frente deles! </li></ul><br>  Tudo isso se resume ao fato de que <strong>as fun√ß√µes constexpr</strong> DEVEM ser aplic√°veis ‚Äã‚Äãao c√°lculo do tempo de execu√ß√£o e do tempo de compila√ß√£o.  Assumindo a exist√™ncia de <strong>par√¢metros constexpr</strong> , isso n√£o permitir√° que eles sejam usados ‚Äã‚Äãem tempo de execu√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/9a7/1be/02f9a71be0409a96415fd5b4a542e70d.jpg"></div><br>  Felizmente, existe uma maneira de nivelar esse problema.  Em vez de aceitar o valor como par√¢metro regular de uma fun√ß√£o, podemos encapsular esse valor em um tipo e passar esse tipo como par√¢metro de modelo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameStringType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse_board</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameStringType</span></span></span><span class="hljs-class">&amp;&amp;) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;CellType, parse_board_size(GameStringType::value())&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ... } struct GameString { static constexpr auto value() { return "...something..."; } }; parse_board(GameString{});</span></span></code> </pre> <br>  Neste exemplo de c√≥digo, estou criando um tipo estrutural de <strong>GameString</strong> que possui uma fun√ß√£o de membro est√°tica constexpr <strong>value ()</strong> que retorna a literal de cadeia de caracteres que eu quero passar para <strong>parse_board</strong> .  Em <strong>parse_board,</strong> eu recebo esse tipo atrav√©s do <strong>par√¢metro do</strong> modelo <strong>GameStringType</strong> , usando as regras para extrair argumentos do modelo.  Tendo um <strong>GameStringType</strong> , devido ao fato de que <strong>value ()</strong> √© constexpr, posso simplesmente chamar a fun√ß√£o de membro est√°tico <strong>value ()</strong> no momento certo para obter uma literal de string mesmo em locais onde s√£o necess√°rias express√µes constantes. <br><br>  Conseguimos encapsular o literal para, de alguma forma, pass√°-lo para <strong>parse_board</strong> usando constexpr.  No entanto, √© muito chato precisar definir um novo tipo toda vez que voc√™ precisar enviar um novo literal <strong>parse_board</strong> : "... alguma <strong>coisa1</strong> ...", "... alguma <strong>coisa2</strong> ...".  Para resolver esse problema no <strong>C ++ 11</strong> , voc√™ pode aplicar alguns endere√ßos macro e indiretos feios usando uni√£o an√¥nima e lambda.  Michael Park explicou bem esse t√≥pico em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma de suas postagens</a> . <br><br>  No <strong>C ++ 17, a</strong> situa√ß√£o √© ainda melhor.  Se listarmos os requisitos para passar nossa literal de string, obtemos o seguinte: <br><br><ul><li>  Fun√ß√£o gerada </li><li>  Isso √© constexpr </li><li>  Com um nome exclusivo ou an√¥nimo </li></ul><br>  Esses requisitos devem fornecer uma dica.  O que precisamos √© <strong>constexpr lambda</strong> !  E no <strong>C ++ 17, eles</strong> adicionaram completamente a capacidade de usar a <strong>palavra</strong> - <strong>chave constexpr</strong> para fun√ß√µes lambda.  Podemos reescrever nosso c√≥digo de exemplo da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse_board</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaType</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_game_state_string</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;CellType, parse_board_size(get_game_state_string())&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ^      constexpr-. } parse_board([]() constexpr -&gt; { return ‚Äú...something...‚Äù; }); // ^    constexpr.</span></span></code> </pre> <br>  Acredite, isso j√° parece muito mais conveniente do que o hacking anterior no <strong>C ++ 11</strong> usando macros.  Descobri esse truque incr√≠vel gra√ßas a <strong>Bjorn Fahler</strong> , membro do grupo de mitap do C ++ em que participo.  Leia mais sobre esse truque em seu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">blog</a> .  Tamb√©m vale a pena considerar que, de fato, a palavra-chave <strong>constexpr</strong> √© opcional neste caso: todas as <strong>lambdas</strong> com a capacidade de se tornar <strong>constexpr</strong> ser√£o por padr√£o.  A adi√ß√£o expl√≠cita de <strong>constexpr</strong> √© uma assinatura que simplifica nossa solu√ß√£o de problemas. <br><br>  Agora voc√™ deve entender por que fui for√ßado a usar um <strong>constexpr</strong> lambda para transmitir uma string que representa o estado do jogo.  Veja esta fun√ß√£o lambda e voc√™ ter√° outra pergunta.  O que √© esse tipo <strong>constexpr_string</strong> que eu tamb√©m uso para quebrar o literal do estoque? <br><br><h5>  constexpr_string e constexpr_string_view: </h5><br>  Ao trabalhar com strings, voc√™ n√£o deve process√°-las no estilo C. Voc√™ precisa esquecer todos esses algoritmos irritantes que executam itera√ß√µes brutas e verificam se a conclus√£o √© zero!  A alternativa oferecida pelo <strong>C ++</strong> √© o onipotente <strong>std :: string</strong> e os <strong>algoritmos STL</strong> .  Infelizmente, <strong>std :: string</strong> pode exigir aloca√ß√£o de mem√≥ria no heap (mesmo com a Small String Optimization) para armazenar seu conte√∫do.  Um ou dois padr√µes anteriores, poder√≠amos usar <strong>constexpr new / delete</strong> ou passar os <strong>alocadores constexpr</strong> para <strong>std :: string</strong> , mas agora precisamos encontrar outra solu√ß√£o. <br><br>  Minha abordagem foi escrever uma classe <strong>constexpr_string</strong> com uma capacidade fixa.  Essa capacidade √© passada como um par√¢metro para o modelo de valor.  Aqui est√° uma breve vis√£o geral da minha turma: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">// N -    . class constexpr_string { private: std::array&lt;char, N&gt; data_; //  N char   -. std::size_t size_; //   . public: constexpr constexpr_string(const char(&amp;a)[N]): data_{}, size_(N -1) { //   data_ } // ... constexpr iterator begin() { return data_; } //    . constexpr iterator end() { return data_ + size_; } //     . // ... };</span></span></code> </pre> <br>  Minha classe <a href="">constexpr_string</a> procura imitar a interface <strong>std :: string o</strong> mais pr√≥ximo poss√≠vel (para as opera√ß√µes que preciso): podemos solicitar <strong>iteradores do in√≠cio e do fim</strong> , obter o <strong>tamanho (tamanho)</strong> , acessar os <strong>dados (dados)</strong> , <strong>excluir (apagar)</strong> parte deles, obter substring usando <strong>substr</strong> e assim por diante.  Isso facilita a convers√£o de um peda√ßo de c√≥digo de <strong>std :: string</strong> para <strong>constexpr_string</strong> .  Voc√™ pode se perguntar o que acontece quando precisamos usar opera√ß√µes que geralmente exigem destaque em <strong>std :: string</strong> .  Nesses casos, fui for√ßado a convert√™-los em <strong>opera√ß√µes imut√°veis</strong> que criam uma nova inst√¢ncia de <strong>constexpr_string</strong> . <br><br>  Vamos dar uma olhada na opera√ß√£o de <strong>acr√©scimo</strong> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">// N -    . class constexpr_string { // ... template &lt;std::size_t M&gt; // M -    . constexpr auto append(const constexpr_string&lt;M&gt;&amp; other) { constexpr_string&lt;N + M&gt; output(*this, size() + other.size()); // ^    . ^     output. for (std::size_t i = 0; i &lt; other.size(); ++i) { output[size() + i] = other[i]; ^     output. } return output; } // ... };</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/481/745/1d0/4817451d03f8a4214afad8896e71b2b3.jpg"></div><br>  Voc√™ n√£o precisa ter um pr√™mio Fields para assumir que, se tivermos uma sequ√™ncia de tamanho <strong>N</strong> e uma sequ√™ncia de tamanho <strong>M</strong> , uma sequ√™ncia de tamanho <strong>N + M</strong> ser√° suficiente para armazenar sua concatena√ß√£o.  Podemos desperdi√ßar parte do "reposit√≥rio em tempo de compila√ß√£o", pois as duas linhas podem n√£o usar toda a capacidade, mas esse √© um pre√ßo bastante pequeno por conveni√™ncia.  Obviamente, tamb√©m escrevi uma duplicata do <strong>std :: string_view</strong> , que chamava <a href="">constexpr_string_view</a> . <br><br>  Com essas duas classes, eu estava pronto para escrever um c√≥digo elegante para analisar meu <strong>estado de jogo</strong> .  Pense em algo como isto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> game_state = constexpr_string(‚Äú...something...‚Äù); <span class="hljs-comment"><span class="hljs-comment">//          : constexpr auto blue_gem = find_if(game_state.begin(), game_state.end(), [](char c) constexpr -&gt; { return c == 'B'; } );</span></span></code> </pre> <br>  Era muito f√°cil percorrer as joias no campo de jogo - a prop√≥sito, voc√™ notou outro recurso precioso do <strong>C ++ 17</strong> neste exemplo de c√≥digo? <br><br>  Sim  N√£o tive que especificar explicitamente a capacidade de <strong>constexpr_string</strong> ao constru√≠-lo.  Anteriormente, ao usar um <strong>modelo de classe</strong> , t√≠nhamos que indicar explicitamente seus argumentos.  Para evitar essas dores, criamos fun√ß√µes <em>make_xxx</em> porque os par√¢metros <strong>dos modelos de fun√ß√£o</strong> podem ser rastreados.  Veja como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">acompanhar os argumentos do modelo de classe</a> muda nossas vidas para melhor: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr_string</span></span></span><span class="hljs-class"> {</span></span> constexpr_string(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>(&amp;a)[N]) {} <span class="hljs-comment"><span class="hljs-comment">// .. }; // ****  C++17 **** template &lt;int N&gt; constexpr_string&lt;N&gt; make_constexpr_string(const char(&amp;a)[N]) { //      N ^   return constexpr_string&lt;N&gt;(a); // ^    . } auto test2 = make_constexpr_string("blablabla"); // ^      . constexpr_string&lt;7&gt; test("blabla"); // ^      ,    . // ****  C++17 **** constexpr_string test("blabla"); // ^    ,  .</span></span></code> </pre> <br>  Em algumas situa√ß√µes dif√≠ceis, voc√™ precisar√° ajudar o compilador a calcular corretamente os argumentos.  Se voc√™ encontrar esse problema, estude os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">manuais para c√°lculos de argumentos definidos pelo usu√°rio</a> . <br><br><h4>  Comida gr√°tis da STL: </h4><br>  Bem, sempre podemos reescrever tudo por conta pr√≥pria.  Mas talvez os membros do comit√™ tenham generosamente preparado algo para n√≥s na biblioteca padr√£o? <br><br><h5>  Novos tipos de auxiliar: </h5><br>  No <strong>C ++ 17</strong> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">std :: variant</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">std :: optional s√£o</a> adicionados aos tipos de dicion√°rio padr√£o, com base no <strong>constexpr</strong> .  O primeiro √© muito interessante porque nos permite expressar associa√ß√µes de tipo seguro, mas a implementa√ß√£o na <strong>biblioteca libstdc ++</strong> com o <strong>GCC 7.2</strong> tem problemas ao usar express√µes constantes.  Portanto, abandonei a ideia de adicionar <strong>std :: variant</strong> ao meu c√≥digo e use apenas <strong>std :: optional</strong> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com o tipo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T, o</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tipo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: optional</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nos permite criar um novo tipo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: optional &lt;T&gt;</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que pode conter um valor do tipo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou nada. Isso √© bastante semelhante aos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipos significativos que permitem valor indefinido</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C #</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Vejamos a fun√ß√£o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_in_board</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que retorna a posi√ß√£o do primeiro elemento em um campo que confirma que o predicado est√° correto. Pode n√£o haver esse elemento no campo. Para lidar com essa situa√ß√£o, o tipo de posi√ß√£o deve ser opcional:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Predicate</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; find_in_board(GameBoard&amp;&amp; g, Predicate&amp;&amp; p) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> item : g.items()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p(item)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {item.x, item.y}; } <span class="hljs-comment"><span class="hljs-comment">//   ,     . } return std::nullopt; //      . } auto item = find_in_board(g, [](const auto&amp; item) { return true; }); if (item) { // ,   optional. do_something(*item); //    optional, ""   *. /* ... */ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente, t√≠nhamos que recorrer √† </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sem√¢ntica dos ponteiros</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ou adicionar um "estado vazio" diretamente ao tipo de posi√ß√£o, ou retornar um booleano e pegar o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√¢metro de sa√≠da</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . √â certo que isso foi bastante estranho! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alguns tipos pr√©-existentes tamb√©m receberam suporte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tupla</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . N√£o explicarei em detalhes seu uso, porque muito j√° foi escrito sobre eles, mas compartilharei uma de minhas decep√ß√µes. O comit√™ adicionou </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a√ß√∫car sint√°tico</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ao </font><font style="vertical-align: inherit;">padr√£o </font><font style="vertical-align: inherit;">para extrair os valores contidos em uma </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tupla</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esse novo tipo de declara√ß√£o chamado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">liga√ß√£o estruturada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, usa par√™nteses para especificar em quais vari√°veis ‚Äã‚Äãarmazenar a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tupla</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dividido </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">1337</span></span>}; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [x, y] = foo(); <span class="hljs-comment"><span class="hljs-comment">// x = 42, y = 1337.</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muito esperto! </font><font style="vertical-align: inherit;">Mas √© uma pena que os membros do comit√™ [n√£o pudessem, n√£o quisessem, n√£o encontrassem tempo, se esquecessem] de torn√°-los amig√°veis ‚Äã‚Äãpara se </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expressar</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Eu esperaria algo assim:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [x, y] = foo(); <span class="hljs-comment"><span class="hljs-comment">// OR auto [x, y] constexpr = foo();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora temos cont√™ineres complexos e tipos auxiliares, mas como os manipulamos convenientemente? </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritmos: </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atualizar um cont√™iner para processar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© uma tarefa bastante mon√≥tona. </font><font style="vertical-align: inherit;">Comparado a isso, portar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que </font><strong><font style="vertical-align: inherit;">n√£o </font></strong><strong><font style="vertical-align: inherit;">modificam</font></strong><font style="vertical-align: inherit;"> parece bastante simples. </font><font style="vertical-align: inherit;">Mas √© bastante estranho que no </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o vimos progresso nessa √°rea, ele aparecer√° apenas no </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 20</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por exemplo, os maravilhosos algoritmos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: find</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o receberam assinaturas </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas n√£o tenha medo! </font><font style="vertical-align: inherit;">Como Ben e Jason explicaram, voc√™ pode facilmente transformar o algoritmo em </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simplesmente copiando a implementa√ß√£o atual (mas n√£o se esque√ßa dos direitos autorais); </font><font style="vertical-align: inherit;">cppreference √© bom. </font><font style="vertical-align: inherit;">Senhoras e senhores, apresento a sua aten√ß√£o</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr std :: find</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">find</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">) // ^ !!!    </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class">. {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; first != last; ++first) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*first == value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> last; } <span class="hljs-comment"><span class="hljs-comment">//  http://en.cppreference.com/w/cpp/algorithm/find</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J√° posso ouvir dos estandes os gritos dos f√£s de otimiza√ß√£o! </font><font style="vertical-align: inherit;">Sim, apenas adicionar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na frente do c√≥digo de amostra gentilmente fornecido pelo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cppreference</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode n√£o nos dar a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">velocidade</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ideal </font><strong><font style="vertical-align: inherit;">em tempo de execu√ß√£o</font></strong><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mas se precisarmos melhorar esse algoritmo, ser√° necess√°rio obter </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">velocidade no tempo de compila√ß√£o</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tanto quanto eu sei, quando se trata de velocidade de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compila√ß√£o</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , solu√ß√µes simples s√£o as melhores.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Velocidade e bugs: </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Os desenvolvedores de qualquer jogo AAA devem investir na solu√ß√£o desses problemas, certo? </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Velocidade: </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando consegui criar uma vers√£o semi-funcional do </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o trabalho foi mais suave. Na verdade, consegui obter um pouco mais de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 FPS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (quadros por segundo) no meu laptop antigo com o i5 com overclock para 1,80 GHz (a frequ√™ncia √© importante neste caso). Como em qualquer projeto, percebi rapidamente que o c√≥digo escrito anteriormente era nojento e comecei a reescrever a an√°lise do estado do jogo usando </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr_string</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e algoritmos padr√£o. Embora isso tenha tornado o c√≥digo muito mais conveniente de manter, as altera√ß√µes afetaram seriamente a velocidade; o novo teto √© de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5 FPS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apesar do velho ditado sobre C ++, "abstra√ß√µes sem cabe√ßalho" n√£o s√£o aplic√°veis ‚Äã‚Äãa </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√°lculos em tempo de compila√ß√£o</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso √© bastante l√≥gico se considerarmos o compilador como um int√©rprete de algum "c√≥digo de tempo de compila√ß√£o". </font><font style="vertical-align: inherit;">Melhorias para v√°rios compiladores ainda s√£o poss√≠veis, mas tamb√©m existem oportunidades de crescimento para n√≥s, os autores desse c√≥digo. </font><font style="vertical-align: inherit;">Aqui est√° uma lista incompleta de observa√ß√µes e dicas que encontrei, possivelmente espec√≠ficas do GCC:</font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matrizes C</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funcionam muito melhor do que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O std :: array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© um pouco de cosm√©ticos C ++ modernos em cima </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de um array no estilo C</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e voc√™ precisa pagar um pre√ßo por us√°-lo nessas condi√ß√µes.</font></font></li><li>  ,  <strong> </strong>   (   )     <strong>  </strong> .  ,   ,          ,    .    :  ,         ,     ,    ,   (  )      ,        . </li><li>      ,      .        ,        . </li><li>         .            GCC.  ,     ¬´¬ª. </li></ul><br><h4> : </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78c/000/4e9/78c0004e91d753a658fa8190626c3be9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muitas vezes, meu compilador gerou terr√≠veis erros de compila√ß√£o e minha l√≥gica de c√≥digo sofreu. Mas como encontrar o lugar onde o bug est√° escondido? Sem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depurador</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf, as</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coisas ficam mais complicadas. Se sua "barba metaf√≥rica do programador" ainda n√£o se ajoelhou (tanto a barba metaf√≥rica quanto a barba real ainda est√£o longe dessas expectativas), ent√£o talvez voc√™ n√£o tenha motiva√ß√£o para usar a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">luz direta</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou depurar o compilador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nosso primeiro amigo ser√° </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_assert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o que nos d√° a oportunidade de verificar o valor booleano do tempo de compila√ß√£o. Nosso segundo amigo ser√° uma macro que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habilita</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e desabilita o </font><strong><font style="vertical-align: inherit;">constexpr</font></strong><font style="vertical-align: inherit;"> sempre que poss√≠vel:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONSTEXPR constexpr </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      //  #define CONSTEXPR //    </span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Com essa macro, podemos fazer a l√≥gica funcionar em tempo de execu√ß√£o, o que significa que podemos anexar um depurador a ela. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meta Crush Saga II - lute pela jogabilidade completamente em tempo de execu√ß√£o: </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o ganhar√° o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Game Awards</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> este ano </font><font style="vertical-align: inherit;">. Tem um grande potencial, mas a jogabilidade n√£o √© totalmente executada </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em tempo de compila√ß√£o</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Isso pode incomodar os jogadores hardcore ... N√£o consigo me livrar do script bash, a menos que algu√©m adicione </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entrada do teclado</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e l√≥gica suja na fase de compila√ß√£o (e isso √© loucura!). Mas acredito que um dia poderei abandonar completamente o arquivo execut√°vel do </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renderizador</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e exibir o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estado do jogo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tempo de compila√ß√£o</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/661/efc/26d/661efc26dbb41f0b8800916058993a56.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O maluco com o pseud√¥nimo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saarraz </font></font></strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estendeu o GCC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para adicionar a constru√ß√£o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_print</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ao idioma </font><font style="vertical-align: inherit;">. Essa constru√ß√£o deve pegar v√°rias express√µes constantes ou literais de string e produzi-las no est√°gio de compila√ß√£o. Eu ficaria feliz se uma ferramenta desse tipo fosse adicionada ao padr√£o ou, pelo menos, estendida </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_assert</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que ela </font><strong><font style="vertical-align: inherit;">aceite</font></strong><font style="vertical-align: inherit;"> express√µes constantes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, no </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode haver uma maneira de alcan√ßar esse resultado. Os compiladores j√° produzem duas coisas - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erros</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avisos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! Se, de alguma maneira, pudermos gerenciar ou alterar os </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avisos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para nossas necessidades, j√° receberemos uma conclus√£o digna. Eu tentei v√°rias solu√ß√µes, em particular</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atributo obsoleto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... words&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">useless</span></span></span><span class="hljs-class"> {</span></span> [[deprecated]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// Will trigger a warning. }; template &lt;char... words&gt; void output_as_warning() { useless&lt;words...&gt;().call(); } output_as_warning&lt;'a', 'b', 'c'&gt;(); // warning: 'void useless&lt;words&gt;::call() [with char ...words = {'a', 'b', 'c'}]' is deprecated // [-Wdeprecated-declarations]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora a sa√≠da esteja obviamente presente e possa ser analisada, infelizmente, o c√≥digo n√£o pode ser reproduzido! </font><font style="vertical-align: inherit;">Se, por pura coincid√™ncia, voc√™ for membro de uma sociedade secreta de programadores em C ++ que pode executar resultados durante a compila√ß√£o, ficarei feliz em contrat√°-lo em minha equipe para criar a perfeita </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga II</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclus√µes: </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acabei vendendo o meu </font><font style="vertical-align: inherit;">jogo de </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fraude</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Espero que voc√™ ache este post curioso e aprenda algo novo no processo de l√™-lo. </font><font style="vertical-align: inherit;">Se voc√™ encontrar erros ou maneiras de melhorar o artigo, entre em contato comigo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quero agradecer </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† equipe do SwedenCpp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> por me </font><strong><font style="vertical-align: inherit;">permitir</font></strong><font style="vertical-align: inherit;"> conduzir meu relat√≥rio de projeto em um de seus eventos. </font><font style="vertical-align: inherit;">Al√©m disso, quero expressar minha </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">profunda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gratid√£o a </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Alexander Gurdeev</font></a><font style="vertical-align: inherit;"> , que me ajudou a melhorar os aspectos significativos da </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saga Meta Crush</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414465/">https://habr.com/ru/post/pt414465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414451/index.html">"Calend√°rio do testador" para junho. O testador deve pegar o erro, ler Caner e organizar a mudan√ßa.</a></li>
<li><a href="../pt414453/index.html">Implementar o Path Finder para agentes de IA com o NavMesh</a></li>
<li><a href="../pt414455/index.html">Algoritmo de gera√ß√£o de paleta de cores</a></li>
<li><a href="../pt414459/index.html">Detectores e descritores de pontos singulares FAST, BREVE, ORB</a></li>
<li><a href="../pt414463/index.html">A pr√≥pria IA aprendeu a construir um cubo de Rubik</a></li>
<li><a href="../pt414467/index.html">Artigos da Confer√™ncia Minsk C ++ CoreHard Spring 2018</a></li>
<li><a href="../pt414469/index.html">Semana 22 de seguran√ßa: bloqueios inteligentes de dois segundos</a></li>
<li><a href="../pt414471/index.html">11 c√≠rculos do inferno para quem n√£o tem experi√™ncia em um novo emprego</a></li>
<li><a href="../pt414473/index.html">Ninja DVR: Neoline G-Tech X27 revis√£o dupla</a></li>
<li><a href="../pt414475/index.html">‚ÄúUsu√°rios finais - estamos com voc√™‚Äù: sobre o desenvolvimento do Android na CFT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>