<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥈 🏜️ ♠️ Curso MIT "Segurança de sistemas de computadores". Palestra 4: “Compartilhando Privilégios”, Parte 2 🎣 👩🏽‍🔬 ⏏️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnologia de Massachusetts. Curso de Aula nº 6.858. "Segurança de sistemas de computador". Nikolai Zeldovich, James Mickens. 2014 ano 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Segurança de sistemas de computadores". Palestra 4: “Compartilhando Privilégios”, Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418197/"><h3>  Instituto de Tecnologia de Massachusetts.  Curso de Aula nº 6.858.  "Segurança de sistemas de computador".  Nikolai Zeldovich, James Mickens.  2014 ano </h3><br>  Computer Systems Security é um curso sobre o desenvolvimento e implementação de sistemas de computador seguros.  As palestras abrangem modelos de ameaças, ataques que comprometem a segurança e técnicas de segurança baseadas em trabalhos científicos recentes.  Os tópicos incluem segurança do sistema operacional (SO), recursos, gerenciamento de fluxo de informações, segurança de idiomas, protocolos de rede, segurança de hardware e segurança de aplicativos da web. <br><br>  Palestra 1: “Introdução: modelos de ameaças” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 2: “Controle de ataques de hackers” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 3: “Estouros de Buffer: Explorações e Proteção” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 4: “Separação de Privilégios” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Então, o que mais tínhamos nessa lista?  Processos.  A memória é algo que acontece simultaneamente com o processo.  Portanto, se você não estiver nesse processo, não poderá acessar sua memória.  A memória virtual aprimora perfeitamente esse isolamento para nós.  Além disso, o mecanismo de depuração permite "pop" na memória de outro processo, se você tiver o mesmo ID do usuário <br><br>  Em seguida, temos a rede.  As redes no <b>Unix</b> não correspondem exatamente ao modelo descrito acima, em parte devido ao fato de o <b>sistema</b> operacional <b>Unix ter</b> sido desenvolvido pela primeira vez e, em seguida, aparecer uma rede, que logo se tornou popular.  Tem um conjunto de regras ligeiramente diferente.  Portanto, as operações que realmente precisamos cuidar estão conectando alguém à rede se você gerencia a rede ou escutando alguma porta se você atua como servidor.  Pode ser necessário ler ou gravar dados nessa conexão ou enviar e receber pacotes <b>brutos</b> . <br><br><img src="https://habrastorage.org/webt/dw/gn/zv/dwgnzva6txwuj_esllvdnx3uexg.jpeg"><br><br>  Assim, as redes no <b>Unix não</b> são relacionadas à <b>identificação</b> do <b>usuário</b> .  As regras são que qualquer pessoa sempre pode conectar-se a qualquer máquina ou endereço IP ou abrir uma conexão.  Se você deseja escutar em uma porta, nesse caso, há uma diferença: a maioria dos usuários está proibida de escutar portas com um número abaixo do "valor mágico" de 1024. Em princípio, você pode escutar essas portas, mas nesse caso você deve Seja um usuário especial chamado <b>"superusuário"</b> com <b>uid = 0</b> . <br><br>  Em geral, no Unix, existe o conceito de administrador ou superusuário, representado pelo identificador uid = 0, que pode ignorar quase todas essas verificações; portanto, se você trabalha com direitos de root, pode ler e gravar arquivos, alterar os direitos de acesso a eles.  O sistema operacional permitirá que você faça isso porque acha que você deve ter todos os privilégios.  E você realmente precisa de tais privilégios para ouvir em portas com número &lt;1024. O que você acha dessa restrição tão estranha? <br><br>  <b>Público:</b> identifica números de porta específicos para conexões específicas, por exemplo, para <b>http</b> na porta 80. <br><br>  <b>Professor:</b> sim, por padrão, o <b>protocolo HTTP</b> usa a porta 80. Por outro lado, outros serviços podem usar portas com um número maior que 1024, por que essa restrição é necessária?  Qual é a utilidade aqui? <br><br>  <b>Público:</b> porque você não deseja que ninguém escute acidentalmente seu <b>HTTP</b> . <br><br>  <b>Professor:</b> sim.  Eu acho que a razão para isso é que você costumava ter muitos usuários na mesma máquina.  Eles efetuaram login com seus logins, lançaram seus aplicativos, para que você desejasse ter certeza de que algum usuário aleatório, tendo efetuado login no computador, não seria capaz de se apossar do servidor Web em execução.  Como os usuários que se conectam de fora não sabem quem trabalha nessa porta e apenas se conectam à porta 80. Se eu quiser entrar nesta máquina e iniciar meu próprio servidor da Web, transfiro todo o tráfego do servidor da Web para esse carro.  Esse provavelmente não é um plano muito bom, mas é o modo como o subsistema de rede Unix impede que usuários aleatórios controlem serviços conhecidos executados nesses números de porta baixos.  Essa é a lógica de tal limitação. <br><br><img src="https://habrastorage.org/webt/ba/0o/qn/ba0oqn2qgabud4-_hmizsks086s.jpeg"><br><br>  Além disso, do ponto de vista da leitura e gravação de dados de conexão, se você tiver um arquivo descritor para um soquete específico, o <b>Unix</b> permitirá que você leia e <b>grave</b> quaisquer dados nessa <b>conexão TCP</b> ou <b>uTP</b> .  Ao enviar pacotes <b>brutos</b> , o <b>Unix</b> se comporta como um paranóico, portanto não permite o envio de pacotes arbitrários pela rede.  Isso deve estar dentro do contexto da conexão especial, a menos que você tenha o <b>root - o</b> certo e você possa fazer o que quiser. <br><br>  Então, uma pergunta interessante que você poderia fazer é de onde vêm todos esses <b>IDs de usuário</b> ? <br><br>  Estamos falando de processos com <b>userid</b> ou <b>groupid</b> .  Ao iniciar o <b>PS</b> no seu computador, você definitivamente verá uma série de processos com diferentes valores de <b>uid</b> .  De onde eles vieram? <br><br>  Precisamos de algum mecanismo para carregar todos esses valores de <b>ID</b> do <b>usuário</b> .  <b>O Unix</b> possui várias chamadas de sistema projetadas para isso.  Portanto, para inicializar esses valores de identificador, existe uma função chamada <b>setuid (uid)</b> , para que você possa atribuir o número de <b>uid</b> de algum processo atual a esse valor.  Esta é realmente uma operação perigosa, como tudo na tradição do <b>Unix</b> , porque você só pode fazer isso se o seu <b>uid = 0</b> .  De qualquer forma, deve ser assim. <br><br>  Portanto, se você é um usuário com direitos de root e possui <b>uid = 0</b> , pode chamar <b>setuid (uid)</b> e alternar o usuário para qualquer processo.  Existem algumas outras chamadas de sistema semelhantes para inicializar o <b>gid</b> relacionado ao processo: são <b>setgid</b> e <b>setgroups</b> .  Portanto, essas chamadas do sistema permitem configurar privilégios de processo. <br><br><img src="https://habrastorage.org/webt/qs/6m/bk/qs6mbkc520bn-n_vlpznivx1z0q.jpeg"><br><br>  O fato de seus processos obterem os direitos de acesso corretos quando você efetua login na máquina <b>Unix</b> não ocorre porque você tem o mesmo <b>ID</b> dos processos, porque o sistema ainda não sabe quem você é.  Em vez disso, no <b>Unix,</b> existe algum tipo de procedimento de login quando o <b>protocolo</b> shell seguro <b>SSH</b> inicia o processo para qualquer pessoa que se conecta ao computador e tenta autenticar o usuário. <br><br>  Portanto, inicialmente esse processo de login começa com <b>uid = 0,</b> como para um usuário com direitos de root, e quando recebe um nome de usuário e senha específicos, ele os verifica em seu próprio banco de dados de contas.  Como regra, no <b>Unix,</b> esses dados são armazenados em dois arquivos: <b>/ etc / password</b> (por razões históricas, as senhas não são mais armazenadas nesse arquivo) e no arquivo <b>/ etc / shadow</b> , no qual as senhas são armazenadas.  No entanto, há uma tabela no arquivo <b>/ etc / password</b> que exibe cada nome de usuário no sistema como um valor inteiro. <br><br>  Portanto, seu nome de usuário é mapeado para um número inteiro específico neste arquivo <b>/ etc / password</b> e, em seguida, o processo de login verifica se sua senha está correta de acordo com este arquivo.  Se encontrar seu <b>uid</b> inteiro, ele definirá as funções <b>setuid</b> para esse valor de <b>uid</b> e iniciará o shell com o comando <b>exec (/ bin / sh)</b> .  Agora você pode interagir com o shell, mas ele funciona sob o seu <b>uid</b> ; portanto, você não poderá causar danos acidentais a esta máquina. <br><br><img src="https://habrastorage.org/webt/oa/vi/t8/oavit8bjjn_skjz8-n1k5dhc6co.jpeg"><br><br>  <b>Público: é</b> possível iniciar um novo processo com <b>uid = 0</b> se o seu <b>uid</b> não for realmente 0? <br><br>  <b>Professor:</b> se você tiver privilégios de root, poderá se limitar a outro <b>uid</b> , diminuir sua autoridade, mas, em qualquer caso, poderá criar um processo com apenas o mesmo <b>uid</b> que o seu.  Mas acontece que, por várias razões, você deseja aumentar seus privilégios.  Suponha que você precise instalar um pacote, para o qual você precisa de privilégios de <b>root</b> . <br><br>  Existem duas maneiras de definir privilégios no <b>Unix</b> .  Um que já mencionamos é um descritor de arquivo.  Portanto, se você realmente deseja aumentar seus privilégios, pode conversar com alguém que trabalha com direitos de root e pedir que ele abra esse arquivo para você.  Ou você precisa instalar uma nova interface, esse assistente abre um arquivo para você e retorna um descritor de arquivo para você usando a transferência <b>fd</b> .  Essa é uma maneira de aumentar seus privilégios, mas é inconveniente porque, em alguns casos, existem processos em execução com um grande número de privilégios.  Para isso, o <b>Unix</b> possui um mecanismo inteligente, mas ao mesmo tempo problemático, chamado <b>"binários setuid"</b> .  Esse mecanismo é executável regularmente em um <b>sistema de</b> arquivos <b>Unix</b> , exceto quando você executa <b>exec</b> no binário <b>setuid</b> , por exemplo, <b>/ bin / su</b> na maioria das máquinas, ou <b>sudo</b> , na inicialização. <br><br>  Um sistema <b>Unix</b> típico possui um monte de binários <b>setuid</b> .  A diferença é que, quando você executa um desses binários, na verdade, ele alterna a <b>identificação do usuário do</b> processo para o proprietário desse binário.  Esse mecanismo parece estranho quando você o vê pela primeira vez.  Como regra, as maneiras de usá-lo são que esse “binário” provavelmente possui um proprietário <b>de</b> 0, porque você realmente deseja restaurar muitos privilégios. <br><br><img src="https://habrastorage.org/webt/zt/s5/8d/zts58db83nchnbo1a6qqobpbpuw.jpeg"><br><br>  Você deseja restaurar os direitos do superusuário para poder executar este comando <b>su</b> , e o kernel, ao executar esse binário, alternará o processo <b>uid</b> para 0, para que este programa agora execute algumas coisas privilegiadas. <br><br>  <b>Público:</b> se você tiver <b>uid = 0</b> e alterar o <b>uid de</b> todos esses binários <b>setuid</b> para algo diferente de 0, poderá restaurar seus privilégios? <br><br>  <b>Professor:</b> não, muitos processos não poderão restaurar privilégios ao diminuir o nível de acesso; portanto, você pode ficar preso nesse local.  Este mecanismo não está vinculado a <b>uid = 0</b> .  Como qualquer usuário de um sistema <b>Unix</b> , você pode criar qualquer arquivo binário, criar um programa, compilá-lo e definir esse bit <b>setuid</b> para o próprio programa.  Pertence a você, usuário, seu ID de usuário.  E isso significa que qualquer pessoa que execute seu programa executará esse código com seu ID de usuário.  Existe algum problema com isso?  O que precisa ser feito? <br><br>  <b>Público:</b> ou seja, se houve um erro no seu aplicativo, alguém poderia fazer algo com ele, agindo com seus privilégios? <br><br>  <b>Professor:</b> certo, isso acontece se meu aplicativo for "buggy" ou se permitir que você execute tudo o que deseja.  Suponha que eu possa copiar o shell do sistema e <b>defini-</b> lo para mim, mas qualquer um pode executar esse shell na minha conta.  Este provavelmente não é o melhor plano de ação.  Mas esse mecanismo não cria um problema, porque a única pessoa que pode definir o bit <b>setuid</b> em um arquivo binário é o proprietário desse arquivo.  Você, como proprietário do arquivo, tem o privilégio <b>uid</b> , para poder transferir sua conta para outra pessoa, mas essa outra pessoa não poderá criar o binário <b>setuid</b> com seu <b>ID do usuário</b> . <br><br>  Esse bit setuid é armazenado próximo a esses bits de permissão, ou seja, em cada <b>inode</b> também há um bit <b>setuid</b> que diz se esse arquivo executável deve ou se o programa mudou para o proprietário <b>uid</b> durante a execução. <br><br><img src="https://habrastorage.org/webt/4d/o0/cf/4do0cfauri7y6g94omunnrdyv14.jpeg"><br><br>  Acontece que este é um mecanismo muito complicado quando usado corretamente e, graças a ele, o kernel implementa o programa corretamente.  Na verdade, isso é bastante fácil de fazer, porque apenas uma verificação é realizada: se esse bit <b>setuid</b> existe, o processo muda para <b>uid</b> .  É bem simples. <br><br>  Mas usá-lo com segurança é bastante difícil, porque, como acabamos de indicar, se este programa contém erros ou faz algo inesperado, você pode fazer coisas arbitrárias sob <b>uid = 0</b> ou sob qualquer outro <b>uid</b> .  No <b>Unix,</b> quando você executa um programa, herda muitas coisas do processo pai. <br><br>  Por exemplo, você pode passar variáveis ​​de ambiente para binários <b>setuid</b> .  O fato é que, no <b>Unix,</b> você pode especificar qual biblioteca compartilhada usar para o processo, definindo a variável de ambiente, e os binários <b>setuid</b> não se importam em filtrar essas variáveis ​​de ambiente. <br><br>  Por exemplo, você pode executar o <b>bin / su</b> , mas use bibliotecas compartilhadas para a função <b>printf</b> , para que o <b>printf</b> inicie quando o <b>bin / su</b> imprimir alguma coisa e você possa executar o shell em vez de o printingf. <br><br>  Existem muitas sutilezas que você deve entender corretamente em relação à desconfiança do programa com os dados inseridos pelo usuário.  Como você geralmente confia na entrada do usuário, o <b>setuid</b> nunca foi a parte mais segura de um sistema <b>Unix</b> inteiro.  Tem perguntas sobre isso? <br><br>  <b>Público:</b> o <b>setuid</b> também se aplica a grupos ou apenas ao usuário? <br><br>  <b>Professor:</b> existe um bit <b>setgid</b> simétrico ao bit <b>setuid</b> , que você também pode definir.  Se o arquivo tiver um <b>gid</b> específico e esse bit <b>setgid</b> estiver definido quando o programa for iniciado, você o receberá. <br><br>  <b>O Setgid</b> não <b>é</b> particularmente usado, mas pode ser útil nos casos em que você deseja fornecer privilégios muito específicos.  Por exemplo, o <b>bin / su</b> provavelmente precisa de muitos privilégios, mas talvez haja algum programa que precise de alguns privilégios extras, por exemplo, para gravar algo em um arquivo de log especial.  Portanto, você provavelmente deseja fornecer a ela um determinado grupo e criar um arquivo de log que seja gravável por esse grupo.  Portanto, mesmo que o programa seja "buggy", você não perderá nada além deste grupo.  Isso é útil como um mecanismo que, por algum motivo, não é usado com muita frequência, porque, afinal, as pessoas devem usar mais os direitos de root. <br><br>  <b>Público:</b> existem restrições sobre quem pode alterar o acesso? <br><br>  <b>Professor:</b> sim.  Implementações diferentes do <b>Unix</b> têm verificações diferentes para isso.  A regra geral é que apenas o root pode alterar o proprietário do arquivo, porque você não deseja criar arquivos que pertencerão a outra pessoa e, é claro, não deseja se apropriar dos arquivos de outras pessoas.  Portanto, se o seu <b>uid</b> não <b>for</b> 0, você estará preso.  Você não pode alterar a propriedade de nenhum arquivo.  Se seu <b>uid = 0</b> , você possui privilégios de root e pode alterar o proprietário para qualquer um.  Existem algumas complicações se você tiver um <b>setuid</b> binário e mudar de um <b>uid</b> para outro, isso é bastante complicado, mas basicamente você não pode alterar o proprietário do arquivo se não tiver privilégios de root. <br><br>  Por todas as contas, este é um sistema um pouco desatualizado.  Você provavelmente poderia imaginar várias maneiras de simplificar os processos descritos acima, mas, na verdade, os sistemas mais avançados se parecem com isso porque evoluem com o tempo.  Mas você pode usar perfeitamente esses mecanismos como uma "caixa de areia". <br><br>  Estes são apenas alguns tipos de princípios básicos do <b>Unix</b> , que aparecem em quase todos os sistemas operacionais do tipo Unix: <b>Mac OS X</b> , <b>Linux</b> , <b>FreeBSD</b> , <b>Solaris</b> , se alguém o usa, e assim por diante.  Mas cada um desses sistemas possui mecanismos mais sofisticados que você pode usar.  Por exemplo, no <b>Linux,</b> existe um conjunto de "sandbox" <b>COMP</b> , o <b>Mac OS X</b> usa o cinto de <b>segurança</b> "sandbox".  Na próxima semana, darei exemplos de caixas de proteção disponíveis em todos os sistemas baseados em <b>Unix</b> . <br><br>  Portanto, um dos últimos mecanismos, que consideraremos antes de mergulhar no <b>OKWS</b> , explica como você precisa lidar com binários <b>setuid</b> e mostra como você pode se proteger contra falhas de segurança existentes.  O problema é que você inevitavelmente terá alguns binários <b>setuid</b> no seu sistema, como <b>/ bin / su</b> ou <b>sudo</b> ou qualquer outra coisa, e é provável que seus programas apresentem erros.  Por isso, alguém poderá executar o binário <b>setuid</b> e o processo poderá obter acesso <b>root</b> , o que você não deseja permitir. <br><br><img src="https://habrastorage.org/webt/gy/nt/aa/gyntaadl0kgyfcku6ncq8v334kg.jpeg"><br><br>  O mecanismo <b>Unix</b> , que geralmente é usado para impedir a execução de um processo potencialmente malicioso usando binários <b>setuid</b> , é usar o namespace do sistema de arquivos para alterá-lo usando a chamada do sistema <b>chroot</b> , a operação de alterar o diretório raiz.  <b>O OKWS</b> , como servidor da web especializado na criação de serviços da web rápidos e seguros, usa isso amplamente. <br><br><img src="https://habrastorage.org/webt/m3/x1/xr/m3x1xrg_tmht2b2l8rwd8kzzy7s.jpeg"><br><br>  Então, no <b>Unix,</b> você pode executar <b>chroot</b> em um diretório específico, então talvez você também possa executar <b>chroot ("/ foo")</b> . <br><br>  Existem 2 explicações para o que o <b>chroot</b> faz.  O primeiro é apenas intuitivo, significa que, após executar o <b>chroot</b> , o diretório raiz ou o diretório localizado atrás da barra é basicamente equivalente ao que <b>/ foo usou</b> antes de você chamar <b>chroot</b> .  Parece limitar o namespace abaixo do seu <b>/ foo</b> .  Portanto, se você tem um arquivo que costumava ser chamado <b>/ foo / x</b> , depois de chamar o <b>chroot,</b> pode obtê-lo simplesmente abrindo <b>/ x</b> .  Portanto, basta limitar seu espaço para nome a um subdiretório.  Aqui está o que é a versão intuitiva. <br><br><img src="https://habrastorage.org/webt/2w/58/wf/2w58wflgecku62k-urraxwggxcc.jpeg"><br><br>  Obviamente, em segurança, não é a versão intuitiva que importa, mas o que exatamente o kernel faz com essa chamada de sistema?  E faz basicamente duas coisas.  Primeiro, ele altera o valor dessa barra, portanto, sempre que você acessa ou inicia o nome do diretório com uma barra, o kernel inclui qualquer arquivo que você forneceu nas operações <b>chroot</b> .  No nosso exemplo, este é o arquivo <b>/ foo</b> antes de você chamar <b>chroot</b> , ou seja, obtemos esse <b>/ = / foo</b> . <br><br><img src="https://habrastorage.org/webt/gn/yx/-t/gnyx-tksd5brn4avys0dhppaw6c.jpeg"><br><br>  A próxima coisa que o kernel tentará fazer é protegê-lo de ser capaz de "escapar" do seu <b>/</b> se você fizer <b>/../</b> .  Porque no <b>Unix,</b> eu poderia pedir que você me desse, por exemplo, <b>/../etc/password</b> .  Portanto, se eu apenas suplementasse essa linha assim: <b>/foo/../etc/password</b> , isso não seria bom, porque eu poderia simplesmente sair do <b>/ foo</b> e continuar com o <b>/ etc / password</b> . <br><br>  A segunda coisa que o kernel faz com uma chamada de sistema <b>Unix</b> é que, quando você chama <b>chroot</b> para esse processo específico, ele muda a maneira como <b>/../ é</b> avaliado neste diretório.  Portanto, modifica <b>/../</b> para que <b>/ foo</b> aponte para si mesmo.  Portanto, isso não permite que você "escape", e essa alteração se aplica apenas a esse processo e não afeta o resto.  Que idéias você tem sobre como "escapar" do ambiente <b>chroot</b> usando como ele é implementado? <br><br>  Curiosamente, o kernel monitora apenas um diretório <b>chroot</b> , então você provavelmente pode executar a operação <b>chroot = (/ foo)</b> , mas você estaria preso a esse local.  Então você quer obter o <b>/ etc / password</b> , mas como fazê-lo?  Você pode abrir o diretório raiz agora mesmo, digitando <b>abrir (* / *)</b> .  Isso fornecerá um descritor de arquivo descrevendo o que é <b>/ foo</b> .  Então você pode chamar <b>chroot</b> novamente e executar <b>chroot (`/ bar)</b> . <br><br><img src="https://habrastorage.org/webt/er/ce/o6/erceo6xadygvj95nuy8fj-zn1bi.jpeg"><br><br> ,    : <b>root</b>   <b>/foo</b> ,  <b>/foo/bar</b>   <b>/../</b>     <b>/foo / bar/..</b> <br><br><img src="https://habrastorage.org/webt/gi/vb/zy/givbzygict7u1xirzzwneycl3sw.jpeg"><br><br>  ,          <b>/foo</b> .            <b>fchdir (fd)</b>     <b>(*/*)</b> ,      <b>chdir (..)</b> . <br><br><img src="https://habrastorage.org/webt/lb/qz/mx/lbqzmxnz8308avfwfyaxxprq7d8.jpeg"><br><br><img src="https://habrastorage.org/webt/gu/cn/kd/gucnkdez6q9ntda3zwtotnc4igg.jpeg"><br><br>       <b>/foo</b> ,     <b>/../</b> .     <b>/foo</b>        ,       <b>root</b> ,       . <br><br> ,    ,       .       .   <b>Unix</b>    root-   <b>chroot</b> ,  <b>chroot</b>     .  ,  <b>Unix</b>    <b>uid = 0</b>  ,      <b>chroot</b> .   .           ,         ,    <b>chroot</b> ,   <b>userid</b>   .   ,     <b>Unix</b> ,     ,    <b>root</b> ,    . <br><br>       ,  , ,     .      <b>chroot</b>       —      .    . <br><br> <b>:</b>  ,       <b>inod</b> ,      ? <br><br> <b>:</b>    !              ,  , , : «   <b>inode</b>  23»,      -        <b>hroot</b> .  ,  <b>Unix</b>     <b>inode</b>   <b>inode</b> ,  , ,   root-. <br><br>  ,      ,  ,   <b>OKWS</b> .  ,      <b>OKWS</b> . <br><br>  ,     -,   ,      -  ,      .          , , <b>httpd</b> , ,  <b>Apache</b> . <br><br>        <b>userid</b>   <b>www</b>  <b>/etc/password</b> .     ,   ,     <b>SSL</b> ,      <b>PHP</b>   ,        .   ,       , , <b>MySQL</b> ,           .    <b>MySQL</b>     .      <b>MySQL</b> , , ,      . <br><br><img src="https://habrastorage.org/webt/sx/tx/gd/sxtxgdpf7q9jr3q_tfxyzi6zgdc.jpeg"><br><br> ,  ,    ,    <b>MySQL</b>    ,        ,             . <br><br>         ,       ,  ,         ,   .    ,      , ,     <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apache</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou talvez no código do aplicativo ou no interpretador </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">E, como existem erros, você pode usá-los para obter todo o conteúdo do aplicativo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">52:30 min </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuação:</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Curso MIT "Segurança de sistemas de computadores".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Palestra 4: “Compartilhando Privilégios”, Parte 2</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/dNl22h1kW1k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A versão completa do curso está disponível </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Obrigado por ficar conosco.  Você gosta dos nossos artigos?  Deseja ver materiais mais interessantes?  Ajude-nos fazendo um pedido ou recomendando a seus amigos, um <b>desconto de 30% para os usuários da Habr em um análogo exclusivo de servidores básicos que inventamos para você:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Toda a verdade sobre o VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD 1Gbps de US $ 20 ou como dividir o servidor?</a>  (as opções estão disponíveis com RAID1 e RAID10, até 24 núcleos e até 40GB DDR4). <br><br>  <b>Dell R730xd 2 vezes mais barato?</b>  Somente nós temos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2 TVs Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 a partir de US $ 249</a> na Holanda e nos EUA!</b>  Leia sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como criar um prédio de infraestrutura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe usando servidores Dell R730xd E5-2650 v4 custando 9.000 euros por um centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418197/">https://habr.com/ru/post/pt418197/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418187/index.html">Na América, eles sugeriram a substituição de todas as bibliotecas pelos hubs da Amazon. O público está indignado</a></li>
<li><a href="../pt418189/index.html">Herdeiro de Zeus: por que o Trojan IcedID é perigoso para clientes de bancos</a></li>
<li><a href="../pt418191/index.html">Análogos em Python e JavaScript. Parte três</a></li>
<li><a href="../pt418193/index.html">Como é criar um jogo para o Game Boy em 2017</a></li>
<li><a href="../pt418195/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 4: “Compartilhando Privilégios”, Parte 1</a></li>
<li><a href="../pt418199/index.html">Como fazer uma tarefa técnica simples e não perder dinheiro e nervos</a></li>
<li><a href="../pt418201/index.html">Podemos reviver Duck Hunt?</a></li>
<li><a href="../pt418203/index.html">API do GraphQL (CRUD) on Go</a></li>
<li><a href="../pt418205/index.html">Space Language Vol. 2: Bem-vindo, GJ273b</a></li>
<li><a href="../pt418207/index.html">Análise dos laptops para jogos ASUS ROG Strix GL504GS SCAR II e ASUS ROG Strix GL504GM HERO II</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>