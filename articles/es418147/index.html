<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüî¨ üíé üì† Silencio de las ejecuciones de Ruby: Transactional Rails / PostgreSQL Thriller üë∞üèΩ üîç üë®üèø‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta es una historia sobre por qu√© nunca debe ignorar los errores cuando est√° dentro de una transacci√≥n en una base de datos. Averiguar c√≥mo usar las ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Silencio de las ejecuciones de Ruby: Transactional Rails / PostgreSQL Thriller</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418147/"><p>  <em>Esta es una historia sobre por qu√© <strong>nunca debe</strong> ignorar los errores cuando est√° dentro de una transacci√≥n en una base de datos.</em>  <em>Averiguar c√≥mo usar las transacciones correctamente y qu√© hacer al usarlas no es una opci√≥n.</em>  <em>Spoiler: ¬°se tratar√° de bloqueos de asesoramiento en PostgreSQL!</em> </p><br><p> Trabaj√© en un proyecto en el que los usuarios pueden importar una gran cantidad de entidades pesadas (llam√©moslas productos) desde un servicio externo a nuestra aplicaci√≥n.  Para cada producto, se cargan datos a√∫n m√°s diversos asociados desde API externas.  No es raro que un usuario cargue cientos de productos junto con todas las dependencias, como resultado, importar un producto lleva un tiempo tangible (30-60 segundos), y todo el proceso puede llevar mucho tiempo.  El usuario puede estar cansado de esperar el resultado y tiene derecho a hacer clic en el bot√≥n "Cancelar" en cualquier momento y la aplicaci√≥n deber√≠a ser √∫til con la cantidad de productos que se pudieron descargar en este momento. </p><a name="habracut"></a><br><p>  La ‚Äúimportaci√≥n interrumpida‚Äù se implementa de la siguiente manera: al principio de cada producto se crea un registro de tarea temporal en la placa de identificaci√≥n de la base de datos.  Para cada producto, se inicia una tarea de importaci√≥n en segundo plano, que descarga el producto, lo guarda en la base de datos junto con todas las dependencias (hace todo en general) y, al final, elimina su registro de tareas.  Si para el momento en que comienza la tarea en segundo plano, no habr√° ning√∫n registro en la base de datos, la tarea simplemente finaliza en silencio.  Por lo tanto, para cancelar la importaci√≥n, es suficiente simplemente eliminar todas las tareas y listo. </p><br><p>  No importa si la importaci√≥n fue cancelada por el usuario o completada por √©l mismo; en cualquier caso, la ausencia de tareas significa que todo ha terminado y el usuario puede comenzar a usar la aplicaci√≥n. </p><br><p>  El dise√±o es simple y confiable, pero hab√≠a un peque√±o error.  Un informe de error t√≠pico sobre √©l fue: ‚ÄúDespu√©s de que se cancela la importaci√≥n, se muestra al usuario una lista de sus productos.  Sin embargo, si actualiza la p√°gina, la lista de productos se complementa con varias entradas ".  La raz√≥n de este comportamiento es simple: cuando el usuario hizo clic en el bot√≥n "Cancelar", fue transferido inmediatamente a la lista de todos los productos.  Pero en este momento, las importaciones ya iniciadas de ciertos bienes todav√≠a est√°n "funcionando". </p><br><p>  Esto, por supuesto, es un poco, pero los usuarios estaban desconcertados por la orden, por lo que ser√≠a bueno solucionarlo.  Ten√≠a dos formas: identificar y "matar" de alguna manera las tareas que ya se estaban ejecutando, o cuando hago clic en el bot√≥n cancelar, esperar hasta que se completen y "morir por su propia muerte" antes de transferir al usuario a√∫n m√°s.  Eleg√≠ la segunda forma: esperar. </p><br><h2 id="tranzakcionnye-blokirovki-speshat-na-pomosch">  Las cerraduras transaccionales corren al rescate </h2><br><p>  Para todos los que trabajan con bases de datos (relacionales), la respuesta es obvia: ¬°use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">transacciones</a> ! </p><br><p> Es importante recordar que en la mayor√≠a de los RDBMS, los registros actualizados dentro de una transacci√≥n ser√°n <em>bloqueados</em> e inaccesibles para cambios por otros procesos hasta que se complete esta transacci√≥n.  Los registros seleccionados con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>SELECT FOR UPDATE</code></a> tambi√©n se bloquear√°n. </p><br><p>  ¬°Exactamente nuestro caso!  Termin√© la tarea de importar bienes individuales en una transacci√≥n y bloque√© el registro de la tarea desde el principio: </p><br><pre> <code class="ruby hljs">ActiveRecord::Base.transaction <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> task = Import::Task.lock.find_by(<span class="hljs-symbol"><span class="hljs-symbol">id:</span></span> id) <span class="hljs-comment"><span class="hljs-comment"># SELECT ‚Ä¶ FOR UPDATE  ¬´    ¬ª return unless task #  - ? ,    ! #     task.destroy end</span></span></code> </pre> <br><p>  Ahora, cuando el usuario desea cancelar la importaci√≥n, la operaci√≥n de detenci√≥n de importaci√≥n eliminar√° las tareas para las importaciones que a√∫n no se han iniciado y se ver√° obligado a esperar la finalizaci√≥n de las ya existentes: </p><br><pre> <code class="ruby hljs">user.import_tasks.delete_all <span class="hljs-comment"><span class="hljs-comment">#       </span></span></code> </pre> <br><p>  Simple y elegante!  Ejecut√© las pruebas, verifiqu√© la importaci√≥n localmente y en la puesta en escena, y me desplegu√© "en batalla". </p><br><h2 id="ne-tak-bystro">  No tan r√°pido ... </h2><br><p>  Satisfecho con mi trabajo, me sorprendi√≥ encontrar pronto informes de errores y toneladas de errores en los registros.  Muchos productos no fueron importados <em>en absoluto</em> .  En algunos casos, solo puede quedar un solo producto despu√©s de la finalizaci√≥n de todas las importaciones. </p><br><p>  Los errores en los registros tampoco fueron alentadores: <code>PG::InFailedSqlTransaction</code> con un <code>PG::InFailedSqlTransaction</code> conduce al c√≥digo que ejecut√≥ los inocentes <code>SELECT</code> .  ¬øQu√© est√° pasando en absoluto? </p><br><p>  Despu√©s de un d√≠a de depuraci√≥n agotadora, identifiqu√© tres causas principales de los problemas: </p><br><ol><li>  Inserci√≥n competitiva de registros en conflicto en la base de datos. </li><li>  Cancelaci√≥n autom√°tica de transacciones en PostgreSQL despu√©s de errores. </li><li>  Silencio de problemas (excepciones de Ruby) en el c√≥digo de la aplicaci√≥n. </li></ol><br><p>  <strong>Problema uno: inserci√≥n competitiva de entradas en conflicto</strong> </p><br><p>  Como cada operaci√≥n de importaci√≥n demora hasta un minuto y hay muchas de estas tareas, las realizamos en paralelo para ahorrar tiempo.  Los registros dependientes de bienes pueden cruzarse, en la medida en que todos los productos del usuario puedan referirse a un solo registro, creado una vez y luego reutilizado. </p><br><p>  Hay comprobaciones para encontrar y reutilizar las mismas dependencias en el c√≥digo de la aplicaci√≥n, pero <em>ahora, cuando usamos transacciones, estas comprobaciones se vuelven in√∫tiles</em> : si la transacci√≥n A cre√≥ un registro dependiente pero a√∫n no se ha completado, la transacci√≥n B no podr√° descubrir su existencia e intentar√° crear un duplicado registro. </p><br><p>  <strong>Problema dos: cancelaci√≥n autom√°tica de transacciones de PostgreSQL despu√©s de errores</strong> </p><br><p>  Por supuesto, evitamos la creaci√≥n de tareas duplicadas a nivel de base de datos utilizando el siguiente DDL: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> product_deps <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span> (user_id, characteristics);</code> </pre> <br><p>  Si una transacci√≥n en curso A inserta un nuevo registro y la transacci√≥n B intenta insertar un registro con los mismos valores de los campos <code>user_id</code> y <code>characteristics</code> , la transacci√≥n B recibir√° un error: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> product_deps (user_id, characteristics) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'{"same": "value"}'</span></span>); <span class="hljs-comment"><span class="hljs-comment">-- Now it will block until first transaction will be finished ERROR: duplicate key value violates unique constraint "product_deps_user_id_characteristics_key" DETAIL: Key (user_id, characteristics)=(1, {"same": "value"}) already exists. -- And will throw an error when first transaction have commited and it is become clear that we have a conflict</span></span></code> </pre> <br><p>  Pero hay una caracter√≠stica que no debe olvidarse: la transacci√≥n B, despu√©s de detectar un error, se cancelar√° autom√°ticamente y todo el trabajo realizado se ir√° por el desag√ºe.  Sin embargo, esta transacci√≥n <strong>a√∫n est√° abierta</strong> en un estado "err√≥neo", pero con cualquier intento de ejecutar cualquier solicitud, incluso la m√°s inofensiva, solo se devolver√°n los errores en respuesta: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> products; ERROR: current transaction is aborted, commands ignored until <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">block</span></span></code> </pre> <br><p>  Bueno, es completamente innecesario decir que todo lo que se ingres√≥ en la base de datos en esta transacci√≥n no se guardar√°: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; <span class="hljs-comment"><span class="hljs-comment">--      ,   ROLLBACK --          </span></span></code> </pre> <br><p>  <strong>Problema tres: silencio</strong> </p><br><p>  En este punto, ya estaba claro que simplemente agregando transacciones a la aplicaci√≥n la rompi√≥.  No hab√≠a otra opci√≥n: tuve que sumergirme en el c√≥digo de importaci√≥n.  En el c√≥digo, a menudo los siguientes patrones comenzaron a llamar mi atenci√≥n: </p><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_stuff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment"># ,   rescue StandardError nil #  ,  end</span></span></code> </pre> <br><p>  El autor del c√≥digo aqu√≠ nos dice: "Lo intentamos, no lo logramos, pero est√° bien, continuamos sin √©l".  Y aunque las razones de esta elecci√≥n pueden ser bastante explicables (no todo se puede procesar a nivel de aplicaci√≥n), esto es lo que hace que cualquier l√≥gica basada en transacciones sea imposible: una ejecuci√≥n rechazada no podr√° flotar hasta el bloque de <code>transaction</code> y no causar√° una reversi√≥n correcta transacciones (ActiveRecord detecta todos los errores en este bloque, revierte la transacci√≥n y los arroja nuevamente). </p><br><h2 id="idealnyy-shtorm">  Tormenta perfecta </h2><br><p>  Y as√≠ es como estos tres factores se unieron para crear el perfecto <del>  la tormenta </del>  error: </p><br><ul><li>  Una aplicaci√≥n en una transacci√≥n intenta insertar un registro conflictivo en la base de datos y causa un error de "clave duplicada" de PostgreSQL.  Sin embargo, este error no hace que la transacci√≥n se revierta en la aplicaci√≥n, ya que se "silencia" dentro de una de las partes de la aplicaci√≥n. </li><li>  La transacci√≥n deja de ser v√°lida, pero la aplicaci√≥n no lo sabe y contin√∫a funcionando.  En cualquier intento de acceder a la base de datos, la aplicaci√≥n nuevamente recibe un error, esta vez "la transacci√≥n actual se cancela", pero este error tambi√©n se puede descartar ... </li><li>  Probablemente ya haya entendido que algo en la aplicaci√≥n contin√∫a rompi√©ndose, pero nadie lo sabr√° hasta que la ejecuci√≥n llegue al primer lugar, donde no haya un <code>rescue</code> demasiado codicioso y donde el error pueda aparecer, registrarse. registrado en el rastreador de errores - cualquier cosa.  Pero este lugar ya estar√° muy lejos del lugar que se convirti√≥ en la causa ra√≠z del error, y esto solo convertir√° la depuraci√≥n en una pesadilla. </li></ul><br><h2 id="alternativa-tranzakcionnym-blokirovkam-v-postgresql">  Alternativa a los bloqueos transaccionales en PostgreSQL </h2><br><p>  Buscar el <code>rescue</code> en el c√≥digo de la aplicaci√≥n y reescribir toda la l√≥gica de importaci√≥n no es una opci√≥n.  Mucho tiempo  ¬°Necesitaba una soluci√≥n r√°pida y la encontr√© en el postgres!  Tiene una soluci√≥n integrada para bloqueos, una alternativa al bloqueo de registros en transacciones, bloqueos de aviso de reuni√≥n.  Los us√© de la siguiente manera: </p><br><p>  Primero, elimin√© la transacci√≥n de envoltura primero.  En cualquier caso, es una mala idea interactuar con API externas (o cualquier otro "efecto secundario") del c√≥digo de la aplicaci√≥n con una transacci√≥n abierta, porque incluso si revierte la transacci√≥n junto con todos los cambios en nuestra base de datos, los cambios en los sistemas externos permanecer√°n , y la aplicaci√≥n en su conjunto puede estar en un estado extra√±o e indeseable.  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gema aislante</a> puede ayudarlo a asegurarse de que los efectos secundarios est√©n adecuadamente <em>aislados</em> de las transacciones. </p><br><p>  Luego, en cada operaci√≥n de importaci√≥n, tomo un bloqueo <em>compartido</em> en alguna clave √∫nica para toda la importaci√≥n (por ejemplo, creada a partir del ID de usuario y hash del nombre de la clase de operaci√≥n): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock_shared(<span class="hljs-number"><span class="hljs-number">42</span></span>, user.id);</code> </pre> <br><p>  Las cerraduras compartidas en la misma clave se pueden tomar simult√°neamente por cualquier n√∫mero de sesiones. </p><br><p>  La cancelaci√≥n de la operaci√≥n de importaci√≥n al mismo tiempo elimina todas las entradas de tareas de la base de datos e intenta tomar <em>un</em> bloqueo <em>exclusivo</em> en la misma clave.  En este caso, tendr√° que esperar hasta que se liberen todos los bloqueos compartidos: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock(<span class="hljs-number"><span class="hljs-number">42</span></span>, user.id)</code> </pre> <br><p>  ¬°Y eso es todo!  Ahora la "cancelaci√≥n" esperar√° hasta que se completen todas las importaciones "en ejecuci√≥n" de bienes individuales. </p><br><p>  Adem√°s, ahora que no estamos conectados por una transacci√≥n, podemos usar un peque√±o truco para limitar el tiempo de espera para la cancelaci√≥n de la importaci√≥n (en caso de que algunos "bloqueos" de la importaci√≥n), porque no es bueno bloquear el flujo del servidor web durante mucho tiempo (y forzar esperar al usuario): </p><br><pre> <code class="ruby hljs">transaction <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> execute(<span class="hljs-string"><span class="hljs-string">"SET LOCAL lock_timeout = '30s'"</span></span>) execute(<span class="hljs-string"><span class="hljs-string">"SELECT pg_advisory_lock(42, user.id)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">rescue</span></span> ActiveRecord::LockWaitTimeout <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-comment"><span class="hljs-comment">#    (     ) end</span></span></code> </pre> <br><p>  Es seguro detectar un error <em>fuera</em> del bloque de <code>transaction</code> , porque <a href="">ActiveRecord ya revertir√° la transacci√≥n</a> . </p><br><h2 id="no-chto-delat-s-konkurentnoy-vstavkoy-odinakovyh-zapisey">  Pero, ¬øqu√© hacer con la inserci√≥n competitiva de registros id√©nticos? </h2><br><p>  Desafortunadamente, no conozco una soluci√≥n que funcione bien con insertos <em>competitivos</em> .  Existen los siguientes enfoques, pero todos bloquear√°n las inserciones concurrentes hasta que se complete la primera de las transacciones: </p><br><ul><li>  <code>INSERT ‚Ä¶ ON CONFLICT UPDATE</code> (disponible desde PostgreSQL 9.5) en la segunda transacci√≥n se bloquear√° hasta que se complete la primera transacci√≥n y luego devolver√° el registro insertado por la primera transacci√≥n. </li><li>  Bloquee alg√∫n registro general en una transacci√≥n antes de ejecutar validaciones para insertar un nuevo registro.  Aqu√≠ esperaremos hasta que el registro insertado en otra transacci√≥n sea visible y las validaciones no puedan funcionar por completo. </li><li>  Tome alg√∫n tipo de bloqueo de recomendaci√≥n general: el efecto es el mismo que para bloquear un registro general. </li></ul><br><p>  Bueno, si no tiene miedo de trabajar con errores de nivel base, puede detectar el error de unicidad: </p><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">import_all_the_things</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">#   ,   Dep.create(user_id, chars) rescue ActiveRecord::RecordNotUnique retry end</span></span></span></span></code> </pre> <br><p>  Solo aseg√∫rese de que este c√≥digo ya no est√© envuelto en una transacci√≥n. </p><br><blockquote>  ¬øPor qu√© est√°n bloqueados? <br><br>  Las restricciones √öNICAS y EXCLUIDAS bloquean <em>conflictos potenciales al</em> evitar que se graben al mismo tiempo.  Por ejemplo, si tiene una restricci√≥n √∫nica en una columna de enteros y una transacci√≥n inserta una fila con un valor de 5, se bloquear√°n otras transacciones que tambi√©n intenten insertar 5, pero las transacciones que intenten insertar 6 o 4 tendr√°n √©xito inmediatamente, sin bloqueo.  Dado que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el nivel m√≠nimo de aislamiento de transacci√≥n real de PostgreSQL</a> es <code>READ COMMITED</code> , una transacci√≥n no tiene derecho a ver cambios no confirmados de otras transacciones.  Por lo tanto, un <code>INSERT</code> con un valor en conflicto no puede ser aceptado o rechazado hasta que la primera transacci√≥n confirme sus cambios (luego la segunda reciba un error de unicidad) o retroceda (entonces la inserci√≥n en la segunda transacci√≥n tendr√° √©xito).  Lea m√°s sobre esto en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo del autor de restricciones EXCLUDE</a> . </blockquote><br><h2 id="predotvraschaem-katastrofu-v-buduschem">  Prevenir futuros desastres </h2><br><p>  <em>Ahora</em> sabe que no todo el c√≥digo se puede incluir en una transacci√≥n.  Ser√≠a bueno asegurarse de que nadie m√°s envuelva dicho c√≥digo en una transacci√≥n en el futuro, repitiendo mi error. </p><br><p>  Para hacer esto, puede envolver todas sus operaciones en un peque√±o m√≥dulo auxiliar que verificar√° si la transacci√≥n est√° abierta antes de ejecutar el c√≥digo de operaci√≥n envuelto (aqu√≠ se supone que todas sus operaciones tienen la misma interfaz: el m√©todo de <code>call</code> ). </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#     module NoTransactionAllowed class InTransactionError &lt; RuntimeError; end def call(*) return super unless in_transaction? raise InTransactionError, "#{self.class.name} doesn't work reliably within a DB transaction" end def in_transaction? connection = ApplicationRecord.connection # service transactions (tests and database_cleaner) are not joinable connection.transaction_open? &amp;&amp; connection.current_transaction.joinable? end end #    class Deps::Import &lt; BaseService prepend NoTransactionAllowed def call do_import rescue ActiveRecord::RecordNotUnique retry end end</span></span></code> </pre> <br><p>  Ahora, si alguien intenta envolver un servicio <em>peligroso</em> en una transacci√≥n, recibir√° inmediatamente un error (a menos que, por supuesto, lo mantenga en silencio). </p><br><h2 id="itogi">  Resumen </h2><br><p>  La principal lecci√≥n que se debe aprender: tenga cuidado con las excepciones.  No maneje todo en una fila, capture solo aquellas excepciones que sepa c√≥mo manejar y deje que el resto llegue a los registros.  Nunca ignore las excepciones (solo si no est√° 100% seguro de por qu√© est√° haciendo esto).  Cuanto antes se note un error, m√°s f√°cil ser√° depurarlo. </p><br><p>  Y no exagere con las transacciones en la base de datos.  Esto no es una panacea.  Use nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aislador de</a> gemas y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">after_commit_everywhere</a> : ayudar√°n a que sus transacciones sean completamente infalibles. </p><br><h2 id="chto-pochitat">  Que leer </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Ruby excepcional</em></a> <em>de Avdi Grimm</em> .  Este breve libro le ense√±ar√° c√≥mo manejar las excepciones existentes en Ruby y c√≥mo dise√±ar adecuadamente un sistema de excepciones para su aplicaci√≥n. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://brandur.org/"><em>Uso de transacciones at√≥micas para</em></a> impulsar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://brandur.org/"><em>una API idempotente</em></a> por @Brandur.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Su blog tiene</a> muchos art√≠culos √∫tiles sobre la confiabilidad de la aplicaci√≥n, Ruby y PostgreSQL. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418147/">https://habr.com/ru/post/es418147/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418137/index.html">Sed de sangre: entrevista con el fundador de DonorSearch</a></li>
<li><a href="../es418139/index.html">Soluci√≥n num√©rica de modelos matem√°ticos de objetos dados por sistemas de ecuaciones diferenciales.</a></li>
<li><a href="../es418141/index.html">RE: Ghat / AFR Principiante Skipper Race</a></li>
<li><a href="../es418143/index.html">PVS-Studio como una soluci√≥n SAST</a></li>
<li><a href="../es418145/index.html">La primera demanda contra Roskomnadzor de una compa√±√≠a que sufri√≥ cuando Telegram fue bloqueado</a></li>
<li><a href="../es418149/index.html">Phishing con etiqueta de t√≠tulo</a></li>
<li><a href="../es418151/index.html">Introducci√≥n a la tarea de reconocer las emociones.</a></li>
<li><a href="../es418153/index.html">Kolesa Android Meetup Video: Acerca de MVVM, Antipatterns y Desarrollo modular</a></li>
<li><a href="../es418155/index.html">Diodo LED Diodo Zener</a></li>
<li><a href="../es418157/index.html">El libro "Objetos elegantes. Edici√≥n Java ¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>