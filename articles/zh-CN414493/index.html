<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👉🏽 💰 👞 如何在5分钟内为ICO编写智能合约 🌡️ 🦄 🚜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好！ 在本文中，我将告诉您如何在5分钟内在以太坊上启动ICO的智能收款合同，并在终端中执行几个命令。 本文将为您节省数万美元，因为任何程序员（而不是程序员）都可以启动经过审计且安全的智能合约（而不是支付15,000美元至75,000美元的开发费用）。 简而言之，您可以向该智能合约汇款，并为其接收...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何在5分钟内为ICO编写智能合约</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414493/"><img src="https://habrastorage.org/webt/rv/6d/_c/rv6d_cyxk3ix-su6le9q4lyqntc.png"><br><br> 大家好！ 在本文中，我将告诉您如何在5分钟内在以太坊上启动ICO的智能收款合同，并在终端中执行几个命令。 本文将为您节省数万美元，因为任何程序员（而不是程序员）都可以启动经过审计且安全的智能合约（而不是支付15,000美元至75,000美元的开发费用）。 简而言之，您可以向该智能合约汇款，并为其接收ERC20令牌。 可以说，本文是我通过为项目启动ICO获得的所有经验的集合。 <br><br> 在Internet上，您的这些书中已经充斥着有关智能合约的文章，但是一旦您开始撰写有关智能合约的文章，就会发现一个事实，即信息无处不在，并且根本没有关于如何欺骗ERC20的教程，或者它们已经过时了。 顺便说一下，为了使本文保持相关性，我将尝试指出它可能已过时的潜在位置（以及解决方法）。 走吧 <br><a name="habracut"></a><br><h2> 坚固性 </h2><br> 这是开菲尔团队开发的用于启动智能合约的主要语言的名称。 如果您是一名程序员，那么只需遍历<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该语言</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a> -这很简单。 顺便说一句，他们简化了工作，因此在编写智能合约时更容易出错。 因此， <b>绝对是任何</b>程序员，至少是初级的程序员，都可以弄清楚这一点。 向知道稳定性的开发人员支付巨额资金<b>绝对没有</b>意义-培训现有开发人员会便宜一个数量级。 <br><br><h2> 智能合约 </h2><br>  ...以及您需要了解的所有信息。 如果您不是程序员，请跳过本节。 智能合约是一段代码。 原则上，这是实体类（OOP，是），它具有两种类型的功能：状态更改和非状态更改。 好吧，为了仅通过向其发送开菲尔在智能合约中运行功能，就需要将此功能标记为<code>payable</code>功能。 <br><br> 国家是一个数据仓库，区块链，EPT。 合同可以更改区块链（状态，存储）-但是要更改区块链，您需要向开采矿者支付开菲尔。 在本文的框架中不会分析他们如何分享开菲尔。 向矿工支付运行状态更改代码的费用称为天然气。 如果有人从外部将开菲尔扔到智能合约的地址上，并且调用了一个标记为<code>payable</code>但未标记为<code>Constant</code> ， <code>View</code>或<code>Pure</code>的函数，那么将从发送的金额中扣除开菲尔支付给矿工的必要金额。 通常，在ERC20令牌中，这些功能要么发出开菲尔的令牌发送者，要么将令牌从一个令牌持有者转移到另一个令牌持有者。 <br><br> 而且，如果您在合同中用“ <code>Constant</code>或“ <code>View</code> （它们表示相同的内容，它们只允许您读取状态）或“ <code>Pure</code> （相同的内容，甚至不读取状态）字样标记功能，那么您甚至不需要在该功能上花费开菲尔！ 我什至还要说更多的是这些功能不需要通过事务来调用-毕竟，任何酸奶客户理论上都可以在家执行它-而且没有人需要知道这一点（毕竟，什么都没有写到区块链上）。 <br><br> 稳固性有两个重要方面：多重继承和函数修饰符。 您还需要了解它们。 <br><br> 第一个合同可以同时从多个类（如<code>TimedCrowdsale</code> ， <code>CappedCrowdsale</code> ， <code>MintedCrowdsale</code> ， <code>Ownable</code>继承，同时，构造函数的功能也会一个接一个地启动-但我将在后面举例说明。 <br><br> 第二个是创建功能的能力，然后将这些功能插入其他功能。 就像简单的封装一样，只是稍微灵活一点-它实际上是<b>一个</b>函数<b>模板</b> 。 创建修饰符时，请写特殊字符<code>_</code> ，表示使用该修饰符的函数代码。 也就是说，修饰符不仅仅是返回值的封装功能。 当使用修饰符将字面意义上的修饰符代码插入函数时，这是一个函数模板。 <br><br> 让我们继续练习。 <br><br><h2> 烹饪环境 </h2><br> 如果您不知道终端机是什么，请<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文</a> 。 如果您在Windows上，请通过WLS设置终端。 如果您已经熟悉终端，让我们继续。 另外，立即<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将自己放到</a> Node.js中-接下来的步骤将是必需的。 最好安装LTS，但实际上，安装哪种现代版本没有什么区别。 <br><br> 我们立即安装并启动块同步过程的第一件事是<code>geth</code> 。 简而言之，这是一个用Go编写的实用程序，它将使我们能够在本地计算机上运行以太节点，并连接到测试和真实网络。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过安装程序进行安装</a> ，但我强烈建议您立即在Terminal中安装，如此处所述。 您可以<code>geth</code>在终端中运行以下命令来检查您的<code>geth</code>标准是否<code>geth</code> ： <br><br><pre> <code class="bash hljs">geth version</code> </pre> <br> 如果您不喜欢geth版本-一切都在镂空中，请继续学习本教程。 如果不是-不好，请纠正； 看来您必须与终端机和操作系统做爱-但这不是您第一次了解它。 如何安装geth，在终端中运行命令： <br><br><pre> <code class="bash hljs">geth --testnet console</code> </pre> <br> 这将启动将节点与测试服务器同步的过程，可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>查看其块。 您可以通过以下命令在<code>geth</code>控制台中检查是否与网络同步： <br><br><pre> <code class="bash hljs">eth.blockNumber <span class="hljs-comment"><span class="hljs-comment">#  0 —     eth.syncing #     false,    </span></span></code> </pre> <br> 同步过程使我花了1到4个小时-什么时候开始。 另外，除了块同步之外，您还必须等待状态同步-它通常比块同步长。 您还可以将<code>geth</code>与<code>--light</code>标志一起使用-然后同步持续几秒钟到一分钟，您仍然可以部署合同。 <br><br> 好的，我们安装了第一个实用程序-放下一个。 我们需要模拟一个<code>geth</code>的模拟，只是一个非常本地的<code>testrpc</code>链模拟<code>testrpc</code> 。 是的，我们有<b>3个区块链</b> ： <br><br><ul><li>  <code>testrpc</code>本地<code>testrpc</code>链模拟; 快速，但是伪造的，仅存储在您的计算机上 </li><li>  <code>geth --testnet</code>已经是一个真正的<code>geth --testnet</code>链，但是您不会在这里亏损，可以免费获得开菲尔和测试<code>geth --testnet</code> </li><li>  geth-主网，主，真实区块链，真实开菲尔; 都是以成人的方式，这里的错误是真正的开菲尔酒的损失 </li></ul><br> 因此，我们将使用<code>testrpc</code>启动测试合同，然后将其安装在<code>geth --testnet</code> ，然后直接在<code>geth</code>下载它。 <br><br> 我们通过运行以下命令来<code>testrpc</code> ： <br><br><pre> <code class="bash hljs">npm install -g ethereumjs-testrpc</code> </pre> <br> 好吧，或者它随松露一起上升，因为现在<code>testrpc</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在松露翼下</a> ，被称为<code>ganache-cli</code> 。 尽管魔鬼知道，但使用vanilla <code>testrpc</code>一切<code>testrpc</code> 。 而且如果它可行，请不要触摸它，就像我在银河系学院所教过的那样。 您也可以通过在控制台中注册<code>truffle</code>来运行它以验证安装，但是测试区块链已经与我们同步-让我们不要打扰它。 <br><br> 好了，找出了区块链吗？ 现在有节点并且测试甚至是同步的？ 我们使用以下命令在kefir- <code>truffle</code>上放置了一个方便的实用程序来处理智能合约： <br><br><pre> <code class="bash hljs">npm install -g truffle truffle version <span class="hljs-comment"><span class="hljs-comment">#  ,  ,  </span></span></code> </pre> <br> 松露是一种工具，可让您将智能合约保存在不同的文件中，导入其他文件，并将智能合约代码编译为一个大字节码（人无法读取），它会自动查找本地运行的<code>geth</code> （测试和真实） ）或<code>testrpc</code> ，将智能合约部署到该网络。 此外，检查您的智能合约代码中是否有错误，并且最近完成的交易<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">也有助于调试</a> 。 简而言之，刊头。 <br><br> 在这一阶段，您应该已经安装： <code>testrpc</code> ， <code>geth</code> ， <code>testrpc</code> －如果其中任何一个丢失或版本未根据要求吐出到控制台，则请更正此错误。 否则，您将不会成功。 <br><br><blockquote> 另外，我抛出了一个简单的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bash脚本</a> ，它将为您安装所有内容。 这样称呼： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">source</span></span> &lt;(curl -s https://raw.githubusercontent.com/backmeupplz/eth-installer/master/install.sh)</code> </pre> <br>  -但我尚未对其进行测试，因此我不确定其性能。 不过，我很乐意提出要求。 </blockquote><br><h2> 菲加什合同 </h2><br> 一切都已经发明出来，可以为您编写-很好。 一点点彩旗都是一样的-但我会尽力将其最小化。 我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来自OpenZeppelin的现成的ERC20合同</a> -这已成为行业标准，它们已通过审核，并且确实都使用了其代码。 非常感谢您对开源的贡献。 <br><br> 使<code>cd</code>进入一些安全文件夹，然后输入： <br><br><pre> <code class="bash hljs">mkdir contract &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> contract</code> </pre> <br> 在此文件夹中，我们将工作。 在此处为我们的智能合约创建存根： <br><br><pre> <code class="bash hljs">truffle init</code> </pre> <br> 清楚地跌倒了。 现在，我们有两个非常重要的文件夹可供选择： <code>contracts</code>和<code>migrations</code> 。 第一个是我们合同的代码，第二个是松露的代码，以了解将合同部署到区块链时该怎么做。 <br><br> 接下来，我们需要从npm中获取当前的智能合约代码，并且实际上启动项目本身： <br><br><pre> <code class="bash hljs">npm init -y <span class="hljs-comment"><span class="hljs-comment">#     ( -y) npm install -E openzeppelin-solidity #       ( -E)</span></span></code> </pre> <br> 好吧，来自OpenZeppelin的智能合约代码位于我们的口袋中的<code>node_modules/openzeppelin-solidity/contracts</code>文件夹中。 现在，我们转到主<code>contracts</code>文件夹，删除其中的所有文件，然后添加文件<code>MyToken.sol</code>和<code>MyCrowdsale.sol</code>自然，您将以不同的方式命名合同。 第一个将是我们的ERC20代币的合同，第二个将是我们的ICO的合同，它将接受开<code>MyToken</code>并将<code>MyToken</code>人们。 本文可能已过时，但是您始终可以查看OpenZeppelin如何建议您<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在其存储库中</a>创建合同。 这就是<code>MyToken.sol</code>样子： <br><br><pre> <code class="javascript hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Imports import "../node_modules/openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol"; // Main token smart contract contract MyToken is MintableToken { string public constant name = "My Token"; string public constant symbol = "MTKN"; uint8 public constant decimals = 18; }</span></span></code> </pre> <br> 不错-您拥有自己的令牌智能合约（只需更改常量中的名称）！ 您可以看到<code>MintableToken</code>有什么<code>MintableToken</code>继承-但是那里的一切都尽可能简单。 这是可以发行的令牌（从英文“ Mint”到薄荷），并且只有所有者才有权发行，因为<code>MintableToken</code>也是从<code>Ownable</code>继承的。 另外， <code>MintableToken</code>还继承了OpenZeppelin编写的ERC20令牌类，其中实现了ERC20接口： <br><br><pre> <code class="javascript hljs">contract ERC20Basic { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">totalSupply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">balanceOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address who</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transfer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address to, uint256 value</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bool</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">event</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Transfer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address indexed from, address indexed to, uint256 value</span></span></span><span class="hljs-function">); }</span></span></code> </pre> <br> 是的，这里您拥有整个ERC20界面。 有困难吗？ 我不这么认为。 它使您有机会查看发出的令牌数量，检查地址余额并通过为网络上的轻质开菲尔客户吐出转移事件来将令牌转移到另一个地址。 由于<code>MyToken.sol</code>的工作，您可以在<code>MyToken.sol</code>免费获得所有这些功能-它们很棒。 <br><br> 现在让我们继续进行ICO的主要部分-我们需要接受开<code>MyToken</code>并发出<code>MyToken</code> ！ 这是您的<code>MyCrowdsale.sol</code>样子： <br><br><pre> <code class="javascript hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Imports import "../node_modules/openzeppelin-solidity/contracts/crowdsale/emission/MintedCrowdsale.sol"; import "../node_modules/openzeppelin-solidity/contracts/crowdsale/distribution/RefundableCrowdsale.sol"; import "../node_modules/openzeppelin-solidity/contracts/crowdsale/validation/CappedCrowdsale.sol"; import "../node_modules/openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol"; contract MyCrowdsale is CappedCrowdsale, RefundableCrowdsale, MintedCrowdsale { constructor( uint256 _openingTime, uint256 _closingTime, uint256 _rate, address _wallet, uint256 _cap, MintableToken _token, uint256 _goal ) public Crowdsale(_rate, _wallet, _token) CappedCrowdsale(_cap) TimedCrowdsale(_openingTime, _closingTime) RefundableCrowdsale(_goal) { //   ,  ,    // ,     require(_goal &lt;= _cap); } }</span></span></code> </pre><br> 一般般，我们怎么了？ 什么，男孩，智能合约？ 我们的代币公开销售继承了三个最受欢迎的属性：它具有硬上限，无法再收集； 软顶，不收集返回的酯类； 代币销售开始和结束的时间。 事实上，幸福还需要什么？ <br><br> 程序员请注意，如何将多个继承类的构造函数排成一行，并从<code>MyCrowdsale</code>的主要构造函数获取参数。 另外，我们检查硬键是否高于软键-Ales Gut！ 同样，不要被<code>MyCrowdsale</code>构造函数中<code>MyCrowdsale</code>参数所<code>MyCrowdsale</code> -我们将在松露中的合同部署阶段传递它们。 <br><br> 仅此而已-您拥有自己的ERC20代币的现成合同，甚至还有ICO智能合约，该智能合约均根据您的需求进行配置，并为开菲尔提供代币。 而且，所有ERC20钱包都支持它-一个大错！ 让我们继续进行手动测试和部署。 <br><br><h2> 移居 </h2><br> 正如我之前所说，我们将在三个区块链网络上进行顺序测试，但是使用笔进行测试的过程将始终相同。 让我们从<code>testrpc</code>开始，然后进入<code>geth --testnet</code>并继续<code>geth</code> 。 搜大灯，我们只是编写了代码，让我们尝试对其进行编译。 在项目文件夹中，输入： <br><br><pre> <code class="bash hljs">truffle compile</code> </pre> <br> 如果一切编译都没有问题，那么您将看到<code>build</code> ，其中将包含松露的krakozyab，以便它将智能合约的字节码嵌入到区块链中。 在部署智能合约之前，我们需要告诉松露该做什么。 智能合约的松露部署称为迁移-好吧，让我们坚持这个术语。 转到<code>migrations/1_initial_migration.js</code>并按以下方式进行更改： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> token = artifacts.require(<span class="hljs-string"><span class="hljs-string">"../contracts/MyToken.sol"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> crowdsale = artifacts.require(<span class="hljs-string"><span class="hljs-string">"../contracts/MyCrowdsale.sol"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">deployer, network, accounts</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> openingTime = <span class="hljs-number"><span class="hljs-number">1514764800</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 15  2018 const closingTime = 1561939200; // 1  2019 const rate = new web3.BigNumber(1); // 1   1  const wallet = '0x281055afc982d96fab65b3a49cac8b878184cb16'; // - const cap = 200 * 1000000; //  const goal = 100 * 1000000; //  return deployer .then(() =&gt; { return deployer.deploy(token); }) .then(() =&gt; { return deployer.deploy( crowdsale, openingTime, closingTime, rate, wallet, cap, token.address, goal ); }) .then(() =&gt; { // Crowdsale    var tokenContract = web3.eth.contract(token.abi).at(token.address); web3.eth.defaultAccount = web3.eth.accounts[0]; tokenContract.transferOwnership(crowdsale.address); }); };</span></span></code> </pre> <br> 松露将使用该文件来部署合同。 那我们在这里做什么？ 首先，我们要求编译<code>MyToken</code>和<code>MyCrowdsale</code> 。 之后，我们使用ICO的所有参数设置常量-设置开始和结束时间； 人们将获得1千开菲尔的代币数量（0.000000000000000001 eth = 1 wei；设置<code>decimals</code>表示获得1个新制作的代币需要多少wei）； 从销售中获得的开菲尔的钱包； 硬顶和软顶。 请注意， <code>openingTime</code>应该始终在区块链中当前块的时间之后–否则，由于检查<code>TimedCrowdsale</code>的条件，您的智能合约将不会被阻止。 我踩了一把耙子，失败的交易根本无法扣账。 根据需要更改这些常数。 <br><br> 下一步就是部署智能合约。 这里没什么有趣的：我们有一个<code>deployer</code>对象，该对象部署智能合约工件并在此处传递参数。 请注意，首先<code>MyToken</code> MyToken，然后才<code>MyToken</code> MyCrowdsale-第一个的地址在第二个作为参数传递。 <br><br> 然后，最有趣的是他们在文档或书籍中没有写的内容。 当您从钱包创建<code>MyToken</code> ，此钱包将成为<code>Ownable</code>超类中<code>MyToken</code>的所有者<code>MyToken</code> <code>Ownable</code>发生相同的情况。 如果深入研究<code>MintableToken</code> ，您会看到只有<code>Owner</code>才能铸造硬币！ 谁是<code>MyToken</code>的所有者？ 是的：让他不高兴的地址。 谁将发送铸造硬币的请求？ 正确： <code>MyCrowdsale</code>智能合约。 让我提醒您，创建<code>MyToken</code>和<code>MyCrowdsale</code>的地址是两个不同的地址。 <br><br> 因此，我们将添加非正统的第三部署步骤，在该步骤中，已<code>web3.eth.accounts[0]</code>的地址（ <code>web3.eth.accounts[0]</code> ）调用<code>MyToken</code>合同上的<code>transferOwnership</code>函数， <code>MyToken</code> <code>MyCrowdsale</code>拥有<code>MyToken</code>并可以铸造硬币。 而且<code>MyCrowdsale</code>仍然是<code>web3.eth.accounts[0]</code>的所有者-因此，所有内容都捆绑在一起。 <br><br><blockquote> 关于<code>web3.eth.accounts[0]</code>注意事项：部署智能合约时，请确保geth或testrpc在<code>web3.eth.accounts[0]</code>具有正确的钱包-不要丢失私钥，尽管这不会以任何方式伤害您，但是突然，所有者将需要稍后再做一些事情，但是钥匙不再在那里了？ </blockquote><blockquote>  <code>testrpc</code> ，在<code>testrpc</code> ，帐户在启动时立即创建并立即解锁。 但是，在测试和真实的区块链上，值得通过<code>personal.newAccount()</code>创建一个帐户-然后通过测试区块链上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Faucet</a>或真实区块链上的真实开菲尔来补充该地址。 不要丢失密码和私钥。 </blockquote><blockquote> 另外，您可以通过调用<code>web3.personal.importRawKey('pvt_key', 'password')</code>将现有的钱包添加到您的帐户，但是为此，您需要使用附加参数<code>--rpcapi="db,eth,net,web3,personal,web3"</code> 。 我想您会发现的。 </blockquote><br><h2> 测试与部署 </h2><br> 是的，合同已准备就绪，已编写迁移，仅保留以进行部署和检查。  <code>geth</code> （test和real）和<code>testrpc</code>通过<code>truffle console</code>以相同的方式<code>testrpc</code>管理-因此，我将介绍<code>testrpc</code>的验证方法，只告诉您之后如何启用<code>geth</code> 。 因此，我们启动了测试本地开菲尔区块链： <br><br><pre> <code class="bash hljs">testrpc</code> </pre> <br> 嗯...仅此而已。 您在本地模拟开菲尔区块链。 <br><br><blockquote> 为了将其部署到测试以太区块链，而不是此命令，您将得到<code>geth --testnet --rpc</code> 。 为了部署到以太<code>geth --rpc</code>的真实<code>geth --rpc</code>链中，您只需<code>geth --rpc</code> 。 需要<code>--rpc</code>标志，以便松露可以连接。 对于所有三种类型的区块链，以下部署和测试步骤大致相同。 唯一的事情是，通过<code>geth</code>运行测试或真实的区块链之后，它将开始同步块-在良好的Internet连接上，这可能需要多达4-5个小时。 关于此的评论是在本文的开头。 部署智能合约之前，建议您等待完全同步。 此外，区块链的重量约为60-100 GB，因此请为此准备磁盘空间。 </blockquote><blockquote> 同样，请确保<code>web3.eth.accounts[0]</code>解锁。 通常，您可以在立即打开的控制台中或通过<code>geth console</code>打开的控制台中的单独终端窗口中注册<code>testrpc</code> ： <code>eth.unlockAccount(eth.accounts[0], ",    ", 24*3600)</code> -这将解锁您的帐户，这应该创建一个智能合约 </blockquote><br> 现在打开一个新的终端窗口（ <code>testrpc</code>不关闭<code>testrpc</code>它应该可以工作）并将其写入项目文件夹中： <br><br><pre> <code class="bash hljs">truffle migrate --reset</code> </pre> <br> 这个魔术命令将编译一个智能合约（也就是说，您不需要每次都编写<code>truffle compile</code> ）并将其部署到本地开放的区块链微服务器上。 值得注意的是，如果<code>testrpc</code>立即执行此操作，则测试和实际区块链将在更长的下一个区块中包含交易。 之后，您应该在控制台中吐出以下内容： <br><br><pre> <code class="bash hljs">Using network <span class="hljs-string"><span class="hljs-string">'development'</span></span>. Running migration: 1_initial_migration.js Running step... Replacing MyToken... ... 0x86a7090b0a279f8befc95b38fa8bee6918df30928dda0a3c48416454e2082b65 MyToken: 0x2dc35f255e56f06bd2935f5a49a0033548d85477 Replacing MyCrowdsale... ... 0xf0aab5d550f363478ac426dc2aff570302a576282c6c2c4e91205a7a3dea5d72 MyCrowdsale: 0xaac611907f12d5ebe89648d6459c1c81eca78151 ... 0x459303aa0b79be2dc2c8041dd48493f2d0e109fac19588f50c0ac664f34c7e30 Saving artifacts...</code> </pre> <br> 我认为您已经意识到控制台已为您提供了智能合约<code>MyToken</code>和<code>MyCrowdsale</code>的地址。 仅此而已！ 智能合约嵌入在您已打开微服务器的区块链中。 仅需验证令牌是否已真正分发给将开<code>MyCrowdsale</code>发送给<code>MyCrowdsale</code>智能合约的用户。 我们在终端中输入以下内容以进入松露控制台： <br><br><pre> <code class="bash hljs">truffle console</code> </pre> <br> 我们在现在的松露中写下以下内容（仅无评论）： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   - t="0x2dc35f255e56f06bd2935f5a49a0033548d85477" //     MyToken ="0xaac611907f12d5ebe89648d6459c1c81eca78151" //     MyCrowdsale //   - token=MyToken.at(t) crowdsale=MyCrowdsale.at(c) //       account=web3.eth.accounts[0] // ,      token.balanceOf(account) //   0 //    - web3.eth.sendTransaction({from: account, to:c, value: web3.toWei(0.1, 'ether'), gas: 900000})</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，</font></font><code>testrpc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以立即再次检查我们钱包的余额，但是在测试和真实区块链的情况下，您需要等待直到我们的交易被包含在区块中-通常在这种情况发生时，松露为您提供交易号。你等了吗再次检查我们的余额</font></font><code>MyToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,      token.balanceOf(account) //    </span></span></code> </pre> <br> 仅此而已！<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先在上测试您的合同</font></font><code>testrpc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后在上进行</font><font style="vertical-align: inherit;">测试</font><font style="vertical-align: inherit;">，然后在上</font></font><code>geth --testnet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行部署</font></font><code>geth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。因此，您启动了自己的ICO！而且，您不必花费数十万美元来进行审核和发布。搞砸OpenZeppelin的家伙为我们提供的东西实际上是非常困难的。而且，当您使用它时</font></font><code>truffle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这就是团结发展通常变成童话故事的方式。好吧，除了在智能合约执行过程中交易发生逆转的情况外，请首次亮相。但是，智能合约的调试确实值得单独写一篇文章。</font></font><br><br><h2> 结论 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常感谢您阅读本文结尾！如果我设法节省您的时间或金钱，或者您从本文中学到了新的知识，那么我将对此感到非常高兴。如果您与想进行ICO的朋友或熟人分享这篇文章，我也将不胜感激-为那些从寄生虫等领域从加密货币市场吸取金钱，复制粘贴相同25行代码的编程人员节省75,000美元。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开发智能合约的好运！还有问题吗？我想在评论中问您-我很乐意回答所有问题，并尝试解决问题。</font></font><br><br><h2> 红利 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果您想改变考虑代币购买价格的逻辑怎么办？</font><font style="vertical-align: inherit;">当然，您可以正确地更改它，也可以</font></font><code>rate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用OpenZeppelin的其中一类合同，但是如果您想要更变态的东西怎么办？</font><font style="vertical-align: inherit;">在智能合约中，您可以</font></font><code>getTokenAmount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按以下</font><font style="vertical-align: inherit;">方式覆盖该功能</font><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_getTokenAmount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256 _weiAmount</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (block.timestamp &lt; <span class="hljs-number"><span class="hljs-number">1533081600</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// August 1st, 2018 rate = rate * 4; } else if (block.timestamp &lt; 1546300800) { // January 1st, 2019 rate = rate * 2; } return _weiAmount.mul(rate); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常，这会使令牌的价格取决于购买时间-进入森林越远，令牌就越昂贵。</font><font style="vertical-align: inherit;">不要害怕尝试并重写智能合约的某些功能-这很有趣！</font></font><br><br><img src="https://habrastorage.org/webt/3a/mp/lk/3amplkx2fhpeplqauietmgshkc8.png"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN414493/">https://habr.com/ru/post/zh-CN414493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN414481/index.html">星期五的PHP测验：程序员Brad的一些历险，一个奇怪的序列和奖品</a></li>
<li><a href="../zh-CN414483/index.html">在Kotlin上输入Safe SQL</a></li>
<li><a href="../zh-CN414485/index.html">GNMT，史诗般的失败或机器翻译的微妙之处</a></li>
<li><a href="../zh-CN414487/index.html">暴力类型的罕见代表：一次攻击的历史</a></li>
<li><a href="../zh-CN414489/index.html">美国计划认真解决太空碎片问题</a></li>
<li><a href="../zh-CN414495/index.html">toString：伟大而可怕</a></li>
<li><a href="../zh-CN414497/index.html">Consulo UI API从构思到原型</a></li>
<li><a href="../zh-CN414499/index.html">《 2018年罗马俱乐部报告》，第1.1.3章：“空虚的世界与充分的和平”</a></li>
<li><a href="../zh-CN414501/index.html">《 2018年罗马俱乐部报告》，第3.11章：“金融部门改革”</a></li>
<li><a href="../zh-CN414503/index.html">带有AMD Vega Graphics的英特尔NUC Hades Canyon-VR还是不是VR？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>