<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Ingenier铆a inversa del popular BattlEye anti-trampa   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="BattlEye es predominantemente un anti-enga帽o de un tercero alem谩n, desarrollado principalmente por Bastian Heiko Suter , de 32 a帽os. Proporciona (o in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ingenier铆a inversa del popular BattlEye anti-trampa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483068/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ps/ae/ij/psaeijpcayldgrqiqeiq6l83nue.jpeg"></div><br>  BattlEye es predominantemente un anti-enga帽o de un tercero alem谩n, desarrollado principalmente por <em>Bastian Heiko Suter</em> , de 32 a帽os.  Proporciona (o intenta proporcionar) a los editores de juegos un sistema anti-trampa f谩cil de usar que utiliza mecanismos de protecci贸n generales, as铆 como la detecci贸n de trampas para juegos espec铆ficos para optimizar la seguridad.  Como se indica en el sitio web del producto, siempre se mantiene en la cima de la tecnolog铆a moderna y utiliza m茅todos innovadores de protecci贸n y detecci贸n;  obviamente esto es consecuencia de la nacionalidad del desarrollador: <code>QUALITY MADE IN GERMANY</code> .  BattlEye consta de muchos elementos que trabajan juntos para encontrar tramposos en los juegos que han pagado por el uso del producto.  Los cuatro elementos principales son: <br><br><ul><li>  BEService <ul><li>  Un servicio del sistema de Windows que se comunica con el servidor BattlEye <em>BEServer</em> , que proporciona comunicaci贸n cliente-servidor con <em>BEDaisy</em> y <em>BEClient</em> . </li></ul></li><li>  BEDaisy <ul><li>  Un controlador de kernel de Windows que registra mecanismos de procesamiento de eventos preventivos y mini filtros para evitar que los tramposos modifiquen ilegalmente el juego </li></ul></li><li>  Becient <ul><li>  Una biblioteca de Windows conectada din谩micamente que es responsable de la mayor铆a de los vectores de detecci贸n, incluidos los descritos en este art铆culo.  Despu茅s de la inicializaci贸n, se adjunta al proceso del juego. </li></ul></li><li>  Beserver <ul><li>  Servidor backend patentado, responsable de recopilar informaci贸n y tomar medidas espec铆ficas contra los tramposos. </li></ul></li></ul><br><h1>  Shellcode </h1><br>  Recientemente, un volcado del c贸digo de shell BattlEye apareci贸 en Internet, y decidimos escribir sobre lo que est谩 buscando exactamente la versi贸n actual de BattlEye.  No analizamos BattlEye durante seis meses, por lo que nuestro 煤ltimo volcado del shellcode probablemente est茅 desactualizado.  Varias partes del c贸digo se recuperaron solo de la memoria de este 煤ltimo volcado, suponiendo que BattlEye solo complet贸 el c贸digo de shell y no elimin贸 los procedimientos de detecci贸n anteriores. <br><a name="habracut"></a><br><h1>  Como? </h1><br>  BattlEye supuestamente transmite c贸digo shell desde su servidor a un servicio de Windows llamado BEService.  Este servicio se comunica con el m贸dulo BEClient ubicado dentro del juego.  El intercambio de datos se realiza a trav茅s de la <code>\.namedpipeBattleye</code> y hasta 2018 no se cifr贸.  Ahora, todos los datos transmitidos se cifran con un xor-encryptor con claves muy peque帽as, lo que hace que sea extremadamente f谩cil realizar ataques de texto sin formato conocidos.  Cuando el c贸digo de shell se transmite al cliente, se ubica y ejecuta fuera de todos los m贸dulos conocidos, lo que facilita su determinaci贸n.  Para crear un volcado de shellcode, puede procesar las funciones est谩ndar de la API de Windows, como CreateFile, ReadFile, etc., y volcar el 谩rea de memoria correspondiente de todos los m贸dulos de llamada (solicitando informaci贸n de memoria para la direcci贸n devuelta) que est谩n fuera de todos los m贸dulos conocidos, o escanee peri贸dicamente el espacio de memoria virtual del juego en busca de memoria ejecutable fuera de todos los m贸dulos conocidos, y vu茅lvala al disco.  Al mismo tiempo, debe realizar un seguimiento de las 谩reas que ya se han volcado, de modo que no obtendr谩 muchos volcados id茅nticos. <br><br><h1>  Explicaci贸n </h1><br>  Los fragmentos de pseudoc贸digo presentados en el art铆culo est谩n <strong>fuertemente</strong> modificados por el bien de la belleza.  No podr谩 volcar el c贸digo de shell BattlEye e inmediatamente reconocer estas partes;  el shellcode no contiene llamadas a funciones, y se implementan muchos algoritmos en el art铆culo.  Pero, de hecho, esto no es importante, porque cuando termine de leer sobre esta terrible antig眉edad, tendr谩 la oportunidad de sortearla (: <br><br><h2>  Clasificaci贸n de memoria </h2><br>  El mecanismo de detecci贸n m谩s com煤n en anti-trampas es la enumeraci贸n de memoria y el escaneo de memoria para buscar im谩genes de trampas <em>conocidas</em> .  Es f谩cil de implementar y, como se muestra en el pasado, con el enfoque correcto, es bastante efectivo si no ha olvidado los conceptos b谩sicos del ensamblador y ha incluido en la lista negra el pr贸logo de una funci贸n com煤n. <br><br>  Battleye itera sobre todo el espacio de direcciones del proceso del juego (el proceso actual en este contexto) y realiza varias comprobaciones sobre el rendimiento de la p谩gina y encuentra el c贸digo de shell fuera del espacio de memoria correspondiente. <br><br>  As铆 es como se implementa en Battleye: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// MEMORY ENUMERATION for (current_address = 0 // QUERY MEMORY_BASIC_INFORMATION NtQueryVirtualMemory(GetCurrentProcess(), current_address, 0, &amp;memory_information, 0x30, &amp;return_length) &gt;= 0 current_address = memory_information.base_address + memory_information.region_size) { const auto outside_of_shellcode = memory_information.base_address &gt; shellcode_entry || memory_information.base_address + memory_information.region_size &lt;= shellcode_entry const auto executable_memory = memory_information.state == MEM_COMMIT &amp;&amp; (memory_information.protect == PAGE_EXECUTE || memory_information.protect == PAGE_EXECUTE_READ || memory_information.protect == PAGE_EXECUTE_READWRITE const auto unknown_whitelist = memory_information.protect != PAGE_EXECUTE_READWRITE || memory_information.region_size != 100000000 if (!executable_memory || !outside_of_shellcode || !unknown_whitelist) continue // RUN CHECKS memory::anomaly_check(memory_information memory::pattern_check(current_address, memory_information memory::module_specific_check_microsoft(memory_information memory::guard_check(current_address, memory_information memory::module_specific_check_unknown(memory_information }</span></span></code> </pre> <br><h1>  Anomal铆as de memoria </h1><br>  BattlEye marca todas las anomal铆as en el espacio de direcciones de memoria, principalmente la memoria de m贸dulos ejecutables que no corresponden a la imagen cargada: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> memory::anomaly_check(MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-comment"><span class="hljs-comment">// REPORT ANY EXECUTABLE PAGE OUTSIDE OF KNOWN MODULES if (memory_information.type == MEM_PRIVATE || memory_information.type == MEM_MAPPED) { if ((memory_information.base_address &amp; 0xFF0000000000) != 0x7F0000000000 &amp;&amp; // UPPER EQUALS 0x7F (memory_information.base_address &amp; 0xFFF000000000) != 0x7F000000000 &amp;&amp; // UPPER EQUALS 0x7F0 (memory_information.base_address &amp; 0xFFFFF0000000) != 0x70000000 &amp;&amp; // UPPER EQUALS 0x70000 memory_information.base_address != 0x3E0000)) { memory_report.unknown = 0 memory_report.report_id = 0x2F memory_report.base_address = memory_information.base_address memory_report.region_size = memory_information.region_size memory_report.memory_info = memory_information.type | memory_information.protect | memory_information.state battleye::report(&amp;memory_report, sizeof(memory_report), 0 } } }</span></span></code> </pre> <br><h1>  Escaneo de patrones </h1><br>  Como se mencion贸 anteriormente, BattlEye tambi茅n escanea la memoria de los procesos locales en busca de varios patrones claramente definidos, como se puede ver en la implementaci贸n que se muestra a continuaci贸n. <br><br>  Al leer este pseudoc贸digo, puede adivinar que <strong>estas comprobaciones pueden eludirse</strong> reescribiendo el 谩rea de c贸digo de cada m贸dulo cargado, ya que no escanear谩n en busca de patrones en im谩genes conocidas.  Para no caer en las verificaciones de integridad, debe descargar todas las 谩reas empaquetadas y en la lista blanca y volver a escribir las 谩reas de c贸digo marcadas como <em>RWX</em> , porque no podemos realizar verificaciones de integridad sin emular el empaquetador.  En la versi贸n actual del c贸digo de shell BattlEye, estos patrones de memoria est谩n codificados: <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span>] ojectsPUBGChinese [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>] BattleGroundsPrivate_CheatESP [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>] [%<span class="hljs-number"><span class="hljs-number">.0</span></span>fm] %s [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>E] <span class="hljs-number"><span class="hljs-number">0000</span></span>Neck0000Chest0000000Mouse <span class="hljs-number"><span class="hljs-number">10</span></span> [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">3F</span></span>] PlayerESPColor [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span>] Aimbot: %d02D3E2041 [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span>] HackMachine [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>A] VisualHacks.net [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span>] <span class="hljs-number"><span class="hljs-number">3E232</span></span>F653E31314E4E563D4276282A3A2E463F757523286752552E6F30584748 [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">4F</span></span>] DLLInjection-master\x64\Release\ [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">52</span></span>] NameESP [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">48</span></span>] Skullhack [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">55</span></span>] .rdata$zzzdbg [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">39</span></span>] AimBot [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">39</span></span>] EB4941803C123F755C623FEB388D41D0FBEC93C977583E930EB683E1DF [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">5F</span></span>] <span class="hljs-number"><span class="hljs-number">55E9</span></span> [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">5F</span></span>] <span class="hljs-number"><span class="hljs-number">57E9</span></span> [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">5F</span></span>] <span class="hljs-number"><span class="hljs-number">60E9</span></span> [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">68</span></span>] D3D11Present initialised [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>E] [ %<span class="hljs-number"><span class="hljs-number">.0</span></span>fM ] [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">74</span></span>] [hp:%d]%dm [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span>] <span class="hljs-number"><span class="hljs-number">48836424380488</span></span>D4C2458488B5424504C8BC848894C24304C8BC7488D4C2460 [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span>] <span class="hljs-number"><span class="hljs-number">741F</span></span>BA80000FF15607E0085C07510F2F1087801008B8788100EB [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span>] <span class="hljs-number"><span class="hljs-number">40F</span></span>2AA156F8D2894E9AB4489535D34F9CPOSITION0000COL [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>A] FFE090 [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">79</span></span>] %s00%d00POSITION0000COLOR0000000 [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span>] <span class="hljs-number"><span class="hljs-number">8E85765</span></span>DCDDA452E75BA12B4C7B94872116DB948A1DAA6B948A7676BB948902C [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>A] n&lt;assembly xmlsn=<span class="hljs-string"><span class="hljs-string">'urn:schemas-mi</span></span></code> </pre> <br>  Estos patrones de memoria tambi茅n contienen un encabezado de dos bytes, es decir, el valor est谩tico desconocido <code>05</code> y un identificador 煤nico. <br><br>  Lo que no veremos es que BattlEye tambi茅n transmite din谩micamente patrones desde <em>BEServer</em> y los env铆a a <em>BEClient</em> , pero no discutiremos esto en el art铆culo. <br><br>  Son escaneados iterativamente por el siguiente algoritmo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> memory::pattern_check(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* current_address, MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> is_user32 = memory_information.allocation_base == GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"user32.dll"</span></span> <span class="hljs-comment"><span class="hljs-comment">// ONLY SCAN PRIVATE MEMORY AND USER32 CODE SECTION if (memory_information.type != MEM_PRIVATE &amp;&amp; !is_user32) continue for (address = current_address address != memory_information.base_address + memory_information.region_size address += PAGE_SIZE) // PAGE_SIZE { // READ ENTIRE PAGE FROM LOCAL PROCESS INTO BUFFER if (NtReadVirtualMemory(GetCurrentProcess(), address, buffer, PAGE_SIZE, 0) &lt; 0) continue for (pattern_index = 0 pattern_index &lt; 0x1C/*PATTERN COUNT*/ ++pattern_index) { if (pattern[pattern_index].header == 0x57A &amp;&amp; !is_user32) // ONLY DO FFE090 SEARCHES WHEN IN USER32 continue for (offset = 0 pattern[pattern_index].length + offset &lt;= PAGE_SIZE ++offset) { const auto pattern_matches = memory::pattern_match(&amp;address[offset], pattern[pattern_index // BASIC PATTERN MATCH if (pattern_matches) { // PATTERN FOUND IN MEMORY pattern_report.unknown = 0 pattern_report.report_id = 0x35 pattern_report.type = pattern[index].header pattern_report.data = &amp;address[offset pattern_report.base_address = memory_information.base_address pattern_report.region_size = memory_information.region_size pattern_report.memory_info = memory_information.type | memory_information.protect | memory_information.state battleye::report(&amp;pattern_report, sizeof(pattern_report), 0 } } } } }</span></span></code> </pre> <br><h1>  Validaci贸n de m贸dulos espec铆ficos (Microsoft) </h1><br>  Las verificaciones de m贸dulos informan la presencia de m贸dulos espec铆ficos cargados en el juego: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> memory::module_specific_check_microsoft(MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> executable = memory_information.protect == PAGE_EXECUTE || memory_information.protect == PAGE_EXECUTE_READ || memory_information.protect == PAGE_EXECUTE_READWRITE <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> allocated = memory_information.state == MEM_COMMIT <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!allocated || !executable) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> mmres_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"mmres.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> mshtml_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"mshtml.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mmres_handle &amp;&amp; mmres_handle == memory_information.allocation_base) { battleye_module_anomaly_report module_anomaly_report module_anomaly_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> module_anomaly_report.report_id = <span class="hljs-number"><span class="hljs-number">0x5B</span></span> module_anomaly_report.identifier = <span class="hljs-number"><span class="hljs-number">0x3480</span></span> module_anomaly_report.region_size = memory_information.region_size battleye::report(&amp;module_anomaly_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(module_anomaly_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mshtml_handle &amp;&amp; mshtml_handle == memory_information.allocation_base) { battleye_module_anomaly_report module_anomaly_report module_anomaly_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> module_anomaly_report.report_id = <span class="hljs-number"><span class="hljs-number">0x5B</span></span> module_anomaly_report.identifier = <span class="hljs-number"><span class="hljs-number">0xB480</span></span> module_anomaly_report.region_size = memory_information.region_size battleye::report(&amp;module_anomaly_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(module_anomaly_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h1>  Comprobaci贸n de m贸dulos espec铆ficos (desconocido) </h1><br>  Se ha agregado una comprobaci贸n de m贸dulos espec铆ficos al sistema, que indica al servidor que ha cargado m贸dulos que satisfacen <em>cualquiera</em> de estos criterios: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> memory::module_specific_check_unknown(MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> dos_header = (DOS_HEADER*)module_handle <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pe_header = (PE_HEADER*)(module_handle + dos_header-&gt;e_lfanew <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> is_image = memory_information.state == MEM_COMMIT &amp;&amp; memory_information.type == MEM_IMAGE <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!is_image) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> is_base = memory_information.base_address == memory_information.allocation_base <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!is_base) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> match_1 = time_date_stamp == <span class="hljs-number"><span class="hljs-number">0x5B12C900</span></span> &amp;&amp; *(__int8*)(memory_information.base_address + <span class="hljs-number"><span class="hljs-number">0x1000</span></span>) == <span class="hljs-number"><span class="hljs-number">0x00</span></span> &amp;&amp; *(__int32*)(memory_information.base_address + <span class="hljs-number"><span class="hljs-number">0x501000</span></span>) != <span class="hljs-number"><span class="hljs-number">0x353E900</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> match_2 = time_date_stamp == <span class="hljs-number"><span class="hljs-number">0x5A180C35</span></span> &amp;&amp; *(__int8*)(memory_information.base_address + <span class="hljs-number"><span class="hljs-number">0x1000</span></span>) != <span class="hljs-number"><span class="hljs-number">0x00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> match_2 = time_date_stamp == <span class="hljs-number"><span class="hljs-number">0xFC9B9325</span></span> &amp;&amp; *(__int8*)(memory_information.base_address + <span class="hljs-number"><span class="hljs-number">0x6D3000</span></span>) != <span class="hljs-number"><span class="hljs-number">0x00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match_1 &amp;&amp; !match_2 &amp;&amp; !match_3) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> buffer_offset = <span class="hljs-number"><span class="hljs-number">0x00</span></span> <span class="hljs-comment"><span class="hljs-comment">// OFFSET DEPENDS ON WHICH MODULE MATCHES, RESPECTIVELY 0x501000, 0x1000 AND 0x6D3000 unknown_module_report.unknown1 = 0 unknown_module_report.report_id = 0x46 unknown_module_report.unknown2 = 1 unknown_module_report.data = *(__int128*)(memory_information.base_address + buffer_offset battleye::report(&amp;unknown_module_report, sizeof(unknown_module_report), 0 }</span></span></code> </pre> <br>  No sabemos qu茅 m贸dulos satisfacen estos criterios, pero sospechamos que este es un intento de detectar un conjunto muy limitado de m贸dulos de trucos espec铆ficos. <br><br>  Anexo: @ how02 nos inform贸 que el m贸dulo <code>action_x64.dll</code> tiene una <code>0x5B12C900</code> tiempo <code>0x5B12C900</code> y contiene un 谩rea de c贸digo en la que puede escribir;  Como se mencion贸 anteriormente, esto se puede utilizar para explotar. <br><br><h1>  Protecci贸n de la memoria </h1><br>  BattlEye tambi茅n implementa un procedimiento de detecci贸n muy dudoso, que, en nuestra opini贸n, busca memoria con el <em>conjunto de</em> indicadores <em>PAGE_GUARD</em> , sin verificar realmente si el indicador <em>PAGE_GUARD</em> est谩 <em>configurado</em> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> memory::guard_check(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* current_address, MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (memory_information.protect != PAGE_NOACCESS) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> bad_ptr = IsBadReadPtr(current_address, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(temporary_buffer <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> read = NtReadVirtualMemory( GetCurrentProcess(), current_address, temporary_buffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(temporary_buffer), <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || bad_ptr) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> query = NtQueryVirtualMemory( GetCurrentProcess(), current_address, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;new_memory_information, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(new_memory_information), &amp;return_length memory_guard_report.guard = query &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || new_memory_information.state != memory_information.state || new_memory_information.protect != memory_information.protect <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (memory_guard_report.guard) { memory_guard_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> memory_guard_report.report_id = <span class="hljs-number"><span class="hljs-number">0x21</span></span> memory_guard_report.base_address = memory_information.base_address memory_guard_report.region_size = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)memory_information.region_size memory_guard_report.memory_info = memory_information.type | memory_information.protect | memory_information.state battleye::report(&amp;memory_guard_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(memory_guard_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } } } }</code> </pre> <br><h2>  Ordenar ventanas </h2><br>  El c贸digo de shell BattlEye itera sobre cada una de las ventanas que est谩n visibles actualmente durante el juego, pasando por alto las ventanas de arriba a abajo (por valor z).  Los <code>GetWindowThreadProcessId</code> ventana dentro del juego se excluyen de esta enumeraci贸n, y esto se determina llamando a <code>GetWindowThreadProcessId</code> .  Por lo tanto, puede vincular la funci贸n correspondiente al falso propietario de la ventana para que <strong>BattlEye no compruebe su ventana</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> window_handler::enumerate() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> window_handle = GetTopWindow window_handle window_handle = GetWindow(window_handle, GW_HWNDNEXT), <span class="hljs-comment"><span class="hljs-comment">// GET WINDOW BELOW ++window_handler::windows_enumerated) // INCREMENT GLOBAL COUNT FOR LATER USAGE { auto window_process_pid = 0 GetWindowThreadProcessId(window_handle, &amp;window_process_pid if (window_process_pid == GetCurrentProcessId()) continue // APPEND INFORMATION TO THE MISC. REPORT, THIS IS EXPLAINED LATER IN THE ARTICLE window_handler::handle_summary(window_handle constexpr auto max_character_count = 0x80 const auto length = GetWindowTextA(window_handle, window_title_report.window_title, max_character_count // DOES WINDOW TITLE MATCH ANY OF THE BLACKLISTED TITLES? if (!contains(window_title_report.window_title, "CheatAut") &amp;&amp; !contains(window_title_report.window_title, "pubg_kh") &amp;&amp; !contains(window_title_report.window_title, "conl -") &amp;&amp; !contains(window_title_report.window_title, "PerfectA") &amp;&amp; !contains(window_title_report.window_title, "AIMWA") &amp;&amp; !contains(window_title_report.window_title, "PUBG AIM") &amp;&amp; !contains(window_title_report.window_title, "HyperChe")) continue // REPORT WINDOW window_title_report.unknown_1 = 0 window_title_report.report_id = 0x33 battleye::report(&amp;window_title_report, sizeof(window_title_report) + length, 0 } }</span></span></code> </pre> <br><h2>  Anomal铆a de b煤squeda </h2><br>  Si se marcan menos de dos ventanas, se env铆a una notificaci贸n al servidor.  Esto probablemente se haga para evitar parchear las funciones correspondientes que no permiten que el c贸digo de shell BattlEye examine ninguna ventana: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> window_handler::check_count() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window_handler::windows_enumerated &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">// WINDOW ENUMERATION FAILED, MOST LIKELY DUE TO HOOK window_anomaly_report.unknown_1 = 0 window_anomaly_report.report_id = 0x44 window_anomaly_report.enumerated_windows = windows_enumerated battleye::report(&amp;window_anomaly_report, sizeof(window_anomaly_report), 0 }</span></span></code> </pre> <br><h2>  Clasificaci贸n de procesos </h2><br>  Al llamar a <code>CreateToolhelp32Snapshot</code> itera sobre todos los procesos en ejecuci贸n, pero <strong>no procesa ning煤n error</strong> , por lo que es muy f谩cil parchear y evitar los siguientes procedimientos de detecci贸n: <br><br><h1>  Comprobaci贸n de ruta </h1><br>  Si la imagen est谩 dentro de al menos dos subdirectorios (contando desde la ra铆z del disco), el sistema marcar谩 los procesos si la ruta a la imagen correspondiente contiene al menos una de estas l铆neas: <br><br><pre> <code class="cpp hljs">Desktop Temp FileRec Documents Downloads Roaming tmp.ex notepad. ...\. cmd.ex</code> </pre> <br>  Si la ruta al archivo ejecutable corresponde a una de estas l铆neas, el servidor recibe una notificaci贸n sobre la ruta al archivo ejecutable, as铆 como informaci贸n sobre si el proceso padre es uno de los siguientes (contiene el bit de bandera correspondiente enviado al servidor): <br><br><pre> <code class="cpp hljs">steam.exe [<span class="hljs-number"><span class="hljs-number">0x01</span></span>] explorer.exe [<span class="hljs-number"><span class="hljs-number">0x02</span></span>] lsass.exe [<span class="hljs-number"><span class="hljs-number">0x08</span></span>] cmd.exe [<span class="hljs-number"><span class="hljs-number">0x10</span></span>]</code> </pre> <br>  Si el cliente no puede abrir el descriptor con los derechos de informaci贸n <code>QueryLimitedInformation</code> apropiados, establecer谩 el bit de indicador <code>0x04</code> , si la causa del error cuando falla la llamada de <code>OpenProcess</code> no es <code>ERROR_ACCESS_DENIED</code> , que nos proporciona el 煤ltimo contenedor de enumeraci贸n para el valor de indicador correspondiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> BATTLEYE_PROCESS_FLAG { STEAM = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, EXPLORER = <span class="hljs-number"><span class="hljs-number">0x2</span></span>, ERROR = <span class="hljs-number"><span class="hljs-number">0x4</span></span>, LSASS = <span class="hljs-number"><span class="hljs-number">0x8</span></span>, CMD = <span class="hljs-number"><span class="hljs-number">0x10</span></span> }</code> </pre> <br>  Si el proceso principal es steam, entonces el indicador se establece instant谩neamente para el usuario y se informa al servidor sobre esto con la identificaci贸n de notificaci贸n <code>0x40</code> <br><br><h1>  Nombre de la imagen </h1><br>  Si el proceso cumple con alguno de los muchos criterios que se presentan a continuaci贸n, se establece una <code>0x38</code> instante y esto se informa al servidor con la identificaci贸n de notificaci贸n <code>0x38</code> <br><br><pre> <code class="cpp hljs">   <span class="hljs-string"><span class="hljs-string">"Loadlibr"</span></span>    <span class="hljs-string"><span class="hljs-string">"Rng "</span></span>    <span class="hljs-string"><span class="hljs-string">"A0E7FFFFFF81"</span></span>    <span class="hljs-string"><span class="hljs-string">"RNG "</span></span>    <span class="hljs-string"><span class="hljs-string">"90E54355"</span></span>    <span class="hljs-string"><span class="hljs-string">"2.6.ex"</span></span>    <span class="hljs-string"><span class="hljs-string">"TempFile.exe"</span></span></code> </pre> <br><h1>  Steam Game Overlay </h1><br>  BattlEye supervisa el proceso de superposici贸n de juegos de Steam, que es responsable de la superposici贸n en el juego, conocida por la mayor铆a de los usuarios de Steam.  El nombre de host completo de la superposici贸n de Steam Games es <code>gameoverlayui.exe</code> ;  se sabe que a menudo se usa para renderizar exploits, porque es bastante f谩cil de hackear y realizar renderizaciones ilegales en la ventana del juego.  La verificaci贸n tiene la siguiente condici贸n: <br><br><pre> <code class="cpp hljs">file size != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; image name contains (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> insensitive) gameoverlayu</code> </pre> <br>  Las comprobaciones adicionales espec铆ficas para la superposici贸n de juegos de Steam son casi id茅nticas a los procedimientos realizados para el proceso del juego en s铆, por lo tanto, se omiten en el pseudoc贸digo. <br><br><h1>  Escaneo de memoria de superposici贸n de vapor </h1><br>  El proceso de superposici贸n de juegos de Steam se analiza en busca de patrones y anomal铆as.  No pudimos profundizar en la madriguera del conejo y descubrir para qu茅 sirven estos patrones, porque son muy generalizados y muy probablemente asociados con m贸dulos de trucos. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> gameoverlay::pattern_scan(MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-comment"><span class="hljs-comment">// PATTERNS: // Home // F1 // FFFF83C48C30000000000 // \.pipe%s // C760000C64730 // 60C01810033D2 // ... // PATTERN SCAN, ALMOST IDENTICAL CODE TO THE AFOREMENTIONED PATTERN SCANNING ROUTINE gameoverlay_memory_report.unknown_1 = 0 gameoverlay_memory_report.report_id = 0x35 gameoverlay_memory_report.identifier = 0x56C gameoverlay_memory_report.data = &amp;buffer[offset gameoverlay_memory_report.base_address = memory_information.base_address gameoverlay_memory_report.region_size = (int)memory_information.region_size gameoverlay_memory_report.memory_info = memory_information.type | memory_information.protect | memory_information.state battleye::report(&amp;gameoverlay_memory_report, sizeof(gameoverlay_memory_report), 0 }</span></span></code> </pre> <br>  El procedimiento de escaneo tambi茅n busca cualquier anomal铆a en forma de c贸digo ejecutable fuera de las im谩genes descargadas, lo que sugiere que los crackers inyectaron el c贸digo en el proceso de superposici贸n: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> gameoverlay::memory_anomaly_scan(MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-comment"><span class="hljs-comment">// ... // ALMOST IDENTICAL ANOMALY SCAN COMPARED TO MEMORY ENUMERATION ROUTINE OF GAME PROCESS gameoverlay_report.unknown = 0 gameoverlay_report.report_id = 0x3B gameoverlay_report.base_address = memory_information.base_address gameoverlay_report.region_size = memory_information.region_size gameoverlay_report.memory_info = memory_information.type | memory_information.protect | memory_information.state battleye::report(&amp;gameoverlay_report, sizeof(gameoverlay_report), 0 }</span></span></code> </pre> <br><h1>  Protecci贸n de superposici贸n de juegos de Steam </h1><br>  Si el proceso de superposici贸n de juegos de Steam est谩 protegido por alguna protecci贸n de procesos de Windows como <em>Light (WinTcb)</em> , entonces el servidor recibir谩 una notificaci贸n al respecto. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> gameoverlay::protection_check(HANDLE process_handle) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> process_protection = <span class="hljs-number"><span class="hljs-number">0</span></span> NtQueryInformationProcess( process_handle, ProcessProtectionInformation, &amp;process_protection, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(process_protection), <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process_protection == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// NO PROTECTION return gameoverlay_protected_report.unknown = 0 gameoverlay_protected_report.report_id = 0x35 gameoverlay_protected_report.identifier = 0x5B1 gameoverlay_protected_report.data = process_protection battleye::report(&amp;gameoverlay_protected_report, sizeof(gameoverlay_protected_report), 0 }</span></span></code> </pre> <br>  Adem谩s, si la llamada correspondiente de <em>OpenProcess</em> devuelve <em>ERROR_ACCESS_DENIED</em> al proceso de superposici贸n, se env铆a una notificaci贸n sobre el usuario con id <code>3B</code> . <br><br><h1>  M贸dulos de clasificaci贸n </h1><br>  Tambi茅n se buscan m贸dulos de proceso de superposici贸n de juegos de Steam, en particular, se <code>vgui2_s.dll</code> y <code>gameoverlayui.dll</code> .  Se realizan varias verificaciones para estos m贸dulos, comenzando con <code>gameoverlayui.dll</code> . <br><br>  Si se cumple esta condici贸n: <code>[gameoverlayui.dll+6C779] == 08BE55DC3CCCCB8????????C3CCCCCC</code> , entonces el <code>[gameoverlayui.dll+6C779] == 08BE55DC3CCCCB8????????C3CCCCCC</code> escanea la vtable en la direcci贸n almacenada en bytes <code>????????</code>  .  Si alguno de estos elementos vtable est谩 fuera del m贸dulo fuente gameoverlayui.dll o apunta a una instrucci贸n <code>int 3</code> , el usuario es informado al servidor con una identificaci贸n de notificaci贸n de <code>3B</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> gameoverlay::scan_vtable(HANDLE process_handle, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* buffer, MODULEENTRY32 module_entry) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> function_buffer[<span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (vtable_index = <span class="hljs-number"><span class="hljs-number">0</span></span> vtable_index &lt; <span class="hljs-number"><span class="hljs-number">20</span></span> vtable_index += <span class="hljs-number"><span class="hljs-number">4</span></span>) { NtReadVirtualMemory( process_handle, *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)&amp;buffer[vtable_index], &amp;function_buffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(function_buffer), <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)&amp;buffer[vtable_index] &lt; module_entry.modBaseAddr || *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)&amp;buffer[vtable_index] &gt;= module_entry.modBaseAddr + module_entry.modBaseSize || function_buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">0xCC</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// FUNCTION PADDING { gameoverlay_vtable_report.report_id = 0x3B gameoverlay_vtable_report.vtable_index = vtable_index gameoverlay_vtable_report.address = buffer[vtable_index battleye::report(&amp;gameoverlay_vtable_report, sizeof(gameoverlay_vtable_report), 0 } } }</span></span></code> </pre> <br>  Tambi茅n se realiza un procedimiento de verificaci贸n espec铆fico para el m贸dulo <code>vgui2_s.dll</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> vgui::scan() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!equals(vgui_buffer, <span class="hljs-string"><span class="hljs-string">"6A08B31FF561C8BD??????????FF96????????8BD????????8B1FF90"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> could_read = NtReadVirtualMemory( process_handle, module_entry.modBaseAddr + <span class="hljs-number"><span class="hljs-number">0x48338</span></span>, vgui_buffer, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pattern_offset = <span class="hljs-number"><span class="hljs-number">0x48378</span></span> <span class="hljs-comment"><span class="hljs-comment">// IF READ DID NOT FAIL AND PATTERN IS FOUND if (could_read &amp;&amp; equals(vgui_buffer, "6A46A06A26A")) { vgui_report.unknown_1 = 0 vgui_report.report_id = 0x3B vgui_report.unknown_2 = 0 vgui_report.address = LODWORD(module_entry.modBaseAddr) + pattern_offset // READ TARGET BUFFER INTO REPORT NtReadVirtualMemory( process_handle, module_entry.modBaseAddr + pattern_offset, vgui_report.buffer, sizeof(vgui_report.buffer), 0 battleye::report(&amp;vgui_report, sizeof(vgui_report), 0 } } else if ( // READ ADDRESS FROM CODE NtReadVirtualMemory(process_handle, *(int*)&amp;vgui_buffer[9], vgui_buffer, 4, 0) &gt;= 0 &amp;&amp; // READ POINTER TO CLASS NtReadVirtualMemory(process_handle, *(int*)vgui_buffer, vgui_buffer, 4, 0) &gt;= 0 &amp;&amp; // READ POINTER TO VIRTUAL TABLE NtReadVirtualMemory(process_handle, *(int*)vgui_buffer, vgui_buffer, sizeof(vgui_buffer), 0) &gt;= 0) { for (vtable_index = 0 vtable_index &lt; 984 vtable_index += 4 ) // 984/4 VTABLE ENTRY COUNT { NtReadVirtualMemory(process_handle, *(int*)&amp;vgui_buffer[vtable_index], &amp;vtable_entry, sizeof(vtable_entry), 0 if (*(int*)&amp;vgui_buffer[vtable_index] &lt; module_entry.modBaseAddr || *(int*)&amp;vgui_buffer[vtable_index] &gt;= module_entry.modBaseAddr + module_entry.modBaseSize || vtable_entry == 0xCC ) { vgui_vtable_report.unknown = 0 vgui_vtable_report.report_id = 0x3B vgui_vtable_report.vtable_index = vtable_index vgui_vtable_report.address = *(int*)&amp;vgui_buffer[vtable_index battleye::report(&amp;vgui_vtable_report, sizeof(vgui_vtable_report), 0 } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este procedimiento busca cambios en el desplazamiento </font></font><code>48378</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que es la ubicaci贸n del 谩rea de c贸digo:</font></font><br><br><pre> <code class="cpp hljs">push <span class="hljs-number"><span class="hljs-number">04</span></span> push offset aCBuildslaveSte_4 ; <span class="hljs-string"><span class="hljs-string">"c:\buildslave\steam_rel_client_win32"</span></span>... push offset aAssertionFaile_7 ; <span class="hljs-string"><span class="hljs-string">"Assertion Failed: IsValidIndex(elem)"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El procedimiento luego verifica un cambio muy espec铆fico y aparentemente basura: </font></font><br><br><pre> <code class="cpp hljs">push <span class="hljs-number"><span class="hljs-number">04</span></span> push <span class="hljs-number"><span class="hljs-number">00</span></span> push <span class="hljs-number"><span class="hljs-number">02</span></span> push ??</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No hemos podido encontrar una copia de vgui2_s.dll que no coincida con la primera de las dos comprobaciones anteriores, por lo que no podemos averiguar qu茅 tabla comprueba. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Steam Overlay Streams </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Las secuencias en el proceso de superponer juegos de Steam tambi茅n se mueven: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> gameoverlay::check_thread(THREADENTRY32 thread_entry) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tread_handle = OpenThread(THREAD_SUSPEND_RESUME|THREAD_GET_CONTEXT, <span class="hljs-number"><span class="hljs-number">0</span></span>, thread_entry.th32ThreadID <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (thread_handle) { suspend_count = ResumeThread(thread_handle <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (suspend_count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { SuspendThread(thread_handle gameoverlay_thread_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> gameoverlay_thread_report.report_id = <span class="hljs-number"><span class="hljs-number">0x3B</span></span> gameoverlay_thread_report.suspend_count = suspend_count battleye::report(&amp;gameoverlay_thread_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(gameoverlay_thread_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetThreadContext(thread_handle, &amp;context) &amp;&amp; context.Dr7) { gameoverlay_debug_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> gameoverlay_debug_report.report_id = <span class="hljs-number"><span class="hljs-number">0x3B</span></span> gameoverlay_debug_report.debug_register = context.Dr0 battleye::report(&amp;gameoverlay_debug_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(gameoverlay_debug_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LSASS </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El espacio de direcciones de memoria del proceso Windows </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lsass.exe</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tambi茅n conocido como proceso de la Autoridad de Seguridad Local, tambi茅n se escanea y todas las anomal铆as se informan al servidor, como en el caso de las dos comprobaciones anteriores:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (equals(process_entry.executable_path, <span class="hljs-string"><span class="hljs-string">"lsass.exe"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> lsass_handle = OpenProcess(QueryInformation, <span class="hljs-number"><span class="hljs-number">0</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)process_entry.th32ProcessID <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lsass_handle) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (address = <span class="hljs-number"><span class="hljs-number">0</span></span> NtQueryVirtualMemory(lsass_handle, address, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;lsass_memory_info, <span class="hljs-number"><span class="hljs-number">0x30</span></span>, &amp;bytes_needed) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> address = lsass_memory_info.base_address + lsass_memory_info.region_size) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lsass_memory_info.state == MEM_COMMIT &amp;&amp; lsass_memory_info.type == MEM_PRIVATE &amp;&amp; (lsass_memory_info.protect == PAGE_EXECUTE || lsass_memory_info.protect == PAGE_EXECUTE_READ || lsass_memory_info.protect == PAGE_EXECUTE_READWRITE)) { <span class="hljs-comment"><span class="hljs-comment">// FOUND EXECUTABLE MEMORY OUTSIDE OF MODULES lsass_report.unknown = 0 lsass_report.report_id = 0x42 lsass_report.base_address = lsass_memory_info.base_address lsass_report.region_size = lsass_memory_info.region_size lsass_report.memory_info = lsass_memory_info.type | lsass_memory_info.protect | lsass_memory_info.state battleye::report(&amp;lsass_report, sizeof(lsass_report), 0 } } CloseHandle(lsass_handle } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LSASS se utiliz贸 anteriormente en exploits para realizar operaciones con memoria, ya que cualquier proceso que necesite una conexi贸n a Internet debe proporcionarle acceso LSASS. </font><font style="vertical-align: inherit;">BattlEye est谩 lidiando actualmente con este problema borrando manualmente el identificador de proceso de las operaciones de lectura / escritura y luego </font><font style="vertical-align: inherit;">adjuntando </font></font><code>ReadProcessMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>WriteProcessMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">redirigiendo las llamadas a su controlador BEDaisy. </font><font style="vertical-align: inherit;">Luego, BEDaisy decide si la operaci贸n de memoria es legal. </font><font style="vertical-align: inherit;">Si cree que la operaci贸n es legal, entonces la contin煤a, y de lo contrario enciende deliberadamente la m谩quina con una pantalla azul.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Varias notificaciones </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BattlEye recopila informaci贸n diversa y la env铆a al servidor con la identificaci贸n de notificaci贸n </font></font><code>3C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esta informaci贸n consta de los siguientes elementos:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cualquier ventana con el indicador </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WS_EX_TOPMOST</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o sus an谩logos:</font></font><ul><li>   (Unicode) </li><li>    (Unicode) </li><li> Window style </li><li> Window extended style </li><li>   </li><li>    - </li><li>   - </li></ul></li><li>        (VM_WRITE|VM_READ) <ul><li>   </li><li>    </li><li>   </li><li>    </li></ul></li><li>    : <br><ul><li> .ContentPaksTslGame-WindowsNoEditor_assets_world.pak </li><li> .ContentPaksTslGame-WindowsNoEditor_ui.pak </li><li> .ContentPaksTslGame-WindowsNoEditor_sound.pak </li></ul><br></li><li>    : <br><ul><li> .BLGameCookedContentScriptBLGame.u </li></ul></li><li>    NtGetContextThread <br><ul><li>     (E9),       </li></ul></li></ul><br><h2> NoEye </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BattlEye implementa una comprobaci贸n bastante perezosa para detectar un rootkit de acceso p煤blico para evitar este anti-trampa llamado NoEye: el sistema usa </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetFileAttributesExA para</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verificar el tama帽o del archivo </font></font><code>BE_DLL.dll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si esta biblioteca se encuentra en el disco.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> noeye::detect() { <span class="hljs-function"><span class="hljs-function">WIN32_FILE_ATTRIBUTE_DATA file_information </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GetFileAttributesExA(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"BE_DLL.dll"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, &amp;file_information))</span></span></span><span class="hljs-function"> </span></span>{ noeye_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> noeye_report.report_id = <span class="hljs-number"><span class="hljs-number">0x3D</span></span> noeye_report.file_size = file_information.nFileSizeLow battleye::report(&amp;noeye_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(noeye_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Disponibilidad del conductor </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comprobaciones para dispositivos Beep y Null; </font><font style="vertical-align: inherit;">si lo hay, se genera una notificaci贸n. </font><font style="vertical-align: inherit;">En el estado normal, estos dos dispositivos no est谩n disponibles en el sistema, y esto puede indicar que alguien encendi贸 el dispositivo manualmente. </font><font style="vertical-align: inherit;">Esta t茅cnica se llama secuestro del dispositivo del controlador. </font><font style="vertical-align: inherit;">Esto es para garantizar que los datos IOCTL se intercambien con el controlador malicioso sin la necesidad de un objeto de controlador separado para este controlador.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> driver::check_beep() { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> handle = CreateFileA(<span class="hljs-string"><span class="hljs-string">"\\.\Beep"</span></span>, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="hljs-number"><span class="hljs-number">0</span></span>, OPEN_EXISTING, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle != INVALID_HANDLE_VALUE) { beep_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> beep_report.report_id = <span class="hljs-number"><span class="hljs-number">0x3E</span></span> battleye::report(&amp;beep_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(beep_report), <span class="hljs-number"><span class="hljs-number">0</span></span> CloseHandle(handle } }</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> driver::check_null() { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> handle = CreateFileA(<span class="hljs-string"><span class="hljs-string">"\\.\Null"</span></span>, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="hljs-number"><span class="hljs-number">0</span></span>, OPEN_EXISTING, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle != INVALID_HANDLE_VALUE) { null_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> null_report.report_id = <span class="hljs-number"><span class="hljs-number">0x3E</span></span> battleye::report(&amp;null_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(null_report), <span class="hljs-number"><span class="hljs-number">0</span></span> CloseHandle(handle } }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Delta del sue帽o </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adem谩s, BattlEye puede solicitar un segundo de inactividad del hilo actual y mide la diferencia en el n煤mero de ciclos antes y despu茅s de la inactividad (suspensi贸n): </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> sleep::check_delta() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tick_count = GetTickCount Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tick_delta = GetTickCount() - tick_count <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tick_delta &gt;= <span class="hljs-number"><span class="hljs-number">1200</span></span>) { sleep_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> sleep_report.report_id = <span class="hljs-number"><span class="hljs-number">0x45</span></span> sleep_report.delta = tick_delta battleye::report(&amp;sleep_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sleep_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7zip </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se ha agregado una verificaci贸n de integridad muy perezosa a BattlEye para que los usuarios no puedan cargar la biblioteca 7zip en los procesos del juego y sobrescribir 谩reas. </font><font style="vertical-align: inherit;">Los usuarios hicieron esto para reducir la gravedad de los escaneos de patrones y la detecci贸n de anomal铆as descritos anteriormente. </font><font style="vertical-align: inherit;">BattlEye simplemente decidi贸 agregar verificaciones de integridad para esta biblioteca particular de 7zip.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_7zip() { <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sz_7zipdll = <span class="hljs-string"><span class="hljs-string">"..\..\Plugins\ZipUtility\ThirdParty\7zpp\dll\Win64\7z.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(sz_7zipdll <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle &amp;&amp; *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1000</span></span>) != <span class="hljs-number"><span class="hljs-number">0xFF1441C7</span></span>) { sevenzip_report.unknown_1 = <span class="hljs-number"><span class="hljs-number">0</span></span> sevenzip_report.report_id = <span class="hljs-number"><span class="hljs-number">0x46</span></span> sevenzip_report.unknown_2 = <span class="hljs-number"><span class="hljs-number">0</span></span> sevenzip_report.data1 = *(__int64*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1000</span></span> sevenzip_report.data2 = *(__int64*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1008</span></span> battleye::report(&amp;sevenzip_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sevenzip_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Capa de abstracci贸n de hardware </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> BattlEye busca una biblioteca de capa de abstracci贸n de hardware de Windows vinculada din谩micamente (hal.dll) y le dice al servidor si est谩 cargada dentro del juego. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_hal() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"hal.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { hal_report.unknown_1 = <span class="hljs-number"><span class="hljs-number">0</span></span> hal_report.report_id = <span class="hljs-number"><span class="hljs-number">0x46</span></span> hal_report.unknown_2 = <span class="hljs-number"><span class="hljs-number">2</span></span> hal_report.data1 = *(__int64*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1000</span></span> hal_report.data2 = *(__int64*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1008</span></span> battleye::report(&amp;hal_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(hal_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verificaciones de imagen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BattlEye tambi茅n verifica varias im谩genes cargadas en el juego. </font><font style="vertical-align: inherit;">Se supone que estos m贸dulos son im谩genes firmadas que de alguna manera se manipulan, cambiando su comportamiento a malicioso, pero no podemos decir nada m谩s sobre ellos, solo sobre su detecci贸n:</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nvToolsExt64_1 </font></font></h1><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_nvtoolsext64_1 { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"nvToolsExt64_1.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { nvtools_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> nvtools_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> nvtools_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5A8</span></span> nvtools_report.size_of_image = (PE_HEADER*)(module_handle + (DOS_HEADER*)(module_handle)-&gt;e_lfanew))-&gt;SizeOfImage battleye::report(&amp;nvtools_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nvtools_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ws2detour_x96 </font></font></h1><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_ws2detour_x96 { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"ws2detour_x96.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { ws2detour_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> ws2detour_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> ws2detour_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5B5</span></span> ws2detour_report.size_of_image = (PE_HEADER*)(module_handle + (DOS_HEADER*)(module_handle)-&gt;e_lfanew))-&gt;SizeOfImage battleye::report(&amp;ws2detour_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ws2detour_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> networkdllx64 </font></font></h1><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_networkdllx64 { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"networkdllx64.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> dos_header = (DOS_HEADER*)module_handle <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pe_header = (PE_HEADER*)(module_handle + dos_header-&gt;e_lfanew <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size_of_image = pe_header-&gt;SizeOfImage <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size_of_image &lt; <span class="hljs-number"><span class="hljs-number">0x200000</span></span> || size_of_image &gt;= <span class="hljs-number"><span class="hljs-number">0x400000</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pe_header-&gt;sections[DEBUG_DIRECTORY].size == <span class="hljs-number"><span class="hljs-number">0x1B20</span></span>) { networkdll64_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> networkdll64_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> networkdll64_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5B7</span></span> networkdll64_report.data = pe_header-&gt;TimeDatestamp battleye::report(&amp;networkdll64_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(networkdll64_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { networkdll64_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> networkdll64_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> networkdll64_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5B7</span></span> networkdll64_report.data = pe_header-&gt;sections[DEBUG_DIRECTORY].size battleye::report(&amp;networkdll64_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(networkdll64_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nxdetours_64 </font></font></h1><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_nxdetours_64 { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"nxdetours_64.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { nxdetours64_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> nxdetours64_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> nxdetours64_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5B8</span></span> nxdetours64_report.size_of_image = (PE_HEADER*)(module_handle + (DOS_HEADER*)(module_handle)-&gt;e_lfanew))-&gt;SizeOfImage battleye::report(&amp;nxdetours64_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nxdetours64_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nvcompiler </font></font></h1><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_nvcompiler { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"nvcompiler.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { nvcompiler_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> nvcompiler_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> nvcompiler_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5BC</span></span> nvcompiler_report.data = *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1000</span></span> battleye::report(&amp;nvcompiler_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nvcompiler_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wmp </font></font></h1><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_wmp { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"wmp.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { wmp_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> wmp_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> wmp_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5BE</span></span> wmp_report.data = *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1000</span></span> battleye::report(&amp;wmp_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(wmp_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Identificadores de enumeraci贸n de m贸dulos </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como referencia, le damos la identificaci贸n de enumeraci贸n para los m贸dulos: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> module_id { nvtoolsext64 = <span class="hljs-number"><span class="hljs-number">0x5A8</span></span>, ws2detour_x96 = <span class="hljs-number"><span class="hljs-number">0x5B5</span></span>, networkdll64 = <span class="hljs-number"><span class="hljs-number">0x5B7</span></span>, nxdetours_64 = <span class="hljs-number"><span class="hljs-number">0x5B8</span></span>, nvcompiler = <span class="hljs-number"><span class="hljs-number">0x5BC</span></span>, wmp = <span class="hljs-number"><span class="hljs-number">0x5BE</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escanear tablas TCP </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El c贸digo de shell BattlEye busca una lista de conexiones TCP para todo el sistema (conocida como la tabla TCP) e informa si el usuario est谩 conectado al menos a una de las direcciones IP de la puerta de enlace Cloudflare que pertenecen al sitio web alem谩n de pago -cheat llamada </font></font><a href="https://xera.ph/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xera.ph</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Este mecanismo se ha agregado al c贸digo de shell para detectar usuarios que tienen el iniciador en ejecuci贸n cuando el juego se est谩 ejecutando, haci茅ndolos f谩ciles de reconocer. El 煤nico problema con este mecanismo es que las direcciones IP de la puerta de enlace de Cloudflare pueden cambiar de propietario m谩s adelante. y si su nuevo propietario distribuye software que se conecta a sus servidores a trav茅s de un puerto espec铆fico, entonces se producir谩n disparadores falsos positivos contra trampas sin ninguna duda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pagar para enga帽ar a los </font><em><font style="vertical-align: inherit;">usuarios del</font></em><font style="vertical-align: inherit;"> proveedor de servicios </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xera.ph</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durante mucho tiempo han estado informando que est谩n siendo atrapados, y los desarrolladores no pueden lidiar con eso de ninguna manera. </font><font style="vertical-align: inherit;">Nos pusimos en contacto con los desarrolladores de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xera.ph</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para informarles de su comportamiento est煤pido, pero nos entendieron mal y nos enviaron una copia gratuita, sin pensar que podr铆amos piratearla y liberarla. </font><font style="vertical-align: inherit;">No haremos esto, pero probablemente no deber铆a enviar archivos binarios con licencia de propiedad de forma gratuita a las personas involucradas en ingenier铆a inversa y esperar que no sean pirateados.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> network::scan_tcp_table { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(local_port_buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(local_port_buffer <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (iteration_index = <span class="hljs-number"><span class="hljs-number">0</span></span> iteration_index &lt; <span class="hljs-number"><span class="hljs-number">500</span></span> ++iteration_index) { <span class="hljs-comment"><span class="hljs-comment">// GET NECESSARY SIZE OF TCP TABLE auto table_size = 0 GetExtendedTcpTable(0, &amp;table_size, false, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0 // ALLOCATE BUFFER OF PROPER SIZE FOR TCP TABLE auto allocated_ip_table = (MIB_TCPTABLE_OWNER_MODULE*)malloc(table_size if (GetExtendedTcpTable(allocated_ip_table, &amp;table_size, false, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0) != NO_ERROR) goto cleanup for (entry_index = 0 entry_index &lt; allocated_ip_table-&gt;dwNumEntries ++entry_index) { const auto ip_address_match_1 = allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656B1468 // 104.20.107.101 const auto ip_address_match_2 = allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656C1468 // 104.20.108.101 const auto port_match = allocated_ip_table-&gt;table[entry_index].dwRemotePort == 20480 if ( (!ip_address_match_1 &amp;&amp; !ip_address_match_2) || !port_match) continue for (port_index = 0 port_index &lt; 10 &amp;&amp; allocated_ip_table-&gt;table[entry_index].dwLocalPort != local_port_buffer[port_index ++port_index) { if (local_port_buffer[port_index]) continue tcp_table_report.unknown = 0 tcp_table_report.report_id = 0x48 tcp_table_report.module_id = 0x5B9 tcp_table_report.data = BYTE1(allocated_ip_table-&gt;table[entry_index].dwLocalPort) | (LOBYTE(allocated_ip_table-&gt;table[entry_index.dwLocalPort) &lt;&lt; 8 battleye::report(&amp;tcp_table_report, sizeof(tcp_table_report), 0 local_port_buffer[port_index] = allocated_ip_table-&gt;table[entry_index].dwLocalPort break } } cleanup: // FREE TABLE AND SLEEP free(allocated_ip_table Sleep(10 } }</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tipos de notificaciones </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqu铆 hay como referencia todos los tipos conocidos de notificaciones del c贸digo de shell: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> BATTLEYE_REPORT_ID { MEMORY_GUARD = <span class="hljs-number"><span class="hljs-number">0x21</span></span>, MEMORY_SUSPICIOUS = <span class="hljs-number"><span class="hljs-number">0x2F</span></span>, WINDOW_TITLE = <span class="hljs-number"><span class="hljs-number">0x33</span></span>, MEMORY = <span class="hljs-number"><span class="hljs-number">0x35</span></span>, PROCESS_ANOMALY = <span class="hljs-number"><span class="hljs-number">0x38</span></span>, DRIVER_BEEP_PRESENCE = <span class="hljs-number"><span class="hljs-number">0x3E</span></span>, DRIVER_NULL_PRESENCE = <span class="hljs-number"><span class="hljs-number">0x3F</span></span>, MISCELLANEOUS_ANOMALY = <span class="hljs-number"><span class="hljs-number">0x3B</span></span>, PROCESS_SUSPICIOUS = <span class="hljs-number"><span class="hljs-number">0x40</span></span>, LSASS_MEMORY = <span class="hljs-number"><span class="hljs-number">0x42</span></span>, SLEEP_ANOMALY = <span class="hljs-number"><span class="hljs-number">0x45</span></span>, MEMORY_MODULE_SPECIFIC = <span class="hljs-number"><span class="hljs-number">0x46</span></span>, GENERIC_ANOMALY = <span class="hljs-number"><span class="hljs-number">0x48</span></span>, MEMORY_MODULE_SPECIFIC2 = <span class="hljs-number"><span class="hljs-number">0x5B</span></span>, }</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/483068/">https://habr.com/ru/post/483068/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../483054/index.html">"No habr谩 masacre" - la historia de la traducci贸n de The Worm</a></li>
<li><a href="../483056/index.html">Campos l贸gicos en bases de datos, 驴hay un ant铆doto?</a></li>
<li><a href="../483058/index.html">Resultados de la encuesta de vacaciones</a></li>
<li><a href="../483064/index.html">Vue para el blog m谩s peque帽o conocido como peque帽o en todos los c谩nones</a></li>
<li><a href="../483066/index.html">Los 5 libros tradicionales de Bill Gates</a></li>
<li><a href="../483074/index.html">TensorRT 6.xxx: inferencia de alto rendimiento para modelos de aprendizaje profundo (detecci贸n y segmentaci贸n de objetos)</a></li>
<li><a href="../483076/index.html">Principales lenguajes de programaci贸n para el desarrollo de aplicaciones de Android en 2020</a></li>
<li><a href="../483078/index.html">Aprendizaje de refuerzo profundo: c贸mo ense帽ar a las ara帽as a caminar</a></li>
<li><a href="../483082/index.html">La caza de vulnerabilidades es un 7% m谩s efectiva</a></li>
<li><a href="../483084/index.html">C谩mara con funci贸n de seguimiento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>