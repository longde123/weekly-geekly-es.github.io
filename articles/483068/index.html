<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👉🏾 🌙 🦓 Ingeniería inversa del popular BattlEye anti-trampa 🚊 🌅 🕦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="BattlEye es predominantemente un anti-engaño de un tercero alemán, desarrollado principalmente por Bastian Heiko Suter , de 32 años. Proporciona (o in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ingeniería inversa del popular BattlEye anti-trampa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483068/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ps/ae/ij/psaeijpcayldgrqiqeiq6l83nue.jpeg"></div><br>  BattlEye es predominantemente un anti-engaño de un tercero alemán, desarrollado principalmente por <em>Bastian Heiko Suter</em> , de 32 años.  Proporciona (o intenta proporcionar) a los editores de juegos un sistema anti-trampa fácil de usar que utiliza mecanismos de protección generales, así como la detección de trampas para juegos específicos para optimizar la seguridad.  Como se indica en el sitio web del producto, siempre se mantiene en la cima de la tecnología moderna y utiliza métodos innovadores de protección y detección;  obviamente esto es consecuencia de la nacionalidad del desarrollador: <code>QUALITY MADE IN GERMANY</code> .  BattlEye consta de muchos elementos que trabajan juntos para encontrar tramposos en los juegos que han pagado por el uso del producto.  Los cuatro elementos principales son: <br><br><ul><li>  BEService <ul><li>  Un servicio del sistema de Windows que se comunica con el servidor BattlEye <em>BEServer</em> , que proporciona comunicación cliente-servidor con <em>BEDaisy</em> y <em>BEClient</em> . </li></ul></li><li>  BEDaisy <ul><li>  Un controlador de kernel de Windows que registra mecanismos de procesamiento de eventos preventivos y mini filtros para evitar que los tramposos modifiquen ilegalmente el juego </li></ul></li><li>  Becient <ul><li>  Una biblioteca de Windows conectada dinámicamente que es responsable de la mayoría de los vectores de detección, incluidos los descritos en este artículo.  Después de la inicialización, se adjunta al proceso del juego. </li></ul></li><li>  Beserver <ul><li>  Servidor backend patentado, responsable de recopilar información y tomar medidas específicas contra los tramposos. </li></ul></li></ul><br><h1>  Shellcode </h1><br>  Recientemente, un volcado del código de shell BattlEye apareció en Internet, y decidimos escribir sobre lo que está buscando exactamente la versión actual de BattlEye.  No analizamos BattlEye durante seis meses, por lo que nuestro último volcado del shellcode probablemente esté desactualizado.  Varias partes del código se recuperaron solo de la memoria de este último volcado, suponiendo que BattlEye solo completó el código de shell y no eliminó los procedimientos de detección anteriores. <br><a name="habracut"></a><br><h1>  Como? </h1><br>  BattlEye supuestamente transmite código shell desde su servidor a un servicio de Windows llamado BEService.  Este servicio se comunica con el módulo BEClient ubicado dentro del juego.  El intercambio de datos se realiza a través de la <code>\.namedpipeBattleye</code> y hasta 2018 no se cifró.  Ahora, todos los datos transmitidos se cifran con un xor-encryptor con claves muy pequeñas, lo que hace que sea extremadamente fácil realizar ataques de texto sin formato conocidos.  Cuando el código de shell se transmite al cliente, se ubica y ejecuta fuera de todos los módulos conocidos, lo que facilita su determinación.  Para crear un volcado de shellcode, puede procesar las funciones estándar de la API de Windows, como CreateFile, ReadFile, etc., y volcar el área de memoria correspondiente de todos los módulos de llamada (solicitando información de memoria para la dirección devuelta) que están fuera de todos los módulos conocidos, o escanee periódicamente el espacio de memoria virtual del juego en busca de memoria ejecutable fuera de todos los módulos conocidos, y vuélvala al disco.  Al mismo tiempo, debe realizar un seguimiento de las áreas que ya se han volcado, de modo que no obtendrá muchos volcados idénticos. <br><br><h1>  Explicación </h1><br>  Los fragmentos de pseudocódigo presentados en el artículo están <strong>fuertemente</strong> modificados por el bien de la belleza.  No podrá volcar el código de shell BattlEye e inmediatamente reconocer estas partes;  el shellcode no contiene llamadas a funciones, y se implementan muchos algoritmos en el artículo.  Pero, de hecho, esto no es importante, porque cuando termine de leer sobre esta terrible antigüedad, tendrá la oportunidad de sortearla (: <br><br><h2>  Clasificación de memoria </h2><br>  El mecanismo de detección más común en anti-trampas es la enumeración de memoria y el escaneo de memoria para buscar imágenes de trampas <em>conocidas</em> .  Es fácil de implementar y, como se muestra en el pasado, con el enfoque correcto, es bastante efectivo si no ha olvidado los conceptos básicos del ensamblador y ha incluido en la lista negra el prólogo de una función común. <br><br>  Battleye itera sobre todo el espacio de direcciones del proceso del juego (el proceso actual en este contexto) y realiza varias comprobaciones sobre el rendimiento de la página y encuentra el código de shell fuera del espacio de memoria correspondiente. <br><br>  Así es como se implementa en Battleye: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// MEMORY ENUMERATION for (current_address = 0 // QUERY MEMORY_BASIC_INFORMATION NtQueryVirtualMemory(GetCurrentProcess(), current_address, 0, &amp;memory_information, 0x30, &amp;return_length) &gt;= 0 current_address = memory_information.base_address + memory_information.region_size) { const auto outside_of_shellcode = memory_information.base_address &gt; shellcode_entry || memory_information.base_address + memory_information.region_size &lt;= shellcode_entry const auto executable_memory = memory_information.state == MEM_COMMIT &amp;&amp; (memory_information.protect == PAGE_EXECUTE || memory_information.protect == PAGE_EXECUTE_READ || memory_information.protect == PAGE_EXECUTE_READWRITE const auto unknown_whitelist = memory_information.protect != PAGE_EXECUTE_READWRITE || memory_information.region_size != 100000000 if (!executable_memory || !outside_of_shellcode || !unknown_whitelist) continue // RUN CHECKS memory::anomaly_check(memory_information memory::pattern_check(current_address, memory_information memory::module_specific_check_microsoft(memory_information memory::guard_check(current_address, memory_information memory::module_specific_check_unknown(memory_information }</span></span></code> </pre> <br><h1>  Anomalías de memoria </h1><br>  BattlEye marca todas las anomalías en el espacio de direcciones de memoria, principalmente la memoria de módulos ejecutables que no corresponden a la imagen cargada: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> memory::anomaly_check(MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-comment"><span class="hljs-comment">// REPORT ANY EXECUTABLE PAGE OUTSIDE OF KNOWN MODULES if (memory_information.type == MEM_PRIVATE || memory_information.type == MEM_MAPPED) { if ((memory_information.base_address &amp; 0xFF0000000000) != 0x7F0000000000 &amp;&amp; // UPPER EQUALS 0x7F (memory_information.base_address &amp; 0xFFF000000000) != 0x7F000000000 &amp;&amp; // UPPER EQUALS 0x7F0 (memory_information.base_address &amp; 0xFFFFF0000000) != 0x70000000 &amp;&amp; // UPPER EQUALS 0x70000 memory_information.base_address != 0x3E0000)) { memory_report.unknown = 0 memory_report.report_id = 0x2F memory_report.base_address = memory_information.base_address memory_report.region_size = memory_information.region_size memory_report.memory_info = memory_information.type | memory_information.protect | memory_information.state battleye::report(&amp;memory_report, sizeof(memory_report), 0 } } }</span></span></code> </pre> <br><h1>  Escaneo de patrones </h1><br>  Como se mencionó anteriormente, BattlEye también escanea la memoria de los procesos locales en busca de varios patrones claramente definidos, como se puede ver en la implementación que se muestra a continuación. <br><br>  Al leer este pseudocódigo, puede adivinar que <strong>estas comprobaciones pueden eludirse</strong> reescribiendo el área de código de cada módulo cargado, ya que no escanearán en busca de patrones en imágenes conocidas.  Para no caer en las verificaciones de integridad, debe descargar todas las áreas empaquetadas y en la lista blanca y volver a escribir las áreas de código marcadas como <em>RWX</em> , porque no podemos realizar verificaciones de integridad sin emular el empaquetador.  En la versión actual del código de shell BattlEye, estos patrones de memoria están codificados: <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span>] ojectsPUBGChinese [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>] BattleGroundsPrivate_CheatESP [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>] [%<span class="hljs-number"><span class="hljs-number">.0</span></span>fm] %s [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>E] <span class="hljs-number"><span class="hljs-number">0000</span></span>Neck0000Chest0000000Mouse <span class="hljs-number"><span class="hljs-number">10</span></span> [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">3F</span></span>] PlayerESPColor [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span>] Aimbot: %d02D3E2041 [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span>] HackMachine [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>A] VisualHacks.net [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span>] <span class="hljs-number"><span class="hljs-number">3E232</span></span>F653E31314E4E563D4276282A3A2E463F757523286752552E6F30584748 [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">4F</span></span>] DLLInjection-master\x64\Release\ [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">52</span></span>] NameESP [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">48</span></span>] Skullhack [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">55</span></span>] .rdata$zzzdbg [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">39</span></span>] AimBot [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">39</span></span>] EB4941803C123F755C623FEB388D41D0FBEC93C977583E930EB683E1DF [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">5F</span></span>] <span class="hljs-number"><span class="hljs-number">55E9</span></span> [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">5F</span></span>] <span class="hljs-number"><span class="hljs-number">57E9</span></span> [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">5F</span></span>] <span class="hljs-number"><span class="hljs-number">60E9</span></span> [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">68</span></span>] D3D11Present initialised [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>E] [ %<span class="hljs-number"><span class="hljs-number">.0</span></span>fM ] [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">74</span></span>] [hp:%d]%dm [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span>] <span class="hljs-number"><span class="hljs-number">48836424380488</span></span>D4C2458488B5424504C8BC848894C24304C8BC7488D4C2460 [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span>] <span class="hljs-number"><span class="hljs-number">741F</span></span>BA80000FF15607E0085C07510F2F1087801008B8788100EB [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span>] <span class="hljs-number"><span class="hljs-number">40F</span></span>2AA156F8D2894E9AB4489535D34F9CPOSITION0000COL [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>A] FFE090 [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">79</span></span>] %s00%d00POSITION0000COLOR0000000 [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span>] <span class="hljs-number"><span class="hljs-number">8E85765</span></span>DCDDA452E75BA12B4C7B94872116DB948A1DAA6B948A7676BB948902C [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>A] n&lt;assembly xmlsn=<span class="hljs-string"><span class="hljs-string">'urn:schemas-mi</span></span></code> </pre> <br>  Estos patrones de memoria también contienen un encabezado de dos bytes, es decir, el valor estático desconocido <code>05</code> y un identificador único. <br><br>  Lo que no veremos es que BattlEye también transmite dinámicamente patrones desde <em>BEServer</em> y los envía a <em>BEClient</em> , pero no discutiremos esto en el artículo. <br><br>  Son escaneados iterativamente por el siguiente algoritmo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> memory::pattern_check(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* current_address, MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> is_user32 = memory_information.allocation_base == GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"user32.dll"</span></span> <span class="hljs-comment"><span class="hljs-comment">// ONLY SCAN PRIVATE MEMORY AND USER32 CODE SECTION if (memory_information.type != MEM_PRIVATE &amp;&amp; !is_user32) continue for (address = current_address address != memory_information.base_address + memory_information.region_size address += PAGE_SIZE) // PAGE_SIZE { // READ ENTIRE PAGE FROM LOCAL PROCESS INTO BUFFER if (NtReadVirtualMemory(GetCurrentProcess(), address, buffer, PAGE_SIZE, 0) &lt; 0) continue for (pattern_index = 0 pattern_index &lt; 0x1C/*PATTERN COUNT*/ ++pattern_index) { if (pattern[pattern_index].header == 0x57A &amp;&amp; !is_user32) // ONLY DO FFE090 SEARCHES WHEN IN USER32 continue for (offset = 0 pattern[pattern_index].length + offset &lt;= PAGE_SIZE ++offset) { const auto pattern_matches = memory::pattern_match(&amp;address[offset], pattern[pattern_index // BASIC PATTERN MATCH if (pattern_matches) { // PATTERN FOUND IN MEMORY pattern_report.unknown = 0 pattern_report.report_id = 0x35 pattern_report.type = pattern[index].header pattern_report.data = &amp;address[offset pattern_report.base_address = memory_information.base_address pattern_report.region_size = memory_information.region_size pattern_report.memory_info = memory_information.type | memory_information.protect | memory_information.state battleye::report(&amp;pattern_report, sizeof(pattern_report), 0 } } } } }</span></span></code> </pre> <br><h1>  Validación de módulos específicos (Microsoft) </h1><br>  Las verificaciones de módulos informan la presencia de módulos específicos cargados en el juego: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> memory::module_specific_check_microsoft(MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> executable = memory_information.protect == PAGE_EXECUTE || memory_information.protect == PAGE_EXECUTE_READ || memory_information.protect == PAGE_EXECUTE_READWRITE <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> allocated = memory_information.state == MEM_COMMIT <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!allocated || !executable) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> mmres_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"mmres.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> mshtml_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"mshtml.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mmres_handle &amp;&amp; mmres_handle == memory_information.allocation_base) { battleye_module_anomaly_report module_anomaly_report module_anomaly_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> module_anomaly_report.report_id = <span class="hljs-number"><span class="hljs-number">0x5B</span></span> module_anomaly_report.identifier = <span class="hljs-number"><span class="hljs-number">0x3480</span></span> module_anomaly_report.region_size = memory_information.region_size battleye::report(&amp;module_anomaly_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(module_anomaly_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mshtml_handle &amp;&amp; mshtml_handle == memory_information.allocation_base) { battleye_module_anomaly_report module_anomaly_report module_anomaly_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> module_anomaly_report.report_id = <span class="hljs-number"><span class="hljs-number">0x5B</span></span> module_anomaly_report.identifier = <span class="hljs-number"><span class="hljs-number">0xB480</span></span> module_anomaly_report.region_size = memory_information.region_size battleye::report(&amp;module_anomaly_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(module_anomaly_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h1>  Comprobación de módulos específicos (desconocido) </h1><br>  Se ha agregado una comprobación de módulos específicos al sistema, que indica al servidor que ha cargado módulos que satisfacen <em>cualquiera</em> de estos criterios: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> memory::module_specific_check_unknown(MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> dos_header = (DOS_HEADER*)module_handle <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pe_header = (PE_HEADER*)(module_handle + dos_header-&gt;e_lfanew <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> is_image = memory_information.state == MEM_COMMIT &amp;&amp; memory_information.type == MEM_IMAGE <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!is_image) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> is_base = memory_information.base_address == memory_information.allocation_base <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!is_base) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> match_1 = time_date_stamp == <span class="hljs-number"><span class="hljs-number">0x5B12C900</span></span> &amp;&amp; *(__int8*)(memory_information.base_address + <span class="hljs-number"><span class="hljs-number">0x1000</span></span>) == <span class="hljs-number"><span class="hljs-number">0x00</span></span> &amp;&amp; *(__int32*)(memory_information.base_address + <span class="hljs-number"><span class="hljs-number">0x501000</span></span>) != <span class="hljs-number"><span class="hljs-number">0x353E900</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> match_2 = time_date_stamp == <span class="hljs-number"><span class="hljs-number">0x5A180C35</span></span> &amp;&amp; *(__int8*)(memory_information.base_address + <span class="hljs-number"><span class="hljs-number">0x1000</span></span>) != <span class="hljs-number"><span class="hljs-number">0x00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> match_2 = time_date_stamp == <span class="hljs-number"><span class="hljs-number">0xFC9B9325</span></span> &amp;&amp; *(__int8*)(memory_information.base_address + <span class="hljs-number"><span class="hljs-number">0x6D3000</span></span>) != <span class="hljs-number"><span class="hljs-number">0x00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match_1 &amp;&amp; !match_2 &amp;&amp; !match_3) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> buffer_offset = <span class="hljs-number"><span class="hljs-number">0x00</span></span> <span class="hljs-comment"><span class="hljs-comment">// OFFSET DEPENDS ON WHICH MODULE MATCHES, RESPECTIVELY 0x501000, 0x1000 AND 0x6D3000 unknown_module_report.unknown1 = 0 unknown_module_report.report_id = 0x46 unknown_module_report.unknown2 = 1 unknown_module_report.data = *(__int128*)(memory_information.base_address + buffer_offset battleye::report(&amp;unknown_module_report, sizeof(unknown_module_report), 0 }</span></span></code> </pre> <br>  No sabemos qué módulos satisfacen estos criterios, pero sospechamos que este es un intento de detectar un conjunto muy limitado de módulos de trucos específicos. <br><br>  Anexo: @ how02 nos informó que el módulo <code>action_x64.dll</code> tiene una <code>0x5B12C900</code> tiempo <code>0x5B12C900</code> y contiene un área de código en la que puede escribir;  Como se mencionó anteriormente, esto se puede utilizar para explotar. <br><br><h1>  Protección de la memoria </h1><br>  BattlEye también implementa un procedimiento de detección muy dudoso, que, en nuestra opinión, busca memoria con el <em>conjunto de</em> indicadores <em>PAGE_GUARD</em> , sin verificar realmente si el indicador <em>PAGE_GUARD</em> está <em>configurado</em> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> memory::guard_check(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* current_address, MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (memory_information.protect != PAGE_NOACCESS) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> bad_ptr = IsBadReadPtr(current_address, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(temporary_buffer <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> read = NtReadVirtualMemory( GetCurrentProcess(), current_address, temporary_buffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(temporary_buffer), <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || bad_ptr) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> query = NtQueryVirtualMemory( GetCurrentProcess(), current_address, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;new_memory_information, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(new_memory_information), &amp;return_length memory_guard_report.guard = query &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || new_memory_information.state != memory_information.state || new_memory_information.protect != memory_information.protect <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (memory_guard_report.guard) { memory_guard_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> memory_guard_report.report_id = <span class="hljs-number"><span class="hljs-number">0x21</span></span> memory_guard_report.base_address = memory_information.base_address memory_guard_report.region_size = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)memory_information.region_size memory_guard_report.memory_info = memory_information.type | memory_information.protect | memory_information.state battleye::report(&amp;memory_guard_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(memory_guard_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } } } }</code> </pre> <br><h2>  Ordenar ventanas </h2><br>  El código de shell BattlEye itera sobre cada una de las ventanas que están visibles actualmente durante el juego, pasando por alto las ventanas de arriba a abajo (por valor z).  Los <code>GetWindowThreadProcessId</code> ventana dentro del juego se excluyen de esta enumeración, y esto se determina llamando a <code>GetWindowThreadProcessId</code> .  Por lo tanto, puede vincular la función correspondiente al falso propietario de la ventana para que <strong>BattlEye no compruebe su ventana</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> window_handler::enumerate() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> window_handle = GetTopWindow window_handle window_handle = GetWindow(window_handle, GW_HWNDNEXT), <span class="hljs-comment"><span class="hljs-comment">// GET WINDOW BELOW ++window_handler::windows_enumerated) // INCREMENT GLOBAL COUNT FOR LATER USAGE { auto window_process_pid = 0 GetWindowThreadProcessId(window_handle, &amp;window_process_pid if (window_process_pid == GetCurrentProcessId()) continue // APPEND INFORMATION TO THE MISC. REPORT, THIS IS EXPLAINED LATER IN THE ARTICLE window_handler::handle_summary(window_handle constexpr auto max_character_count = 0x80 const auto length = GetWindowTextA(window_handle, window_title_report.window_title, max_character_count // DOES WINDOW TITLE MATCH ANY OF THE BLACKLISTED TITLES? if (!contains(window_title_report.window_title, "CheatAut") &amp;&amp; !contains(window_title_report.window_title, "pubg_kh") &amp;&amp; !contains(window_title_report.window_title, "conl -") &amp;&amp; !contains(window_title_report.window_title, "PerfectA") &amp;&amp; !contains(window_title_report.window_title, "AIMWA") &amp;&amp; !contains(window_title_report.window_title, "PUBG AIM") &amp;&amp; !contains(window_title_report.window_title, "HyperChe")) continue // REPORT WINDOW window_title_report.unknown_1 = 0 window_title_report.report_id = 0x33 battleye::report(&amp;window_title_report, sizeof(window_title_report) + length, 0 } }</span></span></code> </pre> <br><h2>  Anomalía de búsqueda </h2><br>  Si se marcan menos de dos ventanas, se envía una notificación al servidor.  Esto probablemente se haga para evitar parchear las funciones correspondientes que no permiten que el código de shell BattlEye examine ninguna ventana: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> window_handler::check_count() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window_handler::windows_enumerated &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">// WINDOW ENUMERATION FAILED, MOST LIKELY DUE TO HOOK window_anomaly_report.unknown_1 = 0 window_anomaly_report.report_id = 0x44 window_anomaly_report.enumerated_windows = windows_enumerated battleye::report(&amp;window_anomaly_report, sizeof(window_anomaly_report), 0 }</span></span></code> </pre> <br><h2>  Clasificación de procesos </h2><br>  Al llamar a <code>CreateToolhelp32Snapshot</code> itera sobre todos los procesos en ejecución, pero <strong>no procesa ningún error</strong> , por lo que es muy fácil parchear y evitar los siguientes procedimientos de detección: <br><br><h1>  Comprobación de ruta </h1><br>  Si la imagen está dentro de al menos dos subdirectorios (contando desde la raíz del disco), el sistema marcará los procesos si la ruta a la imagen correspondiente contiene al menos una de estas líneas: <br><br><pre> <code class="cpp hljs">Desktop Temp FileRec Documents Downloads Roaming tmp.ex notepad. ...\. cmd.ex</code> </pre> <br>  Si la ruta al archivo ejecutable corresponde a una de estas líneas, el servidor recibe una notificación sobre la ruta al archivo ejecutable, así como información sobre si el proceso padre es uno de los siguientes (contiene el bit de bandera correspondiente enviado al servidor): <br><br><pre> <code class="cpp hljs">steam.exe [<span class="hljs-number"><span class="hljs-number">0x01</span></span>] explorer.exe [<span class="hljs-number"><span class="hljs-number">0x02</span></span>] lsass.exe [<span class="hljs-number"><span class="hljs-number">0x08</span></span>] cmd.exe [<span class="hljs-number"><span class="hljs-number">0x10</span></span>]</code> </pre> <br>  Si el cliente no puede abrir el descriptor con los derechos de información <code>QueryLimitedInformation</code> apropiados, establecerá el bit de indicador <code>0x04</code> , si la causa del error cuando falla la llamada de <code>OpenProcess</code> no es <code>ERROR_ACCESS_DENIED</code> , que nos proporciona el último contenedor de enumeración para el valor de indicador correspondiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> BATTLEYE_PROCESS_FLAG { STEAM = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, EXPLORER = <span class="hljs-number"><span class="hljs-number">0x2</span></span>, ERROR = <span class="hljs-number"><span class="hljs-number">0x4</span></span>, LSASS = <span class="hljs-number"><span class="hljs-number">0x8</span></span>, CMD = <span class="hljs-number"><span class="hljs-number">0x10</span></span> }</code> </pre> <br>  Si el proceso principal es steam, entonces el indicador se establece instantáneamente para el usuario y se informa al servidor sobre esto con la identificación de notificación <code>0x40</code> <br><br><h1>  Nombre de la imagen </h1><br>  Si el proceso cumple con alguno de los muchos criterios que se presentan a continuación, se establece una <code>0x38</code> instante y esto se informa al servidor con la identificación de notificación <code>0x38</code> <br><br><pre> <code class="cpp hljs">   <span class="hljs-string"><span class="hljs-string">"Loadlibr"</span></span>    <span class="hljs-string"><span class="hljs-string">"Rng "</span></span>    <span class="hljs-string"><span class="hljs-string">"A0E7FFFFFF81"</span></span>    <span class="hljs-string"><span class="hljs-string">"RNG "</span></span>    <span class="hljs-string"><span class="hljs-string">"90E54355"</span></span>    <span class="hljs-string"><span class="hljs-string">"2.6.ex"</span></span>    <span class="hljs-string"><span class="hljs-string">"TempFile.exe"</span></span></code> </pre> <br><h1>  Steam Game Overlay </h1><br>  BattlEye supervisa el proceso de superposición de juegos de Steam, que es responsable de la superposición en el juego, conocida por la mayoría de los usuarios de Steam.  El nombre de host completo de la superposición de Steam Games es <code>gameoverlayui.exe</code> ;  se sabe que a menudo se usa para renderizar exploits, porque es bastante fácil de hackear y realizar renderizaciones ilegales en la ventana del juego.  La verificación tiene la siguiente condición: <br><br><pre> <code class="cpp hljs">file size != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; image name contains (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> insensitive) gameoverlayu</code> </pre> <br>  Las comprobaciones adicionales específicas para la superposición de juegos de Steam son casi idénticas a los procedimientos realizados para el proceso del juego en sí, por lo tanto, se omiten en el pseudocódigo. <br><br><h1>  Escaneo de memoria de superposición de vapor </h1><br>  El proceso de superposición de juegos de Steam se analiza en busca de patrones y anomalías.  No pudimos profundizar en la madriguera del conejo y descubrir para qué sirven estos patrones, porque son muy generalizados y muy probablemente asociados con módulos de trucos. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> gameoverlay::pattern_scan(MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-comment"><span class="hljs-comment">// PATTERNS: // Home // F1 // FFFF83C48C30000000000 // \.pipe%s // C760000C64730 // 60C01810033D2 // ... // PATTERN SCAN, ALMOST IDENTICAL CODE TO THE AFOREMENTIONED PATTERN SCANNING ROUTINE gameoverlay_memory_report.unknown_1 = 0 gameoverlay_memory_report.report_id = 0x35 gameoverlay_memory_report.identifier = 0x56C gameoverlay_memory_report.data = &amp;buffer[offset gameoverlay_memory_report.base_address = memory_information.base_address gameoverlay_memory_report.region_size = (int)memory_information.region_size gameoverlay_memory_report.memory_info = memory_information.type | memory_information.protect | memory_information.state battleye::report(&amp;gameoverlay_memory_report, sizeof(gameoverlay_memory_report), 0 }</span></span></code> </pre> <br>  El procedimiento de escaneo también busca cualquier anomalía en forma de código ejecutable fuera de las imágenes descargadas, lo que sugiere que los crackers inyectaron el código en el proceso de superposición: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> gameoverlay::memory_anomaly_scan(MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-comment"><span class="hljs-comment">// ... // ALMOST IDENTICAL ANOMALY SCAN COMPARED TO MEMORY ENUMERATION ROUTINE OF GAME PROCESS gameoverlay_report.unknown = 0 gameoverlay_report.report_id = 0x3B gameoverlay_report.base_address = memory_information.base_address gameoverlay_report.region_size = memory_information.region_size gameoverlay_report.memory_info = memory_information.type | memory_information.protect | memory_information.state battleye::report(&amp;gameoverlay_report, sizeof(gameoverlay_report), 0 }</span></span></code> </pre> <br><h1>  Protección de superposición de juegos de Steam </h1><br>  Si el proceso de superposición de juegos de Steam está protegido por alguna protección de procesos de Windows como <em>Light (WinTcb)</em> , entonces el servidor recibirá una notificación al respecto. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> gameoverlay::protection_check(HANDLE process_handle) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> process_protection = <span class="hljs-number"><span class="hljs-number">0</span></span> NtQueryInformationProcess( process_handle, ProcessProtectionInformation, &amp;process_protection, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(process_protection), <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process_protection == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// NO PROTECTION return gameoverlay_protected_report.unknown = 0 gameoverlay_protected_report.report_id = 0x35 gameoverlay_protected_report.identifier = 0x5B1 gameoverlay_protected_report.data = process_protection battleye::report(&amp;gameoverlay_protected_report, sizeof(gameoverlay_protected_report), 0 }</span></span></code> </pre> <br>  Además, si la llamada correspondiente de <em>OpenProcess</em> devuelve <em>ERROR_ACCESS_DENIED</em> al proceso de superposición, se envía una notificación sobre el usuario con id <code>3B</code> . <br><br><h1>  Módulos de clasificación </h1><br>  También se buscan módulos de proceso de superposición de juegos de Steam, en particular, se <code>vgui2_s.dll</code> y <code>gameoverlayui.dll</code> .  Se realizan varias verificaciones para estos módulos, comenzando con <code>gameoverlayui.dll</code> . <br><br>  Si se cumple esta condición: <code>[gameoverlayui.dll+6C779] == 08BE55DC3CCCCB8????????C3CCCCCC</code> , entonces el <code>[gameoverlayui.dll+6C779] == 08BE55DC3CCCCB8????????C3CCCCCC</code> escanea la vtable en la dirección almacenada en bytes <code>????????</code>  .  Si alguno de estos elementos vtable está fuera del módulo fuente gameoverlayui.dll o apunta a una instrucción <code>int 3</code> , el usuario es informado al servidor con una identificación de notificación de <code>3B</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> gameoverlay::scan_vtable(HANDLE process_handle, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* buffer, MODULEENTRY32 module_entry) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> function_buffer[<span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (vtable_index = <span class="hljs-number"><span class="hljs-number">0</span></span> vtable_index &lt; <span class="hljs-number"><span class="hljs-number">20</span></span> vtable_index += <span class="hljs-number"><span class="hljs-number">4</span></span>) { NtReadVirtualMemory( process_handle, *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)&amp;buffer[vtable_index], &amp;function_buffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(function_buffer), <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)&amp;buffer[vtable_index] &lt; module_entry.modBaseAddr || *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)&amp;buffer[vtable_index] &gt;= module_entry.modBaseAddr + module_entry.modBaseSize || function_buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">0xCC</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// FUNCTION PADDING { gameoverlay_vtable_report.report_id = 0x3B gameoverlay_vtable_report.vtable_index = vtable_index gameoverlay_vtable_report.address = buffer[vtable_index battleye::report(&amp;gameoverlay_vtable_report, sizeof(gameoverlay_vtable_report), 0 } } }</span></span></code> </pre> <br>  También se realiza un procedimiento de verificación específico para el módulo <code>vgui2_s.dll</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> vgui::scan() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!equals(vgui_buffer, <span class="hljs-string"><span class="hljs-string">"6A08B31FF561C8BD??????????FF96????????8BD????????8B1FF90"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> could_read = NtReadVirtualMemory( process_handle, module_entry.modBaseAddr + <span class="hljs-number"><span class="hljs-number">0x48338</span></span>, vgui_buffer, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pattern_offset = <span class="hljs-number"><span class="hljs-number">0x48378</span></span> <span class="hljs-comment"><span class="hljs-comment">// IF READ DID NOT FAIL AND PATTERN IS FOUND if (could_read &amp;&amp; equals(vgui_buffer, "6A46A06A26A")) { vgui_report.unknown_1 = 0 vgui_report.report_id = 0x3B vgui_report.unknown_2 = 0 vgui_report.address = LODWORD(module_entry.modBaseAddr) + pattern_offset // READ TARGET BUFFER INTO REPORT NtReadVirtualMemory( process_handle, module_entry.modBaseAddr + pattern_offset, vgui_report.buffer, sizeof(vgui_report.buffer), 0 battleye::report(&amp;vgui_report, sizeof(vgui_report), 0 } } else if ( // READ ADDRESS FROM CODE NtReadVirtualMemory(process_handle, *(int*)&amp;vgui_buffer[9], vgui_buffer, 4, 0) &gt;= 0 &amp;&amp; // READ POINTER TO CLASS NtReadVirtualMemory(process_handle, *(int*)vgui_buffer, vgui_buffer, 4, 0) &gt;= 0 &amp;&amp; // READ POINTER TO VIRTUAL TABLE NtReadVirtualMemory(process_handle, *(int*)vgui_buffer, vgui_buffer, sizeof(vgui_buffer), 0) &gt;= 0) { for (vtable_index = 0 vtable_index &lt; 984 vtable_index += 4 ) // 984/4 VTABLE ENTRY COUNT { NtReadVirtualMemory(process_handle, *(int*)&amp;vgui_buffer[vtable_index], &amp;vtable_entry, sizeof(vtable_entry), 0 if (*(int*)&amp;vgui_buffer[vtable_index] &lt; module_entry.modBaseAddr || *(int*)&amp;vgui_buffer[vtable_index] &gt;= module_entry.modBaseAddr + module_entry.modBaseSize || vtable_entry == 0xCC ) { vgui_vtable_report.unknown = 0 vgui_vtable_report.report_id = 0x3B vgui_vtable_report.vtable_index = vtable_index vgui_vtable_report.address = *(int*)&amp;vgui_buffer[vtable_index battleye::report(&amp;vgui_vtable_report, sizeof(vgui_vtable_report), 0 } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este procedimiento busca cambios en el desplazamiento </font></font><code>48378</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que es la ubicación del área de código:</font></font><br><br><pre> <code class="cpp hljs">push <span class="hljs-number"><span class="hljs-number">04</span></span> push offset aCBuildslaveSte_4 ; <span class="hljs-string"><span class="hljs-string">"c:\buildslave\steam_rel_client_win32"</span></span>... push offset aAssertionFaile_7 ; <span class="hljs-string"><span class="hljs-string">"Assertion Failed: IsValidIndex(elem)"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El procedimiento luego verifica un cambio muy específico y aparentemente basura: </font></font><br><br><pre> <code class="cpp hljs">push <span class="hljs-number"><span class="hljs-number">04</span></span> push <span class="hljs-number"><span class="hljs-number">00</span></span> push <span class="hljs-number"><span class="hljs-number">02</span></span> push ??</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No hemos podido encontrar una copia de vgui2_s.dll que no coincida con la primera de las dos comprobaciones anteriores, por lo que no podemos averiguar qué tabla comprueba. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Steam Overlay Streams </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Las secuencias en el proceso de superponer juegos de Steam también se mueven: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> gameoverlay::check_thread(THREADENTRY32 thread_entry) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tread_handle = OpenThread(THREAD_SUSPEND_RESUME|THREAD_GET_CONTEXT, <span class="hljs-number"><span class="hljs-number">0</span></span>, thread_entry.th32ThreadID <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (thread_handle) { suspend_count = ResumeThread(thread_handle <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (suspend_count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { SuspendThread(thread_handle gameoverlay_thread_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> gameoverlay_thread_report.report_id = <span class="hljs-number"><span class="hljs-number">0x3B</span></span> gameoverlay_thread_report.suspend_count = suspend_count battleye::report(&amp;gameoverlay_thread_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(gameoverlay_thread_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetThreadContext(thread_handle, &amp;context) &amp;&amp; context.Dr7) { gameoverlay_debug_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> gameoverlay_debug_report.report_id = <span class="hljs-number"><span class="hljs-number">0x3B</span></span> gameoverlay_debug_report.debug_register = context.Dr0 battleye::report(&amp;gameoverlay_debug_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(gameoverlay_debug_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LSASS </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El espacio de direcciones de memoria del proceso Windows </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lsass.exe</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , también conocido como proceso de la Autoridad de Seguridad Local, también se escanea y todas las anomalías se informan al servidor, como en el caso de las dos comprobaciones anteriores:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (equals(process_entry.executable_path, <span class="hljs-string"><span class="hljs-string">"lsass.exe"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> lsass_handle = OpenProcess(QueryInformation, <span class="hljs-number"><span class="hljs-number">0</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)process_entry.th32ProcessID <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lsass_handle) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (address = <span class="hljs-number"><span class="hljs-number">0</span></span> NtQueryVirtualMemory(lsass_handle, address, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;lsass_memory_info, <span class="hljs-number"><span class="hljs-number">0x30</span></span>, &amp;bytes_needed) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> address = lsass_memory_info.base_address + lsass_memory_info.region_size) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lsass_memory_info.state == MEM_COMMIT &amp;&amp; lsass_memory_info.type == MEM_PRIVATE &amp;&amp; (lsass_memory_info.protect == PAGE_EXECUTE || lsass_memory_info.protect == PAGE_EXECUTE_READ || lsass_memory_info.protect == PAGE_EXECUTE_READWRITE)) { <span class="hljs-comment"><span class="hljs-comment">// FOUND EXECUTABLE MEMORY OUTSIDE OF MODULES lsass_report.unknown = 0 lsass_report.report_id = 0x42 lsass_report.base_address = lsass_memory_info.base_address lsass_report.region_size = lsass_memory_info.region_size lsass_report.memory_info = lsass_memory_info.type | lsass_memory_info.protect | lsass_memory_info.state battleye::report(&amp;lsass_report, sizeof(lsass_report), 0 } } CloseHandle(lsass_handle } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LSASS se utilizó anteriormente en exploits para realizar operaciones con memoria, ya que cualquier proceso que necesite una conexión a Internet debe proporcionarle acceso LSASS. </font><font style="vertical-align: inherit;">BattlEye está lidiando actualmente con este problema borrando manualmente el identificador de proceso de las operaciones de lectura / escritura y luego </font><font style="vertical-align: inherit;">adjuntando </font></font><code>ReadProcessMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>WriteProcessMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">redirigiendo las llamadas a su controlador BEDaisy. </font><font style="vertical-align: inherit;">Luego, BEDaisy decide si la operación de memoria es legal. </font><font style="vertical-align: inherit;">Si cree que la operación es legal, entonces la continúa, y de lo contrario enciende deliberadamente la máquina con una pantalla azul.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Varias notificaciones </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BattlEye recopila información diversa y la envía al servidor con la identificación de notificación </font></font><code>3C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esta información consta de los siguientes elementos:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cualquier ventana con el indicador </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WS_EX_TOPMOST</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o sus análogos:</font></font><ul><li>   (Unicode) </li><li>    (Unicode) </li><li> Window style </li><li> Window extended style </li><li>   </li><li>    - </li><li>   - </li></ul></li><li>        (VM_WRITE|VM_READ) <ul><li>   </li><li>    </li><li>   </li><li>    </li></ul></li><li>    : <br><ul><li> ….ContentPaksTslGame-WindowsNoEditor_assets_world.pak </li><li> ….ContentPaksTslGame-WindowsNoEditor_ui.pak </li><li> ….ContentPaksTslGame-WindowsNoEditor_sound.pak </li></ul><br></li><li>    : <br><ul><li> ….BLGameCookedContentScriptBLGame.u </li></ul></li><li>    NtGetContextThread <br><ul><li>     (E9),       </li></ul></li></ul><br><h2> NoEye </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BattlEye implementa una comprobación bastante perezosa para detectar un rootkit de acceso público para evitar este anti-trampa llamado NoEye: el sistema usa </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetFileAttributesExA para</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verificar el tamaño del archivo </font></font><code>BE_DLL.dll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si esta biblioteca se encuentra en el disco.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> noeye::detect() { <span class="hljs-function"><span class="hljs-function">WIN32_FILE_ATTRIBUTE_DATA file_information </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GetFileAttributesExA(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"BE_DLL.dll"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, &amp;file_information))</span></span></span><span class="hljs-function"> </span></span>{ noeye_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> noeye_report.report_id = <span class="hljs-number"><span class="hljs-number">0x3D</span></span> noeye_report.file_size = file_information.nFileSizeLow battleye::report(&amp;noeye_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(noeye_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Disponibilidad del conductor </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comprobaciones para dispositivos Beep y Null; </font><font style="vertical-align: inherit;">si lo hay, se genera una notificación. </font><font style="vertical-align: inherit;">En el estado normal, estos dos dispositivos no están disponibles en el sistema, y ​​esto puede indicar que alguien encendió el dispositivo manualmente. </font><font style="vertical-align: inherit;">Esta técnica se llama secuestro del dispositivo del controlador. </font><font style="vertical-align: inherit;">Esto es para garantizar que los datos IOCTL se intercambien con el controlador malicioso sin la necesidad de un objeto de controlador separado para este controlador.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> driver::check_beep() { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> handle = CreateFileA(<span class="hljs-string"><span class="hljs-string">"\\.\Beep"</span></span>, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="hljs-number"><span class="hljs-number">0</span></span>, OPEN_EXISTING, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle != INVALID_HANDLE_VALUE) { beep_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> beep_report.report_id = <span class="hljs-number"><span class="hljs-number">0x3E</span></span> battleye::report(&amp;beep_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(beep_report), <span class="hljs-number"><span class="hljs-number">0</span></span> CloseHandle(handle } }</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> driver::check_null() { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> handle = CreateFileA(<span class="hljs-string"><span class="hljs-string">"\\.\Null"</span></span>, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="hljs-number"><span class="hljs-number">0</span></span>, OPEN_EXISTING, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle != INVALID_HANDLE_VALUE) { null_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> null_report.report_id = <span class="hljs-number"><span class="hljs-number">0x3E</span></span> battleye::report(&amp;null_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(null_report), <span class="hljs-number"><span class="hljs-number">0</span></span> CloseHandle(handle } }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Delta del sueño </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Además, BattlEye puede solicitar un segundo de inactividad del hilo actual y mide la diferencia en el número de ciclos antes y después de la inactividad (suspensión): </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> sleep::check_delta() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tick_count = GetTickCount Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tick_delta = GetTickCount() - tick_count <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tick_delta &gt;= <span class="hljs-number"><span class="hljs-number">1200</span></span>) { sleep_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> sleep_report.report_id = <span class="hljs-number"><span class="hljs-number">0x45</span></span> sleep_report.delta = tick_delta battleye::report(&amp;sleep_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sleep_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7zip </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se ha agregado una verificación de integridad muy perezosa a BattlEye para que los usuarios no puedan cargar la biblioteca 7zip en los procesos del juego y sobrescribir áreas. </font><font style="vertical-align: inherit;">Los usuarios hicieron esto para reducir la gravedad de los escaneos de patrones y la detección de anomalías descritos anteriormente. </font><font style="vertical-align: inherit;">BattlEye simplemente decidió agregar verificaciones de integridad para esta biblioteca particular de 7zip.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_7zip() { <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sz_7zipdll = <span class="hljs-string"><span class="hljs-string">"..\..\Plugins\ZipUtility\ThirdParty\7zpp\dll\Win64\7z.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(sz_7zipdll <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle &amp;&amp; *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1000</span></span>) != <span class="hljs-number"><span class="hljs-number">0xFF1441C7</span></span>) { sevenzip_report.unknown_1 = <span class="hljs-number"><span class="hljs-number">0</span></span> sevenzip_report.report_id = <span class="hljs-number"><span class="hljs-number">0x46</span></span> sevenzip_report.unknown_2 = <span class="hljs-number"><span class="hljs-number">0</span></span> sevenzip_report.data1 = *(__int64*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1000</span></span> sevenzip_report.data2 = *(__int64*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1008</span></span> battleye::report(&amp;sevenzip_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sevenzip_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Capa de abstracción de hardware </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> BattlEye busca una biblioteca de capa de abstracción de hardware de Windows vinculada dinámicamente (hal.dll) y le dice al servidor si está cargada dentro del juego. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_hal() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"hal.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { hal_report.unknown_1 = <span class="hljs-number"><span class="hljs-number">0</span></span> hal_report.report_id = <span class="hljs-number"><span class="hljs-number">0x46</span></span> hal_report.unknown_2 = <span class="hljs-number"><span class="hljs-number">2</span></span> hal_report.data1 = *(__int64*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1000</span></span> hal_report.data2 = *(__int64*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1008</span></span> battleye::report(&amp;hal_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(hal_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verificaciones de imagen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BattlEye también verifica varias imágenes cargadas en el juego. </font><font style="vertical-align: inherit;">Se supone que estos módulos son imágenes firmadas que de alguna manera se manipulan, cambiando su comportamiento a malicioso, pero no podemos decir nada más sobre ellos, solo sobre su detección:</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nvToolsExt64_1 </font></font></h1><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_nvtoolsext64_1 { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"nvToolsExt64_1.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { nvtools_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> nvtools_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> nvtools_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5A8</span></span> nvtools_report.size_of_image = (PE_HEADER*)(module_handle + (DOS_HEADER*)(module_handle)-&gt;e_lfanew))-&gt;SizeOfImage battleye::report(&amp;nvtools_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nvtools_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ws2detour_x96 </font></font></h1><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_ws2detour_x96 { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"ws2detour_x96.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { ws2detour_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> ws2detour_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> ws2detour_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5B5</span></span> ws2detour_report.size_of_image = (PE_HEADER*)(module_handle + (DOS_HEADER*)(module_handle)-&gt;e_lfanew))-&gt;SizeOfImage battleye::report(&amp;ws2detour_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ws2detour_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> networkdllx64 </font></font></h1><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_networkdllx64 { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"networkdllx64.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> dos_header = (DOS_HEADER*)module_handle <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pe_header = (PE_HEADER*)(module_handle + dos_header-&gt;e_lfanew <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size_of_image = pe_header-&gt;SizeOfImage <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size_of_image &lt; <span class="hljs-number"><span class="hljs-number">0x200000</span></span> || size_of_image &gt;= <span class="hljs-number"><span class="hljs-number">0x400000</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pe_header-&gt;sections[DEBUG_DIRECTORY].size == <span class="hljs-number"><span class="hljs-number">0x1B20</span></span>) { networkdll64_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> networkdll64_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> networkdll64_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5B7</span></span> networkdll64_report.data = pe_header-&gt;TimeDatestamp battleye::report(&amp;networkdll64_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(networkdll64_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { networkdll64_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> networkdll64_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> networkdll64_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5B7</span></span> networkdll64_report.data = pe_header-&gt;sections[DEBUG_DIRECTORY].size battleye::report(&amp;networkdll64_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(networkdll64_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nxdetours_64 </font></font></h1><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_nxdetours_64 { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"nxdetours_64.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { nxdetours64_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> nxdetours64_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> nxdetours64_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5B8</span></span> nxdetours64_report.size_of_image = (PE_HEADER*)(module_handle + (DOS_HEADER*)(module_handle)-&gt;e_lfanew))-&gt;SizeOfImage battleye::report(&amp;nxdetours64_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nxdetours64_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nvcompiler </font></font></h1><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_nvcompiler { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"nvcompiler.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { nvcompiler_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> nvcompiler_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> nvcompiler_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5BC</span></span> nvcompiler_report.data = *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1000</span></span> battleye::report(&amp;nvcompiler_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nvcompiler_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wmp </font></font></h1><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_wmp { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"wmp.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { wmp_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> wmp_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> wmp_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5BE</span></span> wmp_report.data = *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1000</span></span> battleye::report(&amp;wmp_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(wmp_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Identificadores de enumeración de módulos </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como referencia, le damos la identificación de enumeración para los módulos: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> module_id { nvtoolsext64 = <span class="hljs-number"><span class="hljs-number">0x5A8</span></span>, ws2detour_x96 = <span class="hljs-number"><span class="hljs-number">0x5B5</span></span>, networkdll64 = <span class="hljs-number"><span class="hljs-number">0x5B7</span></span>, nxdetours_64 = <span class="hljs-number"><span class="hljs-number">0x5B8</span></span>, nvcompiler = <span class="hljs-number"><span class="hljs-number">0x5BC</span></span>, wmp = <span class="hljs-number"><span class="hljs-number">0x5BE</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escanear tablas TCP </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El código de shell BattlEye busca una lista de conexiones TCP para todo el sistema (conocida como la tabla TCP) e informa si el usuario está conectado al menos a una de las direcciones IP de la puerta de enlace Cloudflare que pertenecen al sitio web alemán de pago -cheat llamada </font></font><a href="https://xera.ph/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xera.ph</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Este mecanismo se ha agregado al código de shell para detectar usuarios que tienen el iniciador en ejecución cuando el juego se está ejecutando, haciéndolos fáciles de reconocer. El único problema con este mecanismo es que las direcciones IP de la puerta de enlace de Cloudflare pueden cambiar de propietario más adelante. y si su nuevo propietario distribuye software que se conecta a sus servidores a través de un puerto específico, entonces se producirán disparadores falsos positivos contra trampas sin ninguna duda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pagar para engañar a los </font><em><font style="vertical-align: inherit;">usuarios del</font></em><font style="vertical-align: inherit;"> proveedor de servicios </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xera.ph</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durante mucho tiempo han estado informando que están siendo atrapados, y los desarrolladores no pueden lidiar con eso de ninguna manera. </font><font style="vertical-align: inherit;">Nos pusimos en contacto con los desarrolladores de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xera.ph</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para informarles de su comportamiento estúpido, pero nos entendieron mal y nos enviaron una copia gratuita, sin pensar que podríamos piratearla y liberarla. </font><font style="vertical-align: inherit;">No haremos esto, pero probablemente no debería enviar archivos binarios con licencia de propiedad de forma gratuita a las personas involucradas en ingeniería inversa y esperar que no sean pirateados.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> network::scan_tcp_table { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(local_port_buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(local_port_buffer <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (iteration_index = <span class="hljs-number"><span class="hljs-number">0</span></span> iteration_index &lt; <span class="hljs-number"><span class="hljs-number">500</span></span> ++iteration_index) { <span class="hljs-comment"><span class="hljs-comment">// GET NECESSARY SIZE OF TCP TABLE auto table_size = 0 GetExtendedTcpTable(0, &amp;table_size, false, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0 // ALLOCATE BUFFER OF PROPER SIZE FOR TCP TABLE auto allocated_ip_table = (MIB_TCPTABLE_OWNER_MODULE*)malloc(table_size if (GetExtendedTcpTable(allocated_ip_table, &amp;table_size, false, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0) != NO_ERROR) goto cleanup for (entry_index = 0 entry_index &lt; allocated_ip_table-&gt;dwNumEntries ++entry_index) { const auto ip_address_match_1 = allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656B1468 // 104.20.107.101 const auto ip_address_match_2 = allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656C1468 // 104.20.108.101 const auto port_match = allocated_ip_table-&gt;table[entry_index].dwRemotePort == 20480 if ( (!ip_address_match_1 &amp;&amp; !ip_address_match_2) || !port_match) continue for (port_index = 0 port_index &lt; 10 &amp;&amp; allocated_ip_table-&gt;table[entry_index].dwLocalPort != local_port_buffer[port_index ++port_index) { if (local_port_buffer[port_index]) continue tcp_table_report.unknown = 0 tcp_table_report.report_id = 0x48 tcp_table_report.module_id = 0x5B9 tcp_table_report.data = BYTE1(allocated_ip_table-&gt;table[entry_index].dwLocalPort) | (LOBYTE(allocated_ip_table-&gt;table[entry_index.dwLocalPort) &lt;&lt; 8 battleye::report(&amp;tcp_table_report, sizeof(tcp_table_report), 0 local_port_buffer[port_index] = allocated_ip_table-&gt;table[entry_index].dwLocalPort break } } cleanup: // FREE TABLE AND SLEEP free(allocated_ip_table Sleep(10 } }</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tipos de notificaciones </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aquí hay como referencia todos los tipos conocidos de notificaciones del código de shell: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> BATTLEYE_REPORT_ID { MEMORY_GUARD = <span class="hljs-number"><span class="hljs-number">0x21</span></span>, MEMORY_SUSPICIOUS = <span class="hljs-number"><span class="hljs-number">0x2F</span></span>, WINDOW_TITLE = <span class="hljs-number"><span class="hljs-number">0x33</span></span>, MEMORY = <span class="hljs-number"><span class="hljs-number">0x35</span></span>, PROCESS_ANOMALY = <span class="hljs-number"><span class="hljs-number">0x38</span></span>, DRIVER_BEEP_PRESENCE = <span class="hljs-number"><span class="hljs-number">0x3E</span></span>, DRIVER_NULL_PRESENCE = <span class="hljs-number"><span class="hljs-number">0x3F</span></span>, MISCELLANEOUS_ANOMALY = <span class="hljs-number"><span class="hljs-number">0x3B</span></span>, PROCESS_SUSPICIOUS = <span class="hljs-number"><span class="hljs-number">0x40</span></span>, LSASS_MEMORY = <span class="hljs-number"><span class="hljs-number">0x42</span></span>, SLEEP_ANOMALY = <span class="hljs-number"><span class="hljs-number">0x45</span></span>, MEMORY_MODULE_SPECIFIC = <span class="hljs-number"><span class="hljs-number">0x46</span></span>, GENERIC_ANOMALY = <span class="hljs-number"><span class="hljs-number">0x48</span></span>, MEMORY_MODULE_SPECIFIC2 = <span class="hljs-number"><span class="hljs-number">0x5B</span></span>, }</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/483068/">https://habr.com/ru/post/483068/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../483054/index.html">"No habrá masacre" - la historia de la traducción de The Worm</a></li>
<li><a href="../483056/index.html">Campos lógicos en bases de datos, ¿hay un antídoto?</a></li>
<li><a href="../483058/index.html">Resultados de la encuesta de vacaciones</a></li>
<li><a href="../483064/index.html">Vue para el blog más pequeño conocido como pequeño en todos los cánones</a></li>
<li><a href="../483066/index.html">Los 5 libros tradicionales de Bill Gates</a></li>
<li><a href="../483074/index.html">TensorRT 6.xxx: inferencia de alto rendimiento para modelos de aprendizaje profundo (detección y segmentación de objetos)</a></li>
<li><a href="../483076/index.html">Principales lenguajes de programación para el desarrollo de aplicaciones de Android en 2020</a></li>
<li><a href="../483078/index.html">Aprendizaje de refuerzo profundo: cómo enseñar a las arañas a caminar</a></li>
<li><a href="../483082/index.html">La caza de vulnerabilidades es un 7% más efectiva</a></li>
<li><a href="../483084/index.html">Cámara con función de seguimiento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>