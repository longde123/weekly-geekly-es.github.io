<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👎🏽 🚩 🤜🏾 Bagaimana cara mengajar telepon untuk melihat keindahan 🧦 🌰 🐭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, saya membaca sebuah buku tentang matematika dan keindahan orang-orang dan berpikir tentang apa yang sepuluh tahun lalu, gagasan tentang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara mengajar telepon untuk melihat keindahan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485858/"><img src="https://habrastorage.org/webt/-f/0z/on/-f0zonxrb_qtnmaxp2bt34gu-d4.png" alt="gambar"><br><br>  Baru-baru ini, saya membaca sebuah buku tentang matematika dan keindahan orang-orang dan berpikir tentang apa yang sepuluh tahun lalu, gagasan tentang bagaimana memahami kecantikan manusia apa yang cukup primitif.  Penalaran tentang wajah mana yang dianggap indah dari sudut pandang matematika sampai pada fakta bahwa itu harus simetris.  Juga, sejak Renaissance, ada upaya untuk menggambarkan wajah cantik menggunakan hubungan antara jarak pada beberapa titik di wajah dan menunjukkan, misalnya, bahwa wajah cantik memiliki semacam hubungan dekat dengan rasio emas.  Gagasan serupa tentang lokasi titik sekarang digunakan sebagai salah satu metode untuk mengidentifikasi wajah (pencarian landmark wajah).  Namun, seperti yang ditunjukkan oleh pengalaman, jika Anda tidak membatasi serangkaian tanda pada posisi titik tertentu pada wajah, Anda dapat mencapai hasil yang lebih baik dalam sejumlah tugas, <a href="https://arxiv.org/abs/1603.01249" rel="nofollow">termasuk menentukan usia, jenis kelamin</a> atau bahkan <a href="https://www.gsb.stanford.edu/sites/gsb/files/publication-pdf/wang_kosinski.pdf" rel="nofollow">orientasi seksual</a> .  Sudah jelas di sini bahwa masalah etika penerbitan hasil-hasil studi semacam itu mungkin bersifat akut. <br><a name="habracut"></a><br>  Topik kecantikan orang dan penilaiannya juga bisa menjadi kontroversial secara etis.  Saat mengembangkan aplikasi, banyak teman saya menolak untuk menggunakan foto mereka untuk tes, atau hanya tidak ingin tahu hasilnya (lucu bahwa sebagian besar perempuan menolak untuk mengetahui hasilnya).  Juga, tujuan penilaian kecantikan otomatis dapat menimbulkan pertanyaan filosofis yang menarik.  Sejauh mana konsep kecantikan ditentukan oleh budaya?  Seberapa benar “Kecantikan di mata yang melihatnya”?  Apakah mungkin untuk menyoroti tanda-tanda keindahan objektif? <br><br>  Untuk menjawab pertanyaan ini, Anda perlu mempelajari statistik tentang peringkat beberapa orang oleh orang lain.  Saya mencoba merancang dan melatih model jaringan saraf yang akan mengevaluasi kecantikan, serta menjalankannya di ponsel android. <br><br><h2>  Bagian 0. Pipa </h2><br>  Untuk memahami bagaimana langkah-langkah selanjutnya terkait satu sama lain, saya menggambar diagram proyek: <br><br><img src="https://habrastorage.org/webt/cy/jp/zh/cyjpzhhy_hiczxqefjp9qgaohf0.png" alt="gambar"><br><br>  Biru - perpustakaan penting dan data eksternal.  Kuning - kontrol dalam aplikasi. <br><br><h2>  Bagian 1. Python </h2><br>  Karena penilaian kecantikan adalah topik yang agak rumit, tidak ada terlalu banyak kumpulan data di domain publik yang berisi foto dengan penilaian (saya yakin bahwa layanan kencan online seperti pekerja tambang memiliki set statistik yang jauh lebih besar).  Saya menemukan <a href="https://github.com/HCIILAB/SCUT-FBP5500-Database-Release" rel="nofollow">database yang</a> dikompilasi di salah satu universitas di China, yang berisi 5.500 foto, masing-masing dievaluasi oleh 7 evaluator dari kalangan mahasiswa Tiongkok.  Dari 5.500 foto, 2.000 adalah pria Asia (AM), 2000 adalah wanita Asia (AF), dan 750 pria Europioid (CM) dan wanita (CF) masing-masing. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fcf/1db/f9b/fcf1dbf9b67fee5543fdc9833d429676.jpg" alt="gambar"><br><br>  Mari kita baca data menggunakan modul Python panda dan lihat datanya.  Perkiraan distribusi untuk jenis kelamin dan ras yang berbeda: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt ratingDS=pd.read_excel(<span class="hljs-string"><span class="hljs-string">'../input/faces-scut/scut-fbp5500_v2/SCUT-FBP5500_v2/All_Ratings.xlsx'</span></span>) Answer=ratingDS.groupby(<span class="hljs-string"><span class="hljs-string">'Filename'</span></span>).mean()[<span class="hljs-string"><span class="hljs-string">'Rating'</span></span>] ratingDS[<span class="hljs-string"><span class="hljs-string">'race'</span></span>]=ratingDS[<span class="hljs-string"><span class="hljs-string">'Filename'</span></span>].apply(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x:x[:<span class="hljs-number"><span class="hljs-number">2</span></span>]) fig, ax = plt.subplots(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, sharex=<span class="hljs-string"><span class="hljs-string">'col'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, race <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate([<span class="hljs-string"><span class="hljs-string">'CF'</span></span>,<span class="hljs-string"><span class="hljs-string">'CM'</span></span>,<span class="hljs-string"><span class="hljs-string">'AF'</span></span>,<span class="hljs-string"><span class="hljs-string">'AM'</span></span>]): sbp=ax[i%<span class="hljs-number"><span class="hljs-number">2</span></span>,i//<span class="hljs-number"><span class="hljs-number">2</span></span>] ratingDS[ratingDS[<span class="hljs-string"><span class="hljs-string">'race'</span></span>]==race].groupby(<span class="hljs-string"><span class="hljs-string">'Filename'</span></span>)[<span class="hljs-string"><span class="hljs-string">'Rating'</span></span>].mean().hist(alpha=<span class="hljs-number"><span class="hljs-number">0.5</span></span>, bins=<span class="hljs-number"><span class="hljs-number">20</span></span>,label=race,grid=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>,rwidth=<span class="hljs-number"><span class="hljs-number">0.9</span></span>,ax=sbp) sbp.set_title(race)</code> </pre> <br><img src="https://habrastorage.org/webt/fz/1q/fo/fz1qfoby_-ijefbbl4ifctz3llo.png" alt="gambar"><br><br>  Dapat dilihat bahwa, secara umum, pria dianggap kurang cantik daripada wanita, distribusinya adalah bimodal - ada yang seperti itu.  yang dianggap cantik dan "rata-rata".  Hampir tidak ada peringkat rendah, sehingga data dapat dinormalisasi ulang.  Tapi mari kita tinggalkan mereka untuk saat ini. <br><br>  Mari kita lihat deviasi standar dalam perkiraan: <br><br><pre> <code class="python hljs">ratingDS.groupby(<span class="hljs-string"><span class="hljs-string">'Filename'</span></span>)[<span class="hljs-string"><span class="hljs-string">'Rating'</span></span>].std().mean()</code> </pre><br>  Itu adalah 0,64, yang berarti bahwa perbedaan dalam penilaian evaluator yang berbeda kurang dari 1 poin dari 5, yang menunjukkan kebulatan suara dalam penilaian keindahan.  Dapat dikatakan bahwa "kecantikan TIDAK di mata yang melihatnya."  Saat membuat rata-rata, Anda dapat menggunakan data dengan andal untuk melatih model dan tidak khawatir tentang ketidakmungkinan mendasar dari evaluasi program. <br><br>  Namun, meskipun nilai standar deviasi estimasi kecil, pendapat beberapa evaluator bisa sangat berbeda dari yang "biasa".  Mari kita bangun distribusi perbedaan antara taksiran dan median: <br><br><pre> <code class="python hljs">R2=ratingDS.join(ratingDS.groupby(<span class="hljs-string"><span class="hljs-string">'Filename'</span></span>)[<span class="hljs-string"><span class="hljs-string">'Rating'</span></span>].median(), on=<span class="hljs-string"><span class="hljs-string">'Filename'</span></span>, how=<span class="hljs-string"><span class="hljs-string">'inner'</span></span>,rsuffix =<span class="hljs-string"><span class="hljs-string">' median'</span></span>) R2[<span class="hljs-string"><span class="hljs-string">'ratingdiff'</span></span>]=(R2[<span class="hljs-string"><span class="hljs-string">'Rating median'</span></span>]-R2[<span class="hljs-string"><span class="hljs-string">'Rating'</span></span>]).astype(int) print(set(R2[<span class="hljs-string"><span class="hljs-string">'ratingdiff'</span></span>])) R2[<span class="hljs-string"><span class="hljs-string">'ratingdiff'</span></span>].hist(label=<span class="hljs-string"><span class="hljs-string">'difference of raings'</span></span>,bins=[<span class="hljs-number"><span class="hljs-number">-3.5</span></span>,<span class="hljs-number"><span class="hljs-number">-2.5</span></span>,<span class="hljs-number"><span class="hljs-number">-1.5</span></span>,<span class="hljs-number"><span class="hljs-number">-0.5</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>,<span class="hljs-number"><span class="hljs-number">1.5</span></span>,<span class="hljs-number"><span class="hljs-number">2.5</span></span>,<span class="hljs-number"><span class="hljs-number">3.5</span></span>,<span class="hljs-number"><span class="hljs-number">4.5</span></span>],grid=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>,rwidth=<span class="hljs-number"><span class="hljs-number">0.5</span></span>)</code> </pre><br><img src="https://habrastorage.org/webt/ww/qb/7w/wwqb7wdyk_neg_semros1qthb_g.png" alt="gambar"><br><br>  Pola yang menarik ditemukan.  Orang yang nilainya berbeda dari median lebih dari 1 poin <br><br><pre> <code class="python hljs">len(R2[R2[<span class="hljs-string"><span class="hljs-string">'ratingdiff'</span></span>].abs()&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>])/len(R2)</code> </pre><br>  0,02943333333333333332 <br>  Kurang dari 3%.  Artinya, kebulatan suara yang mencolok sekali lagi dikonfirmasi dalam hal menilai keindahan. <br>  Buat tabel dengan peringkat rata-rata yang diperlukan <br><br><pre> <code class="python hljs">Answer=ratingDS.groupby(<span class="hljs-string"><span class="hljs-string">'Filename'</span></span>).mean()[<span class="hljs-string"><span class="hljs-string">'Rating'</span></span>]</code> </pre><br>  Basis data kami kecil;  Selain itu, semua foto sebagian besar berisi gambar wajah penuh, dan saya ingin hasil yang dapat diandalkan untuk setiap posisi wajah.  Untuk memecahkan masalah dengan sejumlah kecil data, teknik transfer pembelajaran sering digunakan - penggunaan model yang sudah dilatih sebelumnya untuk tugas yang serupa dan modifikasinya.  Dekat dengan tugas saya adalah tugas pengenalan wajah.  Biasanya diselesaikan dengan tiga tahap. <br><br>  1. Ada deteksi wajah pada gambar dan penskalaannya. <br><br>  2. Menggunakan jaringan saraf convolutional, gambar wajah diubah menjadi vektor fitur, dan sifat-sifat dari transformasi tersebut sedemikian rupa sehingga transformasi tidak berubah sehubungan dengan rotasi wajah dan perubahan gaya rambut.  manifestasi emosi dan gambar sementara.  Mempelajari jaringan semacam itu adalah tugas yang menarik, yang dapat ditulis untuk waktu yang lama.  Selain itu, perkembangan baru terus muncul untuk meningkatkan konversi ini untuk meningkatkan pelacakan massa dan algoritma identifikasi.  Mereka mengoptimalkan arsitektur jaringan dan metode pelatihan (mis. Triplet loss -cosface-arcface loss). <br><br>  3. Perbandingan vektor fitur dengan yang disimpan dalam database. <br><br>  Untuk tugas kami, saya menggunakan solusi siap pakai 1-2 poin.  Tugas mendeteksi wajah pada umumnya diselesaikan dengan banyak cara, apalagi, hampir semua perangkat seluler memiliki detektor wajah (di Android mereka adalah bagian dari paket layanan GooglePlay standar), yang digunakan untuk fokus pada wajah saat memotret.  Adapun terjemahan orang ke dalam bentuk vektor, ada satu titik halus yang tidak jelas.  Faktanya adalah bahwa tanda-tandanya.  diekstraksi untuk memecahkan masalah pengenalan - adalah karakteristik seseorang, tetapi mereka mungkin tidak berkorelasi dengan kecantikan sama sekali.  apalagi  karena kekhasan jaringan saraf convolutional, tanda-tanda ini terutama bersifat lokal, dan secara umum hal ini dapat menyebabkan banyak masalah (serangan piksel tunggal).  Namun demikian, saya menemukan bahwa hasilnya sangat tergantung pada dimensi vektor, dan jika 128 tanda tidak cukup untuk menentukan keindahan, 512 sudah cukup.  Berdasarkan hal ini, <a href="https://github.com/shaoanlu/face_toolbox_keras" rel="nofollow">jaringan insightFace berbasis Reset yang dilatih sebelumnya</a> telah dipilih.  Kami juga akan menggunakan keras sebagai kerangka belajar mesin. <br>  Kode terperinci untuk mengunduh model pra-terlatih dapat ditemukan di <a href="https://www.kaggle.com/alexanderkhar/face-beauty-ranking-ported-to-android" rel="nofollow">sini.</a> <br><br><pre> <code class="python hljs">model=LResNet100E_IR()</code> </pre><br>  <a href="https://github.com/ipazc/mtcnn" rel="nofollow">Detektor wajah mtcnn</a> digunakan sebagai detektor wajah untuk preprocessing <a href="https://github.com/ipazc/mtcnn" rel="nofollow">.</a> <br><br><pre> <code class="python hljs">detector = MtcnnDetector(model_folder=mtcnn_path, ctx=ctx, num_worker=<span class="hljs-number"><span class="hljs-number">1</span></span>, accurate_landmark = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, threshold=det_threshold)</code> </pre><br>  Sejajarkan, pangkas, dan vektorkan gambar dari dataset: <br><br><pre> <code class="python hljs">imgpath=<span class="hljs-string"><span class="hljs-string">'../input/faces-scut/scut-fbp5500_v2/SCUT-FBP5500_v2/Images/'</span></span> <span class="hljs-comment"><span class="hljs-comment">#    facevecs=[] for name in tqdm.tqdm(Answer.index): #   img1 = cv2.imread(imgpath+name) # ,     pre1 = np.moveaxis(get_input(detector,img1),0,-1) #  vec = model.predict(np.stack([pre1])) #   facevecs.append(vec)</span></span></code> </pre><br>  Kami akan menyiapkan data dengan memecahnya menjadi pelatihan (90% dari mereka, kami akan mempelajarinya) dan validasi (kami akan memeriksa kerja model pada mereka) vektor.  Kami menormalkan data hingga rentang 0-1. <br><br><pre> <code class="python hljs">X=np.stack(facevecs)[:,<span class="hljs-number"><span class="hljs-number">0</span></span>,:] Y=(Answer[:])/<span class="hljs-number"><span class="hljs-number">5</span></span> Indicies=np.arange(len(Answer)) X,Y,Indicies=sklearn.utils.shuffle(X,Y,Indicies) Xtrain=X[:int(len(facevecs)*<span class="hljs-number"><span class="hljs-number">0.9</span></span>)] Ytrain=Y[:int(len(facevecs)*<span class="hljs-number"><span class="hljs-number">0.9</span></span>)] Indtrain=Indicies[:int(len(facevecs)*<span class="hljs-number"><span class="hljs-number">0.9</span></span>)] Xval=X[int(len(facevecs)*<span class="hljs-number"><span class="hljs-number">0.9</span></span>):] Yval=Y[int(len(facevecs)*<span class="hljs-number"><span class="hljs-number">0.9</span></span>):] Indval=Indicies[int(len(facevecs)*<span class="hljs-number"><span class="hljs-number">0.9</span></span>):]</code> </pre><br>  Sekarang mari kita beralih ke model.  menggambarkan keindahan. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Createheadmodel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> inp=keras.layers.Input((<span class="hljs-number"><span class="hljs-number">512</span></span>,)) x=keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">32</span></span>,activation=<span class="hljs-string"><span class="hljs-string">'elu'</span></span>)(inp) x=keras.layers.Dropout(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)(x) out=keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">1</span></span>,activation=<span class="hljs-string"><span class="hljs-string">'hard_sigmoid'</span></span>,use_bias=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>,kernel_initializer=keras.initializers.Ones())(x) model=keras.models.Model(input=inp,output=out) model.layers[<span class="hljs-number"><span class="hljs-number">-1</span></span>].trainable=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span> model.compile(optimizer=keras.optimizers.Adam(lr=<span class="hljs-number"><span class="hljs-number">0.0001</span></span>), loss=<span class="hljs-string"><span class="hljs-string">'mse'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model modelhead=Createheadmodel()</code> </pre><br>  Model ini adalah jaringan saraf satu-lapis yang terhubung penuh dengan 32 neuron dan 512 node input - salah satu arsitektur paling sederhana, yang, bagaimanapun, terlatih dengan baik: <br><br><pre> <code class="python hljs">hist=modelhead.fit(Xtrain,Ytrain, epochs=<span class="hljs-number"><span class="hljs-number">4000</span></span>, batch_size=<span class="hljs-number"><span class="hljs-number">5000</span></span>, validation_data=(Xval,Yval) )</code> </pre><br>  4950/4950 [===============================] - 0s 3us / langkah - kerugian: 0,0069 - val_loss: 0,0071 <br>  Mari kita membangun kurva belajar <br><br><pre> <code class="python hljs">plt.plot(hist.history[<span class="hljs-string"><span class="hljs-string">'loss'</span></span>][<span class="hljs-number"><span class="hljs-number">100</span></span>:], label=<span class="hljs-string"><span class="hljs-string">'loss'</span></span>) plt.plot(hist.history[<span class="hljs-string"><span class="hljs-string">'val_loss'</span></span>][<span class="hljs-number"><span class="hljs-number">100</span></span>:],label=<span class="hljs-string"><span class="hljs-string">'validation_loss'</span></span>) plt.legend(bbox_to_anchor=(<span class="hljs-number"><span class="hljs-number">0.95</span></span>, <span class="hljs-number"><span class="hljs-number">0.95</span></span>), loc=<span class="hljs-string"><span class="hljs-string">'upper right'</span></span>, borderaxespad=<span class="hljs-number"><span class="hljs-number">0.</span></span>)</code> </pre><br>  Kita melihat bahwa kerugian (deviasi kuadrat rata-rata) adalah 0,0071 pada data validasi, oleh karena itu deviasi standar = 0,084 atau 0,42 poin pada skala lima poin, yang kurang dari sebaran dalam estimasi yang diberikan oleh orang (0,6 poin).  Model kami berfungsi. <br><br>  Untuk memvisualisasikan cara kerja model, Anda dapat menggunakan diagram hamburan - untuk setiap foto dari data validasi, kami membuat titik di mana salah satu koordinat terkait dengan rata-rata nilai permukaan dan yang kedua ke rata-rata peringkat yang diprediksi: <br><br><pre> <code class="python hljs">Answer2=Answer.to_frame()[:<span class="hljs-number"><span class="hljs-number">5500</span></span>] Answer2[<span class="hljs-string"><span class="hljs-string">'ans'</span></span>]=<span class="hljs-number"><span class="hljs-number">0</span></span> Answer2[<span class="hljs-string"><span class="hljs-string">'race'</span></span>]=Answer2.index Answer2[<span class="hljs-string"><span class="hljs-string">'race'</span></span>]=Answer2[<span class="hljs-string"><span class="hljs-string">'race'</span></span>].apply(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[:<span class="hljs-number"><span class="hljs-number">2</span></span>]) Answer2[<span class="hljs-string"><span class="hljs-string">'ans'</span></span>]=modelhead.predict(np.stack(facevecs)[:,<span class="hljs-number"><span class="hljs-number">0</span></span>,:])*<span class="hljs-number"><span class="hljs-number">5</span></span> xy=np.array(Answer2.iloc[Indval][[<span class="hljs-string"><span class="hljs-string">'ans'</span></span>,<span class="hljs-string"><span class="hljs-string">'Rating'</span></span>]]) plt.scatter(xy[:,<span class="hljs-number"><span class="hljs-number">1</span></span>],xy[:,<span class="hljs-number"><span class="hljs-number">0</span></span>])</code> </pre><br><img src="https://habrastorage.org/webt/w2/t9/dd/w2t9ddnfyzjpx-xp7q3_wmsubzk.png" alt="gambar"><br><br>  Sumbu Y - nilai yang diprediksi oleh model, sumbu X - nilai rata-rata estimasi orang.  Kami melihat korelasi yang tinggi (diagram memanjang di sepanjang diagonal).  Anda juga dapat memeriksa hasil kami secara visual - ambil wajah dari masing-masing kategori dengan peringkat yang diperkirakan dari 1 hingga 5 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.image <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> mpimg f, axarr = plt.subplots(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,figsize=(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, race <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate([<span class="hljs-string"><span class="hljs-string">'AF'</span></span>,<span class="hljs-string"><span class="hljs-string">'CF'</span></span>, <span class="hljs-string"><span class="hljs-string">"AM"</span></span>, <span class="hljs-string"><span class="hljs-string">'CM'</span></span>]): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rating <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>): <span class="hljs-comment"><span class="hljs-comment">#axarr[i,rating-1].axis('off') axarr[i,rating-1].tick_params(# changes apply to the x-axis which='both', # both major and minor ticks are affected bottom=False, # ticks along the bottom edge are off top=False, # ticks along the top edge are off right=False, left=False, labelbottom=False, labelleft=False ) picname=(Answer2[Answer2['race']==race]['ans']-rating).abs().argmin() axarr[i,rating-1].set_xlabel(Answer2.loc[picname]['ans']) axarr[i,rating-1].imshow(mpimg.imread(imgpath+picname))</span></span></code> </pre><br><img src="https://habrastorage.org/webt/i4/az/pe/i4azpe-biju4pozojrgpiyxkoag.png" alt="gambar"><br><br>  Kita melihat bahwa hasil dengan memilah berdasarkan kecantikan terlihat masuk akal. <br><br>  Sekarang kita akan membuat model lengkap di mana kita mengirimkan wajah ke input, pada output kita mendapatkan peringkat dari 0 ke 1 dan mengubahnya menjadi format tflite yang sesuai untuk telepon <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tf finmodel=Model(input=model.input, output=modelhead(model.output)) finmodel.save(<span class="hljs-string"><span class="hljs-string">'finmodel.h5'</span></span>) converter = tf.lite.TFLiteConverter.from_keras_model_file(<span class="hljs-string"><span class="hljs-string">'finmodel.h5'</span></span>) converter.optimizations = [tf.lite.Optimize.OPTIMIZE_FOR_SIZE] tflite_quant_model = converter.convert() open (<span class="hljs-string"><span class="hljs-string">"modelquant.tflite"</span></span> , <span class="hljs-string"><span class="hljs-string">"wb"</span></span>).write(tflite_quant_model) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> IPython.display <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FileLink FileLink(<span class="hljs-string"><span class="hljs-string">r'modelquant.tflite'</span></span>)</code> </pre><br>  Model ini menerima gambar wajah ukuran 112 * 112 * 3, dan pada outputnya memberikan angka tunggal dari 0 hingga 1, yang berarti keindahan wajah (walaupun harus diingat bahwa dalam set data peringkatnya tidak bervariasi dari 0 hingga 5, tetapi dari 1 hingga 5). <br><br><h2>  Bagian 2. JAVA </h2><br>  Mari kita coba menulis aplikasi sederhana untuk ponsel Android.  Bahasa Java baru bagi saya, dan saya tidak pernah terlibat dalam pengembangan untuk android, jadi proyek ini tidak menggunakan optimasi kerja, tidak menggunakan kontrol aliran dan hal-hal lain yang padat karya untuk pemula.  Karena kode java agak rumit, di sini saya hanya akan memberikan bagian yang paling penting untuk program untuk bekerja.  Kode aplikasi lengkap tersedia di <a href="https://github.com/Alexankharin/HowCuteAmI" rel="nofollow">sini</a> .  Aplikasi membuka foto, mendeteksi dan mengevaluasi wajah menggunakan jaringan yang disimpan sebelumnya dan menampilkan hasilnya: <br><br><img src="https://habrastorage.org/webt/7s/si/a-/7ssia-98n-lxqpitskjaudyohpc.png" alt="gambar"><br><br>  Dari sudut pandang pengembangan, fungsi-fungsi berikut ini penting di dalamnya. <br><br>  1. Fungsi memuat jaringan saraf dari model file.tflite dalam folder aset ke objek juru bahasa <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.tensorflow.lite.Interpreter; Interpreter interpreter; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { interpreter=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Interpreter(loadModelFile(MainActivity.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); Log.e(<span class="hljs-string"><span class="hljs-string">"TIME"</span></span>, <span class="hljs-string"><span class="hljs-string">"Interpreter_started "</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { e.printStackTrace(); Log.e(<span class="hljs-string"><span class="hljs-string">"TIME"</span></span>, <span class="hljs-string"><span class="hljs-string">"Interpreter NOT started "</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> MappedByteBuffer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadModelFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Activity activity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ AssetFileDescriptor fileDescriptor = activity.getAssets().openFd(<span class="hljs-string"><span class="hljs-string">"model.tflite"</span></span>); FileInputStream inputStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(fileDescriptor.getFileDescriptor()); FileChannel fileChannel = inputStream.getChannel(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> startOffset = fileDescriptor.getStartOffset(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> declaredLength = fileDescriptor.getDeclaredLength(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, declaredLength); }</code> </pre><br>  2. Mendeteksi wajah menggunakan modul FaceDetector, yang merupakan bagian dari paket pustaka standar dari google, menggunakan jaringan saraf dan menampilkan hasilnya. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.google.android.gms.vision.face.Face; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.google.android.gms.vision.face.FaceDetector; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detectFace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//Create a Paint object for drawing with Paint myRectPaint = new Paint(); myRectPaint.setStrokeWidth(5); myRectPaint.setColor(Color.GREEN); myRectPaint.setStyle(Paint.Style.STROKE); Paint fontPaint = new Paint(); fontPaint.setStrokeWidth(3); fontPaint.setTextSize(70); fontPaint.setColor(Color.BLUE); fontPaint.setStyle(Paint.Style.FILL_AND_STROKE); //Create a Canvas object for drawing on tempBitmap = Bitmap.createBitmap(myBitmap.getWidth(), myBitmap.getHeight(), Bitmap.Config.RGB_565); Canvas tempCanvas = new Canvas(tempBitmap); tempCanvas.drawBitmap(myBitmap, 0, 0, null); //Detect the Faces FaceDetector faceDetector = new FaceDetector.Builder(getApplicationContext()).build(); Frame frame = new Frame.Builder().setBitmap(myBitmap).build(); SparseArray&lt;Face&gt; faces = faceDetector.detect(frame); Face face; float[][] labelProbArray = new float[1][1]; imgData.order(ByteOrder.nativeOrder()); //Draw Rectangles on the Faces if (faces.size()&gt;0){ for (int i = 0; i &lt; faces.size(); i++) { face = faces.valueAt(i); isFaceFound=true; float x1 = Math.max(face.getPosition().x,0); float y1 = Math.max(face.getPosition().y,0); float x2 = Math.min(x1 + face.getWidth(),frame.getBitmap().getWidth()); float y2 = Math.min(y1 + face.getHeight(),frame.getBitmap().getHeight()); Bitmap tempbitmap2 = Bitmap.createBitmap(tempBitmap, (int)x1, (int)y1, (int) (x2-x1), (int) (y2-y1)); tempbitmap2 = Bitmap.createScaledBitmap(tempbitmap2, 112, 112, true); convertBitmapToByteBuffer(tempbitmap2); interpreter.run(imgData, labelProbArray); String textToShow = String.format("%.1f", (Answer[0][0]*5-1)/4 * 10); textToShow = textToShow + "/10"; int width= tempCanvas.getWidth(); //int height=tempCanvas.getHeight(); int fontsize=Math.max(width/20,imgView.getWidth()/20); fontPaint.setTextSize(fontsize); tempCanvas.drawText(textToShow, x1, y1-10, fontPaint); tempCanvas.drawRoundRect(new RectF(x1, y1, x2, y2), 2, 2, myRectPaint) } imgView.setImageDrawable(new BitmapDrawable(getResources(),tempBitmap)); } }</span></span></code> </pre><br>  Jika Anda ingin bermain dengan penilaian pada ponsel Anda, Anda dapat mengunduh <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.beautyfromphoto.androidfacedetection" rel="nofollow">aplikasi dari pasar GooglePlay</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485858/">https://habr.com/ru/post/id485858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485846/index.html">Fujitsu dan SUSE Joint Webinar: "Solusi Terbuka dan Andal untuk Era Digital"</a></li>
<li><a href="../id485850/index.html">Bagaimana Clickhouse dipilih di Galaksi Matahari</a></li>
<li><a href="../id485852/index.html">10 alasan untuk TIDAK memesan audit usability audit online</a></li>
<li><a href="../id485854/index.html">Bantu kompiler C ++ dalam mengatasi kelebihan fungsi</a></li>
<li><a href="../id485856/index.html">Bagaimana kami mencetak hexapod dan apa yang terjadi</a></li>
<li><a href="../id485862/index.html">DDoS dari pembuat kopi</a></li>
<li><a href="../id485866/index.html">Integrasi Zimbra Open-Source Edition dengan Enterprise Portal</a></li>
<li><a href="../id485868/index.html">Pencahayaan untuk ruang kelas dan ruang kelas</a></li>
<li><a href="../id485872/index.html">Mengunyah Regresi Logistik</a></li>
<li><a href="../id485874/index.html">Buku “Learning Python: pemrograman game, visualisasi data, aplikasi web. Edisi ke-3.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>