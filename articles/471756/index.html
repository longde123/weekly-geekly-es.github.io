<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚜️ 🌱 🚟 Cómo se inicia el servidor 🏧 👨🏾 🤽🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Iniciar un servidor es una secuencia larga y compleja de acciones, que depende del componente de hardware, la configuración y el software utilizado. M...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo se inicia el servidor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/selectel/blog/471756/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/za/hv/8v/zahv8vvh9_djipoukte16mkat-m.png"></div><br>  Iniciar un servidor es una secuencia larga y compleja de acciones, que depende del componente de hardware, la configuración y el software utilizado.  Muchos, incluso administradores de sistemas experimentados y calificados, tienen una mala idea de lo que sucede exactamente cuando se inicia el servidor, por lo que decidimos analizar este proceso en detalle. <br><a name="habracut"></a><br>  Para no desmontar todos los casos posibles, consideraremos la carga en las siguientes condiciones: <br><br><ul><li>  Procesador Intel de 64 bits; </li><li>  Modo de arranque heredado </li><li>  Particionamiento de disco MBR; </li><li>  cargador de arranque GRUB2. </li></ul><br><h2>  Despierta y canta </h2><br>  La activación del servidor se inicia de varias maneras, entre las cuales presionar el botón de Encendido es la más común, pero no la única.  Otra opción es mediante un comando a través de la red ( <b>Wake-on-LAN</b> ) o mediante comandos desde dispositivos externos ( <b>Wake-on-PCIe</b> , <b>Wake-on-Keyboard</b> , <b>Wake-on-Mouse</b> ).  Los comandos se ejecutan solo si los parámetros correspondientes están habilitados en la <b>Utilidad de configuración</b> del <b>BIOS</b> , de lo que hablaremos más adelante. <br><br>  Un dispositivo separado es el módulo BMC, que proporciona capacidades avanzadas de administración del servidor.  Lea más sobre esta tecnología <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en nuestro blog</a> . <br><br>  Los métodos anteriores son inteligentes y requieren el envío de un comando especialmente formado en los buses de datos.  Una forma más simple: enciéndalo cuando se suministre energía a la fuente de alimentación.  En la configuración del BIOS, este parámetro se llama <b>Pérdida de energía de CA</b> y toma uno de tres estados: <br><br><ul><li>  <b>Apagado</b> : el servidor permanecerá apagado. </li><li>  <b>Encendido</b> : el servidor se encenderá. </li><li>  <b>Último estado</b> : el servidor se encenderá solo si se encendió en el momento de la pérdida de energía. </li></ul><br>  El uso de estos métodos igualmente lleva a enviar al procesador una señal de <b>reinicio</b> y al inicio del procedimiento de inicio. <br><br><h2>  Descargar el primer programa </h2><br>  El primer paso para iniciar el servidor es encender la fuente de alimentación y configurar la señal de <b>reinicio</b> para el procesador.  Si hay una señal de <b>reinicio</b> , el generador de frecuencia del procesador no funciona y los registros del procesador se reinician a los valores establecidos por el fabricante del procesador. <br><br>  Cuando se inicia en la fuente de alimentación, se producen transitorios, por lo que el voltaje de salida puede estar fuera de los límites permitidos, lo que afectará negativamente al procesador en funcionamiento.  Por lo tanto, la señal de <b>reinicio</b> no se elimina hasta que la potencia entrante esté completamente estabilizada. <br><br>  Después de estabilizar el voltaje, la fuente de alimentación establece la señal <b>Power Good</b> .  Esta señal significa que la placa base puede iniciar todos los componentes del servidor.  A continuación, el chipset asigna al espacio de direcciones todos los dispositivos conectados, incluida la ROM (memoria de solo lectura) con el código del <b>Sistema básico de entrada / salida</b> (BIOS).  A continuación, se elimina la señal de <b>reinicio</b> y se inicia el generador de frecuencia del procesador. <br><br>  BIOS: un sistema que proporciona una API para trabajar con equipos y dispositivos conectados.  Uno de los objetivos importantes del BIOS es inicializar y probar el hardware al inicio. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/az/vh/fh/azvhfhkglubk080zk7rxwuahs1y.jpeg" title="BIOS ROM en la placa base SuperMicro X8DTL-3"></div><br>  Independientemente de la cantidad de procesadores del sistema, cuando se inicia el servidor, solo se activa un núcleo de un procesador y los núcleos restantes permanecen en modo de suspensión.  El núcleo despertado se denota mediante el <b>procesador Bootstrap</b> (BSP, en lo sucesivo denominado el procesador).  Una vez que desaparece la señal de <b>reinicio</b> , los registros del procesador se llenan de tal manera que el procesador funciona en un modo especial de 32 bits llamado <b>Modo de procesador inicial</b> . <br><br>  <b>Modo de procesador inicial</b> : un modo operativo en el que un procesador de 64 bits solo se obtiene después de un reinicio.  En este modo, el procesador es capaz de ejecutar instrucciones de 32 bits y el espacio de direcciones es de 4 GiB. <br><br>  Una vez que desaparece la señal de <b>reinicio</b> , el contador de comandos del procesador apunta a la dirección <b>0xFFFFFFF0</b> , que se denomina <b>Vector de reinicio</b> .  En esta dirección se encuentra el primer comando que el procesador decodifica y ejecuta. <blockquote>  Colocar la primera instrucción al final del espacio de direcciones tiene justificación histórica.  Al desarrollar el procesador Intel 8086, al comienzo del espacio de direcciones había un vector de interrupción, seguido de RAM, cuya cantidad podría ser cualquiera.  Para evitar intersecciones con RAM, la dirección del primer comando se tomó al final del espacio de direcciones. <br><br>  Más tarde, con la llegada de Intel 80286, el vector de interrupción podría moverse a cualquier lugar.  Sin embargo, incluso los procesadores modernos se ejecutan en modo de compatibilidad con 8086 y el vector de interrupción en 0x0. </blockquote>  Al acceder a la dirección <b>0xFFFFFFF0, el</b> procesador recibe el primer comando de la ROM.  En el modo Legacy, este comando es un <b>salto de longitud</b> o <b>Far Jump</b> en un segmento de memoria con un código de BIOS.  Después de completar el primer salto largo, el procesador ingresa al <b>modo real de</b> 16 bits y procede a ejecutar el código del BIOS. <br><br>  <b>Modo real: modo de</b> compatibilidad con procesadores obsoletos de 16 bits.  En este modo, solo los comandos de 16 bits están disponibles y el espacio de direcciones, que se denomina "memoria inferior", contiene solo 1 MiB. <br><br>  Como se señaló anteriormente, el código ejecutable del BIOS se almacena en un dispositivo externo, cuyo trabajo no es muy rápido, por lo que lo primero que hace el BIOS es inicializar la RAM y copiar su propio código desde la ROM.  El BIOS conserva la compatibilidad con procesadores obsoletos; por lo tanto, realiza todas las acciones en modo de 16 bits. <br><br><h2>  Prueba automática de encendido </h2><br>  La prueba automática de encendido (POST) es un paso clave en el BIOS.  POST se abrevia y completa.  La POST completa verifica todos los controladores disponibles y prueba toda la RAM disponible, lo que puede llevar mucho tiempo. <br><br>  La POST abreviada acelera el proceso de arranque e incluye el conjunto mínimo de acciones necesarias: <br><br><ul><li>  verificar la integridad de los programas de BIOS en ROM utilizando el mecanismo de verificación de suma de verificación; </li><li>  detección e inicialización de los principales controladores, buses del sistema y dispositivos conectados; </li><li>  determinar el tamaño de la RAM y probar el primer segmento (64 kilobytes); </li><li>  transferencia de control al gestor de arranque. </li></ul><br>  Al pasar la POST, el servidor utiliza varias formas de reflejar información sobre el paso de las pruebas.  Las formas más comunes: <br><br><ul><li>  mostrar el identificador de prueba, el <b>código POST</b> en la pantalla o usar indicadores de siete segmentos en la placa base; </li><li>  indicación sonora; </li><li>  alarma de luz con una combinación de LED. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uj/ee/_1/ujee_1g778z_8j-oayfruxy64ru.png" title="BIOS muestra el código POST en la esquina inferior derecha"></div><br>  La forma más informativa de obtener información sobre posibles fallos es mostrar el código POST actual.  Al completar con éxito las pruebas, los códigos se reemplazan rápidamente entre sí, pero en caso de mal funcionamiento, la POST se detiene y puede ver el identificador de la prueba fallida.  Los fabricantes de placas base siempre adjuntan una decodificación, lo que significa un código particular. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zm/xi/xx/zmxixxhixw3a651-iaqof1j5u9i.jpeg" title="El indicador de siete segmentos del servidor ASUS ESC8000 G3 se detuvo en 0xB0"></div><br>  En las placas base modernas hay una indicación LED que le permite identificar un componente defectuoso.  Si el servidor se inicia correctamente, puede escuchar un pitido que indica que la POST fue exitosa.  Por la duración y el número de señales de sonido, también es posible determinar un componente fallido. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/_a/f3/gp/_af3gpangdbwzgkka2d-tcwegiy.png" title="Tarjeta profesional PCI POST (source.wikipedia.org)"></a> </div><br>  En algunos casos, cuando se requiere la máxima precisión para el diagnóstico, puede recurrir al uso de un dispositivo externo llamado tarjeta POST.  Las placas base envían información sobre las pruebas POST en los buses de datos, y una tarjeta POST procesa esta información y la muestra utilizando los indicadores disponibles. <br><br><h2>  Utilidad de configuración del BIOS </h2><br>  El BIOS tiene un menú de configuración especial llamado <b>Utilidad de configuración del BIOS</b> .  Puede ingresarlo presionando una tecla especial mientras pasa POST.  La mayoría de las veces, las claves para ingresar al BIOS son <b>Del</b> y <b>F2</b> , sin embargo, cuando se carga, siempre se indica qué clave abrirá la configuración del BIOS. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hh/lj/jt/hhljjttanyeib8whct5ikuqmlqw.png" title="Menú de configuración UEFI BIOS - Utilidad de configuración Aptio"></div><br>  <b>La utilidad de configuración del BIOS</b> proporciona una interfaz para la configuración, que solo requiere un teclado para comunicarse.  La utilidad de configuración del BIOS proporciona información sobre el hardware instalado y le permite cambiar los parámetros de funcionamiento de la placa base y el equipo conectado. <br><br>  Los posibles nombres y opciones de este o aquel parámetro dependen de muchos factores, entre los cuales: <br><br><ul><li>  Versión del BIOS </li><li>  modelo de placa base; </li><li>  modelo del equipo instalado en la placa base. </li></ul><br>  Entre los parámetros estamos interesados ​​en <b>Boot Priority</b> .  La prioridad de arranque establece el orden en que el BIOS sondea los dispositivos para encontrar el área de arranque en ellos.  Tan pronto como el BIOS encuentra el área de arranque, el control se transfiere al gestor de arranque y comienza el siguiente paso. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/wb/eo/qqwbeoxvdxqehipvcp7cmzsmopa.png" title="Descargar Priority en Aptio Setup Utility"></div><br><h2>  Cargador de SO </h2><br>  Después de pasar la POST, el BIOS busca el área de arranque y sondea los dispositivos en el orden especificado.  En el modo <b>Legacy</b> , el área de arranque en el disco se llama <b>Master Boot Record</b> (MBR).  MBR es una estructura especial ubicada en los primeros 512 bytes del disco.  Estos 512 bytes contienen los siguientes datos: <br><br><ul><li>  <b>código de la primera etapa del gestor de arranque</b> : de 0 a 445 bytes; </li><li>  <b>tabla de particiones</b> : de 446 a 509 bytes; </li><li>  <b>El número mágico es 0xAA55</b> , de 510 a 511 bytes. </li></ul><br>  Si no hay un número mágico <b>0xAA55</b> , se considera que no se encontró el registro MBR en este disco y el BIOS procede a sondear el siguiente disco. <br><br>  Cuando el BIOS encuentra el registro MBR, lo copia del disco a la RAM en la dirección <b>0x7C00</b> y <b>salta</b> a esta dirección.  Después del salto, comienza la primera etapa ( <b>Etapa 1</b> ) del gestor de arranque.  Debido al tamaño limitado, el propósito de la primera etapa es cargar el código de la segunda etapa ( <b>Etapa 2</b> ) en la memoria y transferirle el control. <br><br>  <b>El</b> código de la <b>etapa 2</b> se almacena inmediatamente después de la estructura MBR y hasta el comienzo de la primera partición del disco.  Históricamente, esta brecha contiene 31 KB de memoria, y en los sistemas modernos alcanza 1 MB.  Sin embargo, para mantener la compatibilidad, el tamaño de la segunda etapa no supera los 31 KB. <br><br>  La segunda etapa prepara el entorno para lanzar la tercera etapa: <br><br><ul><li>  Carga los controladores necesarios del sistema de archivos </li><li>  encuentra el código de la tercera etapa en el sistema de archivos; </li><li>  carga el código en la RAM y le transfiere el control. </li></ul><br>  <b>Las</b> tareas de la <b>etapa 3 se</b> reducen a una configuración mínima del entorno y el gestor de arranque: <br><br><ul><li>  transfiera el procesador al <b>modo protegido</b> ; </li><li>  Descargar extensiones GRUB2 instaladas </li><li>  encuentre la <b>Etapa 4</b> en el sistema de archivos y dele el control. </li></ul><br>  <b>Modo protegido: modo de</b> compatibilidad con procesadores x86.  En este modo, el procesador es capaz de ejecutar instrucciones de 32 bits y el espacio de direcciones se expande a 4 GiB.  Han aparecido innovaciones significativas en el modo protegido, por ejemplo: <br><br><ul><li>  memoria de paginación; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anillos de protección</a> ; </li><li>  memoria virtual </li></ul><br>  La cuarta etapa ( <b>Etapa 4</b> ) ya se está ejecutando en modo de 32 bits, si es necesario, se carga desde el disco de expansión de la GUI, "analiza" el archivo <b>grub.cfg</b> y muestra el menú de selección del sistema operativo familiar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jb/z6/qk/jbz6qkpcfksjvjlleuw5s2wfo68.png" title="Menú principal de GRUB2"></div><br><h2>  Núcleo del sistema operativo </h2><br>  GRUB2 sigue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la especificación de arranque múltiple</a> para cargar el ejecutable del núcleo.  El gestor de arranque comprueba el número mágico <b>0x1BADB002</b> al comienzo del núcleo y comprueba la suma de comprobación para asegurarse de que el núcleo sea compatible con la especificación.  Después de una verificación exitosa, el núcleo puede cargarse en la RAM y transferirse a él. <br><br>  Según la misma especificación, el gestor de arranque proporciona al núcleo información del sistema, como por ejemplo: <br><br><ul><li>  modo de procesador actual; </li><li>  cantidad de RAM detectada; </li><li>  tipo de salida de video (texto o píxel); </li><li>  resolución de pantalla </li></ul><br>  A pesar de que el gestor de arranque utilizó controladores del sistema de archivos y, posiblemente, extensiones para la interfaz gráfica, el núcleo de arranque no recibirá todas estas cosas maravillosas.  En primer lugar, después de obtener el control, el núcleo "revela" todo el potencial del servidor y pone el procesador en <b>modo largo</b> . <br><br>  <b>Modo largo</b> : el modo principal de los procesadores de 64 bits.  En este modo, el procesador puede ejecutar instrucciones de 64 bits y utilizar registros de propósito general de 64 bits.  El espacio de direcciones tiene 16 BEI.  El modo largo abolió la organización de memoria segmentada inherente a la arquitectura de 32 bits. <br><br>  A pesar del enorme espacio de direcciones para direccionar la memoria física, solo se utilizan 48 bits de los 64 posibles, lo que reduce la cantidad máxima de RAM a 256 TiB, que es 65.536 veces menos que el espacio de direcciones.  En el futuro previsible, se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">planea</a> expandir el direccionamiento físico a 57 bits. <br><br>  Después de cambiar al Modo largo, el núcleo realiza el conjunto mínimo de acciones necesarias para la operación: <br><br><ul><li>  Configura la memoria de paginación </li><li>  carga los controladores e inicializa el equipo utilizado; </li><li>  Configura la memoria y los planificadores de procesos. </li><li>  encuentra e inicia init. </li></ul><br>  Es importante que antes de configurar el planificador de procesos, el servidor trabajara en un solo núcleo, que se llamaba BSP.  La configuración del planificador activa el resto del kernel llamado <b>Application Processor</b> (AP).  Los núcleos no tienen una conexión directa entre sí, y su comunicación se realiza a través de controladores de interrupción locales llamados <b>Controlador de interrupción programable avanzado local</b> (LAPIC). <br><br>  El núcleo del sistema operativo se inicia en el BSP, que durante la inicialización recibió información sobre los procesadores disponibles en el sistema utilizando las tablas ACPI.  BSP, utilizando su propio LAPIC, envía una secuencia de interrupciones " <b>Init</b> - <b>StartUp</b> - <b>StartUp</b> " para activar todos los AP.  Después de comenzar, los procesadores de aplicaciones también deben inicializarse y transferirse al Modo largo, pero ahora este proceso es más rápido, ya que este trabajo ya lo ha realizado el procesador principal. <br><br>  Después de que todos los AP se inicializan, el planificador de procesos inicia un proceso de servicio llamado " <b>inacción</b> " o <b>inactivo</b> .  Como su nombre lo indica, este proceso no hace nada y ocupa el procesador cuando no hay otros procesos. <br><br>  Cuando todo está configurado y listo para funcionar, el núcleo del sistema operativo inicia el primer proceso en el espacio del usuario: <b>Init</b> .  Eso, a su vez, inicia el resto de los procesos en el espacio del usuario.  Después de que comienza el proceso de inicio, el kernel pasa al modo de espera y está inactivo hasta que las tareas aparezcan en el espacio del kernel. <br><br>  Después de iniciar todos los procesos, el servidor se vuelve disponible a través de la red y en la consola puede ver el mensaje de Inicio de sesión en la pantalla. <br><br><h2>  Conclusión </h2><br>  A primera vista, un inicio de servidor simple y rápido y cargar el sistema operativo es, de hecho, un proceso complejo y confuso con muchos matices.  El paso de este proceso es una pequeña evolución que desarrolla la potencia de procesamiento del procesador desde los procesadores antiguos de 16 bits hasta los modernos "monstruos" de 64 bits. <br><br>  ¿Y qué piensas, cuando aparezcan los procesadores de 128 bits, habrá un modo de compatibilidad con los de 16 bits? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471756/">https://habr.com/ru/post/471756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471742/index.html">Sberbank AI Journey. Cómo enseñamos a una red neuronal a tomar un examen</a></li>
<li><a href="../471744/index.html">Tarantool Data Grid: arquitectura y características</a></li>
<li><a href="../471746/index.html">Guía completa para configurar encabezados HTTP para seguridad</a></li>
<li><a href="../471748/index.html">Optimización de farmacia: lo que hicimos con las matemáticas</a></li>
<li><a href="../471750/index.html">Gestión de acceso privilegiado como tarea prioritaria en seguridad de la información (por ejemplo, Fudo PAM)</a></li>
<li><a href="../471758/index.html">¿Cómo traducir texto a un idioma diferente?</a></li>
<li><a href="../471760/index.html">Edward Snowden: El campo de batalla - Cifrado</a></li>
<li><a href="../471766/index.html">Manejo de errores de Kotlin / Java: ¿cómo hacerlo bien?</a></li>
<li><a href="../471770/index.html">Conozca las herramientas de Big Data: compatibilidad con portátiles Spark y Zeppelin en IntelliJ IDEA</a></li>
<li><a href="../471772/index.html">Herramientas para iniciar y desarrollar aplicaciones Java, compilación, ejecución en la JVM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>