<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍞 👩‍👧‍👧 📪 Docker-Compose So warten Sie, bis der Container fertig ist 👨🏽‍🔬 🐴 🌋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 
 Es gibt viele Artikel über das Ausführen von Containern und das Schreiben von docker-compose.yml . Aber für mich war lange Zeit nicht kla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker-Compose So warten Sie, bis der Container fertig ist</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454552/"><h1>  Einführung </h1><br>  Es gibt viele Artikel über das Ausführen von Containern und das Schreiben von <b>docker-compose.yml</b> .  Aber für mich war lange Zeit nicht klar, wie ich richtig vorgehen sollte, wenn ein Container erst gestartet werden sollte, wenn ein anderer Container bereit ist, seine Anforderungen zu verarbeiten oder eine gewisse Arbeit auszuführen. <br><a name="habracut"></a><br>  Diese Frage wurde relevant, nachdem wir begonnen hatten, <b>Docker-Compose</b> aktiv zu verwenden, anstatt einzelne Docker zu starten. <br><br><h1>  Wofür ist es? </h1><br>  Lassen Sie die Anwendung in Container B tatsächlich von der Verfügbarkeit des Dienstes in Container A abhängen. Beim Start erhält die Anwendung in Container B diesen Dienst nicht.  Was soll es tun? <br><br>  Es gibt zwei Möglichkeiten: <br><br><ul><li>  Das erste ist zu sterben (vorzugsweise mit einem Fehlercode) </li><li>  Die zweite besteht darin, zu warten und dann trotzdem zu sterben, wenn die Anwendung in Container B nicht auf das zugewiesene Zeitlimit reagiert hat </li></ul><br>  Nach dem Tod von Container B wird <b>Docker-Compose</b> (natürlich abhängig von der Konfiguration) neu gestartet und die Anwendung in Container B versucht erneut, den Dienst in Container A zu erreichen. <br><br>  Dies wird so lange fortgesetzt, bis der Dienst in Container A bereit ist, auf Anforderungen zu antworten, oder bis wir feststellen, dass der Container ständig überlastet wird. <br>  Tatsächlich ist dies der normale Weg für die Multi-Container-Architektur. <br><br>  Insbesondere waren wir jedoch mit einer Situation konfrontiert, in der Container A gestartet wird und Daten für Container B vorbereitet. Die Anwendung in Container B weiß nicht, wie sie überprüfen kann, ob die Daten bereit sind oder nicht, und beginnt sofort mit der Arbeit mit ihnen.  Daher müssen wir das Signal zur Datenbereitschaft selbst empfangen und verarbeiten. <br><br>  Ich denke, dass Sie noch einige Anwendungsfälle nennen können.  Vor allem aber müssen Sie genau verstehen, warum Sie dies tun.  Andernfalls ist es besser, die Standard- <b>Docker-Compose-</b> Tools zu verwenden. <br><br><h1>  Ein bisschen Ideologie </h1><br>  Wenn Sie die Dokumentation sorgfältig lesen, ist dort alles geschrieben.  Nämlich jeder <br>  Das Gerät ist unabhängig und muss darauf achten, dass alle Dienste mit <br>  mit denen er arbeiten wird, stehen ihm zur Verfügung. <br><br>  Daher geht es nicht darum, den Container zu starten oder nicht zu starten, sondern um <br>  Überprüfen Sie im Container die Bereitschaft aller erforderlichen Dienste und nur <br>  Übertragen Sie dann die Steuerung auf die Containeranwendung. <br><br><h1>  Wie wird es umgesetzt? </h1><br>  Um dieses Problem zu lösen <b>,</b> hat mir die <b>Docker-Compose-</b> Beschreibung sehr geholfen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> Teil davon <br>  und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel</a> über die ordnungsgemäße Verwendung von <b>Entrypoint</b> und <b>Cmd</b> . <br><br>  Also, was wir brauchen: <br><br><ul><li>  Es gibt einen Anhang A, den wir in Behälter A eingewickelt haben </li><li>  es startet und reagiert auf Port 8000 OK </li><li>  Außerdem gibt es Anwendung B, die wir von Container B aus starten. Sie sollte jedoch nicht früher funktionieren, als Anwendung A auf Anforderungen an Port 8000 reagiert </li></ul><br>  Die offizielle Dokumentation bietet zwei Möglichkeiten, um dieses Problem zu lösen. <br><br>  Der erste besteht darin, einen eigenen <b>Einstiegspunkt</b> in den Container zu schreiben, der alle Überprüfungen durchführt, und dann die Arbeitsanwendung zu starten. <br><br>  Die zweite besteht darin, die bereits geschriebene Batch-Datei <b>wait-for-it.sh zu verwenden</b> . <br>  Wir haben beide Möglichkeiten ausprobiert. <br><br><h2>  Schreiben Sie Ihren eigenen Einstiegspunkt </h2><br>  Was ist der <b>Einstiegspunkt</b> ? <br><br>  Dies ist nur die ausführbare Datei, die Sie beim Erstellen des Containers in der <b>Docker-</b> <b>Datei im</b> Feld <b>ENTRYPOINT</b> <b>angeben</b> .  Diese Datei führt, wie bereits erwähnt, Überprüfungen durch und startet dann die Hauptanwendung des Containers. <br><br>  Also was wir bekommen: <br><br>  Erstellen Sie einen <i>Entrypoint-</i> Ordner. <br><br>  Es hat zwei Unterordner - <i>container_A</i> und <i>container_B</i> .  Wir werden unsere Container in ihnen erstellen. <br><br>  Nehmen wir für Container A einen einfachen http-Server auf Python.  Nach dem Start beginnt er zu antworten, um Anfragen an Port 8000 zu erhalten. <br><br>  Um unser Experiment deutlicher zu machen, haben wir eine Verzögerung von 15 Sekunden festgelegt, bevor wir den Server starten. <br><br>  Es stellt sich die folgende <b>Docker-Datei für Container A heraus</b> : <br><br><pre><code class="plaintext hljs">FROM python:3 EXPOSE 8000 CMD sleep 15 &amp;&amp; python3 -m http.server --cgi</code> </pre> <br>  Erstellen Sie <b>für Container B</b> die folgende <b>Docker-Datei für Container B</b> : <br><br><pre> <code class="plaintext hljs">FROM ubuntu:18.04 RUN apt-get update RUN apt-get install -y curl COPY ./entrypoint.sh /usr/bin/entrypoint.sh ENTRYPOINT [ "entrypoint.sh" ] CMD ["echo", "!!!!!!!! Container_A is available now !!!!!!!!"]</code> </pre><br>  Und legen Sie unsere ausführbare Datei entrypoint.sh im selben Ordner ab.  Wir werden es so haben <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash set -e host="conteiner_a" port="8000" cmd="$@" &gt;&amp;2 echo "!!!!!!!! Check conteiner_a for available !!!!!!!!" until curl http://"$host":"$port"; do &gt;&amp;2 echo "Conteiner_A is unavailable - sleeping" sleep 1 done &gt;&amp;2 echo "Conteiner_A is up - executing command" exec $cmd</span></span></code> </pre><br>  Was ist los in Container B: <br><br><ul><li>  Wenn es startet, startet es <b>ENTRYPOINT</b> , d.h.  startet <b>entrypoint.sh</b> </li><li>  <b>entrypoint.sh</b> beginnt mit <b>curl</b> mit dem Abfragen von Port 8000 für Container A. Dies geschieht so lange, bis eine Antwort von 200 empfangen wird (d. <b>h</b> . <b>curl</b> endet in diesem Fall mit einem Ergebnis von Null und die Schleife endet). </li><li>  Wenn 200 empfangen wird, endet die Schleife und die Steuerung wird an den in der Variablen <b>$ cmd</b> angegebenen Befehl übergeben.  Und es zeigt an, was wir in der Docker-Datei im <b>CMD-</b> Feld angegeben haben, d. H.  <i>echo "!!! Container_A ist jetzt verfügbar !!!!!!!!"</i>  Warum dies so ist, wird im obigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel beschrieben</a> </li><li>  Wir drucken - <i>!!!</i>  <i>Container_A ist ab sofort verfügbar !!!</i>  <i>und schließen.</i> </li></ul><br>  Wir werden alles mit <b>Docker-Compose beginnen</b> . <br><br>  <b>docker-compose.yml</b> hier haben wir folgendes: <br><br><pre> <code class="plaintext hljs">version: '3' networks: waiting_for_conteiner: services: conteiner_a: build: ./conteiner_A container_name: conteiner_a image: conteiner_a restart: unless-stopped networks: - waiting_for_conteiner ports: - 8000:8000 conteiner_b: build: ./conteiner_B container_name: conteiner_b image: waiting_for_conteiner.entrypoint.conteiner_b restart: "no" networks: - waiting_for_conteiner</code> </pre><br>  Hier in <b>conteiner_a müssen</b> keine <i>Ports angegeben werden: 8000: 8000</i> .  Dies wurde durchgeführt, um den Betrieb des darin ausgeführten http-Servers von außen überprüfen zu können. <br><br>  Außerdem wird Container B nach dem Herunterfahren nicht neu gestartet. <br><br>  Wir starten: <br><br><pre> <code class="plaintext hljs">docker-compose up —-build</code> </pre><br>  Wir sehen, dass für 15 Sekunden eine Meldung über die Nichtverfügbarkeit von Container A angezeigt wird, und dann <br><br><pre> <code class="plaintext hljs">conteiner_b | Conteiner_A is unavailable - sleeping conteiner_b | % Total % Received % Xferd Average Speed Time Time Time Current conteiner_b | Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt; conteiner_b | &lt;html&gt; conteiner_b | &lt;head&gt; conteiner_b | &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; conteiner_b | &lt;title&gt;Directory listing for /&lt;/title&gt; conteiner_b | &lt;/head&gt; conteiner_b | &lt;body&gt; conteiner_b | &lt;h1&gt;Directory listing for /&lt;/h1&gt; conteiner_b | &lt;hr&gt; conteiner_b | &lt;ul&gt; conteiner_b | &lt;li&gt;&lt;a href=".dockerenv"&gt;.dockerenv&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="bin/"&gt;bin/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="boot/"&gt;boot/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="dev/"&gt;dev/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="etc/"&gt;etc/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="home/"&gt;home/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="lib/"&gt;lib/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="lib64/"&gt;lib64/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="media/"&gt;media/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="mnt/"&gt;mnt/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="opt/"&gt;opt/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="proc/"&gt;proc/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="root/"&gt;root/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="run/"&gt;run/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="sbin/"&gt;sbin/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="srv/"&gt;srv/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="sys/"&gt;sys/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="tmp/"&gt;tmp/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="usr/"&gt;usr/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="var/"&gt;var/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;/ul&gt; conteiner_b | &lt;hr&gt; conteiner_b | &lt;/body&gt; conteiner_b | &lt;/html&gt; 100 987 100 987 0 0 98700 0 --:--:-- --:--:-- --:--:-- 107k conteiner_b | Conteiner_A is up - executing command conteiner_b | !!!!!!!! Container_A is available now !!!!!!!!</code> </pre><br>  Wir bekommen eine Antwort auf Ihre Anfrage, drucken <nobr><i>!!!</i></nobr>  <nobr><i>Container_A ist ab sofort verfügbar !!!!!!!!</i></nobr>  und schließen. <br><br><h2>  Verwenden von wait-for-it.sh </h2><br>  Es ist sofort zu sagen, dass dieser Weg bei uns nicht funktioniert hat, wie in der Dokumentation beschrieben. <br>  Es ist nämlich bekannt, dass, wenn <b>ENTRYPOINT</b> und <b>CMD</b> in die <b>Docker-Datei</b> geschrieben <b>werden</b> , beim <b>Starten</b> des Containers der Befehl von <b>ENTRYPOINT</b> ausgeführt wird und der Inhalt von <b>CMD</b> als Parameter an ihn übergeben wird. <br><br>  Es ist auch bekannt, dass <b>ENTRYPOINT</b> und <b>CMD,</b> die in der <b>Docker-Datei</b> angegeben sind, in <b>docker</b> <b>-compose.yml</b> überschrieben werden <b>können</b> <br><br>  Das <b>Startformat wait-for-it.sh lautet</b> wie folgt: <br><br><pre> <code class="plaintext hljs">wait-for-it.sh __ -- ___</code> </pre><br>  Dann können wir, wie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel angegeben</a> , einen neuen <b>ENTRYPOINT</b> in <b>docker-compose.yml definieren</b> , und die <b>CMD wird</b> aus der <b>Docker-Datei</b> <b>ersetzt</b> . <br><br>  Also bekommen wir: <br><br>  <b>Docker-Datei für Container A</b> bleibt unverändert: <br><br><pre> <code class="plaintext hljs">FROM python:3 EXPOSE 8000 CMD sleep 15 &amp;&amp; python3 -m http.server --cgi</code> </pre><br>  <b>Docker-Datei für Container B.</b> <br><br><pre> <code class="plaintext hljs">FROM ubuntu:18.04 COPY ./wait-for-it.sh /usr/bin/wait-for-it.sh CMD ["echo", "!!!!!!!! Container_A is available now !!!!!!!!"]</code> </pre><br>  <b>Docker-compose.yml</b> sieht <b>folgendermaßen</b> aus: <br><br><pre> <code class="plaintext hljs">version: '3' networks: waiting_for_conteiner: services: conteiner_a: build: ./conteiner_A container_name: conteiner_a image: conteiner_a restart: unless-stopped networks: - waiting_for_conteiner ports: - 8000:8000 conteiner_b: build: ./conteiner_B container_name: conteiner_b image: waiting_for_conteiner.wait_for_it.conteiner_b restart: "no" networks: - waiting_for_conteiner entrypoint: ["wait-for-it.sh", "-s" , "-t", "20", "conteiner_a:8000", "--"]</code> </pre><br>  Wir führen den Befehl <b>wait-for-it aus</b> , weisen ihn an, 20 Sekunden zu warten, bis Container A zum Leben erweckt wird, und geben einen weiteren Parameter <b>"-" an</b> , der die <b>Wait-for-it-</b> Parameter von dem Programm trennen soll, das nach Abschluss des Vorgangs gestartet wird. <br><br>  Wir versuchen es! <br>  Und leider bekommen wir nichts. <br><br>  Wenn wir überprüfen, mit welchen Argumenten wir wait-for-it ausführen, werden wir <b>feststellen,</b> dass nur das übergeben wird, was wir im <b>Einstiegspunkt</b> angegeben haben. Die <b>CMD</b> aus dem Container wird nicht angehängt. <br><br><h3>  Arbeitsoption </h3><br>  Dann gibt es nur eine Option.  Was wir in der <b>CMD</b> in der <b>Docker-Datei</b> angegeben haben, müssen wir auf den <b>Befehl</b> in <b>docker-compose.yml übertragen</b> . <br><br>  <b>Lassen Sie dann die</b> <b>Docker-Datei</b> <b>von</b> Container B unverändert, und <b>docker-compose.yml</b> sieht folgendermaßen aus: <br><br><pre> <code class="plaintext hljs">version: '3' networks: waiting_for_conteiner: services: conteiner_a: build: ./conteiner_A container_name: conteiner_a image: conteiner_a restart: unless-stopped networks: - waiting_for_conteiner ports: - 8000:8000 conteiner_b: build: ./conteiner_B container_name: conteiner_b image: waiting_for_conteiner.wait_for_it.conteiner_b restart: "no" networks: - waiting_for_conteiner entrypoint: ["wait-for-it.sh", "-s" ,"-t", "20", "conteiner_a:8000", "--"] command: ["echo", "!!!!!!!! Container_A is available now !!!!!!!!"]</code> </pre><br>  Und in dieser Version funktioniert es. <br><br>  Abschließend muss gesagt werden, dass unserer Meinung nach der richtige Weg der erste ist.  Es ist das vielseitigste und ermöglicht es Ihnen, eine Bereitschaftsprüfung auf jede mögliche Weise durchzuführen.  <b>Wait-for-it ist</b> nur ein nützliches Dienstprogramm, das Sie entweder separat oder durch Einbetten in Ihre <b>entrypoint.sh verwenden können</b> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454552/">https://habr.com/ru/post/de454552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454536/index.html">Verstärker zum klassischen Herzfrequenzsensor</a></li>
<li><a href="../de454538/index.html">Frontend Weekly Digest (27. Mai - 2. Juni 2019)</a></li>
<li><a href="../de454540/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 367 (27. Mai - 2. Juni 2019)</a></li>
<li><a href="../de454542/index.html">Kabelfernsehnetze für die Kleinsten. Teil 7: Optische Empfänger</a></li>
<li><a href="../de454546/index.html">Wie viele Programmierer brauchen Sie, um eine Tasse Kaffee zu trinken?</a></li>
<li><a href="../de454556/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 462 (21.05.2019 - 27.05.2019)</a></li>
<li><a href="../de454558/index.html">PHP Digest Nr. 157 (20. Mai - 3. Juni 2019)</a></li>
<li><a href="../de454562/index.html">Warum das Konzept des Bytecodes nicht mehr so ​​relevant ist wie zuvor</a></li>
<li><a href="../de454568/index.html">Mozilla bezeichnete Googles digital signierte Webpaket-Distribution als "schlecht".</a></li>
<li><a href="../de454570/index.html">Neuerstellung eines alten DOS-Spiels in C ++ 17</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>