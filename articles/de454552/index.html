<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçû üë©‚Äçüëß‚Äçüëß üì™ Docker-Compose So warten Sie, bis der Container fertig ist üë®üèΩ‚Äçüî¨ üê¥ üåã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Es gibt viele Artikel √ºber das Ausf√ºhren von Containern und das Schreiben von docker-compose.yml . Aber f√ºr mich war lange Zeit nicht kla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker-Compose So warten Sie, bis der Container fertig ist</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454552/"><h1>  Einf√ºhrung </h1><br>  Es gibt viele Artikel √ºber das Ausf√ºhren von Containern und das Schreiben von <b>docker-compose.yml</b> .  Aber f√ºr mich war lange Zeit nicht klar, wie ich richtig vorgehen sollte, wenn ein Container erst gestartet werden sollte, wenn ein anderer Container bereit ist, seine Anforderungen zu verarbeiten oder eine gewisse Arbeit auszuf√ºhren. <br><a name="habracut"></a><br>  Diese Frage wurde relevant, nachdem wir begonnen hatten, <b>Docker-Compose</b> aktiv zu verwenden, anstatt einzelne Docker zu starten. <br><br><h1>  Wof√ºr ist es? </h1><br>  Lassen Sie die Anwendung in Container B tats√§chlich von der Verf√ºgbarkeit des Dienstes in Container A abh√§ngen. Beim Start erh√§lt die Anwendung in Container B diesen Dienst nicht.  Was soll es tun? <br><br>  Es gibt zwei M√∂glichkeiten: <br><br><ul><li>  Das erste ist zu sterben (vorzugsweise mit einem Fehlercode) </li><li>  Die zweite besteht darin, zu warten und dann trotzdem zu sterben, wenn die Anwendung in Container B nicht auf das zugewiesene Zeitlimit reagiert hat </li></ul><br>  Nach dem Tod von Container B wird <b>Docker-Compose</b> (nat√ºrlich abh√§ngig von der Konfiguration) neu gestartet und die Anwendung in Container B versucht erneut, den Dienst in Container A zu erreichen. <br><br>  Dies wird so lange fortgesetzt, bis der Dienst in Container A bereit ist, auf Anforderungen zu antworten, oder bis wir feststellen, dass der Container st√§ndig √ºberlastet wird. <br>  Tats√§chlich ist dies der normale Weg f√ºr die Multi-Container-Architektur. <br><br>  Insbesondere waren wir jedoch mit einer Situation konfrontiert, in der Container A gestartet wird und Daten f√ºr Container B vorbereitet. Die Anwendung in Container B wei√ü nicht, wie sie √ºberpr√ºfen kann, ob die Daten bereit sind oder nicht, und beginnt sofort mit der Arbeit mit ihnen.  Daher m√ºssen wir das Signal zur Datenbereitschaft selbst empfangen und verarbeiten. <br><br>  Ich denke, dass Sie noch einige Anwendungsf√§lle nennen k√∂nnen.  Vor allem aber m√ºssen Sie genau verstehen, warum Sie dies tun.  Andernfalls ist es besser, die Standard- <b>Docker-Compose-</b> Tools zu verwenden. <br><br><h1>  Ein bisschen Ideologie </h1><br>  Wenn Sie die Dokumentation sorgf√§ltig lesen, ist dort alles geschrieben.  N√§mlich jeder <br>  Das Ger√§t ist unabh√§ngig und muss darauf achten, dass alle Dienste mit <br>  mit denen er arbeiten wird, stehen ihm zur Verf√ºgung. <br><br>  Daher geht es nicht darum, den Container zu starten oder nicht zu starten, sondern um <br>  √úberpr√ºfen Sie im Container die Bereitschaft aller erforderlichen Dienste und nur <br>  √úbertragen Sie dann die Steuerung auf die Containeranwendung. <br><br><h1>  Wie wird es umgesetzt? </h1><br>  Um dieses Problem zu l√∂sen <b>,</b> hat mir die <b>Docker-Compose-</b> Beschreibung sehr geholfen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> Teil davon <br>  und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel</a> √ºber die ordnungsgem√§√üe Verwendung von <b>Entrypoint</b> und <b>Cmd</b> . <br><br>  Also, was wir brauchen: <br><br><ul><li>  Es gibt einen Anhang A, den wir in Beh√§lter A eingewickelt haben </li><li>  es startet und reagiert auf Port 8000 OK </li><li>  Au√üerdem gibt es Anwendung B, die wir von Container B aus starten. Sie sollte jedoch nicht fr√ºher funktionieren, als Anwendung A auf Anforderungen an Port 8000 reagiert </li></ul><br>  Die offizielle Dokumentation bietet zwei M√∂glichkeiten, um dieses Problem zu l√∂sen. <br><br>  Der erste besteht darin, einen eigenen <b>Einstiegspunkt</b> in den Container zu schreiben, der alle √úberpr√ºfungen durchf√ºhrt, und dann die Arbeitsanwendung zu starten. <br><br>  Die zweite besteht darin, die bereits geschriebene Batch-Datei <b>wait-for-it.sh zu verwenden</b> . <br>  Wir haben beide M√∂glichkeiten ausprobiert. <br><br><h2>  Schreiben Sie Ihren eigenen Einstiegspunkt </h2><br>  Was ist der <b>Einstiegspunkt</b> ? <br><br>  Dies ist nur die ausf√ºhrbare Datei, die Sie beim Erstellen des Containers in der <b>Docker-</b> <b>Datei im</b> Feld <b>ENTRYPOINT</b> <b>angeben</b> .  Diese Datei f√ºhrt, wie bereits erw√§hnt, √úberpr√ºfungen durch und startet dann die Hauptanwendung des Containers. <br><br>  Also was wir bekommen: <br><br>  Erstellen Sie einen <i>Entrypoint-</i> Ordner. <br><br>  Es hat zwei Unterordner - <i>container_A</i> und <i>container_B</i> .  Wir werden unsere Container in ihnen erstellen. <br><br>  Nehmen wir f√ºr Container A einen einfachen http-Server auf Python.  Nach dem Start beginnt er zu antworten, um Anfragen an Port 8000 zu erhalten. <br><br>  Um unser Experiment deutlicher zu machen, haben wir eine Verz√∂gerung von 15 Sekunden festgelegt, bevor wir den Server starten. <br><br>  Es stellt sich die folgende <b>Docker-Datei f√ºr Container A heraus</b> : <br><br><pre><code class="plaintext hljs">FROM python:3 EXPOSE 8000 CMD sleep 15 &amp;&amp; python3 -m http.server --cgi</code> </pre> <br>  Erstellen Sie <b>f√ºr Container B</b> die folgende <b>Docker-Datei f√ºr Container B</b> : <br><br><pre> <code class="plaintext hljs">FROM ubuntu:18.04 RUN apt-get update RUN apt-get install -y curl COPY ./entrypoint.sh /usr/bin/entrypoint.sh ENTRYPOINT [ "entrypoint.sh" ] CMD ["echo", "!!!!!!!! Container_A is available now !!!!!!!!"]</code> </pre><br>  Und legen Sie unsere ausf√ºhrbare Datei entrypoint.sh im selben Ordner ab.  Wir werden es so haben <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash set -e host="conteiner_a" port="8000" cmd="$@" &gt;&amp;2 echo "!!!!!!!! Check conteiner_a for available !!!!!!!!" until curl http://"$host":"$port"; do &gt;&amp;2 echo "Conteiner_A is unavailable - sleeping" sleep 1 done &gt;&amp;2 echo "Conteiner_A is up - executing command" exec $cmd</span></span></code> </pre><br>  Was ist los in Container B: <br><br><ul><li>  Wenn es startet, startet es <b>ENTRYPOINT</b> , d.h.  startet <b>entrypoint.sh</b> </li><li>  <b>entrypoint.sh</b> beginnt mit <b>curl</b> mit dem Abfragen von Port 8000 f√ºr Container A. Dies geschieht so lange, bis eine Antwort von 200 empfangen wird (d. <b>h</b> . <b>curl</b> endet in diesem Fall mit einem Ergebnis von Null und die Schleife endet). </li><li>  Wenn 200 empfangen wird, endet die Schleife und die Steuerung wird an den in der Variablen <b>$ cmd</b> angegebenen Befehl √ºbergeben.  Und es zeigt an, was wir in der Docker-Datei im <b>CMD-</b> Feld angegeben haben, d. H.  <i>echo "!!! Container_A ist jetzt verf√ºgbar !!!!!!!!"</i>  Warum dies so ist, wird im obigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel beschrieben</a> </li><li>  Wir drucken - <i>!!!</i>  <i>Container_A ist ab sofort verf√ºgbar !!!</i>  <i>und schlie√üen.</i> </li></ul><br>  Wir werden alles mit <b>Docker-Compose beginnen</b> . <br><br>  <b>docker-compose.yml</b> hier haben wir folgendes: <br><br><pre> <code class="plaintext hljs">version: '3' networks: waiting_for_conteiner: services: conteiner_a: build: ./conteiner_A container_name: conteiner_a image: conteiner_a restart: unless-stopped networks: - waiting_for_conteiner ports: - 8000:8000 conteiner_b: build: ./conteiner_B container_name: conteiner_b image: waiting_for_conteiner.entrypoint.conteiner_b restart: "no" networks: - waiting_for_conteiner</code> </pre><br>  Hier in <b>conteiner_a m√ºssen</b> keine <i>Ports angegeben werden: 8000: 8000</i> .  Dies wurde durchgef√ºhrt, um den Betrieb des darin ausgef√ºhrten http-Servers von au√üen √ºberpr√ºfen zu k√∂nnen. <br><br>  Au√üerdem wird Container B nach dem Herunterfahren nicht neu gestartet. <br><br>  Wir starten: <br><br><pre> <code class="plaintext hljs">docker-compose up ‚Äî-build</code> </pre><br>  Wir sehen, dass f√ºr 15 Sekunden eine Meldung √ºber die Nichtverf√ºgbarkeit von Container A angezeigt wird, und dann <br><br><pre> <code class="plaintext hljs">conteiner_b | Conteiner_A is unavailable - sleeping conteiner_b | % Total % Received % Xferd Average Speed Time Time Time Current conteiner_b | Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt; conteiner_b | &lt;html&gt; conteiner_b | &lt;head&gt; conteiner_b | &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; conteiner_b | &lt;title&gt;Directory listing for /&lt;/title&gt; conteiner_b | &lt;/head&gt; conteiner_b | &lt;body&gt; conteiner_b | &lt;h1&gt;Directory listing for /&lt;/h1&gt; conteiner_b | &lt;hr&gt; conteiner_b | &lt;ul&gt; conteiner_b | &lt;li&gt;&lt;a href=".dockerenv"&gt;.dockerenv&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="bin/"&gt;bin/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="boot/"&gt;boot/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="dev/"&gt;dev/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="etc/"&gt;etc/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="home/"&gt;home/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="lib/"&gt;lib/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="lib64/"&gt;lib64/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="media/"&gt;media/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="mnt/"&gt;mnt/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="opt/"&gt;opt/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="proc/"&gt;proc/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="root/"&gt;root/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="run/"&gt;run/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="sbin/"&gt;sbin/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="srv/"&gt;srv/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="sys/"&gt;sys/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="tmp/"&gt;tmp/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="usr/"&gt;usr/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="var/"&gt;var/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;/ul&gt; conteiner_b | &lt;hr&gt; conteiner_b | &lt;/body&gt; conteiner_b | &lt;/html&gt; 100 987 100 987 0 0 98700 0 --:--:-- --:--:-- --:--:-- 107k conteiner_b | Conteiner_A is up - executing command conteiner_b | !!!!!!!! Container_A is available now !!!!!!!!</code> </pre><br>  Wir bekommen eine Antwort auf Ihre Anfrage, drucken <nobr><i>!!!</i></nobr>  <nobr><i>Container_A ist ab sofort verf√ºgbar !!!!!!!!</i></nobr>  und schlie√üen. <br><br><h2>  Verwenden von wait-for-it.sh </h2><br>  Es ist sofort zu sagen, dass dieser Weg bei uns nicht funktioniert hat, wie in der Dokumentation beschrieben. <br>  Es ist n√§mlich bekannt, dass, wenn <b>ENTRYPOINT</b> und <b>CMD</b> in die <b>Docker-Datei</b> geschrieben <b>werden</b> , beim <b>Starten</b> des Containers der Befehl von <b>ENTRYPOINT</b> ausgef√ºhrt wird und der Inhalt von <b>CMD</b> als Parameter an ihn √ºbergeben wird. <br><br>  Es ist auch bekannt, dass <b>ENTRYPOINT</b> und <b>CMD,</b> die in der <b>Docker-Datei</b> angegeben sind, in <b>docker</b> <b>-compose.yml</b> √ºberschrieben werden <b>k√∂nnen</b> <br><br>  Das <b>Startformat wait-for-it.sh lautet</b> wie folgt: <br><br><pre> <code class="plaintext hljs">wait-for-it.sh __ -- ___</code> </pre><br>  Dann k√∂nnen wir, wie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel angegeben</a> , einen neuen <b>ENTRYPOINT</b> in <b>docker-compose.yml definieren</b> , und die <b>CMD wird</b> aus der <b>Docker-Datei</b> <b>ersetzt</b> . <br><br>  Also bekommen wir: <br><br>  <b>Docker-Datei f√ºr Container A</b> bleibt unver√§ndert: <br><br><pre> <code class="plaintext hljs">FROM python:3 EXPOSE 8000 CMD sleep 15 &amp;&amp; python3 -m http.server --cgi</code> </pre><br>  <b>Docker-Datei f√ºr Container B.</b> <br><br><pre> <code class="plaintext hljs">FROM ubuntu:18.04 COPY ./wait-for-it.sh /usr/bin/wait-for-it.sh CMD ["echo", "!!!!!!!! Container_A is available now !!!!!!!!"]</code> </pre><br>  <b>Docker-compose.yml</b> sieht <b>folgenderma√üen</b> aus: <br><br><pre> <code class="plaintext hljs">version: '3' networks: waiting_for_conteiner: services: conteiner_a: build: ./conteiner_A container_name: conteiner_a image: conteiner_a restart: unless-stopped networks: - waiting_for_conteiner ports: - 8000:8000 conteiner_b: build: ./conteiner_B container_name: conteiner_b image: waiting_for_conteiner.wait_for_it.conteiner_b restart: "no" networks: - waiting_for_conteiner entrypoint: ["wait-for-it.sh", "-s" , "-t", "20", "conteiner_a:8000", "--"]</code> </pre><br>  Wir f√ºhren den Befehl <b>wait-for-it aus</b> , weisen ihn an, 20 Sekunden zu warten, bis Container A zum Leben erweckt wird, und geben einen weiteren Parameter <b>"-" an</b> , der die <b>Wait-for-it-</b> Parameter von dem Programm trennen soll, das nach Abschluss des Vorgangs gestartet wird. <br><br>  Wir versuchen es! <br>  Und leider bekommen wir nichts. <br><br>  Wenn wir √ºberpr√ºfen, mit welchen Argumenten wir wait-for-it ausf√ºhren, werden wir <b>feststellen,</b> dass nur das √ºbergeben wird, was wir im <b>Einstiegspunkt</b> angegeben haben. Die <b>CMD</b> aus dem Container wird nicht angeh√§ngt. <br><br><h3>  Arbeitsoption </h3><br>  Dann gibt es nur eine Option.  Was wir in der <b>CMD</b> in der <b>Docker-Datei</b> angegeben haben, m√ºssen wir auf den <b>Befehl</b> in <b>docker-compose.yml √ºbertragen</b> . <br><br>  <b>Lassen Sie dann die</b> <b>Docker-Datei</b> <b>von</b> Container B unver√§ndert, und <b>docker-compose.yml</b> sieht folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">version: '3' networks: waiting_for_conteiner: services: conteiner_a: build: ./conteiner_A container_name: conteiner_a image: conteiner_a restart: unless-stopped networks: - waiting_for_conteiner ports: - 8000:8000 conteiner_b: build: ./conteiner_B container_name: conteiner_b image: waiting_for_conteiner.wait_for_it.conteiner_b restart: "no" networks: - waiting_for_conteiner entrypoint: ["wait-for-it.sh", "-s" ,"-t", "20", "conteiner_a:8000", "--"] command: ["echo", "!!!!!!!! Container_A is available now !!!!!!!!"]</code> </pre><br>  Und in dieser Version funktioniert es. <br><br>  Abschlie√üend muss gesagt werden, dass unserer Meinung nach der richtige Weg der erste ist.  Es ist das vielseitigste und erm√∂glicht es Ihnen, eine Bereitschaftspr√ºfung auf jede m√∂gliche Weise durchzuf√ºhren.  <b>Wait-for-it ist</b> nur ein n√ºtzliches Dienstprogramm, das Sie entweder separat oder durch Einbetten in Ihre <b>entrypoint.sh verwenden k√∂nnen</b> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454552/">https://habr.com/ru/post/de454552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454536/index.html">Verst√§rker zum klassischen Herzfrequenzsensor</a></li>
<li><a href="../de454538/index.html">Frontend Weekly Digest (27. Mai - 2. Juni 2019)</a></li>
<li><a href="../de454540/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 367 (27. Mai - 2. Juni 2019)</a></li>
<li><a href="../de454542/index.html">Kabelfernsehnetze f√ºr die Kleinsten. Teil 7: Optische Empf√§nger</a></li>
<li><a href="../de454546/index.html">Wie viele Programmierer brauchen Sie, um eine Tasse Kaffee zu trinken?</a></li>
<li><a href="../de454556/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 462 (21.05.2019 - 27.05.2019)</a></li>
<li><a href="../de454558/index.html">PHP Digest Nr. 157 (20. Mai - 3. Juni 2019)</a></li>
<li><a href="../de454562/index.html">Warum das Konzept des Bytecodes nicht mehr so ‚Äã‚Äãrelevant ist wie zuvor</a></li>
<li><a href="../de454568/index.html">Mozilla bezeichnete Googles digital signierte Webpaket-Distribution als "schlecht".</a></li>
<li><a href="../de454570/index.html">Neuerstellung eines alten DOS-Spiels in C ++ 17</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>