<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👬 🦕 👇🏾 Angular Pitfall Bypass und Zeitersparnis 🏉 🤰🏽 🔟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mit Angular können Sie alles tun. Oder fast alles. Aber manchmal führt dieses heimtückische „fast“ dazu, dass der Entwickler Zeit verschwendet, indem ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angular Pitfall Bypass und Zeitersparnis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459304/">  Mit Angular können Sie alles tun.  Oder fast alles.  Aber manchmal führt dieses heimtückische „fast“ dazu, dass der Entwickler Zeit verschwendet, indem er Problemumgehungen erstellt oder versucht zu verstehen, warum etwas passiert oder warum etwas nicht wie erwartet funktioniert. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/bl/sj/vq/blsjvqaqs4fhtnqmscwlw7lx0zs.jpeg"></a> <br><br>  Der Autor des Artikels, den wir heute übersetzen, sagt, er möchte Tipps teilen, die Angular-Entwicklern helfen, Zeit zu sparen.  Er wird über die Fallstricke von Angular sprechen, die er (und nicht nur er) kennenlernen durfte. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Nr. 1.</font>  <font color="#3AC1EF">Die von Ihnen angewendete benutzerdefinierte Direktive funktioniert nicht</font> </h2><br>  Sie haben also eine nette Angular-Direktive von Drittanbietern gefunden und beschlossen, sie mit Standardelementen in der Angular-Vorlage zu verwenden.  Großartig!  Versuchen wir Folgendes: <br><br><pre><code class="javascript hljs">&lt;span awesomeTooltip=<span class="hljs-string"><span class="hljs-string">"'Tooltip text'"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Sie starten die Anwendung ... und nichts passiert.  Sie schauen wie jeder normale, erfahrene Programmierer in die Chrome Developer Tools-Konsole.  Und Sie sehen dort nichts.  Die Direktive funktioniert nicht und Angular schweigt. <br><br>  Dann beschließt ein kluger Kopf Ihres Teams, die Richtlinie in eckige Klammern zu setzen. <br><br><pre> <code class="javascript hljs">&lt;span [awesomeTooltip]=<span class="hljs-string"><span class="hljs-string">"'Tooltip text'"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Nachdem wir etwas Zeit verloren haben, sehen wir Folgendes in der Konsole. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/532/4aa/95f/5324aa95f7aa2d0d1a20e74f93953eb1.png"></div><br>  <i><font color="#999999">Hier ist die Sache: Wir haben nur vergessen, das Modul mit der Direktive zu importieren</font></i> <br><br>  Jetzt liegt die Ursache des Problems auf der Hand: Wir haben nur vergessen, das Direktivenmodul in das Angular-Anwendungsmodul zu importieren. <br>  Dies führt zu einer wichtigen Regel: Verwenden Sie niemals Direktiven ohne eckige Klammern. <br><br>  Hier können Sie mit Direktiven experimentieren. <br><br><h2>  <font color="#3AC1EF">Nr. 2.</font>  <font color="#3AC1EF">ViewChild gibt undefiniert zurück</font> </h2><br>  Angenommen, Sie haben einen Link zu einem Texteingabeelement erstellt, das in einer Winkelvorlage beschrieben ist. <br><br><pre> <code class="javascript hljs">&lt;input type=<span class="hljs-string"><span class="hljs-string">"text"</span></span> name=<span class="hljs-string"><span class="hljs-string">"fname"</span></span> #inputTag&gt;</code> </pre> <br>  Mit der Funktion RxJS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fromEvent</a> erstellen Sie einen Stream, in den das, was in das Feld eingegeben wird, fällt.  Dazu benötigen Sie einen Link zum Eingabefeld, der mit dem Angular <code>ViewChild</code> Dekorator abgerufen werden kann: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AfterViewInit</span></span></span><span class="hljs-class"> </span></span>{    @ViewChild(<span class="hljs-string"><span class="hljs-string">'inputTag'</span></span>) inputTag: ElementRef;    ngAfterViewInit(){        <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input$ = fromEvent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputTag.nativeElement, <span class="hljs-string"><span class="hljs-string">'keyUp'</span></span>)    } ...   }</code> </pre> <br>  Hier erstellen wir mit der Funktion RxJS <code>fromEvent</code> einen Stream, in den die in das Feld eingegebenen Daten fallen. <br>  Testen Sie diesen Code. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f0/504/558/4f0504558e9daf73a87d78da7f00fb04.png"></div><br>  <i><font color="#999999">Fehler</font></i> <br><br>  Was ist passiert? <br><br>  Tatsächlich gilt hier die folgende Regel: Wenn <code>ViewChild</code> <code>undefined</code> zurückgibt, suchen <code>*ngIf</code> in der Vorlage nach <code>*ngIf</code> . <br><br><pre> <code class="javascript hljs">&lt;div *ngIf=<span class="hljs-string"><span class="hljs-string">"someCondition"</span></span>&gt;    <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"fname"</span></span></span></span><span class="xml"><span class="hljs-tag"> #</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">inputTag</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Hier ist er der Schuldige des Problems. <br><br>  Überprüfen Sie außerdem die Vorlage auf andere strukturelle Anweisungen oder die <code>ng-template</code> über dem Problemelement. <br>  Überlegen Sie sich mögliche Lösungen für dieses Problem. <br><br><h3>  <font color="#3AC1EF">▍Variante zur Lösung des Problems №1</font> </h3><br>  Sie können das Vorlagenelement einfach ausblenden, wenn Sie es nicht benötigen.  In diesem Fall bleibt das Element immer bestehen und <code>ViewChild</code> kann im <code>ngAfterViewInit</code> Hook einen Link dazu <code>ngAfterViewInit</code> . <br><br><pre> <code class="javascript hljs">&lt;div [hidden]=<span class="hljs-string"><span class="hljs-string">"!someCondition"</span></span>&gt;    <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"fname"</span></span></span></span><span class="xml"><span class="hljs-tag"> #</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">inputTag</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Variante zur Lösung des Problems №2</font> </h3><br>  Eine andere Möglichkeit, dieses Problem zu lösen, ist die Verwendung von Setzern. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{   @ViewChild(<span class="hljs-string"><span class="hljs-string">'inputTag'</span></span>) set inputTag(input: ElementRef|<span class="hljs-literal"><span class="hljs-literal">null</span></span>) {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!input) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomething(input);  }  doSomething(input) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input$ = keysfromEvent(input.nativeElement, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>);    ...  } }</code> </pre> <br>  Sobald Angular der Eigenschaft <code>inputTag</code> einen bestimmten Wert <code>inputTag</code> , erstellen wir hier einen Stream aus den im Eingabefeld eingegebenen Daten. <br><br>  Im Folgenden finden Sie einige nützliche Ressourcen zu diesem Problem: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier können</a> Sie lesen, dass die Ergebnisse von <code>ViewChild</code> in Angular 8 statisch und dynamisch sein können. </li><li>  Wenn Sie Schwierigkeiten haben, mit RxJs zu arbeiten, schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen</a> Videokurs an. </li></ul><br><h2>  <font color="#3AC1EF">Nummer 3.</font>  <font color="#3AC1EF">Codeausführung beim Aktualisieren der mit * ngFor generierten Liste (nachdem die Elemente im DOM angezeigt wurden)</font> </h2><br>  Angenommen, Sie haben eine interessante benutzerdefinierte Direktive zum Organisieren von scrollbaren Listen.  Sie werden es auf eine Liste anwenden, die mit der <code>*ngFor</code> Angular <code>*ngFor</code> . <br><br><pre> <code class="javascript hljs">&lt;div *ngFor=<span class="hljs-string"><span class="hljs-string">"let item of itemsList; let i = index;"</span></span>     [customScroll]     &gt;  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag"> *</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ngFor</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"let item of items"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"list-item"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{{item}}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>   &lt;<span class="hljs-regexp"><span class="hljs-regexp">/div&gt;</span></span></code> </pre> <br>  In solchen Fällen müssen Sie beim Aktualisieren der Liste <code>scrollDirective.update</code> etwas wie <code>scrollDirective.update</code> , um das Bildlaufverhalten unter Berücksichtigung der in der Liste vorgenommenen Änderungen zu konfigurieren. <br><br>  Es scheint, dass dies mit dem <code>ngOnChanges</code> Hook möglich ist: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnChanges</span></span></span><span class="hljs-class"> </span></span>{  @Input() itemsList = [];   @ViewChild(CustomScrollDirective) scroll: CustomScrollDirective;  ngOnChanges(changes) {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (changes.itemsList) {      <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scroll.update();    }  } ... }</code> </pre> <br>  Hier stehen wir zwar vor einem Problem.  Der Hook wird aufgerufen, bevor der Browser die aktualisierte Liste anzeigt.  Infolgedessen wird die Neuberechnung der Direktivenparameter zum Scrollen der Liste falsch durchgeführt. <br><br>  Wie kann ich direkt nach Abschluss der Arbeit einen Anruf <code>*ngFor</code> ? <br><br>  Sie können dies tun, indem Sie diese 3 einfachen Schritte ausführen: <br><br><h3>  <font color="#3AC1EF">▍Schritt Nummer 1</font> </h3><br>  <code>*ngFor</code> Sie die Links zu den Elementen ein, auf die <code>*ngFor</code> ( <code>#listItems</code> ) <code>#listItems</code> . <br><br><pre> <code class="javascript hljs">&lt;div [customScroll]&gt;    <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag"> *</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ngFor</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"let item of items"</span></span></span></span><span class="xml"><span class="hljs-tag"> #</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">listItems</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{{item}}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/div&gt;</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Schritt Nummer 2</font> </h3><br>  <code>ViewChildren</code> mit dem Angular <code>ViewChildren</code> Dekorator eine Liste dieser Elemente ab.  Es gibt eine Entität vom Typ <code>QueryList</code> . <br><br><h3>  <font color="#3AC1EF">▍Schritt Nummer 3</font> </h3><br>  Die <code>QueryList</code> Klasse verfügt über eine schreibgeschützte <a href="">Änderungseigenschaft</a> , die bei jeder Änderung der Liste Ereignisse <code>QueryList</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AfterViewInit</span></span></span><span class="hljs-class"> </span></span>{  @Input() itemsList = [];   @ViewChild(CustomScrollDirective) scroll: CustomScrollDirective;  @ViewChildren(<span class="hljs-string"><span class="hljs-string">'listItems'</span></span>) listItems: QueryList&lt;any&gt;;  private sub: Subscription;   ngAfterViewInit() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sub = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listItems.changes.subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scroll.update())  } ... }</code> </pre> <br>  Jetzt ist das Problem behoben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier können</a> Sie mit dem entsprechenden Beispiel experimentieren. <br><br><h2>  <font color="#3AC1EF">Nummer 4.</font>  <font color="#3AC1EF">Probleme mit ActivatedRoute.queryParam, die auftreten, wenn Abfragen ohne Parameter ausgeführt werden können</font> </h2><br>  Der folgende Code hilft uns, die Essenz dieses Problems zu verstehen. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// app-routing.module.ts const routes: Routes = [    {path: '', redirectTo: '/home', pathMatch: 'full'},    {path: 'home', component: HomeComponent},  ];   @NgModule({    imports: [RouterModule.forRoot(routes)], //  #1    exports: [RouterModule]  })  export class AppRoutingModule { }    //app.module.ts  @NgModule({    ...    bootstrap: [AppComponent] //  #2  })  export class AppModule { }   // app.component.html  &lt;router-outlet&gt;&lt;/router-outlet&gt; //  #3    // app.component.ts  export class AppComponent implements OnInit {    title = 'QueryTest';     constructor(private route: ActivatedRoute) { }     ngOnInit() {      this.route.queryParams          .subscribe(params =&gt; {            console.log('saveToken', params); //  #4          });    }  }</span></span></code> </pre> <br>  Einige Fragmente dieses Codes sind Kommentare wie <code> #x</code> .  Betrachten Sie sie: <br><br><ol><li>  Im Hauptmodul der Anwendung haben wir die Routen definiert und dort das <code>RouterModule</code> hinzugefügt.  Routen sind so konfiguriert, dass wir den Benutzer zur <code>/home</code> Seite umleiten, wenn in der URL keine Route angegeben ist. </li><li>  Als Komponente zum Herunterladen geben wir im Hauptmodul <code>AppComponent</code> . </li><li>  <code>AppComponent</code> verwendet <code>&lt;router-outlet&gt;</code> um die entsprechenden <code>AppComponent</code> auszugeben. </li><li>  Nun das Wichtigste.  Wir müssen <code>queryParams</code> für die Route von der URL erhalten </li></ol><br>  Angenommen, wir haben die folgende URL: <br><br><pre> <code class="javascript hljs">https:<span class="hljs-comment"><span class="hljs-comment">//localhost:4400/home?accessToken=someTokenSequence</span></span></code> </pre> <br>  In diesem Fall <code>queryParams</code> aus: <br><br><pre> <code class="javascript hljs">{<span class="hljs-attr"><span class="hljs-attr">accessToken</span></span>: <span class="hljs-string"><span class="hljs-string">'someTokenSequence'</span></span>}</code> </pre> <br>  Schauen wir uns die Arbeit im Browser an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29f/aef/ae5/29faefae56d8e01e314cb6eab9fae6dc.png"></div><br>  <i><font color="#999999">Testen einer Anwendung, die ein Routing-System implementiert</font></i> <br><br>  Hier haben Sie möglicherweise eine Frage zum Wesen des Problems.  Wir haben die Parameter, alles funktioniert wie erwartet ... <br><br>  Schauen Sie sich den obigen Screenshot des Browsers an und was in der Konsole angezeigt wird.  Hier sehen Sie, dass das <code>queryParams</code> Objekt zweimal ausgegeben wird.  Das erste Objekt ist leer und wird während des Initialisierungsprozesses des Angular-Routers ausgegeben.  Erst danach erhalten wir ein Objekt, das die Anforderungsparameter enthält (in unserem Fall - <code>{accessToken: 'someTokenSequence'}</code> ). <br><br>  Das Problem ist, dass der Router nichts zurückgibt, wenn die URL keine Anforderungsparameter enthält.  Das heißt, nach der Ausgabe des ersten leeren Objekts wird das zweite ebenfalls leere Objekt, das auf das Fehlen von Parametern hinweisen könnte, nicht ausgegeben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e16/1b7/8be/e161b78be5051b1ee9f9ca1ec2c9d31a.png"></div><br>  <i><font color="#999999">Wenn eine Anforderung ohne Parameter ausgeführt wird, wird das zweite Objekt nicht ausgegeben</font></i> <br><br>  Infolgedessen stellt sich heraus, dass der Code, wenn er ein zweites Objekt erwartet, von dem er Anforderungsdaten empfangen kann, nicht gestartet wird, wenn die URL keine Anforderungsparameter enthält. <br><br>  Wie kann man dieses Problem lösen?  Hier können uns RxJs helfen.  Wir werden zwei beobachtbare Objekte basierend auf <code>ActivatedRoute.queryParams</code> erstellen.  Überlegen Sie sich wie gewohnt eine schrittweise Lösung des Problems. <br><br><h3>  <font color="#3AC1EF">▍Schritt Nummer 1</font> </h3><br>  Das erste beobachtbare Objekt, <code>paramsInUrl$</code> , gibt Daten zurück, wenn <code>queryParams</code> nicht leer ist: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private route: ActivatedRoute,                private locationService: Location) {    }    ngOnInit() {             <span class="hljs-comment"><span class="hljs-comment">//            //              const paramsInUrl$ = this.route.queryParams.pipe(            filter(params =&gt; Object.keys(params).length &gt; 0)        );     ...    } }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Schritt Nummer 2</font> </h3><br>  Das zweite beobachtbare Objekt, <code>noParamsInUrl$</code> , gibt nur dann <code>noParamsInUrl$</code> leeren Wert zurück, wenn in der URL keine Anforderungsparameter gefunden wurden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{    title = <span class="hljs-string"><span class="hljs-string">'QueryTest'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private route: ActivatedRoute,                private locationService: Location) {    }    ngOnInit() {                 ...        <span class="hljs-comment"><span class="hljs-comment">//   ,     ,   URL        //             const noParamsInUrl$ = this.route.queryParams.pipe(            filter(() =&gt; !this.locationService.path().includes('?')),            map(() =&gt; ({}))        );            ...    } }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Schritt Nummer 3</font> </h3><br>  Kombinieren Sie nun die beobachteten Objekte mit der RxJS- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammenführungsfunktion</a> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{    title = <span class="hljs-string"><span class="hljs-string">'QueryTest'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private route: ActivatedRoute,                private locationService: Location) {    }    ngOnInit() {             <span class="hljs-comment"><span class="hljs-comment">//            //              const paramsInUrl$ = this.route.queryParams.pipe(            filter(params =&gt; Object.keys(params).length &gt; 0)        );        //   ,     ,   URL        //             const noParamsInUrl$ = this.route.queryParams.pipe(            filter(() =&gt; !this.locationService.path().includes('?')),            map(() =&gt; ({}))        );        const params$ = merge(paramsInUrl$, noParamsInUrl$);        params$.subscribe(params =&gt; {            console.log('saveToken', params);        });    } }</span></span></code> </pre> <br>  Jetzt gibt das beobachtete <code>param$</code> -Objekt nur einmal <code>param$</code> Wert zurück - unabhängig davon, ob etwas in <code>queryParams</code> (ein Objekt mit Abfrageparametern wird <code>queryParams</code> ) oder nicht (ein leeres Objekt wird <code>queryParams</code> ). <br><br>  Sie können hier mit diesem Code experimentieren. <br><br><h2>  <font color="#3AC1EF">Nr. 5.</font>  <font color="#3AC1EF">Langsame Seiten</font> </h2><br>  Angenommen, Sie haben eine Komponente, die einige formatierte Daten anzeigt: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// home.component.html &lt;div class="wrapper" (mousemove)="mouseCoordinates = {x: $event.x, y: $event.y}"&gt;  &lt;div *ngFor="let item of items"&gt;     &lt;span&gt;{{formatItem(item)}}&lt;/span&gt;  &lt;/div&gt; &lt;/div&gt; {{mouseCoordinates | json}} // home.component.ts export class HomeComponent {    items = [1, 2, 3, 4, 5, 6];    mouseCoordinates = {};    formatItem(item) {              //           const t = Array.apply(null, Array(5)).map(() =&gt; 1);             console.log('formatItem');        return item + '%';    } }</span></span></code> </pre> <br>  Diese Komponente löst zwei Probleme: <br><br><ol><li>  Es zeigt ein Array von Elementen an (es wird angenommen, dass diese Operation einmal ausgeführt wird).  Darüber hinaus wird formatiert, was durch Aufrufen der <code>formatItem</code> Methode angezeigt wird. </li><li>  Es zeigt die Koordinaten der Maus an (dieser Wert wird offensichtlich sehr oft aktualisiert). </li></ol><br>  Sie erwarten nicht, dass diese Komponente Leistungsprobleme aufweist.  Führen Sie daher nur einen Leistungstest durch, um alle Formalitäten zu erfüllen.  Während dieses Tests treten jedoch einige Kuriositäten auf. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/015/97d/621/01597d6210a35f37a8030702c0b71753.png"></div><br>  <i><font color="#999999">Viele formatItem-Aufrufe und ziemlich viel CPU-Auslastung</font></i> <br><br>  Was ist los?  Tatsache ist jedoch, dass Angular beim erneuten Zeichnen der Vorlage alle Funktionen aus der Vorlage aufruft (in unserem Fall die <code>formatItem</code> Funktion).  Wenn in den Vorlagenfunktionen umfangreiche Berechnungen durchgeführt werden, belastet dies den Prozessor und wirkt sich darauf aus, wie Benutzer die entsprechende Seite wahrnehmen. <br><br>  Wie kann ich das beheben?  Es reicht aus, die in <code>formatItem</code> durchgeführten <code>formatItem</code> im Voraus <code>formatItem</code> und die bereits bereitstehenden Daten auf der Seite anzuzeigen. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// home.component.html &lt;div class="wrapper" (mousemove)="mouseCoordinates = {x: $event.x, y: $event.y}"&gt;  &lt;div *ngFor="let item of displayedItems"&gt;    &lt;span&gt;{{item}}&lt;/span&gt;  &lt;/div&gt; &lt;/div&gt; {{mouseCoordinates | json}} // home.component.ts @Component({    selector: 'app-home',    templateUrl: './home.component.html',    styleUrls: ['./home.component.sass'] }) export class HomeComponent implements OnInit {    items = [1, 2, 3, 4, 5, 6];    displayedItems = [];    mouseCoordinates = {};    ngOnInit() {        this.displayedItems = this.items.map((item) =&gt; this.formatItem(item));    }    formatItem(item) {        console.log('formatItem');        const t = Array.apply(null, Array(5)).map(() =&gt; 1);        return item + '%';    } }</span></span></code> </pre> <br>  Jetzt sieht der Leistungstest viel anständiger aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ce/f49/118/2cef4911810ce0a506dd0697ee801119.png"></div><br>  <i><font color="#999999">Nur 6 formatItem-Aufrufe und geringe Prozessorlast</font></i> <br><br>  Jetzt funktioniert die Anwendung viel besser.  Die hier verwendete Lösung weist jedoch einige Funktionen auf, die nicht immer angenehm sind: <br><br><ul><li>  Da wir die Koordinaten der Maus in der Vorlage <code>mousemove</code> , löst das <code>mousemove</code> immer noch eine Änderungsprüfung aus.  Da wir jedoch die Koordinaten der Maus benötigen, können wir dies nicht loswerden. </li><li>  Wenn der <code>mousemove</code> Ereignishandler nur einige Berechnungen durchführen muss (die sich nicht auf die Anzeige auf der Seite auswirken), können Sie Folgendes tun, um die Anwendung zu beschleunigen: <br><br><ol><li>  Sie können <code>NgZone.runOutsideOfAngular</code> in der Ereignishandlerfunktion verwenden.  Dies verhindert, dass die Überprüfung von Änderungen <code>mousemove</code> wenn das <code>mousemove</code> (dies <code>mousemove</code> sich nur auf diesen Handler aus). </li><li>  Sie können den Patch zone.js für einige Ereignisse verhindern, indem Sie die folgende Codezeile in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">polyfills.ts verwenden</a> .  Dies wirkt sich auf die gesamte Angular-Anwendung aus. </li></ol></li></ul><br><pre> <code class="javascript hljs">* (<span class="hljs-built_in"><span class="hljs-built_in">window</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> any).__zone_symbol__UNPATCHED_EVENTS = [<span class="hljs-string"><span class="hljs-string">'scroll'</span></span>, <span class="hljs-string"><span class="hljs-string">'mousemove'</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre> <br>  Wenn Sie sich für die Verbesserung der Leistung von Angular-Anwendungen interessieren - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> - nützliche Materialien dazu. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Nachdem Sie diesen Artikel gelesen haben, sollten in Ihrem Angular-Entwickler-Arsenal 5 neue Tools angezeigt werden, mit denen Sie einige häufig auftretende Probleme lösen können.  Wir hoffen, dass die Tipps, die Sie hier gefunden haben, Ihnen helfen, Zeit zu sparen. <br><br>  <b>Liebe Leser!</b>  Wissen Sie etwas, das Ihnen hilft, Zeit bei der Entwicklung von Angular-Anwendungen zu sparen? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459304/">https://habr.com/ru/post/de459304/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459294/index.html">Was ist wichtiger: eine Programmiersprache kennen oder ein Geschäftsproblem lösen können?</a></li>
<li><a href="../de459296/index.html">JavaScript Preis 2019</a></li>
<li><a href="../de459298/index.html">Winkel: Status im Jahr 2019</a></li>
<li><a href="../de459300/index.html">Quasar 1.0: Ein neues nützliches Tool für Vue-Entwickler und nicht nur für sie</a></li>
<li><a href="../de459302/index.html">Wiederholen fehlgeschlagener HTTP-Anforderungen in Angular</a></li>
<li><a href="../de459306/index.html">Server-Rendering in einer Umgebung ohne Server</a></li>
<li><a href="../de459308/index.html">SEO funktioniert 2019 nicht?</a></li>
<li><a href="../de459310/index.html">Testautomatisierungstools oder mobiler Steroidtester</a></li>
<li><a href="../de459312/index.html">Lieber Agile, ich habe es satt, so zu tun</a></li>
<li><a href="../de459314/index.html">Visualisieren und behandeln Sie Hash Match Join</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>