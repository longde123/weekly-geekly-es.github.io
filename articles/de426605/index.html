<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüî¨ üö¥ ü§¶üèæ Statische Analyse von PHP-Code am Beispiel von PHPStan, Phan und Psalm ü•° üèä üíï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Badoo gibt es seit √ºber 12 Jahren. Wir haben viel PHP-Code (Millionen von Zeilen) und wahrscheinlich wurden sogar Zeilen, die vor 12 Jahren geschriebe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Statische Analyse von PHP-Code am Beispiel von PHPStan, Phan und Psalm</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/426605/"><img src="https://habrastorage.org/webt/yj/nq/4_/yjnq4_9tdzj0noyiimybxjpoctk.jpeg"><br><br>  Badoo gibt es seit √ºber 12 Jahren.  Wir haben viel PHP-Code (Millionen von Zeilen) und wahrscheinlich wurden sogar Zeilen, die vor 12 Jahren geschrieben wurden, beibehalten.  Wir haben Code in den Tagen von PHP 4 und PHP 5 zur√ºckgeschrieben. Wir laden den Code zweimal t√§glich hoch und jedes Layout enth√§lt ungef√§hr 10-20 Aufgaben.  Dar√ºber hinaus k√∂nnen Programmierer dringende Patches ver√∂ffentlichen - kleine √Ñnderungen.  Und am Tag solcher Patches gewinnen wir ein paar Dutzend.  Im Allgemeinen √§ndert sich unser Code sehr aktiv. <br><br>  Wir suchen st√§ndig nach M√∂glichkeiten, die Entwicklung zu beschleunigen und die Qualit√§t des Codes zu verbessern.  Eines Tages beschlossen wir, eine statische Code-Analyse zu implementieren.  Was dabei herauskam, lesen Sie unter dem Schnitt. <br><a name="habracut"></a><br><h1>  Strenge Typen: Warum verwenden wir es noch nicht? </h1><br>  Einmal begann eine Diskussion in unserem PHP-Chat f√ºr Unternehmen.  Einer der neuen Mitarbeiter erz√§hlte, wie er am vorherigen Arbeitsplatz die obligatorischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinweise</a> f√ºr strict_types + scalar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">type</a> f√ºr den gesamten Code eingef√ºhrt hat - und dies hat die Anzahl der Fehler in der Produktion erheblich reduziert. <br><br>  Die meisten Chat-Oldtimer waren gegen eine solche Innovation.  Der Hauptgrund war, dass PHP keinen Compiler hat, der alle Typen im Code zum Zeitpunkt der Kompilierung √ºberpr√ºft. Wenn Sie den Code nicht zu 100% mit Tests abdecken, besteht immer das Risiko, dass Fehler in der Produktion auftreten, was wir nicht tun wollen erlauben. <br><br>  Nat√ºrlich findet strict_types einen bestimmten Prozentsatz von Fehlern, die durch Typinkongruenz verursacht werden, und wie PHP Typen "stillschweigend" konvertiert.  Viele erfahrene PHP-Programmierer wissen jedoch bereits, wie das Typsystem in PHP funktioniert, nach welchen Regeln die Typkonvertierung erfolgt, und in den meisten F√§llen schreiben sie korrekten Arbeitscode. <br><br>  Aber die Idee, ein bestimmtes System zu haben, das anzeigt, wo im Code eine Typinkongruenz vorliegt, hat uns gefallen.  Wir haben √ºber Alternativen zu strict_types nachgedacht. <br><br>  Zuerst wollten wir sogar PHP patchen.  Wir wollten, dass TypeError (was an sich eine Ausnahme darstellt) nicht ausgel√∂st wird, wenn die Funktion einen Skalartyp (z. B. int) verwendet und ein anderer Skalartyp (wie float) eingeht, sondern eine Typkonvertierung erfolgt. sowie das Protokollieren dieses Ereignisses in error.log.  Dies w√ºrde es uns erm√∂glichen, alle Stellen zu finden, an denen unsere Annahmen √ºber Typen falsch sind.  Aber ein solcher Patch schien uns riskant, und selbst es k√∂nnte Probleme mit externen Abh√§ngigkeiten geben, die f√ºr ein solches Verhalten nicht bereit sind. <br><br>  Wir haben die Idee des Patchens von PHP aufgegeben, aber mit der Zeit fiel alles mit den ersten Versionen des statischen Phan-Analysators zusammen, die ersten Commits, die von Rasmus Lerdorf selbst vorgenommen wurden.  Deshalb kamen wir auf die Idee, statische Code-Analysatoren auszuprobieren. <br><br><h1>  Was ist statische Code-Analyse? </h1><br>  Statische Code-Analysatoren lesen einfach den Code und versuchen, Fehler darin zu finden.  Sie k√∂nnen sehr einfache und offensichtliche √úberpr√ºfungen durchf√ºhren (z. B. auf das Vorhandensein von Klassen, Methoden und Funktionen sowie auf schwierigere (z. B. nach Typinkongruenzen, Rassenbedingungen oder Schwachstellen im Code). Der Schl√ºssel ist, dass Analysatoren keinen Code ausf√ºhren - sie Analysieren Sie den Programmtext und √ºberpr√ºfen Sie ihn auf typische (und nicht so) Fehler. <br><br>  Das offensichtlichste Beispiel f√ºr einen statischen PHP-Code-Analysator sind Inspektionen in PHPStorm: Wenn Sie Code schreiben, werden falsche Aufrufe von Funktionen, Methoden, Fehlanpassungen von Parametertypen usw. hervorgehoben. PHPStorm f√ºhrt Ihren PHP-Code jedoch nicht aus, sondern analysiert ihn nur. <br><br>  Ich stelle fest, dass es sich in diesem Artikel um Analysatoren handelt, die nach Fehlern im Code suchen.  Es gibt eine andere Klasse von Analysatoren - sie √ºberpr√ºfen den Schreibstil des Codes, die zyklomatische Komplexit√§t, die Methodengr√∂√üen, die Zeilenl√§ngen usw. Wir betrachten solche Analysatoren hier nicht. <br><br>  Obwohl nicht alles, was die von uns in Betracht gezogenen Analyseger√§te finden, genau ein Fehler ist.  Aus Versehen meine ich den Code, den Fatal in der Produktion erstellt.  Sehr oft ist es wahrscheinlicher, dass Analysatoren eine Ungenauigkeit feststellen.  Beispielsweise kann in PHPDoc ein falscher Parametertyp angegeben werden.  Diese Ungenauigkeit wirkt sich nicht auf den Betrieb des Codes aus, aber anschlie√üend entwickelt sich der Code weiter - ein anderer Programmierer kann einen Fehler machen. <br><br><h1>  Bestehende PHP-Code-Analysatoren </h1><br>  Es gibt drei beliebte PHP-Code-Analysatoren: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHPStan</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Psalm</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phan</a> . <br></li></ol><br>  Und da ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Exakat</a> , das wir nicht ausprobiert haben. <br><br>  Auf der Benutzerseite sind alle drei Analysatoren gleich: Sie installieren sie (h√∂chstwahrscheinlich √ºber Composer) und konfigurieren sie. Anschlie√üend k√∂nnen Sie die Analyse des gesamten Projekts oder der gesamten Dateigruppe starten.  In der Regel kann der Analysator die Ergebnisse in der Konsole sch√∂n anzeigen.  Sie k√∂nnen die Ergebnisse auch im JSON-Format ausgeben und in CI verwenden. <br><br>  Alle drei Projekte entwickeln sich jetzt aktiv weiter.  Ihre Betreuer reagieren sehr aktiv auf Probleme mit GitHub.  Oft reagieren sie am ersten Tag nach dem Erstellen eines Tickets zumindest darauf (kommentieren oder setzen Sie ein Tag wie Bug / Enhancement).  Viele der gefundenen Fehler wurden innerhalb weniger Tage behoben.  Besonders gut gef√§llt mir aber, dass Projektbetreuer aktiv miteinander kommunizieren, Fehler untereinander melden und Pull-Anfragen senden. <br><br>  Wir haben alle drei Analyseger√§te implementiert und eingesetzt.  Jeder hat seine eigenen Nuancen, seine eigenen Fehler.  Die gleichzeitige Verwendung von drei Analysatoren erleichtert jedoch das Verst√§ndnis, wo das eigentliche Problem liegt und wo das falsch positive ist. <br><br><h2>  Was Analysatoren k√∂nnen </h2><br>  Analysatoren haben viele gemeinsame Funktionen. Wir werden uns also zun√§chst ansehen, was sie alle k√∂nnen, und dann zu den Funktionen der einzelnen Funktionen √ºbergehen. <br><br><h3>  Standardpr√ºfungen </h3><br>  Nat√ºrlich f√ºhren Analysatoren alle Standardcodepr√ºfungen durch, um Folgendes festzustellen: <br><br><ul><li>  Der Code enth√§lt keine Syntaxfehler. <br></li><li>  Alle Klassen, Methoden, Funktionen und Konstanten existieren. <br></li><li>  Variablen existieren; <br></li><li>  In PHPDoc sind die Hinweise wahr. <br></li></ul><br>  Au√üerdem √ºberpr√ºfen Parser den Code auf nicht verwendete Argumente und Variablen.  Viele dieser Fehler f√ºhren zu echten Todesf√§llen im Code. <br><br>  Auf den ersten Blick scheint es, dass gute Programmierer solche Fehler nicht machen, aber manchmal haben wir es eilig, manchmal kopieren und einf√ºgen, manchmal sind wir einfach unaufmerksam.  In solchen F√§llen sparen diese √úberpr√ºfungen viel. <br><br><h3>  Datentyppr√ºfungen </h3><br>  Selbstverst√§ndlich f√ºhren statische Analyseger√§te auch Standardpr√ºfungen hinsichtlich der Datentypen durch.  Wenn in dem Code geschrieben ist, dass die Funktion beispielsweise int akzeptiert, pr√ºft der Analysator, ob es Stellen gibt, an denen ein Objekt an diese Funktion √ºbergeben wird.  Bei den meisten Analysatoren k√∂nnen Sie den Schweregrad des Tests konfigurieren und strict_types simulieren: Stellen Sie sicher, dass keine Zeichenfolgen oder Booleschen Werte an diese Funktion √ºbergeben werden. <br><br>  Neben Standardpr√ºfungen haben Analysatoren noch viel zu tun. <br><br>  <b>Unionstypen</b> <br><br>  Alle Analysatoren unterst√ºtzen das Konzept der Unionstypen.  Angenommen, Sie haben eine Funktion wie: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string|int|bool $yes_or_no */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($yes_or_no)</span></span></span><span class="hljs-function"> :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\is_bool($yes_or_no)) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $yes_or_no;     } <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> (is_numeric($yes_or_no)) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $yes_or_no &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strtoupper($yes_or_no) == <span class="hljs-string"><span class="hljs-string">'YES'</span></span>;     } }</code> </pre> <br>  Der Inhalt ist nicht sehr wichtig - der Typ des Eingabeparameters <code>string|int|bool</code> ist wichtig.  Das hei√üt, die Variable <code>$yes_or_no</code> ist entweder eine Zeichenfolge oder eine Ganzzahl oder ein <code>Boolean</code> <code>$yes_or_no</code> . <br><br>  Mit PHP kann diese Art von Funktionsparameter nicht beschrieben werden.  In PHPDoc ist dies jedoch m√∂glich, und viele Editoren (wie PHPStorm) verstehen es. <br><br>  In statischen Analysatoren wird dieser Typ als <b>Vereinigungstyp bezeichnet</b> , und sie k√∂nnen solche Datentypen sehr gut √ºberpr√ºfen.  Wenn wir zum Beispiel die obige Funktion wie folgt geschrieben haben (ohne nach <code>Boolean</code> zu <code>Boolean</code> ): <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string|int|bool $yes_or_no */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($yes_or_no)</span></span></span><span class="hljs-function"> :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_numeric($yes_or_no)) {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $yes_or_no &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strtoupper($yes_or_no) == <span class="hljs-string"><span class="hljs-string">'YES'</span></span>;    } }</code> </pre> <br>  Die Analysatoren w√ºrden sehen, dass entweder ein String oder ein Boolescher Wert zu strtoupper kommen und einen Fehler zur√ºckgeben k√∂nnten. Sie k√∂nnen keinen Booleschen Wert an strtoupper √ºbergeben. <br><br>  Diese Art der √úberpr√ºfung hilft Programmierern, Fehler oder Situationen, in denen eine Funktion keine Daten zur√ºckgeben kann, korrekt zu behandeln.  Wir schreiben oft Funktionen, die einige Daten oder <code>null</code> : <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// load()  null   \User $User = UserLoader::load($user_id); $User-&gt;getName();</span></span></code> </pre> <br>  Im Fall eines solchen Codes teilt Ihnen der Analysator mit, dass die Variable <code>$User</code> hier <code>null</code> und dieser Code zu schwerwiegenden Folgen f√ºhren kann. <br><br>  <b>Geben Sie false ein</b> <br><br>  In der PHP-Sprache selbst gibt es einige Funktionen, die entweder einen Wert oder einen falschen Wert zur√ºckgeben k√∂nnen.  Wenn wir eine solche Funktion schreiben w√ºrden, wie w√ºrden wir ihren Typ dokumentieren? <br><br><pre> <code class="php hljs">         <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> resource|bool */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fopen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{       ‚Ä¶ }</code> </pre> <br>  Formal scheint hier alles wahr zu sein: fopen gibt entweder resource oder <code>false</code> (was vom Typ <code>Boolean</code> ).  Wenn wir jedoch sagen, dass eine Funktion einen Datentyp zur√ºckgibt, bedeutet dies, dass sie einen <b>beliebigen</b> Wert aus einer Menge zur√ºckgeben kann, die zu diesem Datentyp geh√∂rt.  In unserem Beispiel bedeutet dies f√ºr den Analysator, dass <code>fopen()</code> <code>true</code> .  Und zum Beispiel im Fall eines solchen Codes: <br><br><pre> <code class="php hljs">$fp = fopen(<span class="hljs-string"><span class="hljs-string">'some.file'</span></span>,<span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($fp === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } fwrite($fp, <span class="hljs-string"><span class="hljs-string">"some string"</span></span>);</code> </pre> <br>  Die Analysatoren w√ºrden sich beschweren, dass <code>fwrite</code> die erste Parameterressource akzeptiert, und wir √ºbergeben <code>bool</code> (weil der Analysator <code>fwrite</code> , dass eine echte Option m√∂glich ist).  Aus diesem Grund verstehen alle Analysatoren einen solchen ‚Äûk√ºnstlichen‚Äú Datentyp als <code>false</code> , und in unserem Beispiel k√∂nnen wir <code>@return false|resource</code> schreiben.  PHPStorm versteht auch diese Typbeschreibung. <br><br>  <b>Array-Formen</b> <br><br>  Sehr oft werden Arrays in PHP als <code>record</code> verwendet - eine Struktur mit einer √ºbersichtlichen Liste von Feldern, wobei jedes Feld seinen eigenen Typ hat.  Nat√ºrlich verwenden viele Programmierer bereits Klassen daf√ºr.  Aber wir haben viel Legacy-Code in Badoo und Arrays werden dort aktiv verwendet.  Und es kommt auch vor, dass Programmierer zu faul sind, um eine separate Klasse f√ºr eine einmalige Struktur zu erstellen, und an solchen Stellen werden h√§ufig auch Arrays verwendet. <br><br>  Das Problem bei solchen Arrays besteht darin, dass der Code keine eindeutige Beschreibung dieser Struktur (eine Liste der Felder und ihrer Typen) enth√§lt.  Programmierer k√∂nnen bei der Arbeit mit einer solchen Struktur Fehler machen: Vergessen Sie die erforderlichen Felder oder f√ºgen Sie "linke" Tasten hinzu, was den Code weiter verwirrt. <br><br>  Mit Analysatoren k√∂nnen Sie eine Beschreibung solcher Strukturen eingeben: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array{scheme:string,host:string,path:string} $parsed_url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $parsed_url)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  In diesem Beispiel haben wir ein Array mit drei Zeichenfolgenfeldern beschrieben: <code>scheme, host</code> und <code>path</code> .  Wenn wir uns innerhalb der Funktion einem anderen Feld zuwenden, zeigt der Analysator einen Fehler an. <br><br>  Wenn Sie die Typen nicht beschreiben, versuchen die Analysatoren, die Struktur des Arrays zu ‚Äûerraten‚Äú, aber wie die Praxis zeigt, sind sie mit unserem Code nicht wirklich erfolgreich.  :) :) <br><br>  Dieser Ansatz hat einen Nachteil.  Angenommen, Sie haben eine Struktur, die im Code aktiv verwendet wird.  Sie k√∂nnen einen Pseudotyp nicht an einer Stelle deklarieren und dann √ºberall verwenden.  Sie m√ºssen PHPDoc mit der Beschreibung des Arrays √ºberall im Code registrieren, was sehr unpraktisch ist, insbesondere wenn das Array viele Felder enth√§lt.  Es wird auch problematisch sein, diesen Typ sp√§ter zu bearbeiten (Felder hinzuf√ºgen und entfernen). <br><br>  <b>Beschreibung der Array-Schl√ºsseltypen</b> <br><br>  In PHP k√∂nnen Array-Schl√ºssel Ganzzahlen und Zeichenfolgen sein.  Typen k√∂nnen manchmal f√ºr die statische Analyse wichtig sein (und auch f√ºr Programmierer).  Mit statischen Analysatoren k√∂nnen Sie Array-Schl√ºssel in PHPDoc beschreiben: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;int, \User&gt; $users */</span></span> $users = UserLoaders::loadUsers($user_ids);</code> </pre> <br>  In diesem Beispiel haben wir mit PHPDoc einen Hinweis hinzugef√ºgt, dass die Schl√ºssel im Array <code>$users</code> ganzzahlige Ints und die Werte Objekte der Klasse <code>\User</code> .  Wir k√∂nnten den Typ als \ User [] beschreiben.  Dies w√ºrde dem Analysator mitteilen, dass sich Objekte in der Klasse <code>\User</code> im Array befinden, aber nichts √ºber den Schl√ºsseltyp aussagen. <br><br>  PHPStorm unterst√ºtzt dieses Format zur Beschreibung von Arrays ab Version 2018.3. <br><br>  <b>Ihr Namespace in PHPDoc</b> <br><br>  PHPStorm (und andere Editoren) und statische Analysatoren k√∂nnen PHPDoc unterschiedlich verstehen.  Analysatoren unterst√ºtzen beispielsweise dieses Format: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array{scheme:string,host:string,path:string} $parsed_url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($parsed_url)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  Aber PHPStorm versteht ihn nicht.  Aber wir k√∂nnen so schreiben: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array $parsed_url * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@phan</span></span></span><span class="hljs-comment">-param array{scheme:string,host:string,path:string} $parsed_url * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param array{scheme:string,host:string,path:string} $parsed_url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($parsed_url)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  In diesem Fall sind sowohl Analysatoren als auch PHPStorm zufrieden.  PHPStorm verwendet <code>@param</code> und Analysatoren verwenden ihre eigenen PHPDoc-Tags. <br><br><h3>  PHP-Funktionspr√ºfungen </h3><br>  Diese Art von Test l√§sst sich am besten anhand eines Beispiels veranschaulichen. <br><br>  Wissen wir alle, was die Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">explode () zur√ºckgeben</a> kann?  Wenn Sie sich die Dokumentation ansehen, scheint sie ein Array zur√ºckzugeben.  Wenn Sie es jedoch genauer untersuchen, werden wir feststellen, dass es auch falsch zur√ºckgeben kann.  Tats√§chlich kann es sowohl null als auch einen Fehler zur√ºckgeben, wenn Sie die falschen Typen √ºbergeben. Die √úbergabe des falschen Werts mit dem falschen Datentyp ist jedoch bereits ein Fehler, sodass diese Option f√ºr uns derzeit nicht interessant ist. <br><br>  Wenn aus Sicht des Analysators eine Funktion false oder ein Array zur√ºckgeben kann, sollte der Code h√∂chstwahrscheinlich auf false pr√ºfen.  Die Funktion explode () gibt jedoch nur dann false zur√ºck, wenn das Trennzeichen (erster Parameter) einer leeren Zeichenfolge entspricht.  Oft wird es explizit in den Code geschrieben, und Analysatoren k√∂nnen √ºberpr√ºfen, ob es nicht leer ist. Dies bedeutet, dass an dieser Stelle die Funktion explode () ein Array genau zur√ºckgibt und keine falsche Pr√ºfung erforderlich ist. <br><br>  PHP hat so einige Funktionen.  Analysatoren f√ºgen nach und nach geeignete √úberpr√ºfungen hinzu oder verbessern sie, und wir Programmierer m√ºssen uns nicht mehr an all diese Funktionen erinnern. <br><br>  Wir wenden uns der Beschreibung spezifischer Analysatoren zu. <br><br><h2>  PHPStan </h2><br>  Entwicklung eines bestimmten Ond≈ôej Mirtes aus der Tschechischen Republik.  Aktiv entwickelt seit Ende 2016. <br><br>  Um PHPStan verwenden zu k√∂nnen, ben√∂tigen Sie: <br><br><ol><li>  Installieren Sie es (der einfachste Weg, dies zu tun, ist √ºber Composer). <br></li><li>  (optional) Konfigurieren. <br></li><li>  F√ºhren Sie im einfachsten Fall einfach Folgendes aus: <br></li></ol><br> <code>vendor/bin/phpstan analyse ./src</code> <br> <br>  (Anstelle von <code>src</code> m√∂glicherweise eine Liste bestimmter Dateien, die Sie √ºberpr√ºfen m√∂chten.) <br><br>  PHPStan liest den PHP-Code aus den √ºbertragenen Dateien.  Wenn er auf unbekannte Klassen st√∂√üt, wird er versuchen, diese mit Autoload und durch Reflexion zu laden, um ihre Schnittstelle zu verstehen.  Sie k√∂nnen auch den Pfad zur <code>Bootstrap</code> Datei √ºbertragen, √ºber die Sie das automatische Laden konfigurieren, und einige zus√§tzliche Dateien anh√§ngen, um die PHPStan-Analyse zu vereinfachen. <br><br>  Hauptmerkmale: <br><br><ol><li>  Es ist m√∂glich, nicht die gesamte Codebasis zu analysieren, sondern nur einen Teil - unbekannte Klassen PHPStan versucht, das Autoload zu laden. <br></li><li>  Wenn sich einige Ihrer Klassen aus irgendeinem Grund nicht im Autoload befinden, kann PHPStan sie nicht finden und gibt einen Fehler aus. <br></li><li>  Wenn Sie √ºber <code>__call / __get / __set</code> aktiv magische Methoden <code>__call / __get / __set</code> , k√∂nnen Sie ein Plugin f√ºr PHPStan schreiben.  Es gibt bereits Plugins f√ºr Symfony, Doctrine, Laravel, Mockery usw. <br></li><li>  Tats√§chlich f√ºhrt PHPStan das automatische Laden nicht nur f√ºr unbekannte Klassen durch, sondern im Allgemeinen f√ºr alle.  Wir haben viel alten Code geschrieben, bevor anonyme Klassen angezeigt werden, wenn wir eine Klasse in einer Datei erstellen, sie dann sofort instanziieren und m√∂glicherweise sogar einige Methoden aufrufen.  Das automatische Laden (Einschlie√üen) solcher Dateien f√ºhrt zu Fehlern, da der Code in einer normalen Umgebung nicht ausgef√ºhrt wird. <br></li><li>  Konfigurationen im Neonformat (ich habe nie geh√∂rt, dass ein solches Format woanders verwendet wurde). <br></li><li>  Es gibt keine Unterst√ºtzung f√ºr ihre PHPDoc-Tags wie <code>@phpstan-var, @phpstan-return</code> usw. <br></li></ol><br>  Ein weiteres Merkmal ist, dass Fehler Text enthalten, aber keinen Typ haben.  Das hei√üt, der Fehlertext wird an Sie zur√ºckgegeben, zum Beispiel: <br><br><ul><li> <code>Method \SomeClass::getAge() should return int but returns int|null</code> <br> </li><li> <code>Method \SomeOtherClass::getName() should return string but returns string|null</code> <br> </li></ul><br>  In diesem Beispiel handelt es sich bei beiden Fehlern im Wesentlichen um dasselbe: Die Methode muss einen Typ zur√ºckgeben, in Wirklichkeit jedoch den anderen.  Die Texte der Fehler sind jedoch unterschiedlich, wenn auch √§hnlich.  Wenn Sie Fehler in PHPStan herausfiltern m√∂chten, tun Sie dies daher nur durch regul√§re Ausdr√ºcke. <br><br>  Zum Vergleich haben Fehler in anderen Analysatoren einen Typ.  In Phan ist ein solcher Fehler beispielsweise vom Typ <code>PhanPossiblyNullTypeReturn</code> , und Sie k√∂nnen in der Konfiguration angeben, dass Sie nicht nach solchen Fehlern <code>PhanPossiblyNullTypeReturn</code> m√ºssen.  Mit der Art des Fehlers ist es beispielsweise auch m√∂glich, leicht Statistiken √ºber Fehler zu sammeln. <br><br>  Da wir keine Laravel-, Symfony-, Doctrine- und √§hnliche L√∂sungen verwenden und in unserem Code selten magische Methoden verwenden, stellte sich heraus, dass das Hauptmerkmal von PHPStan f√ºr uns nicht beansprucht wurde.  ; (Dar√ºber hinaus funktioniert die Analyse aufgrund der Tatsache, dass PHPStan <b>alle zu</b> pr√ºfenden Klassen enth√§lt, manchmal einfach nicht auf unserer Codebasis. <br><br>  PHPStan bleibt uns jedoch n√ºtzlich: <br><br><ul><li>  Wenn Sie mehrere Dateien √ºberpr√ºfen m√ºssen, ist PHPStan deutlich schneller als Phan und etwas (20-50%) schneller als Psalm. <br></li><li>  PHPStan-Berichte erleichtern das Auffinden von <code>false-positive</code> in anderen Analyseger√§ten.  Wenn der Code explizit <code>fatal</code> ist, wird er normalerweise von allen Analysatoren (oder mindestens zwei der drei) angezeigt. <br></li></ul><br><br>  <b>Update:</b> <br>  Der Autor von PHPStan Ond≈ôej Mirtes las auch unseren Artikel und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sagte</a> uns, dass PhpStan wie Psalm eine Website mit einer ‚ÄûSandbox‚Äú hat: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://phpstan.org/</a> .  Dies ist sehr praktisch f√ºr Fehlerberichte: Sie reproduzieren den Fehler in und geben einen Link in GitHub an. <br><br><h2>  Phan </h2><br>  Entwickelt von Etsy.  Erste Commits von Rasmus Lerdorf. <br><br>  Von den drei fraglichen ist Phan der einzige <b>echte</b> statische Analysator (in dem Sinne, dass er keine Ihrer Dateien ausf√ºhrt - er analysiert Ihre <b>gesamte</b> Codebasis und analysiert dann, was Sie sagen).  Selbst f√ºr die Analyse mehrerer Dateien in unserer Codebasis werden etwa 6 GB RAM ben√∂tigt, und dieser Vorgang dauert vier bis f√ºnf Minuten.  Dann dauert eine vollst√§ndige Analyse der gesamten Codebasis etwa sechs bis sieben Minuten.  Zum Vergleich analysiert Psalm es in wenigen zehn Minuten.  Und mit PHPStan konnten wir √ºberhaupt keine vollst√§ndige Analyse der gesamten Codebasis erzielen, da diese Include-Klassen enth√§lt. <br><br>  Die Phan-Erfahrung ist zweifach.  Einerseits ist es der qualitativ hochwertigste und stabilste Analysator, es findet viel und es gibt weniger Probleme damit, wenn es notwendig ist, die gesamte Codebasis zu analysieren.  Auf der anderen Seite hat es zwei unangenehme Eigenschaften. <br><br>  Unter der Haube benutzt Phan die PHP-Ast-Erweiterung.  Dies ist anscheinend einer der Gr√ºnde daf√ºr, dass die Analyse der gesamten Codebasis relativ schnell ist.  Aber php-ast zeigt die interne Darstellung des AST-Baums, wie er in PHP selbst erscheint.  In PHP selbst enth√§lt der AST-Baum keine Informationen zu Kommentaren, die sich innerhalb der Funktion befinden.  Das hei√üt, wenn Sie etwas geschrieben haben wie: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $type */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($type)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \My\Object $obj **/</span></span>   $obj = MyFactory::createObjectByType($type);   ‚Ä¶ }</code> </pre> <br>  Dann gibt es innerhalb des AST-Baums Informationen √ºber das externe PHPDoc f√ºr die Funktion <code>doSomething()</code> , aber es gibt keine PHPDoc-Hilfeinformationen innerhalb der Funktion.  Und dementsprechend wei√ü Phan auch nichts √ºber sie.  Dies ist die h√§ufigste Ursache f√ºr <code>false-positive</code> Ergebnisse in Phan.  Es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einige Empfehlungen</a> zum Einf√ºgen von QuickInfos (√ºber Zeichenfolgen oder Assert-s), die sich jedoch leider stark von denen unserer Programmierer unterscheiden.  Teilweise haben wir dieses Problem gel√∂st, indem wir ein Plugin f√ºr Phan geschrieben haben.  Die Plugins werden jedoch weiter unten erl√§utert. <br><br>  Das zweite unangenehme Merkmal ist, dass Phan die Eigenschaften von Objekten nicht gut analysiert.  Hier ist ein Beispiel: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string|null */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $a; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $a = null)</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a = $a; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a &amp;&amp; strpos(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a, <span class="hljs-string"><span class="hljs-string">'a'</span></span>) === <span class="hljs-number"><span class="hljs-number">0</span></span>) {          var_dump(<span class="hljs-string"><span class="hljs-string">"test1"</span></span>);      } } }</code> </pre> <br>  In diesem Beispiel sagt Ihnen Phan, dass Sie in strpos null √ºbergeben k√∂nnen.  Weitere Informationen zu diesem Problem finden Sie hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/phan/phan/issues/204</a> . <br><br>  Zusammenfassung  Trotz einiger Schwierigkeiten ist Phan eine sehr coole und n√ºtzliche Entwicklung.  Zus√§tzlich zu diesen beiden Arten von <code>false-positive</code> er fast keine Fehler oder Fehler, sondern auf einem wirklich komplexen Code.  Uns hat auch gefallen, dass sich die Konfiguration in einer PHP-Datei befindet - dies gibt etwas Flexibilit√§t.  Phan wei√ü auch, wie man als Sprachserver arbeitet, aber wir haben diese Funktion nicht verwendet, da PHPStorm f√ºr uns ausreicht. <br><br><h3>  Plugins </h3><br>  Phan hat eine gut entwickelte Plugin-Entwicklungs-API.  Sie k√∂nnen Ihre eigenen Pr√ºfungen hinzuf√ºgen und die Typinferenz f√ºr Ihren Code verbessern.  Diese API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">enth√§lt Dokumentation</a> , aber es ist besonders cool, dass bereits funktionierende Plugins vorhanden sind, die als Beispiele verwendet werden k√∂nnen. <br><br>  Wir haben es geschafft, zwei Plugins zu schreiben.  Die erste war f√ºr eine einmalige √úberpr√ºfung vorgesehen.  Wir wollten bewerten, wie bereit unser Code f√ºr PHP 7.3 ist (insbesondere um herauszufinden, ob er Konstanten ohne <code>case-insensitive</code> ).  Wir waren uns fast sicher, dass es keine solchen Konstanten gab, aber in 12 Jahren konnte alles passieren - es sollte √ºberpr√ºft werden.  Und wir haben ein Plugin f√ºr Phan geschrieben, das schw√∂ren w√ºrde, wenn der dritte Parameter in <code>define()</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Das Plugin ist sehr einfach</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span>(strict_types=<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">AST</span></span>\<span class="hljs-title"><span class="hljs-title">ContextNode</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">CodeBase</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">Language</span></span>\<span class="hljs-title"><span class="hljs-title">Context</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">Language</span></span>\<span class="hljs-title"><span class="hljs-title">Element</span></span>\<span class="hljs-title"><span class="hljs-title">Func</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">PluginV2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">PluginV2</span></span>\<span class="hljs-title"><span class="hljs-title">AnalyzeFunctionCallCapability</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">ast</span></span>\<span class="hljs-title"><span class="hljs-title">Node</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefineThirdParamTrue</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PluginV2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyzeFunctionCallCapability</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAnalyzeFunctionCallClosures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeBase $code_base)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{   $define_callback = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       CodeBase $code_base,                  Context $context,                  Func $function,                  array $args    )</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\count($args) &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;      }       <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emitIssue(       $code_base,      $context,      <span class="hljs-string"><span class="hljs-string">'PhanDefineCaseInsensitiv'</span></span>,      <span class="hljs-string"><span class="hljs-string">'Define with 3 arguments'</span></span>,      []      );    };    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [          <span class="hljs-string"><span class="hljs-string">'define'</span></span> =&gt; $define_callback,    ]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefineThirdParamTrue();</code> </pre> <br></div></div><br><br>  In Phan k√∂nnen verschiedene Plugins an verschiedene Ereignisse geh√§ngt werden.  Insbesondere Plugins mit der <code>AnalyzeFunctionCallCapability</code> Schnittstelle <code>AnalyzeFunctionCallCapability</code> ausgel√∂st, wenn ein Funktionsaufruf analysiert wird.  In diesem Plugin haben wir es so gemacht, dass beim Aufrufen der Funktion <code>define()</code> unsere anonyme Funktion aufgerufen wird, die √ºberpr√ºft, ob <code>define()</code> nicht mehr als zwei Argumente enth√§lt.  Dann haben wir gerade Phan gestartet, alle Stellen gefunden, an denen <code>define()</code> mit drei Argumenten aufgerufen wurde, und sichergestellt, dass wir keine <code>case-insensitive-</code> haben, <code>case-insensitive-</code> die <code>case-insensitive-</code> nicht <code>case-insensitive-</code> . <br><br>  Mit dem Plugin haben wir auch das <code>false-positive</code> Problem teilweise gel√∂st, wenn Phan keine PHPDoc-Hinweise im Code sieht. <br><br>  Wir verwenden h√§ufig Factory-Methoden, die eine Konstante als Eingabe verwenden und daraus ein Objekt erstellen.  Oft sieht der Code ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Objects\Controllers\My $Object */</span></span> $Object = \Objects\Factory::create(\Objects\Config::MY_CONTROLLER);</code> </pre> <br>  Phan versteht solche PHPDoc-Hinweise nicht, aber in diesem Code kann die Objektklasse aus dem Namen der Konstante abgerufen werden, die an die <code>create()</code> -Methode √ºbergeben wird.  Mit Phan k√∂nnen Sie ein Plugin schreiben, das ausgel√∂st wird, wenn der R√ºckgabewert einer Funktion analysiert wird.  Mit diesem Plugin k√∂nnen Sie dem Analysator mitteilen, welchen Typ die Funktion in diesem Aufruf zur√ºckgibt. <br><br>  Ein Beispiel f√ºr dieses Plugin ist komplexer.  Es gibt jedoch ein gutes Beispiel f√ºr den Phan-Code in der <code>vendor/phan/phan/src/Phan/Plugin/Internal/DependentReturnTypeOverridePlugin.php.</code> <br><br>  Insgesamt sind wir mit dem Phan-Analyseger√§t sehr zufrieden.  Die oben aufgef√ºhrten <code>false-positive</code> Ergebnisse haben wir teilweise (in einfachen F√§llen mit einfachem Code) zum Filtern gelernt.  Danach wurde Phan ein fast Referenzanalysator.  Die Notwendigkeit, die gesamte Codebasis (Zeit und viel Speicher) sofort zu analysieren, erschwert jedoch immer noch den Implementierungsprozess. <br><br><h2>  Psalm </h2><br>  Psalm ist eine Entwicklung von Vimeo.  Ehrlich gesagt wusste ich nicht einmal, dass Vimeo PHP verwendet, bis ich Psalm sah. <br><br>  Dieser Analysator ist der j√ºngste unserer drei.  Als ich die Nachricht las, dass Vimeo Psalm ver√∂ffentlicht hat, war ich ratlos: ‚ÄûWarum in Psalm investieren, wenn Sie bereits Phan und PHPStan haben?‚Äú  Es stellte sich jedoch heraus, dass der Psalm seine eigenen n√ºtzlichen Eigenschaften hat. <br><br>  Psalm trat in die Fu√üstapfen von PHPStan: Sie k√∂nnen ihm auch eine Liste von Dateien zur Analyse geben, die analysiert werden und Klassen, die nicht gefunden wurden, mit einem automatischen Laden verbinden.  Gleichzeitig werden <b>nur</b> Klassen verbunden, die nicht gefunden wurden, und die Dateien, die wir zur Analyse angefordert haben, werden nicht ber√ºcksichtigt (dies unterscheidet sich von PHPStan).  Die Konfiguration wird in einer XML-Datei gespeichert (f√ºr uns ist dies eher ein Minus, aber nicht sehr kritisch). <br><br>  Psalm hat eine Sandbox- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Site,</a> auf der Sie PHP-Code schreiben und analysieren k√∂nnen.  Dies ist sehr praktisch f√ºr Fehlerberichte: Sie reproduzieren den Fehler auf der Site und geben den Link in GitHub an.  √úbrigens beschreibt die Site alle m√∂glichen Arten von Fehlern.  Zum Vergleich: In PHPStan gibt es keine Typen, und in Phan gibt es keine, aber es konnte keine einzige Liste gefunden werden. <br><br>  Uns hat auch gefallen, dass Psalm bei der Ausgabe von Fehlern sofort die Codezeilen anzeigt, in denen sie gefunden wurden.  Dies vereinfacht das Lesen von Berichten <b>erheblich</b> . <br><br>  Das vielleicht interessanteste Merkmal von Psalm sind jedoch die benutzerdefinierten PHPDoc-Tags, mit denen Sie die Analyse (insbesondere die Definition von Typen) verbessern k√∂nnen.  Wir listen die interessantesten von ihnen auf. <br><br><h3>  @ psalm-ignore-nullable-return </h3><br>  Es kommt vor, dass eine Methode formal <code>null</code> , aber der Code ist bereits so organisiert, dass dies niemals geschieht.  In diesem Fall ist es sehr praktisch, dass Sie der Methode / Funktion einen solchen PHPDoc-Hinweis hinzuf√ºgen k√∂nnen - und Psalm wird ber√ºcksichtigen, dass <code>null</code> nicht zur√ºckgegeben wird. <br><br>  Ein √§hnlicher Hinweis existiert f√ºr false: <code>@psalm-ignore-falsable-return</code> . <br><br><h3>  Arten zum Schlie√üen </h3><br>  Wenn Sie sich jemals f√ºr funktionale Programmierung interessiert haben, haben Sie vielleicht bemerkt, dass eine Funktion h√§ufig eine andere Funktion zur√ºckgeben oder eine Funktion als Parameter √ºbernehmen kann.  In PHP kann dieser Stil f√ºr Ihre Kollegen sehr verwirrend sein, und einer der Gr√ºnde ist, dass PHP keine Standards f√ºr die Dokumentation solcher Funktionen hat.  Zum Beispiel: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $ar, \Closure $func)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  Wie kann ein Programmierer verstehen, welche Schnittstelle die Funktion im zweiten Parameter hat?  Welche Parameter sollte es nehmen?  Was soll sie zur√ºckgeben? <br><br>  Psalm unterst√ºtzt die Syntax zur Beschreibung von Funktionen in PHPDoc: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array $ar * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param Closure(int):bool $func */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $ar, \Closure $func)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  Mit einer solchen Beschreibung ist bereits klar, dass Sie eine anonyme Funktion an <code>my_filter</code> , die ein int akzeptiert und bool <code>my_filter</code> .  Und nat√ºrlich wird Psalm √ºberpr√ºfen, ob Sie genau eine solche Funktion in Ihrem Code √ºbergeben haben. <br><br><h3>  Aufz√§hlungen </h3><br>  Angenommen, Sie haben eine Funktion, die einen Zeichenfolgenparameter akzeptiert, und Sie k√∂nnen dort nur bestimmte Zeichenfolgen √ºbergeben: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $yes_or_no)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{     $yes_or_no = strtolower($yes_or_no)     <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>($yes_or_no)  {           <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'yes'</span></span>:                 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;          <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'no'</span></span>:                 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;           <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>:                <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \InvalidArgumentException(‚Ä¶);     } }</code> </pre><br>  Mit Psalm k√∂nnen Sie den Parameter dieser Funktion folgenderma√üen beschreiben: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param 'Yes'|'No' $yes_or_no **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $yes_or_no)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  In diesem Fall versucht Psalm zu verstehen, welche spezifischen Werte an diese Funktion √ºbergeben werden, und gibt Fehler aus, wenn andere Werte als <code>Yes</code> und <code>No</code> vorhanden sind <code>No</code> <br><br>  Lesen Sie hier mehr √ºber enum. <br><br><h3>  Geben Sie Aliase ein </h3><br>  In der Beschreibung der <code>array shapes</code> ich bereits erw√§hnt, dass Analysatoren zwar die Beschreibung der Struktur von Arrays erm√∂glichen, die Verwendung jedoch nicht sehr praktisch ist, da die Beschreibung des Arrays an verschiedenen Stellen kopiert werden muss.  Die richtige L√∂sung besteht nat√ºrlich darin, Klassen anstelle von Arrays zu verwenden.  Bei langj√§hrigem Erbe ist dies jedoch nicht immer m√∂glich. <br><br>   ,      ,    ,    : <br><br><ul><li> ; <br></li><li> closure; <br></li><li> union- (,       ); <br></li><li> enum. <br></li></ul><br>   ,      ,    PHPDoc    , ,  .   Psalm      .    alias      PHPDoc   <code>alias</code> .  ,  :      PHP-.      . ,   Psalm. <br><br><h3> Generics aka templates </h3><br>     . ,     : <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $x; }</code> </pre> <br>     ?      ?   ? <br><br> , ,    , ‚Äî <code>mixed</code> ,             . <br><br>     <code>mixed</code> ‚Äî  .  ,            .    ,   <code>identity()</code>  /  ,    :     ,   .       -.  ,   : <br><br><pre> <code class="php hljs">$i = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// int $y = identity($i);</span></span></code> </pre> <br>       <code>(int)</code> ,  ,      <code>$y</code> ( <code>int</code> ). <br><br>       ?  Psalm     PHPDoc-: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@template</span></span></span><span class="hljs-comment"> T * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param T $x * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-return T */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ $return $x; }</code> </pre> <br>   templates   Psalm   ,  /     . <br><br>  Psalm      templates: <br><br> ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vendor/vimeo/psalm/src/Psalm/Stubs/CoreGenericFunctions.php</a> ; <br> ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vendor/vimeo/psalm/src/Psalm/Stubs/CoreGenericClasses.php</a> . <br><br>      Phan,      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/phan/phan/wiki/Generic-Types</a> . <br><br>  ,  Psalm  . ,    ¬´¬ª              .   ,  Psalm    ,    ,       Phan  PHPStan.     . <br><br><h2>    PHPStorm </h2><br>      :          ,   .    ,      ,    . <br><br>             .     Phan,    language server.    PHPStorm, ,   . <br><br> ,  ,  PHPStorm     ( ),       .         ‚Äî Php Inspections (EA Extended).     ‚Äî   ,   ,         .  ,      . ,      scopes     -   scopes. <br><br>     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">deep-assoc-completion</a> .         . <br><br><h1>    Badoo </h1><br>     ? <br><br>       ,         . <br><br>     ,   .  ,     ,    <code>git diff</code>      / ,       ,     () .       ,    . <br><br> ,     :      -    <code>git diff</code> .     .             ,    .         . , ,  ,          ,    . <br><br>     ,     ,       : <br><br><img src="https://habrastorage.org/webt/zj/e2/rt/zje2rtxhy1nkwsamex4umguv4yw.png"><br><br>           <code>false-positive</code> . ,  ,   Phan        ,   ,     . ,   -    Phan      ,     ,      . <br><br><h1>     QA </h1><br>        : <br><br><ul><li>     ; <br></li><li>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">code review</a> ; <br></li><li>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . <br></li></ul><br><br>   ‚Äî ,  ,      ,     .      : <br><br><ul><li>    100%  (   ,        ); <br></li><li>     ,      code review; <br></li><li>      ,        . <br></li></ul><br>         <code>strict types</code> .          ,  <code>strict types</code> ,    : <br><br><ul><li>     ,     <code>strict types</code> ,   ; <br></li><li>     ,     (,    ,        ); <br></li><li>        ,    PHP (,   <code>union types</code> ,    PHP); <br></li><li>       <code>strict types</code> ,        . <br></li></ul><br><h1>  :   </h1><br>  ,        .   . <br><br> -,     , ,      -  ,    . <br><br> -,     ,     ‚Äî  , ,     PHPDoc.        ‚Äî   . <br><br> -,     .  ,     -  ,            PHPDoc.  :) :) <br><br>  ,  ,     .    ,      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426605/">https://habr.com/ru/post/de426605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426591/index.html">Haltungsmeister: Bleib am Leben</a></li>
<li><a href="../de426593/index.html">DJI Phantom 4 RTK: Kartierung der n√§chsten Generation</a></li>
<li><a href="../de426595/index.html">Richard Hamming "Nicht existierendes Kapitel": Wie wir wissen, was wir wissen (1-10 Minuten von 40)</a></li>
<li><a href="../de426597/index.html">Madrobots auf der IFA 2018. Teil 2 - Intelligente Projektoren: Von XGIMI zu Anker</a></li>
<li><a href="../de426603/index.html">Spinnspirale: Mathematik und Halluzinationen</a></li>
<li><a href="../de426609/index.html">Office 365 und andere MS-Produkte f√ºgen Sprach-E / A f√ºr Legastheniker hinzu</a></li>
<li><a href="../de426611/index.html">Integration in SAP ERP am Beispiel von Django-Python am Beispiel des oData (Rest) -Protokolls</a></li>
<li><a href="../de426613/index.html">Lassen Sie den 3D-Drucker nicht faul sein</a></li>
<li><a href="../de426615/index.html">Schreiben einer CLI auf NodeJS</a></li>
<li><a href="../de426617/index.html">F√ºhrerschein zum Autofahren oder warum Anwendungen Single-Activity sein sollten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>