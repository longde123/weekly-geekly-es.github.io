<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíó üçÜ üö∑ So teilen Sie Architektur und Implementierung ohne Streit üë©üèª üëêüèΩ üì©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Erstellen eines neuen Systems ist ein mehrstufiger Prozess: Ausarbeitung des Konzepts und des Designs, Architekturdesign, Implementierung, Testen,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So teilen Sie Architektur und Implementierung ohne Streit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435386/"><p>  Das Erstellen eines neuen Systems ist ein mehrstufiger Prozess: Ausarbeitung des Konzepts und des Designs, Architekturdesign, Implementierung, Testen, Freigabe.  Architekturdesign und -implementierung sind die Phasen, mit denen sich Entwickler haupts√§chlich befassen. </p><br><p>  Die meisten Entwickler besch√§ftigen sich gerne mit Architektur und √ºberlegen, wie das System oder ein Teil davon von Grund auf neu angeordnet wird.  Wenn jemand die Architektur des Systems durchdacht und implementiert hat, gibt es keine Probleme mit der Motivation: Der Programmierer wird durch die Umsetzung seiner Ideen zufrieden sein.  Aber wenn ein Gedanke an Architektur und ein anderer an der Umsetzung beteiligt sein wird, dann kann letzterer eine nat√ºrliche Emp√∂rung haben: Sie haben alles f√ºr mich √ºberlegt, aber kann ich einfach das tun, was geschrieben steht? </p><br><p><img src="https://habrastorage.org/webt/vj/ii/ox/vjiioxfop6iqofh1irlgn_kuueo.jpeg"></p><br><p>  In diesem Artikel wird erl√§utert, wie solche Situationen vermieden werden k√∂nnen, warum die Implementierung nicht weniger interessant sein kann als die Ausarbeitung der Architektur und manchmal auch mehr. </p><a name="habracut"></a><br><h1 id="vvedenie">  Einf√ºhrung </h1><br><p>  Eine durchdachte Architektur kann als Grundlage f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausfallaufgaben verwendet werden</a> : Die Implementierung jeder ausreichend separaten Komponente wird zu einer separaten Unteraufgabe. </p><br><p>  Wenn es beispielsweise eine Abfrageverarbeitungspipeline gibt, die im Stil von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pipes &amp; Filtern entworfen wurde</a> , sind die Unteraufgaben die Implementierung einzelner Verarbeitungsschritte (jeder Schritt hat seine eigene Unteraufgabe) und einer anderen Unteraufgabe, um alle Schritte miteinander zu verbinden. </p><br><p>  Eine durchdachte Architektur und die Aufteilung in Unteraufgaben geben zwar eine allgemeine Vorstellung davon, wie ein System erstellt und die Bewertung der Arbeitskosten erm√∂glicht wird, reichen jedoch nicht aus, um den Plan umzusetzen.  In der Beschreibung der Unteraufgabe wird angegeben, was die Komponente tun soll. Sie enth√§lt m√∂glicherweise Anforderungen an Geschwindigkeit und Speicherverbrauch, enth√§lt jedoch keine umfassenden Anweisungen dazu. </p><br><p>  Tatsache ist, dass es viele Optionen gibt, um eine Komponente herzustellen, die die angegebenen Anforderungen erf√ºllt.  Viel h√§ngt davon ab, wie es implementiert wird: Codeflexibilit√§t, Erweiterbarkeit, einfache Unterst√ºtzung usw.  Wir kommen dem Konzept <em>des Code-Designs nahe</em> . </p><br><h1 id="koncepciya-dizayna-koda">  Code-Design-Konzept </h1><br><p>  Manchmal wird Code-Design als Architektur oder Code-Organisation bezeichnet, manchmal sogar nur als Architektur.  Ich halte mich an den Begriff <em>Code-Design,</em> weil er sich von der Systemarchitektur abhebt und eine klare Linie zwischen ihnen zieht.  Um genauer zu sein, betrachten Sie ein Beispiel. </p><br><p>  Nehmen wir an, wir entwickeln das Backend einer Website, die immer beliebter wird.  Die Anzahl der Server hat bereits mehrere zehn √ºberschritten, das Publikum w√§chst und wir beschlie√üen, Analysen zum Benutzerverhalten auf der Website zu sammeln: Beliebtheit von Besuchsseiten, H√§ufigkeit der Nutzung von Funktionen abh√§ngig vom Benutzerprofil usw. </p><br><p>  Es treten eine Reihe von architektonischen und technologischen Problemen auf: Wo werden Metriken gespeichert, wie werden sie √ºber das Netzwerk √ºbertragen, was ist zu tun, wenn der Metrikspeicher nicht verf√ºgbar ist, wie der Backend-Dienst Metriken aufzeichnet usw.  Die Architektur muss nur diese Fragen beantworten, die Komponenten der L√∂sung bestimmen und Anforderungen f√ºr sie festlegen. </p><br><p>  Angenommen, wir haben eine Architektur entwickelt: Wir werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">InfluxDB</a> als Speicher verwenden, Metriken mithilfe von UDP f√ºr das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegraf</a> √ºber das Netzwerk √ºbertragen und die Nichtverf√ºgbarkeit des Speichers umgehen, um die Metriken in Kafka zu speichern, die auf mehreren Servern repliziert wurden.  Alle Metriken gehen den Weg Backend-Service -&gt; Telegraf -&gt; Kafka -&gt; InfluxDB.  Um die Metriken zu schreiben, hat das Backend beschlossen, ein Modul zu schreiben, das die Metrik√ºbertragungsfunktion in Telegraf mithilfe von UDP implementiert. </p><br><p>  Das Modul zum Aufzeichnen von Metriken ist eine separate Komponente des Systems. Das Schreiben ist eine separate Unteraufgabe, die dem Entwickler anvertraut werden kann.  Diese Unteraufgabe enth√§lt viele L√∂sungen und Fragen, die beantwortet werden m√ºssen: Metriken werden synchron oder asynchron gesendet.  Wie wird der gleichzeitige Zugriff auf mehrere Backend-Threads synchronisiert, welche Hauptklassen / Funktionen werden verwendet? </p><br><p>  Diese Fragen gehen √ºber die Beschreibung der L√∂sungsarchitektur hinaus, aber die Antworten darauf haben weitreichende Konsequenzen.  Wenn beispielsweise w√§hrend des Betriebs einer L√∂sung klar wird, dass der Technologie-Stack nicht optimal ist und Sie Telegraf durch eine alternative L√∂sung ersetzen m√ºssen, kann dies durch eine falsche Unterteilung des Moduls in Klassen nicht ohne Umschreiben des gesamten Moduls erfolgen.  Die Antworten auf diese Fragen liegen im <strong>Bereich des Code-Designs</strong> . </p><br><p>  <strong>Die Entwicklung des Code-Designs ist eine separate Entwurfsphase</strong> , die zwischen der Entwicklung der Systemarchitektur und der Codierung liegt.  Wenn Sie eine Grenze zwischen Architektur und Code-Design ziehen, k√∂nnen Sie ein System entwerfen, ohne alle Details zu ber√ºcksichtigen, und die Arbeitskosten in einer begrenzten Zeit bewerten.  Wenn Sie andererseits die Entwicklung des Code-Designs als separate Implementierungsphase hervorheben, k√∂nnen Sie die Qualit√§t der Systemimplementierung verbessern, die Kosten f√ºr weitere Verbesserungen senken und den Support vereinfachen. </p><br><p>  Die Notwendigkeit, das Code-Design in der Implementierungsphase vor dem Codieren zu √ºberdenken, <strong>macht die Implementierung interessant</strong> : Die Aufgaben beim Entwerfen eines Code-Designs k√∂nnen nicht weniger interessant sein als das Entwerfen eines gesamten Systems auf Architekturebene.  Diese Idee wurde von Brooks im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mythischen</a> Mannmonat zum Ausdruck gebracht. </p><br><p>  Nat√ºrlich ist es m√∂glicherweise nicht so einfach, eine Grenze zwischen Architektur und Code-Design zu ziehen. Schauen wir uns dieses Problem genauer an. </p><br><h1 id="granica-mezhdu-arhitekturoy-i-dizaynom-koda">  Die Grenze zwischen Architektur und Code-Design </h1><br><p>  Ideologisch gesehen befinden sich Architektur und Code-Design auf verschiedenen Designebenen: Architektur wird in der Anfangsphase durchdacht, wenn wenig Sicherheit besteht, und das Nachdenken √ºber das Code-Design f√ºgt Details hinzu.  Dementsprechend werden sie zu unterschiedlichen Zeitpunkten ausgef√ºhrt: Die Architektur ist n√§her am Anfang und das Code-Design w√§hrend der Implementierung von Unteraufgaben. </p><br><p>  Das Zeichnen einer Grenze zwischen diesen beiden Entwurfsstufen h√§ngt von einer Reihe von Faktoren ab. Hier sind die wichtigsten: </p><br><ul><li>  Das Ausma√ü, in dem die Komponente das System beeinflusst.  Manchmal kann das Ger√§t des gesamten Systems erheblich vom Ger√§t seiner einzelnen Komponente abh√§ngen.  In diesem Fall m√ºssen Sie die Komponente in der Architekturentwicklungsphase und nicht in der Implementierungsphase entwerfen. </li><li>  Das Vorhandensein einer klaren Schnittstelle f√ºr die Komponente.  Es ist nur m√∂glich, das Design einer Komponente als Unteraufgabe zu isolieren, wenn klar definiert ist, was diese Komponente tun soll und wie sie mit dem Rest des Systems interagiert. </li><li>  Realistische Sch√§tzungen des Aufwands zur Vervollst√§ndigung der Teilaufgabe.  Die Aufgabe ist m√∂glicherweise zu gro√ü, um die Arbeitskosten mit ausreichender Genauigkeit bewerten zu k√∂nnen.  In diesem Fall ist es besser, die Aufgabe detaillierter zu gestalten und in eigene Unteraufgaben zu unterteilen, um eine angemessenere Bewertung der Arbeitskosten zu erhalten. </li></ul><br><p>  Es gibt mehrere Sonderf√§lle, in denen Sie eine gute Grenze zwischen Architekturdesign und Code-Design ziehen k√∂nnen. </p><br><p>  <strong>Die Komponente verf√ºgt √ºber eine strikte API.</strong> <br>  In meiner Praxis gab es beispielsweise eine Aufgabe: Auf einer UNIX-Socket-API zu implementieren, um Betriebssystemressourcen zu erfassen / freizugeben, die von einem vorhandenen D√§mon verwendet werden.  Diese Aufgabe entstand im Rahmen der gew√§hlten Architektur f√ºr das neue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">epische Feature</a> .  Im Rahmen der Architektur war es ziemlich allgemein, die API zu beschreiben, und das detaillierte Design wurde sp√§ter w√§hrend der Implementierung durchgef√ºhrt. </p><br><p>  <strong>Modul / Klasse mit einer bestimmten Schnittstelle</strong> <br>  Der einfachste Weg, den Entwurf eines Teils eines monolithischen Systems zu delegieren, besteht darin, ein Modul oder eine Klasse hervorzuheben, ihre Schnittstelle und Aufgaben zu beschreiben.  Ein Modul, das als separate Unteraufgabe zugewiesen ist, sollte nicht zu gro√ü sein.  Beispielsweise ist die Clientbibliothek f√ºr den Zugriff auf die Shard-Datenbank zweifellos ein separates Modul, aber die Aufgabe der Implementierung dieser Bibliothek wird ohne ein detaillierteres Design nur schwer anhand der Arbeitskosten bewertet werden k√∂nnen.  Andererseits ist die Aufgabe, eine zu kleine Klasse zu implementieren, trivial.  Wenn beispielsweise die Unteraufgabe "Implementieren einer Funktion, die die Existenz eines bestimmten Ordners anhand eines bestimmten Pfads √ºberpr√ºft" auftritt, wird die Architektur eindeutig zu detailliert durchdacht. </p><br><p>  <strong>Kleine Komponente mit festen Anforderungen</strong> <br>  Wenn die Komponente klein genug ist und das Problem, das sie l√∂st, genau definiert ist, k√∂nnen die Arbeitskosten f√ºr die Implementierung mit ausreichender Genauigkeit gesch√§tzt werden, und die Implementierung der Komponente selbst l√§sst Raum f√ºr Design.  Beispiel: Ein Prozess, der auf einer Krone ausgef√ºhrt wird und alte Dateien und Verzeichnisse unter einem bestimmten Pfad rekursiv l√∂scht. </p><br><h1 id="antipatterny">  Antipatterns </h1><br><p>  Es gibt Szenarien, in denen die Verteilung zwischen dem Nachdenken √ºber die Architektur und der Implementierung nicht richtig ist. Einige davon werden im Folgenden erl√§utert. </p><br><p>  <strong>Alles ist bis ins kleinste Detail gestaltet.</strong> <br>  Detaillierte UML-Diagramme wurden erstellt, die Signatur jeder Methode jeder Klasse wurde angegeben, die Algorithmen zur Implementierung einzelner Methoden wurden beschrieben ... Nach einer so detaillierten Beschreibung k√∂nnen Sie das System wirklich am schnellsten implementieren, da alles so detailliert geplant ist, dass √ºberhaupt kein Raum f√ºr Kreativit√§t vorhanden ist. Nehmen Sie es und tun Sie es geschrieben.  Wenn der Entwickler das Ziel hat, so schnell wie m√∂glich zu codieren, was er zu ihm sagt, k√∂nnen Sie dies. </p><br><p>  Wenn Sie jedoch etwas tiefer graben, wird eine Reihe von M√§ngeln bei der Organisation der Arbeit in diesem Sinne deutlich.  Erstens m√ºssen Sie viel Zeit mit dem Design selbst verbringen, um alles in solchen Details zu entwerfen.  Was der Entwickler normalerweise vor der Implementierung denkt, wird der Architekt in diesem Schema durchdenken: Der gesamte Entwurf verschiebt sich n√§her an den Beginn des Projekts, was seine Dauer verl√§ngern kann.  Wenn Sie die Konstruktionsarbeit nicht in Teile zerlegen, k√∂nnen Sie sie schlie√ülich nicht parallelisieren.  Zweitens wird der Mangel an Designarbeit w√§hrend der Implementierung die Motivation der Entwickler erheblich verringern: Genau das zu tun, was sie sagen, kann f√ºr Anf√§nger n√ºtzlich sein, aber erfahrene Entwickler werden sich langweilen.  Drittens kann dieser Ansatz im Allgemeinen die Qualit√§t der Ausgabe verringern: Das System, das nicht in ausreichend unabh√§ngige Komponenten unterteilt ist, ist schwieriger zu warten und zu erweitern. </p><br><p>  <strong>Architektur wird immer von einem Entwickler entworfen, der Rest</strong> <del>  <strong>Rauch beiseite</strong> </del>  <strong>nur realisieren</strong> <br>  Zun√§chst sollten mehrere F√§lle erw√§hnt werden, in denen dies n√ºtzlich sein kann.  Erstens ist es ein Team, in dem es viele Anf√§nger und nur einen erfahrenen Programmierer gibt.  In diesem Fall verf√ºgen Anf√§nger nicht √ºber gen√ºgend Erfahrung, um die Architektur so zu gestalten, dass sie die Arbeit mit ausreichender Qualit√§t erledigt. Gleichzeitig hilft ihnen die Implementierung einer durchdachten Architektur, ihr Niveau zu verbessern.  Zweitens handelt es sich um gro√üe Projekte, an denen mehrere Teams beteiligt sind.  Dann wird das Design der Architektur des Projekts in zwei Ebenen unterteilt: Der Architekt denkt es als Ganzes durch und jedes Team - die Architektur der Komponenten in seinem Verantwortungsbereich. </p><br><p>  Betrachten Sie jedoch ein Team, das aus ausreichend erfahrenen Spezialisten besteht.  Wenn Architekturaufgaben immer nur einem, beispielsweise dem erfahrensten Entwickler, zugewiesen werden, k√∂nnen andere Entwickler ihre F√§higkeiten nicht vollst√§ndig offenlegen.  Die Systemarchitektur wird einseitig sein, da jeder eine Reihe von Techniken hat, die er anwendet.  Wenn verschiedene Entwickler an die Architektur verschiedener Komponenten / Subsysteme denken w√ºrden, w√ºrde dies den Erfahrungsaustausch und die Entwicklung von Teammitgliedern erleichtern.  Selbst nicht allzu erfahrene Teammitglieder sollten manchmal architektonische Aufgaben erhalten: Dies erh√∂ht ihr Niveau und erh√∂ht ihre Beteiligung am Projekt. </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Das Vorhandensein der Entwurfsphase in der Implementierung ist der Hauptfaktor, der Implementierungsaufgaben interessant macht.  Nat√ºrlich gibt es noch andere: den Einsatz neuer Technologien, Forschungsaufgaben, aber sie sind in der Regel viel seltener.  Wenn die Implementierungsaufgaben kein Design erfordern und aus einer einfachen Codierung bestehen, wirkt sich dies stark auf die Motivation der Entwickler aus und erm√∂glicht nicht den Einsatz ihrer F√§higkeiten. </p><br><p>  Durch das Entwerfen eines Code-Designs in der Implementierungsphase k√∂nnen Sie schnell angemessene Sch√§tzungen der Arbeitskosten vornehmen, die Arbeit effizienter parallelisieren und im Allgemeinen die Qualit√§t des Systems verbessern. <br>  Die Notwendigkeit, w√§hrend der Implementierung ein Code-Design zu entwerfen, macht die Implementierungsarbeit in den Augen der Entwickler interessant. </p><br><p>  Es lohnt sich nicht, Fehler zu machen, indem Sie Entwurfsarbeiten von der Implementierung von Unteraufgaben ausschlie√üen, so wie Sie Architekturaufgaben nicht immer nur dem erfahrensten Entwickler anvertrauen sollten. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435386/">https://habr.com/ru/post/de435386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435372/index.html">Ein paar Worte zu FastPath und FastTrack bei MikroTik</a></li>
<li><a href="../de435374/index.html">Mathe in Gamedev ist einfach. Triangulation und Triangle.Net in Unity</a></li>
<li><a href="../de435376/index.html">Weltraum 2019: bemannte Schiffe, neue Raketen und Mondsonden</a></li>
<li><a href="../de435380/index.html">Kostenlose Konten auf GitHub k√∂nnen [fast] ohne Einschr√§nkungen mit privaten Repositories arbeiten</a></li>
<li><a href="../de435384/index.html">Wie ich mein Online-Spiel erstellt habe. Teil 1: Vernetzung</a></li>
<li><a href="../de435390/index.html">3D-Engine in SQL-Abfrage</a></li>
<li><a href="../de435394/index.html">K√∂rperliche Ergebnisse des Jahres</a></li>
<li><a href="../de435398/index.html">Metaspiele: Meine Erfahrung bei der Erstellung von Wettbewerben f√ºr Vertriebsleiter</a></li>
<li><a href="../de435400/index.html">1 Million US-Dollar Belohnung f√ºr WhatsApp- und iMessage-Hack-Informationen angek√ºndigt</a></li>
<li><a href="../de435406/index.html">Englisch lernen: ein geekiger Weg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>