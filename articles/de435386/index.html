<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💗 🍆 🚷 So teilen Sie Architektur und Implementierung ohne Streit 👩🏻 👐🏽 📩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Erstellen eines neuen Systems ist ein mehrstufiger Prozess: Ausarbeitung des Konzepts und des Designs, Architekturdesign, Implementierung, Testen,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So teilen Sie Architektur und Implementierung ohne Streit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435386/"><p>  Das Erstellen eines neuen Systems ist ein mehrstufiger Prozess: Ausarbeitung des Konzepts und des Designs, Architekturdesign, Implementierung, Testen, Freigabe.  Architekturdesign und -implementierung sind die Phasen, mit denen sich Entwickler hauptsächlich befassen. </p><br><p>  Die meisten Entwickler beschäftigen sich gerne mit Architektur und überlegen, wie das System oder ein Teil davon von Grund auf neu angeordnet wird.  Wenn jemand die Architektur des Systems durchdacht und implementiert hat, gibt es keine Probleme mit der Motivation: Der Programmierer wird durch die Umsetzung seiner Ideen zufrieden sein.  Aber wenn ein Gedanke an Architektur und ein anderer an der Umsetzung beteiligt sein wird, dann kann letzterer eine natürliche Empörung haben: Sie haben alles für mich überlegt, aber kann ich einfach das tun, was geschrieben steht? </p><br><p><img src="https://habrastorage.org/webt/vj/ii/ox/vjiioxfop6iqofh1irlgn_kuueo.jpeg"></p><br><p>  In diesem Artikel wird erläutert, wie solche Situationen vermieden werden können, warum die Implementierung nicht weniger interessant sein kann als die Ausarbeitung der Architektur und manchmal auch mehr. </p><a name="habracut"></a><br><h1 id="vvedenie">  Einführung </h1><br><p>  Eine durchdachte Architektur kann als Grundlage für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausfallaufgaben verwendet werden</a> : Die Implementierung jeder ausreichend separaten Komponente wird zu einer separaten Unteraufgabe. </p><br><p>  Wenn es beispielsweise eine Abfrageverarbeitungspipeline gibt, die im Stil von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pipes &amp; Filtern entworfen wurde</a> , sind die Unteraufgaben die Implementierung einzelner Verarbeitungsschritte (jeder Schritt hat seine eigene Unteraufgabe) und einer anderen Unteraufgabe, um alle Schritte miteinander zu verbinden. </p><br><p>  Eine durchdachte Architektur und die Aufteilung in Unteraufgaben geben zwar eine allgemeine Vorstellung davon, wie ein System erstellt und die Bewertung der Arbeitskosten ermöglicht wird, reichen jedoch nicht aus, um den Plan umzusetzen.  In der Beschreibung der Unteraufgabe wird angegeben, was die Komponente tun soll. Sie enthält möglicherweise Anforderungen an Geschwindigkeit und Speicherverbrauch, enthält jedoch keine umfassenden Anweisungen dazu. </p><br><p>  Tatsache ist, dass es viele Optionen gibt, um eine Komponente herzustellen, die die angegebenen Anforderungen erfüllt.  Viel hängt davon ab, wie es implementiert wird: Codeflexibilität, Erweiterbarkeit, einfache Unterstützung usw.  Wir kommen dem Konzept <em>des Code-Designs nahe</em> . </p><br><h1 id="koncepciya-dizayna-koda">  Code-Design-Konzept </h1><br><p>  Manchmal wird Code-Design als Architektur oder Code-Organisation bezeichnet, manchmal sogar nur als Architektur.  Ich halte mich an den Begriff <em>Code-Design,</em> weil er sich von der Systemarchitektur abhebt und eine klare Linie zwischen ihnen zieht.  Um genauer zu sein, betrachten Sie ein Beispiel. </p><br><p>  Nehmen wir an, wir entwickeln das Backend einer Website, die immer beliebter wird.  Die Anzahl der Server hat bereits mehrere zehn überschritten, das Publikum wächst und wir beschließen, Analysen zum Benutzerverhalten auf der Website zu sammeln: Beliebtheit von Besuchsseiten, Häufigkeit der Nutzung von Funktionen abhängig vom Benutzerprofil usw. </p><br><p>  Es treten eine Reihe von architektonischen und technologischen Problemen auf: Wo werden Metriken gespeichert, wie werden sie über das Netzwerk übertragen, was ist zu tun, wenn der Metrikspeicher nicht verfügbar ist, wie der Backend-Dienst Metriken aufzeichnet usw.  Die Architektur muss nur diese Fragen beantworten, die Komponenten der Lösung bestimmen und Anforderungen für sie festlegen. </p><br><p>  Angenommen, wir haben eine Architektur entwickelt: Wir werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">InfluxDB</a> als Speicher verwenden, Metriken mithilfe von UDP für das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegraf</a> über das Netzwerk übertragen und die Nichtverfügbarkeit des Speichers umgehen, um die Metriken in Kafka zu speichern, die auf mehreren Servern repliziert wurden.  Alle Metriken gehen den Weg Backend-Service -&gt; Telegraf -&gt; Kafka -&gt; InfluxDB.  Um die Metriken zu schreiben, hat das Backend beschlossen, ein Modul zu schreiben, das die Metrikübertragungsfunktion in Telegraf mithilfe von UDP implementiert. </p><br><p>  Das Modul zum Aufzeichnen von Metriken ist eine separate Komponente des Systems. Das Schreiben ist eine separate Unteraufgabe, die dem Entwickler anvertraut werden kann.  Diese Unteraufgabe enthält viele Lösungen und Fragen, die beantwortet werden müssen: Metriken werden synchron oder asynchron gesendet.  Wie wird der gleichzeitige Zugriff auf mehrere Backend-Threads synchronisiert, welche Hauptklassen / Funktionen werden verwendet? </p><br><p>  Diese Fragen gehen über die Beschreibung der Lösungsarchitektur hinaus, aber die Antworten darauf haben weitreichende Konsequenzen.  Wenn beispielsweise während des Betriebs einer Lösung klar wird, dass der Technologie-Stack nicht optimal ist und Sie Telegraf durch eine alternative Lösung ersetzen müssen, kann dies durch eine falsche Unterteilung des Moduls in Klassen nicht ohne Umschreiben des gesamten Moduls erfolgen.  Die Antworten auf diese Fragen liegen im <strong>Bereich des Code-Designs</strong> . </p><br><p>  <strong>Die Entwicklung des Code-Designs ist eine separate Entwurfsphase</strong> , die zwischen der Entwicklung der Systemarchitektur und der Codierung liegt.  Wenn Sie eine Grenze zwischen Architektur und Code-Design ziehen, können Sie ein System entwerfen, ohne alle Details zu berücksichtigen, und die Arbeitskosten in einer begrenzten Zeit bewerten.  Wenn Sie andererseits die Entwicklung des Code-Designs als separate Implementierungsphase hervorheben, können Sie die Qualität der Systemimplementierung verbessern, die Kosten für weitere Verbesserungen senken und den Support vereinfachen. </p><br><p>  Die Notwendigkeit, das Code-Design in der Implementierungsphase vor dem Codieren zu überdenken, <strong>macht die Implementierung interessant</strong> : Die Aufgaben beim Entwerfen eines Code-Designs können nicht weniger interessant sein als das Entwerfen eines gesamten Systems auf Architekturebene.  Diese Idee wurde von Brooks im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mythischen</a> Mannmonat zum Ausdruck gebracht. </p><br><p>  Natürlich ist es möglicherweise nicht so einfach, eine Grenze zwischen Architektur und Code-Design zu ziehen. Schauen wir uns dieses Problem genauer an. </p><br><h1 id="granica-mezhdu-arhitekturoy-i-dizaynom-koda">  Die Grenze zwischen Architektur und Code-Design </h1><br><p>  Ideologisch gesehen befinden sich Architektur und Code-Design auf verschiedenen Designebenen: Architektur wird in der Anfangsphase durchdacht, wenn wenig Sicherheit besteht, und das Nachdenken über das Code-Design fügt Details hinzu.  Dementsprechend werden sie zu unterschiedlichen Zeitpunkten ausgeführt: Die Architektur ist näher am Anfang und das Code-Design während der Implementierung von Unteraufgaben. </p><br><p>  Das Zeichnen einer Grenze zwischen diesen beiden Entwurfsstufen hängt von einer Reihe von Faktoren ab. Hier sind die wichtigsten: </p><br><ul><li>  Das Ausmaß, in dem die Komponente das System beeinflusst.  Manchmal kann das Gerät des gesamten Systems erheblich vom Gerät seiner einzelnen Komponente abhängen.  In diesem Fall müssen Sie die Komponente in der Architekturentwicklungsphase und nicht in der Implementierungsphase entwerfen. </li><li>  Das Vorhandensein einer klaren Schnittstelle für die Komponente.  Es ist nur möglich, das Design einer Komponente als Unteraufgabe zu isolieren, wenn klar definiert ist, was diese Komponente tun soll und wie sie mit dem Rest des Systems interagiert. </li><li>  Realistische Schätzungen des Aufwands zur Vervollständigung der Teilaufgabe.  Die Aufgabe ist möglicherweise zu groß, um die Arbeitskosten mit ausreichender Genauigkeit bewerten zu können.  In diesem Fall ist es besser, die Aufgabe detaillierter zu gestalten und in eigene Unteraufgaben zu unterteilen, um eine angemessenere Bewertung der Arbeitskosten zu erhalten. </li></ul><br><p>  Es gibt mehrere Sonderfälle, in denen Sie eine gute Grenze zwischen Architekturdesign und Code-Design ziehen können. </p><br><p>  <strong>Die Komponente verfügt über eine strikte API.</strong> <br>  In meiner Praxis gab es beispielsweise eine Aufgabe: Auf einer UNIX-Socket-API zu implementieren, um Betriebssystemressourcen zu erfassen / freizugeben, die von einem vorhandenen Dämon verwendet werden.  Diese Aufgabe entstand im Rahmen der gewählten Architektur für das neue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">epische Feature</a> .  Im Rahmen der Architektur war es ziemlich allgemein, die API zu beschreiben, und das detaillierte Design wurde später während der Implementierung durchgeführt. </p><br><p>  <strong>Modul / Klasse mit einer bestimmten Schnittstelle</strong> <br>  Der einfachste Weg, den Entwurf eines Teils eines monolithischen Systems zu delegieren, besteht darin, ein Modul oder eine Klasse hervorzuheben, ihre Schnittstelle und Aufgaben zu beschreiben.  Ein Modul, das als separate Unteraufgabe zugewiesen ist, sollte nicht zu groß sein.  Beispielsweise ist die Clientbibliothek für den Zugriff auf die Shard-Datenbank zweifellos ein separates Modul, aber die Aufgabe der Implementierung dieser Bibliothek wird ohne ein detaillierteres Design nur schwer anhand der Arbeitskosten bewertet werden können.  Andererseits ist die Aufgabe, eine zu kleine Klasse zu implementieren, trivial.  Wenn beispielsweise die Unteraufgabe "Implementieren einer Funktion, die die Existenz eines bestimmten Ordners anhand eines bestimmten Pfads überprüft" auftritt, wird die Architektur eindeutig zu detailliert durchdacht. </p><br><p>  <strong>Kleine Komponente mit festen Anforderungen</strong> <br>  Wenn die Komponente klein genug ist und das Problem, das sie löst, genau definiert ist, können die Arbeitskosten für die Implementierung mit ausreichender Genauigkeit geschätzt werden, und die Implementierung der Komponente selbst lässt Raum für Design.  Beispiel: Ein Prozess, der auf einer Krone ausgeführt wird und alte Dateien und Verzeichnisse unter einem bestimmten Pfad rekursiv löscht. </p><br><h1 id="antipatterny">  Antipatterns </h1><br><p>  Es gibt Szenarien, in denen die Verteilung zwischen dem Nachdenken über die Architektur und der Implementierung nicht richtig ist. Einige davon werden im Folgenden erläutert. </p><br><p>  <strong>Alles ist bis ins kleinste Detail gestaltet.</strong> <br>  Detaillierte UML-Diagramme wurden erstellt, die Signatur jeder Methode jeder Klasse wurde angegeben, die Algorithmen zur Implementierung einzelner Methoden wurden beschrieben ... Nach einer so detaillierten Beschreibung können Sie das System wirklich am schnellsten implementieren, da alles so detailliert geplant ist, dass überhaupt kein Raum für Kreativität vorhanden ist. Nehmen Sie es und tun Sie es geschrieben.  Wenn der Entwickler das Ziel hat, so schnell wie möglich zu codieren, was er zu ihm sagt, können Sie dies. </p><br><p>  Wenn Sie jedoch etwas tiefer graben, wird eine Reihe von Mängeln bei der Organisation der Arbeit in diesem Sinne deutlich.  Erstens müssen Sie viel Zeit mit dem Design selbst verbringen, um alles in solchen Details zu entwerfen.  Was der Entwickler normalerweise vor der Implementierung denkt, wird der Architekt in diesem Schema durchdenken: Der gesamte Entwurf verschiebt sich näher an den Beginn des Projekts, was seine Dauer verlängern kann.  Wenn Sie die Konstruktionsarbeit nicht in Teile zerlegen, können Sie sie schließlich nicht parallelisieren.  Zweitens wird der Mangel an Designarbeit während der Implementierung die Motivation der Entwickler erheblich verringern: Genau das zu tun, was sie sagen, kann für Anfänger nützlich sein, aber erfahrene Entwickler werden sich langweilen.  Drittens kann dieser Ansatz im Allgemeinen die Qualität der Ausgabe verringern: Das System, das nicht in ausreichend unabhängige Komponenten unterteilt ist, ist schwieriger zu warten und zu erweitern. </p><br><p>  <strong>Architektur wird immer von einem Entwickler entworfen, der Rest</strong> <del>  <strong>Rauch beiseite</strong> </del>  <strong>nur realisieren</strong> <br>  Zunächst sollten mehrere Fälle erwähnt werden, in denen dies nützlich sein kann.  Erstens ist es ein Team, in dem es viele Anfänger und nur einen erfahrenen Programmierer gibt.  In diesem Fall verfügen Anfänger nicht über genügend Erfahrung, um die Architektur so zu gestalten, dass sie die Arbeit mit ausreichender Qualität erledigt. Gleichzeitig hilft ihnen die Implementierung einer durchdachten Architektur, ihr Niveau zu verbessern.  Zweitens handelt es sich um große Projekte, an denen mehrere Teams beteiligt sind.  Dann wird das Design der Architektur des Projekts in zwei Ebenen unterteilt: Der Architekt denkt es als Ganzes durch und jedes Team - die Architektur der Komponenten in seinem Verantwortungsbereich. </p><br><p>  Betrachten Sie jedoch ein Team, das aus ausreichend erfahrenen Spezialisten besteht.  Wenn Architekturaufgaben immer nur einem, beispielsweise dem erfahrensten Entwickler, zugewiesen werden, können andere Entwickler ihre Fähigkeiten nicht vollständig offenlegen.  Die Systemarchitektur wird einseitig sein, da jeder eine Reihe von Techniken hat, die er anwendet.  Wenn verschiedene Entwickler an die Architektur verschiedener Komponenten / Subsysteme denken würden, würde dies den Erfahrungsaustausch und die Entwicklung von Teammitgliedern erleichtern.  Selbst nicht allzu erfahrene Teammitglieder sollten manchmal architektonische Aufgaben erhalten: Dies erhöht ihr Niveau und erhöht ihre Beteiligung am Projekt. </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Das Vorhandensein der Entwurfsphase in der Implementierung ist der Hauptfaktor, der Implementierungsaufgaben interessant macht.  Natürlich gibt es noch andere: den Einsatz neuer Technologien, Forschungsaufgaben, aber sie sind in der Regel viel seltener.  Wenn die Implementierungsaufgaben kein Design erfordern und aus einer einfachen Codierung bestehen, wirkt sich dies stark auf die Motivation der Entwickler aus und ermöglicht nicht den Einsatz ihrer Fähigkeiten. </p><br><p>  Durch das Entwerfen eines Code-Designs in der Implementierungsphase können Sie schnell angemessene Schätzungen der Arbeitskosten vornehmen, die Arbeit effizienter parallelisieren und im Allgemeinen die Qualität des Systems verbessern. <br>  Die Notwendigkeit, während der Implementierung ein Code-Design zu entwerfen, macht die Implementierungsarbeit in den Augen der Entwickler interessant. </p><br><p>  Es lohnt sich nicht, Fehler zu machen, indem Sie Entwurfsarbeiten von der Implementierung von Unteraufgaben ausschließen, so wie Sie Architekturaufgaben nicht immer nur dem erfahrensten Entwickler anvertrauen sollten. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435386/">https://habr.com/ru/post/de435386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435372/index.html">Ein paar Worte zu FastPath und FastTrack bei MikroTik</a></li>
<li><a href="../de435374/index.html">Mathe in Gamedev ist einfach. Triangulation und Triangle.Net in Unity</a></li>
<li><a href="../de435376/index.html">Weltraum 2019: bemannte Schiffe, neue Raketen und Mondsonden</a></li>
<li><a href="../de435380/index.html">Kostenlose Konten auf GitHub können [fast] ohne Einschränkungen mit privaten Repositories arbeiten</a></li>
<li><a href="../de435384/index.html">Wie ich mein Online-Spiel erstellt habe. Teil 1: Vernetzung</a></li>
<li><a href="../de435390/index.html">3D-Engine in SQL-Abfrage</a></li>
<li><a href="../de435394/index.html">Körperliche Ergebnisse des Jahres</a></li>
<li><a href="../de435398/index.html">Metaspiele: Meine Erfahrung bei der Erstellung von Wettbewerben für Vertriebsleiter</a></li>
<li><a href="../de435400/index.html">1 Million US-Dollar Belohnung für WhatsApp- und iMessage-Hack-Informationen angekündigt</a></li>
<li><a href="../de435406/index.html">Englisch lernen: ein geekiger Weg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>