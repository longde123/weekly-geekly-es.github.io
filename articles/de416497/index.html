<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèª ‚èèÔ∏è üòñ Ein Beispiel f√ºr die Berechnung der Signalreaktion mithilfe der Fourier-Transformation in MATLAB ü§∑üèæ üïô üòõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei der L√∂sung von Problemen der Daten√ºbertragung durch durch Frequenzkennlinien dargestellte Leitungen werden Fourier-Transformationen angewendet - d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein Beispiel f√ºr die Berechnung der Signalreaktion mithilfe der Fourier-Transformation in MATLAB</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416497/">  Bei der L√∂sung von Problemen der Daten√ºbertragung durch durch Frequenzkennlinien dargestellte Leitungen werden Fourier-Transformationen angewendet - die √úbertragung von Signalen vom Zeitbereich in den Frequenzbereich und umgekehrt.  Die MATLAB-Umgebung verf√ºgt √ºber alle Funktionen zur L√∂sung solcher Probleme.  In dieser Arbeit wird ein Beispiel f√ºr die Berechnung der Reaktion eines √ºber eine Leitung √ºbertragenen Signals in MATLAB analysiert, dessen Charakteristik bei Frequenzen gemessen wird, die nicht mit der Daten√ºbertragungsfrequenz √ºbereinstimmen.  Ich hoffe, dass dieses Beispiel das Verst√§ndnis der Funktionen der Signalumwandlungstechnologie in der MATLAB-Umgebung erleichtert. <br><br><h3>  Aufgabenbedingung </h3><br>  Es ist notwendig, die √Ñnderung der Form des bin√§ren digitalen Signals zu bestimmen, das durch das Filter und die Signalleitung l√§uft.  Das Signal wird durch die Amplitude und die √úbertragungsrate eingestellt.  Das auf die Daten√ºbertragungsfrequenz normierte Filter zweiter Ordnung wird durch Zeitkonstanten eingestellt.  Die √úbertragungsfunktion der Signalleitung wird durch den gemessenen Frequenzgang in komplexer Form dargestellt. <br><br>  Die zum Berechnen und Anzeigen von Daten verwendete Umgebung ist MATLAB R2015a. <br>  Die folgenden auf der Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.StatEye.org</a> ver√∂ffentlichten Beziehungen f√ºr die Version der StatEye 3.0-GUI-Methode [1, 2, 3] wurden als Beispiel f√ºr die Anfangsdaten verwendet. <br><br>  Datenrate bps = 10,3125 Gbit / s.  Die Zeitkonstanten des normalisierten Filters zweiter Ordnung sind gleich, ihr Kehrwert ist ¬æ der Daten√ºbertragungsfrequenz.  Die Signalleitung wird durch einen Frequenzgang dargestellt.  Die Charakteristik wurde bei Kanal f = 0,006495: 0,0012475: 20 GHz gemessen.  Die angegebene Anzahl von Abtastpunkten der Fourier-Transformation: Punkte = 2 ^ 13. <br><a name="habracut"></a><br>  Abbildung 1 zeigt die in diesem Dokument diskutierten Daten√ºbertragungs-, Sequenz- und Datenverarbeitungsergebnisse.  Der √úbergang vom Zeitbereich zum Frequenzbereich und umgekehrt erfolgt mit dem Fast Fourier Transform (FFT) -Algorithmus. <br><img src="https://habrastorage.org/webt/ex/c8/fw/exc8fwf3_bfcnnczjnoo_qdj43q.png" alt="Bild"><br>  <i>Abbildung 1. Datenkanal.</i>  <i>Eingangssignal iSignal.Tx, Ausgangssignal des Filters iSignal.Filter_out, Ausgangssignalleitung iSignal.Rx.</i>  <i>Die im Diagramm gezeigten Eigenschaften werden unten diskutiert.</i> <br><br><h3>  Berechnungssequenz </h3><br>  In dieser Arbeit werden die Hauptberechnungen im Frequenzbereich durchgef√ºhrt.  Hierzu wurde das urspr√ºngliche Signal aus dem Zeitbereich unter Verwendung der Fourier-Transformation in den Frequenzbereich √ºbertragen. Durch Multiplizieren der spektralen Eigenschaften des Signals, des Filters und der Signalleitung wurde das Ausgangssignal des Pfades gefunden, das durch die inverse Fourier-Transformation vom Frequenzbereich in den Zeitbereich √ºbertragen wird. <br><br>  Die Daten√ºbertragungsrate ist doppelt so hoch wie die Frequenz, mit der Daten √ºbertragen werden.  Die maximale Frequenz der gemessenen Signalleitung max (Kanal.f) = 20 GHz.  Bei dieser Frequenz k√∂nnen Daten mit einer Geschwindigkeit von 40 Gbit / s (als 2 * max (Kanal.f)) √ºbertragen werden. <br><br>  Die maximale Daten√ºbertragungsrate, die die maximale √úbertragungsrate auf der Signalleitung von 40 Gbit / s und eine Mehrfach√ºbertragungsrate von bps = 10,3125 Gbit / s nicht √ºberschreitet, betr√§gt fmax = 30,9375 Gbit / s, die Multiplizit√§t N = 3 (N = fmax / bps).  Ferner wird fmax als Grenzfrequenz zum Berechnen der Antwort des Signals unter Verwendung der Fourier-Transformation verwendet. <br><br><h3>  √úbersetzung des Eingangssignals in den Frequenzbereich </h3><br>  Zeitdiskriminierung zum Aufbau des Eingangssignals (Datenbit) im Zeitbereich Ts = 1 / fmax;  Ts = 3,232e-11 s.  Normalisiert in Bezug auf die Signaldauer besteht die Zeitskala aus 2 ^ 13 Punkten (Punkten), die Skala enth√§lt das folgende Array von Punkten Zeit = bps / Ts. * (1: Punkte).  Ein diskretes Einzelsignal mit einer √úbertragungsrate von bps = 10,3125 Gbit / s und einer Quantisierung mit einer Periode Ts = 1 / fmax besteht aus drei Punkten im Bereich von 10 bis 11 Einheiten normalisierter Zeit.  Ein Signal mit Einheitsamplitude kann an einer anderen Stelle auf der Timeline erstellt werden. Es ist jedoch besser, von den R√§ndern zur√ºckzutreten, um den Hintergrund und den √úbergangsprozess des Ausgangssignals vollst√§ndig zu sehen.  Ein Impulssignal (Datenbit), das mit den folgenden MATLAB-Befehlen erstellt wurde, ist in Abbildung 2 dargestellt. <br><br><pre><code class="matlab hljs">iSignal.Tx(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">size</span></span>(time,<span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>; t0 = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(time&lt;=<span class="hljs-number"><span class="hljs-number">10</span></span>)); t1 = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(time&lt;<span class="hljs-number"><span class="hljs-number">11</span></span>)); iSignal.Tx(t0:t1) = <span class="hljs-number"><span class="hljs-number">1.0</span></span>;</code> </pre> <br><img src="https://habrastorage.org/webt/qf/df/ec/qfdfec6aehsjzwgjgenqazdh82y.png" alt="Bild"><br>  <i>Abbildung 2. Eingangsimpulssignal iSignal.Tx, Datenbit.</i> <br><br>  Die √úbersetzung des iSignal.Tx-Signals in den Frequenzbereich wird durch die folgenden FFT-Funktionen durchgef√ºhrt. <br><br><pre> <code class="matlab hljs">iSignal.shiftedPSD = fft(iSignal.Tx); iSignal.PSD = fftshift(iSignal.shiftedPSD);</code> </pre> <br>  Die Fourier-Transformationsfunktion fft konstruiert ein symmetrisches Spektrum des Signals in den Bereichen positiver und negativer Frequenzen, deren maximale Frequenz in der Mitte des Spektrums liegt (siehe Abbildung 3).  Die fftshift-Funktion stellt das Spektrum wieder her, indem die Nullfrequenz des Signals wie in Abbildung 4 gezeigt in die Mitte verschoben wird. <br><br>  Die Aufl√∂sung der Spektrumsfrequenz betr√§gt fs = fmax / Punkte;  Die Frequenzfrequenzen reichen von -fmax / 2 bis fmax / 2-fs und sind gleich f = -fmax / 2: fs: fmax / 2-fs; <br><br><img src="https://habrastorage.org/webt/ho/8s/sb/ho8ssbopxofj9awqb5rudr9i4ks.png" alt="Bild"><br>  <i>Abbildung 3. Amplitudenantwort des verschobenen Spektrums des mit der FFT erhaltenen iSignal.Tx-Signals.</i> <br><br><img src="https://habrastorage.org/webt/gr/hn/lc/grhnlcgd4yp6lhei-wwiqw_ui0c.png" alt="Bild"><br>  <i>Abbildung 4. Amplitudenantwort des rekonstruierten Spektrums des in Abbildung 3 gezeigten iSignal.Tx-Signals. 2 ^ 13 Beispiele werden vorgestellt.</i>  <i>Die durchschnittliche Anzahl bei 4097 entspricht der Frequenz Null.</i>  <i>Negative Frequenzen befinden sich auf der linken Seite (von 1 bis 4096 Punkten) und der Bereich der positiven Frequenzen auf der rechten Seite (von 4098 bis 8192 Punkten).</i> <br><br><h3>  √úbertragungsfunktion des normalisierten Tiefpassfilters </h3><br>  In diesem Beispiel hat die √úbertragungsfunktion des Filters zweiter Ordnung die Form <br><br><img src="https://habrastorage.org/webt/bz/ov/pt/bzovptea80xq-lyjjgayndllj98.png" alt="Bild"><br>  wobei T1 und T2 Filterzeitkonstanten sind.  Die Frequenzen 1 / T1 sind gleich und 1 / T2 werden relativ zu der Frequenz eingestellt, mit der die Daten √ºbertragen werden: 1 / T1 = 1 / T2 = 0,75 * bps (bps = 10,3125 Gbit / s). <br><br>  Normalisierte Filterbandbreite <br><br><pre> <code class="matlab hljs">f_nrm =fmax/bps/points.*(-points/<span class="hljs-number"><span class="hljs-number">2</span></span>:points/<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>).</code> </pre> <br>  Betreiber <br><br><pre> <code class="matlab hljs">s = f_nrm .* <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>;</code> </pre> <br>  Die Amplitudenphasenkennlinie des normalisierten Filters f√ºr positive und negative Frequenzen, die in Bezug auf die Signal√ºbertragungsfrequenz normalisiert sind, ist in 5 gezeigt. Die logarithmische Amplitudenfrequenzkennlinie des Filters ist in 6 gezeigt. <br><br><img src="https://habrastorage.org/webt/ct/32/rj/ct32rjkglsoalv2s9lq9sdc41xy.png" alt="Bild"><br>  <i>Abbildung 5. Die Amplituden-Phasen-Charakteristik eines normalisierten Filters</i> <br><br><img src="https://habrastorage.org/webt/fa/zp/x5/fazpx5t-iptrisubkndxs-aizes.png" alt="Bild"><br>  <i>Abbildung 6. Logarithmischer Amplituden-Phasen-Frequenzgang eines normalisierten Filters.</i>  <i>Die blaue gestrichelte Linie zeigt die Position der Filterfrequenz mit einem Wert von 0,75 der Frequenz, mit der Daten √ºbertragen werden.</i>  <i>Bei dieser Frequenz (1 / T1 = 1 / T2) betr√§gt der Transmissionskoeffizient des Filters zweiter Ordnung -6 Dezibel.</i>  <i>Die rote gestrichelte Linie zeigt die Einheitsfrequenz an, mit der Daten √ºbertragen werden.</i> <br><br><h3>  √úbersetzung der Messergebnisse der Signalleitung in die Art der √úbertragungsfunktion </h3><br>  Die gemessene Amplituden-Phasen-Charakteristik der Signalleitung umfasst 1599 Abtastwerte im Band bis 20 GHz mit einem festen Schritt von 12,475 MHz.  Es enth√§lt die folgenden Frequenzwerte: channel.f = 0,006495: 0,0012475: 20 GHz.  Anfangs wurde die Signalleitung durch eine Kennlinie mit vier Anschl√ºssen dargestellt.  Diese Eigenschaft wurde transformiert und wird im Beispiel als eindimensionale komplexe Funktion verwendet. <br><br>  Die als Ergebnis der Messung erhaltenen charakteristischen Signalleitungsfrequenzen stimmen nicht mit den Frequenzen des Eingangssignalspektrums √ºberein, die ein Vielfaches der Daten√ºbertragungsfrequenz sind.  Au√üerdem enth√§lt das Signalleitungsspektrum nur positive Frequenzen und keine Frequenzen im Nullbereich.  Das Eingangssignalspektrum enth√§lt positive, Null- und negative Frequenzen. <br>  Um die Eigenschaften der Signalleitung in eine √úbertragungsfunktion umzuwandeln - eine Eigenschaft, deren Frequenzen mit den Frequenzen des Spektrums des Eingangssignals √ºbereinstimmen, werden die folgenden Schritte ausgef√ºhrt. <br><br>  1. Die Berechnung der Amplitude der Eigenschaften der Linie bei einer Frequenz von Null durch Extrapolation.  Hierzu werden aus zehn Punkten der Amplitudenkennlinie, die der Frequenz Null am n√§chsten liegen, die Koeffizienten eines linearen Polynoms gefunden, die sich der Amplitudenkennlinie ann√§hern: <br><br><pre> <code class="matlab hljs">[a] = polyfit(channel.f(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>), channel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Der zweite gefundene Polynomkoeffizient ist gleich der Amplitude der Charakteristik bei einer Frequenz von Null: <br><br><pre> <code class="matlab hljs">channel.dc = a(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  2. Die Phasenantwort bei einer Frequenz von Null wird gleich Null genommen. <br><br><pre> <code class="matlab hljs">channel.dcPhase = <span class="hljs-number"><span class="hljs-number">0.00</span></span>;</code> </pre> <br>  3. Die Neuberechnung der Amplitudenkanal- und Phasenkanalphaseneigenschaften der Signalleitung mit Werten bei einer Frequenz von Null wird an der Frequenz des Eingangssignalspektrums (f = -fmax / 2: fmax / Punkte: fmax / 2-fmax / Punkte) mit Extrapolation der Eigenschaften auf durchgef√ºhrt Bereich von Null und negativen Frequenzen: <br><br><pre> <code class="matlab hljs">ichannel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span> = interp1([<span class="hljs-number"><span class="hljs-number">0</span></span> channel.f], [channel.dc channel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(f), <span class="hljs-string"><span class="hljs-string">'linear'</span></span>, <span class="hljs-string"><span class="hljs-string">'extrap'</span></span>); ichannel.phase = interp1([<span class="hljs-number"><span class="hljs-number">0</span></span> channel.f], [channel.dcPhase <span class="hljs-built_in"><span class="hljs-built_in">unwrap</span></span>(channel.phase)], <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(f), <span class="hljs-string"><span class="hljs-string">'linear'</span></span>, <span class="hljs-string"><span class="hljs-string">'extrap'</span></span>); ichannel.s = ichannel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span> .* <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(+<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>.*ichannel.phase); ichannel.tf = <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(ichannel.s) + <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">imag</span></span>(ichannel.s) .* <span class="hljs-built_in"><span class="hljs-built_in">sign</span></span>(f);</code> </pre> <br>  Die erhaltene √úbertragungsfunktion - der Amplituden-Phasen-Frequenzgang des Kanals im Niederfrequenzbereich ist in Abbildung 7 dargestellt. Die Amplituden-Frequenz-Eigenschaften der gemessenen Signalleitung und die berechnete √úbertragungsfunktion in den vollen Frequenzbereichen sind in Abbildung 8 dargestellt. Die gleichen Eigenschaften im Phasenraum sind in Abbildung 9 dargestellt. <br><br><img src="https://habrastorage.org/webt/u0/wm/sl/u0wmslmlvtgejybmkwlmg-qwxcg.png" alt="Bild"><br>  <i>Abbildung 7. Die √úbertragungsfunktion der Signalleitung im Niederfrequenzbereich.</i>  <i>Rote und blaue Punkte zeigen diskrete Amplituden- bzw. Phaseneigenschaften an.</i>  <i>Die Amplitudenantwort wird in Dezibel angegeben, die Phase im Bogenma√ü.</i>  <i>Die rosa Linie markiert die niedrigste Frequenz der gemessenen Charakteristik der Signalleitung.</i>  <i>Der √úbertragungskoeffizient bei einer Frequenz von Null betr√§gt 0,992.</i> <br><br><img src="https://habrastorage.org/webt/4o/q5/yd/4oq5ydmnjdijeopyumfiir0nlia.png" alt="Bild"><br>  <i>Abbildung 8. Frequenzgang der Signalleitung.</i>  <i>Blaue Punkte zeigen die komplexen Daten der gemessenen Linie an.</i>  <i>Die berechnete symmetrische Abh√§ngigkeit der Signalleitungsverst√§rkung bei den Frequenzen des Eingangssignalspektrums ist rot hervorgehoben.</i>  <i>Im Nullfrequenzbereich ist diese Charakteristik in Abbildung 7 dargestellt.</i> <br><br><img src="https://habrastorage.org/webt/nx/zp/xo/nxzpxosf_rti2d2-zdny6p-qbrw.png" alt="Bild"><br>  <i>Abbildung 9. Amplitudenphasenfrequenzkennlinien der gemessenen Datenleitung und ihres normalisierten Spektrums.</i> <br><br><h3>  Berechnung der Signalantwort </h3><br>  Die Antwort (Antwort auf den Eingangseffekt) im Frequenzbereich wird erhalten, indem das Spektrum des Signals mit dem Produkt der √úbertragungsfunktionen der Elemente multipliziert wird, die die Reaktion auf das Eingangssignal beziehen.  In unserem Fall passiert das Signal das Filter und die Signalleitung. <br>  Die inverse Fourier-Transformation ifft wird verwendet, um das Signal vom Frequenzbereich in den Zeitbereich zu √ºbertragen. <br><br>  Die Filterausgabe im Zeitbereich iSignal.Filter_out wird berechnet als <br><br><pre> <code class="matlab hljs">TransFunction.PSD = iSignal.PSD .* Filter.PSD_Tx; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Filter_out = <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(ifft(TransFunction.shiftedPSD));</code> </pre> <br>  Das Ausgangssignal der iSignal.Rx-Leitung ist gleich dem Produkt aus dem Spektrum des Eingangssignals und den √úbertragungsfunktionen des Filters und der Signalleitung mit der anschlie√üenden √úbertragung des empfangenen Signals vom Frequenzbereich in den Zeitbereich. <br><br><pre> <code class="matlab hljs">TransFunction.PSD = TransFunction.PSD .* ichannel.tf; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Rx = <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(ifft(TransFunction.shiftedPSD));</code> </pre> <br>  Die Reaktion des Filters auf den idealen Eingangsimpuls und die Reaktion des Kanals sind in Abbildung 10 dargestellt. <br><br><img src="https://habrastorage.org/webt/ta/fh/0b/tafh0btf_ayq9wcxrowembxxbdk.png" alt="Bild"><br>  <i>Abbildung 10. Filterausgabe (rotes Diagramm) und Datenzeilenausgabe (gr√ºnes Diagramm).</i>  <i>Filtereingangssignal - Ein einzelner Impuls ist in Abbildung 2 dargestellt. Der Signalleitungseingang ist das Filterausgangssignal.</i> <br><br><h3>  Anwendung.  Verwendeter M-Code MATLAB </h3><br><div class="spoiler">  <b class="spoiler_title">Auflistung</b> <div class="spoiler_text"><pre> <code class="matlab hljs">clear all <span class="hljs-comment"><span class="hljs-comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Ini data %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% bps = 1.03125e+10; FilterParam = [0.75 0.75]; points = 2^13; load('channel'); N = floor(max(channel.f)*2/bps); fmax = N*bps; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Signal %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % normalise all the scales for the bit rate time = bps/fmax .* (1:points); iSignal.Tx(1:size(time,2)) = 0; t0 = max(find(time&lt;=10)); t1 = max(find(time&lt;11)); iSignal.Tx(t0:t1) = 1.0; figure plot(time(1:t1+10), iSignal.Tx(1:t1+10),'b'); hold on plot(time(1:t1+10), iSignal.Tx(1:t1+10),'xb'); grid on xlabel('Normalised Time, tick Ts = 1/fmax'); ylabel('Normalised Amplitude'); title(['Pulse, data bit']); iSignal.shiftedPSD = fft(iSignal.Tx); figure plot(abs(iSignal.shiftedPSD),'c'); grid on xlabel('points, num'); ylabel('Amplitude'); title(['abs(fft(iSignal.Tx))']); iSignal.PSD = fftshift(iSignal.shiftedPSD); figure plot(abs(iSignal.PSD),'r'); grid on xlabel('points, num'); ylabel('Amplitude'); title(['abs(fftshift(fft(iSignal.Tx)))']); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Filter %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% f_nrm =fmax/bps/points.*(-points/2:points/2-1); s = f_nrm .* j; Filter_PSD = 1 ./(1 + s/FilterParam(1)) ./ (1 + s/FilterParam(2)); figure [AX,H1,H2] = plotyy (f_nrm, abs(Filter_PSD), f_nrm, phase(Filter_PSD)); hold(AX(1)); hold(AX(2)); set(H1,'LineWidth',2); grid(AX(2),'on'); xlabel('Normalised Frequency (Hz)'); set(get(AX(1),'Ylabel'),'String','Gain'); set(get(AX(2),'Ylabel'),'String','Phase, rad'); title(['Twopole filter [' sprintf(' %3.2f ', FilterParam) '] normalised to baud rate frequency']); figure plot_handles_Filter = plot(f_nrm(points/2 + 1:points), 20*log10(abs(Filter_PSD(points/2 + 1:points))), 'r', 'linewidth', 2); hold on stem_handles_br = stem(1, 20*log10(abs(Filter_PSD(max(find(f_nrm &lt; 1))))), '-.ro'); hold on stem_handles_c = stem(FilterParam, [20*log10(abs(Filter_PSD(max(find(f_nrm &lt; FilterParam(1)))))) 20*log10(abs(Filter_PSD(max(find(f_nrm &lt; FilterParam(2))))))], '-.bo'); grid legend_handles = [plot_handles_Filter, stem_handles_br(1), stem_handles_c(1)]; legend(legend_handles, 'transfer function', 'filter attenuation at normalised baud rate', 'filter attenuation at normalised cutoff frequency', 3); xlabel('Normalised Frequency (Hz)'); ylabel('Magnitude (dB)'); title(['Twopole filter [' sprintf(' %3.2f ', FilterParam) '] normalised to baud rate frequency']); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Channel %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % create negative frequencies, convert data to complex value, taking care about negative frequency channel.abs = abs(channel.s); channel.phase = angle(channel.s); %channel.s = channel.abs .* exp(+j.*channel.phase); [a] = polyfit(channel.f(1:10), channel.abs(1:10), 1); channel.dc = a(2); channel.dcPhase = 0.00; fs = fmax/points; % frequency step f = -fmax/2:fs:fmax/2-fs; % frequency matrix % create new data structure with linearly interpolated data ichannel.abs = interp1([0 channel.f], [channel.dc channel.abs], abs(f), 'linear', 'extrap'); ichannel.phase = interp1([0 channel.f], [channel.dcPhase unwrap(channel.phase)], abs(f), 'linear', 'extrap'); % correct for negative frequencies ichannel.s = ichannel.abs .* exp(+j.*ichannel.phase); ichannel.tf = real(ichannel.s) + j*imag(ichannel.s) .* sign(f); figure disp_points = 2*round(channel.f(1)/fs); stem_handles_br = stem(channel.f(1), angle(ichannel.tf(max(find(f &lt; channel.f(1))))), '-.mo'); hold on plot_abs = plot(f(points/2-disp_points:points/2+disp_points), 20*log10(abs(ichannel.tf(points/2-disp_points:points/2+disp_points))), '.r', 'linewidth', 3); hold on plot_phase = plot(f(points/2-disp_points:points/2+disp_points), angle(ichannel.tf(points/2-disp_points:points/2+disp_points)), '.b', 'linewidth', 3); grid legend_handles = [plot_abs, plot_phase, stem_handles_br(1)]; legend(legend_handles, 'absolute value (dB)', 'phase (rad)', 'min data freq', 3); xlabel('Relative Frequency (Hz)'); ylabel('Magnitude'); title(sprintf('dc extrapolation. dc trans function=%4.3f, dc phase=%4.3f rad', abs(ichannel.tf(points/2+1)), angle(ichannel.tf(points/2+1)))); figure plot(channel.f, 20*log10(channel.abs), '.r', 'linewidth', 3); hold on plot(f, 20*log10(ichannel.abs), 'g'); grid on legend('Measured Data', 'Interpolated Data', 3); xlabel('Frequency (Hz)'); ylabel('Magnitude (dB)'); title(['Chnnel interpolated Data : ']); figure plot3(channel.f, real(channel.s), imag(channel.s),'r'); hold on plot3(f, real(ichannel.tf), imag(ichannel.tf),'g'); grid on legend('Measured Data', 'Interpolated Data'); xlabel('Frequency in Hz'); ylabel('Re(fwd transfer)'); zlabel('Im(fwd transfer)'); title(['Chnnel interpolated Data : ']); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Response %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % filter Output TransFunction.PSD = iSignal.PSD .* Filter_PSD; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Filter_out = real(ifft(TransFunction.shiftedPSD)); % pass through channel TransFunction.PSD = TransFunction.PSD .* ichannel.tf; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Rx = real(ifft(TransFunction.shiftedPSD)); figure plot(time, iSignal.Filter_out,'r'); hold on [max_Tx, time_maxTx] = max(iSignal.Filter_out); [min_Tx, time_minTx] = min(iSignal.Filter_out); [max_Rx, time_maxRx] = max(iSignal.Rx); dtime_p5= round((time_maxRx - time_maxTx)*time(1) -1); plot(time - dtime_p5, iSignal.Rx,'g'); hold on plot(time, iSignal.Filter_out,'rx'); axis([(time_maxTx*time(1) - 3) (time_maxTx*time(1) + 5) (min_Tx-0.15) (max_Tx+0.1)]) grid on legend('Filter out','Rx', 2); xlabel('Normalised Time'); ylabel('Normalised Amplitude'); title(sprintf('Transmit pulse (Tx) max= %4.3f; Response (Rx) max (h0)= %4.3f', max(iSignal.Filter_out), max(iSignal.Rx)));</span></span></code> </pre><br></div></div><br><h3>  Bibliografische Liste </h3><br>  1. IEEE802.3ap.  NRZ-Simulationsergebnisse mit 10,3125 Gbit / s unter Verwendung von ‚ÄûStatEye‚Äú und ‚ÄûSignal-zu-Interferenz-Modell‚Äú f√ºr kaskadierte Kanalkomponenten.  Shannon Sawyer und Charles Moore / Agilent Technologies.  24. Januar 2005 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.ieee802.org/3/ap/public/jan05/sawyer_01_0105.pdf</a> <br><br>  2. Was ist StatEye?  IEEE 803.3ap Task Force.  16. September 2004 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.ieee802.org/3/ap/public/signal_adhoc/ghiasi_01_0904.pdf</a> <br><br>  3. Stat Eye / IBM-Vereinbarung.  Steve Anderson.  Xilinx, Inc.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.ieee802.org/3/ap/public/nov04/anderson_01_1104.pdf</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416497/">https://habr.com/ru/post/de416497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416487/index.html">Radio Astron wird 7 Jahre alt</a></li>
<li><a href="../de416489/index.html">Au√üerirdisches Leben: Zur Korrektur der Drake-Gleichung und des gro√üen Filters</a></li>
<li><a href="../de416491/index.html">Activiti - Gesch√§ftsprozess-Engine</a></li>
<li><a href="../de416493/index.html">Starten Sie SIIG MiniSys S286</a></li>
<li><a href="../de416495/index.html">SamsPcbGuide Teil 6: Verfolgen von Signalleitungen. Verlust- und √úbersprechmodelle</a></li>
<li><a href="../de416501/index.html">Schreiben Sie mir einen GraphQL-Server in C #</a></li>
<li><a href="../de416505/index.html">Wir schreiben eine virtuelle Stapelmaschine auf Rust'e</a></li>
<li><a href="../de416507/index.html">So √ºberpr√ºfen Sie die Zuverl√§ssigkeit des Rechenzentrums: 3 Hauptpunkte, auf die Sie achten m√ºssen</a></li>
<li><a href="../de416511/index.html">Die h√§ufigsten Fehler in Ihrem React-Code, die Sie (m√∂glicherweise) machen</a></li>
<li><a href="../de416513/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 260 (2. Juli - 8. Juli)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>