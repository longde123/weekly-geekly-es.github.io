<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🅱️ 👨🏽‍🚒 👩🏽‍⚕️ UDB. Qu'est-ce que c'est? Partie 6. Module d'état et de contrôle 🧙🏽 👩🏾‍🤝‍👨🏻 🤷🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans des articles antérieurs, traductions de la documentation de Cypress, l'automate opérationnel Datapath a été très largement considéré. Progressive...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>UDB. Qu'est-ce que c'est? Partie 6. Module d'état et de contrôle</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443380/"><img src="https://habrastorage.org/webt/mf/zu/nx/mfzunxkuzhcahgj4dodvrfn2i18.jpeg"><br><br>  Dans des articles antérieurs, traductions de la documentation de Cypress, l'automate opérationnel Datapath a été très largement considéré.  Progressivement, nous passons à l'étude d'autres modules UDB, en particulier le module de gestion et d'état. <a name="habracut"></a><br><br>  Le contenu général du cycle «UDB.  Qu'est-ce que c'est? " <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1. Introduction.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pld.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2. Chemin de données.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3. Datapath FIFO.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 4. Datapath ALU.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 5. Chemin de données.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Petites choses utiles.</a> <br>  Partie 6. Module de gestion et d'état.  (Article actuel) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 7. Module de commande de temporisation et de réinitialisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 8. Adressage UDB</a> <br><br><h2>  21.3.3.  Module de gestion et d'état </h2><br>  Une vue de haut niveau du module de commande et de l'état est illustrée à la figure 21-28.  Les bits d'état du registre de contrôle sont transférés vers des ressources de trace, donnant au programme la possibilité de contrôler le comportement de l'UDB.  Le registre d'état reçoit les données des lignes de traçage, de sorte que le programme peut surveiller les opérations effectuées par UDB. <br><br><img src="https://habrastorage.org/webt/4n/0g/wf/4n0gwf_b13miix_dof5ojhxwltk.png"><br>  <i>Figure 21-28.</i>  <i>Registres de gestion et de statut.</i> <br><br>  La structure et l'état du module de commande sont illustrés plus en détail à la figure 21-29.  L'objectif principal de cette unité est de coordonner l'interaction du programme de base du processeur avec le travail des éléments UDB internes.  Cependant, en raison de la forte connexion avec la matrice de trace, ce bloc peut être configuré pour exécuter d'autres fonctions. <br><br><img src="https://habrastorage.org/webt/rh/ak/9e/rhak9e-mn02qvbn0-di2e_81r_i.png"><br>  <i>Figure 21-29.</i>  <i>Module de contrôle et d'état.</i> <br><br>  Modes de fonctionnement: <br><br><ul><li>  <b>Entrée d'état</b>  L'état des lignes enroulées de l'extérieur peut être entré et capturé comme état, après quoi le CPU ou le DMA est lu. </li><li>  <b>Sortie de contrôle</b>  La CPU ou le DMA peut écrire des données dans le registre de contrôle.  Ces données détermineront l'état des lignes allant aux ressources de trace. </li><li>  <b>Entrée parallèle</b> - vers l'entrée parallèle Datapath. </li><li>  <b>Sortie parallèle</b> - à partir de la sortie parallèle de Datapath. </li><li>  <b>Mode compteur</b>  Dans ce mode, le registre de contrôle fonctionne comme un compteur décroissant à 7 bits avec une période programmable et une réinitialisation automatique.  Les entrées de canal de trace peuvent être configurées pour contrôler à la fois le démarrage et la réinitialisation du compteur.  Lorsque ce mode est activé, la fonctionnalité du registre de contrôle n'est pas disponible. </li><li>  <b>Mode synchrone / mode de synchronisation</b> .  Dans ce mode, le registre d'état agit comme un synchroniseur double 4 bits.  Lorsque ce mode est activé, la fonctionnalité du registre d'état n'est pas disponible. </li></ul><br><h2>  21.3.3.1 Statut et mode de contrôle </h2><br>  Lorsqu'il fonctionne en mode de contrôle et d'état, ce module agit comme un registre d'état, un registre de priorité de masque et un registre de contrôle dans la configuration illustrée à la figure 21-30. <br><br><img src="https://habrastorage.org/webt/t3/2j/hk/t32jhkcoc-imxe6vuwpuv91b_rs.png"><br>  <i>Figure 21-30.</i>  <i>Gestion et statut des emplois.</i> <br><br><h4>  Fonctionnement du registre d'état </h4><br>  Chaque UDB possède un registre d'état 8 bits.  L'entrée de ce registre provient de tout signal provenant d'une structure de trace numérique.  Le registre d'état est destructible: il perd son état pendant le sommeil et après le réveil a une valeur de 0x00.  Chaque bit peut être programmé indépendamment pour fonctionner dans l'un des deux modes. <br><br>  Tableau 21-19.  Registre d'état. <br><br><div class="scrollable-table"><table><tbody><tr><th>  <b>STAT MD</b> </th><th>  <b>La description</b> </th></tr><tr><td>  0 </td><td>  Lecture normale.  Renvoie la valeur actuelle du signal d'entrée. </td></tr><tr><td>  1 </td><td>  Sticking, effacé lors de la lecture.  Loquets à haut niveau d'entrée <br>  sur un signal d'horloge.  Effacé après la lecture du registre. </td></tr></tbody></table></div><br>  Une caractéristique importante de l'opération d'effacement du registre d'état est que seuls les bits armés sont effacés.  Cela permet aux bits restants de continuer à capturer l'état pour maintenir la continuité du processus. <br><br><h4>  Statut de lecture normal </h4><br>  Par défaut, le CPU lit de manière transparente l'état du circuit correspondant.  Ce mode peut être utilisé pour lire des données verrouillées dans UDB. <br><br><h4>  Stick status avec clear après lecture </h4><br>  Dans ce mode, les entrées du registre d'état sont échantillonnées à chaque cycle de contrôle et d'horloge d'état.  Si le signal à une horloge donnée est élevé, il est capturé dans le bit d'état et reste élevé, indépendamment des états d'entrée ultérieurs.  Lorsque la CPU ou le DMA lit le registre d'état, le bit est effacé.  L'effacement du registre d'état est indépendant du mode et se produit même lorsque la synchronisation UDB est désactivée;  il est basé sur la synchronisation du bus et se produit dans le cadre d'une opération de lecture. <br><br><h4>  Statut du verrou pendant la lecture </h4><br>  La figure 21-31 montre la structure de la logique de lecture d'état.  Le registre d'état collant est suivi d'un verrou qui verrouille les données du registre d'état et les maintient stables pendant le cycle de lecture, quel que soit le nombre de ticks d'attente dans l'opération de lecture en cours. <br><br><img src="https://habrastorage.org/webt/vc/0w/3c/vc0w3cd0tr9yc51xphqneftldra.png"><br>  <i>Figure 21-31.</i>  <i>La logique de lecture de l'état.</i> <br><br><h4>  Génération d'interruption </h4><br>  Dans la plupart des fonctions, la génération d'interruption est liée aux paramètres du bit d'état.  Comme le montre la figure 21-31, cette fonction est intégrée dans la logique du registre d'état sous la forme d'une opération de masquage et d'application de l'opération <b>OU</b> à l'état.  Seuls les 7 bits inférieurs de l'entrée d'état peuvent être utilisés avec les générateurs d'interruption intégrés.  Le bit le plus significatif (bit le plus significatif, MSB) est généralement utilisé comme sortie d'interruption et peut être transmis au contrôleur d'interruption à l'aide de canaux de traçage numérique.  Dans cette configuration, l'état du bit de demande d'interruption est lu à partir du bit de registre d'état élevé. <br><br><h2>  21.3.3.2 Fonctionnement du registre de contrôle </h2><br>  Chaque UDB dispose d'un registre de contrôle 8 bits.  Il fonctionne comme un registre de lecture / écriture standard sur le bus système, où la sortie de ces bits de registre est contrôlée par les lignes de la structure de trace numérique. <br><br>  Le registre de contrôle est destructible: il perd son état pendant le sommeil et après le réveil a une valeur de 0x00. <br><br><h4>  Modes de registre de gestion </h4><br>  Chaque bit peut être configuré dans l'un des trois modes.  La configuration est spécifiée en combinant les bits de deux registres 8 bits CTL_MD1 [7: 0] et CTL_MD0 [7: 0].  Par exemple, {CTL_MD1 [0], CTL_MD0 [0]} contrôle le mode à zéro bit du registre de contrôle (voir tableau 21-20). <br><br>  Tableau 21-20.  Registre de contrôle Mode zéro bit <br><div class="scrollable-table"><table><tbody><tr><th>  <b>CTL MD</b> </th><th>  <b>La description</b> </th></tr><tr><td>  00 </td><td>  Mode direct </td></tr><tr><td>  01 </td><td>  Mode de synchronisation </td></tr><tr><td>  10 </td><td>  (réservé) </td></tr><tr><td>  11 </td><td>  Mode impulsion </td></tr></tbody></table></div><br><h4>  Mode d'enregistrement de contrôle direct </h4><br>  Par défaut, le mode est direct.  Comme le montre la figure 21-32, lorsque la CPU ou le DMA est écrit dans le registre de contrôle, la sortie du registre de contrôle est envoyée directement à la ligne de trace dans le même cycle. <br><br><img src="https://habrastorage.org/webt/ft/cl/q-/ftclq-bcwhq3r_kozkj3vrwuli0.png"><br>  <i>Figure 21-32.</i>  <i>Mode registre de contrôle direct.</i> <br><br><h4>  Mode registre de contrôle synchrone </h4><br>  En mode synchrone, comme le montre la figure 21-33, la sortie du registre de contrôle est resynchronisée avec une horloge égale à l'horloge actuelle du contrôle et de l'état (Status and Control, SC).  Cela vous permet de contrôler les chronogrammes de la sortie à la fréquence SC sélectionnée, et non à la fréquence d'horloge du bus. <br><br><img src="https://habrastorage.org/webt/jd/a6/7s/jda67s-pgp1kw-03dnttxc-zdcq.png"><br>  <i>Figure 21-33.</i>  <i>Mode registre de contrôle synchrone.</i> <br><br><h4>  Registre de contrôle du mode d'impulsion </h4><br>  Le mode impulsion est similaire au mode synchrone, car en lui le bit de commande est rééchantillonné à la fréquence SC;  l'impulsion commence au premier cycle d'horloge SC et suit le cycle d'écriture du bus.  La sortie du bit de commande est définie pendant un cycle d'horloge SC complet.  À la fin de ce cycle d'horloge, le bit de commande est automatiquement réinitialisé. <br><br>  Avec ce mode de fonctionnement, le programme peut écrire 1 dans le bit de registre de commande pour générer une impulsion.  Une fois que le bit a reçu la valeur 1, le programme le lira comme 1 jusqu'à la fin de l'impulsion, après quoi il sera lu comme 0. Après cela, le programme peut écrire un autre 1 pour démarrer une nouvelle impulsion.  Ainsi, il ne sera pas possible de donner une impulsion plus souvent qu'à chaque deuxième pas du signal SC. <br><br><h4>  Réinitialiser le registre de gestion </h4><br>  Le registre de contrôle a deux modes de réinitialisation contrôlés par le bit de configuration EXT RES, comme illustré à la figure 21-34.  Lorsque EXT RES est 0 (par défaut), en mode synchrone ou impulsionnel, l'entrée de réinitialisation tracée réinitialise la sortie synchronisée, mais pas le bit de commande lui-même.  Lorsque EXT RES est 1, l'entrée de réinitialisation traçable réinitialise à la fois le bit de commande et la sortie synchronisée. <br><br><img src="https://habrastorage.org/webt/lo/ho/dl/lohodlp2-dbsqoqzpwurp8hx2di.png"><br>  <i>Figure 21-34.</i>  <i>Réinitialiser le registre de gestion.</i> <br><br><h2>  21.3.3.3 Mode entrée / sortie parallèle </h2><br>  Dans ce mode, le contrôle et le suivi de l'état sont connectés aux signaux Datapath d'entrée et de sortie parallèle.  Pour activer ce mode, vous devez armer les bits de configuration SC OUT pour sélectionner la sortie parallèle de Datapath.  La communication avec une entrée parallèle est toujours disponible, cependant, ces connexions de trace sont partagées avec les entrées du registre d'état, les entrées de commande de compteur et les sorties d'interruption. <br><br><img src="https://habrastorage.org/webt/9c/se/c2/9csec2u290m0hm1qaecqxpyybhe.png"><br>  <i>Figure 21-35.</i>  <i>Mode E / S parallèle.</i> <br><br><h2>  21.3.3.4 Mode compteur </h2><br>  Comme le montre la figure 21-36, lorsque l'unité fonctionne en mode compteur, un compteur décroissant de 7 bits est disponible pour une utilisation à la fois dans les opérations au sein de l'UDB et pour les besoins du programme.  Les caractéristiques du compteur comprennent: <br><br><ul><li>  Registre de période de 7 bits, (lecture / écriture). </li><li>  Registre de compte 7 bits, (lecture / écriture).  L'accès n'est possible que lorsque le compteur est arrêté. </li><li>  Recharge automatiquement la période dans le registre des comptes lorsqu'elle atteint zéro. </li><li>  Le bit de commande accessible par logiciel dans le registre de commande auxiliaire CNT START, utilisé pour démarrer et arrêter le compteur.  (Il chevauche le signal matériel ENABLE et doit être installé pour que le signal matériel ENABLE en option fonctionne). </li><li>  Bits sélectionnables des canaux de trace de la commande de compteur dynamique en option pour les fonctions de démarrage et de chargement: <br>  - EN, signal tracé pour démarrer ou arrêter le comptage. <br>  - LD, un signal de charge traçable qui provoque un rechargement de période.  Lorsque ce signal est armé, il chevauche le signal de fin en attente.  Il est sensible au niveau et pendant que le signal est armé, la période continue de se charger. </li><li>  Un compteur 7 bits peut être envoyé pour tracer les ressources en tant que sc_out [6: 0]. </li><li>  Le signal de terminaison peut entrer des ressources de trace comme sc_out [7]. </li><li>  En mode «par défaut», le mode d'accrochage est utilisé pour le signal de comptage.  En mode alternatif, il passe en mode combiné. </li><li>  En mode par défaut, le signal matériel EN optionnel, s'il est utilisé, doit être réglé pour activer le signal matériel LD.  En mode alternatif, les signaux matériels LD et EN sont indépendants. </li></ul><br><img src="https://habrastorage.org/webt/no/ov/up/noovupgcemdnnl1v6ak4tyl1rnq.png"><br>  <i>Figure 21-36.</i>  <i>Mode compteur</i> <br><blockquote>  <i><b>Note du traducteur:</b></i> <br>  Autour de cet endroit, j'ai réalisé que je ne comprenais rien du document.  Nulle part ces modes «par défaut» et «alternatifs» ne sont décrits.  Après une longue recherche, j'ai réussi à en trouver, mais un exemple. <br>  Fichier: C: \ Program Files (x86) \ Cypress \ PSoC Creator \ 4.2 \ PSoC Creator \ psoc \ content \ CyComponentLibrary \ CyComponentLibrary.cylib \ bScanComp_v1_10 \ bScanComp_v1_10.v <br>  Code explicatif: <br><br><img src="https://habrastorage.org/webt/ba/rf/13/barf13t7suartgjw8b0frvtsccs.png"><br><br><div class="spoiler">  <b class="spoiler_title">Même texte:</b> <div class="spoiler_text"><pre><code class="plaintext hljs">cy_psoc3_count7 #(.cy_period(Period),.cy_route_ld(0),.cy_route_en(1), .cy_alt_mode(1)) ChannelCounter( /* input */ .clock(clk_int), /* input */ .reset(1'b0), /* input */ .load(1'b0), /* input */ .enable(enable_int), /* output [06:00] */ .count(count), /* output */ .tc(tc_o) );</code> </pre> <br></div></div><br>  La déclaration même du composant cy_psoc3_count7 que j'ai trouvée uniquement pour le langage VHDL, il semble que pour Verilog il soit intégré dans les outils de développement.  Maintenant, vous savez à peu près où chercher les bits de réglage en cours de discussion. <br><br>  Nous considérons ici les bits mystérieux, qui sont appelés SC OUT CTL ou SC_OUT_CTL, mais leurs valeurs ne sont pas documentées.  Je ne les ai trouvés nulle part.  Il ressort clairement du texte qu'ils commutent le composant STATUS_CONTROL entre les modes.  Mais dans le fichier VHDL mentionné précédemment C: \ Program Files (x86) \ Cypress \ PSoC Creator \ 4.2 \ PSoC Creator \ warp \ lib \ lcpsoc3 \ cpsoc3.vhd <br><br><div class="spoiler">  <b class="spoiler_title">on voit séparément le compteur déjà connu de nous</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">component cy_psoc3_count7 generic(cy_period : std_logic_vector (6 downto 0) := "1111111"; cy_init_value : std_logic_vector (6 downto 0) := "0000000"; cy_route_ld : boolean := false; cy_route_en : boolean := false; cy_alt_mode : boolean := false); port (clock : in std_logic; reset : in std_logic; load : in std_logic; enable : in std_logic; count : out std_logic_vector (6 downto 0); tc : out std_logic); end component;</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">séparément - statut et gestion</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> attribute atomic_rtl of cy_psoc3_status : component is rtl_generic; attribute cpu_access of cy_psoc3_status : component is true; component cy_psoc3_statusi generic(cy_force_order : boolean := false; cy_md_select : std_logic_vector (6 downto 0) := "0000000"; cy_int_mask : std_logic_vector (6 downto 0) := "0000000"); port (reset : in std_logic := '0'; clock : in std_logic := '0'; status : in std_logic_vector (6 downto 0); interrupt : out std_logic); end component; attribute atomic_rtl of cy_psoc3_statusi : component is rtl_generic; attribute cpu_access of cy_psoc3_statusi : component is true; component cy_psoc3_control generic(cy_init_value : std_logic_vector (7 downto 0) := "00000000"; cy_force_order : boolean := false; cy_ctrl_mode_1 : std_logic_vector (7 downto 0) := "00000000"; cy_ctrl_mode_0 : std_logic_vector (7 downto 0) := "00000000"; cy_ext_reset : boolean := false); port (reset : in std_logic := '0'; clock : in std_logic := '0'; control : out std_logic_vector (7 downto 0)); end component;</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">séparément - synchroniseur</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">component cy_psoc3_sync port (clock : in std_logic := '0'; sc_in : in std_logic; sc_out : out std_logic); end component;</code> </pre><br></div></div><br>  Je répète que Verilog n'a pas du tout de version de ces déclarations (il n'y a que des modèles comportementaux dans le répertoire C: \ Program Files (x86) \ Cypress \ PSoC Creator \ 4.2 \ PSoC Creator \ warp \ lib \ sim, donc je pense que le réglage des bits les modes ne sont pas accessibles aux simples programmeurs. Lors de la lecture de cette section, il convient de garder ce fait à l'esprit. Quelque chose est donné à titre purement indicatif, il n'est pas soumis à nous programmeurs. </blockquote>  Pour activer le mode compteur, la sortie du compteur doit être sélectionnée dans les bits SC_OUT_CTI [1: 0].  Dans ce mode, le fonctionnement normal du registre de contrôle n'est pas disponible.  Dans le même temps, le registre d'état peut être utilisé pour des opérations de lecture, mais vous ne devez pas l'utiliser pour générer une interruption, car le registre de mappage de masque est également utilisé comme registre de période de compteur.  Le registre de période n'est pas détruit et conserve son état après le réveil.  Pour une période de N mesures, la valeur N-1 doit être chargée dans le registre de période.  La valeur N = 1 (la période est nulle) car la valeur du diviseur de fréquence n'est pas supportée et conduira à une unité constante à la sortie du TC (Terminal count, TC).  La disponibilité du mode SYNC dépend de l'utilisation ou non du contrôle dynamique (LD / EN).  S'il n'est pas utilisé, il n'affecte pas le mode SYNC.  S'il est utilisé, le mode SYNC n'est pas disponible. <br><br><h2>  21.3.3.5 Mode de synchronisation </h2><br>  Comme le montre la figure 21-37, le registre d'état peut fonctionner comme une horloge double 4 bits synchronisée avec la valeur SC_CLK actuelle si le bit SYNC MD est défini.  Ce mode peut être utilisé pour implémenter la synchronisation locale des signaux asynchrones (par exemple, les entrées GPIO).  Dans ce cas, les signaux synchronisés sont sélectionnés dans SC_IN [3: 0], les sorties sont acheminées vers les contacts SC_IO_OUT [3: 0], et SYNC MD bascule automatiquement les contacts SC_IO en mode de sortie.  Dans ce mode, le fonctionnement normal du registre d'état n'est pas disponible et le mode bit d'état collant est désactivé de force, quels que soient les paramètres de contrôle de mode.  Ce mode n'affecte pas le registre de contrôle.  Le compteur peut toujours être utilisé, mais avec des limitations.  Dans ce mode de fonctionnement, les entrées dynamiques (LD / EN) ne peuvent pas être utilisées. <br><br><img src="https://habrastorage.org/webt/ol/cw/6z/olcw6ztxrs5xqzb-9l0i6uyyqa8.png"><br>  <i>Figure 21-37.</i>  <i>Mode synchrone.</i> <br><br><h2>  21.3.3.6 Horloge d'état et de contrôle </h2><br>  Les registres de contrôle et d'état nécessitent une sélection d'horloge dans l'un des modes de fonctionnement suivants: <br><br><ul><li>  registre d'état avec n'importe quel bit en mode collant avec effacement après lecture, </li><li>  registre de contrôle en mode compteur, </li><li>  mode synchrone. </li></ul><br>  La synchronisation est affectée dans le module d'horloge et de réinitialisation.  Voir 21.3.4.  Module de commande d'horloge et de réinitialisation. <br><br><h2>  21.3.3.7 Registre de contrôle auxiliaire </h2><br>  Le registre de contrôle auxiliaire pour la lecture et l'écriture est un registre spécial qui contrôle l'équipement UDB dur.  Ce registre permet au CPU ou au DMA de contrôler dynamiquement les interruptions, les FIFO et le fonctionnement du compteur.  Les bits des registres et leur description sont donnés ci-dessous: <br><br><div class="scrollable-table"><table><tbody><tr><th colspan="8">  <b>Registre de commande auxiliaire</b> </th></tr><tr><td>  <b>7</b> </td><td>  <b>6</b> </td><td>  <b>5</b> </td><td>  <b>4</b> </td><td>  <b>3</b> </td><td>  <b>2</b> </td><td>  <b>1</b> </td><td>  <b>0</b> </td></tr><tr><td></td><td></td><td>  CNT <br>  COMMENCER </td><td>  INT EN </td><td>  FIFO1 <br>  LVL </td><td>  FIFO0 <br>  LVL </td><td>  FIFO1 <br>  CLR </td><td>  FIFO0 <br>  CLR </td></tr></tbody></table></div><br><h4>  Clear FIFO0 et FIFO1 (FIFO0 Clear, FIFO1 Clear) </h4><br>  Les bits FIFO0 CLR et FIFO1 CLR sont utilisés pour réinitialiser l'état des FIFO correspondants.  Lorsque 1 est écrit sur ces bits, l'état de la FIFO correspondante est réinitialisé.  Pour continuer le fonctionnement FIFO, il est nécessaire d'écrire 0. Ces bits restent armés Les FIFO fonctionnent comme de simples tampons à un octet sans état. <br><br><h4>  Niveau FIFO0 et FIFO1 (niveau FIFO0, niveau FIFO1) </h4><br>  Les bits FIFO0 LVL et FIFO1 LVL définissent le niveau auquel une FIFO de 4 octets augmente l'état du bus (lorsque le bus lit ou écrit dans FIFO).  La valeur d'état du bus FIFO dépend de la direction configurée, comme indiqué dans le tableau ci-dessous. <br><br>  Tableau 21-21.  Bits de contrôle de niveau FIFO. <br><div class="scrollable-table"><table><tbody><tr><th>  <b>FIFOx</b> <b><br></b>  <b>LVL</b> </th><th>  <b>Mode d'entrée</b> <b><br></b>  <b>(Le bus écrit au FIFO)</b> </th><th>  <b>Mode de sortie</b> <b><br></b>  <b>(Le bus lit depuis FIFO)</b> </th></tr><tr><td>  0 </td><td>  <b>Pas plein.</b> <br>  Vous pouvez écrire au moins 1 octet. <br></td><td>  <b>Pas vide.</b> <br>  Au moins 1 octet est disponible pour la lecture. </td></tr><tr><td>  1 </td><td>  <b>Dévasté d'au moins la moitié.</b> <br>  Vous pouvez écrire au moins 2 octets. </td><td>  <b>Au moins à moitié plein.</b> <br>  Au moins 2 octets sont disponibles pour la lecture. </td></tr></tbody></table></div><br><h4>  Activer l'interruption </h4><br>  Lorsque la logique de génération de registre d'état est activée, le bit INT EN permet le passage du signal d'interruption généré. <br><br><h4>  Démarrer un compteur / compte?  (Compte de début) </h4><br>  Le bit CNT START peut être utilisé pour démarrer et arrêter le compteur (disponible uniquement si les bits SC_OUT_CTL [1: 0] sont configurés pour le mode de sortie du compteur). <br><br><h2>  21.3.3.8 Résumé des registres de gestion et d'état </h2><br>  Le tableau ci-dessous résume les fonctions des registres de contrôle et d'état.  Veuillez noter que les registres de masque et de contrôle sont combinés avec des compteurs et des registres de période, et la valeur de ces registres ne dépend pas du mode de fonctionnement. <br><br>  Tableau 21-22.  Un bref résumé du fonctionnement des registres de gestion et de statut <br><div class="scrollable-table"><table><tbody><tr><th>  Le mode </th><th>  Gestion / Comptoir <br>  (Contrôle / comptage) </th><th>  Statut / Sync <br>  (Statut / SYNC) </th><th>  Superposition / période de masque <br>  (Masque / Période) </th></tr><tr><td>  Contrôle </td><td>  Control Out </td><td rowspan="2">  Status In ou SYNC </td><td>  Masque d'état de superposition </td></tr><tr><td>  Comptoir </td><td>  Counter Out </td><td>  Période de comptage <sup>a</sup> (période de comptage) </td></tr><tr><td>  Statut </td><td rowspan="2">  Contrôle ou décompte </td><td>  Statut dans </td><td>  Masque d'état de superposition </td></tr><tr><td>  Sync (SYNC) </td><td>  Sync (SYNC) </td><td>  Non disponible <sup>b</sup> (NA) </td></tr></tbody></table></div><br>  a.  - notez qu'en mode compteur, le registre de superposition de masque fonctionne comme un registre de période et ne peut pas fonctionner comme un registre de masque.  Par conséquent, la sortie d'interruption n'est pas disponible lorsque le mode compteur est activé. <br><br>  b.  - notez qu'en mode de synchronisation, le registre d'état n'est pas disponible et qu'il est donc impossible d'utiliser le registre de superposition de masque.  Cependant, il peut être utilisé comme registre de période pour le mode compteur. <br><br>  À suivre ... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443380/">https://habr.com/ru/post/fr443380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443364/index.html">Comment une holding médiatique peut lancer 12 startups prospères par an</a></li>
<li><a href="../fr443368/index.html">Nous préparons une recherche plein texte dans Postgres. 2e partie</a></li>
<li><a href="../fr443372/index.html">Backend sur CodeFest. Des tripes commandées?</a></li>
<li><a href="../fr443376/index.html">Géré pour trouver des dizaines de stockages d'entreprise Box.com qui divulguent des données d'Apple, Herbalife, etc.</a></li>
<li><a href="../fr443378/index.html">Nous écrivons un client http hautes performances en utilisant fasthttp comme exemple. Alexander Valyalkin (VertaMedia)</a></li>
<li><a href="../fr443382/index.html">Fintech Digest: Mir Pay pour Android, levant l'interdiction de retirer de l'argent des portefeuilles anonymes, les startups de l'IA ne sont pas exactement de l'IA</a></li>
<li><a href="../fr443384/index.html">Slurm et MegaSlerm à Moscou fin mai</a></li>
<li><a href="../fr443386/index.html">Comment obtenir le journal de sécurité avec un utilisateur non administrateur</a></li>
<li><a href="../fr443388/index.html">Contrôle d'éclairage à plusieurs niveaux basé sur KTS NPL</a></li>
<li><a href="../fr443390/index.html">Caractéristiques de l'anglais australien</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>