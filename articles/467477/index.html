<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📭 💙 🤳🏾 Kubernetes 1.16: Aspectos destacados 🔑 👆🏼 🛶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy, miércoles, se realizará el próximo lanzamiento de Kubernetes: 1.16. De acuerdo con la tradición que se ha desarrollado para nuestro blog, por déc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes 1.16: Aspectos destacados</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/467477/"><img src="https://habrastorage.org/webt/6b/oi/xq/6boixq7wqypazw43aysbw8y9xty.png"><br><br>  Hoy, miércoles, se realizará el próximo lanzamiento de Kubernetes: 1.16.  De acuerdo con la tradición que se ha desarrollado para nuestro blog, por décimo aniversario, estamos hablando de los cambios más significativos en la nueva versión. <br><br>  La información utilizada para preparar este material se toma de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la tabla de seguimiento de mejoras de Kubernetes</a> , <a href="">CHANGELOG-1.16</a> y cuestiones relacionadas, solicitudes de extracción, así como las Propuestas de mejora de Kubernetes (KEP).  ¡Entonces vamos! .. <a name="habracut"></a><br><br><h2>  Nudos </h2><br>  Un número realmente grande de innovaciones notables (en el estado de versión alfa) se presentan en el lado de los nodos de los grupos K8s (Kubelet). <br><br>  En primer lugar, se presentan los llamados <b>" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">contenedores efímeros</a> " <i>(Contenedores</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">efímeros</a> <i>)</i> , diseñados para simplificar el proceso de depuración en pods</b> .  El nuevo mecanismo le permite ejecutar contenedores especiales que comienzan en el espacio de nombres de los pods existentes y viven por un corto tiempo.  Su propósito es interactuar con otros pods y contenedores para resolver cualquier problema y depuración.  Para esta característica, se <code>kubectl debug</code> un nuevo <code>kubectl debug</code> , similar en esencia a <code>kubectl exec</code> : solo que en lugar de iniciar el proceso en el contenedor (como en el caso de <code>exec</code> ), inicia el contenedor en el pod.  Por ejemplo, dicho comando conectará un nuevo contenedor al pod: <br><br><pre> <code class="bash hljs">kubectl debug -c debug-shell --image=debian target-pod -- bash</code> </pre> <br>  Los detalles sobre contenedores efímeros (y ejemplos de su uso) se pueden encontrar en el <a href="">KEP correspondiente</a> .  La implementación actual (en K8s 1.16) es la versión alfa, y entre los criterios para su transferencia a la versión beta está "probar la API de Contenedores Efímeros para al menos 2 lanzamientos [Kubernetes]". <br><br>  <i><b>NB</b> : en esencia, incluso el nombre de la característica se asemeja al plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">kubectl-debug</a> ya existente, sobre el que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ya escribimos</a> .</i>  <i>Se supone que con la llegada de los contenedores efímeros, se detendrá el desarrollo de un complemento externo separado.</i> <br><br>  Otra innovación, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>PodOverhead</code></a> está diseñada para proporcionar un <b>mecanismo para calcular los costos generales de las cápsulas</b> , que pueden variar mucho según el tiempo de ejecución utilizado.  Como ejemplo, los autores de <a href="">esta KEP</a> citan Kata Containers, que requieren el lanzamiento del kernel invitado, el agente kata, el sistema init, etc.  Cuando los gastos generales se vuelven tan grandes, no se pueden ignorar, lo que significa que se necesita una forma de tenerlo en cuenta para nuevas cuotas, planificación, etc.  Para implementarlo, el campo <code>Overhead *ResourceList</code> se ha agregado a <code>PodSpec</code> (en comparación con los datos en <code>RuntimeClass</code> , si se usa uno). <br><br>  Otra innovación notable es el <i>Node Topology Manager</i> , diseñado para unificar el enfoque para ajustar la asignación de recursos de hardware para varios componentes en Kubernetes.  Esta iniciativa es causada por la creciente demanda de varios sistemas modernos (del campo de las telecomunicaciones, el aprendizaje automático, los servicios financieros, etc.) de computación paralela de alto rendimiento y minimizando los retrasos en la ejecución de operaciones, para lo cual utilizan las capacidades avanzadas de aceleración de CPU y hardware.  Tales optimizaciones en Kubernetes se han logrado hasta ahora gracias a componentes dispares (administrador de CPU, administrador de dispositivos, CNI), y ahora agregarán una única interfaz interna que unifica el enfoque y simplifica la conexión de nuevos componentes similares, los llamados conscientes de la topología, en el lado de Kubelet.  Los detalles están en el <a href="">KEP correspondiente</a> . <br><br><img src="https://habrastorage.org/webt/tq/bs/vr/tqbsvryzr9tnxv_9uldn-ofx1es.png"><br>  <i>Diagrama de componentes del administrador de topología</i> <br><br>  La siguiente característica es <b>verificar los contenedores durante el inicio <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sonda de inicio</a> )</i></b> .  Como ya sabe, para los contenedores que se ejecutan durante mucho tiempo, es difícil obtener el estado actual: se los "mata" antes del inicio real de la operación o terminan en un punto muerto durante mucho tiempo.  Una nueva verificación (habilitada a través de la puerta de funciones llamada <code>StartupProbeEnabled</code> ) cancela, o más bien <code>StartupProbeEnabled</code> , la acción de cualquier otra verificación hasta el momento en que el pod ha terminado su lanzamiento.  Por esta razón, la característica originalmente se llamaba <a href="">espera de inicio de prueba de podness de inicio de pod</a> .  Para los pods que tardan mucho en iniciarse, puede sondear el estado en intervalos de tiempo relativamente cortos. <br><br>  Además, inmediatamente en estado beta se agrega una mejora para RuntimeClass, agregando soporte para "clústeres heterogéneos".  Con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RuntimeClass Scheduling,</a> ahora no es necesario que cada nodo tenga soporte para cada RuntimeClass: para los pods, puede elegir RuntimeClass sin pensar en la topología del clúster.  Anteriormente, para lograr esto, para que los pods aparecieran en nodos con soporte para todo lo que necesitaban, tenían que asignar reglas apropiadas a NodeSelector y tolerancias.  <a href="">KEP</a> habla sobre ejemplos de uso y, por supuesto, detalles de implementación. <br><br><h2>  Red </h2><br>  Dos características importantes de la red que aparecieron por primera vez (en la versión alfa) en Kubernetes 1.16 son: <br><br><ul><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soporte para una</a> pila de red dual - IPv4 / IPv6</b> - y su correspondiente "comprensión" a nivel de pods, nodos, servicios.  Incluye la interacción de IPv4 a IPv4 e IPv6 a IPv6 entre pods, desde pods a servicios externos, implementaciones de referencia (en el marco de los complementos Bridge CNI, PTP CNI y Host-Local IPAM), así como a la inversa Compatible con clústeres de Kubernetes que funcionan solo a través de IPv4 o IPv6.  Los detalles de implementación están en <a href="">KEP</a> . <br><br>  Un ejemplo de la salida de dos tipos de direcciones IP (IPv4 e IPv6) en la lista de pods: <br><br><pre> <code class="bash hljs">kube-master<span class="hljs-comment"><span class="hljs-comment"># kubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE nginx-controller 1/1 Running 0 20m fd00:db8:1::2,192.168.1.3 kube-minion-1 kube-master#</span></span></code> </pre> <br></li><li>  <b>La nueva API para Endpoint</b> es la <a href="">API EndpointSlice</a> .  Resuelve los problemas de la API de Endpoint existente con rendimiento / escalabilidad que afecta a varios componentes en el plano de control (apiserver, etcd, endpoints-controller, kube-proxy).  La nueva API se agregará al grupo Discovery API y podrá servir decenas de miles de puntos finales de back-end en cada servicio en un clúster que consta de mil nodos.  Para hacer esto, cada Servicio se asigna a N objetos de <code>EndpointSlice</code> , cada uno de los cuales por defecto no tiene más de 100 puntos finales (el valor es configurable).  La API EndpointSlice también brindará oportunidades para su desarrollo futuro: soporte para muchas direcciones IP para cada pod, nuevos estados para puntos finales (no solo <code>Ready</code> y <code>NotReady</code> ), subconjunto dinámico para puntos finales. </li></ul><br>  El <a href="">finalizador</a> presentado en la última versión llamada <code>service.kubernetes.io/load-balancer-cleanup</code> y adjuntado a cada servicio con el tipo <code>LoadBalancer</code> avanzado a la versión beta.  En el momento de la eliminación de dicho servicio, evita la eliminación real del recurso hasta que se complete la "limpieza" de todos los recursos correspondientes del equilibrador. <br><br><h2>  Maquinaria API </h2><br>  El verdadero "hito de estabilización" se fija en el área del servidor API de Kubernetes y la interacción con él.  En muchos aspectos, esto sucedió debido a la <b>transferencia al estado estable de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CustomResourceDefinitions</a> (CRD)</b> que <b>no necesitaba una presentación especial</b> , que tenía un estado beta desde el distante Kubernetes 1.7 (¡y esto es junio de 2017!).  La misma estabilización llegó a las características relacionadas con ellos: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Subresources"</a> con <code>/status</code> y <code>/scale</code> para CustomResources; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conversión de</a> versión para CRD, basada en un webhook externo; </li><li>  valores predeterminados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recientemente introducidos</a> (en K8s 1.15) <i>(</i> valores predeterminados <i>)</i> y eliminación automática de campos <i>(poda)</i> para CustomResources; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La posibilidad de</a> utilizar el esquema OpenAPI v3 para crear y publicar la documentación de OpenAPI utilizada para validar los recursos CRD en el lado del servidor. </li></ul><br>  Otro mecanismo que ha sido familiar para los administradores de Kubernetes: el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>webhook de admisión</b></a> , también ha estado en estado beta durante mucho tiempo (desde K8s 1.9) y ahora se ha declarado estable. <br><br>  Otras dos características llegaron a beta: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aplicar en el lado del servidor</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mirar marcadores</a> . <br><br>  Y la única innovación significativa en la versión alfa fue el <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rechazo</a> de <code>SelfLink</code></b> , un URI especial que representa el objeto especificado y es parte de <code>ObjectMeta</code> y <code>ListMeta</code> (es decir, parte de cualquier objeto en Kubernetes).  ¿Por qué rechazarlo?  La motivación "simple" <a href="">suena</a> como la ausencia de razones reales (insuperables) para que este campo continúe existiendo.  Las razones más formales son para optimizar el rendimiento (eliminar un campo innecesario) y simplificar el trabajo del genérico-apiserver, que se ve obligado a procesar dicho campo de una manera especial (este es el único campo que se establece justo antes de que el objeto se serialice).  La verdadera "obsolescencia" (en la versión beta) de <code>SelfLink</code> pasará a la versión 1.20 de Kubernetes, y la versión final - 1.21. <br><br><h2>  Almacenamiento de datos </h2><br>  El trabajo principal en el campo del almacenamiento, como en versiones anteriores, se observa en el campo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">soporte para CSI</a> .  Los principales cambios aquí son: <br><br><ul><li>  por primera vez (en la versión alfa) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> <b>ha aparecido</b> la <b>compatibilidad con los complementos CSI para los nodos de trabajo de Windows</b> : la forma actual de trabajar con repositorios reemplazará los complementos en árbol en el núcleo Kubernetes y los complementos FlexVolume basados ​​en Powershell de Microsoft; <br><br><img src="https://habrastorage.org/webt/4_/6o/h2/4_6oh2zuutje1tcvwqwzhi385m0.png"><br>  <i>Esquema de implementación del complemento Kubernetes Windows CSI</i> <br></li><li>  la capacidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de cambiar el tamaño de los volúmenes CSI</a> , introducida en K8s 1.12, ha crecido a una versión beta; </li><li>  La posibilidad de utilizar CSI para crear volúmenes efímeros locales ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soporte de volumen en línea CSI</a> ) ha alcanzado un "aumento" similar (de alfa a beta). </li></ul><br>  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">función para clonar volúmenes que</a> aparecieron en la versión anterior de Kubernetes (usando PVC existentes como <code>DataSource</code> para crear nuevos PVC) ahora también ha recibido el estado beta. <br><br><h2>  Planificador </h2><br>  Dos cambios notables en la planificación (ambos en versión alfa): <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>EvenPodsSpreading</code></a> es la capacidad de <b>usar</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>EvenPodsSpreading</code></a> <b>para "distribuir equitativamente" cargas de cargas en lugar de unidades lógicas de aplicación</b> (como Deployment y ReplicaSet) y ajustar esta distribución (como un requisito estricto o como una condición leve, es decir, prioridad).  La función ampliará las capacidades de distribución existentes de los pods planificados, ahora limitados por las <code>PodAntiAffinity</code> <code>PodAffinity</code> y <code>PodAntiAffinity</code> , brindando a los administradores más control sobre este problema, lo que significa una mejor accesibilidad y un consumo de recursos optimizado.  Los detalles están en el <a href="">KEP</a> . </li><li>  Uso de la <i>política de BestFit</i> en la <i>función de prioridad RequestedToCapacityRatio</i> durante la programación del pod, que permite que el <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">empaquetado bin</a></b> ("empaquetado en contenedores") se use tanto para recursos centrales (procesador, memoria) como extendido (como GPU).  Ver <a href="">KEP para</a> más detalles. <br><br><img src="https://habrastorage.org/webt/4z/gx/zm/4zgxzmdtmhyg-mmjnw-cccyw8wq.gif"><br>  <i>Programación de pod: antes de usar la política de mejor ajuste (directamente a través del planificador predeterminado) y usarla (a través del extensor del planificador)</i> </li></ul><br>  Además, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se presenta la</a> oportunidad de crear sus propios complementos para el planificador fuera del árbol de desarrollo principal de Kubernetes (fuera del árbol). <br><br><h2>  Otros cambios </h2><br>  También en la versión 1.16 de Kubernetes, puede observar la <b>iniciativa de <a href="">poner</a> las métricas existentes en orden completo</b> , o más precisamente, de acuerdo con los <a href="">requisitos oficiales</a> para la instrumentación de K8.  Básicamente se basan en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> relevante de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prometheus</a> .  Las inconsistencias se formaron por varias razones (por ejemplo, algunas métricas simplemente se crearon antes de que aparecieran las instrucciones actuales), y los desarrolladores decidieron que era hora de poner todo en un solo estándar, "en línea con el resto del ecosistema Prometheus".  La implementación actual de esta iniciativa tiene el estado de la versión alfa, que aumentará gradualmente en futuras versiones de Kubernetes a beta (1.17) y estable (1.18). <br><br>  Además, se pueden observar los siguientes cambios: <br><br><ul><li>  <b>Desarrollo de soporte de Windows</b> con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">advenimiento</a> de la utilidad Kubeadm para este sistema operativo (versión alfa), la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">posibilidad de</a> <code>RunAsUserName</code> para contenedores de Windows (versión alfa), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mejora del</a> soporte para la Cuenta de servicio administrado grupal (gMSA) a la versión beta, soporte de montaje / conexión para volúmenes vSphere. </li><li>  <b>Mecanismo de compresión de datos</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rediseñado</a> <b>en respuestas API</b> .  Anteriormente, se usaba un filtro HTTP para estos fines, que imponía una serie de restricciones que impedían su inclusión por defecto.  Ahora funciona la "compresión transparente de solicitudes": los clientes que envían <code>Accept-Encoding: gzip</code> en el encabezado reciben una respuesta comprimida en GZIP si su tamaño supera los 128 Kb.  Los clientes en Go admiten automáticamente la compresión (envíe el encabezado deseado), por lo que notan inmediatamente una disminución en el tráfico.  (Para otros idiomas, pueden ser necesarias modificaciones menores). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Se hizo posible</a> <b>escalar HPA de / a cero pods en función de métricas externas</b> .  Si el escalado se basa en objetos / métricas externas, cuando las cargas de trabajo estén inactivas, puede escalar automáticamente a 0 réplicas para ahorrar recursos.  Esta característica debería ser especialmente útil para los casos en que los trabajadores solicitan recursos de GPU, y la cantidad de diferentes tipos de trabajadores inactivos excede la cantidad de GPU disponibles. </li><li>  Un nuevo cliente - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>k8s.io/client-go/metadata.Client</code></a> - para el acceso "generalizado" a los objetos.  Está diseñado para obtener fácilmente metadatos (es decir, la subsección de <code>metadata</code> ) de los recursos del clúster y realizar operaciones con ellos desde la categoría de recolección de basura y cuotas. </li><li>  Kubernetes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ahora se puede construir</a> sin proveedores de nube desactualizados ("incorporado" en el árbol) (versión alfa). </li><li>  La capacidad experimental (versión alfa) para aplicar parches de kustomize durante las operaciones de <code>init</code> , <code>join</code> y <code>upgrade</code> se ha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">agregado a la</a> utilidad kubeadm.  Para obtener detalles sobre cómo usar la <code>--experimental-kustomize</code> , consulte <a href="">KEP</a> . </li><li>  El nuevo punto final para apiserver es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>readyz</code></a> , que le permite exportar información de preparación.  El servidor API también tiene un indicador: <code>--maximum-startup-sequence-duration</code> , que le permite ajustar sus reinicios. </li><li>  Dos <b>características para Azure se</b> declaran estables: Soporte para zonas de disponibilidad y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">grupo de recursos cruzados</a> (RG).  Además, Azure agregó: <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soporte de autenticación</a> AAD y ADFS </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anotación</a> <code>service.beta.kubernetes.io/azure-pip-name</code> para especificar la IP pública del equilibrador de carga; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Capacidad para</a> configurar <code>LoadBalancerName</code> y <code>LoadBalancerResourceGroup</code> . </li></ul></li><li>  AWS tiene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">soporte</a> para EBS en Windows y llamadas de API EC2 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">optimizadas</a> <code>DescribeInstances</code> . </li><li>  Kubeadm ahora <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">migra su</a> configuración CoreDNS por sí solo cuando se actualiza a CoreDNS. </li><li>  Los archivos binarios, <b>etc.,</b> en la imagen de Docker correspondiente se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hicieron</a> ejecutables en todo el mundo, lo que le permite ejecutar esta imagen sin la necesidad de privilegios de root.  Además, la imagen de migración de etcd <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dejó de ser</a> compatible con la versión de etcd2. </li><li>  <a href="">Cluster Autoscaler 1.16.0</a> cambió a usar distroless como imagen base, mejor rendimiento y nuevos proveedores de nube (DigitalOcean, Magnum, Packet). </li><li>  Actualizaciones en el software usado / dependiente: Go 1.12.9, etcd 3.3.15, CoreDNS 1.6.2. </li></ul><br><h2>  PS </h2><br>  Lea también en nuestro blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes 1.15: Una visión general de las innovaciones clave</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes 1.14: una visión general de las innovaciones clave</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes 1.13: Una visión general de las innovaciones clave</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes 1.12: Una visión general de las innovaciones clave</a> ". </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467477/">https://habr.com/ru/post/467477/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467463/index.html">Solo división, o cómo crear una teoría matemática y ganar $ 400K con ella. Serie tres, final</a></li>
<li><a href="../467465/index.html">¿La nube salvará los teléfonos inteligentes con un presupuesto ultrabajo?</a></li>
<li><a href="../467471/index.html">Soul Mikrotik contra ILV sin alma y el mismo proveedor</a></li>
<li><a href="../467473/index.html">Y más sobre tipos</a></li>
<li><a href="../467475/index.html">Devuelva Thread.Abort () a .NET Core. Entrega de aplicaciones con su versión de CoreCLR y CoreFX</a></li>
<li><a href="../467479/index.html">Kir Shatrov: Shopify comenzó con Rails y aquí les encanta este marco.</a></li>
<li><a href="../467485/index.html">Resolución de problemas con pwnable.kr 23 - calculadora md5. Nos ocupamos de Stack Canary. Conexión de bibliotecas C en python</a></li>
<li><a href="../467487/index.html">Sobre el futuro de los pagos de blockchain y criptomonedas</a></li>
<li><a href="../467489/index.html">Son variables estáticas extrañas en PHP</a></li>
<li><a href="../467493/index.html">Cómo volverse menos accesible para un atacante potencial en Internet. Experiencia personal y observaciones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>