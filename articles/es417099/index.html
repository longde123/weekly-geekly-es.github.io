<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÖæÔ∏è ‚ÜïÔ∏è üö¥üèº ¬øC√≥mo escrib√≠ la biblioteca est√°ndar de C ++ 11 o por qu√© boost es tan aterrador? Cap√≠tulo 2 ‚úãüèø ü§úüèº üóæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Resumen de partes anteriores 
 Debido a las restricciones en la capacidad de usar compiladores de C ++ 11, y por la falta de alternativa, boost quer√≠a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øC√≥mo escrib√≠ la biblioteca est√°ndar de C ++ 11 o por qu√© boost es tan aterrador? Cap√≠tulo 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417099/"><img src="https://habrastorage.org/webt/lr/zq/if/lrzqifvfeajppx2fdvqbxnwf4ce.png" alt="S√≠, s√≠, con este lema me apresur√© a la batalla." width="300" height="350" align="left"><h3>  Resumen de partes anteriores </h3><br>  Debido a las restricciones en la capacidad de usar compiladores de C ++ 11, y por la falta de alternativa, boost quer√≠a escribir su propia implementaci√≥n de la biblioteca est√°ndar de C ++ 11 sobre la biblioteca de C ++ 98 / C ++ 03 suministrada con el compilador. <br><br>  Adem√°s de los archivos de encabezado est√°ndar, se <b>agregaron type_traits</b> , <b>thread</b> , <b>mutex</b> , <b>chrono</b> , <b>nullptr.h</b> <b>que</b> implementa <i>std :: nullptr_t</i> y <b>core.h</b> donde se <b>agregaron</b> macros relacionadas con la <b>funcionalidad dependiente del</b> compilador, as√≠ como expandir la biblioteca est√°ndar. <br><br>  Enlace a GitHub con el resultado de hoy para impacientes y no lectores: <br><br><blockquote>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los compromisos y las cr√≠ticas constructivas son bienvenidos</a></b> </blockquote><a name="habracut"></a><br><h4>  Tabla de contenidos </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introduccion</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cap√≠tulo 1. Viam supervadet vadens</a> <br>  <b>Cap√≠tulo 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cap√≠tulo 3. Encontrar la implementaci√≥n nullptr perfecta</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cap√≠tulo 4. Magia de plantilla de C ++</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.1 Comenzamos peque√±o</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.2 Acerca de cu√°ntos errores milagrosos compila el registro para nosotros</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.3 Punteros y todo-todo-todo</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.4 ¬øQu√© m√°s se necesita para la biblioteca de plantillas?</a> <br>  Capitulo 5 <br>  ... <br><br><h3>  Cap√≠tulo 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif </h3><br>  Despu√©s de que todo el c√≥digo fue peinado un poco y dividido por encabezados "est√°ndar" en un <b>stdex de espacio de nombres separado,</b> proced√≠ a completar <b>type_traits</b> , <b>nullptr.h</b> y a lo largo del mismo <b>core.h</b> , que conten√≠a macros para determinar la versi√≥n del est√°ndar utilizado por el compilador y <b>admitirlo</b> <b>Nullptr</b> <b>nativo</b> , <b>char16_t</b> , <b>char32_t</b> y <b>static_assert</b> . <br><br>  En teor√≠a, todo es simple: de acuerdo con el est√°ndar C ++ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">(cl√°usula 14.8), el</a> <b>compilador</b> debe definir la macro <b>__cplusplus y</b> debe coincidir con la versi√≥n del est√°ndar admitido: <br><br><pre><code class="cpp hljs">C++ pre-C++<span class="hljs-number"><span class="hljs-number">98</span></span>: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 1 C++98: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L C++98 + TR1: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ??? C++11: #define __cplusplus 201103L C++14: #define __cplusplus 201402L C++17: #define __cplusplus 201703L</span></span></span></span></code> </pre> <br>  en consecuencia, el c√≥digo para determinar la disponibilidad de soporte es trivial: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (__cplusplus &gt;= 201103L) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  C++ 11   #define _STDEX_NATIVE_CPP11_SUPPORT //   11  (nullptr, static_assert) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT //    char16_t, char32_t #endif</span></span></span></span></code> </pre><br><img src="https://habrastorage.org/webt/oq/qj/y8/oqqjy8dy_l8fyahlkfb3m-6uv3u.jpeg" alt="imagen" width="300" height="250" align="left">  De hecho, no todo es tan simple y ahora comienzan las muletas interesantes con un rastrillo. <br><br>  En primer lugar, no todos, o m√°s bien ninguno, de los compiladores no implementan el siguiente est√°ndar de forma completa e inmediata.  Por ejemplo, en Visual Studio 2013, <b>constexpr estuvo</b> ausente <b>durante</b> mucho tiempo, mientras se afirmaba que era compatible con C ++ 11, con la advertencia de que la implementaci√≥n no estaba completa.  Es decir, <b>auto</b> , por favor, <b>static_assert</b> , es igual de f√°cil (incluso de MS VS anteriores), pero <b>constexpr</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no lo</a> es.  En segundo lugar, no todos los compiladores (y esto es a√∫n m√°s sorprendente) exponen correctamente esta definici√≥n y la actualizan de manera oportuna.  Inesperadamente, en el mismo compilador, Visual Studio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no cambi√≥ la versi√≥n de __cplusplus</a> <b>define</b> desde las primeras versiones del compilador, aunque se ha declarado por completo el soporte para C ++ 11 (lo cual tampoco es cierto, para lo cual hay rayos separados de descontento, tan pronto como la conversaci√≥n llega a la funcionalidad espec√≠fica del "nuevo "11 desarrolladores est√°ndar dicen de inmediato que no hay un preprocesador C99, no hay otras" caracter√≠sticas ").  Y la situaci√≥n se ve agravada por el hecho de que los compiladores est√°ndar pueden establecer esta definici√≥n en diferente de los valores anteriores, si no cumplen totalmente con los est√°ndares declarados.  Ser√≠a l√≥gico suponer, por ejemplo, tal desarrollo de definiciones para una macro dada (con la introducci√≥n de una nueva funcionalidad, aumentar el n√∫mero oculto detr√°s de esta definici√≥n): <br><br><pre> <code class="cpp hljs">standart C++<span class="hljs-number"><span class="hljs-number">98</span></span>: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// C++98 standart C++98 + TR1: #define __cplusplus 200311L // C++03 nonstandart C++11: #define __cplusplus 200411L // C++03 + auto and dectype nonstandart C++11: #define __cplusplus 200511L // C++03 + auto, dectype and constexpr(partly) ... standart C++11: #define __cplusplus 201103L // C++11</span></span></span></span></code> </pre><br>  Pero al mismo tiempo, ninguno de los principales compiladores populares est√° "desgastado" con esta caracter√≠stica. <br><br>  Debido a todo esto (no tengo miedo de esta palabra), ahora para cada compilador no est√°ndar tiene que escribir sus propias comprobaciones espec√≠ficas para averiguar qu√© est√°ndar de C ++ y en qu√© medida es compatible.  La buena noticia es que necesitamos aprender algunas funciones del compilador para que funcionen correctamente.  Primero, ahora agregamos la verificaci√≥n de versi√≥n para Visual Studio a trav√©s de la macro <b>_MSC_VER</b> , exclusiva de este compilador.  Dado que en mi arsenal de compiladores compatibles tambi√©n hay C ++ Borland Builder 6.0, cuyos desarrolladores, a su vez, estaban muy interesados ‚Äã‚Äãen mantener la compatibilidad con Visual Studio (incluidas sus "caracter√≠sticas" y errores), de repente tambi√©n aparece esta macro.  Para los compiladores compatibles con clang, hay una macro no est√°ndar <b>__has_feature (</b> feature_name <b>)</b> , que le permite averiguar si el compilador admite esta o aquella funcionalidad.  Como resultado, el c√≥digo se hincha para: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif</span></span></span></span></code> </pre><br>  ¬øQuieres llegar a m√°s compiladores?  Agregamos controles para Codegear C ++ Builder, que es el heredero de Borland (en sus peores manifestaciones, pero m√°s sobre eso m√°s adelante): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif</span></span></span></span></code> </pre><br>  Tambi√©n vale la pena se√±alar que, dado que Visual Studio ya ha implementado el soporte <b>nullptr</b> de la versi√≥n del compilador <b>_MSC_VER 1600</b> , as√≠ como los tipos <b>incorporados char16_t</b> y <b>char32_t</b> , debemos manejar esto correctamente.  Se agregaron algunos controles m√°s: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if ((!defined(_MSC_VER) || _MSC_VER &lt; 1600) &amp;&amp; !defined(_STDEX_NATIVE_CPP11_SUPPORT)) #define _STDEX_IMPLEMENTS_NULLPTR_SUPPORT #else #define _STDEX_NATIVE_NULLPTR_SUPPORT #endif #if (_MSC_VER &gt;= 1600) #ifndef _STDEX_NATIVE_CPP11_TYPES_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif</span></span></span></span></code> </pre><br>  Al mismo tiempo, verificaremos el soporte de C ++ 98, ya que para los compiladores sin √©l no habr√° algunos archivos de encabezado de la biblioteca est√°ndar, y no podemos verificar la ausencia de ellos utilizando el compilador. <br><br><div class="spoiler">  <b class="spoiler_title">Opci√≥n completa</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if ((!defined(_MSC_VER) || _MSC_VER &lt; 1600) &amp;&amp; !defined(_STDEX_NATIVE_CPP11_SUPPORT)) #define _STDEX_IMPLEMENTS_NULLPTR_SUPPORT #else #define _STDEX_NATIVE_NULLPTR_SUPPORT #endif #if (_MSC_VER &gt;= 1600) #ifndef _STDEX_NATIVE_CPP11_TYPES_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if _MSC_VER // Visual C++ fallback #define _STDEX_NATIVE_MICROSOFT_COMPILER_EXTENSIONS_SUPPORT #define _STDEX_CDECL __cdecl #if (__cplusplus &gt;= 199711L) #define _STDEX_NATIVE_CPP_98_SUPPORT #endif #endif // C++ 98 check: #if ((__cplusplus &gt;= 199711L) &amp;&amp; ((defined(__INTEL_COMPILER) || defined(__clang__) || (defined(__GNUC__) &amp;&amp; ((__GNUC__ &gt; 4) || (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 4)))))) #ifndef _STDEX_NATIVE_CPP_98_SUPPORT #define _STDEX_NATIVE_CPP_98_SUPPORT #endif #endif</span></span></span></span></code> </pre><br></div></div><br>  Y ahora las configuraciones voluminosas de boost est√°n comenzando a aparecer en mi memoria en la que muchos desarrolladores trabajadores escribieron todas estas macros dependientes del compilador e hicieron un mapa de lo que es compatible y lo que no es por un compilador espec√≠fico de una versi√≥n espec√≠fica, de lo cual personalmente me siento inc√≥modo, No quiero mirarlo ni tocarlo nunca m√°s.  Pero la buena noticia es que puedes detenerte all√≠.  Al menos esto es suficiente para m√≠ para admitir los compiladores m√°s populares, pero si encuentra una inexactitud o desea agregar otro compilador, estar√© muy feliz de aceptar la solicitud de extracci√≥n. <br><br>  Un gran logro en comparaci√≥n con el impulso, creo que fue posible mantener la difusi√≥n de las macros dependientes del compilador en todo el c√≥digo, lo que hace que el c√≥digo sea m√°s limpio y f√°cil de entender, y tampoco acumule docenas de archivos de configuraci√≥n para cada sistema operativo y para cada compilador.  Hablaremos de las desventajas de este enfoque un poco m√°s adelante. <br><br>  En esta etapa, ya podemos comenzar a conectar la funcionalidad faltante de los 11 est√°ndares, y lo primero que presentamos es <b>static_assert</b> . <br><br><h3>  static_assert </h3><br>  Definimos la estructura <i>StaticAssertion</i> , que tomar√° un valor booleano como un par√°metro de plantilla: existir√° nuestra condici√≥n, si no se cumple (la expresi√≥n es <b>falsa</b> ), se producir√° un error al compilar una plantilla no especializada.  Y otra estructura ficticia para recibir <b>sizeof (</b> <i>StaticAssertion</i> <b>)</b> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> stdex { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticAssertion</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticAssertion</span></span></span><span class="hljs-class">&lt;true&gt; {</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// StaticAssertion&lt;true&gt; template&lt;int i&gt; struct StaticAssertionTest { }; // StaticAssertionTest&lt;int&gt; } }</span></span></code> </pre><br>  y m√°s macro magia <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message) static_assert((expression), #message) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// no C++11 support #define CONCATENATE(arg1, arg2) CONCATENATE1(arg1, arg2) #define CONCATENATE1(arg1, arg2) CONCATENATE2(arg1, arg2) #define CONCATENATE2(arg1, arg2) arg1##arg2 #define STATIC_ASSERT(expression, message)\ struct CONCATENATE(__static_assertion_at_line_, __LINE__)\ {\ stdex::detail::StaticAssertion&lt;static_cast&lt;bool&gt;((expression))&gt; CONCATENATE(CONCATENATE(CONCATENATE(STATIC_ASSERTION_FAILED_AT_LINE_, __LINE__), _WITH__), message);\ };\ typedef stdex::detail::StaticAssertionTest&lt;sizeof(CONCATENATE(__static_assertion_at_line_, __LINE__))&gt; CONCATENATE(__static_assertion_test_at_line_, __LINE__) #ifndef _STDEX_NATIVE_NULLPTR_SUPPORT #define static_assert(expression, message) STATIC_ASSERT(expression, ERROR_MESSAGE_STRING) #endif #endif</span></span></span></span></code> </pre><br>  uso: <br><br><pre> <code class="cpp hljs">STATIC_ASSERT(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*) == <span class="hljs-number"><span class="hljs-number">4</span></span>, non_x32_platform_is_unsupported);</code> </pre><br><blockquote>  Una diferencia importante entre mi implementaci√≥n y la <a href="">est√°ndar</a> es que no hay sobrecarga de esta palabra clave <u>sin</u> decirle al usuario.  Esto se debe al hecho de que en C ++ es imposible definir varias definiciones con diferentes n√∫meros de argumentos pero un solo nombre, y una implementaci√≥n sin mensaje es mucho menos √∫til que la opci√≥n seleccionada.  Esta caracter√≠stica lleva al hecho de que, en esencia, <b>STATIC_ASSERT</b> en mi implementaci√≥n es la versi√≥n agregada ya en C ++ 11. </blockquote>  Echemos un vistazo a lo que sucedi√≥.  Como resultado de verificar las versiones de <b>__cplusplus</b> y las macros de compilaci√≥n no est√°ndar, tenemos suficiente informaci√≥n sobre el soporte de C ++ 11 (y, por <b>lo</b> tanto, <b>static_assert</b> ), expresada por la <b>definici√≥n</b> _STDEX_NATIVE_CPP11_SUPPORT.  Por lo tanto, si esta macro est√° definida, simplemente podemos usar el <b>static_assert</b> est√°ndar: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message) static_assert((expression), #message)</span></span></code> </pre><br><blockquote>  Tenga en cuenta que el segundo par√°metro de la macro <b>STATIC_ASSERT</b> no es una <b>cadena literal en absoluto,</b> y por lo tanto, utilizando el operador de preprocesador <b>#</b> convertiremos el par√°metro del <i>mensaje</i> en una cadena para su transmisi√≥n al <b>static_assert</b> est√°ndar. </blockquote>  Si no tenemos soporte del compilador, procedemos a nuestra implementaci√≥n.  Para comenzar, declararemos macros auxiliares para "pegar" cadenas (el operador del preprocesador <b>##</b> es el √∫nico responsable de esto). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE(arg1, arg2) CONCATENATE1(arg1, arg2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE1(arg1, arg2) CONCATENATE2(arg1, arg2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE2(arg1, arg2) arg1##arg2</span></span></code> </pre><br><blockquote>  Espec√≠ficamente, no <b>utilic√©</b> simplemente <b>#define CONCATENATE (</b> <i>arg1</i> , <i>arg2</i> <b>)</b> <i>arg1 ## arg2</i> para poder pasar el resultado de la misma macro <b>CONCATENATE</b> como argumento a <i>arg1</i> y <i>arg2</i> . </blockquote>  A continuaci√≥n, declaramos una estructura con el hermoso nombre __static_assertion_at_line_ {n√∫mero de l√≠nea} (la macro <b>__LINE__</b> tambi√©n est√° definida por el est√°ndar y debe expandirse al n√∫mero de l√≠nea en el que se llam√≥), y dentro de esta estructura agregamos un campo de nuestro tipo <i>StaticAssertion</i> con el nombre STATIC_ASSERTION_FAILED_AT_LINE_ {line number} _WITH__ { mensajes de error de la macro que llama}. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message)\ struct CONCATENATE(__static_assertion_at_line_, __LINE__)\ {\ stdex::detail::StaticAssertion</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;static_cast&lt;bool&gt;((expression))&gt; CONCATENATE(CONCATENATE(CONCATENATE(STATIC_ASSERTION_FAILED_AT_LINE_, __LINE__), _WITH__), message);\ };\ typedef stdex::detail::StaticAssertionTest&lt;sizeof(CONCATENATE(__static_assertion_at_line_, __LINE__))&gt; CONCATENATE(__static_assertion_test_at_line_, __LINE__)</span></span></span></span></code> </pre><br>  <i>Con el</i> par√°metro de plantilla en <i>StaticAssertion,</i> pasamos una expresi√≥n que se verifica en <b>STATIC_ASSERT</b> , lo que lleva a <b>bool</b> .  Finalmente, para evitar crear variables locales y verificar la condici√≥n del usuario sin sobrecarga, se declara un alias para el tipo <i>StaticAssertionTest &lt;sizeof ({nombre de la estructura declarada anteriormente})</i> con el nombre __static_assertion_test_at_line_ {n√∫mero de l√≠nea}. <br><br>  Toda la belleza de la nomenclatura es necesaria solo para aclarar a partir de un error de compilaci√≥n que este es un resultado de afirmaci√≥n, y no solo un error, sino tambi√©n para mostrar un mensaje de error que se configur√≥ para esta afirmaci√≥n.  El truco <b>sizeof</b> es necesario para forzar al compilador a crear una instancia de la clase de plantilla <i>StaticAssertion</i> , que est√° dentro de la estructura reci√©n declarada, y as√≠ verificar la condici√≥n pasada para afirmar. <br><br><div class="spoiler">  <b class="spoiler_title">STATIC_ASSERT resultados</b> <div class="spoiler_text"><blockquote>  CCG: <br>  30: 103: error: el campo 'STATIC_ASSERTION_FAILED_AT_LINE_36_WITH__non_x32_platform_is_unsupported' tiene un tipo incompleto 'stdex :: detail :: StaticAssertion &lt;false&gt;' <br>  25:36: nota: en la definici√≥n de macro 'CONCATENATE2' <br>  23:36: nota: en expansi√≥n de la macro 'CONCATENATE1' <br>  30:67: nota: en expansi√≥n de la macro 'CONCATENAR' <br>  24:36: nota: en expansi√≥n de la macro 'CONCATENATE2' <br>  23:36: nota: en expansi√≥n de la macro 'CONCATENATE1' <br>  30:79: nota: en expansi√≥n de la macro 'CONCATENAR' <br>  24:36: nota: en expansi√≥n de la macro 'CONCATENATE2' <br>  23:36: nota: en expansi√≥n de la macro 'CONCATENATE1' <br>  30:91: nota: en expansi√≥n de la macro 'CONCATENAR' <br>  36: 3: nota: en la expansi√≥n de la macro 'STATIC_ASSERT' <br><br>  Borland C ++ Builder: <br>  [Error de C ++] stdex_test.cpp (36): E2450 Estructura no definida 'stdex :: detail :: StaticAssertion &lt;0&gt;' <br>  [Error de C ++] stdex_test.cpp (36): E2449 El tama√±o de 'STATIC_ASSERTION_FAILED_AT_LINE_36_WITH__non_x32_platform_is_unsupported' es desconocido o cero <br>  [Error de C ++] stdex_test.cpp (36): E2450 Estructura no definida 'stdex :: detail :: StaticAssertion &lt;0&gt;' <br><br>  Visual Studio: <br>  Error c2079 </blockquote><br></div></div><br>  El segundo "truco" que quer√≠a tener, aunque <u>faltaba</u> en el est√°ndar, es <b>contar</b> : contar el n√∫mero de elementos en la matriz.  A las hermanas les gusta declarar esta macro a trav√©s de sizeof (arr) / sizeof (arr [0]), pero iremos m√°s all√°. <br><br><h3>  cuenta de </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstddef&gt; namespace stdex { namespace detail { template &lt;class T, std::size_t N&gt; constexpr std::size_t _my_countof(T const (&amp;)[N]) noexcept { return N; } } // namespace detail } #define countof(arr) stdex::detail::_my_countof(arr) #else //no C++11 support #ifdef _STDEX_NATIVE_MICROSOFT_COMPILER_EXTENSIONS_SUPPORT // Visual C++ fallback #include &lt;stdlib.h&gt; #define countof(arr) _countof(arr) #elif defined(_STDEX_NATIVE_CPP_98_SUPPORT)// C++ 98 trick #include &lt;cstddef&gt; template &lt;typename T, std::size_t N&gt; char(&amp;COUNTOF_REQUIRES_ARRAY_ARGUMENT(T(&amp;)[N]))[N]; #define countof(x) sizeof(COUNTOF_REQUIRES_ARRAY_ARGUMENT(x)) #else #define countof(arr) sizeof(arr) / sizeof(arr[0]) #endif</span></span></span></span></code> </pre><br>  Para los compiladores con soporte <b>constexpr</b> , declararemos una versi√≥n constexpr de esta plantilla (que no es absolutamente necesaria, para todos los est√°ndares, la implementaci√≥n a trav√©s de la plantilla <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> es <i>suficiente</i> ), por lo dem√°s presentamos la versi√≥n a trav√©s de la funci√≥n de plantilla <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> .  Visual Studio aqu√≠ nuevamente se distingue por la presencia de su propia implementaci√≥n de <b>_countof</b> en el archivo de encabezado <b>stdlib.h</b> . <br><br>  La funci√≥n <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> parece intimidante y descubrir lo que hace es bastante complicado.  Si observa detenidamente, puede comprender que toma una matriz de elementos de tipo de plantilla <i>T</i> y tama√±o <i>N</i> como √∫nico argumento; por lo tanto, en el caso de transferir otros tipos de elementos (no matrices), obtenemos un error de compilaci√≥n, que indudablemente agrada.  Echando un vistazo m√°s de cerca, puede descubrir (con dificultad) que devuelve una serie de elementos de tama√±o <i>N.</i>  La pregunta es, ¬øpor qu√© necesitamos todo esto?  Aqu√≠ es donde entra en <b>juego el</b> operador <b>sizeof</b> y su capacidad √∫nica de trabajar en tiempo de compilaci√≥n.  El tama√±o de la llamada <b>(</b> <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> <b>)</b> determina el tama√±o del conjunto de elementos <b>char</b> devueltos por la funci√≥n, y dado que el tama√±o est√°ndar de <b>(char)</b> == 1, este es el n√∫mero de <i>N</i> elementos en el conjunto original.  Elegante, hermoso y completamente gratis. <br><br><h3>  por siempre </h3><br>  Otra peque√±a macro auxiliar que uso siempre que se necesita un bucle infinito es para <b>siempre</b> .  Se define de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined(forever) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> forever for(;;) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STRINGIZE_HELPER(x) #x #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STRINGIZE(x) STRINGIZE_HELPER(x) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WARNING(desc) message(__FILE__ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"("</span></span></span><span class="hljs-meta"> STRINGIZE(__LINE__) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">") : warning: "</span></span></span><span class="hljs-meta"> desc) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> WARNING(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdex library - macro 'forever' was previously defined by user; ignoring stdex macro definition"</span></span></span><span class="hljs-meta">) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> STRINGIZE_HELPER #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> STRINGIZE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> WARNING #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Ejemplo de sintaxis para definir un bucle infinito expl√≠cito: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; forever { ++i; }</code> </pre><br>  Esta macro se usa √∫nicamente para definir expl√≠citamente un bucle infinito y se incluye en la biblioteca solo por razones de "agregar az√∫car sint√°ctico".  En el futuro, propongo reemplazarlo con opcionalmente a trav√©s de definir la macro del plugin <b>FOREVER</b> .  Lo que es notable en el fragmento de c√≥digo anterior de la biblioteca es la misma macro <b>WARNING</b> que genera un mensaje de advertencia en todos los compiladores si el usuario ya ha definido la macro <b>forever</b> .  Utiliza la familiar macro est√°ndar <b>__LINE__</b> y la macro est√°ndar <b>__FILE__</b> , que se convierte en una cadena con el nombre del archivo fuente actual. <br><br><h3>  stdex_assert </h3><br>  Para implementar la <b>aserci√≥n</b> en tiempo de ejecuci√≥n, la macro <b>stdex_assert se</b> presenta como: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(assert) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> NDEBUG #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #define stdex_assert(condition, message) \ do { \ if (! (condition)) { \ std::cerr &lt;&lt; "Assertion `" #condition "` failed in " &lt;&lt; __FILE__ \ &lt;&lt; " line " &lt;&lt; __LINE__ &lt;&lt; ": " &lt;&lt; message &lt;&lt; std::endl; \ std::terminate(); \ } \ } while (false) #else #define stdex_assert(condition, message) ((void)0) #endif #endif</span></span></span></span></code> </pre><br>  No dir√© que estoy muy orgulloso de esta implementaci√≥n (se cambiar√° en el futuro), pero aqu√≠ se ha utilizado una t√©cnica interesante a la que me gustar√≠a llamar la atenci√≥n.  Para ocultar las comprobaciones del alcance del c√≥digo de la aplicaci√≥n, se utiliza la construcci√≥n <b>do</b> <i>{}</i> <b>while (false)</b> , que se ejecutar√°, lo que es obvio una vez y al mismo tiempo no introducir√° el c√≥digo de "servicio" en el c√≥digo general de la aplicaci√≥n.  Esta t√©cnica es bastante √∫til y se usa en varios lugares de la biblioteca. <br><br>  De lo contrario, la implementaci√≥n es muy similar a la <b>afirmaci√≥n</b> est√°ndar: con una cierta macro <b>NDEBUG</b> , que los compiladores generalmente configuran en versiones de lanzamiento, afirma no hace nada, de lo contrario, interrumpe la ejecuci√≥n del programa con la salida del mensaje a la secuencia de error est√°ndar si no se cumple la condici√≥n de afirmaci√≥n. <br><br><h3>  no excepto </h3><br>  Para las funciones que no arrojan excepciones, la palabra clave <b>noexcept</b> se ha introducido en el nuevo est√°ndar.  Tambi√©n es bastante simple e indoloro posible implementarlo a trav√©s de la macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> stdex_noexcept noexcept #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> stdex_noexcept throw() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  sin embargo, es necesario comprender que, seg√∫n el est√°ndar, <b>noexcept</b> puede tomar el valor <b>bool</b> , y tambi√©n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puede usarse</a> para determinar en tiempo de compilaci√≥n que la expresi√≥n que se le pasa no arroja una excepci√≥n.  Esta funcionalidad no se puede implementar sin el soporte del compilador y, por lo tanto, solo hay un <b>stdex_noexcept</b> "despojado" en la biblioteca. <br><br>  El final del segundo cap√≠tulo.  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tercer cap√≠tulo</a> hablar√° sobre las complejidades de la implementaci√≥n nullptr, por qu√© es diferente para diferentes compiladores, as√≠ como el desarrollo de type_traits, y qu√© otros errores en los compiladores me encontr√© durante su desarrollo. <br><br>  Gracias por su atencion </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417099/">https://habr.com/ru/post/es417099/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417087/index.html">HPE Digitize 2018: evento y transmisi√≥n en vivo</a></li>
<li><a href="../es417089/index.html">Computadora cu√°ntica: un fot√≥n para gobernar todo</a></li>
<li><a href="../es417091/index.html">Crea un sombreador de agua de dibujos animados para la web. Parte 3</a></li>
<li><a href="../es417093/index.html">Interruptores t√°ctiles con Modbus: por qu√© son necesarios y c√≥mo aplicarlos en un apartamento inteligente</a></li>
<li><a href="../es417097/index.html">Metaprogramaci√≥n de JavaScript</a></li>
<li><a href="../es417101/index.html">Definici√≥n de Listo: lo que olvidamos contar</a></li>
<li><a href="../es417103/index.html">Spark SQL. Un poco sobre el optimizador de consultas</a></li>
<li><a href="../es417105/index.html">Impresi√≥n en una impresora 3D. Experiencias secretas de 3Dtool</a></li>
<li><a href="../es417107/index.html">Creador del juego mientras es verdadero: aprenda () sobre la programaci√≥n de gamedev, los problemas de realidad virtual y las simulaciones de ML</a></li>
<li><a href="../es417109/index.html">Richard Hamming: Cap√≠tulo 10. Teor√≠a de la codificaci√≥n - I</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>