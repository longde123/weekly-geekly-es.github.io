<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õπÔ∏è üë¢ ‚õΩÔ∏è Kotlin: tiefer graben. Konstruktoren und Initialisierer üíü üëµüèª ü¶í</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bereits im Mai 2017 gab Google bekannt, dass Kotlin die offizielle Entwicklungssprache f√ºr Android geworden ist. Jemand h√∂rte dann zum ersten Mal den ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin: tiefer graben. Konstruktoren und Initialisierer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/425943/"><img src="https://habrastorage.org/webt/fy/cu/i6/fycui6wsj3p54nc1y7v5ga_hfdq.jpeg"><br><br>  Bereits im Mai 2017 gab Google bekannt, dass Kotlin die offizielle Entwicklungssprache f√ºr Android geworden ist.  Jemand h√∂rte dann zum ersten Mal den Namen dieser Sprache, jemand schrieb lange dar√ºber, aber von diesem Moment an wurde klar, dass jeder, der der Android-Entwicklung nahe steht, nun einfach verpflichtet ist, ihn kennenzulernen.  Es folgten begeisterte Antworten ‚ÄûEndlich!‚Äú Und schreckliche Emp√∂rung ‚ÄûWarum brauchen wir eine neue Sprache?‚Äú.  Was hat Java nicht gefallen? "  usw.  usw. <br><br>  Seitdem ist genug Zeit vergangen, und obwohl die Debatte dar√ºber, ob Kotlin gut oder schlecht ist, immer noch nicht abgeklungen ist, wird immer mehr Code f√ºr Android darauf geschrieben.  Und auch recht konservative Entwickler wechseln dazu.  Dar√ºber hinaus k√∂nnen Sie im Netzwerk auf Informationen sto√üen, dass die Entwicklungsgeschwindigkeit nach dem Erlernen dieser Sprache im Vergleich zu Java um 30% erh√∂ht ist. <br><br>  Kotlin hat es bereits heute geschafft, sich von mehreren Kinderkrankheiten zu erholen, die mit vielen Fragen und Antworten zum Stapel√ºberlauf √ºberwachsen sind.  Mit blo√üem Auge wurden sowohl seine Vor- als auch seine Schw√§chen sichtbar. <br><br>  Und auf dieser Welle kam mir die Idee, die einzelnen Elemente einer jungen, aber popul√§ren Sprache im Detail zu analysieren.  Achten Sie auf komplexe Punkte und vergleichen Sie sie zur besseren √úbersichtlichkeit und zum besseren Verst√§ndnis mit Java.  Um die Frage etwas tiefer zu verstehen, lesen Sie die Dokumentation.  Wenn dieser Artikel Interesse weckt, wird er h√∂chstwahrscheinlich den Grundstein f√ºr eine ganze Reihe von Artikeln legen.  In der Zwischenzeit werde ich mit ziemlich einfachen Dingen beginnen, die jedoch viele Fallstricke verbergen.  Lassen Sie uns √ºber Konstruktoren und Initialisierer in Kotlin sprechen. <a name="habracut"></a><br><br>  Wie in Java erfolgt in Kotlin die Erstellung neuer Objekte - Entit√§ten eines bestimmten Typs - durch Aufrufen des Klassenkonstruktors.  Sie k√∂nnen dem Konstruktor auch Argumente √ºbergeben, und es k√∂nnen mehrere Konstruktoren vorhanden sein.  Wenn Sie diesen Prozess von au√üen betrachten, besteht der einzige Unterschied zu Java darin, dass beim Aufrufen des Konstruktors das neue Schl√ºsselwort fehlt.  Schauen Sie jetzt genauer hin und sehen Sie, was in der Klasse passiert. <br><br>  Eine Klasse kann prim√§re und sekund√§re Konstruktoren haben. <br>  Ein Konstruktor wird mit dem Schl√ºsselwort constructor deklariert.  Wenn der prim√§re Konstruktor keine Zugriffsmodifikatoren und Anmerkungen hat, kann das Schl√ºsselwort weggelassen werden. <br>  In einer Klasse sind Konstruktoren m√∂glicherweise nicht explizit deklariert.  In diesem Fall fahren wir nach der Deklaration der Klasse ohne Konstruktionen sofort mit dem Hauptteil der Klasse fort.  Wenn wir eine Analogie zu Java ziehen, entspricht dies dem Fehlen einer expliziten Deklaration von Konstruktoren, wodurch der Standardkonstruktor (ohne Parameter) in der Kompilierungsphase automatisch generiert wird.  Es sieht aus wie erwartet: <br><br><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span></span></code> </pre> <br>  Dies entspricht dem folgenden Eintrag: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre> <br>  Wenn Sie jedoch so schreiben, werden Sie h√∂flich gebeten, den prim√§ren Konstruktor ohne Parameter zu entfernen. <br><br>  Der prim√§re Konstruktor wird immer aufgerufen, wenn ein Objekt erstellt wird, falls es existiert.  W√§hrend wir dies ber√ºcksichtigen, werden wir es sp√§ter genauer analysieren, wenn wir zu den sekund√§ren Konstruktoren √ºbergehen.  Dementsprechend erinnern wir uns, dass wenn es √ºberhaupt keine Konstruktoren gibt, es tats√§chlich einen (prim√§ren) gibt, aber wir sehen es nicht. <br><br>  Wenn wir beispielsweise m√∂chten, dass der prim√§re Konstruktor ohne Parameter keinen √∂ffentlichen Zugriff hat, m√ºssen wir ihn zusammen mit der <code>private</code> √Ñnderung explizit mit dem Schl√ºsselwort <code>constructor</code> deklarieren. <br><br>  Das Hauptmerkmal des prim√§ren Konstruktors ist, dass er keinen K√∂rper hat, d.h.  darf keinen ausf√ºhrbaren Code enthalten.  Es nimmt einfach Parameter in sich auf und √ºbergibt sie zur zuk√ºnftigen Verwendung tief an die Klasse.  Auf der Syntaxebene sieht es so aus: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(param1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, param2: Int, param3: Boolean)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ // some code }</span></span></span></span></code> </pre><br>  Auf diese Weise √ºbergebene Parameter k√∂nnen f√ºr verschiedene Initialisierungen verwendet werden, jedoch nicht mehr.  In seiner reinen Form k√∂nnen wir diese Argumente nicht im Arbeitscode der Klasse verwenden.  Hier k√∂nnen wir jedoch die Felder der Klasse initialisieren.  Es sieht so aus: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val param1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> param2: Int, param3: Boolean)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ // some code }</span></span></span></span></code> </pre><br>  Hier k√∂nnen <code>param1</code> und <code>param2</code> im Code als Felder der Klasse verwendet werden, was dem Folgenden entspricht: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int, param3: Boolean)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ val param1 = p1 var param2 = p2 // some code }</span></span></span></span></code> </pre><br>  Wenn Sie mit Java vergleichen, sieht es folgenderma√üen aus (und in diesem Beispiel k√∂nnen Sie √ºbrigens bewerten, um wie viel Kotlin die Codemenge reduzieren kann): <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String param1; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer param2; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyClassAJava(String p1, Integer p2, <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> param3) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param1 = p1; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param2 = p2; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String getParam1() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> param1; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Integer getParam2() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> param2; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> void setParam2(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Integer param2) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param2 = param2; } <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Lassen Sie uns √ºber zus√§tzliche Designer sprechen.  Sie erinnern eher an gew√∂hnliche Konstruktoren in Java: Sie akzeptieren Parameter und haben m√∂glicherweise einen ausf√ºhrbaren Block.  Wenn Sie zus√§tzliche Konstruktoren deklarieren, ist das Schl√ºsselwort Konstruktor erforderlich.  Wie bereits erw√§hnt, sollte trotz der M√∂glichkeit, ein Objekt durch Aufrufen eines zus√§tzlichen Konstruktors zu erstellen, der prim√§re Konstruktor (falls vorhanden) auch mit Hilfe <code>this</code> aufgerufen werden.  Auf Syntaxebene ist dies wie folgt organisiert: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p1: String) { <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1) { <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Das hei√üt,  der zus√§tzliche Konstruktor ist sozusagen der Erbe des Prim√§ren. <br>  Wenn wir nun ein Objekt erstellen, indem wir einen zus√§tzlichen Konstruktor aufrufen, geschieht Folgendes: <br><br>  einen zus√§tzlichen Konstruktor aufrufen; <br>  Rufen Sie den Hauptkonstruktor auf. <br>  Initialisierung eines Feldes der Klasse <code>p1</code> im Hauptkonstruktor; <br>  Codeausf√ºhrung im Hauptteil eines zus√§tzlichen Konstruktors. <br><br>  Dies √§hnelt einer solchen Konstruktion in Java: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String param1; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1)</span></span></span><span class="hljs-function"> </span></span>{ param1 = p1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, Boolean param3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1); <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Denken Sie daran, dass wir in Java einen Konstruktor mit dem <code>this</code> nur am Anfang des Konstruktork√∂rpers von einem anderen aufrufen k√∂nnen.  Bei Kotlin wurde dieses Problem grundlegend gel√∂st - ein solcher Aufruf wurde zu einem Teil der Signatur des Konstruktors.  F√ºr alle F√§lle stelle ich fest, dass es verboten ist, einen (prim√§ren oder zus√§tzlichen) Konstruktor direkt aus dem Hauptteil des zus√§tzlichen Konstruktors aufzurufen. <br><br>  Ein zus√§tzlicher Konstruktor sollte sich immer auf den Hauptkonstruktor beziehen (falls vorhanden), kann dies jedoch indirekt tun und sich auf einen anderen zus√§tzlichen Konstruktor beziehen.  Das Fazit ist, dass wir am Ende der Kette immer noch zur Hauptsache kommen.  Das Ausl√∂sen der Konstruktoren erfolgt offensichtlich in umgekehrter Reihenfolge, in der sich die Konstrukteure zueinander wenden: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA(p1: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>) <span class="hljs-comment"><span class="hljs-comment">{ constructor(p1: String, p2: Int, p3: Boolean) : this(p1) { // some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int, p3: Boolean, p4: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> :</span></span> this(p1, p2, p3) <span class="hljs-comment"><span class="hljs-comment">{ // some code }</span></span> <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Jetzt lautet die Reihenfolge: <br><br><ul><li>  Aufrufen eines zus√§tzlichen Konstruktors mit 4 Parametern; </li><li>  Aufrufen eines zus√§tzlichen Konstruktors mit 3 Parametern; </li><li>  Rufen Sie den prim√§ren Konstruktor auf. </li><li>  Initialisierung eines Feldes der Klasse p1 im Prim√§rkonstruktor; </li><li>  Codeausf√ºhrung im Hauptteil des Konstruktors mit 3 Parametern; </li><li>  Codeausf√ºhrung im Konstruktork√∂rper mit 4 Parametern. </li></ul><br>  In jedem Fall wird der Compiler uns niemals vergessen lassen, zum prim√§ren Konstruktor zu gelangen. <br><br>  Es kommt vor, dass eine Klasse keinen prim√§ren Konstruktor hat, w√§hrend sie m√∂glicherweise einen oder mehrere zus√§tzliche hat.  Dann m√ºssen zus√§tzliche Konstruktoren nicht auf jemanden verweisen, sondern k√∂nnen auch auf andere zus√§tzliche Konstruktoren dieser Klasse verweisen.  Zuvor haben wir festgestellt, dass der nicht explizit angegebene Hauptkonstruktor automatisch generiert wird. Dies gilt jedoch f√ºr F√§lle, in denen die Klasse √ºberhaupt keine Konstruktoren enth√§lt.  Wenn mindestens ein zus√§tzlicher Konstruktor vorhanden ist, wird kein Prim√§rkonstruktor ohne Parameter erstellt: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Wir k√∂nnen ein Klassenobjekt erstellen, indem wir Folgendes aufrufen: <br><br><pre> <code class="hljs lisp">val myClassA = MyClassA()</code> </pre> <br>  In diesem Fall: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Wir k√∂nnen ein Objekt nur mit diesem Aufruf erstellen: <br><br><pre> <code class="hljs pgsql">val myClassA = MyClassA(‚Äú<span class="hljs-keyword"><span class="hljs-keyword">some</span></span> string‚Äù, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br>  In Kotlin gibt es im Vergleich zu Java nichts Neues. <br><br>  √úbrigens hat der zus√§tzliche Konstruktor wie der prim√§re Konstruktor m√∂glicherweise keinen Body, wenn seine Aufgabe nur darin besteht, Parameter an andere Konstruktoren zu √ºbergeben. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1, p2, p3, <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>, p4: String) { <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Es ist auch zu beachten, dass im Gegensatz zum prim√§ren Konstruktor die Initialisierung von Klassenfeldern in der Argumentliste des zus√§tzlichen Konstruktors verboten ist. <br>  Das hei√üt,  Ein solcher Datensatz ist ung√ºltig: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p1: String, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Unabh√§ngig davon ist anzumerken, dass der zus√§tzliche Konstruktor, wie der prim√§re, durchaus ohne Parameter sein kann: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Wenn man von Konstruktoren spricht, kann man nur eine der praktischen Funktionen von Kotlin erw√§hnen - die M√∂glichkeit, Standardwerte f√ºr Argumente zuzuweisen. <br><br>  Nehmen wir nun an, wir haben eine Klasse mit mehreren Konstruktoren, die eine unterschiedliche Anzahl von Argumenten haben.  Ich werde ein Beispiel in Java geben: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String param1; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer param2; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> param3; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> param4; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> (p1, <span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> (p1, p2, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1, p2, p3, <span class="hljs-number"><span class="hljs-number">20</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param1 = p1; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param2 = p2; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param3 = p3; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param4 = p4; } <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Wie die Praxis zeigt, sind solche Designs weit verbreitet.  Mal sehen, wie das gleiche auf Kotlin geschrieben werden kann: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p1: String, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p4: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">20</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Lassen Sie uns jetzt Kotlin zusammenklopfen, um wie viel er den Code geschnitten hat.  √úbrigens, wir reduzieren nicht nur die Anzahl der Zeilen, sondern erhalten auch mehr Ordnung.  Denken Sie daran, dass Sie so etwas mehr als einmal gesehen haben m√ºssen: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p3, p1, p2, <span class="hljs-number"><span class="hljs-number">20</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p1, String p2, Integer p3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Wenn Sie dies sehen, m√∂chten Sie die Person finden, die es geschrieben hat, es per Knopfdruck nehmen, auf den Bildschirm bringen und mit trauriger Stimme fragen: ‚ÄûWarum?‚Äú <br>  Sie k√∂nnen dieses Kunstst√ºck zwar auf Kotlin wiederholen, sind aber nicht notwendig. <br><br>  Es gibt jedoch ein Detail, das im Fall einer solchen Kurznotation in Kotlin ber√ºcksichtigt werden muss: Wenn wir den Konstruktor mit Standardwerten aus Java aufrufen m√∂chten, m√ºssen wir die Annotation <b><code>@JvmOverloads</code></b> hinzuf√ºgen: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA @JvmOverloads <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p2: Int = 5, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3: Boolean = true, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p4: Int = 20)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ // some code }</span></span></span></span></code> </pre><br>  Andernfalls erhalten wir eine Fehlermeldung. <br><br>  Lassen Sie uns nun <b>√ºber Initialisierer</b> sprechen. <br><br>  Ein Initialisierer ist ein Codeblock, der mit dem Schl√ºsselwort <code>init</code> .  In diesem Block k√∂nnen Sie eine Logik ausf√ºhren, um die Elemente der Klasse zu initialisieren, einschlie√ülich der Werte der Argumente, die im prim√§ren Konstruktor enthalten sind.  Wir k√∂nnen auch Funktionen aus diesem Block aufrufen. <br><br>  Java hat auch Initialisierungsbl√∂cke, aber diese sind nicht dasselbe.  In ihnen k√∂nnen wir nicht wie in Kotlin einen Wert von au√üen √ºbergeben (die Argumente des prim√§ren Konstruktors).  Der Initialisierer ist dem K√∂rper des prim√§ren Konstruktors sehr √§hnlich, der in einem separaten Block entfernt wird.  Aber es ist auf den ersten Blick.  In der Tat ist dies nicht ganz richtig.  Lass es uns richtig machen. <br><br>  Ein Initialisierer kann auch vorhanden sein, wenn kein prim√§rer Konstruktor vorhanden ist.  Wenn ja, wird sein Code wie alle Initialisierungsprozesse vor dem Code des zus√§tzlichen Konstruktors ausgef√ºhrt.  Es kann mehr als einen Initialisierer geben.  In diesem Fall stimmt die Reihenfolge ihres Anrufs mit der Reihenfolge ihres Standorts im Code √ºberein.  Beachten Sie auch, dass die Initialisierung von Klassenfeldern au√üerhalb von <code>init</code> Bl√∂cken erfolgen kann.  In diesem Fall erfolgt die Initialisierung auch gem√§√ü der Anordnung der Elemente im Code, und dies muss beim Aufrufen von Methoden aus dem Initialisierungsblock ber√ºcksichtigt werden.  Wenn Sie es nachl√§ssig nehmen, besteht die M√∂glichkeit, dass Sie auf einen Fehler sto√üen. <br><br>  Ich werde Ihnen einige interessante F√§lle der Arbeit mit Initialisierern geben. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"some string"</span></span> showTestParam() } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"new string"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> testParam: String = <span class="hljs-string"><span class="hljs-string">"after"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in constructor testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showTestParam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in showTestParam testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre><br>  Dieser Code ist ziemlich g√ºltig, wenn auch nicht ganz offensichtlich.  Wenn Sie nachsehen, k√∂nnen Sie sehen, dass die Zuweisung eines Werts zum Feld <code>testParam</code> im Initialisierungsblock erfolgt, bevor der Parameter deklariert wird.  Dies funktioniert √ºbrigens nur, wenn wir einen zus√§tzlichen Konstruktor in der Klasse haben, aber keinen prim√§ren Konstruktor (wenn wir die Deklaration des <code>testParam</code> Felds √ºber den <code>init</code> Block heben, funktioniert dies ohne Konstruktor).  Wenn wir den Bytecode dieser Klasse in Java dekompilieren, erhalten wir Folgendes: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String testParam = <span class="hljs-string"><span class="hljs-string">"some string"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String getTestParam() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void setTestParam(<span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> String var1) { Intrinsics.checkParameterIsNotNull(var1, <span class="hljs-string"><span class="hljs-string">"&lt;set-?&gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam = var1; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void showTestParam() { Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in showTestParam testParam = "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyClassB() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showTestParam(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam = <span class="hljs-string"><span class="hljs-string">"new string"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam = <span class="hljs-string"><span class="hljs-string">"after"</span></span>; Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in constructor testParam = "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam); } }</code> </pre><br>  Hier sehen wir, dass der erste Aufruf des Feldes w√§hrend der Initialisierung (im <code>init</code> Block oder au√üerhalb davon) seiner √ºblichen Initialisierung in Java entspricht.  Alle anderen Aktionen, die mit der Zuweisung eines Werts w√§hrend des Initialisierungsprozesses verbunden sind, mit Ausnahme der ersten (die erste Zuweisung eines Werts wird mit der Felddeklaration kombiniert), werden an den Konstruktor √ºbertragen. <br>  Wenn wir Experimente mit Dekompilierung durchf√ºhren, stellt sich heraus, dass, wenn es keinen Konstruktor gibt, der prim√§re Konstruktor generiert wird und die gesamte Magie darin geschieht.  Wenn mehrere zus√§tzliche Konstruktoren vorhanden sind, die nicht aufeinander verweisen, und es keinen prim√§ren gibt, werden im Java-Code dieser Klasse alle nachfolgenden Zuweisungen des Werts zum Feld <code>testParam</code> in allen zus√§tzlichen Konstruktoren dupliziert.  Wenn es einen prim√§ren Konstruktor gibt, dann nur im prim√§ren.  Fuf ... <br><br>  Und das Interessanteste f√ºr den <code>testParam</code> : √Ñndern <code>testParam</code> die <code>testParam</code> Signatur von <code>var</code> in <code>val</code> : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"some string"</span></span> showTestParam() } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"new string"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testParam: String = <span class="hljs-string"><span class="hljs-string">"after"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in constructor testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showTestParam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in showTestParam testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre><br>  Und irgendwo im Code nennen wir: <br><br><pre> <code class="hljs cs">MyClassB myClassB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyClassB();</code> </pre><br>  Alles ohne Fehler kompiliert, gestartet, und jetzt sehen wir die Ausgabe der Protokolle: <br><br>  in showTestParam testParam = eine Zeichenfolge <br>  im Konstruktor testParam = after <br><br>  Es stellt sich heraus, dass das als <code>val</code> deklarierte Feld den Wert w√§hrend der Codeausf√ºhrung ge√§ndert hat.  Warum so?  Ich denke, dass dies ein Fehler im Kotlin-Compiler ist, und in Zukunft wird dies m√∂glicherweise nicht kompiliert, aber heute ist alles so, wie es ist. <br><br>  Wenn man aus den obigen F√§llen Schlussfolgerungen zieht, kann man nur raten, keine Initialisierungsbl√∂cke zu erzeugen und diese nicht √ºber die Klasse zu verteilen, um eine wiederholte Zuweisung von Werten w√§hrend des Initialisierungsprozesses zu vermeiden und nur reine Funktionen aus Init-Bl√∂cken aufzurufen.  All dies geschieht, um m√∂gliche Verwirrung zu vermeiden. <br><br>  Also.  <b>Initialisierer sind ein bestimmter Codeblock, der beim Erstellen eines Objekts ausgef√ºhrt werden muss, unabh√§ngig davon, mit welchem ‚Äã‚ÄãKonstruktor dieses Objekt erstellt wird.</b> <br><br>  Es scheint gekl√§rt zu sein.  Betrachten Sie das Zusammenspiel von Konstruktoren und Initialisierern.  Innerhalb einer Klasse ist alles ganz einfach, aber Sie m√ºssen sich daran erinnern: <br><br><ul><li>  einen zus√§tzlichen Konstruktor aufrufen; </li><li>  Rufen Sie den prim√§ren Konstruktor auf. </li><li>  Initialisierung von Klassenfeldern und Initialisierungsbl√∂cken in der Reihenfolge ihrer Position im Code; </li><li>  Codeausf√ºhrung im Hauptteil eines zus√§tzlichen Konstruktors. </li></ul><br>  F√§lle mit Vererbung sehen interessanter aus. <br><br>  Es ist erw√§hnenswert, dass Object die Basis f√ºr alle Klassen in Java ist und Any in Kotlin.  Any und Object sind jedoch nicht dasselbe. <br><br>  Erste Schritte zur Funktionsweise der Vererbung.  Die untergeordnete Klasse kann wie die √ºbergeordnete Klasse einen prim√§ren Konstruktor haben oder nicht, muss sich jedoch auf einen bestimmten Konstruktor der √ºbergeordneten Klasse beziehen. <br><br>  Wenn die untergeordnete Klasse einen prim√§ren Konstruktor hat, muss dieser Konstruktor auf einen bestimmten Konstruktor der Basisklasse verweisen.  In diesem Fall m√ºssen sich alle zus√§tzlichen Konstruktoren der Nachfolgerklasse auf den Hauptkonstruktor ihrer Klasse beziehen. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClassC</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClassA</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">) { constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p2</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">): this(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">) { //some code } //some code }</span></span></code> </pre><br>  Wenn die untergeordnete Klasse keinen prim√§ren Konstruktor hat, muss jeder der zus√§tzlichen Konstruktoren mit dem Schl√ºsselwort <code>super</code> auf den Konstruktor der √ºbergeordneten Klasse zugreifen.  In diesem Fall k√∂nnen verschiedene zus√§tzliche Konstruktoren der Nachfolgerklasse auf verschiedene Konstruktoren der √ºbergeordneten Klasse zugreifen: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassC : MyClassA <span class="hljs-comment"><span class="hljs-comment">{ constructor(p1: String): super(p1) { //some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int)</span></span></span><span class="hljs-function">:</span></span> super(p1, p2) <span class="hljs-comment"><span class="hljs-comment">{ //some code }</span></span> <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre><br>  Vergessen Sie auch nicht die M√∂glichkeit, den Konstruktor der √ºbergeordneten Klasse indirekt √ºber andere Konstruktoren der abgeleiteten Klasse aufzurufen: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassC : MyClassA<span class="hljs-comment"><span class="hljs-comment">{ constructor(p1: String): super(p1){ //some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int)</span></span></span><span class="hljs-function">:</span></span> this (p1)<span class="hljs-comment"><span class="hljs-comment">{ //some code }</span></span> <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre><br>  Wenn die Nachkommenklasse keine Konstruktoren hat, f√ºgen wir einfach den Konstruktoraufruf der Elternklasse nach dem Namen der Nachkommenklasse hinzu: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassC</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClassA</span></span></span></span>(‚Äúsome string‚Äù) { <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre><br>  Es gibt jedoch noch eine Option mit Vererbung, bei der kein Verweis auf den Konstruktor der √ºbergeordneten Klasse erforderlich ist.  Eine solche Aufzeichnung ist g√ºltig: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassC : MyClassB <span class="hljs-comment"><span class="hljs-comment">{ constructor(){ //some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ }</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//some code }</span></span></span></span></code> </pre><br>  Aber nur, wenn die √ºbergeordnete Klasse einen Konstruktor ohne Parameter hat, der der Standardkonstruktor ist (prim√§r oder optional - das spielt keine Rolle). <br><br>  Betrachten Sie nun die Reihenfolge des Aufrufs von Initialisierern und Konstruktoren w√§hrend der Vererbung: <br><br><ul><li>  Rufen Sie den zus√§tzlichen Konstruktor des Erben an. </li><li>  Rufen Sie den Hauptkonstrukteur des Erben an. </li><li>  Aufrufen des zus√§tzlichen Konstruktors des √ºbergeordneten Elements; </li><li>  Rufen Sie den prim√§ren Konstruktor des Elternteils auf. </li><li>  <code>init</code> Bl√∂cke <code>init</code> </li><li>  Ausf√ºhrung des Body-Codes eines zus√§tzlichen √ºbergeordneten Konstruktors </li><li>  Ausf√ºhrung des <code>init</code> Blocks des Erben; </li><li>  Ausf√ºhrung des Body-Codes des zus√§tzlichen Konstruktors des Erben </li></ul><br>  Lassen Sie uns √ºber den Vergleich mit Java sprechen, in dem es tats√§chlich kein Analogon zum Prim√§rkonstruktor von Kotlin gibt.  In Java sind alle Konstruktoren Peers und k√∂nnen entweder voneinander aufgerufen oder nicht voneinander aufgerufen werden.  In Java und Kotlin gibt es einen Standardkonstruktor, einen Konstruktor ohne Parameter, der jedoch nur beim Erben einen Sonderstatus erh√§lt.  Hier ist Folgendes zu beachten: Wenn wir in Kotlin erben, m√ºssen wir der Nachfolgeklasse explizit mitteilen, welcher Konstruktor der √ºbergeordneten Klasse verwendet werden soll - der Compiler l√§sst uns dies nicht vergessen.  In Java k√∂nnen wir dies nicht explizit angeben.  Seien Sie vorsichtig: In diesem Fall wird der Standardkonstruktor der √ºbergeordneten Klasse aufgerufen (falls vorhanden). <br><br>  In diesem Stadium gehen wir davon aus, dass wir die Designer und Initialisierer ziemlich gr√ºndlich studiert haben und jetzt fast alles √ºber sie wissen.  Wir ruhen uns ein bisschen aus und graben in die andere Richtung! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425943/">https://habr.com/ru/post/de425943/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425931/index.html">"Ich m√∂chte die Fabrik im Internet verlassen" - 10 Fragen an den Programmierer, 8. Ausgabe</a></li>
<li><a href="../de425933/index.html">Feuchtigkeit im Rechenzentrum: Warum es wichtig ist</a></li>
<li><a href="../de425935/index.html">Aufh√§ngung der Systemeinheit unter dem Stehtisch</a></li>
<li><a href="../de425937/index.html">CoreBluetooth in der Praxis</a></li>
<li><a href="../de425939/index.html">DataIncrement - Erg√§nzung zu den Funktionen von phpMyAdmin</a></li>
<li><a href="../de425945/index.html">Tipps f√ºr den professionellen Einsatz von RecyclerView. Teil 1</a></li>
<li><a href="../de425947/index.html">Unternehmensratatouille</a></li>
<li><a href="../de425951/index.html">Wie gehackte Blockchain und Kryptow√§hrungen: 6 erfolgreiche Angriffe "51 Prozent"</a></li>
<li><a href="../de425953/index.html">Wetterstation auf Arduino von A bis Z. Teil 3</a></li>
<li><a href="../de425955/index.html">8 interessante Beta-Bugs f√ºr iOS 12 und wie wir sie gesucht haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>