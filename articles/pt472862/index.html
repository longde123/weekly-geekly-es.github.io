<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏼 👨🏼‍🎓 🎒 Invalidação de cache em cascata. Parte 2 🎭 🐧 🔇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na primeira parte da tradução do material dedicado à invalidação do cache em cascata, discutimos a natureza do problema e consideramos uma das soluçõe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Invalidação de cache em cascata. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/472862/">  Na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira parte da</a> tradução do material dedicado à invalidação do cache em cascata, discutimos a natureza do problema e consideramos uma das soluções para ele, que consiste no uso de cartões de importação.  Sua vantagem é a facilidade de implementação.  E menos - suporte ruim ao navegador.  Hoje falaremos sobre outras maneiras de resolver esse problema. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/ft/lh/jx/ftlhjxkkxoeswh7akykdb6fcfoq.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Abordagem 2: Prestar serviços aos trabalhadores</font> </h2><br>  A segunda solução para o problema é reproduzir a funcionalidade de cartões de importação usando um trabalhador de serviço. <br><br>  Por exemplo, usando um trabalhador de serviço, você pode ouvir eventos que visam carregar materiais localizados em endereços correspondentes às chaves do cartão de importação.  Executando essas solicitações, você pode fazer upload de arquivos cujos nomes incluem hashes de seu conteúdo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> importMap = {  <span class="hljs-string"><span class="hljs-string">'/main.mjs'</span></span>: <span class="hljs-string"><span class="hljs-string">'/main-1a2b.mjs'</span></span>,  <span class="hljs-string"><span class="hljs-string">'/dep1.mjs'</span></span>: <span class="hljs-string"><span class="hljs-string">'/dep1-b2c3.mjs'</span></span>,  <span class="hljs-string"><span class="hljs-string">'/dep2.mjs'</span></span>: <span class="hljs-string"><span class="hljs-string">'/dep2-3c4d.mjs'</span></span>,  <span class="hljs-string"><span class="hljs-string">'/dep3.mjs'</span></span>: <span class="hljs-string"><span class="hljs-string">'/dep3-d4e5.mjs'</span></span>,  <span class="hljs-string"><span class="hljs-string">'/vendor.mjs'</span></span>: <span class="hljs-string"><span class="hljs-string">'/vendor-5e6f.mjs'</span></span>, }; addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, (event) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oldPath = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(event.request.url, location).pathname;  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (importMap.hasOwnProperty(oldPath)) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newPath = importMap[oldPath];    event.respondWith(fetch(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request(newPath, event.request)));  } });</code> </pre> <br>  No entanto, levando em conta o fato de que o código do trabalhador do serviço é fornecido acima, você precisa entender que esse código funcionará somente depois que o trabalhador do serviço estiver instalado e ativado.  E isso significa que, quando você carregar o site pela primeira vez, serão solicitados arquivos sem hashes em seus nomes.  Os arquivos com hashes nos nomes serão solicitados nos downloads subsequentes do site.  Em outras palavras, aqui estamos lidando com o carregamento duplo de cada arquivo. <br><br>  Se você levar isso em conta, pode parecer que o responsável pelo serviço não é uma solução adequada para o problema de invalidação de cache em cascata. <br><br>  No entanto, aqui solicitarei que você me permita criticar brevemente as abordagens de longa data do cache.  Vamos pensar no que acontece se pararmos de usar hashes de conteúdo nos nomes dos arquivos, em vez de colocar as informações de hash no código do operador de serviço. <br><br>  É assim que ferramentas, como a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Caixa de</a> Trabalho, que recursos de pré-cache funcionam.  Eles geram hashes do conteúdo de cada arquivo a partir da montagem e armazenam a correspondência dos nomes dos arquivos no trabalhador do serviço (é algo como um cartão de importação externo).  Além disso, eles armazenam em cache recursos durante a primeira instalação de um trabalhador de serviço e adicionam ouvintes de eventos de <code>fetch</code> que retornam arquivos em cache em resposta a solicitações cujos endereços correspondem aos do mapa de importação. <br><br>  Embora a ideia de que o cliente receba arquivos que não contêm informações sobre as versões de seu conteúdo possa parecer assustadora (e contradiga tudo o que você aprendeu), a solicitação para baixar o recurso correspondente é executada apenas quando o trabalhador do serviço está instalado.  Solicitações adicionais para baixar esse recurso passam pela <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API de Armazenamento em Cache</a> (que não usa cabeçalhos de armazenamento em cache), e novas solicitações para o servidor são executadas apenas quando uma nova versão do operador de serviço está sendo implantada (e você precisa, mesmo assim, de uma nova versão desses arquivos). <br><br>  Como resultado, até você começar a implantar novas versões de módulos sem atualizar o trabalhador do serviço (e isso definitivamente não é recomendado), você nunca encontrará um conflito ou incompatibilidade de versão. <br><br>  Para organizar o cache preliminar de arquivos usando a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca de precaching</a> da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">caixa de trabalho,</a> você pode passar os endereços e as seqüências de arquivos com informações de versão desses arquivos para o método da biblioteca <code>precacheAndRoute()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {preacacheAndRoute} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'workbox-precaching'</span></span>; precacheAndRoute([  {<span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/main.mjs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">revision</span></span>: <span class="hljs-string"><span class="hljs-string">'1a2b'</span></span>},  {<span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/dep1.mjs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">revision</span></span>: <span class="hljs-string"><span class="hljs-string">'b2c3'</span></span>},  {<span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/dep2.mjs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">revision</span></span>: <span class="hljs-string"><span class="hljs-string">'3c4d'</span></span>},  {<span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/dep3.mjs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">revision</span></span>: <span class="hljs-string"><span class="hljs-string">'d4e5'</span></span>},  {<span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/vendor.mjs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">revision</span></span>: <span class="hljs-string"><span class="hljs-string">'5e6f'</span></span>}, ]);</code> </pre> <br>  Como exatamente gerar linhas com versões depende do próprio desenvolvedor.  Mas se ele não quiser criá-los, a tarefa de gerar um manifesto pré-cache ajudará a simplificar os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pacotes</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de construção de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">caixa de trabalho</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">workbox-cli</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">workbox-webpack-plugin</a> (eles podem até gerar todo o código do operador de serviço). <br><br>  Meu projeto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">demonstração</a> tem um exemplo de implementação de pré-cache usando um trabalhador de serviço em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aplicativo Rollup</a> (usando <code>workbox-cli</code> ) e em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aplicativo webpack</a> (usando <code>workbox-webpack-plugin</code> ). <br><br><h2>  <font color="#3AC1EF">Abordagem # 3: scripts personalizados para carregar recursos</font> </h2><br>  Se o seu site não puder usar cartões de importação ou técnicos de serviço, aqui está a terceira abordagem para solucionar o problema.  Consiste na implementação da funcionalidade de mapas de importação usando seu próprio script para carregar recursos. <br><br>  Se você estiver familiarizado com os carregadores de módulo no estilo AMD (como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SystemJS</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RequireJS</a> ), também poderá saber que esses carregadores de módulo geralmente suportam aliases de módulo.  De fato, o SystemJS <a href="">suporta</a> alias usando a sintaxe do mapa de importação.  Como resultado, nosso problema é facilmente resolvido de forma que esta solução seja orientada para o futuro (e, além disso, funcionará em todos os navegadores existentes). <br><br>  Se você usar Rollup, poderá definir a opção <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">output.format</a> como <code>system</code> .  Nesse caso, a criação de um mapa de importação para o aplicativo será executada da mesma maneira descrita na descrição da primeira abordagem para solucionar o problema de invalidação de cache em cascata. <br><br>  Meu aplicativo de demonstração tem um site de exemplo em que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rollup é</a> usado para criar materiais em um formato adequado para o SystemJS e criar um mapa de importação com o qual é possível baixar versões em hash dos arquivos. <br><br><h3>  <font color="#3AC1EF">▍Webpack e carregamento de recursos usando scripts</font> </h3><br>  O Webpack também pode ajudá-lo a carregar recursos usando seu próprio script, mas o carregador gerado pelo webpack, diferentemente dos carregadores AMD clássicos, é exclusivo para cada pacote específico. <br><br>  A vantagem dessa abordagem é que o tempo de execução do webpack pode (e realmente funciona) incluir seus próprios mapeamentos entre os nomes / identificadores dos fragmentos e seus endereços (isso é semelhante ao que recomendo aqui).  Isso significa que os pacotes Webpack que usam a divisão de código têm menos probabilidade de sofrer invalidação de cache em cascata. <br><br>  Na verdade, a boa notícia para os usuários do webpack é que, se eles configuraram corretamente o conjunto do projeto usando o webpack (dividindo o código em fragmentos, conforme descrito no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">guia de</a> cache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do</a> webpack), uma alteração no código de um módulo individual não deve levar à invalidação mais de dois fragmentos (um é o que contém o módulo modificado, o segundo é o que contém o tempo de execução). <br><br>  Mas tenho más notícias para quem usa o webpack para criar projetos.  O fato é que o sistema de mapeamento interno desse empacotador não é padrão.  Isso significa que não pode ser integrado às ferramentas existentes e que o usuário não pode configurá-lo.  Por exemplo, você não pode gerar arquivos de saída independentemente (ou seja, faça o descrito na história sobre a primeira abordagem para resolver o problema) e coloque seus próprios hashes no mapeamento.  E isso é um ponto negativo do webpack, porque os hashes usados ​​por esse pacote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">não</a> são baseados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no conteúdo dos arquivos de saída</a> , mas no conteúdo dos arquivos de origem e na configuração da construção.  E isso pode levar a erros pequenos e sutis (por exemplo - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> - mensagens sobre esses erros). <br><br>  Se você usar o webpack para criar um aplicativo que também use um trabalhador de serviço, recomendo o uso da estratégia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">workbox-webpack-plugin</a> e cache, descrita na segunda abordagem para solucionar o problema.  O plug-in gera hashes com base no conteúdo da saída do webpack, o que significa que você não precisa se preocupar com os erros acima.  Além disso, trabalhar com nomes de arquivos que não possuem hashes é geralmente mais fácil do que trabalhar com nomes que possuem hashes. <br><br><h2>  <font color="#3AC1EF">Outros recursos do projeto da web</font> </h2><br>  Anteriormente, eu falei sobre como trabalhar em programas JavaScript com nomes de arquivos "hash" contendo código de programa pode levar à invalidação de cache em cascata.  Mas esse problema se aplica a outros materiais de projetos da web. <br><br>  Portanto, os arquivos CSS e SVG geralmente se referem a outros recursos (imagens, por exemplo), cujos nomes podem conter informações sobre as versões dos arquivos correspondentes na forma de hashes.  Como no caso de arquivos JS, para resolver o problema de invalidação de cache em cascata causado por alterações nos nomes de recursos semelhantes, você pode usar cartões de importação ou trabalhadores de serviço. <br><br>  Para recursos como imagens e arquivos de vídeo, isso não é problema.  Todas as recomendações existentes se aplicam aqui. <br><br>  O principal aqui é lembrar que sempre, quando o arquivo A baixa o arquivo B e, além disso, inclui informações sobre a versão do arquivo B como um hash de seu conteúdo, a invalidação de cache do arquivo B também causa a invalidação de cache do arquivo A. trabalhando com recursos, cuja utilização é organizada de maneira diferente, você pode simplesmente ignorar os conselhos fornecidos neste material. <br><br><h2>  <font color="#3AC1EF">Sumário</font> </h2><br>  Espero que este artigo tenha inspirado você a examinar mais de perto o seu site e descobrir se o problema da invalidação do cache em cascata o afeta.  A maneira mais fácil de verificar isso é montando o site, alterando uma linha de código em um arquivo importado por vários módulos e, em seguida, reconstruindo o site.  Se no diretório em que os resultados da montagem estão localizados, os nomes foram alterados para mais de um arquivo, isso significa que você tem um sinal de invalidação de cache em cascata.  E, nesse caso, talvez seja necessário pensar em usar uma das abordagens descritas aqui para resolver esse problema em seu projeto. <br><br>  Se falamos sobre o que é melhor escolher, então, francamente, isso depende de muito. <br><br>  Quando os cartões de importação serão amplamente suportados pelos navegadores, enfrentaremos a maneira mais simples e perfeita de lidar com a invalidação de cache em cascata.  Mas até que esse suporte esteja disponível, esse mecanismo não é aplicável na prática. <br><br>  Se você já usa trabalhadores de serviço, especialmente se você usa a Caixa de Trabalho, recomendo a segunda das abordagens para resolver o problema discutido aqui.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site</a> em que o original deste material foi publicado, a tarefa de cache preliminar de recursos foi resolvida dessa maneira. <br><br>  Além disso, os trabalhadores do serviço são a única opção para aqueles que usam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">módulos JavaScript</a> na produção.  (E considerando que 98% dos meus usuários têm navegadores que oferecem suporte a trabalhadores de serviço e módulos JS, não foi difícil para mim escolher essa opção). <br><br>  Se os trabalhadores do serviço não forem adequados para você, eu recomendaria a terceira das abordagens discutidas aqui, envolvendo o uso do SystemJS.  Essa abordagem é melhor que outras, com base em scripts do gerenciador de inicialização, focados no futuro.  A partir dele, será fácil mudar para importar cartões em um momento em que o suporte aparecerá em todos os navegadores. <br><br>  Se falamos de produtividade, a escolha da direção de sua otimização depende de cada projeto específico.  Antes de otimizar o desempenho, é importante medi-lo e decidir se há um problema e se é necessário lidar com ele.  Se você liberar novas versões do projeto com pouca frequência e as alterações feitas no projeto geralmente forem em grande escala, o problema da invalidação do cache em cascata pode não ser relevante para você. <br><br>  Por outro lado, se você costuma implantar pequenas alterações no projeto, os usuários que retornam podem ter o problema de carregar grandes quantidades de código que já existe em seus caches.  Resolver esse problema significará um aumento significativo no desempenho do carregamento da página para esses usuários. <br><br>  <b>Caros leitores!</b>  A invalidação de cache em cascata afeta o seu projeto?  Em caso afirmativo, diga-nos como você planeja resolvê-lo. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt472862/">https://habr.com/ru/post/pt472862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt472850/index.html">Profissão ou vida: ganhe um curso de netologia se não tiver medo</a></li>
<li><a href="../pt472852/index.html">O GitLab faz alterações para usuários de produtos comerciais e em nuvem</a></li>
<li><a href="../pt472854/index.html">Criação de perfil de interface de usuário do Unity: quem estraga meus lotes?</a></li>
<li><a href="../pt472856/index.html">Como criei um serviço de controle de qualidade a partir de mesas e paus</a></li>
<li><a href="../pt472858/index.html">Python e clientes HTTP rápidos</a></li>
<li><a href="../pt472864/index.html">Check Point: otimização de CPU e RAM</a></li>
<li><a href="../pt472866/index.html">Talismã para comunicação estável</a></li>
<li><a href="../pt472870/index.html">Por que o Agile fica parado sem transformar as ferramentas de arquitetura e desenvolvimento - apresentação da conferência</a></li>
<li><a href="../pt472872/index.html">Como aumentar a inicialização para 50 funcionários sem perder a cultura</a></li>
<li><a href="../pt472874/index.html">História da nave estelar: através de torres de água para as estrelas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>