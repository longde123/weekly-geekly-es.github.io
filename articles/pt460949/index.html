<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìß #‚É£ üë©üèæ‚Äçüíª ‚ÄúE o imposs√≠vel √© poss√≠vel‚Äù: transformamos uma caixa preta em branco usando an√°lise bin√°ria üîπ ‚è∞ üëç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No momento, existem duas abordagens principais para a busca de vulnerabilidades em aplicativos - an√°lise est√°tica e din√¢mica. Ambas as abordagens t√™m ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>‚ÄúE o imposs√≠vel √© poss√≠vel‚Äù: transformamos uma caixa preta em branco usando an√°lise bin√°ria</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/solarsecurity/blog/460949/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14e/362/af9/14e362af9999b5cdcee04915843352f4.png" alt="imagem"></div><br>  No momento, existem duas abordagens principais para a busca de vulnerabilidades em aplicativos - an√°lise est√°tica e din√¢mica.  Ambas as abordagens t√™m seus pr√≥s e contras.  O mercado chega √† conclus√£o de que ambas as abordagens devem ser usadas - elas resolvem problemas ligeiramente diferentes com resultados diferentes.  No entanto, em alguns casos, o uso da an√°lise est√°tica √© limitado - por exemplo, quando n√£o h√° c√≥digo fonte.  Neste artigo, falaremos sobre uma tecnologia bastante rara, mas muito √∫til, que permite combinar as vantagens de abordagens est√°ticas e din√¢micas - an√°lise est√°tica de c√≥digo execut√°vel. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Vamos de longe</b> <div class="spoiler_text">  De acordo com a empresa de antiv√≠rus da McAfee, os danos globais causados ‚Äã‚Äãpelo cibercrime em 2017 totalizaram cerca de US $ 600 bilh√µes, o que equivale a 0,8% do PIB global.  Vivemos na era da tecnologia da informa√ß√£o, cujas especificidades t√™m sido a r√°pida integra√ß√£o da rede global e das tecnologias da Internet em todas as esferas da atividade humana.  Agora, os crimes cibern√©ticos n√£o s√£o mais fora do comum.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">As estat√≠sticas</a> mostram um aumento exponencial do crime cibern√©tico. <br><br>  A vulnerabilidade dos aplicativos se transformou em um problema s√©rio: de acordo com o Departamento de Seguran√ßa Interna dos EUA, mais de 90% dos ataques cibern√©ticos bem-sucedidos s√£o implementados usando v√°rias vulnerabilidades nos aplicativos.  Os m√©todos mais famosos de explora√ß√£o de vulnerabilidades s√£o: <br><br><ul><li>  Inje√ß√£o de SQL </li><li>  estouro de buffer </li><li>  script crossite </li><li>  Usando uma configura√ß√£o n√£o segura. </li></ul><br></div></div><br>  A an√°lise de software (software) quanto √† presen√ßa de recursos n√£o declarados (NDV) e vulnerabilidades √© a principal tecnologia para garantir a seguran√ßa do aplicativo. <br>  Falando em tecnologias cl√°ssicas e bem estabelecidas para an√°lise de software para vulnerabilidades e NDV (para conformidade com os requisitos de seguran√ßa da informa√ß√£o), podemos distinguir: <br><br><ul><li>  an√°lise de c√≥digo est√°tico (Static Application Security Testing); </li><li>  an√°lise de c√≥digo din√¢mico (Dynamic Application Security Testing). </li></ul><br>  Existe o IAST (an√°lise interativa), no entanto, √© essencialmente din√¢mico (no processo de an√°lise, um agente adicional observa o que acontece durante a execu√ß√£o do aplicativo).  O RASP (Autodefesa de Aplicativo de Tempo de Execu√ß√£o), que tamb√©m √© mencionado √†s vezes em v√°rias ferramentas de an√°lise, √© provavelmente uma ferramenta de prote√ß√£o. <br><br>  A an√°lise din√¢mica (o m√©todo "Black Box") √© uma verifica√ß√£o do programa durante sua execu√ß√£o.  As vantagens a seguir podem ser diferenciadas dessa abordagem. <br><br><ol><li>  Como as vulnerabilidades est√£o no programa execut√°vel e o erro √© detectado usando sua opera√ß√£o, a gera√ß√£o de falsos positivos √© menor que a da an√°lise est√°tica. </li><li>  Nenhum c√≥digo fonte √© necess√°rio para executar a an√°lise. </li></ol><br>  Mas tamb√©m h√° desvantagens. <br><br><ol><li>  Cobertura incompleta do c√≥digo e, portanto, h√° riscos de vulnerabilidades ausentes.  Por exemplo, a an√°lise din√¢mica n√£o pode encontrar vulnerabilidades associadas ao uso de criptografia fraca ou indicadores como "bomba tempor√°ria". </li><li>  A necessidade de executar o aplicativo, o que em alguns casos pode ser dif√≠cil.  O lan√ßamento do aplicativo pode exigir configura√ß√£o complexa e configura√ß√£o de v√°rias integra√ß√µes.  Al√©m disso, para que os resultados sejam t√£o precisos quanto poss√≠vel, √© necess√°rio reproduzir o "ambiente de combate", mas √© dif√≠cil realizar isso sem prejudicar o software. </li></ol><br>  A an√°lise est√°tica (o m√©todo ‚ÄúCaixa Branca‚Äù) √© um tipo de teste de programa no qual o programa n√£o √© executado. <br><br>  Listamos os benef√≠cios. <br><br><ol><li>  Cobertura total do c√≥digo, o que leva √† busca por mais vulnerabilidades. </li><li>  N√£o h√° depend√™ncia do ambiente em que o programa ser√° executado. </li><li>  A capacidade de implementar testes nos est√°gios iniciais de grava√ß√£o de c√≥digo de um m√≥dulo ou programa na aus√™ncia de arquivos execut√°veis.  Isso permite que voc√™ j√° integre de maneira flex√≠vel uma solu√ß√£o semelhante ao SDLC (Ciclo de vida do desenvolvimento de software ou ciclo de vida do desenvolvimento de software) no in√≠cio do desenvolvimento. </li></ol><br>  A √∫nica desvantagem do m√©todo √© a presen√ßa de falsos positivos: a necessidade de avaliar se o analisador indica um erro real ou √© prov√°vel que esse falso positivo. <br><br>  Como podemos ver, ambos os m√©todos de an√°lise t√™m vantagens e desvantagens.  No entanto, √© poss√≠vel de alguma maneira usar as vantagens desses m√©todos, minimizando as desvantagens?  Sim, se voc√™ aplicar a an√°lise bin√°ria - a pesquisa de vulnerabilidades nos arquivos execut√°veis ‚Äã‚Äãpela an√°lise est√°tica. <br><br><h2>  An√°lise bin√°ria ou tecnologia de an√°lise de arquivos execut√°veis </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93b/ba8/662/93bba8662a8a8f2e6dcaf16c39193950.png" alt="imagem"></div><br>  A an√°lise bin√°ria permite a an√°lise est√°tica sem c√≥digo fonte, por exemplo, no caso de terceiros contratados.  Al√©m disso, a cobertura do c√≥digo ser√° completa, em contraste com a aplica√ß√£o do m√©todo de an√°lise din√¢mica.  Usando a an√°lise bin√°ria, voc√™ pode verificar as bibliotecas de terceiros usadas no processo de desenvolvimento para as quais n√£o h√° c√≥digo fonte.  Al√©m disso, usando a an√°lise bin√°ria, voc√™ pode realizar uma verifica√ß√£o de controle da vers√£o, comparando os resultados da an√°lise do c√≥digo fonte do reposit√≥rio e o c√≥digo execut√°vel do servidor de combate. <br><br>  No processo de an√°lise bin√°ria, a imagem bin√°ria √© transformada em uma representa√ß√£o intermedi√°ria (representa√ß√£o interna ou modelo de c√≥digo) para posterior an√°lise.  Depois disso, algoritmos de an√°lise est√°tica s√£o aplicados √† representa√ß√£o interna.  Como resultado, o modelo atual √© complementado com as informa√ß√µes necess√°rias para a detec√ß√£o adicional de vulnerabilidades e NDV.  Na pr√≥xima etapa, a aplica√ß√£o das regras para busca de vulnerabilidades e NDV. <br><br>  Escrevemos mais sobre o esquema de an√°lise est√°tica <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em um artigo anterior</a> .  Diferentemente da an√°lise de c√≥digo-fonte, que usa elementos da teoria da compila√ß√£o (an√°lise lexical e sint√°tica) para construir o modelo, a an√°lise bin√°ria usa a teoria da tradu√ß√£o reversa para desmontar, descompilar e desobstruir o modelo. <br><br><h2>  Um pouco sobre os termos </h2><br>  Estamos falando de analisar arquivos execut√°veis ‚Äã‚Äãque n√£o possuem informa√ß√µes de depura√ß√£o.  Com informa√ß√µes de depura√ß√£o, a tarefa √© bastante simplificada, mas se houver informa√ß√µes de depura√ß√£o, o c√≥digo-fonte provavelmente ser√° e a tarefa se tornar√° irrelevante. <br><br>  Neste artigo, chamamos a an√°lise de bytecode Java tamb√©m de an√°lise bin√°ria, embora isso n√£o esteja totalmente correto.  Fazemos isso para simplificar o texto.  Obviamente, a tarefa de analisar o bytecode da JVM √© mais simples do que analisar o c√≥digo C / C ++ bin√°rio e Objective-C / Swift.  Mas o esquema geral de an√°lise √© semelhante no caso de bytecode e c√≥digo bin√°rio.  As principais dificuldades descritas no artigo est√£o relacionadas especificamente √† an√°lise do c√≥digo bin√°rio. <br><br>  Descompila√ß√£o √© o processo de recuperar o c√≥digo fonte do c√≥digo bin√°rio.  Voc√™ pode falar sobre os elementos da tradu√ß√£o reversa - desmontagem (obten√ß√£o do c√≥digo do assembler a partir de uma imagem bin√°ria), tradu√ß√£o do assembler em um c√≥digo de tr√™s endere√ßos ou outra representa√ß√£o, restaurando constru√ß√µes do n√≠vel do c√≥digo-fonte. <br><br>  Ofusca√ß√£o - transforma√ß√µes que preservam a funcionalidade do c√≥digo fonte, mas dificultam a descompila√ß√£o e a compreens√£o da imagem bin√°ria resultante.  Desobstru√ß√£o √© a transforma√ß√£o inversa.  A ofusca√ß√£o pode ser aplicada no n√≠vel do c√≥digo-fonte e no n√≠vel do c√≥digo bin√°rio. <br><br><h2>  Como assistir os resultados? </h2><br>  Vamos come√ßar um pouco do final, mas a quest√£o de visualizar os resultados da an√°lise bin√°ria √© geralmente feita primeiro. <br><br>  √â importante que um especialista analise o c√≥digo bin√°rio para mapear vulnerabilidades e o NDV para o c√≥digo-fonte.  Para fazer isso, no est√°gio final, o processo de desofusca√ß√£o (desenrolar) √© iniciado se convers√µes confusas foram aplicadas e o c√≥digo bin√°rio foi descompilado na fonte.  Ou seja, as vulnerabilidades podem ser demonstradas no c√≥digo descompilado. <br><br>  No processo de descompila√ß√£o, mesmo que descompilemos o bytecode da JVM, algumas das informa√ß√µes n√£o s√£o restauradas corretamente, portanto, a an√°lise ocorre em uma representa√ß√£o pr√≥xima ao c√≥digo bin√°rio.  Nesse sentido, surge a pergunta: como, localizando vulnerabilidades no c√≥digo bin√°rio, localiz√°-las na fonte?  A solu√ß√£o para o problema do bytecode da JVM foi descrita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em nosso artigo sobre a pesquisa de vulnerabilidades no bytecode Java</a> .  A solu√ß√£o para o c√≥digo bin√°rio √© semelhante, ou seja, uma quest√£o t√©cnica. <br><br>  Vamos repetir a ressalva importante - estamos falando sobre an√°lise de c√≥digo bin√°rio sem informa√ß√µes de depura√ß√£o.  Na presen√ßa de informa√ß√µes de depura√ß√£o, a tarefa √© bastante simplificada. <br><br>  A principal pergunta que temos sobre a exibi√ß√£o dos resultados √© se o c√≥digo descompilado √© suficiente para entender e localizar a vulnerabilidade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d88/8c6/5f5/d888c65f519aa80b4c4281a2f16dfc4e.jpg" alt="imagem"></div><br>  Abaixo est√£o algumas reflex√µes sobre este assunto. <br><br><ol><li>  Se estamos falando sobre o bytecode da JVM, em geral a resposta √© "yes" - a qualidade de descompila√ß√£o para o bytecode √© √≥tima.  Quase sempre voc√™ pode descobrir qual √© a vulnerabilidade. </li><li>  O que pode interferir na localiza√ß√£o qualitativa da vulnerabilidade √© uma ofusca√ß√£o simples, como renomear nomes de fun√ß√µes e fun√ß√µes.  No entanto, na pr√°tica, muitas vezes acontece que √© mais importante entender a vulnerabilidade do que determinar em qual arquivo est√°.  A localiza√ß√£o √© necess√°ria quando algu√©m pode corrigir a vulnerabilidade, mas, nesse caso, o desenvolvedor tamb√©m entender√° onde est√° a vulnerabilidade do c√≥digo descompilado. </li><li>  Quando falamos sobre a an√°lise do c√≥digo bin√°rio (por exemplo, C ++), √© claro, tudo √© muito mais complicado.  N√£o existe uma ferramenta que recupere completamente o c√≥digo C ++ aleat√≥rio.  No entanto, a peculiaridade do nosso caso √© que n√£o precisamos compilar o c√≥digo posteriormente: precisamos de qualidade suficiente para entender a vulnerabilidade. </li><li>  Na maioria das vezes, √© poss√≠vel obter uma qualidade de descompila√ß√£o suficiente para entender a vulnerabilidade encontrada.  Para fazer isso, voc√™ precisa resolver muitos problemas complexos, mas pode resolv√™-los (abaixo, falaremos brevemente sobre isso). </li><li>  Para C / C ++, √© ainda mais dif√≠cil localizar a vulnerabilidade - os nomes dos caracteres s√£o perdidos de v√°rias maneiras durante o processo de compila√ß√£o, voc√™ n√£o pode restaur√°-los. </li><li>  A situa√ß√£o no Objective-C √© um pouco melhor - existem nomes de fun√ß√µes e √© mais f√°cil localizar a vulnerabilidade. </li><li>  As quest√µes da ofusca√ß√£o se destacam.  H√° v√°rias transforma√ß√µes complexas que podem complicar a descompila√ß√£o e o mapeamento de vulnerabilidades.  Na pr√°tica, um bom descompilador pode lidar com a maioria das convers√µes confusas (lembre-se de que precisamos de qualidade de c√≥digo suficiente para entender a vulnerabilidade). </li></ol><br>  Como conclus√£o - geralmente mostra a vulnerabilidade para que possa ser entendida e verificada. <br><br><h2>  Complexidades e detalhes da an√°lise bin√°ria </h2><br>  Aqui n√£o falaremos sobre o bytecode: todas as coisas interessantes sobre ele j√° foram ditas acima.  O mais interessante √© a an√°lise do c√≥digo bin√°rio real.  Aqui vamos falar sobre a an√°lise de C / C ++, Objective-C e Swift como um exemplo. <br><br>  Dificuldades significativas surgem mesmo ao desmontar.  O est√°gio mais importante √© a divis√£o da imagem bin√°ria em subprogramas.  Em seguida, selecione as instru√ß√µes do montador nas sub-rotinas - uma quest√£o t√©cnica.  Escrevemos sobre isso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em</a> detalhes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em um artigo para a revista ‚ÄúIssues of Cybersecurity No. 1 (14) - 2016‚Äù</a> , aqui descreveremos brevemente. <br><br>  Como exemplo, falaremos sobre a arquitetura x86.  As instru√ß√µes nele n√£o t√™m um comprimento fixo.  Em imagens bin√°rias, n√£o h√° uma divis√£o clara em se√ß√µes de c√≥digo e dados: tabelas de importa√ß√£o, tabelas de fun√ß√µes virtuais podem estar na se√ß√£o de c√≥digos, tabelas de transi√ß√£o podem estar nos intervalos entre os blocos de fun√ß√µes base na se√ß√£o de c√≥digos.  Portanto, √© necess√°rio poder separar o c√≥digo dos dados e entender onde as rotinas come√ßam e onde terminam. <br><br>  Os mais comuns s√£o dois m√©todos para resolver o problema de determinar os endere√ßos iniciais dos subprogramas.  No primeiro m√©todo, os endere√ßos dos subprogramas s√£o determinados pelo pr√≥logo padr√£o (para a arquitetura x86 √© push ebp; mov ebp, esp).  No segundo m√©todo, uma se√ß√£o do c√≥digo √© percorrida recursivamente a partir do ponto de entrada com o reconhecimento das instru√ß√µes de chamada da sub-rotina.  O desvio √© feito atrav√©s do reconhecimento de instru√ß√µes de ramifica√ß√£o.  As combina√ß√µes dos m√©todos descritos tamb√©m s√£o usadas quando uma travessia recursiva √© iniciada a partir dos endere√ßos de partida encontrados pelo pr√≥logo. <br><br>  Na pr√°tica, verifica-se que essas abordagens fornecem uma porcentagem bastante baixa de c√≥digo reconhecido, pois nem todas as fun√ß√µes t√™m um pr√≥logo padr√£o e existem chamadas e transi√ß√µes indiretas. <br><br>  Algoritmos b√°sicos podem ser aprimorados pelas seguintes heur√≠sticas. <br><br><ol><li>  Em uma grande base de imagens de teste, encontre uma lista mais precisa de pr√≥logos (novos pr√≥logos ou varia√ß√µes dos padr√µes). </li><li>  Voc√™ pode encontrar automaticamente tabelas de fun√ß√µes virtuais e, a partir delas, selecionar os endere√ßos iniciais dos subprogramas. </li><li>  Os endere√ßos iniciais dos subprogramas e algumas outras constru√ß√µes podem ser encontrados com base nas se√ß√µes do c√≥digo bin√°rio associado ao mecanismo de tratamento de exce√ß√µes. </li><li>  Voc√™ pode verificar os endere√ßos iniciais pesquisando esses endere√ßos na imagem e reconhecendo as instru√ß√µes de chamada. </li><li>  Para procurar limites, voc√™ pode fazer um desvio recursivo da sub-rotina com o reconhecimento de instru√ß√µes no endere√ßo inicial.  H√° uma dificuldade com transi√ß√µes indiretas e fun√ß√µes sem retorno.  A an√°lise da tabela de importa√ß√£o e o reconhecimento de constru√ß√µes de comutadores podem ajudar. <br></li></ol><br>  Outra coisa importante que precisa ser feita durante a convers√£o reversa, para procurar normalmente uma vulnerabilidade posteriormente, √© reconhecer fun√ß√µes padr√£o em uma imagem bin√°ria.  As fun√ß√µes padr√£o podem ser vinculadas estaticamente √† imagem ou at√© estar embutidas.  O principal algoritmo de reconhecimento √© uma pesquisa por assinatura com varia√ß√µes; para a solu√ß√£o, voc√™ pode oferecer o algoritmo Aho-Korasik adaptado.  Para coletar assinaturas, √© necess√°rio pr√©-analisar as imagens da biblioteca coletadas com diferentes condi√ß√µes e selecion√°-las como bytes imut√°veis. <br><br><h2>  O que vem a seguir </h2><br>  Na se√ß√£o anterior, examinamos o est√°gio inicial da tradu√ß√£o reversa de uma imagem bin√°ria - desmontagem.  O est√°gio, de fato, √© inicial, mas determinante.  Nesse est√°gio, voc√™ pode perder parte do c√≥digo, que ter√° um efeito dram√°tico nos resultados da an√°lise. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/2a1/e8e/d0a2a1e8e1a55b64c97f10eca64df9b3.jpg" alt="imagem"></div><br>  Ent√£o, muitas coisas interessantes acontecem.  Diga brevemente sobre as principais tarefas.  N√£o falaremos em detalhes: o know-how, sobre o qual n√£o podemos escrever explicitamente aqui, ou solu√ß√µes t√©cnicas e de engenharia n√£o muito interessantes est√£o nos detalhes. <br><br><ol><li>  Convertendo c√≥digo de montagem em uma representa√ß√£o intermedi√°ria na qual a an√°lise pode ser executada.  Voc√™ pode usar v√°rios bytecodes.  Para idiomas C, o LLVM parece ser uma boa escolha.  O LLVM √© ativamente suportado e desenvolvido pela comunidade; a infraestrutura, inclusive √∫til para an√°lises est√°ticas, √© atualmente impressionante.  Nesta fase, h√° um grande n√∫mero de detalhes aos quais voc√™ precisa prestar aten√ß√£o.  Por exemplo, voc√™ precisa detectar quais vari√°veis ‚Äã‚Äãs√£o endere√ßadas na pilha para n√£o multiplicar entidades na exibi√ß√£o resultante.  Voc√™ precisa configurar a exibi√ß√£o ideal dos conjuntos de instru√ß√µes do assembler nas instru√ß√µes do bytecode. </li><li>  Restaure estruturas de alto n√≠vel (por exemplo, loops, ramifica√ß√µes).  Quanto mais preciso for poss√≠vel restaurar as constru√ß√µes originais do c√≥digo do montador, melhor ser√° a qualidade da an√°lise.  A restaura√ß√£o de tais constru√ß√µes ocorre usando elementos da teoria dos grafos no CFG (controle de fluxo gr√°fico) e algumas outras representa√ß√µes gr√°ficas do programa. </li><li>  Execu√ß√£o de algoritmos de an√°lise est√°tica.  H√° detalhes.  Em geral, n√£o √© muito importante obtermos a representa√ß√£o interna da fonte ou do bin√°rio - todos tamb√©m precisamos criar CFG, aplicar algoritmos de an√°lise de fluxo de dados e outros algoritmos t√≠picos da est√°tica.  Existem alguns recursos ao analisar a visualiza√ß√£o obtida do bin√°rio, mas eles s√£o mais t√©cnicos. </li></ol><br><h2>  Conclus√µes </h2><br>  Falamos sobre como voc√™ pode fazer an√°lises est√°ticas quando n√£o h√° c√≥digo fonte.  De acordo com a experi√™ncia de comunica√ß√£o com os clientes, verifica-se que a tecnologia √© muito procurada.  No entanto, a tecnologia √© rara: o problema da an√°lise bin√°ria n√£o √© trivial, sua solu√ß√£o requer algoritmos complexos de alta tecnologia de an√°lise est√°tica e tradu√ß√£o reversa. <br><br>  <i>Este artigo foi escrito em colabora√ß√£o com Anton Prokofiev, analista do Solar appScreener</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460949/">https://habr.com/ru/post/pt460949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460939/index.html">Longrid sobre a hist√≥ria da minera√ß√£o russa e a atitude dos reguladores em rela√ß√£o a ela</a></li>
<li><a href="../pt460941/index.html">Compromisso de e-mail comercial: sem defesa contra ataques</a></li>
<li><a href="../pt460943/index.html">Como escolher chaves promissoras para SEO com base na previs√£o de cen√°rios no Google Data Studio (modelo +)</a></li>
<li><a href="../pt460945/index.html">Experi√™ncia no uso de um canal de telegrama para aumentar o reconhecimento e o crescimento da receita de um est√∫dio de jogos</a></li>
<li><a href="../pt460947/index.html">Reuni√£o WASM 1/08</a></li>
<li><a href="../pt460951/index.html">Criar pap√©is de parede animados para Android</a></li>
<li><a href="../pt460953/index.html">Os ponteiros s√£o complexos ou o que √© armazenado em um byte?</a></li>
<li><a href="../pt460955/index.html">Programa educacional para passar par√¢metros por valor para construtores e setters (C ++ moderno, exemplos)</a></li>
<li><a href="../pt460959/index.html">A nova tecnologia da Microsoft permite que c√≥pias 3D de uma pessoa real falem qualquer idioma</a></li>
<li><a href="../pt460961/index.html">Configurando testes de unidade em projetos Swift + Objective-C mistos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>