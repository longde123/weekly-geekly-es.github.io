<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëéüèæ üå≠ üëåüèΩ Lo que debe esperar para crear estrategias para operar en el intercambio: cu√°n eficiente es el aprendizaje autom√°tico üòÇ üòé üçÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En nuestro blog sobre Habr√©, publicamos traducciones adaptadas de materiales del blog The Financial Hacker, dedicadas a preguntas sobre la creaci√≥n de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lo que debe esperar para crear estrategias para operar en el intercambio: cu√°n eficiente es el aprendizaje autom√°tico</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/iticapital/blog/412639/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/pq/lc/zm/pqlczmojlxuisfxberyvpnismeu.png"></a> <br><br>  En nuestro blog sobre Habr√©, publicamos traducciones adaptadas de materiales del blog The Financial Hacker, dedicadas a preguntas sobre la creaci√≥n de estrategias para operar en el intercambio.  Anteriormente, discutimos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b√∫squeda de ineficiencias del mercado</a> , la creaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modelos de estrategias comerciales</a> y los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">principios de su programaci√≥n</a> .  Hoy nos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">centraremos</a> en el uso de enfoques de aprendizaje autom√°tico para mejorar la eficiencia de los sistemas comerciales. <br><br>  La primera computadora en ganar el Campeonato Mundial de Ajedrez fue Deep Blue.  Eso fue en 1996, y pasaron otros veinte a√±os antes de que otro programa, Alpha Go, lograra derrotar al mejor jugador en Go.  Deep Blue era un sistema orientado a modelos con reglas de ajedrez integradas.  AplhaGo es un sistema de miner√≠a de datos, una red neuronal profunda, entrenada utilizando miles de juegos en Go.  Es decir, para dar un paso m√°s all√° de las victorias sobre las personas que son campeones en ajedrez, para dominar a los mejores jugadores en Go, no era necesario una pieza de hierro mejorada, sino un avance en el campo del software. <br><br>  En el art√≠culo actual, consideraremos aplicar el enfoque de miner√≠a de datos para crear estrategias comerciales.  Este m√©todo no tiene en cuenta los mecanismos del mercado; simplemente escanea las curvas de precios y otras fuentes de datos para buscar patrones predictivos.  El aprendizaje autom√°tico o la "inteligencia artificial" no siempre son necesarios para esto.  Por el contrario, muy a menudo, los m√©todos m√°s populares y rentables de miner√≠a de datos funcionan sin ning√∫n tipo de adorno en forma de redes neuronales o soporte para m√©todos vectoriales. <a name="habracut"></a><br><br><h2>  Principios de aprendizaje autom√°tico </h2><br>  El algoritmo entrenado se alimenta con muestras de datos, generalmente extra√≠dos de alguna manera de los precios de cambio hist√≥ricos.  Cada muestra consta de n variables x1 ... xn, que generalmente se denominan predictores, funciones, se√±ales o, m√°s simplemente, datos de entrada.  Estos predictores pueden ser los precios de las √∫ltimas n barras en el gr√°fico de precios o un conjunto de valores de indicadores cl√°sicos, o cualquier otra funci√≥n de la curva de precios (¬°incluso hay casos en los que se utilizan p√≠xeles individuales del gr√°fico de precios como predictores para una red neuronal!).  Cada muestra tambi√©n suele contener una determinada variable objetivo y, por ejemplo, el resultado de la pr√≥xima transacci√≥n despu√©s de analizar la muestra o el siguiente movimiento de precios. <br><br>  En la literatura, y a menudo se denomina etiqueta u objetivo.  En el proceso de aprendizaje, el algoritmo aprende a predecir el objetivo y en funci√≥n de los predictores x1 ... xn.  Lo que el sistema "recuerda" en el proceso se almacena en una estructura de datos llamada modelo que es espec√≠fico de un algoritmo particular (es importante no confundir este concepto con un modelo financiero o una estrategia orientada al modelo).  Un modelo de aprendizaje autom√°tico puede ser funciones con reglas de predicci√≥n escritas usando el c√≥digo C generado por el proceso de aprendizaje.  O podr√≠a ser un conjunto de pesos relacionados con la red neuronal: <br><br><blockquote>  Entrenamiento: x1 ... xn, y =&gt; modelo <br><br>  Predicci√≥n: x1 ... xn, modelo =&gt; y <br></blockquote><br>  Los predictores, funciones o como quiera llamarlos deben contener informaci√≥n suficiente para generar predicciones sobre el valor del objetivo y con cierta precisi√≥n.  Tambi√©n deben cumplir con dos criterios formales.  Primero, todos los valores predictores deben estar en el mismo rango, por ejemplo, -1 ... +1 (para la mayor√≠a de los algoritmos en R) o -100 ... +100 (para algoritmos en los lenguajes de script Zorro o TSSB).  Entonces, antes de enviar datos al sistema, debe normalizarlos.  En segundo lugar, las muestras deben estar equilibradas, es decir, distribuidas de manera uniforme sobre los valores de la variable objetivo.  Es decir, debe tener el mismo n√∫mero de muestras que conducen a un resultado positivo y pierden series.  Si no se siguen estos dos requisitos, los buenos resultados no tendr√°n √©xito. <br><br>  Los algoritmos de regresi√≥n generan predicciones sobre valores num√©ricos, como la magnitud o el signo del pr√≥ximo movimiento de precios.  Los algoritmos de clasificaci√≥n predicen clases cuantitativas de muestras, por ejemplo, si preceden a la ganancia o p√©rdida de fondos.  Algunos algoritmos, como las redes neuronales, los √°rboles de decisi√≥n o los m√©todos de vectores de soporte, se pueden ejecutar en ambos modos. <br><br>  Tambi√©n hay algoritmos que pueden aprender a extraer de muestras de clase sin la necesidad de un objetivo y.  Esto se llama aprendizaje no supervisado, en oposici√≥n al aprendizaje supervisado.  En alg√∫n lugar entre estos dos m√©todos se encuentra el "aprendizaje de refuerzo", en el que el sistema se entrena ejecutando simulaciones con funciones espec√≠ficas y utiliza el resultado como un objetivo.  Un seguidor de AlphaGo, un sistema llamado AlphaZero utiliz√≥ aprendizaje reforzado, jugando un mill√≥n de juegos de Go consigo mismo.  En finanzas, tales sistemas o productos que usan aprendizaje no supervisado son extremadamente raros.  El 99% de los sistemas utilizan aprendizaje supervisado. <br><br>  Cualesquiera que sean las se√±ales que usamos para los predictores en finanzas, en la mayor√≠a de los casos contendr√°n mucho ruido y poca informaci√≥n, y adem√°s ser√°n inestables.  Por lo tanto, la predicci√≥n financiera es una de las tareas m√°s dif√≠ciles del aprendizaje autom√°tico.  Algoritmos m√°s complejos aqu√≠ logran mejores resultados.  La selecci√≥n de predictores es cr√≠tica para el √©xito.  No necesariamente debe haber muchos de ellos, ya que esto lleva a la reentrenamiento y el mal funcionamiento.  Por lo tanto, las estrategias de miner√≠a de datos a menudo usan un algoritmo preseleccionado que extrae una peque√±a cantidad de predictores de un grupo m√°s amplio.  Tal selecci√≥n preliminar puede basarse en la correlaci√≥n entre predictores, su importancia, riqueza de informaci√≥n o simplemente el √©xito / fracaso del uso del conjunto de pruebas.  Los experimentos pr√°cticos con la selecci√≥n de objetivos se pueden encontrar, por ejemplo, en el blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Robot Wealth</a> . <br><br>  A continuaci√≥n se muestra una lista de los m√©todos m√°s populares de miner√≠a de datos utilizados en el campo de las finanzas. <br><br><h2>  1. Sopa de indicadores </h2><br>  La mayor√≠a de los sistemas comerciales no se basan en modelos financieros.  A menudo, los operadores solo necesitan se√±ales comerciales generadas por ciertos indicadores t√©cnicos, que se filtran por otros indicadores en combinaci√≥n con indicadores t√©cnicos adicionales.  Cuando le pregunta a un comerciante acerca de c√≥mo tal mezcla de indicadores puede generar alg√∫n tipo de beneficio, generalmente responde algo como: "Cr√©eme, cambio mis manos y todo funciona". <br><br>  Y es verdad  Al menos a veces.  Aunque la mayor√≠a de estos sistemas no pasar√°n la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prueba WFA</a> (y algunos simplemente prueban datos hist√≥ricos), una cantidad sorprendentemente grande de dichos sistemas finalmente funciona y obtiene ganancias.  El autor del blog Financial Hacker se dedica al desarrollo de sistemas de comercio personalizados y cuenta la historia de uno de los clientes que experiment√≥ sistem√°ticamente con indicadores t√©cnicos hasta que encontr√≥ una combinaci√≥n que funciona para ciertos tipos de activos.  Este m√©todo de prueba y error es un enfoque cl√°sico para la miner√≠a de datos, para el √©xito solo lo necesita, suerte y mucho dinero para las pruebas.  Como resultado, a veces puede contar con obtener un sistema rentable. <br><br><h2>  2. Patrones de velas </h2><br>  No debe confundirse con los patrones de velas que han existido durante cientos de a√±os.  El equivalente moderno de este enfoque es el comercio basado en movimientos de precios.  Tambi√©n analiza los indicadores de apertura, alto, bajo y cierre para cada vela en el gr√°fico.  Pero ahora est√° utilizando la miner√≠a de datos para analizar las velas de la curva de precios para resaltar patrones que se pueden usar para generar predicciones sobre la direcci√≥n del movimiento de precios en el futuro. <br><br>  Hay paquetes de software completos para este prop√≥sito.  Buscan patrones que sean rentables en t√©rminos de criterios definidos por el usuario y los utilizan para crear una funci√≥n de detecci√≥n de patrones.  Todo esto puede verse m√°s o menos as√≠: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">0</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">7</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">3</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">4</span></span>] &amp;&amp; eqF(sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]-sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]) &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">3</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">7</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">4</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">0</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">3</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">7</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Esta funci√≥n C devuelve 1 cuando la se√±al coincide con uno de los patrones; de lo contrario, devuelve 0. El c√≥digo largo parece indicar que esta no es la forma m√°s r√°pida de buscar patrones.  Es mejor utilizar un enfoque en el que no sea necesario exportar la funci√≥n de detecci√≥n, pero puede ordenar las se√±ales seg√∫n su importancia y ordenarlas.  Un ejemplo de dicho sistema se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el enlace</a> . <br><br>  ¬øPuede operar a precio de trabajo?  Como en el caso anterior, este m√©todo no se basa en ning√∫n modelo financiero racional.  Al mismo tiempo, todos entienden que realmente ciertos eventos en el mercado pueden afectar a sus participantes, como resultado de lo cual surgen patrones predictivos a corto plazo.  Pero el n√∫mero de tales patrones no puede ser grande si estudia solo la secuencia de varias velas consecutivas en el gr√°fico.  Luego, deber√° comparar el resultado con los datos de las velas, que no est√°n cerca, pero que, por el contrario, se seleccionan al azar durante un per√≠odo de tiempo m√°s largo.  En este caso, obtendr√° un n√∫mero casi ilimitado de patrones, y se separar√° con √©xito de los conceptos de realidad y racionalidad.  Es dif√≠cil imaginar c√≥mo se puede predecir el precio futuro en funci√≥n de algunos de sus valores la semana pasada.  A pesar de esto, muchos comerciantes trabajan en esta direcci√≥n. <br><br><h2>  3. regresi√≥n lineal </h2><br>  Una base simple para muchos algoritmos complejos de aprendizaje autom√°tico: para predecir la variable objetivo y utilizando una combinaci√≥n lineal de predictores x1 ... xn. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d0/230/0e1/3d02300e11bdf79ba483a647d5089421.png" alt="imagen"><br><br>  Probabilidades: este es el modelo.  Se calculan para minimizar la suma de las desviaciones cuadr√°ticas entre los valores reales y, los valores de entrenamiento y los y pronosticados seg√∫n la f√≥rmula: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc7/06c/d46/bc706cd46620a7d8682eb18e16daeeda.png" alt="imagen"><br><br>  Para muestras distribuidas normalmente, la minimizaci√≥n es posible utilizando operaciones matriciales, por lo que no se requieren iteraciones.  En el caso cuando n = 1 - con un solo predictor x, la f√≥rmula de regresi√≥n se reduce a: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/adc/a79/e98/adca79e98f1193be9b631dbfe51dbc96.png" alt="imagen"><br><br>  - es decir, antes de una regresi√≥n lineal simple, y cuando n&gt; 1 la regresi√≥n lineal ser√° multivariante.  La regresi√≥n lineal simple est√° disponible en la mayor√≠a de las plataformas de negociaci√≥n, por ejemplo, el indicador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LinReg</a> en TA-Lib.  Cuando y = precio yx = tiempo, se puede usar como una alternativa a los promedios m√≥viles.  En la plataforma R, dicha regresi√≥n se implementa mediante la funci√≥n de entrega est√°ndar lm (..).  Tambi√©n se puede representar por regresi√≥n polin√≥mica.  Como en el caso m√°s simple, aqu√≠ usamos una variable predictiva x, pero tambi√©n su cuadrado y grados posteriores, entonces xn == xn: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/248/b3c/bd4/248b3cbd40c637b1a15376d227432e81.png" alt="imagen"><br><br>  Si n = 2 o n = 3, la regresi√≥n polin√≥mica se usa a menudo para predecir el pr√≥ximo precio promedio a partir de los precios suavizados de las √∫ltimas barras.  Para la regresi√≥n polin√≥mica, se puede utilizar la funci√≥n polyfit de MatLab, R, Zorro y muchas otras plataformas. <br><br><h2>  4. Perceptr√≥n </h2><br>  A menudo se llama una red neuronal con una sola neurona.  De hecho, el perceptr√≥n es una funci√≥n de regresi√≥n, como se describi√≥ anteriormente, pero con un resultado binario, como resultado de lo cual se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">regresi√≥n log√≠stica</a> .  Aunque, en general, esto no es una regresi√≥n, sino un algoritmo de clasificaci√≥n.  Por ejemplo, la funci√≥n de aviso (PERCEPTRON, ...) del marco Zorro genera un c√≥digo C que devuelve 100 o -100 dependiendo de si el resultado predicho es umbral o no: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">-27.99</span></span>*sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-number"><span class="hljs-number">1.24</span></span>*sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">3.54</span></span>*sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">-21.50</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-100</span></span>; }</code> </pre> <br>  Como puede ver, la matriz sig es equivalente a las funciones xn en la f√≥rmula de regresi√≥n, y los coeficientes an son los factores digitales. <br><br><h2>  5. Redes neuronales </h2><br>  La regresi√≥n lineal o log√≠stica solo puede resolver problemas lineales.  Al mismo tiempo, las tareas comerciales a menudo no encajan en esta categor√≠a.  Un ejemplo famoso es la predicci√≥n de la salida de una funci√≥n XOR simple.  Esto tambi√©n incluye la predicci√≥n de ganancias de las transacciones.  Una red neuronal artificial (ANN) puede resolver problemas no lineales.  Este es un conjunto de perceptrones que est√°n conectados en una matriz de diferentes niveles.  Cada perceptr√≥n es una neurona de red.  Su salida se convierte en entrada a otras neuronas del siguiente nivel: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/050/d12/c5d/050d12c5da82f4f97fdd942d7777b8e4.png" alt="imagen"><br><br>  Al igual que el perceptr√≥n, la red neuronal se entrena determinando coeficientes que minimizan el error entre la predicci√≥n y el objetivo en la muestra.  Esto requiere un proceso de aproximaci√≥n, generalmente con la propagaci√≥n hacia atr√°s del error desde la salida a la entrada con la optimizaci√≥n de los pesos en el camino.  Este proceso tiene dos limitaciones.  Primero, la salida de neuronas debe ser una funci√≥n continuamente diferenciable en lugar de un umbral simple para el perceptr√≥n.  En segundo lugar, la red no debe ser muy profunda: la presencia de una gran cantidad de niveles ocultos de neuronas entre los datos de entrada y salida solo perjudica.  Esta segunda limitaci√≥n limita la complejidad de los problemas que una red neuronal est√°ndar puede resolver. <br><br>  Cuando use redes neuronales para predecir transacciones, tendr√° muchos par√°metros que pueden manipularse, lo que, si se hace de manera incorrecta, puede dar como resultado un sesgo de selecci√≥n (sesgo de selecci√≥n): <br><br><ul><li>  cantidad de niveles ocultos; </li><li>  la cantidad de neuronas en cada nivel oculto; </li><li>  n√∫mero de ciclos de propagaci√≥n hacia atr√°s - √©pocas; </li><li>  grado de entrenamiento, ancho de paso de la era; </li><li>  impulso, factor de inercia para la adaptaci√≥n de pesas; </li><li>  funci√≥n de activaci√≥n </li></ul><br>  La funci√≥n de activaci√≥n emula el umbral del perceptr√≥n.  Para la propagaci√≥n hacia atr√°s, necesita una funci√≥n constantemente diferenciable que genere un paso suave para un cierto valor de x.  Por lo general, para esto se utilizan las funciones sigmoide, tanh o softmax.  A veces se utiliza una funci√≥n lineal que devuelve la suma ponderada de todos los datos de entrada.  En este caso, la red se puede utilizar para la regresi√≥n, la predicci√≥n de valores num√©ricos en lugar de la salida binaria. <br><br>  Las redes neuronales se incluyen en la entrega de paquetes est√°ndar de R (por ejemplo, nnet es una red con un nivel oculto), as√≠ como en muchos otros paquetes (como RSNNS y FCNN4R). <br><br><h2>  6. Aprendizaje profundo </h2><br>  Los m√©todos de aprendizaje profundo utilizan redes neuronales con muchos niveles ocultos y miles de neuronas que no pueden entrenarse de manera efectiva mediante la simple propagaci√≥n de la espalda.  En los √∫ltimos a√±os, varios m√©todos se han vuelto populares para entrenar redes tan grandes.  Por lo general, implican un entrenamiento previo de niveles ocultos de neuronas para aumentar la efectividad del aprendizaje b√°sico. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La</a> m√°quina de Boltzmann restringida (RBM) es un algoritmo de clasificaci√≥n no controlado con una estructura de red especial en la que no hay conexiones entre las neuronas ocultas.  Sparse Auto Encoder (SAE) utiliza la estructura de red habitual, pero pre-entrena niveles ocultos de una manera espec√≠fica, reproduciendo se√±ales de entrada en los niveles de salida con la menor cantidad de conexiones activas posible.  Estos m√©todos le permiten implementar redes muy complejas para resolver problemas de aprendizaje muy complejos.  Por ejemplo, la tarea de derrotar a la mejor persona que juega Go. <br><br>  Las redes de aprendizaje profundo est√°n incluidas en los paquetes deepnet y darch para R. Deepnet incluye el codificador autom√°tico, y darch incluye la m√°quina Boltzmann.  A continuaci√≥n se muestra un ejemplo de c√≥digo que utiliza la red profunda con tres niveles ocultos para procesar se√±ales comerciales a trav√©s de la funci√≥n neor () del marco Zorro: <br><br><pre> <code class="cpp hljs">library(<span class="hljs-string"><span class="hljs-string">'deepnet'</span></span>, quietly = T) library(<span class="hljs-string"><span class="hljs-string">'caret'</span></span>, quietly = T) <span class="hljs-meta"><span class="hljs-meta"># called by Zorro for training neural.train = function(model,XY) { XY </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;- as.matrix(XY) X &lt;- XY[,-ncol(XY)] # predictors Y &lt;- XY[,ncol(XY)] # target Y &lt;- ifelse(Y &gt; 0,1,0) # convert -1..1 to 0..1 Models[[model]] &lt;&lt;- sae.dnn.train(X,Y, hidden = c(50,100,50), activationfun = "tanh", learningrate = 0.5, momentum = 0.5, learningrate_scale = 1.0, output = "sigm", sae_output = "linear", numepochs = 100, batchsize = 100, hidden_dropout = 0, visible_dropout = 0) } # called by Zorro for prediction neural.predict = function(model,X) { if(is.vector(X)) X &lt;- t(X) # transpose horizontal vector return(nn.predict(Models[[model]],X)) } # called by Zorro for saving the models neural.save = function(name) { save(Models,file=name) # save trained models } # called by Zorro for initialization neural.init = function() { set.seed(365) Models &lt;&lt;- vector("list") } # quick OOS test for experimenting with the settings Test = function() { neural.init() XY &lt;&lt;- read.csv('C:/Project/Zorro/Data/signals0.csv',header = F) splits &lt;- nrow(XY)*0.8 XY.tr &lt;&lt;- head(XY,splits) # training set XY.ts &lt;&lt;- tail(XY,-splits) # test set neural.train(1,XY.tr) X &lt;&lt;- XY.ts[,-ncol(XY.ts)] Y &lt;&lt;- XY.ts[,ncol(XY.ts)] Y.ob &lt;&lt;- ifelse(Y &gt; 0,1,0) Y &lt;&lt;- neural.predict(1,X) Y.pr &lt;&lt;- ifelse(Y &gt; 0.5,1,0) confusionMatrix(Y.pr,Y.ob) # display prediction accuracy }</span></span></span></span></code> </pre> <br><h2>  7. Vectores de soporte </h2><br>  Al igual que con las redes neuronales, el m√©todo del vector de soporte es otra extensi√≥n de la regresi√≥n lineal.  Si observa la f√≥rmula de regresi√≥n nuevamente: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d0/230/0e1/3d02300e11bdf79ba483a647d5089421.png" alt="imagen"><br><br>  Entonces uno puede interpretar las funciones xn como las coordenadas de un espacio n-dimensional.  Establecer la variable objetivo y en un valor fijo determinar√° el plano en este espacio; se llamar√° hiperplano, porque de hecho tendr√° dos (incluso n-1) tama√±os.  El hiperplano separa las muestras con y&gt; 0 de aquellas donde y &lt;0. Los coeficientes an se pueden calcular como la ruta que separa el plano de las muestras m√°s cercanas, sus vectores de soporte, de ah√≠ el nombre del algoritmo.  Por lo tanto, obtenemos un clasificador binario con la separaci√≥n √≥ptima de muestras ganadoras y perdedoras. <br><br>  Problema: por lo general, estas muestras no se pueden dividir linealmente; se agrupan aleatoriamente en un espacio de funciones.  Es imposible dibujar un plano suave entre las opciones ganadoras y perdedoras; si esto se pudiera hacer, para su c√°lculo se podr√≠an usar m√©todos m√°s simples como el an√°lisis discriminante lineal.  Pero en el caso general, puede usar el truco: agregar m√°s tama√±os al espacio.  En este caso, el algoritmo de vector de soporte podr√° generar m√°s par√°metros con una funci√≥n nuclear que combine dos predictores, por analog√≠a con la transici√≥n de la regresi√≥n simple al polinomio.  Cuantos m√°s tama√±os agregue, m√°s f√°cil ser√° dividir las muestras con un hiperplano.  Luego se puede volver a convertir al espacio n-dimensional original. <br><br>  Al igual que las redes neuronales, los vectores de referencia pueden usarse no solo para la clasificaci√≥n, sino tambi√©n para la regresi√≥n.  Tambi√©n ofrecen una serie de opciones para la optimizaci√≥n y posible reentrenamiento: <br><br><ul><li>  Funci√≥n del n√∫cleo: generalmente se utiliza el n√∫cleo RBF (funci√≥n de base radial, n√∫cleo sim√©trico), pero se pueden seleccionar otros n√∫cleos, por ejemplo, sigmoides, polinomiales y lineales. </li><li>  Gamma: ancho del n√∫cleo RBF. </li><li>  Par√°metro de costo C, "penalizaci√≥n" por clasificaciones incorrectas de muestras de entrenamiento. </li></ul><br>  A menudo se usa la biblioteca libsvm, que est√° disponible en el paquete e1071 para R. <br><br><h2>  8. Algoritmo de vecinos k-m√°s cercanos </h2><br>  En comparaci√≥n con el pesado ANN y SVM, este es un algoritmo simple y agradable con una propiedad √∫nica: no necesita ser entrenado.  Las muestras ser√°n el modelo.  Este algoritmo se puede usar para un sistema de comercio que se entrena constantemente agregando nuevas muestras.  Este algoritmo calcula las distancias en el espacio de funciones desde el valor actual hasta las muestras k m√°s cercanas.  La distancia en el espacio n-dimensional entre los dos conjuntos (x1 ... xn) y (y1 ... yn) se calcula mediante la f√≥rmula: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66e/322/2bc/66e3222bce4b5e79d460e20b612eadcb.png" alt="imagen"><br><br>  El algoritmo simplemente predice el objetivo a partir del promedio de k variables objetivo de las muestras m√°s cercanas, ponderadas por sus distancias de retorno.  Se puede usar tanto para clasificaci√≥n como para regresi√≥n.  Para predecir los vecinos m√°s cercanos, puede llamar a la funci√≥n knn en R o escribir el c√≥digo C usted mismo para este prop√≥sito. <br><br><h2>  9. K-significa </h2><br>  Este es un algoritmo de aproximaci√≥n para la clasificaci√≥n no controlada.  Es algo similar al algoritmo anterior.  Para clasificar las muestras, el algoritmo primero coloca k puntos aleatorios en el espacio de funciones.  Luego asigna a uno de estos puntos todas las muestras con la distancia m√°s peque√±a.  Luego, el punto se desplaza a la mitad de estos valores m√°s cercanos.  Esto genera nuevos enlaces de muestra, ya que algunos de ellos ahora estar√°n m√°s cerca de otros puntos.  El proceso se repite hasta que se detiene la re-referencia como resultado del cambio de los puntos, es decir, hasta que cada punto sea promedio para las muestras m√°s cercanas.  Ahora tenemos k clases de muestra, cada una ubicada al lado de un punto k. <br><br>  Este algoritmo simple puede producir resultados sorprendentemente buenos.  En R, la funci√≥n kmeans se usa para implementarla; se puede encontrar un ejemplo del algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el enlace</a> . <br><br><h2>  10. ingenuo Bayes </h2><br>  Este algoritmo utiliza el teorema bayesiano para clasificar muestras de funciones no num√©ricas (eventos), como los patrones de velas mencionados anteriormente.  Suponga que el evento X (por ejemplo, el par√°metro Open de la barra anterior debajo del par√°metro Open de la barra actual) aparece en el 80% de las muestras ganadoras.  Entonces, ¬øcu√°l ser√° la probabilidad de ganar la muestra en presencia del evento X en ella?  Esto no es 0.8 como podr√≠a pensar.  Esta probabilidad se calcula mediante la f√≥rmula: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/727/e4e/7ab/727e4e7abb69e9b8ef5334558a753a70.png" alt="imagen"><br><br>  P (Y | X) es la probabilidad de que el evento Y (ganancia) ocurra en todas las muestras que contienen el evento X (en nuestro ejemplo, Open (1) &lt;Open (0)).  De acuerdo con la f√≥rmula, es igual a la probabilidad de ocurrencia del evento X en todas las muestras ganadoras (en nuestro caso, 0.8), multiplicado por la probabilidad Y en todas las muestras (aproximadamente 0.5 si sigue los consejos para equilibrar las muestras) y dividido por la probabilidad de ocurrencia de X en todas las muestras <br><br>  Si somos ingenuos y asumimos que todos los eventos de X son independientes entre s√≠, entonces podemos calcular la probabilidad total de que la muestra gane simplemente multiplicando las probabilidades P (X | ganar) para cada evento X. Luego llegamos a la siguiente f√≥rmula: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b0/c54/d51/7b0c54d515098b06b54e7446d9097954.png" alt="imagen"><br><br>  Con factor de escala s.  Para que una f√≥rmula funcione, las funciones deben elegirse de tal manera que sean lo m√°s independientes posible.  Esto ser√° un obst√°culo para usar ingenuos Bayes para el comercio.  Por ejemplo, dos eventos Cerrar (1) &lt;Cerrar (0) y Abrir (1) &lt;Abrir (0) probablemente no sean independientes entre s√≠.  Los predictores num√©ricos se pueden convertir en eventos dividiendo el n√∫mero en rangos separados.  Naive Bayes est√° disponible en el paquete e1071 para R. <br><br><h2>  11. √Årboles de decisi√≥n y regresi√≥n </h2><br>  Dichos √°rboles predicen el resultado de valores num√©ricos basados ‚Äã‚Äãen una cadena de decisi√≥n en el formato s√≠ / no en la estructura de las ramas de los √°rboles.  Cada decisi√≥n representa la presencia o ausencia de eventos (en el caso de valores no num√©ricos) o la comparaci√≥n de valores con un umbral fijo.  Una funci√≥n de √°rbol t√≠pica, generada, por ejemplo, por el marco Zorro, se ve as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">12.938</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">0.953</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-70</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">43</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">0.962</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-67</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">0.732</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-71</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">30.61</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">27</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">46</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-62</span></span>; } } } }</code> </pre> <br>  ¬øC√≥mo se obtiene tal √°rbol de un conjunto de muestras?  Puede haber varios m√©todos para esto, incluida <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la entrop√≠a informativa de Shannon</a> . <br><br>  Los √°rboles de decisi√≥n pueden ser ampliamente utilizados.  Por ejemplo, son adecuados para generar predicciones que son m√°s precisas de lo que se puede lograr utilizando redes neuronales o vectores de referencia.  Sin embargo, esta no es una soluci√≥n universal.  El algoritmo m√°s conocido de este tipo es C5.0, disponible en el paquete C50 para R. <br><br>  Para mejorar a√∫n m√°s la calidad de las predicciones, puede utilizar conjuntos de √°rboles: se denominan bosques aleatorios.  Este algoritmo est√° disponible en paquetes R llamados randomForest, ranger y Rborist. <br><br><h2>  Conclusi√≥n </h2><br>  Existen muchos m√©todos de miner√≠a de datos y aprendizaje autom√°tico.  La pregunta cr√≠tica aqu√≠ es: ¬øcu√°l es mejor, estrategias basadas en modelos o de aprendizaje autom√°tico?  No hay duda de que el aprendizaje autom√°tico tiene una serie de ventajas.  Por ejemplo, no necesita preocuparse por la microestructura del mercado, la econom√≠a, tener en cuenta la filosof√≠a de los participantes del mercado u otras cosas similares.  Puedes concentrarte en matem√°ticas puras.  El aprendizaje autom√°tico es una forma mucho m√°s elegante y atractiva de crear sistemas comerciales.  Por su parte, todas las ventajas, excepto una, adem√°s de las historias en los foros de comerciantes, el √©xito de este m√©todo en el comercio real es dif√≠cil de rastrear. <br><br>  Casi todas las semanas, se publican nuevos art√≠culos sobre el comercio mediante el aprendizaje autom√°tico.  Dichos materiales deben tomarse con bastante escepticismo.  Algunos autores afirman tasas ganadoras fant√°sticas de 70%, 80% o incluso 85%.  Sin embargo, pocas personas dicen que puede perder dinero incluso si las predicciones est√°n ganando.  Una precisi√≥n del 85% generalmente se traduce en un indicador de rentabilidad superior a 5: si todo fuera tan simple, los creadores de dicho sistema ya se convertir√≠an en multimillonarios.  Sin embargo, por alguna raz√≥n, la reproducci√≥n de los mismos resultados simplemente repitiendo los m√©todos descritos en los art√≠culos falla. <br><br>  En comparaci√≥n con los sistemas basados ‚Äã‚Äãen modelos, hay muy pocos sistemas de aprendizaje autom√°tico realmente exitosos.  Por ejemplo, rara vez son utilizados por fondos de cobertura exitosos.  Quiz√°s en el futuro, cuando la potencia inform√°tica se vuelva a√∫n m√°s accesible, algo cambie, pero hasta ahora los algoritmos de aprendizaje profundo siguen siendo m√°s un pasatiempo interesante para los geeks que una herramienta real para ganar dinero en el intercambio. <br><br><h2>  Otros materiales financieros y burs√°tiles de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ITI Capital</a> : </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">An√°lisis y an√°lisis de mercado.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Regreso al futuro: comprobar el rendimiento de un robot comercial utilizando datos hist√≥ricos</a> </li><li>  Backtesting Python controlado por eventos paso a paso ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 4</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 5</a> ) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es412639/">https://habr.com/ru/post/es412639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es412625/index.html">C√≥mo encontrar r√°pidamente y no perder especialistas en inteligencia artificial y ciencia de datos</a></li>
<li><a href="../es412627/index.html">Exposici√≥n Internacional CMEF & ICMD 2018 Primavera en Shanghai (Parte 2)</a></li>
<li><a href="../es412629/index.html">Forma de onda adaptativa para su servicio de audio</a></li>
<li><a href="../es412633/index.html">Experiencia en la configuraci√≥n y uso de WSL (subsistema de Linux en Windows 10)</a></li>
<li><a href="../es412637/index.html">¬øHacer o no redise√±ar logotipos? Esa es la pregunta</a></li>
<li><a href="../es412641/index.html">¬øQu√© tienen en com√∫n la miner√≠a, Georgia e Irkutsk?</a></li>
<li><a href="../es412643/index.html">C√≥mo integramos el sistema de pago en el proyecto ruso</a></li>
<li><a href="../es412645/index.html">Objeto, propiedad, actividad: modelos y m√©todos de construcci√≥n.</a></li>
<li><a href="../es412647/index.html">Nueva evidencia de la existencia del noveno planeta.</a></li>
<li><a href="../es412649/index.html">C√≥mo construir un equipo y procesos enfocados en un r√°pido crecimiento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>