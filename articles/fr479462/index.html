<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüéì üö™ ü•ú S√©rialisation en C ++ üóÇÔ∏è üïµüèΩ ü¶ì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article se concentrera sur l'automatisation du processus de s√©rialisation en C ++. Au d√©but, nous discuterons des m√©canismes de base pour simplifi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>S√©rialisation en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479462/">  Cet article se concentrera sur l'automatisation du processus de s√©rialisation en C ++.  Au d√©but, nous discuterons des m√©canismes de base pour simplifier la lecture / √©criture des donn√©es dans les flux d'entr√©e / sortie, apr√®s quoi une description sera donn√©e d'un syst√®me de g√©n√©ration de code bas√© sur libclang primitif.  Un lien vers le r√©f√©rentiel avec une version de d√©monstration de la biblioth√®que se trouve √† la fin de l'article. <br><a name="habracut"></a><br>  √Ä ruSO, des questions se posent p√©riodiquement concernant la s√©rialisation des donn√©es en C ++, parfois ces questions sont de nature g√©n√©rale, lorsque TC ne sait pas par o√π commencer, parfois ce sont des questions d√©crivant un probl√®me sp√©cifique.  Le but de cet article est de r√©sumer l'une des mani√®res possibles d'impl√©menter la s√©rialisation en C ++, qui vous permettra de suivre les √©tapes de la construction d'un syst√®me depuis les √©tapes initiales jusqu'√† une conclusion logique, lorsque ce syst√®me peut d√©j√† √™tre utilis√© dans la pratique. <br><br><h2>  1. Informations initiales </h2><br>  Cet article utilisera un format de donn√©es binaires, dont la structure est d√©termin√©e en fonction des types d'objets s√©rialisables.  Cette approche nous √©vite d'utiliser des biblioth√®ques tierces, se limitant uniquement aux outils fournis par la biblioth√®que C ++ standard. <br><br>  Le processus de s√©rialisation consistant √† convertir l'√©tat d'un objet en un flux d'octets, qui devrait √©videmment √™tre accompagn√© d'op√©rations d'√©criture, ces derni√®res seront utilis√©es √† la place du terme ¬´s√©rialisation¬ª pour d√©crire des d√©tails de bas niveau.  De m√™me pour la lecture / d√©s√©rialisation. <br><br>  Pour r√©duire le volume de l'article, seuls des exemples de s√©rialisation d'objets seront donn√©s (sauf dans les cas o√π la d√©s√©rialisation contient des d√©tails qui m√©ritent d'√™tre mentionn√©s).  Le code complet peut √™tre trouv√© dans le r√©f√©rentiel ci-dessus. <br><br><h2>  2. Types pris en charge </h2><br>  Tout d'abord, il convient de d√©cider des types que nous pr√©voyons de prendre en charge - cela d√©pend directement de la fa√ßon dont la biblioth√®que sera impl√©ment√©e. <br><br>  Par exemple, si le choix est limit√© aux types fondamentaux de C ++, alors un mod√®le de fonction (qui est une famille de fonctions pour travailler avec les valeurs des types entiers) et ses sp√©cialisations explicites suffiront.  Mod√®le principal (utilis√© pour les types std :: int32_t, std :: uint16_t, etc.): <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, T value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;value), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(value)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); }</code> </pre> <br>  <b>Remarque</b> : si les donn√©es obtenues lors de la s√©rialisation sont pr√©vues pour √™tre transf√©r√©es entre des machines avec des ordres d'octets diff√©rents, il est n√©cessaire, par exemple, de convertir une valeur de l'ordre d'octets local en octet r√©seau, puis d'effectuer l'op√©ration inverse sur la machine distante, donc des modifications seront n√©cessaires quant √† la fonction d'√©criture donn√©es au flux de sortie, et pour la fonction de lecture √† partir du flux d'entr√©e. <br><br>  Sp√©cialisation pour bool: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> t_value = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">'T'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f_value = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">'F'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmp = (value) ? t_value : f_value; os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;tmp), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tmp)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); }</code> </pre> <br>  Cette approche d√©finit la r√®gle suivante: si une valeur de type T peut √™tre repr√©sent√©e comme une s√©quence d'octets de longueur sizeof (T), la d√©finition du mod√®le primaire peut √™tre utilis√©e pour cela, sinon, il est n√©cessaire de d√©terminer la sp√©cialisation.  Cette exigence peut √™tre dict√©e par les caract√©ristiques de la repr√©sentation d'un objet de type T en m√©moire. <br><br>  Consid√©rez le conteneur std :: string: il est √©vident que nous ne pouvons pas prendre l'adresse d'un objet du type sp√©cifi√©, le convertir en un pointeur sur char et l'√©crire dans le flux de sortie - ce qui signifie que nous avons besoin d'une sp√©cialisation: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> len = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(value.size()); os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;len), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(len)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) os.write(value.data(), len); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); }</code> </pre> <br>  Deux points importants √† souligner ici: <br><br><ol><li>  Non seulement le contenu de la cha√Æne est √©crit dans le flux de sortie, mais √©galement sa taille. </li><li>  Cast std :: string :: size_type pour taper std :: uint32_t.  Dans ce cas, il convient de pr√™ter attention non pas √† la taille du type cible, mais au fait qu'il est de longueur fixe.  Une telle r√©duction permettra d'√©viter des probl√®mes dans le cas, par exemple, si des donn√©es sont transmises sur un r√©seau entre des machines de tailles de mots machine diff√©rentes. </li></ol><br>  Nous avons donc d√©couvert que les valeurs des types fondamentaux (et m√™me des objets de type std :: string) peuvent √™tre √©crites dans le flux de sortie √† l'aide du mod√®le de fonction d' <b>√©criture</b> .  Analysons maintenant les modifications que nous devons apporter si nous voulons ajouter des conteneurs √† la liste des types pris en charge.  Nous n'avons qu'une seule option pour la surcharge - utilisez le param√®tre T comme type d'√©l√©ments de conteneur.  Et si dans le cas de std :: vector cela fonctionnera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> len = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>&gt;(value.size()); os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;len), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(len)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(value.cbegin(), value.cend(), [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; e) { size += ::write(os, e); }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; }</code> </pre> <br>  , puis avec std: map - non, car le mod√®le std :: map n√©cessite au moins deux param√®tres - le type de cl√© et le type de valeur.  Ainsi, √† ce stade, nous ne pouvons plus utiliser le mod√®le de fonction - nous avons besoin d'une solution plus universelle.  Avant de d√©couvrir comment ajouter la prise en charge des conteneurs, rappelons que nous avons toujours des classes personnalis√©es.  De toute √©vidence, m√™me en utilisant la solution actuelle, il ne serait pas judicieux de surcharger la fonction d' <b>√©criture</b> pour chaque classe qui n√©cessite une s√©rialisation.  Dans le meilleur des cas, nous aimerions avoir une sp√©cialisation du mod√®le d' <b>√©criture</b> qui fonctionne avec les types de donn√©es personnalis√©s.  Mais pour cela, il est n√©cessaire que les classes aient la capacit√© de contr√¥ler ind√©pendamment la s√©rialisation, respectivement, elles devraient avoir une interface qui permettrait √† l'utilisateur de s√©rialiser et de d√©s√©rialiser les objets de cette classe.  Comme il s'av√®re un peu plus tard, cette interface servira de ¬´d√©nominateur commun¬ª pour le mod√®le d' <b>√©criture</b> lors de l'utilisation de classes personnalis√©es.  D√©finissons-le. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISerializable</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: ~ISerializable() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deserialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream&amp; is)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialized_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br>  Toute classe qui h√©rite de <b>ISerializable</b> s'engage √†: <br><br><ol><li>  Remplacer l'√©tat <b>s√©rialiser</b> - √©crire (membres de donn√©es) dans le flux de sortie. </li><li>  Override <b>deserialize</b> - Lit l'√©tat (initialisation des membres de donn√©es) du flux d'entr√©e. </li><li>  Override <b>serialized_size</b> - calcule la taille des donn√©es s√©rialis√©es pour l'√©tat actuel de l'objet. </li></ol><br>  Donc, revenons au mod√®le de fonction d' <b>√©criture</b> : en g√©n√©ral, nous pouvons impl√©menter la sp√©cialisation pour la classe <b>ISerializable</b> , mais nous ne pouvons pas l'utiliser, jetez un ≈ìil: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ISerializable&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value.serialize(os); }</code> </pre> <br>  √Ä chaque fois, nous <b>devions convertir le</b> type d'h√©ritier en <b>ISerializable</b> pour profiter de cette sp√©cialisation.  Permettez-moi de vous rappeler qu'au tout d√©but, nous nous √©tions fix√© comme objectif de simplifier l'√©criture de code li√© √† la s√©rialisation, et non l'inverse, de le compliquer.  Donc, si les types pris en charge par notre biblioth√®que ne se limitent pas aux types fondamentaux, alors nous devrions chercher une autre solution. <br><br><h2>  3. stream_writer </h2><br>  L'utilisation de mod√®les de fonctions pour impl√©menter une interface universelle pour √©crire des donn√©es dans un flux n'√©tait pas une solution tout √† fait appropri√©e.  La prochaine option que nous devrions v√©rifier est le mod√®le de classe.  Nous suivrons la m√™me m√©thodologie que celle utilis√©e avec le mod√®le de fonction - le mod√®le principal sera utilis√© par d√©faut et des sp√©cialisations explicites seront ajout√©es pour prendre en charge les types n√©cessaires. <br><br>  De plus, nous devons prendre en compte tout ce qui pr√©c√®de sur <b>ISerializable</b> - √©videmment, nous ne serons pas en mesure de r√©soudre le probl√®me avec de nombreuses classes successives sans recourir √† type_traits: √† partir de C ++ 11, le mod√®le std :: enable_if est apparu dans la biblioth√®que standard, ce qui permet d'ignorer les classes de mod√®les lorsque certaines conditions lors de la compilation - et c'est exactement ce dont nous allons profiter. <br><br>  <b>Mod√®le de</b> classe <b>Stream_writer</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; class stream_writer { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> write(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>; };</code> </pre> <br>  La d√©finition de la m√©thode d' <b>√©criture</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream_writer&lt;T, U&gt;::write(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;value), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(value)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); }</code> </pre> <br>  La sp√©cialisation pour <b>ISerializable</b> sera la suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stream_writer</span></span></span><span class="hljs-class">&lt;T, only_if_serializable&lt;T&gt;&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> stream_io&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t</span></span>; };</code> </pre> <br>  o√π only_if_serializable est un type d'assistance: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> only_if_serializable = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of_v&lt;ISerializable, T&gt;&gt;;</code> </pre> <br>  Ainsi, si le type T est une classe d√©riv√©e de <b>ISerializable</b> , alors cette sp√©cialisation sera consid√©r√©e comme candidate √† l'instanciation, respectivement, si le type T n'est pas dans la m√™me hi√©rarchie de classes <b>qu'ISerializable</b> , elle sera exclue des candidats possibles. <br><br>  Il serait juste de poser ici la question suivante: comment cela fonctionnera-t-il?  Apr√®s tout, le mod√®le principal aura les m√™mes valeurs de param√®tres typiques que sa sp√©cialisation - &lt;T, void&gt;.  Pourquoi la sp√©cialisation sera-t-elle privil√©gi√©e et le sera-t-elle?  R√©ponse: sera, car un tel comportement est prescrit par la norme ( <a href="" rel="nofollow">source</a> ): <br><br><blockquote>  (1.1) Si exactement une sp√©cialisation correspondante est trouv√©e, l'instanciation est g√©n√©r√©e √† partir de cette sp√©cialisation </blockquote><br>  La sp√©cialisation de std :: string ressemblera maintenant √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stream_writer</span></span></span><span class="hljs-class">&lt;T, only_if_string&lt;T&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream_writer&lt;T, only_if_string&lt;T&gt;&gt;::write(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> len = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(value.size()); os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;len), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(len)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) os.write(value.data(), len); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); }</code> </pre> <br>  o√π only_if_string est d√©clar√© comme: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> only_if_string = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same_v&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&gt;;</code> </pre> <br>  Il est temps de retourner dans les conteneurs.  Dans ce cas, nous pouvons utiliser le type de conteneur param√©tr√© avec un certain type de U, ou &lt;U, V&gt;, comme dans le cas de std :: map, directement comme valeur du param√®tre T du mod√®le de la classe <b>stream_writer</b> .  Ainsi, rien ne change dans l'interface de notre interface - c'est ce que nous visions.  Cependant, la question se pose, quel devrait √™tre le deuxi√®me param√®tre du mod√®le pour la classe <b>stream_writer pour</b> que tout fonctionne correctement?  C'est dans le chapitre suivant. <br><br><h2>  4. Concepts </h2><br>  Tout d'abord, je donnerai une br√®ve description des concepts utilis√©s, puis seulement je montrerai des exemples mis √† jour. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept String = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same_v&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;;</code> </pre> <br>  Honn√™tement, ce concept a √©t√© d√©fini pour la fraude, que nous verrons sur la ligne suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept Container = !String&lt;T&gt; &amp;&amp; requires (T a) { <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::value_type; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::reference; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::const_reference; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::iterator; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::const_iterator; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::size_type; { a.begin() } -&gt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::iterator; { a.end() } -&gt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::iterator; { a.cbegin() } -&gt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::const_iterator; { a.cend() } -&gt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::const_iterator; { a.clear() } -&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; };</code> </pre> <br>  <b>Le conteneur</b> contient les exigences que nous ¬´faisons¬ª au type pour vraiment nous assurer qu'il s'agit bien d'un des types de conteneur.  C'est exactement l'ensemble des exigences dont nous aurons besoin lors de l'impl√©mentation de <b>stream_writer</b> , la norme a bien s√ªr beaucoup plus d'exigences. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept SequenceContainer = Container&lt;T&gt; &amp;&amp; requires (T a, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::size_type count) { { a.resize(count) } -&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; };</code> </pre> <br>  Concept pour les conteneurs s√©quentiels: std :: vector, std :: list, etc. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept AssociativeContainer = Container&lt;T&gt; &amp;&amp; requires (T a) { <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::key_type; };</code> </pre> <br>  Concept pour les conteneurs associatifs: std :: map, std :: set, std :: unordered_map, etc. <br><br>  Maintenant, pour d√©terminer la sp√©cialisation des conteneurs cons√©cutifs, il ne nous reste plus qu'√† imposer des restrictions sur le type T: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; requires SequenceContainer&lt;T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stream_writer</span></span></span><span class="hljs-class">&lt;T, void&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; requires SequenceContainer&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream_writer&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt;::write(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); <span class="hljs-comment"><span class="hljs-comment">// to support std::forward_list we have to use std::distance() const auto len = static_cast&lt;std::uint16_t&gt;( std::distance(value.cbegin(), value.cend())); os.write(reinterpret_cast&lt;const char*&gt;(&amp;len), sizeof(len)); auto size = static_cast&lt;std::size_t&gt;(os.tellp() - pos); if (len &gt; 0) { using value_t = typename stream_writer::value_type; std::for_each(value.cbegin(), value.cend(), [&amp;](const auto&amp; item) { size += stream_writer&lt;value_t&gt;::write(os, item); }); } return size; }</span></span></code> </pre> <br>  Conteneurs pris en charge: <br><br><ul><li>  std :: vecteur </li><li>  std :: deque </li><li>  std :: list </li><li>  std :: forward_list </li></ul><br>  De m√™me pour les conteneurs associatifs: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; requires AssociativeContainer&lt;T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stream_writer</span></span></span><span class="hljs-class">&lt;T, void&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> stream_io&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; requires AssociativeContainer&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream_writer&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt;::write(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> len = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> stream_writer::size_type&gt;(value.size()); os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;len), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(len)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> stream_writer::value_type; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(value.cbegin(), value.cend(), [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; item) { size += stream_writer&lt;<span class="hljs-keyword"><span class="hljs-keyword">value_t</span></span>&gt;::write(os, item); }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; }</code> </pre> <br>  Conteneurs pris en charge: <br><br><ul><li>  std :: map </li><li>  std :: unordered_map </li><li>  std :: set </li><li>  std :: unordered_set </li></ul><br>  Dans le cas de map, il y a une petite nuance, elle concerne l'impl√©mentation de <b>stream_reader</b> .  Le type value_type pour std :: map &lt;K, T&gt; est std :: pair &lt;const K, T&gt;, respectivement, lorsque nous essayons de convertir un pointeur en const K en un pointeur en char lors de la lecture du flux d'entr√©e, nous obtenons une erreur de compilation.  Nous pouvons r√©soudre ce probl√®me comme suit: nous savons que pour les conteneurs associatifs value_type est soit un seul type K ou std :: pair &lt;const K, V&gt;, alors nous pouvons √©crire de petites classes d'aide de mod√®le qui seront param√©tr√©es par value_type et √† l'int√©rieur d√©terminer le type dont nous avons besoin. <br><br>  Pour std :: set, tout reste inchang√©: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> V = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; struct converter { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = U; };</code> </pre> <br>  Pour std :: map - supprimez const: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">converter</span></span></span><span class="hljs-class">&lt;U, only_if_pair&lt;U&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_const_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U::first_type&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U::second_type&gt;; };</code> </pre> <br>  La d√©finition de <b>lecture</b> pour les conteneurs associatifs: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; requires AssociativeContainer&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream_reader&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt;::read(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream&amp; is, T&amp; value) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = is.tellg(); <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> stream_reader::size_type len = <span class="hljs-number"><span class="hljs-number">0</span></span>; is.read(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;len), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(len)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(is.tellg() - pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">0U</span></span>; i &lt; len; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> converter&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> stream_reader::value_type&gt;::type; <span class="hljs-keyword"><span class="hljs-keyword">value_t</span></span> v {}; size += stream_reader&lt;<span class="hljs-keyword"><span class="hljs-keyword">value_t</span></span>&gt;::read(is, v); value.insert(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(v)); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; }</code> </pre> <br><br><h2>  5. Fonctions auxiliaires </h2><br>  Prenons un exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ISerializable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: User(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view username, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view password) : m_username(username) , m_password(password) {} SERIALIZABLE_INTERFACE <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_username {}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_password {}; };</code> </pre> <br>  La d√©finition de la m√©thode serialize (std :: ostream &amp;) pour cette classe devrait ressembler √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> User::serialize(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = <span class="hljs-number"><span class="hljs-number">0U</span></span>; size += stream_writer&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;::write(os, m_username); size += stream_writer&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;::write(os, m_password); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; }</code> </pre> <br>  Cependant, vous devez admettre qu'il n'est pas pratique d'indiquer √† chaque fois le type d'objet qui est √©crit dans le flux de sortie.  Nous √©crivons une fonction auxiliaire qui d√©duirait automatiquement le type T: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stream_writer&lt;T&gt;::write(os, value); }</code> </pre> <br>  Maintenant, la d√©finition est la suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> User::serialize(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = <span class="hljs-number"><span class="hljs-number">0U</span></span>; size += ::write(os, m_username); size += ::write(os, m_password); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; }</code> </pre> <br>  Le dernier chapitre n√©cessitera quelques fonctions d'assistance suppl√©mentaires: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_recursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ::write(os, value); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_recursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ts&amp;... values)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = write_recursive(os, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size + write_recursive(os, values...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_all</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ts&amp;... values)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> write_recursive(os, values...); }</code> </pre> <br>  La fonction <b>write_all vous</b> permet de r√©pertorier tous les objets √† s√©rialiser √† la fois, tandis que <b>write_recursive</b> garantit le bon ordre d'√©criture dans le flux de sortie.  Si l'ordre des calculs √©tait d√©fini pour les <a href="https://ru.cppreference.com/w/cpp/language/fold" rel="nofollow">expressions</a> de <a href="https://ru.cppreference.com/w/cpp/language/fold" rel="nofollow">repli</a> (√† condition d'utiliser l'op√©rateur binaire +), nous pourrions les utiliser.  En particulier, dans la fonction <b>size_of_all</b> (elle n'a pas √©t√© mentionn√©e plus haut, elle est utilis√©e pour calculer la taille des donn√©es s√©rialis√©es), ce sont les expressions de repli qui sont utilis√©es en raison de l'absence d'op√©rations d'entr√©e-sortie. <br><br><h2>  6. G√©n√©ration de code </h2><br>  L'API libclang-C pour clang est utilis√©e pour g√©n√©rer le code.  De haut niveau, cette t√¢che peut √™tre d√©crite comme suit: nous devons parcourir r√©cursivement le r√©pertoire avec le code source, v√©rifier tous les fichiers d'en-t√™te pour les classes marqu√©es avec un attribut sp√©cial, et s'il y en a un, v√©rifier les membres de donn√©es pour le m√™me attribut et compiler la cha√Æne √† partir des noms des membres de donn√©es r√©pertori√© avec une virgule.  Il ne nous reste plus qu'√† √©crire les mod√®les de d√©finition des fonctions de la classe <b>ISerializable</b> (dans laquelle nous ne pouvons que mettre l'√©num√©ration des membres de donn√©es n√©cessaires). <br><br>  Un exemple de classe pour laquelle le code sera g√©n√©r√©: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute__</span></span></span><span class="hljs-class">((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">annotate</span></span></span><span class="hljs-class">("</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">serializable</span></span></span><span class="hljs-class">"))) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ISerializable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: User(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view username, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view password) : m_username(username) , m_password(password) {} User() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~User() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; SERIALIZABLE_INTERFACE <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: __attribute__((annotate(<span class="hljs-string"><span class="hljs-string">"serializable"</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_username {}; __attribute__((annotate(<span class="hljs-string"><span class="hljs-string">"serializable"</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_password {}; };</code> </pre> <br>  Les attributs sont √©crits dans le style GNU car libclang refuse de reconna√Ætre le format d'attribut de C ++ 20, et il ne prend pas non plus en charge les attributs non annot√©s.  Travers√©e du r√©pertoire source: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; file : fs::recursive_directory_iterator(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.is_regular_file() &amp;&amp; file.path().extension() == <span class="hljs-string"><span class="hljs-string">".hpp"</span></span>) { processTranslationUnit(file, dst); } }</code> </pre> <br>  La d√©finition de la fonction <b>processTranslationUnit</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processTranslationUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fs::path&amp; path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fs::path&amp; targetDir)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pathname = path.<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(); arg::Context context { <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> translationUnit = arg::TranslationUnit::parse(context, pathname.c_str(), CXTranslationUnit_None); arg::ClassExtractor extractor; extractor.extract(translationUnit.cursor()); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; classes = extractor.classes(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [name, c] : classes) { SerializableDefGenerator::processClass(c, path, targetDir.<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>()); } }</code> </pre> <br>  Dans cette fonction, seul <b>ClassExtractor</b> nous int√©resse - tout le reste est n√©cessaire pour la formation d'AST.  La d√©finition de la fonction d' <b>extraction</b> est la suivante: <br><br><pre> <code class="cpp hljs">  <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ClassExtractor::extract(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CXCursor&amp; cursor) { clang_visitChildren(cursor, [](CXCursor c, CXCursor, CXClientData data) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clang_getCursorKind(c) == CXCursorKind::CXCursor_ClassDecl) { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* -    - */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* -     */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CXChildVisit_Continue; } , <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Ici, nous voyons d√©j√† directement les fonctions de l'API C pour clang.  Nous avons intentionnellement laiss√© uniquement le code n√©cessaire pour comprendre comment libclang est utilis√©.  Tout ce qui reste dans les coulisses ne contient pas d'informations importantes - c'est juste un enregistrement des noms de classe, des membres de donn√©es, etc.  Un code plus d√©taill√© peut √™tre trouv√© dans le r√©f√©rentiel. <br><br>  Et enfin, dans la fonction <b>processClass</b> , la pr√©sence des attributs de s√©rialisation de chaque classe trouv√©e est v√©rifi√©e, et s'il y en a un, un fichier est g√©n√©r√© avec la d√©finition des fonctions n√©cessaires.  Le r√©f√©rentiel fournit des exemples sp√©cifiques: o√π obtenir le ou les noms de l'espace de noms (ces informations sont stock√©es directement dans la classe <b>Class</b> ) et le chemin d'acc√®s au fichier d'en-t√™te. <br><br>  <i>Pour la t√¢che susmentionn√©e, la biblioth√®que Argentum est utilis√©e, ce que, malheureusement, je ne vous recommande pas d'utiliser - j'ai commenc√© √† la d√©velopper √† d'autres fins, mais parce que pour cette t√¢che, j'avais juste besoin des fonctionnalit√©s qui y √©taient impl√©ment√©es, et j'√©tais paresseux, Je n'ai pas r√©√©crit le code, mais l'ai simplement post√© sur Bintray et connect√© au fichier CMake via le gestionnaire de paquets Conan.</i>  <i>Tout ce que cette biblioth√®que fournit est de simples wrappers sur l'API clang C pour les classes et les membres de donn√©es.</i> <br><br>  Et encore une petite remarque - je ne fournis pas de biblioth√®que toute faite, je dis seulement comment l'√©crire. <br><br>  <b>UPD0</b> : cppast peut √™tre utilis√© √† la <a href="https://github.com/foonathan/cppast" rel="nofollow">place de libclang</a> .  Merci √† <a href="https://habr.com/ru/users/masterspline/" class="user_link">masterspline</a> pour le lien fourni. <br><br>  1. <a href="https://github.com/isnullxbh/dsl" rel="nofollow">github.com/isnullxbh/dsl</a> <br>  2. <a href="https://github.com/isnullxbh/Argentum" rel="nofollow">github.com/isnullxbh/Argentum</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479462/">https://habr.com/ru/post/fr479462/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479446/index.html">Les voitures ont d√©j√† une longueur d'avance sur les tests de lecture; mais comprennent-ils ce qu'ils lisent?</a></li>
<li><a href="../fr479450/index.html">AppCode 2019.3: fonctionne plus rapidement, comprend mieux Swift, conna√Æt Mac Catalyst et affiche facilement les messages d'assemblage</a></li>
<li><a href="../fr479452/index.html">Comment le syst√®me de noms de domaine s'est d√©velopp√©: l'√®re ARPANET</a></li>
<li><a href="../fr479458/index.html">Beaut√© ou praticit√© dans la salle des serveurs</a></li>
<li><a href="../fr479460/index.html">Un guide pour les voitures volantes</a></li>
<li><a href="../fr479464/index.html">Tuyaux et filtres. Exemple d'application et d'impl√©mentation √† l'aide de Spring</a></li>
<li><a href="../fr479466/index.html">Habraiting 2019: statistiques et classement des meilleurs articles pour 2019</a></li>
<li><a href="../fr479468/index.html">Edge of Honesty et John Doe</a></li>
<li><a href="../fr479474/index.html">Pourquoi l'auto-organisation des √©quipes est-elle si importante dans Scrum et pourquoi il ne peut y avoir de managers</a></li>
<li><a href="../fr479478/index.html">Plug-in Java sans douleur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>