<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🎓 🚪 🥜 Sérialisation en C ++ 🗂️ 🕵🏽 🦓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article se concentrera sur l'automatisation du processus de sérialisation en C ++. Au début, nous discuterons des mécanismes de base pour simplifi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sérialisation en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479462/">  Cet article se concentrera sur l'automatisation du processus de sérialisation en C ++.  Au début, nous discuterons des mécanismes de base pour simplifier la lecture / écriture des données dans les flux d'entrée / sortie, après quoi une description sera donnée d'un système de génération de code basé sur libclang primitif.  Un lien vers le référentiel avec une version de démonstration de la bibliothèque se trouve à la fin de l'article. <br><a name="habracut"></a><br>  À ruSO, des questions se posent périodiquement concernant la sérialisation des données en C ++, parfois ces questions sont de nature générale, lorsque TC ne sait pas par où commencer, parfois ce sont des questions décrivant un problème spécifique.  Le but de cet article est de résumer l'une des manières possibles d'implémenter la sérialisation en C ++, qui vous permettra de suivre les étapes de la construction d'un système depuis les étapes initiales jusqu'à une conclusion logique, lorsque ce système peut déjà être utilisé dans la pratique. <br><br><h2>  1. Informations initiales </h2><br>  Cet article utilisera un format de données binaires, dont la structure est déterminée en fonction des types d'objets sérialisables.  Cette approche nous évite d'utiliser des bibliothèques tierces, se limitant uniquement aux outils fournis par la bibliothèque C ++ standard. <br><br>  Le processus de sérialisation consistant à convertir l'état d'un objet en un flux d'octets, qui devrait évidemment être accompagné d'opérations d'écriture, ces dernières seront utilisées à la place du terme «sérialisation» pour décrire des détails de bas niveau.  De même pour la lecture / désérialisation. <br><br>  Pour réduire le volume de l'article, seuls des exemples de sérialisation d'objets seront donnés (sauf dans les cas où la désérialisation contient des détails qui méritent d'être mentionnés).  Le code complet peut être trouvé dans le référentiel ci-dessus. <br><br><h2>  2. Types pris en charge </h2><br>  Tout d'abord, il convient de décider des types que nous prévoyons de prendre en charge - cela dépend directement de la façon dont la bibliothèque sera implémentée. <br><br>  Par exemple, si le choix est limité aux types fondamentaux de C ++, alors un modèle de fonction (qui est une famille de fonctions pour travailler avec les valeurs des types entiers) et ses spécialisations explicites suffiront.  Modèle principal (utilisé pour les types std :: int32_t, std :: uint16_t, etc.): <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, T value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;value), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(value)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); }</code> </pre> <br>  <b>Remarque</b> : si les données obtenues lors de la sérialisation sont prévues pour être transférées entre des machines avec des ordres d'octets différents, il est nécessaire, par exemple, de convertir une valeur de l'ordre d'octets local en octet réseau, puis d'effectuer l'opération inverse sur la machine distante, donc des modifications seront nécessaires quant à la fonction d'écriture données au flux de sortie, et pour la fonction de lecture à partir du flux d'entrée. <br><br>  Spécialisation pour bool: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> t_value = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">'T'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f_value = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">'F'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmp = (value) ? t_value : f_value; os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;tmp), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tmp)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); }</code> </pre> <br>  Cette approche définit la règle suivante: si une valeur de type T peut être représentée comme une séquence d'octets de longueur sizeof (T), la définition du modèle primaire peut être utilisée pour cela, sinon, il est nécessaire de déterminer la spécialisation.  Cette exigence peut être dictée par les caractéristiques de la représentation d'un objet de type T en mémoire. <br><br>  Considérez le conteneur std :: string: il est évident que nous ne pouvons pas prendre l'adresse d'un objet du type spécifié, le convertir en un pointeur sur char et l'écrire dans le flux de sortie - ce qui signifie que nous avons besoin d'une spécialisation: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> len = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(value.size()); os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;len), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(len)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) os.write(value.data(), len); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); }</code> </pre> <br>  Deux points importants à souligner ici: <br><br><ol><li>  Non seulement le contenu de la chaîne est écrit dans le flux de sortie, mais également sa taille. </li><li>  Cast std :: string :: size_type pour taper std :: uint32_t.  Dans ce cas, il convient de prêter attention non pas à la taille du type cible, mais au fait qu'il est de longueur fixe.  Une telle réduction permettra d'éviter des problèmes dans le cas, par exemple, si des données sont transmises sur un réseau entre des machines de tailles de mots machine différentes. </li></ol><br>  Nous avons donc découvert que les valeurs des types fondamentaux (et même des objets de type std :: string) peuvent être écrites dans le flux de sortie à l'aide du modèle de fonction d' <b>écriture</b> .  Analysons maintenant les modifications que nous devons apporter si nous voulons ajouter des conteneurs à la liste des types pris en charge.  Nous n'avons qu'une seule option pour la surcharge - utilisez le paramètre T comme type d'éléments de conteneur.  Et si dans le cas de std :: vector cela fonctionnera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> len = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>&gt;(value.size()); os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;len), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(len)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(value.cbegin(), value.cend(), [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; e) { size += ::write(os, e); }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; }</code> </pre> <br>  , puis avec std: map - non, car le modèle std :: map nécessite au moins deux paramètres - le type de clé et le type de valeur.  Ainsi, à ce stade, nous ne pouvons plus utiliser le modèle de fonction - nous avons besoin d'une solution plus universelle.  Avant de découvrir comment ajouter la prise en charge des conteneurs, rappelons que nous avons toujours des classes personnalisées.  De toute évidence, même en utilisant la solution actuelle, il ne serait pas judicieux de surcharger la fonction d' <b>écriture</b> pour chaque classe qui nécessite une sérialisation.  Dans le meilleur des cas, nous aimerions avoir une spécialisation du modèle d' <b>écriture</b> qui fonctionne avec les types de données personnalisés.  Mais pour cela, il est nécessaire que les classes aient la capacité de contrôler indépendamment la sérialisation, respectivement, elles devraient avoir une interface qui permettrait à l'utilisateur de sérialiser et de désérialiser les objets de cette classe.  Comme il s'avère un peu plus tard, cette interface servira de «dénominateur commun» pour le modèle d' <b>écriture</b> lors de l'utilisation de classes personnalisées.  Définissons-le. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISerializable</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: ~ISerializable() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deserialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream&amp; is)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialized_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br>  Toute classe qui hérite de <b>ISerializable</b> s'engage à: <br><br><ol><li>  Remplacer l'état <b>sérialiser</b> - écrire (membres de données) dans le flux de sortie. </li><li>  Override <b>deserialize</b> - Lit l'état (initialisation des membres de données) du flux d'entrée. </li><li>  Override <b>serialized_size</b> - calcule la taille des données sérialisées pour l'état actuel de l'objet. </li></ol><br>  Donc, revenons au modèle de fonction d' <b>écriture</b> : en général, nous pouvons implémenter la spécialisation pour la classe <b>ISerializable</b> , mais nous ne pouvons pas l'utiliser, jetez un œil: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ISerializable&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value.serialize(os); }</code> </pre> <br>  À chaque fois, nous <b>devions convertir le</b> type d'héritier en <b>ISerializable</b> pour profiter de cette spécialisation.  Permettez-moi de vous rappeler qu'au tout début, nous nous étions fixé comme objectif de simplifier l'écriture de code lié à la sérialisation, et non l'inverse, de le compliquer.  Donc, si les types pris en charge par notre bibliothèque ne se limitent pas aux types fondamentaux, alors nous devrions chercher une autre solution. <br><br><h2>  3. stream_writer </h2><br>  L'utilisation de modèles de fonctions pour implémenter une interface universelle pour écrire des données dans un flux n'était pas une solution tout à fait appropriée.  La prochaine option que nous devrions vérifier est le modèle de classe.  Nous suivrons la même méthodologie que celle utilisée avec le modèle de fonction - le modèle principal sera utilisé par défaut et des spécialisations explicites seront ajoutées pour prendre en charge les types nécessaires. <br><br>  De plus, nous devons prendre en compte tout ce qui précède sur <b>ISerializable</b> - évidemment, nous ne serons pas en mesure de résoudre le problème avec de nombreuses classes successives sans recourir à type_traits: à partir de C ++ 11, le modèle std :: enable_if est apparu dans la bibliothèque standard, ce qui permet d'ignorer les classes de modèles lorsque certaines conditions lors de la compilation - et c'est exactement ce dont nous allons profiter. <br><br>  <b>Modèle de</b> classe <b>Stream_writer</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; class stream_writer { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> write(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>; };</code> </pre> <br>  La définition de la méthode d' <b>écriture</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream_writer&lt;T, U&gt;::write(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;value), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(value)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); }</code> </pre> <br>  La spécialisation pour <b>ISerializable</b> sera la suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stream_writer</span></span></span><span class="hljs-class">&lt;T, only_if_serializable&lt;T&gt;&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> stream_io&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t</span></span>; };</code> </pre> <br>  où only_if_serializable est un type d'assistance: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> only_if_serializable = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of_v&lt;ISerializable, T&gt;&gt;;</code> </pre> <br>  Ainsi, si le type T est une classe dérivée de <b>ISerializable</b> , alors cette spécialisation sera considérée comme candidate à l'instanciation, respectivement, si le type T n'est pas dans la même hiérarchie de classes <b>qu'ISerializable</b> , elle sera exclue des candidats possibles. <br><br>  Il serait juste de poser ici la question suivante: comment cela fonctionnera-t-il?  Après tout, le modèle principal aura les mêmes valeurs de paramètres typiques que sa spécialisation - &lt;T, void&gt;.  Pourquoi la spécialisation sera-t-elle privilégiée et le sera-t-elle?  Réponse: sera, car un tel comportement est prescrit par la norme ( <a href="" rel="nofollow">source</a> ): <br><br><blockquote>  (1.1) Si exactement une spécialisation correspondante est trouvée, l'instanciation est générée à partir de cette spécialisation </blockquote><br>  La spécialisation de std :: string ressemblera maintenant à ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stream_writer</span></span></span><span class="hljs-class">&lt;T, only_if_string&lt;T&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream_writer&lt;T, only_if_string&lt;T&gt;&gt;::write(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> len = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(value.size()); os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;len), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(len)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) os.write(value.data(), len); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); }</code> </pre> <br>  où only_if_string est déclaré comme: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> only_if_string = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same_v&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&gt;;</code> </pre> <br>  Il est temps de retourner dans les conteneurs.  Dans ce cas, nous pouvons utiliser le type de conteneur paramétré avec un certain type de U, ou &lt;U, V&gt;, comme dans le cas de std :: map, directement comme valeur du paramètre T du modèle de la classe <b>stream_writer</b> .  Ainsi, rien ne change dans l'interface de notre interface - c'est ce que nous visions.  Cependant, la question se pose, quel devrait être le deuxième paramètre du modèle pour la classe <b>stream_writer pour</b> que tout fonctionne correctement?  C'est dans le chapitre suivant. <br><br><h2>  4. Concepts </h2><br>  Tout d'abord, je donnerai une brève description des concepts utilisés, puis seulement je montrerai des exemples mis à jour. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept String = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same_v&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;;</code> </pre> <br>  Honnêtement, ce concept a été défini pour la fraude, que nous verrons sur la ligne suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept Container = !String&lt;T&gt; &amp;&amp; requires (T a) { <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::value_type; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::reference; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::const_reference; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::iterator; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::const_iterator; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::size_type; { a.begin() } -&gt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::iterator; { a.end() } -&gt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::iterator; { a.cbegin() } -&gt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::const_iterator; { a.cend() } -&gt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::const_iterator; { a.clear() } -&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; };</code> </pre> <br>  <b>Le conteneur</b> contient les exigences que nous «faisons» au type pour vraiment nous assurer qu'il s'agit bien d'un des types de conteneur.  C'est exactement l'ensemble des exigences dont nous aurons besoin lors de l'implémentation de <b>stream_writer</b> , la norme a bien sûr beaucoup plus d'exigences. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept SequenceContainer = Container&lt;T&gt; &amp;&amp; requires (T a, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::size_type count) { { a.resize(count) } -&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; };</code> </pre> <br>  Concept pour les conteneurs séquentiels: std :: vector, std :: list, etc. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept AssociativeContainer = Container&lt;T&gt; &amp;&amp; requires (T a) { <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::key_type; };</code> </pre> <br>  Concept pour les conteneurs associatifs: std :: map, std :: set, std :: unordered_map, etc. <br><br>  Maintenant, pour déterminer la spécialisation des conteneurs consécutifs, il ne nous reste plus qu'à imposer des restrictions sur le type T: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; requires SequenceContainer&lt;T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stream_writer</span></span></span><span class="hljs-class">&lt;T, void&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; requires SequenceContainer&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream_writer&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt;::write(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); <span class="hljs-comment"><span class="hljs-comment">// to support std::forward_list we have to use std::distance() const auto len = static_cast&lt;std::uint16_t&gt;( std::distance(value.cbegin(), value.cend())); os.write(reinterpret_cast&lt;const char*&gt;(&amp;len), sizeof(len)); auto size = static_cast&lt;std::size_t&gt;(os.tellp() - pos); if (len &gt; 0) { using value_t = typename stream_writer::value_type; std::for_each(value.cbegin(), value.cend(), [&amp;](const auto&amp; item) { size += stream_writer&lt;value_t&gt;::write(os, item); }); } return size; }</span></span></code> </pre> <br>  Conteneurs pris en charge: <br><br><ul><li>  std :: vecteur </li><li>  std :: deque </li><li>  std :: list </li><li>  std :: forward_list </li></ul><br>  De même pour les conteneurs associatifs: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; requires AssociativeContainer&lt;T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stream_writer</span></span></span><span class="hljs-class">&lt;T, void&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> stream_io&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; requires AssociativeContainer&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream_writer&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt;::write(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> len = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> stream_writer::size_type&gt;(value.size()); os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;len), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(len)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> stream_writer::value_type; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(value.cbegin(), value.cend(), [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; item) { size += stream_writer&lt;<span class="hljs-keyword"><span class="hljs-keyword">value_t</span></span>&gt;::write(os, item); }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; }</code> </pre> <br>  Conteneurs pris en charge: <br><br><ul><li>  std :: map </li><li>  std :: unordered_map </li><li>  std :: set </li><li>  std :: unordered_set </li></ul><br>  Dans le cas de map, il y a une petite nuance, elle concerne l'implémentation de <b>stream_reader</b> .  Le type value_type pour std :: map &lt;K, T&gt; est std :: pair &lt;const K, T&gt;, respectivement, lorsque nous essayons de convertir un pointeur en const K en un pointeur en char lors de la lecture du flux d'entrée, nous obtenons une erreur de compilation.  Nous pouvons résoudre ce problème comme suit: nous savons que pour les conteneurs associatifs value_type est soit un seul type K ou std :: pair &lt;const K, V&gt;, alors nous pouvons écrire de petites classes d'aide de modèle qui seront paramétrées par value_type et à l'intérieur déterminer le type dont nous avons besoin. <br><br>  Pour std :: set, tout reste inchangé: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> V = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; struct converter { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = U; };</code> </pre> <br>  Pour std :: map - supprimez const: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">converter</span></span></span><span class="hljs-class">&lt;U, only_if_pair&lt;U&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_const_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U::first_type&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U::second_type&gt;; };</code> </pre> <br>  La définition de <b>lecture</b> pour les conteneurs associatifs: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; requires AssociativeContainer&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream_reader&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt;::read(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream&amp; is, T&amp; value) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = is.tellg(); <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> stream_reader::size_type len = <span class="hljs-number"><span class="hljs-number">0</span></span>; is.read(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;len), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(len)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(is.tellg() - pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">0U</span></span>; i &lt; len; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> converter&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> stream_reader::value_type&gt;::type; <span class="hljs-keyword"><span class="hljs-keyword">value_t</span></span> v {}; size += stream_reader&lt;<span class="hljs-keyword"><span class="hljs-keyword">value_t</span></span>&gt;::read(is, v); value.insert(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(v)); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; }</code> </pre> <br><br><h2>  5. Fonctions auxiliaires </h2><br>  Prenons un exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ISerializable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: User(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view username, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view password) : m_username(username) , m_password(password) {} SERIALIZABLE_INTERFACE <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_username {}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_password {}; };</code> </pre> <br>  La définition de la méthode serialize (std :: ostream &amp;) pour cette classe devrait ressembler à ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> User::serialize(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = <span class="hljs-number"><span class="hljs-number">0U</span></span>; size += stream_writer&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;::write(os, m_username); size += stream_writer&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;::write(os, m_password); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; }</code> </pre> <br>  Cependant, vous devez admettre qu'il n'est pas pratique d'indiquer à chaque fois le type d'objet qui est écrit dans le flux de sortie.  Nous écrivons une fonction auxiliaire qui déduirait automatiquement le type T: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stream_writer&lt;T&gt;::write(os, value); }</code> </pre> <br>  Maintenant, la définition est la suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> User::serialize(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = <span class="hljs-number"><span class="hljs-number">0U</span></span>; size += ::write(os, m_username); size += ::write(os, m_password); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; }</code> </pre> <br>  Le dernier chapitre nécessitera quelques fonctions d'assistance supplémentaires: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_recursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ::write(os, value); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_recursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ts&amp;... values)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = write_recursive(os, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size + write_recursive(os, values...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_all</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ts&amp;... values)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> write_recursive(os, values...); }</code> </pre> <br>  La fonction <b>write_all vous</b> permet de répertorier tous les objets à sérialiser à la fois, tandis que <b>write_recursive</b> garantit le bon ordre d'écriture dans le flux de sortie.  Si l'ordre des calculs était défini pour les <a href="https://ru.cppreference.com/w/cpp/language/fold" rel="nofollow">expressions</a> de <a href="https://ru.cppreference.com/w/cpp/language/fold" rel="nofollow">repli</a> (à condition d'utiliser l'opérateur binaire +), nous pourrions les utiliser.  En particulier, dans la fonction <b>size_of_all</b> (elle n'a pas été mentionnée plus haut, elle est utilisée pour calculer la taille des données sérialisées), ce sont les expressions de repli qui sont utilisées en raison de l'absence d'opérations d'entrée-sortie. <br><br><h2>  6. Génération de code </h2><br>  L'API libclang-C pour clang est utilisée pour générer le code.  De haut niveau, cette tâche peut être décrite comme suit: nous devons parcourir récursivement le répertoire avec le code source, vérifier tous les fichiers d'en-tête pour les classes marquées avec un attribut spécial, et s'il y en a un, vérifier les membres de données pour le même attribut et compiler la chaîne à partir des noms des membres de données répertorié avec une virgule.  Il ne nous reste plus qu'à écrire les modèles de définition des fonctions de la classe <b>ISerializable</b> (dans laquelle nous ne pouvons que mettre l'énumération des membres de données nécessaires). <br><br>  Un exemple de classe pour laquelle le code sera généré: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute__</span></span></span><span class="hljs-class">((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">annotate</span></span></span><span class="hljs-class">("</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">serializable</span></span></span><span class="hljs-class">"))) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ISerializable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: User(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view username, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view password) : m_username(username) , m_password(password) {} User() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~User() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; SERIALIZABLE_INTERFACE <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: __attribute__((annotate(<span class="hljs-string"><span class="hljs-string">"serializable"</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_username {}; __attribute__((annotate(<span class="hljs-string"><span class="hljs-string">"serializable"</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_password {}; };</code> </pre> <br>  Les attributs sont écrits dans le style GNU car libclang refuse de reconnaître le format d'attribut de C ++ 20, et il ne prend pas non plus en charge les attributs non annotés.  Traversée du répertoire source: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; file : fs::recursive_directory_iterator(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.is_regular_file() &amp;&amp; file.path().extension() == <span class="hljs-string"><span class="hljs-string">".hpp"</span></span>) { processTranslationUnit(file, dst); } }</code> </pre> <br>  La définition de la fonction <b>processTranslationUnit</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processTranslationUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fs::path&amp; path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fs::path&amp; targetDir)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pathname = path.<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(); arg::Context context { <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> translationUnit = arg::TranslationUnit::parse(context, pathname.c_str(), CXTranslationUnit_None); arg::ClassExtractor extractor; extractor.extract(translationUnit.cursor()); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; classes = extractor.classes(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [name, c] : classes) { SerializableDefGenerator::processClass(c, path, targetDir.<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>()); } }</code> </pre> <br>  Dans cette fonction, seul <b>ClassExtractor</b> nous intéresse - tout le reste est nécessaire pour la formation d'AST.  La définition de la fonction d' <b>extraction</b> est la suivante: <br><br><pre> <code class="cpp hljs">  <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ClassExtractor::extract(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CXCursor&amp; cursor) { clang_visitChildren(cursor, [](CXCursor c, CXCursor, CXClientData data) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clang_getCursorKind(c) == CXCursorKind::CXCursor_ClassDecl) { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* -    - */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* -     */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CXChildVisit_Continue; } , <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Ici, nous voyons déjà directement les fonctions de l'API C pour clang.  Nous avons intentionnellement laissé uniquement le code nécessaire pour comprendre comment libclang est utilisé.  Tout ce qui reste dans les coulisses ne contient pas d'informations importantes - c'est juste un enregistrement des noms de classe, des membres de données, etc.  Un code plus détaillé peut être trouvé dans le référentiel. <br><br>  Et enfin, dans la fonction <b>processClass</b> , la présence des attributs de sérialisation de chaque classe trouvée est vérifiée, et s'il y en a un, un fichier est généré avec la définition des fonctions nécessaires.  Le référentiel fournit des exemples spécifiques: où obtenir le ou les noms de l'espace de noms (ces informations sont stockées directement dans la classe <b>Class</b> ) et le chemin d'accès au fichier d'en-tête. <br><br>  <i>Pour la tâche susmentionnée, la bibliothèque Argentum est utilisée, ce que, malheureusement, je ne vous recommande pas d'utiliser - j'ai commencé à la développer à d'autres fins, mais parce que pour cette tâche, j'avais juste besoin des fonctionnalités qui y étaient implémentées, et j'étais paresseux, Je n'ai pas réécrit le code, mais l'ai simplement posté sur Bintray et connecté au fichier CMake via le gestionnaire de paquets Conan.</i>  <i>Tout ce que cette bibliothèque fournit est de simples wrappers sur l'API clang C pour les classes et les membres de données.</i> <br><br>  Et encore une petite remarque - je ne fournis pas de bibliothèque toute faite, je dis seulement comment l'écrire. <br><br>  <b>UPD0</b> : cppast peut être utilisé à la <a href="https://github.com/foonathan/cppast" rel="nofollow">place de libclang</a> .  Merci à <a href="https://habr.com/ru/users/masterspline/" class="user_link">masterspline</a> pour le lien fourni. <br><br>  1. <a href="https://github.com/isnullxbh/dsl" rel="nofollow">github.com/isnullxbh/dsl</a> <br>  2. <a href="https://github.com/isnullxbh/Argentum" rel="nofollow">github.com/isnullxbh/Argentum</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479462/">https://habr.com/ru/post/fr479462/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479446/index.html">Les voitures ont déjà une longueur d'avance sur les tests de lecture; mais comprennent-ils ce qu'ils lisent?</a></li>
<li><a href="../fr479450/index.html">AppCode 2019.3: fonctionne plus rapidement, comprend mieux Swift, connaît Mac Catalyst et affiche facilement les messages d'assemblage</a></li>
<li><a href="../fr479452/index.html">Comment le système de noms de domaine s'est développé: l'ère ARPANET</a></li>
<li><a href="../fr479458/index.html">Beauté ou praticité dans la salle des serveurs</a></li>
<li><a href="../fr479460/index.html">Un guide pour les voitures volantes</a></li>
<li><a href="../fr479464/index.html">Tuyaux et filtres. Exemple d'application et d'implémentation à l'aide de Spring</a></li>
<li><a href="../fr479466/index.html">Habraiting 2019: statistiques et classement des meilleurs articles pour 2019</a></li>
<li><a href="../fr479468/index.html">Edge of Honesty et John Doe</a></li>
<li><a href="../fr479474/index.html">Pourquoi l'auto-organisation des équipes est-elle si importante dans Scrum et pourquoi il ne peut y avoir de managers</a></li>
<li><a href="../fr479478/index.html">Plug-in Java sans douleur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>