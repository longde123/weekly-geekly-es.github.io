<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛥️ 🤐 👉🏾 Kompilierte verteilte Systemkonfiguration 🕴🏾 👩🏽‍💻 👇🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich möchte Ihnen einen interessanten Mechanismus für die Arbeit mit einer verteilten Systemkonfiguration vorstellen. Die Konfiguration wird direkt in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kompilierte verteilte Systemkonfiguration</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/primetalk/blog/447694/"><p>  Ich möchte Ihnen einen interessanten Mechanismus für die Arbeit mit einer verteilten Systemkonfiguration vorstellen.  Die Konfiguration wird direkt in einer kompilierten Sprache (Scala) unter Verwendung sicherer Typen dargestellt.  In diesem Beitrag wird ein Beispiel für eine solche Konfiguration analysiert und verschiedene Aspekte der Einführung einer kompilierten Konfiguration in den gesamten Entwicklungsprozess werden berücksichtigt. </p><br><p><img src="https://habrastorage.org/webt/71/bl/ax/71blaxtldz-ia4yftyebaxbam7c.png" alt="Konfigurationslebenszyklus"></p><br><p>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Englisch</a> ) </p><a name="habracut"></a><br><h3 id="vvedenie">  Einführung </h3><br><p>  Der Aufbau eines zuverlässigen verteilten Systems setzt voraus, dass alle Knoten die richtige Konfiguration verwenden, die mit anderen Knoten synchronisiert ist.  In der Regel werden DevOps-Technologien (Terraform, Ansible oder ähnliches) verwendet, um automatisch Konfigurationsdateien zu generieren (häufig eigene für jeden Knoten).  Wir möchten auch sicherstellen, dass alle interagierenden Knoten identische Protokolle verwenden (einschließlich derselben Version).  Andernfalls wird Inkompatibilität in unser verteiltes System eingebettet.  In der JVM-Welt ist eine Konsequenz dieser Anforderung die Notwendigkeit, überall dieselbe Version einer Bibliothek zu verwenden, die Protokollnachrichten enthält. </p><br><p>  Was ist mit verteilten Systemtests?  Wir gehen natürlich davon aus, dass Unit-Tests für alle Komponenten bereitgestellt werden, bevor wir mit Integrationstests fortfahren.  (Damit wir die Testergebnisse auf die Laufzeit extrapolieren können, müssen wir in der Testphase und zur Laufzeit auch einen identischen Satz von Bibliotheken bereitstellen.) </p><br><p>  Bei der Arbeit mit Integrationstests ist es häufig überall einfacher, auf allen Knoten einen einzelnen Klassenpfad zu verwenden.  Wir müssen nur sicherstellen, dass derselbe Klassenpfad zur Laufzeit beteiligt ist.  (Trotz der Tatsache, dass es durchaus möglich ist, verschiedene Knoten mit unterschiedlichen Klassenpfaden auszuführen, führt dies zu Komplikationen bei der gesamten Konfiguration und zu Schwierigkeiten bei Bereitstellungs- und Integrationstests.) In diesem Beitrag wird davon ausgegangen, dass auf allen Knoten derselbe Klassenpfad verwendet wird. </p><br><p>  Die Konfiguration entwickelt sich mit der Anwendung.  Um die verschiedenen Phasen der Programmentwicklung zu identifizieren, verwenden wir Versionen.  Es erscheint logisch, auch verschiedene Versionen der Konfigurationen zu identifizieren.  Und die Konfiguration selbst sollte im Versionskontrollsystem platziert werden.  Wenn es in der Produktion nur eine Konfiguration gibt, können wir nur die Versionsnummer verwenden.  Wenn viele Produktionsinstanzen verwendet werden, benötigen wir mehrere <br>  Konfigurationszweige und ein zusätzliches Label zusätzlich zur Version (z. B. der Name des Zweigs).  Somit können wir die genaue Konfiguration eindeutig identifizieren.  Jede Konfigurationskennung entspricht eindeutig einer bestimmten Kombination von verteilten Knoten, Ports, externen Ressourcen und Bibliotheksversionen.  Im Rahmen dieses Beitrags gehen wir von der Tatsache aus, dass es nur einen Zweig gibt, und wir können die Konfiguration auf die übliche Weise anhand von drei durch einen Punkt getrennten Zahlen (1.2.3) identifizieren. </p><br><p>  In modernen Umgebungen werden Konfigurationsdateien nur sehr selten manuell erstellt.  Sie werden häufiger während der Bereitstellung generiert und nicht mehr berührt (um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nichts zu beschädigen</a> ).  Es stellt sich die logische Frage, warum wir immer noch ein Textformat zum Speichern der Konfiguration verwenden.  Eine völlig praktikable Alternative ist die Möglichkeit, regulären Code für die Konfiguration zu verwenden und bei der Kompilierung von Überprüfungen zu profitieren. </p><br><p>  In diesem Beitrag untersuchen wir nur die Idee, eine Konfiguration in einem kompilierten Artefakt darzustellen. </p><br><h3 id="kompiliruemaya-konfiguraciya">  Kompilierte Konfiguration </h3><br><p>  Dieser Abschnitt beschreibt ein Beispiel für eine statisch kompilierte Konfiguration.  Es sind zwei einfache Dienste implementiert - ein Echo-Dienst und ein Echo-Dienst-Client.  Basierend auf diesen beiden Diensten werden zwei Versionen des Systems zusammengestellt.  In einer Ausführungsform befinden sich beide Dienste auf demselben Knoten, in einer anderen Ausführungsform auf verschiedenen Knoten. </p><br><p> In der Regel enthält ein verteiltes System mehrere Knoten.  Knoten können mit Werten eines <code>NodeId</code> Typs <code>NodeId</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Backend</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Frontend</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span></span></code> </pre> <br><p>  oder </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">hostName: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  oder sogar </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Singleton</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span></code> </pre> <br><p>  Knoten spielen verschiedene Rollen, Dienste werden auf ihnen gestartet und TCP / HTTP-Kommunikation kann zwischen ihnen hergestellt werden. </p><br><p>  Zur Beschreibung der TCP-Kommunikation benötigen wir mindestens eine Portnummer.  Wir möchten auch das Protokoll widerspiegeln, das an diesem Port unterstützt wird, um sicherzustellen, dass sowohl der Client als auch der Server dasselbe Protokoll verwenden.  Wir werden die Verbindung mit dieser Klasse beschreiben: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TcpEndPoint</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Protocol</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">node: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">NodeId</span></span></span></span><span class="hljs-class"><span class="hljs-params">, port: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Port</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Protocol</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Dabei ist <code>Port</code> nur eine Ganzzahl <code>Int</code> mit einem Bereich gültiger Werte: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortNumber</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Refined</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Closed</span></span>[_0, <span class="hljs-type"><span class="hljs-type">W</span></span>.`<span class="hljs-number"><span class="hljs-number">65535</span></span>`.<span class="hljs-type"><span class="hljs-type">T</span></span>]]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Verfeinerte Typen</b> <div class="spoiler_text"><p>  Siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verfeinerte</a> Bibliothek und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinen</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> .  Kurz gesagt, mit der Bibliothek können Sie Typen Einschränkungen hinzufügen, die beim Kompilieren überprüft werden.  In diesem Fall sind die gültigen Portnummernwerte ganzzahlige 16-Bit-Zahlen.  Bei einer kompilierten Konfiguration ist die Verwendung der verfeinerten Bibliothek optional, kann jedoch die Fähigkeit des Compilers verbessern, die Konfiguration zu überprüfen. </p></div></div><br><p>  Für HTTP (REST) ​​-Protokolle benötigen wir neben der Portnummer möglicherweise auch einen Pfad zum Dienst: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UrlPathPrefix</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Refined</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">MatchesRegex</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>.`<span class="hljs-string"><span class="hljs-string">"[a-zA-Z_0-9/]*"</span></span>`.<span class="hljs-type"><span class="hljs-type">T</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortWithPrefix</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Protocol</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">portNumber: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">PortNumber</span></span></span></span><span class="hljs-class"><span class="hljs-params">, pathPrefix: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">UrlPathPrefix</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Phantomtypen</b> <div class="spoiler_text"><p>  Um das Protokoll in der Kompilierungsphase zu identifizieren, verwenden wir einen Typparameter, der in der Klasse nicht verwendet wird.  Diese Entscheidung beruht auf der Tatsache, dass wir zur Laufzeit keine Protokollinstanz verwenden, aber wir möchten, dass der Compiler die Protokollkompatibilität überprüft.  Dank des Protokolls können wir den ungeeigneten Dienst nicht als Abhängigkeit übertragen. </p></div></div><br><p>  Ein gängiges Protokoll ist die REST-API mit Json-Serialisierung: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonHttpRestProtocol</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RequestMessage</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ResponseMessage</span></span></span><span class="hljs-class">]</span></span></code> </pre> <br><p>  Dabei ist <code>RequestMessage</code> der Anforderungstyp, <code>ResponseMessage</code> der Antworttyp. <br>  Natürlich können Sie auch andere Protokollbeschreibungen verwenden, die die von uns gewünschte Genauigkeit bieten. </p><br><p>  Für die Zwecke dieses Beitrags verwenden wir eine vereinfachte Version des Protokolls: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleHttpGetRest</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RequestMessage</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ResponseMessage</span></span></span><span class="hljs-class">]</span></span></code> </pre> <br><p>  Hier ist die Anforderung eine Zeichenfolge, die der URL hinzugefügt wird, und die Antwort ist die zurückgegebene Zeichenfolge im Hauptteil der HTTP-Antwort. </p><br><p>  Die Dienstkonfiguration wird durch den Dienstnamen, die Ports und die Abhängigkeiten beschrieben.  Diese Elemente können in Scala auf verschiedene Arten dargestellt werden (z. B. <code>HList</code> , algebraische Datentypen).  Für die Zwecke dieses Beitrags verwenden wir das Kuchenmuster und repräsentieren die Module mithilfe von <code>trait</code> .  (Kuchenmuster ist kein notwendiges Element des beschriebenen Ansatzes. Es ist nur eine der möglichen Implementierungen.) </p><br><p>  Abhängigkeiten zwischen Diensten können als Methoden dargestellt werden, die die <code>EndPoint</code> Ports anderer Knoten zurückgeben: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoProtocol</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">SimpleHttpGetRest</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">portNumber</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortNumber</span></span> = <span class="hljs-number"><span class="hljs-number">8081</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echoPort</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortWithPrefix</span></span>[<span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]] = <span class="hljs-type"><span class="hljs-type">PortWithPrefix</span></span>[<span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]](portNumber, <span class="hljs-string"><span class="hljs-string">"echo"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echoService</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">HttpSimpleGetEndPoint</span></span>[<span class="hljs-type"><span class="hljs-type">NodeId</span></span>, <span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]] = providedSimpleService(echoPort) }</code> </pre> <br><p>  Um einen Echodienst zu erstellen, sind nur eine Portnummer und ein Hinweis darauf, dass dieser Port das Echoprotokoll unterstützt, ausreichend.  Wir konnten keinen bestimmten Port angeben, weil  Mit Merkmalen können Sie Methoden ohne Implementierung deklarieren (abstrakte Methoden).  In diesem Fall müsste der Compiler beim Erstellen einer bestimmten Konfiguration eine abstrakte Methodenimplementierung und eine Portnummer angeben.  Da wir die Methode beim Erstellen einer bestimmten Konfiguration implementiert haben, können wir keinen anderen Port angeben.  Der Standardwert wird verwendet. </p><br><p>  In der Client-Konfiguration deklarieren wir eine Abhängigkeit vom Echo-Service: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMessage</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"test"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pollInterval</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">FiniteDuration</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echoServiceDependency</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">HttpSimpleGetEndPoint</span></span>[_, <span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]] }</code> </pre> <br><p>  Die Abhängigkeit ist vom selben Typ wie der exportierte Dienst <code>echoService</code> .  Insbesondere im Echo-Client benötigen wir dasselbe Protokoll.  Daher können wir beim Verbinden der beiden Dienste sicher sein, dass alles ordnungsgemäß funktioniert. </p><br><div class="spoiler">  <b class="spoiler_title">Service-Implementierung</b> <div class="spoiler_text"><p>  Zum Starten und Stoppen des Dienstes ist eine Funktion erforderlich.  (Die Möglichkeit, den Dienst zu stoppen, ist für das Testen von entscheidender Bedeutung.) Auch hier gibt es verschiedene Optionen zum Implementieren dieser Funktion (wir könnten beispielsweise Typklassen verwenden, die auf dem Konfigurationstyp basieren).  Für die Zwecke dieses Beitrags verwenden wir das Kuchenmuster.  Wir werden den Service mit der <code>cats.Resource</code> Klasse vertreten, weil  In dieser Klasse sind bereits Mittel zur sicheren garantierten Freigabe von Ressourcen bei Problemen vorhanden.  Um die Ressource zu erhalten, müssen wir eine Konfiguration und einen fertigen Laufzeitkontext bereitstellen.  Die Funktion zum Starten des Dienstes kann folgendermaßen aussehen: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResourceReader</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_], </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">Reader</span></span>[<span class="hljs-type"><span class="hljs-type">Config</span></span>, <span class="hljs-type"><span class="hljs-type">Resource</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_]] </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resource</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> implicit resolver: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">AddressResolver</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">], timer: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Timer</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">], contextShift: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ContextShift</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">], ec: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ExecutionContext</span></span></span></span><span class="hljs-class"><span class="hljs-params">, applicative: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Applicative</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">] </span></span></span><span class="hljs-class">)</span></span>: <span class="hljs-type"><span class="hljs-type">ResourceReader</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">Config</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] }</code> </pre> <br><p>  wo </p><br><ul><li>  <code>Config</code> - Konfigurationstyp für diesen Dienst </li><li>  <code>AddressResolver</code> - ein Laufzeitobjekt, mit dem Sie die Adressen anderer Knoten ermitteln können (siehe unten). </li></ul><br><p>  und andere Typen aus der <code>cats</code> : </p><br><ul><li>  <code>F[_]</code> - Art des Effekts (im einfachsten Fall kann <code>F[A]</code> nur eine Funktion sein <code>() =&gt; A</code> In diesem Beitrag werden wir <code>cats.IO</code> </li><li>  <code>Reader[A,B]</code> - mehr oder weniger gleichbedeutend mit der Funktion <code>A =&gt; B</code> </li><li>  <code>cats.Resource</code> - eine Ressource, die erhalten und freigegeben werden kann </li><li>  <code>Timer</code> - Timer (ermöglicht es Ihnen, eine Weile einzuschlafen und Zeitintervalle zu messen) </li><li>  <code>ContextShift</code> - Analogon von <code>ExecutionContext</code> </li><li>  <code>Applicative</code> - eine Effekttypklasse, mit der Sie einzelne Effekte kombinieren können (fast eine Monade).  In komplexeren Anwendungen scheint es besser zu sein, <code>Monad</code> / <code>ConcurrentEffect</code> . </li></ul><br><p>  Mit dieser Funktionssignatur können wir mehrere Dienste implementieren.  Zum Beispiel ein Dienst, der nichts tut: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_]] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&lt;</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Any</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resource</span></span></span></span>(...): <span class="hljs-type"><span class="hljs-type">ResourceReader</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">Config</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] = <span class="hljs-type"><span class="hljs-type">Reader</span></span>(_ =&gt; <span class="hljs-type"><span class="hljs-type">Resource</span></span>.pure[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>](())) }</code> </pre> </div></div><br><p>  (Weitere Dienste finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Echo-Dienst</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Echo-Client</a> <br>  und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lebensdauerkontrollen</a> .) </p><br><p>  Ein Knoten ist ein Objekt, das mehrere Dienste starten kann (der Start der Ressourcenkette wird durch das Kuchenmuster sichergestellt): </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SingleNodeImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoServiceService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleServiceImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">EchoConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">EchoClientConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">FiniteDurationLifecycleConfig</span></span> }</code> </pre> <br><p>  Bitte beachten Sie, dass wir den genauen Konfigurationstyp angeben, der für diesen Knoten erforderlich ist.  Wenn wir vergessen, einen der Konfigurationstypen anzugeben, die von einem separaten Dienst benötigt werden, tritt ein Kompilierungsfehler auf.  Außerdem können wir den Knoten nicht starten, wenn wir einem Objekt des entsprechenden Typs nicht alle erforderlichen Daten zur Verfügung stellen. </p><br><div class="spoiler">  <b class="spoiler_title">Auflösung des Hostnamens</b> <div class="spoiler_text"><p>  Um eine Verbindung zu einem Remote-Host herzustellen, benötigen wir eine echte IP-Adresse.  Es ist möglich, dass die Adresse später als der Rest der Konfiguration bekannt wird.  Daher benötigen wir eine Funktion, die die Knotenkennung der Adresse zuordnet: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeAddress</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NodeId</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">host: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Uri</span></span></span></span><span class="hljs-class"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Host</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddressResolver</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_]] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">NodeId</span></span>](nodeId: <span class="hljs-type"><span class="hljs-type">NodeId</span></span>): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">NodeAddress</span></span>[<span class="hljs-type"><span class="hljs-type">NodeId</span></span>]] }</code> </pre> <br><p>  Sie können eine solche Funktion auf verschiedene Arten implementieren: </p><br><ol><li>  Wenn uns Adressen vor der Bereitstellung bekannt werden, können wir mit einen Scala-Code generieren <br>  Adressen und starten Sie dann die Montage.  Dadurch werden die Tests kompiliert und ausgeführt. <br>  In diesem Fall ist die Funktion statisch bekannt und kann im Code als Kartenanzeige <code>Map[NodeId, NodeAddress]</code> . </li><li>  In einigen Fällen wird eine gültige Adresse erst bekannt, nachdem der Knoten gestartet wurde. <br>  In diesem Fall können wir einen "Erkennungsdienst" (Discovery) implementieren, der ausgeführt wird, bevor die anderen Knoten und alle Knoten sich in diesem Dienst registrieren und die Adressen anderer Knoten anfordern. </li><li>  Wenn wir <code>/etc/hosts</code> ändern können, können wir vordefinierte Hostnamen (wie <code>my-project-main-node</code> und <code>echo-backend</code> ) verwenden und diese Namen einfach binden <br>  mit IP-Adressen während der Bereitstellung. </li></ol><br><p>  Im Rahmen dieses Beitrags werden wir diese Fälle nicht näher betrachten.  Für unsere <br>  In einem Spielzeugbeispiel haben alle Knoten eine IP-Adresse - <code>127.0.0.1</code> . </p></div></div><br><p>  Als nächstes betrachten wir zwei Optionen für ein verteiltes System: </p><br><ol><li>  Platzierung aller Dienste auf einem Knoten. </li><li>  Und die Platzierung des Echo-Dienstes und des Echo-Clients auf verschiedenen Knoten. </li></ol><br><p>  Konfiguration für einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einzelnen Knoten</a> : </p><br><div class="spoiler">  <b class="spoiler_title">Einzelknotenkonfiguration</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SingleNodeConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identifier</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">the</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">single</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">configuration</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">server</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Singleton</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nodeId</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">Singleton</span></span> <span class="hljs-comment"><span class="hljs-comment">/** Type safe service port specification. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">portNumber</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortNumber</span></span> = <span class="hljs-number"><span class="hljs-number">8088</span></span> <span class="hljs-comment"><span class="hljs-comment">// configuration of client /** We'll use the service provided by the same host. */ def echoServiceDependency = echoService override def testMessage: UrlPathElement = "hello" def pollInterval: FiniteDuration = 1.second // lifecycle controller configuration def lifetime: FiniteDuration = 10500.milliseconds // additional 0.5 seconds so that there are 10 requests, not 9. }</span></span></code> </pre> </div></div><br><p>  Das Objekt implementiert die Konfiguration von Client und Server.  Die Konfiguration der Lebensdauer wird auch verwendet, um das Programm nach einer <code>lifetime</code> zu beenden.  (Strg-C funktioniert auch und gibt alle Ressourcen korrekt frei.) </p><br><p>  Mit denselben Konfigurationsmerkmalen und Implementierungen kann ein System erstellt werden, das aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei separaten Knoten besteht</a> : </p><br><div class="spoiler">  <b class="spoiler_title">Konfiguration für zwei Knoten</b> <div class="spoiler_text"><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeServerConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SigTermLifecycleConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">NodeIdImpl</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nodeId</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">NodeServer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">portNumber</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortNumber</span></span> = <span class="hljs-number"><span class="hljs-number">8080</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeClientConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// NB! dependency specification def echoServiceDependency = NodeServerConfig.echoService def pollInterval: FiniteDuration = 1.second def lifetime: FiniteDuration = 10500.milliseconds // additional 0.5 seconds so that there are 10 request, not 9. def testMessage: String = "dolly" }</span></span></code> </pre> </div></div><br><p>  Wichtig!  Beachten Sie, wie die Servicebindung ausgeführt wird.  Wir geben den von einem Knoten implementierten Dienst als Implementierung der Abhängigkeitsmethode eines anderen Knotens an.  Die Art der Abhängigkeit wird vom Compiler überprüft, weil  enthält die Art des Protokolls.  Beim Start enthält die Abhängigkeit die korrekte Kennung des Zielknotens.  Dank dieses Schemas geben wir die Portnummer genau einmal an und beziehen uns garantiert immer auf den richtigen Port. </p><br><div class="spoiler">  <b class="spoiler_title">Implementierung von zwei Systemknoten</b> <div class="spoiler_text"><p>  Für diese Konfiguration verwenden wir dieselbe Service-Implementierung ohne Änderungen.  Der einzige Unterschied besteht darin, dass wir jetzt zwei Objekte haben, die unterschiedliche Sätze von Diensten implementieren: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TwoJvmNodeServerImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoServiceService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SigIntLifecycleServiceImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">EchoConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">SigTermLifecycleConfig</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TwoJvmNodeClientImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleServiceImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">EchoClientConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">FiniteDurationLifecycleConfig</span></span> }</code> </pre> <br><p>  Der erste Knoten implementiert den Server und benötigt nur die Serverkonfiguration.  Der zweite Knoten wird vom Client implementiert und verwendet einen anderen Teil der Konfiguration.  Beide Knoten müssen auch die Lebensdauer verwalten.  Der Serverknoten wird unbegrenzt ausgeführt, bis er von <code>SIGTERM</code> gestoppt wird und der Clientknoten nach einiger Zeit beendet wird.  Siehe die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Startanwendung</a> . </p></div></div><br><h4 id="obschiy-process-razrabotki">  Allgemeiner Entwicklungsprozess </h4><br><p>  Lassen Sie uns sehen, wie sich dieser Konfigurationsansatz auf den gesamten Entwicklungsprozess auswirkt. </p><br><p>  Die Konfiguration wird zusammen mit dem Rest des Codes kompiliert und ein Artefakt (.jar) wird generiert.  Anscheinend ist es sinnvoll, die Konfiguration in einem separaten Artefakt zu platzieren.  Dies liegt an der Tatsache, dass wir viele Konfigurationen basierend auf demselben Code haben können.  Auch hier können Sie Artefakte generieren, die verschiedenen Konfigurationszweigen entsprechen.  Zusammen mit der Konfiguration bleiben Abhängigkeiten von bestimmten Versionen von Bibliotheken erhalten, und diese Versionen bleiben für immer erhalten, wenn wir uns entscheiden, diese Version der Konfiguration bereitzustellen. </p><br><p>  Jede Konfigurationsänderung wird zu einer Codeänderung.  Und deshalb jeder solche <br>  Änderungen werden durch den üblichen Qualitätssicherungsprozess abgedeckt: </p><br><p>  Ein Ticket im Bugtracker -&gt; PR -&gt; Review -&gt; mit den entsprechenden Filialen zusammenführen -&gt; <br>  Integration -&gt; Bereitstellung </p><br><p>  Die Hauptfolgen der Implementierung einer kompilierten Konfiguration: </p><br><ol><li><p>  Die Konfiguration wird auf allen Knoten des verteilten Systems koordiniert.  Aufgrund der Tatsache, dass alle Knoten dieselbe Konfiguration von einer einzigen Quelle erhalten. </p><br></li><li><p>  Es ist problematisch, die Konfiguration nur in einem der Knoten zu ändern.  Daher ist eine „Konfigurationsdrift“ unwahrscheinlich. </p><br></li><li><p>  Es wird schwieriger, kleine Konfigurationsänderungen vorzunehmen. </p><br></li><li><p>  Die meisten Konfigurationsänderungen werden im Rahmen des gesamten Entwicklungsprozesses vorgenommen und überprüft. </p><br></li></ol><br><p>  Benötige ich ein separates Repository zum Speichern der Produktionskonfiguration?  Eine solche Konfiguration kann Passwörter und andere geheime Informationen enthalten, auf die wir den Zugriff beschränken möchten.  Auf dieser Grundlage erscheint es sinnvoll, die endgültige Konfiguration in einem separaten Repository zu speichern.  Sie können die Konfiguration in zwei Teile unterteilen - einen mit öffentlichen Konfigurationseinstellungen und einen mit Einstellungen für eingeschränkten Zugriff.  Dadurch können die meisten Entwickler auf allgemeine Parameter zugreifen.  Diese Trennung ist leicht mit Zwischenmerkmalen zu erreichen, die Standardwerte enthalten. </p><br><h3 id="vozmozhnye-variacii">  Mögliche Abweichungen </h3><br><p>  Versuchen wir, die kompilierte Konfiguration mit einigen gängigen Alternativen zu vergleichen: </p><br><ol><li>  Eine Textdatei auf dem Zielcomputer. </li><li>  Zentraler Schlüsselwertspeicher ( <code>etcd</code> / <code>zookeeper</code> ). </li><li>  Prozesskomponenten, die neu konfiguriert / neu gestartet werden können, ohne den Prozess neu zu starten. </li><li>  Speicherung der Konfiguration außerhalb der Artefakt- und Versionskontrolle. </li></ol><br><p>  Textdateien bieten erhebliche Flexibilität in Bezug auf kleine Änderungen.  Der Systemadministrator kann zum Remote-Knoten wechseln, Änderungen an den entsprechenden Dateien vornehmen und den Dienst neu starten.  Für große Systeme kann eine solche Flexibilität jedoch unerwünscht sein.  Von den vorgenommenen Änderungen gibt es keine Spuren in anderen Systemen.  Niemand überprüft Änderungen.  Es ist schwierig festzustellen, wer die Änderungen aus welchem ​​Grund vorgenommen hat.  Änderungen werden nicht getestet.  Wenn das System verteilt ist, vergisst der Administrator möglicherweise, die entsprechenden Änderungen auf anderen Knoten vorzunehmen. </p><br><p>  (Es sollte auch beachtet werden, dass die Verwendung einer kompilierten Konfiguration die Möglichkeit der zukünftigen Verwendung von Textdateien nicht blockiert. Es reicht aus, einen Parser und einen Validator hinzuzufügen, die den gleichen <code>Config</code> als Ausgabe verwenden, und Sie können Textdateien verwenden. Daraus folgt unmittelbar, dass die Komplexität des Systems mit der kompilierten Konfiguration etwas ist weniger als die Komplexität eines Systems, das Textdateien verwendet, da Textdateien zusätzlichen Code erfordern.) </p><br><p>  Der zentralisierte Schlüsselwertspeicher ist ein guter Mechanismus zum Verteilen von Metaparametern einer verteilten Anwendung.  Wir sollten entscheiden, was Konfigurationsparameter sind und was nur Daten sind.  Angenommen, wir haben eine Funktion <code>C =&gt; A =&gt; B</code> , wobei sich die Parameter <code>C</code> selten ändern und die Daten <code>A</code> häufig.  In diesem Fall können wir sagen, dass <code>C</code> die Konfigurationsparameter und <code>A</code> die Daten sind.  Es scheint, dass sich die Konfigurationsparameter von den Daten dadurch unterscheiden, dass sie sich im Allgemeinen weniger häufig ändern als die Daten.  Außerdem stammen Daten normalerweise von einer Quelle (vom Benutzer) und Konfigurationsparameter von einer anderen Quelle (vom Systemadministrator). </p><br><p>  Wenn selten geänderte Parameter aktualisiert werden müssen, ohne das Programm neu zu starten, kann dies häufig zu einer Komplikation des Programms führen, da wir die Parameter irgendwie liefern, speichern, analysieren und überprüfen sowie falsche Werte verarbeiten müssen.  Unter dem Gesichtspunkt der Verringerung der Komplexität des Programms ist es daher sinnvoll, die Anzahl der Parameter zu verringern, die sich während des Programms ändern können (oder solche Parameter überhaupt nicht zu unterstützen). </p><br><p>  Aus der Sicht dieses Beitrags werden wir zwischen statischen und dynamischen Parametern unterscheiden.  Wenn die Logik des Dienstes das Ändern von Parametern während des Programms erfordert, werden wir diese Parameter als dynamisch bezeichnen.  Andernfalls sind die Parameter statisch und können mithilfe einer kompilierten Konfiguration konfiguriert werden.  Für die dynamische Neukonfiguration benötigen wir möglicherweise einen Mechanismus, um Teile des Programms mit neuen Parametern neu zu starten, ähnlich wie die Prozesse des Betriebssystems neu gestartet werden.  (Unserer Meinung nach ist es ratsam, eine Neukonfiguration in Echtzeit zu vermeiden, da die Systemkomplexität zunimmt. Wenn möglich, ist es besser, die Standardfunktionen des Betriebssystems zum Neustarten von Prozessen zu verwenden.) </p><br><p>  Ein wichtiger Aspekt bei der Verwendung einer statischen Konfiguration, die Benutzer dazu zwingt, eine dynamische Neukonfiguration in Betracht zu ziehen, ist die Zeit, die das System nach einem Konfigurationsupdate (Ausfallzeit) benötigt, um neu zu starten.  Wenn wir Änderungen an der statischen Konfiguration vornehmen müssen, müssen wir das System neu starten, damit die neuen Werte wirksam werden.  Das Ausfallzeitproblem hat für verschiedene Systeme einen unterschiedlichen Schweregrad.  In einigen Fällen können Sie einen Neustart zu einem Zeitpunkt planen, an dem die Last minimal ist.  Wenn Sie einen kontinuierlichen Service bieten möchten, können Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Entwässerungsanschlüsse" (AWS ELB-Verbindungsentleerung)</a> implementieren.  Wenn wir das System neu starten müssen, starten wir gleichzeitig eine parallele Instanz dieses Systems, schalten den Balancer darauf um und warten, bis die alten Verbindungen hergestellt sind.  Nachdem alle alten Verbindungen hergestellt wurden, deaktivieren wir die alte Systeminstanz. </p><br><p>  Betrachten wir nun das Problem des Speicherns der Konfiguration innerhalb oder außerhalb des Artefakts.  Wenn wir die Konfiguration im Artefakt speichern, hatten wir zumindest während der Montage des Artefakts die Möglichkeit, sicherzustellen, dass die Konfiguration korrekt war.  Wenn sich die Konfiguration außerhalb des kontrollierten Artefakts befindet, ist es schwierig zu verfolgen, wer und warum Änderungen an dieser Datei vorgenommen haben.  Wie wichtig ist das?  Unserer Meinung nach ist es für viele Produktionssysteme wichtig, eine stabile und qualitativ hochwertige Konfiguration zu haben. </p><br><p>  Mit der Version des Artefakts können Sie bestimmen, wann es erstellt wurde, welche Werte es enthält, welche Funktionen aktiviert / deaktiviert sind und wer für Änderungen in der Konfiguration verantwortlich ist.  Das Speichern der Konfiguration innerhalb des Artefakts erfordert natürlich einige Anstrengungen, sodass Sie eine fundierte Entscheidung treffen müssen. </p><br><h3 id="za-i-protiv">  Dafür und dagegen </h3><br><p>  Ich möchte auf die Vor- und Nachteile der vorgeschlagenen Technologie eingehen. </p><br><h4 id="preimuschestva">  Die Vorteile </h4><br><p>  Im Folgenden finden Sie eine Liste der Hauptfunktionen einer kompilierten verteilten Systemkonfiguration: </p><br><ol><li>  Statische Konfigurationsprüfung.  Ermöglicht es Ihnen, sicher zu sein <br>  Die Konfiguration ist korrekt. </li><li>   .         .   Scala      ,   . ,    <br> trait'    ,     ,    val',    (DRY)    .        ( <code>Seq</code> , <code>Map</code> ,  ). </li><li> DSL.  Scala    ,   DSL.        ,         , ,           .  , ,     . </li><li>     .    ,           ,       ,    ,   .        ,          .       ,       . </li><li>    .    ,    ,        . </li><li>   .          ,     . </li><li>  .     ,      .     . (  ,     ,     ,     ,     -.)       —    .  , ,    ,       ,    . </li><li>  .          ,         .   , ,        .                .        .       ,       production'. </li><li> .    ,            .  ,           ,    —   .      production- . </li><li>  Testen.     mock-,     ,   . </li><li>  .                  .  , , ,     . </li></ol><br><h4 id="nedostatki-i-ogranicheniya">    </h4><br><p>               .    : </p><br><ol><li>  .       production',    .        .          .           . </li><li>  .  ,      ,        . </li><li> .      ,     ,    .    /      . </li><li>   .   DevOps    .             . </li><li>    .               (CI/CD).      . </li></ol><br><p>       ,      : </p><br><ol><li>      ,    ,        .    ,    Cake Pattern'     , , <code>HList</code>     (case class')   . </li><li>     ,     : ( <code>package</code> , <code>import</code> ,  ; <code>override def</code> '  ,    ).    ,    DSL.  ,    (, XML),       . </li><li>            . </li></ol><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>                  Scala.                 xml-   .   ,      Scala,          (  Kotlin, C#, Swift, ...).         , ,  ,    ,    ,   . </p><br><p> ,      .       . </p><br><p>     : </p><br><ol><li>         . </li><li>   DSL        . </li><li>         . ,       ,  (1)      ; (2)       . </li></ol><br><h3 id="blagodarnosti">  </h3><br><p>     ,          . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447694/">https://habr.com/ru/post/de447694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447682/index.html">Space Data Center: 24 Stunden vor dem Start</a></li>
<li><a href="../de447684/index.html">So zeigen Sie Unternehmenswerte in einem Büro (ohne Poster und Slogans)</a></li>
<li><a href="../de447686/index.html">Ein sehr wichtiger Parameter von LED-Lampen, den nur wenige kennen</a></li>
<li><a href="../de447688/index.html">Auf die Frage nach Bitset</a></li>
<li><a href="../de447690/index.html">Kompilierbare Konfiguration eines verteilten Systems</a></li>
<li><a href="../de447696/index.html">Warum Städte gegen Amazon Go sind, die ersten bargeldlosen Geschäfte</a></li>
<li><a href="../de447698/index.html">Red Hogwarts: Akademiker ohne Diplom</a></li>
<li><a href="../de447700/index.html">Emotionale Flexibilität ist der Schlüssel zum persönlichen Wachstum.</a></li>
<li><a href="../de447702/index.html">Der ideale mathematische Kreis existiert nicht</a></li>
<li><a href="../de447704/index.html">Elbrus besteigen - Aufklärung im Kampf. Technischer Teil 1. Register, Stapel und andere technische Details</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>