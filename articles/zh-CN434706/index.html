<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥂 🎫 💂🏼 UDB。 这是什么 第3部分。数据路径FIFO 👏🏾 👩🏼‍🤝‍👨🏾 🏨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们将继续将赛普拉斯的专有文档转换为UDB模块。 而且，一切都非常吻合。 要继续关于UDB的实用文章，您将需要使用FIFO，并且在理论部分我们已经对它们进行了非常详细的描述。 因此，我们开始详细研究它们。 

 循环的一般内容是“ UDB。 这是什么？ 
 第1部分。简介。 请 
 第2部分。数据路...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>UDB。 这是什么 第3部分。数据路径FIFO</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434706/"><img src="https://habrastorage.org/webt/et/v5/rr/etv5rr-xdmsl0tyw4vtp_doh75k.jpeg"><br><br> 我们将继续将赛普拉斯的专有文档转换为UDB模块。 而且，一切都非常吻合。 要继续<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于UDB</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实用文章，您</a>将需要使用FIFO，并且在理论部分我们已经对它们进行了非常详细的描述。 因此，我们开始详细研究它们。 <br><a name="habracut"></a><br> 循环的一般内容是“ UDB。 这是什么？ <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分。简介。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分。数据路径。</a> <br> 第3部分。数据路径FIFO。  （当前文章） <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4部分。数据路径ALU。</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5部分。数据路径。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有用的小东西。</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第6部分。管理和状态模块。</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第7部分。时序和复位控制模块</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8部分。处理UDB</a> <br><br><h2>  21.3.2.2数据路径FIFO </h2><br><h3>  FIFO模式和配置 </h3><br> 每个FIFO缓冲区都有几种可用的操作模式和配置： <br><br> 表21-2。  FIFO模式和配置。 <br><div class="scrollable-table"><table><tbody><tr><th> 模式 </th><th> 内容描述 </th></tr><tr><td> 输入/输出 <br>  （输入/输出缓冲区） </td><td> 在输入缓冲模式下，CPU或DMA写入 <br>  FIFO中的数据，然后Datapath读取它。 在模式下 <br> 输出缓冲区数据从以下位置进入FIFO <br> 数据路径，并从那里读取CPU或DMA。 </td></tr><tr><td> 单缓冲器 <br>  （单缓冲区） </td><td>  FIFO用作没有状态的单个缓冲区。 <br>  FIFO中记录的数据可立即读取，并且可能 <br> 随时被覆盖。 </td></tr><tr><td> 水平/边缘 <br>  （等级/三角洲） </td><td> 负责从数据路径加载FIFO的参数， <br> 可以通过水平或差分触发。 </td></tr><tr><td> 正常/快速 <br>  （正常/快速） </td><td> 负责从源加载FIFO的参数 <br> 数据路径：以为数据路径选择的频率计时 <br> 时钟源（正常）或总线频率（快速）。 <br> 这使您可以以最高频率进行捕获。 <br> 在系统中（总线频率），与数据路径时钟频率无关。 </td></tr><tr><td> 软件捕获 <br>  （软件捕获） </td><td> 当此模式打开且FIFO处于模式时 <br> 输出缓冲区，读取CPU或DMA相关 <br> 电池（A0代表F0，A1代表F1），初始化 <br> 同步将电池值传输到FIFO。 <br> 捕获的值可立即从FIFO中读取。 <br> 如果激活了链接支持， <br> 该操作将遵循到MS块的链，以便 <br> 数据路径可以执行多字节的原子读取 <br> 价值观。 </td></tr><tr><td>  y <br>  （异步） </td><td> 当Datapach和系统总线时钟不是 <br> 同步的FIFO状态信号可以是 <br> 转发到其余数据路径 <br> 直接从数据路径时钟频率开始计时 <br> 或在Asynch模式下进行双重同步。 </td></tr><tr><td> 独立时钟极性 <br>  （独立时钟极性） </td><td> 每个FIFO都有一个控制位要反转 <br>  FIFO时钟极性与数据路径时钟的关系。 </td></tr></tbody></table></div><br> 图21-7显示了FIFO对的可能配置选项，具体取决于为每个FIFO选择的输入/输出模式。 如果一个FIFO处于输入模式，而另一个FIFO处于输出模式，则得到RX / TX配置。 需要这种配置的典型示例是SPI总线控制器。  <b>双捕获</b>配置（两个FIFO配置为输出）提供对A0和A1对的独立捕获，或者对A0或A1寄存器的两个独立捕获。 最后，在<b>双缓冲</b>模式下（均为输入），可以使用一个寄存器对或两个独立的寄存器进行加载或比较。 <br><br><img src="https://habrastorage.org/webt/jw/ii/lz/jwiilz_qkbulrpqu4n1xahxnsjq.png"><br><br> 图21-7。  FIFO配置。 <br><br> 图21-8详细显示了FIFO的源和接收器。 <br><br><img src="https://habrastorage.org/webt/lj/rf/4l/ljrf4lqn5lyyq2xsi6sml5ywi5o.png"><br><br> 图21-8。  FIFO源和接收器。 <br><br> 当FIFO在输入缓冲模式下工作时，源是系统总线，接收器是Dx和Ax寄存器。 在输出缓冲模式下工作时，源是Ax和ALU寄存器，接收器是系统总线。 多路复用器选择在UDB CFG15配置寄存器中静态设置，如F0_INSEL [1：0]或F1_INSEL [1：0]的表所示： <br><br> 表21-3。  UDB配置寄存器中的一组FIFO多路复用器。 <br><div class="scrollable-table"><table><tbody><tr><th>  Fx_INSEL [1：0] </th><th> 内容描述 </th></tr><tr><td>  00 </td><td> 输入缓冲模式：系统总线写入FIFO，而接收器 <br>  FIFO是Ax或Dx。 </td></tr><tr><td>  01 </td><td> 输出缓冲模式：FIFO源为A0，接收器为 <br>  FIFO-系统总线。 </td></tr><tr><td>  10 </td><td> 输出缓冲模式：FIFO的源是A1，接收器是 <br>  FIFO-系统总线。 </td></tr><tr><td>  11 </td><td> 输出缓冲模式：FIFO源是ALU输出，接收器是 <br>  FIFO-系统总线。 </td></tr></tbody></table></div><br><h3>  FIFO状态 </h3><br> 每个FIFO生成两个状态信号“总线”和“块”，它们通过数据路径输出多路复用器传输到UDB跟踪资源。 总线状态可用于中断或请求对FIFO的DMA读/写。  “块”状态主要用于将FIFO状态传递给内部UDB实体。 状态位的用途取决于配置的方向（Fx_INSEL [1：0]）和FIFO级别位。 在工作寄存器空间的辅助控制寄存器中设置FIFO级别位（Fx_LVL）。 下表显示了状态选项： <br><br> 表21-4。  FIFO状态选项。 <br><div class="scrollable-table"><table><tbody><tr><th>  Fx_INSEL [1：0] </th><th>  Fx_lvl </th><th> 条件 </th><th> 讯号 </th><th> 内容描述 </th></tr><tr><td> 进入 </td><td>  0 </td><td> 不满 </td><td> 巴士状态 </td><td> 当有FIFO时会阻塞 <br> 放置至少一个字节。 </td></tr><tr><td> 进入 </td><td>  1个 </td><td> 毁了 <br> 至少 <br> 一半 </td><td> 巴士状态 </td><td> 当有FIFO时会阻塞 <br> 至少2个字节的空间。 </td></tr><tr><td> 进入 </td><td> 不适用 </td><td> 是空的 </td><td> 封锁状态 </td><td> 没有FIFO时将阻塞 <br> 不是一个字节。 <br>  FIFO不为空时，数据路径 <br> 可以读取字节。 <br>  FIFO为空时，数据路径 <br> 可能能够 <br> 期望要么产生 <br> 毁灭性的状态。 </td></tr><tr><td></td></tr><tr><td> 结论 </td><td>  0 </td><td> 不空 </td><td> 巴士状态 </td><td> 处于FIFO时已阻塞 <br> 至少1个字节可用 <br> 阅读。 </td></tr><tr><td> 结论 </td><td>  1个 </td><td> 已满 <br> 至少 <br> 一半 </td><td> 巴士状态 </td><td> 在FIFO中可用时已阻塞 <br> 至少要读取2个字节。 </td></tr><tr><td> 结论 </td><td> 不适用 </td><td> 已满 </td><td> 封锁状态 </td><td> 当FIFO已满时，将被塞住。 <br> 当FIFO未完成时，数据路径 <br> 可以在FIFO中写入字节。 <br> 当FIFO已满时，数据路径 <br> 可能在 <br> 备用或 <br> 产生条件 <br> 溢出。 </td></tr></tbody></table></div><br><h3>  FIFO工作图 </h3><br> 图21-9显示了典型的读写顺序，以及与这些操作相关的状态的产生。 在图中，读写发生在不同的时间，但是它们可以同时执行。 <br><br><img src="https://habrastorage.org/webt/pp/kr/-p/ppkr-pcweqaiz61mam-o3d4oeti.png"><br><br> 图21-9 FIFO接收器操作 <br><br><h3>  FIFO快速模式（FIFO FAST） </h3><br> 当FIFO处于输出缓冲模式时，FIFO引导操作通常使用所选数据路径的时钟频率为写信号提供时钟。 如图21-10所示，选择FIFO快速模式（FIFO FAST）时，可以选择此特定操作的总线频率。 当与“电<b>平/边沿=边沿”</b>模式结合使用时，此操作可减少从电池到FIFO的从数据路径时钟周期到总线时钟周期的传输延迟，因为总线频率可能更高。 这允许CPU或DMA以最小的延迟读取接收到的FIFO结果。 <br><br> 如图21-10所示，无论当前的Datapath时钟如何，都会执行快速启动操作，但是，使用总线时钟速度会增加功耗。 <br><br><img src="https://habrastorage.org/webt/au/4c/0i/au4c0iq5pfcnnebsvxxq1hmf-zu.png"><br><br> 图21-10。  FIFO快速配置接收器。 <br><br><h3>  FIFO边沿/电平记录模式（差分/电平） </h3><br> 数据路径的FIFO中有两种记录模式。 在第一种模式下，数据从电池同步传输到FIFO。 该记录的控制信号（FX_LD）通常由状态机或与数据路径时钟同步的条件产生。 在输入负载控制信号为“ 1”的任何周期内都将执行对FIFO的写操作。 在第二种模式下，FIFO用于响应FX_LD信号的上升沿来捕获电池值。 在这种模式下，信号的信号格式是任意的（但是，其周期必须至少等于一个数据路径时钟周期）。 此模式的一个示例是使用外部脚的输入作为触发器来捕获电池电量。 此模式的局限性在于，在检测到另一个正差之前，输入参数必须至少一个周期返回值“ 0”。 <br><br> 图21-11显示了FX_LD输入上的差分检测模式的实现。  UDB中两个FIFO的模式都由同一位控制，切换此选项。 注意，差分检测的时钟频率等于所选FIFO的频率。 <br><br><img src="https://habrastorage.org/webt/xv/hq/u8/xvhqu8l5xwjgn-4aaww9ru8tkli.png"><br><br> 图21-11。 内部FIFO记录接收器的差分检测。 <br><br><h3>  FIFO软件捕获模式 </h3><br> 一个共同而重要的要求是使CPU和DMA在正常操作期间可靠地读取电池的内容。 这是使用软件捕获完成的，并使用FIFO上限配置位使能。 该位适用于UDB中的两个FIFO，但仅在FIFO处于输出缓冲区模式时才有效。 使用软件捕获时，F0必须从A0读取，F1必须从A1读取。 <br><br> 如图21-12所示，读取电池将启动从电池写入FIFO的操作。 信号链接在一条链中，因此，同时读取一个特定字节可捕获链中所有UDB的电池值。 这使8位处理器可以成功地同时读取16位或更多位。 读取电池时返回的数据应被忽略，捕获的值可立即从FIFO中读取。 <br><br> 跟踪的FX_LD信号（产生FIFO负载）与程序捕获信号一起发送到OR项。 当同时使用硬件和软件捕获时，结果可能无法预测。 通常，这些功能应该互斥，但是，在以下情况下可以同时使用硬件和软件捕获： <br><br><ul><li>  FIFO捕获时钟模式设置为FIFO FAST。 </li><li>  FIFO记录模式设置为FIFO EDGE。 </li></ul><br> 在上述条件下，硬件和软件捕获的工作原理相同，并且在任何总线时钟周期内，这些信号中的任何一个都可以触发捕获。 <br><br> 还建议在程序捕获开始之前清除程序代码（ACTL寄存器）中的目标FIFO。 因此，FIFO读和写指针将被设置为已知状态。 <br><br><img src="https://habrastorage.org/webt/0n/c7/zg/0nc7zgc7je5sn3emupt2ij7kdc0.png"><br><br> 图21-12。 软件捕获配置。 <br><br>  <i><b>译者注：</b></i> <i><br></i>  <i>很长一段时间我都无法理解本节的含义。</i>  <i>然后很长一段时间，我确定该部分是为PSoC3编写的，其8位内核不能访问的字节数以上。</i>  <i>但是，当创建转换的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第八部分时</a> ，事实证明，即使在PSoC5LP中，对于所有32位ARM处理器内核，也可以以八位或十六位模式访问工作的UDB寄存器。</i>  <i>从文档来看，仅此而已。</i>  <i>这就是所描述的功能派上用场的地方。</i> <i><br></i> <br><br><h3>  FIFO控制位 </h3><br> 辅助控制寄存器可在正常操作期间用于控制FIFO，包含4位。 <br><br>  FIFO0 CLR和FIFO1 CLR位用于复位或清除FIFO。 当为这些位之一分配值“ 1”时，相关的FIFO被复位。 该位必须恢复为其原始值（0），FIFO才能继续工作。 如果该位值保持等于1，则将禁用相应的FIFO，并将其用作无状态的单字节缓冲区。 可以将数据写入FIFO，可以立即读取数据，并且可以随时覆盖。 仍可以使用FX INSEL配置位[1：0]设置数据方向。 <br><br>  FIFO0 LVL和FIFO1 LVL位确定FIFO将阻塞状态位<b>“总线”的电平</b> （总线读取或写入FIFO时）。 也就是说， <b>“总线”</b>状态的状态取决于给定的方向，如下表所示。 <br><br> 表21-5。  FIFO电平控制位 <br><div class="scrollable-table"><table><tbody><tr><th>  FIFO LVL </th><th> 输入缓冲模式 <br>  （总线写入FIFO） </th><th> 输出缓冲模式 <br>  （总线从FIFO读取） </th></tr><tr><td>  0 </td><td> 不满 <br> 至少可以写入一个字节。 </td><td> 不空 <br> 至少可以读取一个字节。 </td></tr><tr><td>  1个 </td><td> 至少中途清空 <br> 至少可以写入2个字节。 </td><td> 半满 <br> 至少可以读取2个字节。 </td></tr></tbody></table></div><br><h3>  FIFO异步操作 </h3><br> 图21-13显示了异步FIFO操作的原理。 例如，假设F0在输入缓冲模式下工作，而F1在输出缓冲模式下工作，这是TX和RX寄存器的典型配置。 <br><br><img src="https://habrastorage.org/webt/ct/ei/lo/cteilo6ne7nn0ah0hprjtkbawvo.png"><br><br> 图21-13。 异步FIFO操作。 <br><br> 在TX端，数据路径状态机使用<b>Empty</b>标志来确定是否有任何字节可用于接收。  <b>Empty</b>值是与Datapath状态机同步设置的，并且由于来自总线的写入而被异步清除。 清洗后，状态再次与数据路径状态机同步。 <br><br> 在RX端，RX状态机使用<b>Full</b>来确定是否有空闲空间可写入FIFO。  <b>Full</b>值与Datapath状态机同步设置，由于总线读取而被异步清除。 清洗后，状态再次与数据路径状态机同步。 <br><br> 一个FIFO ASYNCH位用于启用该同步方法，激活后，该方法将应用于两个FIFO。 <br><br> 它仅适用于“ <b>块”</b>状态，因为假定<b>总线</b>状态由中断过程自然同步。 <br><br> 表21-6。  <b>块</b> FIFO状态同步选项。 <br><div class="scrollable-table"><table><tbody><tr><th> 异步 </th><th> 添加同步 </th><th> 运作方式 </th><th> 使用模式 </th></tr><tr><td>  0 </td><td>  0 </td><td> 与总线定时同步 </td><td>  CPU读/写状态更改 <br> 发生在总线频率上。 可以 <br> 使用最少 <br> 延迟，如果你能实现 <br>  Datapatch时钟频率 <br> 等于总线的频率。 </td></tr><tr><td>  0 </td><td>  1个 </td><td> 频率重新同步 <br> 轮胎到数据路径频率。 </td><td> 此模式应为 <br> 默认操作模式。 什么时候 <br>  CPU执行读/写操作， <br> 状态更改将重新同步 <br> 以及Datapath中使用的频率。 <br> 这样就可以使用全部 <br> 要设置的数据路径频率周期 <br>  UDB逻辑的信号。 </td></tr><tr><td>  1个 </td><td>  0 </td><td> 已预留 </td><td>  -- </td></tr><tr><td>  1个 </td><td>  1个 </td><td> 双频同步 <br> 轮胎到数据路径频率。 </td><td> 时钟脉冲用于数据路径时 <br> 不仅不同步 <br> 全身性但也 <br> 单独生产 <br> 独立发电机 <br> 此参数可能是 <br> 用于双 <br> 同步操作 <br> 读写CPU <br> 与数据路径时钟。 </td></tr></tbody></table></div><br><h3> 操作期间FIFO溢出 </h3><br> 为了安全地实现内部（数据路径）和外部（CPU或DMA）读写操作，应使用FIFO状态信号。 没有内置的清空和溢出条件保护。 如果FIFO已满，并且执行了后续写操作（溢出），则新数据将覆盖FIFO的开头（当前正在输出的数据是读取队列中的下一个）。 如果FIFO为空并且执行了后续读取（清空或耗尽），则读取值不确定。  FIFO指针保持准确，无论是否发生下溢和溢出。 <br><br><h3>  FIFO时钟反转 </h3><br> 每个FIFO都有一个控制位Fx CK INV，该位负责时钟FIFO的极性。关于时钟数据路径的极性。 默认情况下，FIFO与数据路径时钟具有相同的极性。 当该位为1时，FIFO相对于数据路径具有相反的极性。 这为双向交换数据（例如SPI）提供了协议支持。 <br><br><h3> 动态FIFO控制 </h3><br> 通常，FIFO是在输入缓冲模式或输出缓冲模式下静态配置的。 或者，每个FIFO可以配置为在动态控制方向（在外部信号的影响下）的模式下运行。 每个FIFO（Fx DYN）一个配置位负责激活此模式。 图21-14显示了FIFO动态模式下可用的配置。 <br><br><img src="https://habrastorage.org/webt/ny/ei/vo/nyeivo9hrnmr6vg8tkcbnnkaz8i.png"><br><br> 图21-14。 动态FIFO模式。 <br><br> 在内部访问模式下，数据路径可以读写FIFO。 在此配置中，为了选择FIFO中的写操作源，必须将Fx INSEL位设置为1。Fx INSEL = 0（CPU总线源）在此模式下不正确，它只能采用值1、2或3（A0，A1或ALU） ） 值得注意的是，读取只能访问适当的电池，该模式下数据寄存器的方向不可用。 <br><br> 在外部访问模式下，CPU或DMA可以读取或写入FIFO。 <br><br> 通过转发来自Datapath的信号，配置可以在外部访问和内部访问之间动态切换。 为此，使用输入信号数据路径d0_load和d1_load。 值得注意的是，在动态控制模式下，从F0 / F1加载寄存器D0 / D1时，d0_load和d1_load无法正常使用。  Dx_load信号可以由任何跟踪信号（包括常量）触发。 <br><br> 考虑一个示例，其中从外部访问（dx_load == 1）开始，CPU或DMA可以将一个或多个字节的数据写入FIFO。 然后，当切换到内部访问（dx_load == 0）时，Datapath可以对数据执行操作。 之后，当切换到外部访问时，CPU或DMA可以读取计算结果。 <br> 由于Fx INSEL应始终为01、10或11（A0，A1或ALU），这对应于正常操作期间的“输出缓冲区模式”，因此FIFO状态信号具有以下定义（取决于Fx LVL参数）： <br><br> 表21-7。  FIFO状态。 <br><div class="scrollable-table"><table><tbody><tr><th> 状态信号 </th><th> 价值 </th><th>  Fx LVL = 0 </th><th>  Fx LVL = 1 </th></tr><tr><td>  fx_blk_stat </td><td> 记录状态 </td><td>  FIFO已满 </td><td>  FIFO已满 </td></tr><tr><td>  fx_bus_stat </td><td> 阅读状态 </td><td>  FIFO不完整 </td><td> 半满 </td></tr></tbody></table></div><br> 由于数据路径和CPU都可以从FIFO中写入和读取，因此这些信号不再被视为块和总线状态。  blk_stat信号用于写入状态，而bus_stat信号用于读取状态 <br><br><h2>  21.3.2.3 FIFO状态 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有四个FIFO状态信号，每个FIFO有两个：fifo0_bus_stat，fifo0_blk_stat，fifo1_bus_stat和fifo1_blk_stat。</font><font style="vertical-align: inherit;">这些信号的含义取决于特定FIFO的方向，该方向由静态配置确定。</font><font style="vertical-align: inherit;">FIFO状态在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21.3.2.2数据路径FIFO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中有详细描述</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在下一部分中，我们将继续分析算术逻辑单元（ALU）。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN434706/">https://habr.com/ru/post/zh-CN434706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN434696/index.html">IT巨头的员工想出了如何影响公司政策的方法</a></li>
<li><a href="../zh-CN434698/index.html">对多线程的悲观主义</a></li>
<li><a href="../zh-CN434700/index.html">开发Angular应用程序时遵循样式指南的优点</a></li>
<li><a href="../zh-CN434702/index.html">为什么现代SSD使我崩溃</a></li>
<li><a href="../zh-CN434704/index.html">俄罗斯移动流量成本下降的原因以及对2019年的预测</a></li>
<li><a href="../zh-CN434708/index.html">HL2018。报告摘要“再次设置密码！ 如何击败暴力，让黑客一无所获”</a></li>
<li><a href="../zh-CN434710/index.html">RUVDS关于Habr的博客：三年</a></li>
<li><a href="../zh-CN434712/index.html">俄语第三次图灵测试</a></li>
<li><a href="../zh-CN434714/index.html">Spring中的客户端请求同步</a></li>
<li><a href="../zh-CN434716/index.html">移至数据中心：准备</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>