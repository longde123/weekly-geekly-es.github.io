<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘‚ğŸ¿ ğŸ¸ ğŸ˜ˆ Susunan docker Cara menunggu sampai wadah siap â™ï¸ ğŸ® ğŸš½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Ada banyak artikel tentang menjalankan wadah dan menulis docker-compose.yml . Tetapi bagi saya untuk waktu yang lama, pertanyaannya tida...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Susunan docker Cara menunggu sampai wadah siap</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454552/"><h1>  Pendahuluan </h1><br>  Ada banyak artikel tentang menjalankan wadah dan menulis <b>docker-compose.yml</b> .  Tetapi bagi saya untuk waktu yang lama, pertanyaannya tidak jelas bagaimana melanjutkan dengan benar jika beberapa wadah tidak boleh diluncurkan sampai wadah lain siap untuk memproses permintaannya atau melakukan sejumlah pekerjaan. <br><a name="habracut"></a><br>  Pertanyaan ini menjadi relevan setelah kami mulai aktif menggunakan <b>docker-compose</b> , alih-alih meluncurkan masing-masing docker. <br><br><h1>  Untuk apa ini? </h1><br>  Memang, biarkan aplikasi dalam wadah B tergantung pada ketersediaan layanan dalam wadah A. Dan pada saat startup, aplikasi dalam wadah B tidak menerima layanan ini.  Apa yang harus dilakukan? <br><br>  Ada dua opsi: <br><br><ul><li>  yang pertama adalah mati (lebih disukai dengan kode kesalahan) </li><li>  yang kedua adalah menunggu, dan kemudian mati pula, jika aplikasi dalam wadah B tidak merespons untuk batas waktu yang diberikan </li></ul><br>  Setelah kontainer B mati, <b>komposisi buruh pelabuhan</b> (tergantung pada konfigurasi tentu saja) akan memulai kembali dan aplikasi dalam wadah B akan mencoba lagi untuk mencapai layanan dalam wadah A. <br><br>  Ini akan berlanjut sampai layanan dalam wadah A siap untuk menanggapi permintaan, atau sampai kami melihat bahwa kontainer terus kelebihan muatan. <br>  Dan sebenarnya, ini adalah cara normal untuk arsitektur multi-container. <br><br>  Namun, khususnya, kami dihadapkan pada situasi di mana wadah A memulai dan menyiapkan data untuk wadah B. Aplikasi dalam wadah B tidak dapat memeriksa apakah data siap atau tidak, ia segera mulai bekerja dengan mereka.  Karena itu, kita harus menerima dan memproses sinyal tentang kesiapan data sendiri. <br><br>  Saya pikir Anda masih bisa memberikan beberapa use case.  Tetapi yang paling penting, Anda perlu memahami persis mengapa Anda melakukan ini.  Kalau tidak, lebih baik menggunakan alat pembuat <b>docker</b> standar. <br><br><h1>  Sedikit ideologi </h1><br>  Jika Anda membaca dokumentasi dengan cermat, maka semuanya tertulis di sana.  Yaitu masing-masing <br>  unit independen dan harus menjaga semua layanan dengan <br>  dengan mana ia akan bekerja, tersedia baginya. <br><br>  Oleh karena itu, pertanyaannya bukan untuk memulai atau tidak memulai wadah, tetapi untuk memulai <br>  di dalam wadah, periksa kesiapan semua layanan yang diperlukan dan hanya <br>  kemudian transfer kontrol ke aplikasi kontainer. <br><br><h1>  Bagaimana penerapannya </h1><br>  Untuk mengatasi masalah ini, deskripsi <b>buruh pelabuhan-menulis banyak</b> membantu saya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> bagian dari itu <br>  dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel</a> tentang penggunaan <b>entrypoint</b> dan <b>cmd yang tepat</b> . <br><br>  Jadi apa yang kita butuhkan: <br><br><ul><li>  ada lampiran A yang kami bungkus dalam wadah A </li><li>  itu dimulai dan mulai merespons OK pada port 8000 </li><li>  dan juga, ada aplikasi B, yang kita mulai dari wadah B, tetapi itu harus mulai bekerja tidak lebih awal dari aplikasi A akan mulai menanggapi permintaan pada port 8000 </li></ul><br>  Dokumentasi resmi menawarkan dua cara untuk mengatasi masalah ini. <br><br>  Yang pertama adalah menulis titik masuk Anda sendiri dalam wadah, yang akan melakukan semua pemeriksaan, dan kemudian memulai aplikasi yang berfungsi. <br><br>  Yang kedua adalah menggunakan file batch yang sudah ditulis <b>wait-for-it.sh</b> . <br>  Kami mencoba keduanya. <br><br><h2>  Menulis Entrypoint Anda Sendiri </h2><br>  Apa itu <b>entrypoint</b> ? <br><br>  Ini hanya file yang dapat dieksekusi yang Anda tentukan saat membuat wadah di <b>Dockerfile</b> di bidang <b>ENTRYPOINT</b> .  File ini, sebagaimana telah disebutkan, melakukan pemeriksaan, dan kemudian meluncurkan aplikasi utama wadah. <br><br>  Jadi apa yang kita dapatkan: <br><br>  Buat folder <i>Entrypoint</i> . <br><br>  Ini memiliki dua subfolder - <i>container_A</i> dan <i>container_B</i> .  Kami akan membuat wadah kami di dalamnya. <br><br>  Untuk penampung A, mari kita ambil http server sederhana dengan python.  Dia, setelah memulai, mulai merespons untuk mendapatkan permintaan pada port 8000. <br><br>  Untuk menjadikan percobaan kami lebih eksplisit, kami menetapkan penundaan 15 detik sebelum memulai server. <br><br>  Ternyata <b>file buruh pelabuhan</b> berikut <b>untuk wadah A</b> : <br><br><pre><code class="plaintext hljs">FROM python:3 EXPOSE 8000 CMD sleep 15 &amp;&amp; python3 -m http.server --cgi</code> </pre> <br>  Untuk kontainer B, buat <b>file buruh pelabuhan</b> berikut <b>untuk wadah B</b> : <br><br><pre> <code class="plaintext hljs">FROM ubuntu:18.04 RUN apt-get update RUN apt-get install -y curl COPY ./entrypoint.sh /usr/bin/entrypoint.sh ENTRYPOINT [ "entrypoint.sh" ] CMD ["echo", "!!!!!!!! Container_A is available now !!!!!!!!"]</code> </pre><br>  Dan menempatkan entrypoint.sh kita dapat dieksekusi di folder yang sama.  Kami akan memilikinya seperti ini <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash set -e host="conteiner_a" port="8000" cmd="$@" &gt;&amp;2 echo "!!!!!!!! Check conteiner_a for available !!!!!!!!" until curl http://"$host":"$port"; do &gt;&amp;2 echo "Conteiner_A is unavailable - sleeping" sleep 1 done &gt;&amp;2 echo "Conteiner_A is up - executing command" exec $cmd</span></span></code> </pre><br>  Apa yang terjadi dalam wadah B: <br><br><ul><li>  Saat dimulai, ia mulai <b>ENTRYPOINT</b> , mis.  meluncurkan <b>entrypoint.sh</b> </li><li>  <b>entrypoint.sh</b> , menggunakan <b>curl</b> , mulai polling port 8000 untuk container A. Ia melakukan ini hingga menerima respons 200 (mis. <b>curl</b> dalam hal ini akan berakhir dengan hasil nol dan loop akan berakhir) </li><li>  Ketika 200 diterima, loop berakhir dan kontrol beralih ke perintah yang ditentukan dalam variabel <b>$ cmd</b> .  Dan itu menunjukkan apa yang kami tunjukkan dalam file buruh pelabuhan di bidang <b>CMD</b> , mis.  <i>echo "!!! Container_A tersedia sekarang !!!!!!!!"</i>  Mengapa demikian, dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel di</a> atas </li><li>  Kami mencetak - <i>!!!</i>  <i>Container_A tersedia sekarang !!!</i>  <i>dan menyimpulkan.</i> </li></ul><br>  Kami akan memulai semuanya dengan <b>menulis buruh pelabuhan</b> . <br><br>  <b>docker-compose.yml di</b> sini kita memiliki ini: <br><br><pre> <code class="plaintext hljs">version: '3' networks: waiting_for_conteiner: services: conteiner_a: build: ./conteiner_A container_name: conteiner_a image: conteiner_a restart: unless-stopped networks: - waiting_for_conteiner ports: - 8000:8000 conteiner_b: build: ./conteiner_B container_name: conteiner_b image: waiting_for_conteiner.entrypoint.conteiner_b restart: "no" networks: - waiting_for_conteiner</code> </pre><br>  Di sini, di <b>conteiner_a,</b> tidak perlu menentukan <i>port: 8000: 8000</i> .  Ini dilakukan untuk dapat memverifikasi operasi server http yang berjalan di dalamnya dari luar. <br><br>  Juga, wadah B tidak memulai kembali setelah dimatikan. <br><br>  Kami meluncurkan: <br><br><pre> <code class="plaintext hljs">docker-compose up â€”-build</code> </pre><br>  Kami melihat bahwa selama 15 detik ada pesan tentang tidak tersedianya wadah A, dan kemudian <br><br><pre> <code class="plaintext hljs">conteiner_b | Conteiner_A is unavailable - sleeping conteiner_b | % Total % Received % Xferd Average Speed Time Time Time Current conteiner_b | Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt; conteiner_b | &lt;html&gt; conteiner_b | &lt;head&gt; conteiner_b | &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; conteiner_b | &lt;title&gt;Directory listing for /&lt;/title&gt; conteiner_b | &lt;/head&gt; conteiner_b | &lt;body&gt; conteiner_b | &lt;h1&gt;Directory listing for /&lt;/h1&gt; conteiner_b | &lt;hr&gt; conteiner_b | &lt;ul&gt; conteiner_b | &lt;li&gt;&lt;a href=".dockerenv"&gt;.dockerenv&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="bin/"&gt;bin/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="boot/"&gt;boot/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="dev/"&gt;dev/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="etc/"&gt;etc/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="home/"&gt;home/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="lib/"&gt;lib/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="lib64/"&gt;lib64/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="media/"&gt;media/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="mnt/"&gt;mnt/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="opt/"&gt;opt/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="proc/"&gt;proc/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="root/"&gt;root/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="run/"&gt;run/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="sbin/"&gt;sbin/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="srv/"&gt;srv/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="sys/"&gt;sys/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="tmp/"&gt;tmp/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="usr/"&gt;usr/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="var/"&gt;var/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;/ul&gt; conteiner_b | &lt;hr&gt; conteiner_b | &lt;/body&gt; conteiner_b | &lt;/html&gt; 100 987 100 987 0 0 98700 0 --:--:-- --:--:-- --:--:-- 107k conteiner_b | Conteiner_A is up - executing command conteiner_b | !!!!!!!! Container_A is available now !!!!!!!!</code> </pre><br>  Kami mendapatkan jawaban atas permintaan Anda, cetak <nobr><i>!!!</i></nobr>  <nobr><i>Container_A tersedia sekarang !!!!!!!!</i></nobr>  dan menyimpulkan. <br><br><h2>  Menggunakan wait-for-it.sh </h2><br>  Perlu segera mengatakan bahwa jalur ini tidak berfungsi untuk kami seperti yang dijelaskan dalam dokumentasi. <br>  Yaitu, diketahui bahwa jika <b>ENTRYPOINT</b> dan <b>CMD</b> ditulis dalam <b>Dockerfile</b> , maka ketika wadah dimulai, perintah dari <b>ENTRYPOINT</b> akan dieksekusi, dan konten <b>CMD</b> akan diteruskan ke parameter tersebut. <br><br>  Diketahui juga bahwa <b>ENTRYPOINT</b> dan <b>CMD yang</b> ditentukan dalam <b>Dockerfile</b> dapat didefinisikan ulang di <b>docker-compose.yml</b> <br><br>  <b>Format</b> startup <b>wait-for-it.sh adalah</b> sebagai berikut: <br><br><pre> <code class="plaintext hljs">wait-for-it.sh __ -- ___</code> </pre><br>  Kemudian, seperti yang ditunjukkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> , kita dapat mendefinisikan <b>ENTRYPOINT</b> baru di <b>docker-compose.yml</b> , dan <b>CMD akan</b> diganti dari <b>Dockerfile</b> . <br><br>  Jadi, kita dapat: <br><br>  <b>File Docker untuk kontainer A</b> tetap tidak berubah: <br><br><pre> <code class="plaintext hljs">FROM python:3 EXPOSE 8000 CMD sleep 15 &amp;&amp; python3 -m http.server --cgi</code> </pre><br>  <b>File docker untuk kontainer B</b> <br><br><pre> <code class="plaintext hljs">FROM ubuntu:18.04 COPY ./wait-for-it.sh /usr/bin/wait-for-it.sh CMD ["echo", "!!!!!!!! Container_A is available now !!!!!!!!"]</code> </pre><br>  <b>Docker-compose.yml</b> terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">version: '3' networks: waiting_for_conteiner: services: conteiner_a: build: ./conteiner_A container_name: conteiner_a image: conteiner_a restart: unless-stopped networks: - waiting_for_conteiner ports: - 8000:8000 conteiner_b: build: ./conteiner_B container_name: conteiner_b image: waiting_for_conteiner.wait_for_it.conteiner_b restart: "no" networks: - waiting_for_conteiner entrypoint: ["wait-for-it.sh", "-s" , "-t", "20", "conteiner_a:8000", "--"]</code> </pre><br>  Kami menjalankan perintah <b>wait-for-it</b> , suruh menunggu 20 detik hingga container A hidup kembali, dan tentukan parameter lain <b>â€œ-â€</b> , yang akan memisahkan parameter <b>wait-for-it</b> dari program yang akan diluncurkan setelah selesai. <br><br>  Kami mencoba! <br>  Dan sayangnya, kami tidak mendapatkan apa-apa. <br><br>  Jika kita memeriksa dengan argumen apa kita menjalankan wait-for-it, maka kita akan melihat bahwa hanya apa yang kita tentukan di <b>entry point yang dilewatkan ke sana</b> , <b>CMD</b> dari wadah tidak terpasang. <br><br><h3>  Opsi kerja </h3><br>  Lalu, hanya ada satu opsi.  Apa yang kami tentukan dalam <b>CMD</b> di <b>Dockerfile</b> , kami harus mentransfer ke <b>perintah</b> di <b>docker-compose.yml</b> . <br><br>  Kemudian, <b>biarkan Dockerfile dari</b> wadah B tidak berubah, dan <b>docker-compose.yml</b> akan terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">version: '3' networks: waiting_for_conteiner: services: conteiner_a: build: ./conteiner_A container_name: conteiner_a image: conteiner_a restart: unless-stopped networks: - waiting_for_conteiner ports: - 8000:8000 conteiner_b: build: ./conteiner_B container_name: conteiner_b image: waiting_for_conteiner.wait_for_it.conteiner_b restart: "no" networks: - waiting_for_conteiner entrypoint: ["wait-for-it.sh", "-s" ,"-t", "20", "conteiner_a:8000", "--"] command: ["echo", "!!!!!!!! Container_A is available now !!!!!!!!"]</code> </pre><br>  Dan dalam versi ini, ini berfungsi. <br><br>  Kesimpulannya, harus dikatakan bahwa menurut pendapat kami, cara yang benar adalah yang pertama.  Ini adalah yang paling universal dan memungkinkan Anda untuk melakukan pemeriksaan kesiapan dengan cara apa pun yang memungkinkan.  <b>Tunggu-itu-</b> hanya utilitas bermanfaat yang dapat Anda gunakan baik secara terpisah atau dengan menanamkan di <b>entrypoint</b> Anda. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454552/">https://habr.com/ru/post/id454552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454536/index.html">Amplifier ke sensor detak jantung klasik</a></li>
<li><a href="../id454538/index.html">Frontend Weekly Digest (27 Mei - 2 Juni 2019)</a></li>
<li><a href="../id454540/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 367 (27 Mei - 2 Juni 2019)</a></li>
<li><a href="../id454542/index.html">Jaringan TV kabel untuk yang terkecil. Bagian 7: Penerima Optik</a></li>
<li><a href="../id454546/index.html">Berapa banyak programmer yang Anda butuhkan untuk minum kopi</a></li>
<li><a href="../id454556/index.html">Berita dari dunia OpenStreetMap No. 462 (05.21.2019-27.05.2019)</a></li>
<li><a href="../id454558/index.html">PHP Digest No. 157 (20 Mei - 3 Juni 2019)</a></li>
<li><a href="../id454562/index.html">Mengapa konsep bytecode tidak relevan seperti sebelumnya</a></li>
<li><a href="../id454568/index.html">Mozilla menyebut distribusi paket web yang ditandatangani secara digital oleh Google sebagai "buruk"</a></li>
<li><a href="../id454570/index.html">Menciptakan game DOS lama di C ++ 17</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>