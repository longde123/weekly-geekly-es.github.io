<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßìüèø üö® ‚¨ÖÔ∏è Seguridad del m√≥vil OAuth 2.0 üßúüèº üëÉüèΩ üë©üèΩ‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La popularidad de las aplicaciones m√≥viles contin√∫a creciendo. Tambi√©n lo hace el protocolo OAuth 2.0 en aplicaciones m√≥viles. No es suficiente implem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seguridad del m√≥vil OAuth 2.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/456702/"><img src="https://habrastorage.org/getpro/habr/post_images/def/8b1/158/def8b1158655952902bf05be9fb7f308.jpg" alt="imagen"><br><br>  La popularidad de las aplicaciones m√≥viles contin√∫a creciendo.  Tambi√©n lo hace el protocolo OAuth 2.0 en aplicaciones m√≥viles.  No es suficiente implementar el est√°ndar como lo es hacer seguro el protocolo OAuth 2.0 all√≠.  Hay que tener en cuenta los detalles de las aplicaciones m√≥viles y aplicar algunos mecanismos de seguridad adicionales. <br><br>  En este art√≠culo, quiero compartir los conceptos de los ataques m√≥viles OAuth 2.0 y los mecanismos de seguridad utilizados para prevenir tales problemas.  Los conceptos descritos no son nuevos, pero falta informaci√≥n estructurada sobre este tema.  El objetivo principal del art√≠culo es llenar este vac√≠o. <br><a name="habracut"></a><br><h1>  OAuth 2.0 naturaleza y prop√≥sito </h1><br>  OAuth 2.0 es un protocolo de <i>autorizaci√≥n</i> que describe una forma para que un servicio de cliente obtenga un acceso seguro a los recursos del usuario en un proveedor de servicios.  Gracias a OAuth 2.0, el usuario no necesita ingresar su contrase√±a fuera del proveedor de servicios: todo el proceso se reduce a hacer clic en el bot√≥n "Acepto proporcionar acceso a ...". <br><br>  Un proveedor es un servicio que posee los datos del usuario y, con el permiso del usuario, proporciona servicios de terceros (clientes) con un acceso seguro a estos datos.  Un cliente es una aplicaci√≥n que quiere obtener los datos del usuario almacenados por el proveedor. <br><br>  Poco despu√©s del lanzamiento del protocolo OAuth 2.0, se adapt√≥ para la <i>autenticaci√≥n</i> , aunque no estaba destinado a eso.  El uso de OAuth 2.0 para la autenticaci√≥n desplaza un vector de ataque de los datos almacenados en el proveedor del servicio a las cuentas de usuario del servicio del cliente. <br><br>  Pero la autenticaci√≥n fue solo un comienzo.  En tiempos de aplicaciones m√≥viles y glorificaci√≥n de conversi√≥n, acceder a una aplicaci√≥n con solo un bot√≥n sonaba bien.  Los desarrolladores adaptaron OAuth 2.0 para uso m√≥vil.  Por supuesto, no muchos se preocuparon por la seguridad y los detalles de las aplicaciones m√≥viles: ¬°zap y entraron en la producci√≥n!  Por otra parte, OAuth 2.0 no funciona bien fuera de las aplicaciones web: existen los mismos problemas en las aplicaciones m√≥viles y de escritorio. <br><br>  Entonces, descubramos c√≥mo hacer que el OAuth 2.0 m√≥vil sea seguro. <br><br><h1>  Como funciona </h1><br>  Hay dos problemas principales de seguridad de OAuth 2.0 para dispositivos m√≥viles: <br><br><ol><li>  Cliente no confiable.  Algunas aplicaciones m√≥viles no tienen un back-end para OAuth 2.0, por lo que la parte del cliente del flujo del protocolo va en el dispositivo m√≥vil. <br></li><li>  Las redirecciones de un navegador a una aplicaci√≥n m√≥vil se comportan de manera diferente seg√∫n la configuraci√≥n del sistema, el orden en que se instalaron las aplicaciones y otras formas de magia. <br></li></ol><br>  Echemos un vistazo en profundidad a estos problemas. <br><br><h4>  La aplicaci√≥n m√≥vil es un cliente p√∫blico. </h4><br>  Para comprender las ra√≠ces y las consecuencias del primer problema, veamos c√≥mo funciona OAuth 2.0 en caso de interacci√≥n de servidor a servidor y luego comp√°relo con OAuth 2.0 en caso de interacci√≥n de cliente a servidor. <br><br>  En ambos casos, todo comienza con los registros del servicio del cliente en el servicio del proveedor y recibe <code>client_id</code> y <code>,</code> en algunos casos <code>, client_secret. client_id</code>  <code>, client_secret. client_id</code> es un valor p√∫blico, y se requiere para la identificaci√≥n del servicio del cliente en <code>client_secret</code> valor <code>client_secret</code> , que es privado.  Puede leer m√°s sobre el proceso de registro en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RFC 7591</a> . <br><br>  El siguiente esquema muestra la forma en que opera OAuth 2.0 en caso de interacci√≥n de servidor a servidor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a6/689/61f/9a668961fd270118492bec6134a1aca9.png"><br>  <i>Origen de la imagen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc6749#section-1.2</a></i> <br><br>  El protocolo OAuth 2.0 se puede dividir en tres pasos principales: <br><br><ol><li>  [pasos AC] Reciba un <code>code</code> <code>authorization_code</code> (en adelante, <code>code</code> ). <br></li><li>  [pasos DE] <code>code</code> intercambio para <code>access_token</code> . <br></li><li>  Obtenga recursos a trav√©s de <code>access_token</code> . </li></ol><br><br>  Vamos a desarrollar el proceso de obtener el valor del <code>code</code> : <br><br><ol><li>  [Paso A] El cliente redirige al usuario al proveedor de servicios. <br></li><li>  [Paso B] El proveedor de servicios solicita permiso al usuario para proporcionar al cliente los datos (flecha B hacia arriba).  El usuario proporciona acceso a datos (flecha B a la derecha). <br></li><li>  [Paso C] El proveedor de servicios devuelve el <code>code</code> al navegador del usuario que redirige el <code>code</code> al cliente. <br></li></ol><br>  Hablemos m√°s sobre el proceso de obtener <code>access_token</code> : <br><br><ol><li>  [Paso D] El servidor del cliente env√≠a una solicitud de <code>access_token</code> .  <code>Code</code> , <code>client_secret</code> y <code>redirect_uri</code> est√°n incluidos en la solicitud. <br></li><li>  [Paso E] En caso de <code>code</code> v√°lido, <code>client_secret</code> y <code>redirect_uri</code> , se proporciona <code>access_token</code> . <br></li></ol><br>  La solicitud de <code>access_token</code> a <code>access_token</code> se realiza de acuerdo con el esquema de servidor a servidor: por lo tanto, en general, el atacante debe hackear el servidor de servicio del cliente o el servidor del proveedor de servicios para robar <code>access_token</code> . <br><br>  Ahora veamos el esquema m√≥vil OAuth 2.0 sin backend (interacci√≥n de cliente a servidor). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ae/ec8/faa/0aeec8faa00c4d5736e7cf7ad36977ed.png"><br>  <i>Origen de la imagen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  El esquema principal se divide en los mismos pasos principales: <br><br><ol><li>  [pasos 1-4 en la imagen] Obtenga el <code>code</code> . </li><li>  [pasos 5-6 en la imagen] <code>code</code> intercambio para <code>access_token</code> </li><li>  Obtenga acceso a recursos a trav√©s de <code>access_token</code> </li></ol><br>  Sin embargo, en este caso, la aplicaci√≥n m√≥vil tambi√©n tiene funciones de servidor;  por lo tanto, <code>client_secret</code> se incrustar√° en la aplicaci√≥n.  Como resultado, <code>client_secret</code> no puede mantenerse oculto del atacante en dispositivos m√≥viles.  Embedded <code>client_secret</code> se puede extraer de dos maneras: analizando el tr√°fico de la aplicaci√≥n al servidor o mediante ingenier√≠a inversa.  Ambos se pueden implementar f√°cilmente, y es por eso que <code>client_secret</code> es in√∫til en dispositivos m√≥viles. <br><br>  Puede preguntar: "¬øPor qu√© no obtenemos <code>access_token</code> inmediato?"  Puede pensar que este paso adicional es innecesario.  Adem√°s, existe un esquema de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">concesi√≥n impl√≠cita</a> que permite que un cliente reciba <code>access_token</code> inmediato.  A pesar de que puede usarse en algunos casos, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Subvenci√≥n impl√≠cita</a> no funcionar√≠a para OAuth 2.0 m√≥vil seguro. <br><br><h4>  Redirecci√≥n en dispositivos m√≥viles </h4><br>  En general, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esquema URI personalizado</a> y los mecanismos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppLink</a> se utilizan para la redirecci√≥n de navegador a aplicaci√≥n.  Ninguno de estos mecanismos puede ser tan seguro como el navegador redirige por s√≠ solo. <br><br>  <i>El esquema URI personalizado</i> (o enlace profundo) se usa de la siguiente manera: un desarrollador determina un esquema de aplicaci√≥n antes de la implementaci√≥n.  El esquema puede ser cualquiera, y un dispositivo puede tener varias aplicaciones con el mismo esquema. <br><br>  Facilita las cosas cuando cada esquema en un dispositivo corresponde con una aplicaci√≥n.  Pero, ¬øqu√© pasa si dos aplicaciones registran el mismo esquema en un dispositivo?  ¬øC√≥mo decide el sistema operativo qu√© aplicaci√≥n abrir cuando se contacta a trav√©s del esquema URI personalizado?  Android mostrar√° una ventana con la opci√≥n de una aplicaci√≥n y un enlace a seguir.  iOS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no tiene un procedimiento para esto</a> y, por lo tanto, cualquiera de las aplicaciones puede abrirse.  De todos modos, el atacante tiene la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">oportunidad de interceptar c√≥digo o access_token</a> . <br><br>  A diferencia del esquema URI personalizado, <i>AppLink</i> garantiza abrir la aplicaci√≥n correcta, pero este mecanismo tiene varios defectos: <br><br><ol><li>  Cada cliente de servicio debe someterse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">al procedimiento de verificaci√≥n</a> . <br></li><li>  Los usuarios de Android pueden desactivar AppLink para una aplicaci√≥n espec√≠fica en la configuraci√≥n. <br></li><li>  Las versiones de Android anteriores a 6.0 y las versiones de iOS anteriores a 9.0 no son compatibles con AppLink. <br></li></ol><br>  Todos estos defectos de AppLink aumentan la curva de aprendizaje para clientes potenciales de servicio y pueden ocasionar la falla del usuario OAuth 2.0 en algunas circunstancias.  Es por eso que muchos desarrolladores no eligen el mecanismo AppLink como sustituci√≥n de la redirecci√≥n del navegador en el protocolo OAuth 2.0. <br><br><h1>  OK, ¬øqu√© hay para atacar? </h1><br>  Los problemas de Mobile OAuth 2.0 han creado algunos ataques espec√≠ficos.  Veamos qu√© son y c√≥mo funcionan. <br><br><a name="1"></a><h4>  Ataque de intercepci√≥n del c√≥digo de autorizaci√≥n </h4><br>  Consideremos la situaci√≥n en la que el dispositivo del usuario tiene una aplicaci√≥n leg√≠tima (cliente OAuth 2.0) y una aplicaci√≥n maliciosa que registr√≥ el mismo esquema que el leg√≠timo.  La siguiente imagen muestra el esquema de ataque. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d79/b98/46e/d79b9846e18e85a546b32a5927cdd627.png"><br>  <i>Origen de la imagen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc7636#section-1</a></i> <br><br>  Aqu√≠ est√° el problema: en el cuarto paso, el navegador devuelve el <code>code</code> en la aplicaci√≥n a trav√©s del esquema URI personalizado y, por lo tanto, el <code>code</code> puede ser interceptado por una aplicaci√≥n maliciosa (ya que est√° registrado el mismo esquema que una aplicaci√≥n leg√≠tima).  Luego, la aplicaci√≥n maliciosa cambia el <code>code</code> a <code>access_token</code> y recibe acceso a los datos del usuario. <br><br>  ¬øCu√°l es la protecci√≥n?  En algunos casos, puede usar la comunicaci√≥n entre procesos;  Hablaremos de eso m√°s tarde.  En general, necesita un esquema llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clave de prueba para el intercambio de c√≥digo</a> .  Se describe en el esquema a continuaci√≥n. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ac2/289/967/ac2289967122b9d5f458e35ab2a0d902.png"><br>  <i>Origen de la imagen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc7636#section-1.1</a></i> <br><br>  La solicitud del cliente tiene varios par√°metros adicionales: <code>code_verifier</code> , <code>code_challenge</code> (en el esquema <code>t(code_verifier)</code> ) y <code>code_challenge_method</code> (en el esquema <code>t_m</code> ). <br><br>  <code>Code_verifier</code> : es un n√∫mero aleatorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">con una longitud m√≠nima de 256 bits</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">que se usa solo una vez</a> .  Por lo tanto, un cliente debe generar un nuevo <code>code_verifier</code> para cada solicitud de <code>code</code> . <br><br>  <code>Code_challenge_method</code> : este es el nombre de una funci√≥n de conversi√≥n, principalmente SHA-256. <br><br>  <code>Code_challenge</code> : es <code>code_verifier</code> al que se <code>code_challenge_method</code> conversi√≥n <code>code_challenge_method</code> y que se codific√≥ en URL Safe Base64. <br><br>  La conversi√≥n de <code>code_verifier</code> en <code>code_challenge</code> es necesaria para rechazar los vectores de ataque basados ‚Äã‚Äãen la intercepci√≥n de <code>code_verifier</code> (por ejemplo, desde los registros del sistema del dispositivo) cuando se solicita el <code>code</code> . <br><br>  En caso de que un dispositivo de usuario <b>no sea compatible con</b> SHA-256, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>client is allowed to use plain conversion of code_verifier</code></a> .  En todos los dem√°s casos, se debe utilizar SHA-256. <br><br>  As√≠ es como funciona este esquema: <br><br><ol><li>  El cliente genera <code>code_verifier</code> y lo memoriza. <br></li><li>  El cliente elige <code>code_challenge_method</code> y recibe <code>code_challenge</code> de <code>code_verifier</code> . <br></li><li>  [Paso A] El cliente solicita el <code>code</code> , con <code>code_challenge</code> y <code>code_challenge_method</code> agregado a la solicitud. <br></li><li>  [Paso B] El proveedor almacena <code>code_challenge</code> y <code>code_challenge_method</code> en el servidor y devuelve el <code>code</code> a un cliente. <br></li><li>  [Paso C] El cliente solicita <code>access_token</code> , con <code>code_verifier</code> agregado. <br></li><li>  El proveedor recibe <code>code_challenge</code> del <code>code_challenge</code> entrante y luego lo compara con <code>code_challenge</code> , que guard√≥. <br></li><li>  [Paso D] Si los valores coinciden, el proveedor le otorga al cliente <code>access_token</code> . <br></li></ol><br>  Para entender por qu√© <code>code_challenge</code> intercepci√≥n de c√≥digo, veamos c√≥mo se ve el flujo del protocolo desde la perspectiva del atacante. <br><br><ol><li>  Primero, el <code>code</code> solicitud de aplicaci√≥n leg√≠tima ( <code>code_challenge</code> y <code>code_challenge_method</code> se env√≠a junto con la <b>solicitud</b> ). <br></li><li>  La aplicaci√≥n maliciosa intercepta el <code>code</code> (pero no <code>code_challenge</code> , ya que el c√≥digo <code>_challenge</code> no est√° en la respuesta). <br></li><li>  La aplicaci√≥n maliciosa solicita <code>access_token</code> (con <code>code</code> v√°lido, pero <b>sin</b> <code>code_verifier</code> v√°lido). <br></li><li>  El servidor nota la falta de coincidencia de <code>code_challenge</code> y genera un mensaje de error. <br></li></ol><br>  Tenga en cuenta que el atacante no puede adivinar <code>code_verifier</code> (¬°valor aleatorio de 256 bits!) O encontrarlo en alg√∫n lugar de los registros (ya que la primera solicitud realmente transmiti√≥ <code>code_challenge</code> ). <br><br>  Entonces, <code>code_challenge</code> responde la pregunta del proveedor de servicios: "¬ø <code>access_token</code> solicita el mismo cliente de la aplicaci√≥n que solicit√≥ el <code>code</code> o uno diferente?". <br><br><h4>  OAuth 2.0 CSRF </h4><br>  OAuth 2.0 CSRF es relativamente inofensivo cuando se usa OAuth 2.0 para autorizaci√≥n.  Es una historia completamente diferente cuando se usa OAuth 2.0 para la autenticaci√≥n.  En este caso, OAuth 2.0 CSRF a menudo conduce a la toma de control de la cuenta. <br><br>  Hablemos m√°s sobre el ataque CSRF conforme a OAuth 2.0 a trav√©s del ejemplo del cliente de la aplicaci√≥n de taxi y el proveedor provider.com.  Primero, un atacante en su propio dispositivo inicia sesi√≥n en la cuenta <code>attacker@provider.com</code> y recibe el <code>code</code> para el taxi.  Luego interrumpe el proceso OAuth 2.0 y genera un enlace: <br><br><pre> <code class="plaintext hljs">com.taxi.app://oauth? code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4</code> </pre> <br>  Luego, el atacante env√≠a este enlace a su v√≠ctima, por ejemplo, en forma de correo o mensaje de texto de cosas de taxi.  La v√≠ctima hace clic en el enlace, la aplicaci√≥n de taxi se abre y recibe <code>access_token</code> .  Como resultado, se encuentran en la cuenta de taxi <b>del atacante</b> .  Sin darse cuenta de eso, la v√≠ctima usa esta cuenta: realiza viajes, ingresa datos personales, etc. <br><br>  Ahora el atacante puede iniciar sesi√≥n en la cuenta de taxi de la v√≠ctima en cualquier momento, ya que est√° vinculado a <a href=""><code>attacker@provider.com</code></a> .  El ataque de inicio de sesi√≥n CSRF permiti√≥ al infractor robar una cuenta. <br><br>  Los ataques CSRF generalmente se rechazan con un token CSRF (tambi√©n se llama <code>state</code> ), y OAuth 2.0 no es una excepci√≥n.  C√≥mo usar el token CSRF: <br><br><ol><li>  La aplicaci√≥n del cliente genera y guarda el token CSRF en el dispositivo m√≥vil de un cliente. <br></li><li>  La aplicaci√≥n del cliente incluye el token CSRF en la solicitud de acceso al <code>code</code> . <br></li><li>  El servidor devuelve el mismo token CSRF con <code>code</code> en su respuesta. <br></li><li>  La aplicaci√≥n cliente compara los tokens CSRF entrantes y guardados.  Si sus valores coinciden, el proceso contin√∫a. <br></li></ol><br>  Requisitos de token CSRF: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nonce</a> debe ser de al menos 256 bits y recibirse de una buena fuente de secuencias pseudoaleatorias. <br><br>  En pocas palabras, el token CSRF permite que un cliente de la aplicaci√≥n responda la siguiente pregunta: "¬ø <code>access_token</code> yo quien inici√≥ la solicitud de <code>access_token</code> o alguien estaba tratando de enga√±arme?". <br><br><h4>  Secreto de cliente codificado </h4><br>  Las aplicaciones m√≥viles sin backend a veces almacenan valores de <code>client_id</code> y <code>client_secret</code> codificados.  Por supuesto, se pueden extraer f√°cilmente mediante la aplicaci√≥n de ingenier√≠a inversa. <br><br>  El impacto de exponer <code>client_id</code> y <code>client_secret</code> depende en gran medida de la cantidad que el proveedor de servicios de confianza ponga en el determinado par <code>client_id</code> , <code>client_secret</code> .  Uno los usa solo para distinguir un cliente de otro, mientras que otros abren puntos finales de API ocultos o establecen l√≠mites de velocidad m√°s suaves para algunos clientes. <br><br>  El art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Por qu√© las claves y los secretos API de OAuth no son seguros en las aplicaciones m√≥viles</a> explica m√°s sobre este tema. <br><br><h4>  Aplicaci√≥n maliciosa que act√∫a como un cliente leg√≠timo </h4><br>  Algunas aplicaciones maliciosas pueden imitar las aplicaciones leg√≠timas y mostrar una pantalla de consentimiento en su nombre (una pantalla de consentimiento es una pantalla en la que un usuario ve: "Acepto proporcionar acceso a ...").  El usuario puede hacer clic en "permitir" y proporcionar a la aplicaci√≥n maliciosa sus datos. <br><br>  Android e iOS proporcionan los mecanismos de verificaci√≥n cruzada de aplicaciones.  Un proveedor de aplicaciones puede asegurarse de que una aplicaci√≥n cliente sea leg√≠tima y viceversa. <br><br>  Desafortunadamente, si el mecanismo OAuth 2.0 usa un hilo a trav√©s del navegador, es imposible defenderse de este ataque. <br><br><h4>  Otros ataques </h4><br>  Echamos un vistazo m√°s de cerca a los ataques exclusivos para dispositivos m√≥viles OAuth 2.0.  Sin embargo, no nos olvidemos del OAuth 2.0 original: sustituci√≥n de <code>redirect_uri</code> , intercepci√≥n de tr√°fico a trav√©s de una conexi√≥n no segura, etc.  Puedes leer m√°s sobre esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h1>  ¬øC√≥mo hacerlo de forma segura? </h1><br>  Hemos aprendido c√≥mo funciona el protocolo OAuth 2.0 y qu√© vulnerabilidades tiene en los dispositivos m√≥viles.  Ahora, juntemos las piezas separadas para tener un esquema m√≥vil seguro de OAuth 2.0. <br><br><h4>  Bueno, malo OAuth 2.0 </h4><br>  Comencemos con la forma correcta de usar la pantalla de consentimiento.  Los dispositivos m√≥viles tienen dos formas de abrir una p√°gina web en una aplicaci√≥n m√≥vil. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/740/d1e/75a/740d1e75aedec07de286cf9d7fc49292.png"><br><br>  La primera forma es a trav√©s de la pesta√±a personalizada del navegador (a la izquierda de la imagen).  <b>Nota</b> : La pesta√±a personalizada del navegador para Android se denomina pesta√±a personalizada de Chrome y para iOS: SafariViewController.  Es solo una pesta√±a del navegador que se muestra en la aplicaci√≥n: no hay cambio visual entre las aplicaciones. <br><br>  La segunda forma es a trav√©s de WebView (a la derecha en la imagen) y lo considero malo con respecto al m√≥vil OAuth 2.0. <br><br>  WebView es un navegador integrado para una aplicaci√≥n m√≥vil. <br><br>  " <i>Navegador incorporado</i> " significa que el acceso a cookies, almacenamiento, cach√©, historial y otros datos de Safari y Chrome est√° prohibido para WebView.  Lo contrario tambi√©n es correcto: Safari y Chrome no pueden acceder a los datos de WebView. <br><br>  " <i>Navegador de aplicaciones m√≥viles</i> " significa que una aplicaci√≥n m√≥vil que ejecuta WebView tiene acceso <b>completo</b> a cookies, almacenamiento, cach√©, historial y otros datos de WebView. <br><br>  Ahora, imagine: un usuario hace clic en "entrar con ..." y un WebView de una aplicaci√≥n maliciosa solicita su nombre de usuario y contrase√±a al proveedor de servicios. <br><br>  Fracaso √©pico: <br><br><ol><li>  El usuario ingresa su nombre de usuario y contrase√±a para la cuenta del proveedor de servicios en la aplicaci√≥n, que puede robar f√°cilmente estos datos. <br></li><li>  OAuth 2.0 se desarroll√≥ inicialmente para <i>no ingresar el nombre de usuario y la contrase√±a del proveedor de servicios.</i> <i><br></i> <br>  El usuario se acostumbra a ingresar su nombre de usuario y contrase√±a en cualquier lugar, lo que aumenta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la</a> posibilidad de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pesca</a> . <br></li></ol><br>  Teniendo en cuenta todos los inconvenientes de WebView, se ofrece una conclusi√≥n obvia: use la pesta√±a personalizada del navegador para la pantalla de consentimiento. <br><br>  Si alguien tiene argumentos a favor de WebView en lugar de la pesta√±a personalizada del navegador, agradecer√≠a que escribiera al respecto en los comentarios. <br><br><h4>  Esquema m√≥vil seguro de OAuth 2.0 </h4><br>  Vamos a utilizar el esquema de autorizaci√≥n de concesi√≥n de c√≥digo, ya que nos permite agregar <code>code_challenge</code> , as√≠ como <code>state</code> y defendernos contra un ataque de intercepci√≥n de c√≥digo y OAuth 2.0 CSRF. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ae/ec8/faa/0aeec8faa00c4d5736e7cf7ad36977ed.png"><br>  <i>Origen de la imagen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  La solicitud de acceso al c√≥digo (pasos 1-2) tendr√° el siguiente aspecto: <br><br><pre> <code class="plaintext hljs">https://o2.mail.ru/code? redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; state=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; code_challenge_method=S256&amp; scope=email%2Cid&amp; response_type=code&amp; client_id=984a644ec3b56d32b0404777e1eb73390c</code> 3D% 3D y <code class="plaintext hljs">https://o2.mail.ru/code? redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; state=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; code_challenge_method=S256&amp; scope=email%2Cid&amp; response_type=code&amp; client_id=984a644ec3b56d32b0404777e1eb73390c</code> </pre> <br>  En el paso 3, el navegador obtiene una respuesta con redireccionamiento: <br><br><pre> <code class="plaintext hljs">com.mail.cloud.app://outh? code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; state=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24</code> </pre> <br>  En el paso 4, el navegador abre el esquema URI personalizado y pasa el token CSRF a una aplicaci√≥n cliente. <br>  solicitud de <code>access_token</code> (paso 5): <br><br><pre> <code class="plaintext hljs">https://o2.mail.ru/token? code_verifier=e61748f28b7d5daf881d571df434ed815a4a65b62c0f90bc77b8a3056f174abc&amp; code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; client_id=984a644ec3b56d32b0404777e1eb73390c</code> </pre> <br>  El √∫ltimo paso trae una respuesta con <code>access_token</code> . <br><br>  Este esquema es generalmente seguro, pero hay algunos casos especiales en los que OAuth 2.0 puede ser m√°s simple y m√°s seguro. <br><br><h4>  Android IPC </h4><br>  Android tiene un mecanismo de comunicaci√≥n de datos bidireccional entre procesos: IPC (comunicaci√≥n entre procesos).  IPC es mejor que el esquema URI personalizado por dos razones: <br><br><ol><li>  Una aplicaci√≥n que abre el canal IPC puede confirmar la autenticidad de una aplicaci√≥n que est√° abriendo mediante su certificado.  Lo contrario tambi√©n es cierto: la aplicaci√≥n abierta puede confirmar la autenticidad de la aplicaci√≥n que la abri√≥. <br></li><li>  Si un remitente env√≠a una solicitud a trav√©s del canal IPC, puede recibir una respuesta a trav√©s del mismo canal.  Junto con la verificaci√≥n cruzada (elemento 1), significa que ning√∫n proceso externo puede interceptar <code>access_token</code> . <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/dac/d7c/1a9/dacd7c1a98a6d1c7227b7e8e5e24757f.png"><br><br>  Por lo tanto, podemos usar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">concesi√≥n impl√≠cita</a> para simplificar el esquema m√≥vil OAuth 2.0.  Sin <code>code_challenge</code> y <code>state</code> tambi√©n significa menos superficie de ataque.  Tambi√©n podemos reducir los riesgos de que aplicaciones maliciosas act√∫en como clientes leg√≠timos que intentan robar las cuentas de los usuarios. <br><br><h4>  SDK para clientes </h4><br>  Adem√°s de implementar este esquema seguro de OAuth 2.0 m√≥vil, un proveedor debe desarrollar SDK para sus clientes.  Simplificar√° la implementaci√≥n de OAuth 2.0 en el lado del cliente y al mismo tiempo reducir√° la cantidad de errores y vulnerabilidades. <br><br><h1>  Conclusiones </h1><br>  D√©jame resumirlo para ti.  Aqu√≠ est√° la <i>lista de verificaci√≥n</i> (b√°sica) <i>para OAuth 2.0 seguro</i> para proveedores de OAuth 2.0: <br><br><ol><li>  Una base s√≥lida es crucial.  En el caso de OAuth 2.0 m√≥vil, la base es un esquema o un protocolo elegido para su implementaci√≥n.  Es f√°cil cometer errores al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementar su propio esquema OAuth 2.0</a> .  Otros ya recibieron golpes y aprendieron su lecci√≥n;  No hay nada de malo en aprender de sus errores y hacer una implementaci√≥n segura de una vez.  El esquema OAuth 2.0 m√≥vil m√°s seguro se describe en <i>¬øC√≥mo hacerlo de forma segura</i> ? <br></li><li>  <code>Access_token</code> y otros datos confidenciales deben almacenarse en Keychain para iOS y en Internal Storage para Android.  Estos almacenes se desarrollaron espec√≠ficamente solo para eso.  El proveedor de contenido se puede usar en Android, pero se debe configurar de forma segura. <br></li><li>  <code>Client_secret</code> es <b>in√∫til</b> , a menos que est√© almacenado en el backend.  No lo regale a los clientes p√∫blicos. <br></li><li>  No use WebView para la pantalla de consentimiento;  use la pesta√±a personalizada del navegador. <br></li><li>  Para defenderse del ataque de intercepci√≥n de c√≥digo, use <code>code_challenge</code> . <br></li><li>  Para defenderse contra OAuth 2.0 CSRF, use <code>state</code> . <br></li><li>  Use HTTPS en <b>todas partes</b> , con la degradaci√≥n prohibida a HTTP.  Aqu√≠ hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una demostraci√≥n de 3 minutos que</a> explica por qu√© (con un ejemplo de una recompensa por errores). <br></li><li>  Siga los <b>est√°ndares de</b> criptograf√≠a (elecci√≥n del algoritmo, longitud de los tokens, etc.).  Puede copiar los datos y descubrir por qu√© se hace de esta manera, pero no haga rodar su propia criptograf√≠a. <br></li><li>  <code>Code</code> debe usarse solo una vez, con una vida √∫til corta. <br></li><li>  Desde el lado del cliente de una aplicaci√≥n, verifique qu√© abre para OAuth 2.0;  y desde el lado de un proveedor de aplicaciones, verifique qui√©n lo abre para OAuth 2.0. <br></li><li>  Tenga en cuenta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las vulnerabilidades comunes de OAuth 2.0</a> .  Mobile OAuth 2.0 ampl√≠a y completa el original, por lo tanto, la verificaci√≥n de <code>redirect_uri</code> para una coincidencia exacta y otras recomendaciones para el OAuth 2.0 original todav√≠a est√°n vigentes. <br></li><li>  Debe proporcionar a sus clientes SDK.  Tendr√°n menos errores y vulnerabilidades y les ser√° m√°s f√°cil implementar su OAuth 2.0. <br></li></ol><br><h1>  Lectura adicional </h1><br><ol><li>  "Vulnerabilidades del m√≥vil OAuth 2.0" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.youtube.com/watch?v=vjCF_O6aZIg</a> <br></li><li>  Investigaci√≥n de la condici√≥n de carrera de OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://hackerone.com/reports/55140</a> <br></li><li>  Casi todo sobre OAuth 2.0 en un solo lugar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://oauth.net/2/</a> <br></li><li>  Por qu√© las claves y los secretos de la API de OAuth no son seguros en las aplicaciones m√≥viles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://developer.okta.com/blog/2019/01/22/oauth-api-keys-arent-safe-in-mobile-apps</a> <br></li><li>  [RFC] OAuth 2.0 para aplicaciones nativas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc8252</a> <br></li><li>  [RFC] Clave de prueba para el intercambio de c√≥digo por parte de clientes p√∫blicos de OAuth <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc7636</a> <br></li><li>  [RFC] Modelo de amenaza OAuth 2.0 y consideraciones de seguridad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc6819</a> <br></li><li>  [RFC] Protocolo de registro de cliente din√°mico OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc7591</a> <br></li><li>  Google OAuth 2.0 para aplicaciones m√≥viles y de escritorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://developers.google.com/identity/protocols/OAuth2InstalledApp</a> <br></li></ol><br><h1>  Cr√©ditos </h1><br>  Gracias a todos los que me ayudaron a escribir este art√≠culo.  Especialmente a Sergei Belov, Andrei Sumin, Andrey Labunets por los comentarios sobre detalles t√©cnicos, a Pavel Kruglov por la traducci√≥n al ingl√©s y a Daria Yakovleva por la ayuda con el lanzamiento de la versi√≥n rusa de este art√≠culo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456702/">https://habr.com/ru/post/456702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456686/index.html">Las complejidades de las entrevistas al contratar a udalenka</a></li>
<li><a href="../456690/index.html">Auriculares cotidianos de Case Guru - CGPods Sport</a></li>
<li><a href="../456692/index.html">El ascenso y la ca√≠da de Visual Basic</a></li>
<li><a href="../456696/index.html">¬øC√≥mo se devengan los intereses del pr√©stamo y c√≥mo aplicarlo?</a></li>
<li><a href="../456700/index.html">GeekUniversity abre reclutamiento en la facultad de gesti√≥n de productos</a></li>
<li><a href="../456704/index.html">Seis formas en que los evaluadores pueden beneficiarse (adem√°s de las pruebas funcionales)</a></li>
<li><a href="../456710/index.html">¬øQu√© es una plataforma de c√≥digo bajo / sin c√≥digo y CRM, CRM +, ERP?</a></li>
<li><a href="../456712/index.html">Registro selectivo de tr√°fico para servicios SOAP</a></li>
<li><a href="../456714/index.html">Comprender los n√∫meros de coma flotante (parte 0)</a></li>
<li><a href="../456716/index.html">Datos no muy grandes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>