<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏾 😧 🕜 Apa yang membawa kombinasi pengujian manual dan otomatis: pengalaman Wrike 🤷🏾 🧘🏿 ⚗️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Membaca artikel tentang topik pengujian web, dua topik muncul dengan syarat: 1) pengujian manual sedang sekarat, autotest (selanjutnya disebut autotes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang membawa kombinasi pengujian manual dan otomatis: pengalaman Wrike</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wrike/blog/474216/"><img src="https://habrastorage.org/webt/jg/uo/3e/jguo3eeblu6l26megn468bzw7tw.png"><br>  Membaca artikel tentang topik pengujian web, dua topik muncul dengan syarat: 1) pengujian manual sedang sekarat, autotest (selanjutnya disebut autotests adalah Selenium UI dan tes REST) ​​adalah segalanya bagi kami;  2) pengujian otomatis bukanlah obat mujarab, pengujian manual sangat diperlukan.  Pada saat yang sama, dari artikel ada kecenderungan peningkatan persyaratan untuk kualitas perangkat lunak dan kecepatan pengembangan produk.  Wrike hanya terjadi ketika persyaratan ini sangat penting. <br><br>  Produk ini sudah berusia 12 tahun, tetapi masih terus berkembang.  Penyebaran terjadi sekali sehari, dan kadang-kadang dua.  Oleh karena itu, sangat penting bagi kami bahwa regresi dilakukan secara eksklusif pada autotest.  Namun, di Wrike (di perusahaan) ada lebih dari 30 tim scrum, dan staf tim otomasi bukan karet.  Dalam keadaan seperti itu, untuk mengharapkan otomatisasi skenario manual paling baik, satu atau dua sprint bukanlah suatu pilihan.  Pengalaman perusahaan kami mengatakan bahwa penguji manual dapat menulis autotest secara independen, tergantung pada nuansa tertentu.  Dalam artikel saya akan menceritakan tentang mereka dan mengapa, menurut pendapat saya, kemampuan ini tidak hanya membantu untuk mengikuti tren, tetapi juga akan berguna untuk penguji sendiri. <br><a name="habracut"></a><br><h2>  <font color="#9fd326">Proses standar</font> </h2><br><img src="https://habrastorage.org/webt/-e/ai/sw/-eaisw_2cqiyashkplwfnu3o360.png"><br>  Proses apa yang digunakan banyak tim?  Ini bervariasi dari kasus ke kasus, tetapi fitur umum hampir sama.  Ada departemen pengujian otomatis dan manual.  Penguji manual dapat didistribusikan di antara perintah scrum.  Dalam hal ini, otomatisasi, sebagai suatu peraturan, tidak memiliki hubungan dengan tim tertentu. <br><br>  Ketika bekerja dengan fungsionalitas baru, tester membuat skrip pengujian, beberapa di antaranya ia tandai dengan cara yang telah ditentukan untuk automators.  Selain itu, jika sudah ada kasus di mana penyesuaian dilakukan, maka mereka juga dicatat untuk memperbarui kode.  Kemudian tes yang ditandai ditransfer ke departemen otomatisasi.  Sebuah tim insinyur otomasi bertugas memperbaiki dan menulis autotest baru di salah satu sprint berikut.  Selain skenario pengujian pemrograman, tugas automator meliputi menjalankan autotest, menganalisis hasil, serta mendukung dan mengembangkan proyek pengujian.  Ternyata departemen otomatisasi bertindak sebagai pelaksana outsourcing, dan penguji manual adalah sejenis pelanggan. <br><br>  Pelanggan juga menghabiskan waktu menyusun TOR yang terperinci dan akurat, secara berkala mendiskusikan metode implementasi dan memilih tes yang diperlukan.  Ada juga risiko bahwa selama tidak adanya bug autotests dapat dilewati.  Jangan lupa bahwa ada lapisan masalah teknis yang hanya bisa digulung pada tes otomatis, yang akan menghemat banyak waktu.  Tugas-tugas seperti itu harus diperiksa dengan tangan di bagian di mana otomasi masih hilang. <br><br>  Kontraktor, yang tidak terlalu tenggelam dalam fungsionalitas yang terlibat dalam tim, akan membutuhkan waktu untuk membenamkan diri dalam tugas dan kesadaran TOR secara dangkal.  Pada saat yang sama, ada kemungkinan bahwa tes tidak diterjemahkan secara akurat ke dalam kode, karena itu akan memeriksa apa yang tidak kita inginkan.  Dengan demikian, efisiensi dari basis pengujian berkurang. <br><br>  Tim otomasi, menjadi satu-satunya kontributor pada proyek uji, memiliki kendali penuh atas basis kodenya, yang memungkinkannya untuk dikembangkan dengan mudah ke segala arah.  Namun, waktu untuk ini menjadi tidak mencukupi karena meningkatnya beban dari tim lain.  Masalahnya dapat diselesaikan dengan memperluas staf, tetapi kemudian biaya otomatisasi akan melebihi efektivitasnya.  Bahkan jika Anda menghapus sebagian dari beban, memberikan penguji manual kesempatan untuk menjalankan tes dan menganalisis yang jatuh, ini tidak akan membawa hasil yang tepat.  Karena mereka tidak memiliki alat untuk debugging tes, mereka mungkin tidak mengerti bahwa tes macet karena perubahan xpath dan sebagainya. <br><br>  Dengan demikian, pada output kami mendapatkan bahwa autotest dengan skema ini tidak mengikuti pertumbuhan produk, yang mengarah pada cakupan kode yang buruk.  Karena interpretasi TK yang tidak akurat, tes dapat melewati bug.  Ketika mereka kedaluwarsa untuk waktu yang lama, yang jatuh tidak segera diperbaiki, dan sulit bagi penguji manual untuk segera memberi tahu bagian mana dari sistem yang tercakup dengan baik oleh otomatisasi.  Autotests menjadi semacam kotak hitam, di mana penguji tidak percaya.  Oleh karena itu, jumlah pemeriksaan manual yang tidak perlu semakin meningkat, persyaratan tugas semakin panjang, dan kualitas menurun dalam jangka panjang. <br><br>  Anda dapat mengatasi kekurangan ini, tetapi semakin besar produk dan perusahaan, semakin menyakitkan bagi peserta dalam proses, dan yang paling penting, sulit untuk mengikuti tren peningkatan kecepatan dan peningkatan kualitas.  Penguji sendiri menjadi sandera bagi rutinitas dan praktis tidak tetap pada perkembangan waktu. <br><br><h2>  <font color="#9fd326">Jalan yang salah</font> </h2><br><img src="https://habrastorage.org/webt/aw/1s/s5/aw1ss5krkgydvvudfelgilp-bvu.png"><br>  Jadi, bagaimana cara kerjanya pada contoh tim tempat saya bekerja.  Ada tim pengujian otomatis dan manual.  Data awal masih serupa, tetapi kemudian perbedaan dimulai.  Penguji manual didistribusikan di antara tim scrum mereka.  Setiap tim scrum memiliki autotester sendiri.  Kadang-kadang dapat dialokasikan bukan untuk satu tetapi untuk dua tim, jika beban memungkinkan. <br><br>  Ketika bekerja dengan fungsionalitas baru, tester menulis daftar periksa, yang menurutnya ia kemudian melakukan pemeriksaan manual.  Bagian minimum yang diperlukan dari tes dari daftar periksa ini adalah otomatis.  Penguji sendiri menulis autotest ini pada saat fitur sedang dalam pengembangan atau pengujian.  Selanjutnya, kode tertulis diberikan kepada peninjau untuk ditinjau.  Dengan pengecualian yang jarang, tugas tanpa autotes tidak dapat dikeluarkan. <br><br>  Tentu saja, tidak ada persyaratan dalam Wrike untuk menulis autotest oleh penguji manual.  Ini tetap pada kebijaksanaan tim.  Anda dapat memberikan segalanya untuk otomatisasi.  Anda dapat membatasi diri Anda untuk memperbaiki tes yang rusak dan / atau menulis baru dengan analogi, dan mendelegasikan tugas yang lebih kompleks (membuat tes baru atau memperluas pegangan back-end lama, Obyek Halaman atau langkah-langkah dan kelas uji) ke alat otomatisasi khusus.  Itu semua tergantung pada Anda, tetapi bodoh untuk melewatkan keuntungan yang diberikan oleh penulisan independen tes otomatis. <br><br>  Seluruh regresi kami didasarkan pada autotest, dan tanggung jawab penguji manual meliputi menjalankan dan menganalisis kegagalan autotest.  Untuk setiap cabang yang sedang dikerjakan oleh tim, mereka menjalankan tes otomatis sebagai penjamin kualitas awal dan akhir.  Karena itu, jauh lebih mudah bagi mereka yang menulis autotests sendiri untuk memahami mengapa tes yang berjalan di cabang mereka gagal.  Terkadang alat seperti jalankan kembali dan laporan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Allure</a> benar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">-</a> benar cukup, di mana Anda dapat memahami alasan crash pengujian dari tangkapan layar dan langkah-langkahnya.  Namun, seringkali asisten terbaik adalah kemampuan untuk menjalankan tes secara lokal, bermain-main dengan langkah-langkah atau menjalankannya dalam mode debug, melihat xpath yang diharapkan dan nyata.  Tanpa pengalaman bekerja dengan proyek uji, ini akan memakan banyak waktu, atau akan perlu untuk mengalihkan perhatian alat otomatisasi khusus. <br><br>  Selain itu, penulisan independen autotest memungkinkan untuk menjalankannya bahkan sebelum fitur dirilis.  Penguji selalu mengetahui tingkat cakupan bagian sistemnya, dan tugas teknis hanya bergulir pada pengujian otomatis, yang secara signifikan menghemat waktu dan sumber daya tim.  Tes itu sendiri selalu relevan, karena crash disesuaikan sebelum rilis.  Tes yang rusak segera diperbaiki di cabang yang sama di mana yang baru ditulis. <br><br>  Penguji manual secara maksimal terbenam dalam tugas tim, oleh karena itu, tes otomatis minimum yang diperlukan dipilih, yang mencakup sebagian besar kasus.  Sampel direvisi beberapa kali selama pengujian, seperti selama pemeriksaan manual, fungsionalitas dipelajari secara lebih rinci dengan semua nuansa.  Dengan demikian, efisiensi pengujian semacam itu semakin meningkat.  Menulis autotest memungkinkan Anda untuk lebih memahami arsitektur aplikasi, komponen yang digunakan, dan interaksi front-end dengan back-end.  Pada akhirnya, pengetahuan ini membantu pendekatan yang lebih sadar dan efektif untuk pengujian produk.  Sebagai contoh, jika beberapa perintah membuat perubahan pada komponen umum, maka Anda lebih mungkin mengetahui sebelumnya apakah ruang lingkup Anda akan atau tidak akan terpengaruh, karena ketika bekerja dengan xpath Anda memahami komponen mana yang digunakan di bagian aplikasi Anda. <br><br>  Dapat dikatakan bahwa menulis autotests membutuhkan waktu.  Ya, tugas akan dirilis satu hingga tiga hari lebih lambat dari biasanya, tetapi dalam jangka panjang itu terbayar.  Apalagi ada metode optimasi.  Misalnya, saat fitur sedang dikembangkan, Anda dapat menyusun daftar periksa yang diperlukan dan membuat kosong untuk tes, sehingga menghemat waktu.  Jika Anda memiliki kerangka kerja fungsionalitas yang siap pakai, dimungkinkan untuk menambah atau memperbaiki xpath yang ada, jika perlu, membuat Obyek Halaman baru atau menyesuaikan langkah-langkahnya.  Kemudian, pada tahap penulisan autotest, setelah pemeriksaan manual, Anda hanya perlu menambahkan blok kode dalam urutan yang benar. <br><br>  Berkat kerangka yang dikembangkan oleh tim otomasi kami, penulisan autotest untuk sebagian besar merupakan kompilasi kode dari blok - seperti Lego.  Kesederhanaan ini memungkinkan Anda untuk dengan cepat beradaptasi dengan penguji manual dan mulai menulis autotest dengan analogi dengan yang sudah ada.  Dari pengalaman saya sendiri, saya akan mengatakan bahwa butuh sekitar dua minggu dari saat saya pergi bekerja di Wrike sampai autotest pertama yang saya tulis, bersama dengan tugas-tugas lain. <br><br>  Kontrol kualitas tes otomatis tertulis dilakukan melalui tinjauan kode.  Tidak ada satu cabang uji pun yang masuk ke rilis tanpa ulasan.  Ini adalah momen pelatihan yang baik, karena tester mengambil informasi yang berguna dari komentar pada kodenya dan membangun pengalaman solusi yang baik: misalnya, ia mengelola perpustakaan Java standar lebih efisien atau mendefinisikan xpath lebih tepat.  Lain kali akan jelas cara terbaik untuk bekerja dengan situasi tertentu. <br><br>  Tentu saja, pengembangan proyek pengujian, kerangka kerja, dan pelatihan penguji manual mengambil sumber daya otomatisasi, terutama pada tahap awal, tetapi tampaknya bagi saya bahwa upaya ini sepenuhnya terbayar.  Kami memiliki banyak peningkatan di lingkungan pengujian otomatis yang membuat pekerjaan kami lebih mudah.  Produk itu sendiri memiliki cakupan yang baik, sehingga Anda dapat mengandalkan regresi.  Ini membantu mempercepat proses peluncuran fitur ke lingkungan pengguna dan sangat melindungi saraf penguji. <br><br>  Menurut pengalaman tim kami, ini adalah salah satu proses terbaik untuk bekerja dengan produk yang besar dan berkembang pesat di perusahaan besar.  Selain itu, sejalan dengan tren saat ini dalam meningkatkan kualitas perangkat lunak dan kecepatan pengiriman kepada pengguna.  Penguji sendiri praktis menyingkirkan rutinitas, berkembang dalam beberapa arah dan melihat aplikasi dari beberapa sudut. <br><br><h2>  <font color="#9fd326">Secara singkat tentang hal utama</font> </h2><br>  Untuk kenyamanan, saya akan menyoroti keunggulan untuk penguji manual di satu tempat, sehingga lebih mudah untuk menyadari signifikansinya secara individu atau bersama-sama: <br><br><ul><li>  Gambaran yang lebih lengkap terbentuk tentang tingkat dan kualitas otomasi ruang lingkup Anda; </li><li>  Autotests tersedia sebelum fitur dirilis, yang memungkinkan untuk dengan cepat memeriksa kualitasnya kapan saja; </li><li>  Efisiensi autotests meningkat, seperti halnya efisiensi pengujian secara umum; </li><li>  Pendekatan yang lebih terinformasi dan efektif untuk pengujian sedang dibentuk; </li><li>  Menyingkirkan regresi manual yang monoton dan tes evaluasi yang panjang; </li><li>  Pertumbuhan pribadi dan pengembangan kompetensi. </li></ul><br><h2>  <font color="#9fd326">Untuk meringkas</font> </h2><br>  Tentu saja, tidak ada peluru perak.  Apa yang cocok untuk satu perusahaan dapat ditolak dengan tajam oleh perusahaan lain.  Dalam kasus Wrike, produk tumbuh sangat cepat dan tidak ada waktu untuk regresi manual yang panjang dan pengujian evaluatif.  Kami memiliki peran ini dilakukan oleh autotests, yang mencakup hampir setiap komponen produk besar.  Ini membantu menjaga kualitas, mengoptimalkan sumber daya, dan menyediakan fungsionalitas baru kepada pengguna dengan lebih cepat. <br><br>  Berita buruknya adalah ia tidak dapat melakukan tanpa bug, tetapi dalam kasus kami, paling sering ini adalah beberapa kasus ekstrim.  Berita baiknya adalah bahwa bug selama perbaikan juga ditumbuhi autotests. <br>  Untuk beberapa alasan, sudah menjadi hal biasa di masyarakat sehingga gagasan untuk menulis autotest oleh penguji manual ditolak.  Ada dua argumen paling populer di pihak penguji: "Mereka tidak membayar ekstra untuk ini" dan "Kami sudah memiliki cukup banyak pekerjaan."  Bagi saya pribadi, kedua argumen tersebut berantakan ketika saya menyadari bahwa saya dapat menjalankan swa-uji pada saat fitur dikembangkan dan dalam waktu singkat memahami cara kerjanya dengan benar.  Itu sangat berharga.  Tugas kami adalah meningkatkan dan menjaga kualitas produk, sehingga setiap peluang digunakan untuk memfasilitasinya.  Dari saat saya mulai menulis autotests, rutinitas dalam pekerjaan saya menjadi semakin tidak disadari. <br><br>  PS Artikel ini hanya mencerminkan pengalaman tim kami dan mungkin tidak sesuai dengan keyakinan Anda.  Karena itu, saya akan senang mengetahui tentang pendekatan yang memandu Anda dalam pekerjaan Anda.  Saya juga akan senang dengan kritik yang sehat dan kesempatan untuk membahas artikel di komentar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474216/">https://habr.com/ru/post/id474216/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474200/index.html">Windows Terminal Preview 1910 Rilis</a></li>
<li><a href="../id474202/index.html">Sukses bukan tanpa bantuan orang lain: cara "menumbuhkan" proyek yang sudah selesai untuk pasar melalui pra-akselerator</a></li>
<li><a href="../id474204/index.html">Ucapkan kata tentang kutu yang berbeda atau bagaimana tidak mendapatkan kesalahan di Powershell saat bekerja dengan Get-Date</a></li>
<li><a href="../id474208/index.html">Longhorn, Rancher mendistribusikan penyimpanan untuk K8, ditransfer ke CNCF</a></li>
<li><a href="../id474212/index.html">Python dalam sebulan</a></li>
<li><a href="../id474220/index.html">Habr Weekly # 25 / Kerja Sama Informal, Karyawan Autistik, dan Kritik Telegram</a></li>
<li><a href="../id474222/index.html">Yurchik - mutan kecil tapi tangguh (N.-F. story)</a></li>
<li><a href="../id474224/index.html">Kotlin vs. Swift: Android dan iOS bergerak menuju bahasa universal?</a></li>
<li><a href="../id474226/index.html">Memperkenalkan Orleans 3.0</a></li>
<li><a href="../id474228/index.html">Lisensi proyek sumber terbuka yang mengharuskan pengguna untuk "tidak membahayakan"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>