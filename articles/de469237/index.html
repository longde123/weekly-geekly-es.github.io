<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëû üòÜ üë®üèΩ‚Äç‚úàÔ∏è Android Code Transformation üö® ü§úüèæ üÜô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Zweiter Teil 
 Anstatt mitzumachen 


 Alles begann mit der Tatsache, dass ich die Feinheiten der Gradle-Einstellungen lernen wollte, um deren F√§hig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android Code Transformation</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469237/"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweiter Teil</a> </li></ul><br><h2 id="vmesto-vstupleniya">  Anstatt mitzumachen </h2><br><p>  Alles begann mit der Tatsache, dass ich die Feinheiten der Gradle-Einstellungen lernen wollte, um deren F√§higkeiten in der Android-Entwicklung (und in der Tat) zu verstehen.  Ich begann mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lebenszyklus</a> und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B√ºchern</a> , schrieb nach und nach einfache Aufgaben, versuchte mein erstes Gradle-Plugin (in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">buildSrc</a> ) zu erstellen und dann begann es. </p><br><p>  Er entschied sich f√ºr etwas, das der realen Welt der Android-Entwicklung nahe kommt, und schrieb ein Plugin, das Layout-XML-Markup-Dateien analysiert und darauf ein Java-Objekt mit Links zu den Ansichten erstellt.  Dann g√∂nnte er sich die Transformation des Anwendungsmanifests (dies war f√ºr die eigentliche Aufgabe des Arbeitsentwurfs erforderlich), da das Manifest nach der Transformation etwa 5.000 Zeilen dauerte und die Arbeit in der IDE mit einer solchen XML-Datei ziemlich schwierig ist. </p><br><p>  Also habe ich herausgefunden, wie man Code und Ressourcen f√ºr ein Android-Projekt generiert, aber im Laufe der Zeit wollte ich etwas mehr.  Es gab die Idee, dass es cool w√§re, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AST</a> (Abstract Syntax Tree) in Kompilierungszeit umzuwandeln, wie es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Groovy</a> sofort tut.  Eine solche Metaprogrammierung er√∂ffnet viele M√∂glichkeiten, es w√ºrde eine Fantasie geben. </p><br><p>  Damit die Theorie nicht nur eine Theorie war, beschloss ich, das Studium des Themas durch die Schaffung von etwas N√ºtzlichem f√ºr die Android-Entwicklung zu verst√§rken.  Das erste, was mir in den Sinn kam, war die Erhaltung des Zustands bei der Neuerstellung von Systemkomponenten.  Grob gesagt ist das Speichern von Variablen im Bundle mit minimalem Boilerplate so einfach wie m√∂glich. </p><a name="habracut"></a><br><h2 id="s-chego-nachat">  Wo soll ich anfangen? </h2><br><ol><li>  Zun√§chst m√ºssen Sie verstehen, wie Sie in einem Android-Projekt auf die erforderlichen Dateien im Gradle-Lebenszyklus zugreifen, die wir dann transformieren. </li><li>  Zweitens, wenn wir die erforderlichen Dateien erhalten, m√ºssen wir verstehen, wie man sie richtig transformiert. </li></ol><br><p>  Beginnen wir in der richtigen Reihenfolge: </p><br><h3 id="poluchaem-dostup-k-faylam-v-moment-kompilyacii">  Greifen Sie beim Kompilieren auf Dateien zu </h3><br><p> Da wir zur Kompilierungszeit Dateien erhalten, ben√∂tigen wir ein Gradle-Plugin, das Dateien abf√§ngt und sich mit der Transformation befasst.  Das Plugin ist in diesem Fall so einfach wie m√∂glich.  Aber zuerst zeige ich Ihnen, wie die <code>build.gradle</code> Moduldatei mit dem Plugin aussieht: </p><br><pre> <code class="plaintext hljs">apply plugin: 'java-gradle-plugin' apply plugin: 'groovy' dependencies { implementation gradleApi() implementation 'com.android.tools.build:gradle:3.5.0' implementation 'com.android.tools.build:gradle-api:3.5.0' implementation 'org.ow2.asm:asm:7.1' }</code> </pre> <br><ol><li>  <code>apply plugin: 'java-gradle-plugin'</code> sagt, dass dies ein Modul mit einem Grad-Plugin ist. </li><li>  <code>apply plugin: 'groovy'</code> Dieses Plugin wird ben√∂tigt, um auf Grooves schreiben zu k√∂nnen (hier spielt es keine Rolle, Sie k√∂nnen mindestens Groovy, mindestens Java, mindestens Kotlin schreiben, was auch immer Sie m√∂chten).  Ich war urspr√ºnglich daran gew√∂hnt, Plugins in Grooves zu schreiben, da sie dynamisch eingegeben werden und manchmal n√ºtzlich sein k√∂nnen. Wenn sie nicht ben√∂tigt werden, k√∂nnen Sie einfach die Annotation <code>@TypeChecked</code> . </li><li>  <code>implementation gradleApi()</code> - Verbinden Sie die Gradle-API-Abh√§ngigkeit, damit auf <code>org.gradle.api.Plugin</code> , <code>org.gradle.api.Project</code> usw. <code>org.gradle.api.Project</code> kann. </li><li>  <code>'com.android.tools.build:gradle:3.5.0'</code> und <code>'com.android.tools.build:gradle-api:3.5.0'</code> werden ben√∂tigt, um auf die Entit√§ten des Android-Plugins zuzugreifen. </li><li>  <code>'com.android.tools.build:gradle-api:3.5.0'</code> Bibliothek <code>'com.android.tools.build:gradle-api:3.5.0'</code> zum Transformieren von Bytecode wird sp√§ter <code>'com.android.tools.build:gradle-api:3.5.0'</code> . </li></ol><br><p>  Kommen wir zum Plugin selbst, wie gesagt, es ist ganz einfach: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">YourPlugin</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Project</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Project project)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isAndroidApp = project.plugins.findPlugin(<span class="hljs-string"><span class="hljs-string">'com.android.application'</span></span>) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isAndroidLib = project.plugins.findPlugin(<span class="hljs-string"><span class="hljs-string">'com.android.library'</span></span>) != <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">null</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(!isAndroidApp &amp;&amp; !isAndroidLib)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GradleException( <span class="hljs-string"><span class="hljs-string">"'com.android.application' or 'com.android.library' plugin required."</span></span> ) } BaseExtension androidExtension = project.extensions.findByType(BaseExtension.class) androidExtension.registerTransform(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> YourTransform()) } }</code> </pre> <br><p>  <code>isAndroidLib</code> wir mit <code>isAndroidApp</code> und <code>isAndroidLib</code> . Hier √ºberpr√ºfen wir nur, ob es sich um ein Android-Projekt / eine Android-Bibliothek handelt. Wenn nicht, l√∂sen Sie eine Ausnahme aus.  Als n√§chstes registrieren Sie <code>YourTransform</code> im Android-Plugin √ºber <code>androidExtension</code> .  <code>YourTransform</code> ist eine Entit√§t zum <code>YourTransform</code> der erforderlichen Dateien und ihrer m√∂glichen Umwandlung. Sie muss die abstrakte Klasse <code>com.android.build.api.transform.Transform</code> erben. </p><br><p>  Gehen wir direkt zu <code>YourTransform</code> und betrachten zun√§chst die wichtigsten Methoden, die neu definiert werden m√ºssen: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">YourTransform</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Transform</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> YourTransform.simpleName } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> Set&lt;QualifiedContent.ContentType&gt; getInputTypes() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TransformManager.CONTENT_CLASS } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> Set&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> QualifiedContent.Scope&gt; getScopes() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TransformManager.PROJECT_ONLY } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIncremental</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } }</code> </pre> <br><ul><li>  <code>getName</code> - Hier m√ºssen Sie den Namen zur√ºckgeben, der f√ºr die Transformationsaufgabe verwendet wird, z. B. f√ºr die Debug-Assembly. In diesem Fall wird die Aufgabe wie folgt aufgerufen: <code>transformClassesWithYourTransformForDebug</code> . </li><li>  <code>getInputTypes</code> - <code>getInputTypes</code> an welchen Typen wir interessiert sind: Klassen, Ressourcen oder beides (siehe <code>com.android.build.api.transform.QualifiedContent.DefaultContentType</code> ).  Wenn Sie CLASSES angeben, erhalten wir f√ºr die Transformation nur Klassendateien, in diesem Fall sind sie f√ºr uns von Interesse. </li><li>  <code>getScopes</code> - <code>getScopes</code> an, welche Bereiche transformiert werden sollen (siehe <code>com.android.build.api.transform.QualifiedContent.Scope</code> ).  Bereiche sind der Bereich von Dateien.  In meinem Fall ist es beispielsweise PROJECT_ONLY, was bedeutet, dass nur die Dateien transformiert werden, die sich auf das Projektmodul beziehen.  Hier k√∂nnen Sie auch Untermodule, Bibliotheken usw. einf√ºgen. </li><li>  <code>isIncremental</code> - hier teilen wir dem Android-Plug-In mit, ob unsere Umwandlung inkrementelle Assembly unterst√ºtzt: Wenn true, m√ºssen alle ge√§nderten, hinzugef√ºgten und gel√∂schten Dateien korrekt aufgel√∂st werden. Wenn false, werden alle Dateien zur Umwandlung weitergeleitet. Wenn jedoch keine √Ñnderungen im Projekt vorgenommen wurden , dann wird die Transformation nicht aufgerufen. </li></ul><br><p>  Blieb am einfachsten und am meisten <del>  s√º√ü </del>  Methode, bei der die Transformation der Transformationsdateien <code>transform(TransformInvocation transformInvocation)</code> stattfindet.  Leider konnte ich keine normale Erkl√§rung f√ºr die korrekte Arbeitsweise mit dieser Methode finden. Ich habe nur chinesische Artikel und einige Beispiele ohne spezielle Erkl√§rungen gefunden. <a href="">Hier ist</a> eine der Optionen. </p><br><p>  Was ich beim Studium der Arbeit mit einem Transformator verstanden habe: </p><br><ol><li>  Alle Transformatoren sind an den Kettenmontageprozess angeschlossen.  Das hei√üt, Sie schreiben die Logik, die sein wird <del>  gedr√ºckt </del>  in einen bereits etablierten Prozess.  Nach Ihrem Transformator funktioniert ein anderer usw. </li><li>  <strong>SEHR WICHTIG:</strong> Auch wenn Sie beispielsweise keine Datei transformieren m√∂chten, m√∂chten Sie die JAR-Dateien, die bei Ihnen eintreffen, nicht √§ndern. Sie m√ºssen jedoch ohne √Ñnderung in Ihr Ausgabeverzeichnis kopiert werden.  Dieser Punkt folgt aus dem ersten.  Wenn Sie die Datei nicht weiter entlang der Kette auf einen anderen Transformator √ºbertragen, ist die Datei am Ende einfach nicht vorhanden. </li></ol><br><p>  √úberlegen Sie, wie die Transformationsmethode aussehen sollte: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TransformInvocation transformInvocation )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> TransformException, InterruptedException, IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.transform(transformInvocation) transformInvocation.outputProvider.deleteAll() transformInvocation.inputs.each { transformInput -&gt; transformInput.directoryInputs.each { directoryInput -&gt; File inputFile = directoryInput.getFile() File destFolder = transformInvocation.outputProvider.getContentLocation( directoryInput.getName(), directoryInput.getContentTypes(), directoryInput.getScopes(), Format.DIRECTORY ) transformDir(inputFile, destFolder) } transformInput.jarInputs.each { jarInput -&gt; File inputFile = jarInput.getFile() File destFolder = transformInvocation.outputProvider.getContentLocation( jarInput.getName(), jarInput.getContentTypes(), jarInput.getScopes(), Format.JAR ) FileUtils.copyFile(inputFile, destFolder) } } }</code> </pre> <br><p>  Am Eingang zu uns kommt <code>TransformInvocation</code> , das alle notwendigen Informationen f√ºr weitere Transformationen enth√§lt.  Zuerst bereinigen wir das Verzeichnis, in dem neue <code>transformInvocation.outputProvider.deleteAll()</code> -Dateien aufgezeichnet werden. Dies geschieht, da der Transformator keine inkrementelle Assembly unterst√ºtzt und Sie alte Dateien vor der Transformation l√∂schen m√ºssen. </p><br><p>  Als n√§chstes gehen wir alle Eingaben durch und in jeder Eingabe gehen wir die Verzeichnisse und JAR-Dateien durch.  M√∂glicherweise stellen Sie fest, dass alle JAR-Dateien einfach kopiert werden, um zum n√§chsten Transformator zu gelangen.  Dar√ºber hinaus sollte das Kopieren im Verzeichnis Ihres Transformators <code>build/intermediates/transforms/YourTransform/...</code>  Das richtige Verzeichnis kann mit <code>transformInvocation.outputProvider.getContentLocation</code> abgerufen werden. </p><br><p>  Stellen Sie sich eine Methode vor, die bereits bestimmte Dateien zur √Ñnderung extrahiert: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transformDir</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File input, File dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dest.exists()) { FileUtils.forceDelete(dest) } FileUtils.forceMkdir(dest) String srcDirPath = input.getAbsolutePath() String destDirPath = dest.getAbsolutePath() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (File file : input.listFiles()) { String destFilePath = file.absolutePath.replace(srcDirPath, destDirPath) File destFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(destFilePath) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.isDirectory()) { transformDir(file, destFile) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.isFile()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.name.endsWith(<span class="hljs-string"><span class="hljs-string">".class"</span></span>) &amp;&amp; !file.name.endsWith(<span class="hljs-string"><span class="hljs-string">"R.class"</span></span>) &amp;&amp; !file.name.endsWith(<span class="hljs-string"><span class="hljs-string">"BuildConfig.class"</span></span>) &amp;&amp; !file.name.contains(<span class="hljs-string"><span class="hljs-string">"R\$"</span></span>)) { transformSingleFile(file, destFile) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { FileUtils.copyFile(file, destFile) } } } }</code> </pre> <br><p>  Am Eingang erhalten wir das Verzeichnis mit dem Quellcode und das Verzeichnis, in das Sie die ge√§nderten Dateien schreiben m√∂chten.  Wir gehen rekursiv alle Verzeichnisse durch und erhalten die Klassendateien.  Vor der Transformation gibt es noch eine kleine √úberpr√ºfung, mit der Sie zus√§tzliche Klassen aussortieren k√∂nnen. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.name.endsWith(<span class="hljs-string"><span class="hljs-string">".class"</span></span>) &amp;&amp; !file.name.endsWith(<span class="hljs-string"><span class="hljs-string">"R.class"</span></span>) &amp;&amp; !file.name.endsWith(<span class="hljs-string"><span class="hljs-string">"BuildConfig.class"</span></span>) &amp;&amp; !file.name.contains(<span class="hljs-string"><span class="hljs-string">"R\$"</span></span>)) { transformSingleFile(file, destFile) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { FileUtils.copyFile(file, destFile) }</code> </pre> <br><p>  Also kamen wir zur <code>transformSingleFile</code> Methode, die bereits in den zweiten Absatz unseres urspr√ºnglichen Plans einflie√üt </p><br><blockquote>  Zweitens, wenn wir die erforderlichen Dateien erhalten, m√ºssen wir verstehen, wie man sie richtig transformiert. </blockquote><br><h3 id="transformaciya-vo-vsey-ee-krase">  Transformation in ihrer ganzen Pracht </h3><br><p>  F√ºr eine weniger bequeme Transformation der resultierenden Klassendateien gibt es mehrere Bibliotheken: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">javassist</a> , mit dem Sie sowohl den Bytecode als auch den Quellcode √§ndern k√∂nnen (es ist nicht erforderlich, sich mit dem Studium des Bytecodes zu befassen), und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ASM</a> , mit dem Sie nur den Bytecode √§ndern k√∂nnen und √ºber 2 verschiedene APIs verf√ºgen. </p><br><p>  Ich habe mich f√ºr ASM entschieden, da es interessant war, in die Bytecode-Struktur einzutauchen, und au√üerdem analysiert die Core-API Dateien auf der Grundlage des SAX-Parser-Prinzips, was eine hohe Leistung gew√§hrleistet. </p><br><p>  Die <code>transformSingleFile</code> Methode kann je nach ausgew√§hltem Datei√§nderungswerkzeug variieren.  In meinem Fall sieht es ziemlich einfach aus: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transformClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String inputPath, String outputPath)</span></span></span><span class="hljs-function"> </span></span>{ FileInputStream is = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(inputPath) ClassReader classReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassReader(is) ClassWriter classWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassWriter(ClassWriter.COMPUTE_FRAMES) StaterClassVisitor adapter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaterClassVisitor(classWriter) classReader.accept(adapter, ClassReader.EXPAND_FRAMES) <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> [] newBytes = classWriter.toByteArray() FileOutputStream fos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(outputPath) fos.write(newBytes) fos.close() }</code> </pre> <br><p>  Wir erstellen <code>ClassReader</code> zum Lesen einer Datei, wir erstellen <code>ClassWriter</code> zum Schreiben einer neuen Datei.  Ich verwende ClassWriter.COMPUTE_FRAMES, um Stapelrahmen automatisch zu berechnen, da ich mich mehr oder weniger mit Locals und Args_size (Bytecode-Terminologie) befasst habe, aber ich habe noch nicht viel mit Frames gemacht.  Das automatische Berechnen von Frames ist etwas langsamer als das manuelle Berechnen. <br>  Erstellen Sie dann Ihren <code>StaterClassVisitor</code> , der von <code>ClassVisitor</code> erbt und classWriter √ºbergibt.  Es stellt sich heraus, dass unsere Dateimodifikationslogik dem Standard ClassWriter √ºberlagert ist.  In der ASM-Bibliothek werden alle <code>Visitor</code> auf diese Weise erstellt.  Als n√§chstes bilden wir ein Byte-Array f√ºr die neue Datei und generieren die Datei. </p><br><p>  Weitere Einzelheiten meiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">praktischen Anwendung der untersuchten</a> Theorie werden folgen. </p><br><h4 id="sohranenie-sostoyaniya-v-bundle-s-pomoschyu-annotacii">  Speichern des Status im Bundle mithilfe von Anmerkungen </h4><br><p>  Daher habe ich mir die Aufgabe gestellt, die Datenspeicher-Boilerplate bei der Neuerstellung der Aktivit√§t so weit wie m√∂glich im Bundle zu entfernen.  Ich wollte alles so machen: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivityJava</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@State</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> savedInt = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Um die Effizienz zu maximieren, habe ich dies vorerst getan (ich werde Ihnen sp√§ter erkl√§ren, warum): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Stater</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivityJava</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(StateType.INT) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> savedInt = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Und es funktioniert wirklich!  Nach der Transformation sieht der <code>MainActivityJava</code> Code folgenderma√üen aus: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Stater</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivityJava</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(StateType.INT) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> savedInt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.savedInt = savedInstanceState.getInt(<span class="hljs-string"><span class="hljs-string">"com/example/stater/MainActivityJava_savedInt"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSaveInstanceState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Bundle outState)</span></span></span><span class="hljs-function"> </span></span>{ outState.putInt(<span class="hljs-string"><span class="hljs-string">"com/example/stater/MainActivityJava_savedInt"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.savedInt); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onSaveInstanceState(outState); }</code> </pre> <br><p>  Die Idee ist sehr einfach. Fahren wir mit der Implementierung fort. <br>  Mit der Core-API k√∂nnen Sie nicht die vollst√§ndige Struktur der gesamten Klassendatei haben. Bei bestimmten Methoden m√ºssen alle erforderlichen Daten abgerufen werden.  Wenn Sie sich <code>StaterClassVisitor</code> , k√∂nnen Sie sehen, dass wir in der <code>StaterClassVisitor</code> Informationen √ºber die Klasse erhalten. In <code>StaterClassVisitor</code> pr√ºfen wir, ob unsere Klasse mit der Annotation <code>@Stater</code> gekennzeichnet ist. </p><br><p>  Dann durchl√§uft unser <code>ClassVisitor</code> alle Felder der Klasse und ruft die <code>visitField</code> Methode auf. Wenn die Klasse transformiert werden muss, hei√üt unser <code>StaterFieldVisitor</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">FieldVisitor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> access, String name, String descriptor, String signature, Object value)</span></span></span><span class="hljs-function"> </span></span>{ FieldVisitor fv = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.visitField(access, name, descriptor, signature, value) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needTransform) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaterFieldVisitor(fv, name, descriptor, owner) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fv }</code> </pre> <br><p>  <code>StaterFieldVisitor</code> nach der <code>@State</code> Annotation und gibt <code>StateAnnotationVisitor</code> in der <code>visitAnnotation</code> Methode zur√ºck: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">AnnotationVisitor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitAnnotation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String descriptor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible)</span></span></span><span class="hljs-function"> </span></span>{ AnnotationVisitor av = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.visitAnnotation(descriptor, visible) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (descriptor == Descriptors.STATE) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StateAnnotationVisitor(av, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.descriptor, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.owner) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> av }</code> </pre> <br><p>  Was bereits eine Liste der Felder bildet, die zum Speichern / Wiederherstellen erforderlich sind: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitEnum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, String descriptor, String value)</span></span></span><span class="hljs-function"> </span></span>{ String typeString = (String) value SaverField field = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SaverField(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.descriptor, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.owner, StateType.valueOf(typeString)) Const.stateFields.add(field) <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.visitEnum(name, descriptor, value) }</code> </pre> <br><p>  Es zeigt sich die baumartige Struktur unserer Besucher, die als Ergebnis eine Liste von SaverField- <code>SaverField</code> mit allen Informationen bilden, die wir zum Generieren eines Sicherungsstatus ben√∂tigen. <br>  Als <code>ClassVisitor</code> beginnt unser <code>ClassVisitor</code> , die Methoden zu <code>onCreate</code> und <code>onSaveInstanceState</code> und <code>onCreate</code> <code>onSaveInstanceState</code> .  Wenn keine Methoden gefunden werden, werden sie in <code>visitEnd</code> (aufgerufen nach √úbergabe der gesamten Klasse) von Grund auf neu generiert. </p><br><h4 id="gde-zhe-baytkod">  Wo ist der Bytecode? </h4><br><p>  Der interessanteste Teil beginnt in den Klassen <code>OnCreateVisitor</code> und <code>OnSavedInstanceStateVisitor</code> .  F√ºr eine korrekte √Ñnderung des Bytecodes ist es notwendig, seine Struktur zumindest geringf√ºgig darzustellen.  Alle Methoden und Opcodes von ASM sind den tats√§chlichen Anweisungen des Batcodes sehr √§hnlich. Auf diese Weise k√∂nnen Sie mit denselben Konzepten arbeiten. <br>  Betrachten Sie ein Beispiel zum √Ñndern der <code>onCreate</code> Methode und vergleichen Sie sie mit dem generierten Code: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.savedInt = savedInstanceState.getInt(<span class="hljs-string"><span class="hljs-string">"com/example/stater/MainActivityJava_savedInt"</span></span>); }</code> </pre> <br><p>  Das √úberpr√ºfen eines Bundles auf Null bezieht sich auf die folgenden Anweisungen: </p><br><pre> <code class="java hljs">Label l1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Label() mv.visitVarInsn(Opcodes.ALOAD, <span class="hljs-number"><span class="hljs-number">1</span></span>) mv.visitJumpInsn(Opcodes.IFNULL, l1) <span class="hljs-comment"><span class="hljs-comment">//...      mv.visitLabel(l1)</span></span></code> </pre> <br><p>  In einfachen Worten: </p><br><ol><li>  Erstellen Sie ein Label l1 (nur ein Label, zu dem Sie gehen k√∂nnen). </li><li>  Wir laden die Referenzvariable mit Index 1 in den Speicher. Da Index 0 immer der Referenz auf diese entspricht, ist in diesem Fall 1 die Referenz auf das <code>Bundle</code> im Argument. </li><li>  Die Nullpr√ºfung selbst und die goto-Anweisung auf dem l1-Etikett.  <code>visitLabel(l1)</code> nach der Arbeit mit dem Bundle angegeben. </li></ol><br><p>  Wenn wir mit dem Bundle arbeiten, gehen wir die Liste der generierten Felder durch und rufen die <code>PUTFIELD</code> Anweisung auf - Zuweisung zu einer Variablen.  Schauen wir uns den Code an: </p><br><pre> <code class="java hljs">mv.visitVarInsn(Opcodes.ALOAD, <span class="hljs-number"><span class="hljs-number">0</span></span>) mv.visitVarInsn(Opcodes.ALOAD, <span class="hljs-number"><span class="hljs-number">1</span></span>) mv.visitLdcInsn(field.key) <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> StateType type = MethodDescriptorUtils.primitiveIsObject(field.descriptor) ? StateType.SERIALIZABLE : field.type MethodDescriptor methodDescriptor = MethodDescriptorUtils.getDescriptorByType(type, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodDescriptor == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !methodDescriptor.isValid()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"StateType for ${field.name} in ${field.owner} is unknown!"</span></span>) } mv.visitMethodInsn( Opcodes.INVOKEVIRTUAL, Types.BUNDLE, methodDescriptor.method, <span class="hljs-string"><span class="hljs-string">"(${Descriptors.STRING})${methodDescriptor.descriptor}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// cast if (type == StateType.SERIALIZABLE || type == StateType.PARCELABLE || type == StateType.PARCELABLE_ARRAY || type == StateType.IBINDER ) { mv.visitTypeInsn(Opcodes.CHECKCAST, Type.getType(field.descriptor).internalName) } mv.visitFieldInsn(Opcodes.PUTFIELD, field.owner, field.name, field.descriptor)</span></span></code> </pre> <br><p>  <code>MethodDescriptorUtils.primitiveIsObject</code> - hier √ºberpr√ºfen wir, ob die Variable einen Wrapper-Typ hat. Wenn ja, betrachten Sie den Variablentyp als <code>Serializable</code> .  Dann wird der Getter aus dem Bundle aufgerufen, ggf. gegossen und einer Variablen zugeordnet. </p><br><p>  Das ist alles, die Codegenerierung in der <code>onSavedInstanceState</code> Methode erfolgt auf √§hnliche Weise, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beispielsweise</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Auf welche Probleme sind Sie gesto√üen?</b> <div class="spoiler_text"><ol><li>  Der erste Haken, <code>@Stater</code> Annotation <code>@Stater</code> hinzugef√ºgt wurde.  Ihre Aktivit√§t / Ihr Fragment kann von einer <code>BaseActivity</code> , was das Verst√§ndnis dar√ºber, ob ein Status <code>BaseActivity</code> soll oder nicht, erheblich erschwert.  Sie m√ºssen alle Eltern dieser Klasse durchgehen, um herauszufinden, dass dies wirklich eine Aktivit√§t ist.  <code>@Stater</code> kann auch die Leistung des Compilers verringern (in Zukunft besteht die Idee, die Annotation <code>@Stater</code> am effektivsten zu <code>@Stater</code> ). </li><li>  Der Grund f√ºr die explizite Angabe von <code>StateType</code> ist der gleiche wie der Grund f√ºr den ersten Haken.  Sie m√ºssen die Klasse weiter analysieren, um zu verstehen, dass sie <code>Parcelable</code> oder <code>Serializable</code> .  Aber die Pl√§ne haben bereits Ideen, um <code>StateType</code> loszuwerden :). </li></ol></div></div><br><h4 id="nemnogo-o-proizvoditelnosti">  Ein bisschen √ºber Leistung </h4><br><p>  Zur √úberpr√ºfung habe ich 10 Aktivierungen mit jeweils 46 gespeicherten Feldern unterschiedlichen Typs erstellt, die im Befehl <code>./gradlew :app:clean :app:assembleDebug</code> √ºberpr√ºft wurden.  Die Zeit, die meine Transformation ben√∂tigt, reicht von 108 bis 200 ms. </p><br><h4 id="sovety">  Tipps </h4><br><ul><li><p>  Wenn Sie sich den resultierenden Bytecode <code>TraceClassVisitor</code> , k√∂nnen Sie <code>TraceClassVisitor</code> (von ASM bereitgestellt) mit Ihrem Transformationsprozess verbinden: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transformClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String inputPath, String outputPath)</span></span></span><span class="hljs-function"> </span></span>{ ... TraceClassVisitor traceClassVisitor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TraceClassVisitor(classWriter, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintWriter(System.out)) StaterClassVisitor adapter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaterClassVisitor(traceClassVisitor) ... }</code> </pre> <br><p>  <code>TraceClassVisitor</code> in diesem Fall den gesamten Bytecode der Klassen, die ihn durchlaufen haben, in die Konsole. Dies ist ein sehr praktisches Dienstprogramm in der Debugging-Phase. </p><br></li><li><p>  Wenn der Bytecode falsch ge√§ndert wird, treten sehr unverst√§ndliche Fehler auf. Wenn m√∂glich, lohnt es sich daher, potenziell gef√§hrliche Abschnitte des Codes zu protokollieren oder Ausnahmen zu generieren. </p><br></li></ul><br><h2 id="podytozhim">  Zusammenfassend </h2><br><p>  Die √Ñnderung des Quellcodes ist ein leistungsstarkes Werkzeug.  Damit k√∂nnen Sie viele Ideen umsetzen.  Proguard, Realm, Robolectric und andere Frameworks arbeiten nach diesem Prinzip.  AOP ist auch genau dank der Code-Transformation m√∂glich. <br>  Und die Kenntnis der Bytecode-Struktur erm√∂glicht es dem Entwickler zu verstehen, was der von ihm geschriebene Code am Ende kompiliert wird.  Und beim √Ñndern muss nicht √ºberlegt werden, in welcher Sprache der Code geschrieben ist, in Java oder in Kotlin, sondern der Bytecode direkt ge√§ndert werden. </p><br><p>  Dieses Thema erschien mir sehr interessant, die Hauptschwierigkeiten bestanden bei der Entwicklung der Transform-API von Google, da sie mit speziellen Dokumentationen und Beispielen nicht zufrieden sind.  ASM verf√ºgt im Gegensatz zur Transform-API √ºber eine hervorragende Dokumentation und eine sehr detaillierte Anleitung in Form einer PDF-Datei mit 150 Seiten.  Und da die Methoden des Frameworks den Anweisungen f√ºr echte Bytecodes sehr √§hnlich sind, ist das Handbuch doppelt n√ºtzlich. </p><br><p>  Ich denke, mein Eintauchen in Transformation, Bytecode, und das ist noch nicht alles, ich werde weiter studieren und vielleicht etwas anderes schreiben. </p><br><h2 id="ssylki">  Referenzen </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github Beispiel</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ASM</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Habr Artikel √ºber Bytecode</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein bisschen mehr √ºber Bytecode</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API transformieren</a> <br>  Lesen Sie die Dokumentation </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469237/">https://habr.com/ru/post/de469237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469223/index.html">LED-Hintergrundbeleuchtung als Hintert√ºr</a></li>
<li><a href="../de469229/index.html">Robotik-Club-Projekt ‚ÄûGoROBO‚Äú - ein Startup vom Beschleuniger der ITMO-Universit√§t schafft es</a></li>
<li><a href="../de469231/index.html">Game Design Vortragsabend</a></li>
<li><a href="../de469233/index.html">Die Habr Weekly # 20 / 2FA-Authentifizierung ist kein Allheilmittel. Android 10 Gehen Sie f√ºr den schw√§chsten jQuery-Story-Gates-Film</a></li>
<li><a href="../de469235/index.html">Troldesh in einer neuen Maske: die n√§chste Welle der Massenverteilung des Ransomware-Virus</a></li>
<li><a href="../de469245/index.html">Solstice entwickelt die Idee von Gruppenprojekten zur Gewinnung von Sonnenenergie aus Hausd√§chern</a></li>
<li><a href="../de469249/index.html">Nitter, ein alternatives Frontend f√ºr Twitter</a></li>
<li><a href="../de469253/index.html">Wie viel kostet die Erstellung einer App?</a></li>
<li><a href="../de469257/index.html">Wir integrieren Linux-Befehle mit PowerShell und WSL in Windows</a></li>
<li><a href="../de469259/index.html">Klimawandel: Wir analysieren die Temperatur in verschiedenen St√§dten in den letzten 100 Jahren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>