<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏿 📷 💆🏽 Analizando Async / Await en JavaScript con ejemplos 🧘🏽 🖕🏻 🖖🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El autor del artículo analiza Async / Await en JavaScript usando ejemplos. En general, Async / Await es una forma conveniente de escribir código asinc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analizando Async / Await en JavaScript con ejemplos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillbox/blog/458950/"><img src="https://habrastorage.org/getpro/habr/post_images/2c8/f4a/252/2c8f4a252d33ee663665fd7df02b45ed.jpg"><br><br>  El autor del artículo analiza Async / Await en JavaScript usando ejemplos.  En general, Async / Await es una forma conveniente de escribir código asincrónico.  Antes de esta oportunidad, se escribió un código similar utilizando devoluciones de llamada y promesas.  El autor del artículo original revela los beneficios de Async / Await al examinar varios ejemplos. <br><a name="habracut"></a><br><blockquote>  <b>Le recordamos:</b> <i>para todos los lectores de "Habr": un descuento de 10.000 rublos al registrarse en cualquier curso de Skillbox con el código de promoción "Habr".</i> <br><br>  <b>Skillbox recomienda:</b> El curso de educación en línea para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desarrolladores de Java</a> . </blockquote><br><h3>  Devolución de llamada </h3><br>  La devolución de llamada es una función cuya llamada se retrasa indefinidamente.  Anteriormente, las devoluciones de llamada se usaban en aquellas partes del código donde el resultado no se podía obtener de inmediato. <br><br>  Aquí hay un ejemplo de lectura asíncrona de un archivo en Node.js: <br><br><pre><code class="javascript hljs">fs.readFile(__filename, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>, (err, data) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); });</code> </pre> <br>  Los problemas surgen cuando necesita realizar varias operaciones asincrónicas a la vez.  Imaginemos este escenario: se realiza una solicitud a la base de datos de usuarios de Arfat, debe leer su campo profile_img_url y descargar una imagen del servidor someserver.com. <br>  Después de la descarga, convierta la imagen a otro formato, por ejemplo, de PNG a JPEG.  Si la conversión fue exitosa, se envía un correo electrónico al correo del usuario.  Además, la información sobre el evento se ingresa en el archivo transformations.log con la fecha. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad5/c3f/e3b/ad5c3fe3bf0f7a68a4d3444614c3133e.png"><br><br>  Vale la pena prestar atención a la imposición de devoluciones de llamada y un gran número}) en la parte final del código.  Esto se llama Callback Hell o Pyramid of Doom. <br><br>  Las desventajas de este método son obvias: <br><br><ul><li>  Este código es difícil de leer. </li><li>  También es difícil manejar los errores, lo que a menudo conduce a un deterioro en la calidad del código. </li></ul><br>  Para resolver este problema, se agregaron promesas a JavaScript.  Le permiten reemplazar la anidación profunda de las devoluciones de llamada con la palabra .then. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e1/503/0ad/9e15030ad0dbb431a63d9f98ec228111.png"><br><br>  El punto positivo de las promesas fue que con ellos el código se lee mucho mejor, de arriba a abajo, y no de izquierda a derecha.  Sin embargo, las promesas también tienen sus problemas: <br><br><ul><li>  Necesita agregar una gran cantidad de .then. </li><li>  En lugar de try / catch, .catch se usa para manejar todos los errores. </li><li>  Trabajar con varias promesas dentro de un ciclo dista mucho de ser siempre conveniente; en algunos casos, complican el código. </li></ul><br>  Aquí hay una tarea que muestra el significado del último elemento. <br><br>  Supongamos que hay un ciclo for que imprime una secuencia de números del 0 al 10 con un intervalo aleatorio (0 - n segundos).  Usando promesas, debe cambiar este ciclo para que los números se muestren en la secuencia de 0 a 10. Por lo tanto, si la salida cero tarda 6 segundos y las unidades tardan 2 segundos, primero debe salir cero, y luego comenzará la cuenta regresiva de salida de la unidad. <br><br>  Y, por supuesto, para resolver este problema, no utilizamos Async / Await o .sort.  Un ejemplo de una solución está al final. <br><br><h3>  Funciones asincrónicas </h3><br>  Agregar funciones asíncronas a ES2017 (ES8) ha simplificado la tarea de trabajar con promesas.  Observo que las funciones asíncronas funcionan por encima de las promesas.  Estas funciones no representan conceptos cualitativamente diferentes.  Las funciones asíncronas fueron concebidas como una alternativa al código que usa promesas. <br><br>  Async / Await permite organizar el trabajo con código asincrónico en un estilo sincrónico. <br><br>  Por lo tanto, el conocimiento de las promesas facilita la comprensión de los principios de Async / Await. <br><br>  <b>Sintaxis</b> <br><br>  En una situación típica, consta de dos palabras clave: asíncrono y esperar.  La primera palabra hace que la función sea asíncrona.  Estas funciones permiten esperar.  En cualquier otro caso, el uso de esta función causará un error. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// With function declaration async function myFn() { // await ... } // With arrow function const myFn = async () =&gt; { // await ... } function myFn() { // await fn(); (Syntax Error since no async) }</span></span></code> </pre><br>  Async se inserta al comienzo de la declaración de la función, y en el caso de la función de flecha, entre el signo "=" y los corchetes. <br><br>  Estas funciones pueden colocarse en un objeto como métodos o usarse en una declaración de clase. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// As an object's method const obj = { async getName() { return fetch('https://www.example.com'); } } // In a class class Obj { async getResource() { return fetch('https://www.example.com'); } }</span></span></code> </pre> <br>  NB!  Vale la pena recordar que los constructores de clases y getters / setters no pueden ser asíncronos. <br><br>  <b>Semántica y reglas de ejecución.</b> <br><br>  Las funciones asíncronas son básicamente similares a las funciones JS estándar, pero hay excepciones. <br><br>  Entonces, las funciones asíncronas siempre devuelven promesas: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'hello'</span></span>; } fn().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-comment"><span class="hljs-comment">// hello</span></span></code> </pre> <br>  En particular, fn devuelve la cadena hola.  Bueno, dado que esta es una función asincrónica, el valor de la cadena está envuelto en una promesa usando el constructor. <br><br>  Aquí hay un diseño alternativo sin Async: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>); } fn().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-comment"><span class="hljs-comment">// hello</span></span></code> </pre> <br>  En este caso, el retorno de la promesa se realiza "manualmente".  Una función asincrónica siempre se envuelve en una nueva promesa. <br><br>  En el caso de que el valor de retorno sea primitivo, la función asíncrona devuelve un valor, envolviéndolo en una promesa.  En el caso de que el valor de retorno sea el objeto de la promesa, su solución se devuelve en la nueva promesa. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) p <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>; <span class="hljs-comment"><span class="hljs-comment">// true Promise.resolve(p) === p; // true</span></span></code> </pre><br>  Pero, ¿qué sucede si se produce un error dentro de la función asincrónica? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>); } foo().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log);</code> </pre> <br>  Si no se procesa, foo () devolverá una promesa con un redject.  En esta situación, en lugar de Promise.resolve, Promise.reject regresará con un error. <br><br>  Las funciones asíncronas en la salida siempre dan promesas, independientemente de lo que se devuelva. <br><br>  Las funciones asincrónicas se pausan en cada espera. <br><br>  Esperar afecta las expresiones.  Entonces, si la expresión es una promesa, la función asíncrona se suspende hasta que se ejecute la promesa.  En el caso de que la expresión no sea una promesa, se convierte en una promesa a través de Promise.resolve y luego termina. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// utility function to cause delay // and get random value const delayAndGetRandom = (ms) =&gt; { return new Promise(resolve =&gt; setTimeout( () =&gt; { const val = Math.trunc(Math.random() * 100); resolve(val); }, ms )); }; async function fn() { const a = await 9; const b = await delayAndGetRandom(1000); const c = await 5; await delayAndGetRandom(1000); return a + b * c; } // Execute fn fn().then(console.log);</span></span></code> </pre> <br>  Aquí hay una descripción de cómo funciona la función fn. <br><br><ul><li>  Después de llamarlo, la primera línea se convierte de const a = waitit 9;  en const a = wait Promise.resolve (9);. </li><li>  Después de usar Await, la ejecución de la función se suspende hasta que recibe su valor (en la situación actual, es 9). </li><li>  delayAndGetRandom (1000) detiene la ejecución de la función fn hasta que finaliza (después de 1 segundo).  En realidad, esto detiene la función fn durante 1 segundo. </li><li>  delayAndGetRandom (1000) a través de resolver devuelve un valor aleatorio, que luego se asigna a la variable b. </li><li>  Bueno, el caso de la variable c es similar al caso de la variable a.  Después de eso, todo se detiene por un segundo, pero ahora delayAndGetRandom (1000) no devuelve nada, ya que esto no es obligatorio. </li><li>  Como resultado, los valores se calculan mediante la fórmula a + b * c.  El resultado está envuelto en una promesa usando Promise.resolve y devuelto por la función. </li></ul><br>  Estas pausas pueden parecerse a los generadores en ES6, pero hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">razones para esto</a> . <br><br><h3>  Resolvemos el problema </h3><br>  Bueno, ahora veamos la solución al problema que se mencionó anteriormente. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/ec5/c45/40bec5c4564dfabbe1810db3d4a60c2d.png"><br><br>  La función finishMyTask usa Aguardar para esperar los resultados de operaciones como queryDatabase, sendEmail, logTaskInFile y otros.  Si comparamos esta decisión con el lugar donde se usaron las promesas, las similitudes se harán evidentes.  Sin embargo, la versión con Async / Await simplifica enormemente todas las dificultades sintácticas.  En este caso, no hay muchas devoluciones de llamada y cadenas como .then / .catch. <br><br>  Aquí hay una solución con la salida de números, hay dos opciones. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i, ms</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(i), ms)); <span class="hljs-comment"><span class="hljs-comment">// Implementation One (Using for-loop) const printNumbers = () =&gt; new Promise((resolve) =&gt; { let pr = Promise.resolve(0); for (let i = 1; i &lt;= 10; i += 1) { pr = pr.then((val) =&gt; { console.log(val); return wait(i, Math.random() * 1000); }); } resolve(pr); }); // Implementation Two (Using Recursion) const printNumbersRecursive = () =&gt; { return Promise.resolve(0).then(function processNextPromise(i) { if (i === 10) { return undefined; } return wait(i, Math.random() * 1000).then((val) =&gt; { console.log(val); return processNextPromise(i + 1); }); }); };</span></span></code> </pre> <br>  Y aquí hay una solución que utiliza funciones asíncronas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printNumbersUsingAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> wait(i, <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); } }</code> </pre> <br>  <b>Manejo de errores</b> <br><br>  Los errores no procesados ​​se envuelven en promesas rechazadas.  Sin embargo, en las funciones asíncronas, puede usar la construcción try / catch para realizar el manejo de errores sincrónicos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canRejectOrReturn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// wait one second await new Promise(res =&gt; setTimeout(res, 1000)); // Reject with ~50% probability if (Math.random() &gt; 0.5) { throw new Error('Sorry, number too big.') } return 'perfect number'; }</span></span></code> </pre> <br>  canRejectOrReturn () es una función asincrónica que tiene éxito ("número perfecto") o falla con un error ("Lo siento, número demasiado grande"). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'error caught'</span></span>; } }</code> </pre> <br>  Como se espera que canRejectOrReturn se ejecute en el ejemplo anterior, su propia terminación fallida implicará la ejecución del bloque catch.  Como resultado, la función foo finalizará con indefinido (cuando no se devuelve nada en el bloque try) o con un error detectado.  Como resultado, esta función no fallará, ya que try / catch manejará la función foo en sí. <br><br>  Aquí hay otro ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'error caught'</span></span>; } }</code> </pre> <br>  Vale la pena prestar atención al hecho de que en el ejemplo de foo canRejectOrReturn se devuelve.  En este caso, Foo se completa con un número perfecto o devuelve un error de error ("Lo siento, el número es demasiado grande").  El bloque catch nunca se ejecutará. <br><br>  El problema es que foo devuelve la promesa pasada de canRejectOrReturn.  Por lo tanto, la solución a la función foo se convierte en la solución para canRejectOrReturn.  En este caso, el código constará de solo dos líneas: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = canRejectOrReturn(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promise; }</code> </pre> <br>  Pero, ¿qué sucede si usas esperar y volver juntos? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'error caught'</span></span>; } }</code> </pre> <br>  En el código anterior, foo tiene éxito con el número perfecto y el error detectado.  No habrá fallas.  Pero foo terminará con canRejectOrReturn, y no con undefined.  Asegurémonos de esto eliminando el retorno de la línea canRejectOrReturn (): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> canRejectOrReturn(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-comment"><span class="hljs-comment">// …</span></span></code> </pre> <br><h3>  Errores comunes y trampas </h3><br>  En algunos casos, el uso de Async / Await puede provocar errores. <br><br>  <b>Olvidado espera</b> <br><br>  Esto sucede con bastante frecuencia: antes de la promesa, se olvida la palabra clave esperar: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'caught'</span></span>; } }</code> </pre> <br>  En el código, como puede ver, no hay espera ni retorno.  Por lo tanto, foo siempre sale con indefinido sin un retraso de 1 segundo.  Pero la promesa se cumplirá.  Si da un error o un redject, se llamará a UnhandledPromiseRejectionWarning. <br><br>  <b>Funciones asíncronas en devoluciones de llamada</b> <br><br>  Las funciones asíncronas a menudo se usan en .map o .filter como devoluciones de llamada.  Un ejemplo es la función fetchPublicReposCount (nombre de usuario), que devuelve el número de repositorios abiertos en GitHub.  Digamos que hay tres usuarios cuyas métricas necesitamos.  Aquí está el código para esta tarea: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https://api.github.com/users'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Utility fn to fetch repo counts const fetchPublicReposCount = async (username) =&gt; { const response = await fetch(`${url}/${username}`); const json = await response.json(); return json['public_repos']; }</span></span></code> </pre> <br>  Necesitamos cuentas ArfatSalman, octocat, norvig.  En este caso, ejecute: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = [ <span class="hljs-string"><span class="hljs-string">'ArfatSalman'</span></span>, <span class="hljs-string"><span class="hljs-string">'octocat'</span></span>, <span class="hljs-string"><span class="hljs-string">'norvig'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counts = users.map(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> username =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchPublicReposCount(username); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; });</code> </pre> <br>  Debe prestar atención a Aguardar en la devolución de llamada .map.  Aquí cuenta una serie de promesas, bueno .map es una devolución de llamada anónima para cada usuario especificado. <br><br>  <b>Uso excesivamente consistente de esperar</b> <br><br>  Tome el siguiente código como ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchAllCounts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counts = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; users.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> username = users[i]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchPublicReposCount(username); counts.push(count); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counts; }</code> </pre> <br>  Aquí el número de conteo se coloca en la variable de conteo, luego este número se agrega a la matriz de conteos.  El problema con el código es que hasta que lleguen los primeros datos de usuario del servidor, todos los usuarios posteriores estarán en modo de espera.  Por lo tanto, en un solo momento, solo se procesa un usuario. <br><br>  Si, por ejemplo, se requieren aproximadamente 300 ms para procesar un usuario, entonces para todos los usuarios esto ya es un segundo, el tiempo empleado linealmente depende del número de usuarios.  Pero dado que obtener el número de repos no depende el uno del otro, los procesos pueden ser paralelos.  Esto requiere trabajar con .map y Promise.all: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchAllCounts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promises = users.map(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> username =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchPublicReposCount(username); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promises); }</code> </pre> <br>  Promise.all en la entrada recibe una serie de promesas con el regreso de la promesa.  El último después de completar todas las promesas en la matriz o en el primer redject se completa.  Puede suceder que no todos se inicien al mismo tiempo; para garantizar el lanzamiento simultáneo, puede usar p-map. <br><br><h3>  Conclusión </h3><br>  Las funciones asíncronas son cada vez más importantes para el desarrollo.  Bueno, para el uso adaptativo de las funciones asíncronas, vale la pena usar los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow noopener noreferrer">iteradores</a> asíncronos.  El desarrollador de JavaScript debería estar bien versado en esto. <br><br><blockquote>  <b>Skillbox recomienda:</b> <br><br><ul><li>  Curso práctico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Mobile Developer PRO"</a> . </li><li>  Curso en línea aplicado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Analista de datos en Python"</a> . </li><li>  Curso práctico de dos años <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Soy un desarrollador web PRO"</a> . </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458950/">https://habr.com/ru/post/458950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458936/index.html">"Es más fácil responder que guardar silencio": una gran entrevista con el padre de la memoria transaccional, Maurice Herlichi</a></li>
<li><a href="../458938/index.html">C ++ 20 está incluido, se inicia C ++ 23. Resultados de la reunión en Colonia</a></li>
<li><a href="../458940/index.html">Cómo implementamos las pruebas ágiles</a></li>
<li><a href="../458944/index.html">Contratar a un empleado comienza con ... respeto. Entrevistaremos al ingeniero.</a></li>
<li><a href="../458948/index.html">Habr Weekly # 8 / Yandex Sorcerers, un libro sobre Prince of Persia, YouTube contra hackers, el láser "corazón" del Pentágono</a></li>
<li><a href="../458952/index.html">Ajuste de la configuración de PostgreSQL para optimizar el rendimiento</a></li>
<li><a href="../458954/index.html">Qué tipos de detección son útiles en videovigilancia. Mecanismos y funciones.</a></li>
<li><a href="../458956/index.html">Aprendizaje automático vs. enfoque analítico</a></li>
<li><a href="../458960/index.html">Búsqueda corporativa</a></li>
<li><a href="../458962/index.html">Convierta la imagen en sonido, ¿qué puede escuchar?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>