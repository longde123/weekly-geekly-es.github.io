<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏼 🆙 👰🏼 toString：伟大而可怕 🕖 👩🏽‍🤝‍👨🏼 🤱🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JavaScript中的toString函数可能是js开发人员本身和外部观察者中讨论的最“隐式”的。 她是关于许多可疑算术运算的无数笑话和模因的原因，这些运算进入了stupor [object Object]的转换。 也许只有在使用float64时才感到惊讶。 


 我不得不观察，使用或克服的有趣...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>toString：伟大而可怕</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414495/"><p><img src="https://habrastorage.org/webt/on/px/4c/onpx4cu-vxqkdask5tvj3so9va4.jpeg" alt="图片"></p><br><p>  <strong>JavaScript中</strong>的<em>toString</em>函数可能是js开发人员本身和外部观察者中讨论的最“隐式”的。 她是关于许多可疑算术运算的无数笑话和模因的原因，这些运算进入了stupor <em>[object Object]</em>的转换。 也许只有在使用float64时才感到惊讶。 </p><br><p> 我不得不观察，使用或克服的有趣案例促使我写了一份真正的汇报。 我们将深入探讨语言规范，并使用示例分析<em>toString</em>的非显而易见功能。 </p><br><p>如果您希望获得有用且足够的指导，那么<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">this</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">this</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">that</a>材料更适合您。 如果您的好奇心仍然胜过实用主义，那么请谨慎行事。 </p><a name="habracut"></a><br><h3 id="vse-chto-nuzhno-znat"> 所有你需要知道的 </h3><br><p> 简单来说， <em>toString</em>函数是Object原型<em>对象</em>的属性，它是其方法。 它用于对象的字符串转换，并且应该以良好的方式返回原始值。 原型对象也有其实现： <em>Function，Array，String，Boolean，Number，Symbol，Date，RegExp，Error</em> 。 如果实现原型对象（类），则<em>toString</em>将是一个很好的形式。 </p><br><p>  <em>JavaScript</em>是一种类型系统较弱的语言：这意味着它使我们可以混合使用不同类型，并隐式执行许多操作。 在转换中， <em>toString</em>与<em>valueOf</em>配对以将对象简化为操作所需的原语。 例如，如果运算符之间至少有一行，则加法运算符将变为串联。 在工作之前，该语言的一些标准功能导致该字符串的参数： <em>parseInt，decodeURI，JSON.parse，btoa</em>等。 </p><br><p> 关于隐式转换，已经有很多说法和嘲笑了。 我们将考虑关键语言原型对象的<em>toString的</em>实现。 </p><br><h3 id="objectprototypetostring">  Object.prototype.toString </h3><br><p> 如果我们转到规范的相应<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">部分，</a>则会发现默认<em>toString</em>的主要任务是获取所谓的<strong>标签</strong>以连接到结果字符串： </p><br><pre><code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"[object "</span></span> + tag + <span class="hljs-string"><span class="hljs-string">"]"</span></span></code> </pre> <br><p> 为此： </p><br><ol><li> 可以访问内部的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>toStringTag</em></a>符号（或旧版本中的伪属性<em>[[Class]]</em> ）：它具有许多内置的原型对象（ <em>Map，Math，JSON</em>和其他）。 </li><li> 如果缺少或不是一个字符串，则列举许多其他表示对象类型的内部伪属性和方法： <em>[[Call]]</em>表示<em>功能</em> ， <em>[[DateValue]]</em>表示<em>日期，</em>依此类推。 </li><li> 好吧，如果什么都没有，那么<em>标记</em>是<em>“ Object”</em> 。 </li></ol><br><p> 那些受到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">反射</a>影响的人会立即注意到可以通过简单的操作来获得对象类型的可能性（规范不建议这样做，但有可能）： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getObjT = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.toString.call(obj).match(<span class="hljs-regexp"><span class="hljs-regexp">/\[object\s(\w+)]/</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>];</code> </pre> <br><p> 默认<em>toString</em>的特殊之处在于它可以与任何<em>this</em>值一起使用。 如果它是基元，则它将被强制转换为对象（分别检查<em>null</em>和<em>undefined</em> ）。 没有<em>TypeError</em> ： </p><br><pre> <code class="javascript hljs">[<span class="hljs-literal"><span class="hljs-literal">Infinity</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, x =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}].map(getObjT); &gt; [<span class="hljs-string"><span class="hljs-string">"Number"</span></span>, <span class="hljs-string"><span class="hljs-string">"Null"</span></span>, <span class="hljs-string"><span class="hljs-string">"Function"</span></span>, <span class="hljs-string"><span class="hljs-string">"Date"</span></span>, <span class="hljs-string"><span class="hljs-string">"GeneratorFunction"</span></span>]</code> </pre> <br><p> 这怎么派上用场？ 例如，在开发用于动态代码分析的工具时。 在应用程序的工作过程中使用了临时的变量池，您可以在运行时收集有用的同类统计信息。 </p><br><p> 这种方法有一个主要缺点：用户类型。 不难猜测，对于他们的实例，我们只会得到<em>“ Object”</em> 。 </p><br><h3 id="kastomnyy-symboltostringtag-i-functionname"> 自定义Symbol.toStringTag和Function.name </h3><br><p>  JavaScript中的OOP基于原型，而不是基于类（例如Java），并且我们没有现成的<em>getClass（）</em>方法。 为用户类型明确定义<em>toStringTag</em>字符将有助于解决问题： </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> </span></span>{ get [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Cat'</span></span>; } }</code> </pre> <br><p> 或以原型样式： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} Dog.prototype[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag] = <span class="hljs-string"><span class="hljs-string">'Dog'</span></span>;</code> </pre> <br><p> 还有一个替代解决方案，它是只读属性<em>Function.name</em> ，它不是规范的一部分，但大多数浏览器都支持。 原型对象/类的每个实例都有一个指向创建它的构造函数的链接。 这样我们就可以找到类型的名称： </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> </span></span>{} (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat).constructor.name &lt; <span class="hljs-string"><span class="hljs-string">'Cat'</span></span></code> </pre> <br><p> 或以原型样式： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog).constructor.name &lt; <span class="hljs-string"><span class="hljs-string">'Dog'</span></span></code> </pre> <br><p> 当然，该解决方案不适用于使用匿名函数（ <em>“ anonymous”</em> ）或<em>Object.create（null）</em>创建的对象，也不适用于没有包装对象的原语（ <em>null，undefined</em> ）。 </p><br><p> 因此，为了可靠地操作变量类型，值得结合主要基于手头任务的众所周知的技术。 在大多数情况下， <em>typeof</em>和<em>instanceof</em>足够了。 </p><br><h3 id="functionprototypetostring">  Function.prototype.toString </h3><br><p> 我们有些分心，但是结果是我们得到了具有自己有趣的<em>toString的</em>函数。 首先，看下面的代码： </p><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'('</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.callee.toString() + <span class="hljs-string"><span class="hljs-string">')()'</span></span>); })()</code> </pre> <br><p> 许多人可能猜测这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Quine的</a>一个例子。 如果将包含此类内容的脚本加载到页面的主体中，则源代码的精确副本将显示在控制台中。 这是由于<em>arguments.callee</em>函数调用了<em>toString</em>所致。 </p><br><p>  <em>Function</em>原型对象<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a> <em>toString</em>的使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实现</a>返回<em>函数</em>源代码的字符串表示形式，并保留其定义中使用的语法： <em>FunctionDeclaration，FunctionExpression，ClassDeclaration，ArrowFunction</em>等。 </p><br><p> 例如，我们有一个箭头功能： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bind = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, ctx</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.apply(ctx, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); }</code> </pre> <br><p> 调用<em>bind.toString（）</em>将返回一个<em>ArrowFunction</em>的字符串表示<em>形式</em> ： </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"(f, ctx) =&gt; function() { return f.apply(ctx, arguments); }"</span></span></code> </pre> <br><p> 从包装函数中调用<em>toString</em>已经是<em>FunctionExpression</em>的字符串表示形式： </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"function() { return f.apply(ctx, arguments); }"</span></span></code> </pre> <br><p> 这个<em>绑定</em>示例并非偶然，因为我们有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现成的解决方案，它</a>具有上下文绑定<em>Function.prototype.bind</em> ，对于本机<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">绑定函数，</a> <em>Function.prototype.toString</em>具有与之配合使用的<em>功能</em> 。 根据实现方式，可以获得包装函数本身和<em>目标</em>函数的表示。  V8和SpiderMonkey chrome和ff的最新版本： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getx</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } getx.bind({ <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }).toString() &lt; <span class="hljs-string"><span class="hljs-string">"function () { [native code] }"</span></span></code> </pre> <br><p> 因此，应谨慎使用本地装饰的功能。 </p><br><h3 id="praktika-ispolzovaniya-ftostring"> 练习使用f.toString </h3><br><p> 有关使用<em>toString的方法</em>有很多，但是仅作为元编程工具或调试时，它才是紧迫的。 具有类似业务逻辑的典型应用程序迟早会导致无法支持的断槽。 </p><br><p> 我想到的最简单的事情是<strong>确定函数的长度</strong> ： </p><br><pre> <code class="javascript hljs">f.toString().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/g</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).length</code> </pre> <br><p>  <em>toString</em>结果的空白字符的位置和数量由规范指定给特定的实现，因此，为了整洁起见，我们首先删除多余的部分，以形成一个整体视图。 顺便说一下，在旧版本的Gecko引擎中，该函数具有一个特殊的<em>缩进</em>参数，该参数有助于格式化缩进。 </p><br><p> 立即想到<strong>函数参数名称</strong>的<strong>定义</strong> ，可以很方便地进行反思： </p><br><pre> <code class="javascript hljs">f.toString().match(<span class="hljs-regexp"><span class="hljs-regexp">/^function(?:\s+\w+)?\s*\(([^\)]+)/m</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>].split(<span class="hljs-regexp"><span class="hljs-regexp">/\s*,\s*/</span></span>)</code> </pre> <br><p> 此膝盖解决方案适用于<em>FunctionDeclaration</em>和<em>FunctionExpression</em>语法。 如果需要更详细和准确的信息，建议您查找自己喜欢的框架的源代码示例，该框架可能根据声明的参数名称在内部进行某种依赖注入。 </p><br><p> 通过<em>eval</em> <strong>覆盖函数的</strong>危险而有趣的选择： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prod = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(sum.toString().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\+(?=\s*(?:a|b))/gm</span></span>, <span class="hljs-string"><span class="hljs-string">'*'</span></span>)); sum(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">15</span></span> prod(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">50</span></span></code> </pre> <br><p> 知道原始函数的结构后，我们通过用乘法参数替换其主体中使用的加法运算符来创建了一个新函数。 在软件生成的代码或缺少功能扩展接口的情况下，这可能会非常有用。 例如，如果要研究数学模型，则选择一个合适的函数，并运算符和系数。 </p><br><p> 更实际的用途是<strong>模板的编译和分发</strong> 。 许多模板引擎实现会编译模板的源代码，并提供已经形成最终HTML（或其他HTML）的数据功能。 以下是<a href="">_.template</a>函数的示例： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloJst = <span class="hljs-string"><span class="hljs-string">"Hello, &lt;%= user %&gt;"</span></span> _.template(helloJst)({ <span class="hljs-attr"><span class="hljs-attr">user</span></span>: <span class="hljs-string"><span class="hljs-string">'admin'</span></span> }) &lt; <span class="hljs-string"><span class="hljs-string">"Hello, admin"</span></span></code> </pre> <br><p> 但是，如果编译模板需要硬件资源或客户端非常薄怎么办？ 在这种情况下，我们可以在服务器端编译模板，并且不向客户端提供模板文本，而是为完成功能的字符串表示形式。 此外，您无需在客户端上加载模板库。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloStr = _.template(helloJst).toString() helloStr &lt; <span class="hljs-string"><span class="hljs-string">"function(obj) { obj || (obj = {}); var __t, __p = ''; with (obj) { __p += 'Hello, ' + ((__t = ( user )) == null ? '' : __t); } return __p }"</span></span></code> </pre> <br><p> 现在，我们需要在客户端上执行此代码，然后再使用。 由于<em>FunctionExpression</em>语法，在编译时没有<em>SyntaxError</em> ： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloFn = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(helloStr.replace(<span class="hljs-regexp"><span class="hljs-regexp">/^function\(obj\)/</span></span>, <span class="hljs-string"><span class="hljs-string">'obj=&gt;'</span></span>));</code> </pre> <br><p> 左右： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloFn = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">`const f = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${helloStr}</span></span></span><span class="hljs-string">;f`</span></span>);</code> </pre> <br><p> 或如您所愿。 无论如何： </p><br><pre> <code class="javascript hljs">helloFn({ <span class="hljs-attr"><span class="hljs-attr">user</span></span>: <span class="hljs-string"><span class="hljs-string">'admin'</span></span> }) &lt; <span class="hljs-string"><span class="hljs-string">"Hello, admin"</span></span></code> </pre> <br><p> 在服务器端编译模板并将其进一步分发给客户端时，这可能不是最佳实践。 只是使用一堆<em>Function.prototype.toString</em>和<em>eval</em>的示例。 </p><br><p> 最后，通过<em>toString</em> <strong>定义函数名称</strong>的旧任务（在<em>Function.name</em>属性出现之前）： </p><br><pre> <code class="javascript hljs">f.toString().match(<span class="hljs-regexp"><span class="hljs-regexp">/function\s+(\w+)(?=\s*\()/m</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><p> 当然，这可以与<em>FunctionDeclaration</em>语法配合使用。 一个更聪明的解决方案将需要巧妙的正则表达式或模式匹配。 </p><br><p> 只需问一下，Internet上就充满了基于<em>Function.prototype.toString</em>的有趣解决方案。 在评论中分享您的经验：非常有趣。 </p><br><h3 id="arrayprototypetostring">  Array.prototype.toString </h3><br><p>  <em>Array</em>原型对象<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a> <em>toString</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的实现</a>是通用的，可以为任何对象调用。 如果对象具有<em>join</em>方法，则<em>toString</em>的结果将是其调用，否则为<em>Object.prototype.toString</em> 。 </p><br><p> 从逻辑上讲， <em>Array</em>具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个join方法</a> ，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">方法</a>通过作为参数传递的<em>分隔符</em>将其所有元素的字符串表示形式连接起来（默认为逗号）。 </p><br><p> 假设我们需要编写一个序列化其参数列表的函数。 如果所有参数都是基元，那么在很多情况下我们都可以不使用<em>JSON.stringify</em> ： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seria</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>).toString(); }</code> </pre> <br><p> 左右： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> seria = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> a.toString();</code> </pre> <br><p> 只要记住字符串“ 10”和数字10会被序列化为相同。 在某一阶段<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最短的记忆程序</a>问题中，使用了此解决方案。 </p><br><p> 数组元素的本机连接通过从0到<em>长度</em>的算术循环工作，并且不会过滤缺少的元素（ <em>null</em>和<em>undefined</em> ）。 取而代之的是，发生<em>分隔符</em> 。 这导致以下结果： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">1000</span></span>); ar.toString() &lt; <span class="hljs-string"><span class="hljs-string">",,,...,,,"</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1000 times</span></span></code> </pre> <br><p> 因此，如果出于某种原因将具有较大索引的元素添加到数组（例如，这是生成的自然ID），则在任何情况下都不要加入，因此，如果没有进行初步准备，就不会导致字符串。 否则，可能会导致以下后果： <em>无效的字符串长度，内存不足</em>或只是悬空的脚本。 使用对象的功能<em>对象值</em>和<em>键仅</em>迭代其自身的对象枚举属性： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> k = []; k[<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; k[<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">20</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; k[<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">30</span></span>] = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(k).toString() &lt; <span class="hljs-string"><span class="hljs-string">"1,2,3"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(k).toString() &lt; <span class="hljs-string"><span class="hljs-string">"1024,1048576,1073741824"</span></span></code> </pre> <br><p> 但是最好避免对数组进行这种处理：最有可能的是，一个简单的键值对象将适合您作为存储对象。 </p><br><p> 顺便说一句，通过<em>JSON.stringify进行</em>序列化时存在相同的危险。 更严重的是，因为空的和不受支持的元素已经表示为<em>“ null”</em> ： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(ar); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">]" // </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">1000</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">times</span></span></span></span></span></span></code> </pre> <br><p> 最后，我想提醒您，您可以为用户类型定义<em>join</em>方法，并调用<em>Array.prototype.toString.call</em>作为字符串的替代<em>强制</em>转换，但是我怀疑它是否有实际用途。 </p><br><h3 id="numberprototypetostring-i-parseint">  Number.prototype.toString和parseInt </h3><br><p> 我最喜欢的JS测验任务之一是什么将返回下一个<em>parseInt</em>调用？ </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>**<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  <em>parseInt</em>做的第一件事是通过调用抽象函数<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>ToString</em></a>隐式地将参数转换为字符串，该函数根据参数的类型执行所需的转换分支。 对于类型<em>number</em> ，执行以下操作： </p><br><ol><li> 如果值为<em>NaN，0</em>或<em>Infinity</em> ，则返回相应的字符串。 </li><li> 否则，该算法将返回最方便的数字记录：十进制或指数形式。 </li></ol><br><p> 在这里，我将不重复<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用于</a>确定首选格式的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">算法，</a>仅注意以下几点：如果十进制表示形式的位数超过<strong>21</strong> ，则将选择指数格式。 这意味着在我们的情况下<em>parseInt</em>不适用于“ 100 ... 000”，而适用于“ 1e30”。 因此，答案根本不是2 ^ 30。 谁知道这个魔术数字21的性质-写下！ </p><br><p> 接下来， <em>parseInt</em>查看使用的<em>基数</em>系统的<em>基数</em> （默认为10，我们有2），并检查接收到的字符串的字符是否兼容。 遇到“ e”后，它会剪掉整条尾巴，仅留下“ 1”。 结果将是一个整数，该整数是通过将系统从带有基数的基数转换为十进制而获得的，在本例中为1。 </p><br><p> 逆向程序： </p><br><pre> <code class="javascript hljs">(<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">30</span></span>).toString(<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p> 这是从<em>Number</em>原型对象调用<em>toString</em>函数的地方，该对象使用相同的算法将<em>数字</em>转换为字符串。 它还具有可选的<em>基数</em>参数。 仅当它<em>parseInt</em>返回<em>NaN时</em> ，它才会为无效值（必须是2到36之间的整数）抛出<em>RangeError</em> 。 </p><br><p> 如果您计划实现一个奇异的散列函数，请记住数字系统的上限：这个<em>toString</em>可能对您不起作用。 </p><br><p> 分心的任务： </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'3113'</span></span>.split(<span class="hljs-string"><span class="hljs-string">''</span></span>).map(<span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>)</code> </pre> <br><p> 将返回什么以及如何解决？ </p><br><h3 id="obdelennoe-vnimaniem"> 失去关注 </h3><br><p> 我们绝不检查<em>toString</em>甚至所有本机原型对象。 在某种程度上，因为我个人不必麻烦他们，他们也没什么有趣的。 另外，我们没有碰到<em>toLocaleString</em>函数，因为单独讨论它会很不错。 如果我做了一些徒劳无益的事情，被忽视，看不见或被误解-请务必写信！ </p><br><h3 id="prizyv-k-bezdeystviyu"> 呼吁无所作为 </h3><br><p> 我列举的例子绝不是现成的菜谱，只是让人深思。 另外，我发现在技术采访中讨论这一点毫无意义，也有点愚蠢：为此，存在着关于闭包，联接，事件循环，模块/外观/中介者模式的永恒主题，以及关于[使用的框架]的“当然”问题。 </p><br><p> 这篇文章原来是大杂烩，希望您自己发现了一些有趣的东西。  PS JavaScript语言-太神奇了！ </p><br><h3 id="bonus"> 红利 </h3><br><p> 在准备发布该材料时，我使用了Google翻译。 偶然地，我发现了一种有趣的效果。 如果您选择俄语翻译成英语，请输入“ toString”并开始使用Backspace键删除它，那么我们将观察到： </p><br><p><img src="https://habrastorage.org/webt/op/yl/g3/opylg3burl5dlqv5ojibfeis0c4.gif" alt="红利"></p><br><p> 真讽刺！ 我想我距离第一个还差，但以防万一我给他们发送了带有播放脚本的屏幕截图。 看起来像无害的自我XSS，这就是为什么我要分享它。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN414495/">https://habr.com/ru/post/zh-CN414495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN414483/index.html">在Kotlin上输入Safe SQL</a></li>
<li><a href="../zh-CN414485/index.html">GNMT，史诗般的失败或机器翻译的微妙之处</a></li>
<li><a href="../zh-CN414487/index.html">暴力类型的罕见代表：一次攻击的历史</a></li>
<li><a href="../zh-CN414489/index.html">美国计划认真解决太空碎片问题</a></li>
<li><a href="../zh-CN414493/index.html">如何在5分钟内为ICO编写智能合约</a></li>
<li><a href="../zh-CN414497/index.html">Consulo UI API从构思到原型</a></li>
<li><a href="../zh-CN414499/index.html">《 2018年罗马俱乐部报告》，第1.1.3章：“空虚的世界与充分的和平”</a></li>
<li><a href="../zh-CN414501/index.html">《 2018年罗马俱乐部报告》，第3.11章：“金融部门改革”</a></li>
<li><a href="../zh-CN414503/index.html">带有AMD Vega Graphics的英特尔NUC Hades Canyon-VR还是不是VR？</a></li>
<li><a href="../zh-CN414505/index.html">麻省理工学院的课程“计算机系统安全”。 第2课：“控制黑客攻击”，第1部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>