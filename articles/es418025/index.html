<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÑπÔ∏è ‚óªÔ∏è üï≥Ô∏è El libro "Learning Java EE. Programaci√≥n moderna para grandes empresas ‚Äù ü•î üê• üë®‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola habr 

 Este libro describe la nueva generaci√≥n de Java EE. Se embarcar√° en un viaje a trav√©s de Java EE en el contexto del mundo moderno de micr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El libro "Learning Java EE. Programaci√≥n moderna para grandes empresas ‚Äù</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/418025/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ct/ac/t4/ctact4noq-x7eg0x5gqj_8kbm7g.jpeg" align="left" alt="imagen"></a>  Hola habr <br><br>  Este libro describe la nueva generaci√≥n de Java EE.  Se embarcar√° en un viaje a trav√©s de Java EE en el contexto del mundo moderno de microservicios y contenedores.  Esta no es una gu√≠a de referencia para la sintaxis de API: los conceptos y t√©cnicas presentados aqu√≠ reflejan la experiencia real de una persona que recientemente ha recorrido este camino, prestando mucha atenci√≥n a los obst√°culos que surgen y est√° listo para compartir su conocimiento.  En diversas situaciones, comenzando con la creaci√≥n de un paquete para pruebas y uso en la nube, este libro ser√° un compa√±ero ideal tanto para principiantes como para desarrolladores experimentados que buscan comprender m√°s que solo una API y ayudarlos a reconstruir sus mentes para crear una arquitectura de aplicaci√≥n moderna en Java EE . <br><a name="habracut"></a><br><h3>  Secuencia de ejecuci√≥n </h3><br>  Los procesos comerciales implementados en aplicaciones empresariales describen flujos de procesos espec√≠ficos.  Para los escenarios de negocios involucrados, este es un proceso de solicitud y respuesta s√≠ncrono, o el procesamiento as√≠ncrono de un proceso iniciado. <br><br>  Los escenarios empresariales se llaman en subprocesos separados, un subproceso por solicitud o llamada.  El contenedor crea las secuencias y las coloca en la unidad para su reutilizaci√≥n despu√©s de que la llamada se haya procesado correctamente.  Por defecto, los procesos empresariales definidos en las clases de aplicaci√≥n, as√≠ como las tareas transversales como las transacciones, se ejecutan secuencialmente. <br><br><h3>  Ejecuci√≥n sincr√≥nica </h3><br>  Un escenario t√≠pico cuando una solicitud HTTP requiere una respuesta de la base de datos se implementa de la siguiente manera.  Un subproceso procesa la solicitud que llega al bucle, por ejemplo, JAX-RS UsersResource, invirtiendo el principio de control;  El contenedor llama al m√©todo de recurso JAX-RS.  El recurso implementa y usa el UserManagement EJB, que tambi√©n es llamado impl√≠citamente por el contenedor.  Todas las operaciones son realizadas por intermediarios sincr√≥nicamente.  El usuario EJB utilizar√° el administrador de la entidad para almacenar la nueva entidad, y tan pronto como finalice el m√©todo comercial que inici√≥ la transacci√≥n actualmente activa, el contenedor intentar√° confirmar la transacci√≥n en la base de datos.  Dependiendo del resultado de la transacci√≥n, el m√©todo de recursos del circuito reanuda la operaci√≥n y genera una respuesta para el cliente.  Todo sucede sincr√≥nicamente, en este momento el cliente est√° bloqueado y esperando una respuesta. <br><br>  La ejecuci√≥n sincr√≥nica incluye el procesamiento de eventos CDI sincr√≥nicos.  Separan la activaci√≥n de eventos de dominio de su procesamiento, sin embargo, los eventos se procesan sincr√≥nicamente.  Existen varios m√©todos para monitorear las transacciones.  Si se indica una etapa de transacci√≥n, entonces el evento se puede procesar en esta etapa, durante la reparaci√≥n de la transacci√≥n, antes de su finalizaci√≥n, despu√©s de la finalizaci√≥n, en caso de transacci√≥n fallida o exitosa.  Por defecto, o si la transacci√≥n est√° inactiva, los eventos CDI se procesan inmediatamente cuando ocurren.  Esto permite a los ingenieros implementar soluciones complejas, por ejemplo, utilizando eventos que ocurren solo despu√©s de agregar entidades a la base de datos.  Sea como fuere, en todos los casos, el procesamiento se realiza sincr√≥nicamente. <br><br><h3>  Ejecuci√≥n asincr√≥nica </h3><br>  La ejecuci√≥n sincronizada de tareas satisface los requisitos de muchos escenarios comerciales, pero hay momentos en los que necesita un comportamiento asincr√≥nico.  Existen varias restricciones sobre el uso de subprocesos por el entorno Java EE.  El contenedor gestiona recursos y flujos y los coloca en la unidad.  Las utilidades de control de concurrencia externa se encuentran fuera del contenedor y no tienen conocimiento de estas transmisiones.  Por lo tanto, el c√≥digo de la aplicaci√≥n no debe ejecutarse y controlar sus hilos.  Para hacer esto, utiliza las caracter√≠sticas de Java EE.  Hay varias API con soporte as√≠ncrono incorporado. <br><br>  <b>M√©todos asincr√≥nicos de EJB</b> <br><br>  La forma m√°s f√°cil de implementar un comportamiento asincr√≥nico es utilizar la anotaci√≥n @Asynchronous para un m√©todo de negocios de clase EJB o EJB.  Las llamadas a estos m√©todos regresan de inmediato, a veces con una respuesta de tipo Futuro.  Se ejecutan en un hilo separado controlado por el contenedor.  Este m√©todo funciona bien para escenarios simples, pero est√° limitado a EJB: <br><br><pre><code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@Asynchronous</span></span> <span class="hljs-meta"><span class="hljs-meta">@Stateless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculatePi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> decimalPlaces)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      } }</span></span></code> </pre> <br>  <b>Servicio de gesti√≥n del rendimiento</b> <br><br>  Para la ejecuci√≥n asincr√≥nica de tareas en objetos CDI administrados o utilizando utilidades de control de concurrencia de Java SE, Java EE incluye versiones administradas por contenedor de las funciones ExecutorService y ScheduledExecutorService.  Se utilizan para implementar tareas asincr√≥nicas en subprocesos controlados por contenedores.  Las instancias ManagedExecutorService y ManagedScheduledExecutorService est√°n integradas en el c√≥digo de la aplicaci√≥n.  Se pueden usar para ejecutar su propia l√≥gica, pero son m√°s efectivos cuando se combinan con las utilidades de control de concurrencia de Java SE, como los valores futuros complementados.  El siguiente ejemplo muestra c√≥mo crear valores futuros rellenados utilizando subprocesos controlados por contenedor: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.annotation.Resource; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.enterprise.concurrent.ManagedExecutorService; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Random; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.CompletableFuture; <span class="hljs-meta"><span class="hljs-meta">@Stateless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService mes; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CompletableFuture&lt;Double&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateRandomPi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxDecimalPlaces)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CompletableFuture.supplyAsync(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random().nextInt(maxDecimalPlaces) + <span class="hljs-number"><span class="hljs-number">1</span></span>, mes) .thenApply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::calculatePi); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculatePi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> decimalPlaces)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } }</code> </pre> <br>  El objeto Calculadora devuelve el valor futuro complementado del tipo doble, que a√∫n se puede calcular cuando se reanuda el contexto de llamada.  Se puede solicitar cuando se completan los c√°lculos, as√≠ como combinarse con c√°lculos posteriores.  No importa d√≥nde se requieran nuevos subprocesos en la aplicaci√≥n empresarial, debe usar la funcionalidad Java EE para administrarlos. <br><br>  <b>Eventos CDI asincr√≥nicos</b> <br><br>  Los eventos CDI tambi√©n se pueden procesar de forma asincr√≥nica.  En este caso, el contenedor tambi√©n proporciona una secuencia para manejar eventos.  Para describir un controlador de eventos as√≠ncrono, el m√©todo se anota con @ObservesAsync, y el evento se activa usando el m√©todo fireAsync ().  Los siguientes fragmentos de c√≥digo demuestran eventos CDI as√≠ncronos: <br><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@Stateless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CarManufacturer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> CarFactory carFactory; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> Event&lt;CarCreated&gt; carCreated; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Car </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">manufactureCar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Specification spec)</span></span></span><span class="hljs-function"> </span></span>{ Car car = carFactory.createCar(spec); carCreated.fireAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CarCreated(spec)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> car; } }</code> </pre> <br>  El controlador de eventos se llama en su propio subproceso administrado por contenedor: <br><br><pre> <code class="hljs cs">import javax.enterprise.<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.ObservesAsync; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CreatedCarListener</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCarCreated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">@ObservesAsync CarCreated </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    } }</span></span></code> </pre> <br>  Por razones de compatibilidad con versiones anteriores, los eventos CDI sincr√≥nicos tambi√©n se pueden procesar en el m√©todo EJB as√≠ncrono.  Por lo tanto, los eventos y controladores se definen como s√≠ncronos, y el m√©todo de controlador es un m√©todo de negocio EJB con anotaci√≥n @Asynchronous.  Antes de que se introdujeran eventos asincr√≥nicos en el est√°ndar CDI para Java EE 8, esta era la √∫nica forma de implementar esta caracter√≠stica.  Para evitar confusiones en Java EE 8 y versiones posteriores, es mejor evitar esta implementaci√≥n. <br><br>  <b>√Åmbitos de procesamiento asincr√≥nico</b> <br><br>  Como el contenedor no tiene informaci√≥n sobre cu√°nto tiempo se pueden realizar tareas asincr√≥nicas, el uso de √°mbitos en este caso es limitado.  Los objetos con un alcance dentro de la solicitud o sesi√≥n que estaban disponibles cuando se lanz√≥ la tarea asincr√≥nica no estar√°n necesariamente activos durante su implementaci√≥n: la solicitud y la sesi√≥n pueden finalizar mucho antes de su finalizaci√≥n.  Por lo tanto, los subprocesos que realizan tareas asincr√≥nicas, como las proporcionadas por el servicio ejecutor programado o los eventos asincr√≥nicos, pueden no tener acceso a instancias de entidades administradas dentro del alcance de la solicitud o sesi√≥n que estuvieron activas durante la llamada.  Lo mismo ocurre con el acceso a enlaces a instancias incrustadas, por ejemplo, en m√©todos lambda que son parte de la ejecuci√≥n sincr√≥nica. <br><br>  Esto debe tenerse en cuenta al modelar tareas asincr√≥nicas.  Toda la informaci√≥n sobre una llamada en particular debe proporcionarse en el momento en que comienza la tarea.  Sin embargo, una tarea asincr√≥nica puede tener sus propias instancias de objetos administrados con un alcance limitado. <br><br>  <b>Establecer tiempo de ejecuci√≥n</b> <br><br>  Los escenarios empresariales pueden llamarse no solo desde el exterior, por ejemplo, a trav√©s de una solicitud HTTP, sino tambi√©n desde la aplicaci√≥n, una tarea que se ejecuta en un momento espec√≠fico. <br><br>  En el mundo de Unix, la funcionalidad para ejecutar trabajos peri√≥dicos es popular: estas son las tareas del planificador.  Los EJB proporcionan capacidades similares utilizando temporizadores EJB.  Los temporizadores invocan m√©todos comerciales a intervalos espec√≠ficos o despu√©s de un tiempo espec√≠fico.  El siguiente ejemplo describe un temporizador c√≠clico que comienza cada diez minutos: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.ejb.Schedule; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.ejb.Startup; <span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-meta"><span class="hljs-meta">@Startup</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PeriodicJob</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Schedule</span></span>(minute = <span class="hljs-string"><span class="hljs-string">"*/10"</span></span>, hour = <span class="hljs-string"><span class="hljs-string">"*"</span></span>, persistent = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executeJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   10  } }</span></span></code> </pre> <br>  Cualquier EJB (singletones, objetos gestionados con o sin persistencia de estado) puede crear temporizadores.  Sin embargo, en la mayor√≠a de los escenarios tiene sentido crear temporizadores solo para singleton.  El retraso se establece para todos los objetos activos.  Por lo general, es necesario iniciar las tareas programadas a tiempo, por lo que se usa en singleton.  Por el mismo motivo, en este ejemplo, el objeto EJB debe estar activo cuando se inicia la aplicaci√≥n.  Esto asegura que el temporizador comience a funcionar de inmediato. <br><br>  Si describe el temporizador como una constante, su vida √∫til se extiende a todo el ciclo de vida de la JVM.  El contenedor es responsable de almacenar temporizadores persistentes, generalmente en la base de datos.  Los temporizadores permanentes, que deber√≠an funcionar mientras la aplicaci√≥n no est√° disponible, se activan al inicio.  Tambi√©n le permite usar los mismos temporizadores con m√∫ltiples instancias del objeto.  Los temporizadores constantes con una configuraci√≥n de servidor adecuada son una soluci√≥n adecuada si necesita ejecutar un proceso comercial exactamente una vez en varios servidores. <br><br>  Los temporizadores que se crean autom√°ticamente mediante la anotaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Schedule</a> se describen mediante expresiones cron similares a Unix.  Para una mayor flexibilidad temporizadores programa EJB-describe utilizando el servicio proporcionado por el temporizador de contenedor que genera los Temporizadores m√©todos de devoluci√≥n de llamada y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">de tiempo de espera</a> . <br><br>  Las tareas peri√≥dicas y diferidas tambi√©n se pueden describir fuera de los EJB utilizando el servicio de planificador administrado por contenedor.  Una instancia de ManagedScheduledExecutorService que realiza tareas despu√©s del retraso especificado o en intervalos especificados se implementa en los componentes administrados.  Estas tareas se implementar√°n en subprocesos controlados por contenedores: <br><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@ApplicationScoped</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Periodic</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedScheduledExecutorService mses; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startAsyncJobs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mses.schedule(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::execute, <span class="hljs-number"><span class="hljs-number">10</span></span>, TimeUnit.SECONDS); mses.scheduleAtFixedRate(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::execute, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, TimeUnit.SECONDS); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } }</code> </pre> <br>  Llamar al m√©todo startAsyncJobs () ejecutar√° la funci√≥n execute () en el subproceso administrado diez segundos despu√©s de la llamada y luego cada diez segundos despu√©s del primer minuto. <br><br>  <b>Asincron√≠a y reactividad en JAX-RS</b> <br><br>  JAX-RS admite el comportamiento as√≠ncrono para no bloquear innecesariamente los flujos de solicitud del lado del servidor.  Incluso si una conexi√≥n HTTP est√° esperando una respuesta, la secuencia de solicitud puede continuar procesando otras solicitudes mientras se ejecuta un proceso prolongado en el servidor.  Los flujos de solicitud se agregan en un contenedor, y este repositorio de solicitud es de cierto tama√±o.  Para no desperdiciar la secuencia de solicitud, los m√©todos de recursos as√≠ncronos JAX-RS crean tareas que se ejecutan cuando la secuencia de solicitud regresa y se puede reutilizar.  La conexi√≥n HTTP se reanuda y da una respuesta despu√©s de completar la tarea asincr√≥nica o despu√©s de un tiempo de espera.  El siguiente ejemplo muestra el m√©todo de recurso as√≠ncrono JAX-RS: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Path(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"users"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-meta"><span class="hljs-meta">@Consumes(MediaType.APPLICATION_JSON)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UsersResource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService mes; ‚Ä¶ <span class="hljs-meta"><span class="hljs-meta">@POST</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CompletionStage&lt;Response&gt; createUserAsync(User user) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CompletableFuture.supplyAsync(() -&gt; createUser(user), mes); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Response createUser(User user) { userStore.create(user); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response.accepted().build(); } }</code> </pre> <br>  Para mantener el flujo de solicitudes ocupado durante demasiado tiempo, el m√©todo JAX-RS debe completarse r√°pidamente.  Esto se debe al hecho de que el m√©todo de recursos se llama desde el contenedor mediante inversi√≥n de control.  El resultado obtenido en la etapa de finalizaci√≥n se utilizar√° para reanudar la conexi√≥n del cliente al final del procesamiento. <br><br>  Las etapas de retorno de finalizaci√≥n son una tecnolog√≠a relativamente nueva en la API JAX-RS.  Si necesita describir el retraso y al mismo tiempo proporcionar una mayor flexibilidad con una respuesta asincr√≥nica, puede incluir el tipo AsyncResponse en el m√©todo.  Este enfoque se demuestra en el siguiente ejemplo: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">javax</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ws</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.rs</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.container</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.AsyncResponse</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">javax</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ws</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.rs</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.container</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Suspended</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">Path</span></span>("<span class="hljs-keyword"><span class="hljs-keyword">users</span></span>") @Consumes(MediaType.APPLICATION_JSON) public class UsersResource { @<span class="hljs-keyword"><span class="hljs-keyword">Resource</span></span> ManagedExecutorService mes; ‚Ä¶ @<span class="hljs-keyword"><span class="hljs-keyword">POST</span></span> public void createUserAsync(User user, @Suspended AsyncResponse response) { <span class="hljs-selector-tag"><span class="hljs-selector-tag">response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setTimeout</span></span>(5, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TimeUnit</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SECONDS</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setTimeoutHandler</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">r</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">r</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.resume</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.status</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Status</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SERVICE_UNAVAILABLE</span></span>)<span class="hljs-selector-class"><span class="hljs-selector-class">.build</span></span>())); <span class="hljs-selector-tag"><span class="hljs-selector-tag">mes</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.execute</span></span>(() <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.resume</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">createUser</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">user</span></span>))); } }</code> </pre> <br>  Gracias a los tiempos de espera creados, la solicitud del cliente no esperar√° indefinidamente, sino solo hasta que se reciba el resultado o caduque el tiempo de espera de la llamada.  Sin embargo, los c√°lculos continuar√°n a medida que se realicen de forma asincr√≥nica.  Para los recursos JAX-RS implementados como EJB, puede aplicar la anotaci√≥n @Asynchronous para que no llame expl√≠citamente a los m√©todos comerciales asincr√≥nicos a trav√©s del ejecutor de servicios. <br><br>  El cliente JAX-RS tambi√©n admite comportamiento as√≠ncrono.  Dependiendo de los requisitos, tiene sentido no bloquearlo durante las llamadas HTTP.  El ejemplo anterior muestra c√≥mo establecer demoras para las solicitudes de los clientes.  Para llamadas de sistema externo de larga duraci√≥n y especialmente paralelas, es mejor usar un comportamiento as√≠ncrono y reactivo. <br><br>  Considere varias aplicaciones de servidor que proporcionan informaci√≥n meteorol√≥gica.  El componente del cliente accede a todas estas aplicaciones y calcula el pron√≥stico del tiempo promedio.  Idealmente, podr√≠a hacer que el acceso a los sistemas sea paralelo: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.stream.Collectors; <span class="hljs-meta"><span class="hljs-meta">@ApplicationScoped</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WeatherForecast</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Client client; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;WebTarget&gt; targets; <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService mes; <span class="hljs-meta"><span class="hljs-meta">@PostConstruct</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ client = ClientBuilder.newClient(); targets = ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Forecast </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAverageForecast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invokeTargetsAsync() .stream() .map(CompletableFuture::join) .reduce(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::calculateAverage) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"   "</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;CompletableFuture&lt;Forecast&gt;&gt; invokeTargetsAsync() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> targets.stream() .map(t -&gt; CompletableFuture.supplyAsync(() -&gt; t .request(MediaType.APPLICATION_JSON_TYPE) .get(Forecast.class), mes)) .collect(Collectors.toList()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Forecast </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateAverage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Forecast first, Forecast second)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } <span class="hljs-meta"><span class="hljs-meta">@PreDestroy</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closeClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ client.close(); } }</code> </pre> <br>  El m√©todo invokeTargetsAsync () llama a los objetos disponibles de forma asincr√≥nica, invocando el servicio del ejecutor programado.  Los descriptores CompletableFuture se devuelven y se utilizan para calcular los resultados promediados.  El inicio del m√©todo join () se bloquear√° hasta que se complete la llamada y se reciban los resultados. <br><br>  Los objetos que se llaman as√≠ncronamente comienzan y esperan una respuesta de varios recursos a la vez, posiblemente m√°s lentamente.  En este caso, esperar las respuestas de los recursos del servicio meteorol√≥gico lleva tanto tiempo como esperar la respuesta m√°s lenta, y no todas las respuestas juntas. <br><br>  La √∫ltima versi√≥n de JAX-RS tiene soporte incorporado para las etapas de finalizaci√≥n, lo que reduce el c√≥digo estereotipado en las aplicaciones.  Al igual que con los valores rellenados, la llamada devuelve inmediatamente el c√≥digo de fase de finalizaci√≥n para referencia futura.  El siguiente ejemplo muestra las funciones de cliente reactivas JAX-RS utilizando la llamada rx (): <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-type"><span class="hljs-type">Forecast</span></span> getAverageForecast() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invokeTargetsAsync() .stream() .<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>((l, r) -&gt; l.thenCombine(r, this::calculateAverage)) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(s -&gt; s.toCompletableFuture().<span class="hljs-built_in"><span class="hljs-built_in">join</span></span>()) .orElseThrow(() -&gt; new <span class="hljs-type"><span class="hljs-type">IllegalStateException</span></span>(<span class="hljs-string"><span class="hljs-string">"   "</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CompletionStage</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Forecast</span></span>&gt;&gt; invokeTargetsAsync() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> targets.stream() .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(t -&gt; t .request(<span class="hljs-type"><span class="hljs-type">MediaType</span></span>.<span class="hljs-type"><span class="hljs-type">APPLICATION_JSON_TYPE</span></span>) .rx() .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-type"><span class="hljs-type">Forecast</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>)) .collect(<span class="hljs-type"><span class="hljs-type">Collectors</span></span>.toList()); }</code> </pre> <br>  En el ejemplo anterior, no necesita buscar el servicio de los ejecutores programados; el cliente JAX-RS lo administrar√° por s√≠ mismo.  Antes de que apareciera el m√©todo rx (), los clientes usaban una llamada async () expl√≠cita.  Este m√©todo se comport√≥ de manera similar, pero solo devolvi√≥ objetos futuros.  El uso de un enfoque reactivo en los clientes es √≥ptimo para la mayor√≠a de los proyectos. <br>  Como puede ver, Java EE utiliza un servicio de artista administrado por contenedor. <br><br><h3>  Conceptos y principios de dise√±o en Java EE moderno </h3><br>  La API Java EE se basa en convenciones y principios de dise√±o que se detallan como est√°ndares.  Los ingenieros de software encontrar√°n plantillas API conocidas y enfoques de desarrollo de aplicaciones en √©l.  El objetivo de Java EE es promover el uso consistente de la API. <br><br>  El principio principal de las aplicaciones centradas principalmente en la implementaci√≥n de escenarios empresariales es: la tecnolog√≠a no debe interferir.  Como ya se mencion√≥, los ingenieros deber√≠an poder concentrarse en implementar la l√≥gica empresarial sin pasar la mayor parte del tiempo en problemas tecnol√≥gicos y de infraestructura.  Idealmente, la l√≥gica de dominio se implementa en Java simple y se complementa con anotaciones y otras propiedades compatibles con el entorno corporativo, sin afectar el c√≥digo de dominio o complicarlo.  Esto significa que la tecnolog√≠a no requiere mucha atenci√≥n de los ingenieros y no impone restricciones demasiado grandes.  El entorno J2EE sol√≠a requerir muchas soluciones muy complejas.  Para implementar las interfaces y extender las clases base, tuvimos que usar objetos administrados y objetos de almacenamiento persistente.  Esto complic√≥ la l√≥gica del √°rea tem√°tica y dificult√≥ las pruebas. <br><br>  En Java EE, la l√≥gica de dominio se implementa en forma de clases Java simples equipadas con anotaciones, seg√∫n las cuales el contenedor resuelve ciertas tareas corporativas durante la ejecuci√≥n de la aplicaci√≥n.  La pr√°ctica de crear c√≥digo limpio a menudo implica escribir c√≥digo que sea m√°s hermoso que conveniente para su reutilizaci√≥n.  Java EE admite este enfoque.  Si por alguna raz√≥n necesita eliminar la tecnolog√≠a y dejar la l√≥gica pura del √°rea tem√°tica, esto se hace simplemente eliminando las anotaciones correspondientes. <br><br>  Como veremos en el Cap√≠tulo 7, este enfoque de programaci√≥n implica la necesidad de realizar pruebas, porque para los programadores, la mayor√≠a de las especificaciones Java EE no son m√°s que anotaciones. <br><br>  A lo largo de la API, se ha adoptado un principio de dise√±o llamado inversi√≥n de control (IoC); en otras palabras, "no nos llame, nos llamaremos a nosotros mismos".  Esto es especialmente notable en los circuitos de aplicaci√≥n, como los recursos JAX-RS.  Los m√©todos de recursos se describen utilizando anotaciones de m√©todos Java, que luego son llamados por el contenedor en el contexto apropiado.  Lo mismo es cierto para la inyecci√≥n de dependencia, en la que debe elegir generadores o tener en cuenta tareas transversales como los interceptores.  Los desarrolladores de aplicaciones pueden centrarse en implementar la l√≥gica y describir las relaciones, dejando la implementaci√≥n de detalles t√©cnicos en un contenedor.  Otro ejemplo, no tan obvio, es la descripci√≥n de convertir objetos Java a JSON y viceversa a trav√©s de anotaciones JSON-B.  Los objetos se transforman no solo en una forma expl√≠cita y programada, sino tambi√©n impl√≠citamente, en un estilo declarativo. <br><br>  Otro principio que permite a los ingenieros aplicar esta tecnolog√≠a de manera efectiva es la programaci√≥n por acuerdo.  Por defecto, Java EE define un comportamiento espec√≠fico que coincide con la mayor√≠a de los escenarios de uso.  Si no es suficiente o no cumple con los requisitos, el comportamiento puede redefinirse, a menudo en varios niveles. <br>  Hay muchos ejemplos de programaci√≥n de convenciones.  Uno de ellos es el uso de m√©todos de recursos JAX-RS que convierten la funcionalidad de Java en respuestas HTTP.  Si el comportamiento est√°ndar de JAX-RS con respecto a las respuestas no cumple los requisitos, puede aplicar el tipo de respuesta Respuesta.  Otro ejemplo es la especificaci√≥n de objetos gestionados, que generalmente se implementa mediante anotaciones.  Para cambiar este comportamiento, puede usar el descriptor XML beans.xml.  Es muy conveniente para los programadores que en el mundo moderno de Java EE, las aplicaciones empresariales se desarrollen de una manera pragm√°tica y de alto rendimiento que generalmente no requiere un uso intensivo de XML como antes. <br><br>  En cuanto a la productividad de los programadores, otro principio importante de desarrollo en Java EE es que esta plataforma requiere integraci√≥n en el contenedor de varios est√°ndares.  Debido a que los contenedores admiten un conjunto espec√≠fico de API, y si se admite toda la API Java EE, ese es exactamente el caso, tambi√©n requiere implementaciones de API para proporcionar una integraci√≥n perfecta de otras API.  La ventaja de este enfoque es la capacidad de usar recursos JAX-RS de conversi√≥n JSON-B y tecnolog√≠a de validaci√≥n de frijoles sin configuraci√≥n expl√≠cita adicional, con la excepci√≥n de las anotaciones.  En los ejemplos anteriores, vimos c√≥mo las funciones definidas en est√°ndares individuales se pueden usar juntas sin esfuerzo adicional.  Esta es una de las mayores ventajas de la plataforma Java EE.  Una especificaci√≥n gen√©rica garantiza una combinaci√≥n de est√°ndares individuales.  Los programadores pueden confiar en ciertas caracter√≠sticas e implementaci√≥n proporcionadas por el servidor de aplicaciones. <br><br><h3>  C√≥digo de alta calidad f√°cil de usar </h3><br>  Los programadores generalmente aceptan que debes esforzarte por escribir c√≥digo de alta calidad.  Sin embargo, no todas las tecnolog√≠as son igualmente adecuadas para esto. <br><br>  Como se mencion√≥ al principio del libro, el enfoque en el desarrollo de aplicaciones debe ser la l√≥gica empresarial.  En caso de cambios en la l√≥gica de negocios o la aparici√≥n de nuevos conocimientos, es necesario actualizar el modelo de dominio, as√≠ como el c√≥digo fuente.  Se requiere una refactorizaci√≥n iterativa para crear y mantener un modelo de dominio de alta calidad y un c√≥digo fuente en su conjunto.  Los esfuerzos para profundizar la comprensi√≥n del √°rea tem√°tica se describen en el concepto de dise√±o orientado a problemas. <br><br>  Hay mucha literatura sobre refactorizaci√≥n a nivel de c√≥digo.    -        ,          ,      .    ,   .    ,      . <br><br>   -           .  ,  ,    ‚Äî  , ,    -    .    ‚Äî    ,            ,    .        .      ,   ,         . <br><br>  ,        .    ,      . <br><br>     ,    ,  ,        .    ,   ,     -      .  ,      ,    ,       -  ,  .       ,      .       7. <br><br>       ,  .      ,    ,   ,    . Java EE     :  ,    ,   .     . <br><br>        .  ,        , ,         .             .   6  ,     . <br><br>          .        ,  ,    ,    .   ,              . ,  ,  .             ,    .         .   ,        .   -     . <br><br><h3>  Sobre el autor </h3><br> <b>  (Sebastian Daschner)</b> ‚Äî Java-,    ,    Java (EE).     JCP,     Java EE,   JSR   370  374         .        Java      Java  - Oracle. <br><br>       IT-,  JavaLand, JavaOne  Jfokus.    JavaOne Rockstar   JavaOne 2016.     Java   (Steve Chin)        Java,   .     JOnsen ‚Äî  Java,          . <br><br><h3>   </h3><br> <b>  (Melissa McKay)</b> ‚Äî     15-         ,    .       Java-,       .       ,       ,       . <br><br>     JCrete   ()         JOnsen  .      IT-  ,  JavaOne4Kids  JCrete4Kids.       JavaOne 2017     Denver Java User Group. <br><br>  ¬ªSe puede encontrar m√°s informaci√≥n sobre el libro en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sitio web del editor</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Contenidos</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Extracto</a> <br><br>    20%   ‚Äî <b>Java EE</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418025/">https://habr.com/ru/post/es418025/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418011/index.html">P√°ginas individuales y SEO. Secretos de optimizaci√≥n</a></li>
<li><a href="../es418013/index.html">El Intel Core i7-8086K (parte 3)</a></li>
<li><a href="../es418015/index.html">Nuevo Vasyuki. Desarrollo innovador de Mosc√∫ hasta 2100</a></li>
<li><a href="../es418017/index.html">An√°lisis del comportamiento del troyano Pegasus en la red.</a></li>
<li><a href="../es418023/index.html">Los punteros en C son m√°s abstractos de lo que piensas</a></li>
<li><a href="../es418027/index.html">Microservice Blitz</a></li>
<li><a href="../es418029/index.html">ReactOS 0.4.9: los que odian tendr√°n que buscar nuevos argumentos</a></li>
<li><a href="../es418031/index.html">Apilamiento masivo de modelos ML en producci√≥n: ¬øreal o no?</a></li>
<li><a href="../es418035/index.html">Presentando Timeline en Unity</a></li>
<li><a href="../es418037/index.html">Probador m√≥vil prep√°rate. Bienvenido al Avito Mobile Testing Meetup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>