<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎠 💴 🐍 我可以通过几种方式向Scheme写阶乘？ 🔙 🙄 🔽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="邪恶的语言声称功能性编程语言是“阶乘写作语言”。 这通常被定义为Haskell语言，但是我们将从对Haskell和许多其他语言的功能编程工具的子集（Scheme）产生重大影响的功能语言开始。 至少map和for-each ， filter和reduce以及apply和eval成为了我们最喜欢的编程语...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我可以通过几种方式向Scheme写阶乘？</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436698/"><p>邪恶的语言声称功能性编程语言是“阶乘写作语言”。 这通常被定义为Haskell语言，但是我们将从对Haskell和许多其他语言的功能编程工具的子集（Scheme）产生重大影响的功能语言开始。 至少<code>map</code>和<code>for-each</code> ， <code>filter</code>和<code>reduce</code>以及<code>apply</code>和<code>eval</code>成为了我们最喜欢的编程语言，如果不是来自Scheme的话，那么来自那里。 </p><br><p> 考虑<em>一些</em>写阶乘计算的可能方法。 同时，您可以对Scheme编程语言有所了解。 我认为这种美妙的语言值得。 </p><br><p> 我有10个编写函数定义的选项，可以将其简化为3种主要的计算方法：传统的线性递归计算过程，迭代，生成数字序列，然后进行卷积乘法。 我建议更详细地考虑这些选项。 在此过程中，我们将考虑：尾递归优化，高阶函数和元编程，递延计算，无限列表，备忘录，在Scheme中创建静态变量的方法以及卫生宏。 </p><a name="habracut"></a><br><p> 为了进行实验，我们使用了良好的旧方言Scheme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">R5RS</a>和流行的美术原则“最小的手段-最大的印象”。 </p><br><p> 所有Scheme实例都是在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DrRacket</a> 6.2中以R5RS模式准备的。 运行时测量是在OpenSUSE Leap 15 OS环境中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Guile</a> 2.0中进行的。 </p><br><p> 首先，您可以递归定义阶乘，然后简单地在Scheme上重写公式： </p><br><pre> <code class="plaintext hljs">(define (factorial-classic n) (if (zero? n) 1 (* n (factorial-classic (- n 1)))))</code> </pre> <br><p> 结果是定义了一个用于计算阶乘的函数的定义（就Scheme而言，是一个过程，尽管实际上它是一个函数），可以在无数的编程指南中看到，从H. Abelson和D. Sassman的不朽著作“计算机程序的结构和解释”开始。 </p><br><p> 您可以像这样阅读和理解此代码：factorial <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhgHO_cFZJToHv7gR2SkqK8Thy6ojw#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> n </script> 在那边 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mn" id="MJXp-Span-4">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhgHO_cFZJToHv7gR2SkqK8Thy6ojw#MJMAIN-31" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> 1 </script> 如果 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">n</span><span class="MJXp-mo" id="MJXp-Span-7" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-8">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.656ex" height="1.937ex" viewBox="0 -728.2 2435.1 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhgHO_cFZJToHv7gR2SkqK8Thy6ojw#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhgHO_cFZJToHv7gR2SkqK8Thy6ojw#MJMAIN-3D" x="878" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhgHO_cFZJToHv7gR2SkqK8Thy6ojw#MJMAIN-30" x="1934" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> n = 0 </script> 否则- <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">n</span><span class="MJXp-mtext" id="MJXp-Span-11">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-13">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-15">t</span><span class="MJXp-mrow" id="MJXp-Span-16"><span class="MJXp-mo" id="MJXp-Span-17" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18">n</span><span class="MJXp-mo" id="MJXp-Span-19" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-20">1</span><span class="MJXp-mrow" id="MJXp-Span-21"><span class="MJXp-mo" id="MJXp-Span-22" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span><span class="MJXp-mrow" id="MJXp-Span-23"><span class="MJXp-mo" id="MJXp-Span-24" style="margin-left: 0.278em; margin-right: 0.278em;">！</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="17.346ex" height="2.298ex" viewBox="0 -780.1 7468.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhgHO_cFZJToHv7gR2SkqK8Thy6ojw#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhgHO_cFZJToHv7gR2SkqK8Thy6ojw#MJMATHI-63" x="850" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhgHO_cFZJToHv7gR2SkqK8Thy6ojw#MJMATHI-64" x="1284" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhgHO_cFZJToHv7gR2SkqK8Thy6ojw#MJMATHI-6F" x="1807" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhgHO_cFZJToHv7gR2SkqK8Thy6ojw#MJMATHI-74" x="2293" y="0"></use><g transform="translate(2654,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhgHO_cFZJToHv7gR2SkqK8Thy6ojw#MJMATHI-6E" x="3484" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhgHO_cFZJToHv7gR2SkqK8Thy6ojw#MJMAIN-2212" x="4307" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhgHO_cFZJToHv7gR2SkqK8Thy6ojw#MJMAIN-31" x="5307" y="0"></use><g transform="translate(5808,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g><g transform="translate(6638,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">！</text></g></g></svg></span><script type="math/tex" id="MathJax-Element-4"> n \ cdot（n-1）！</script>  。 因此，此代码对应于数学中采用的阶乘的递归定义。 我们唯一不检查从属关系的东西 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-25"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-26">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhgHO_cFZJToHv7gR2SkqK8Thy6ojw#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> n </script> 非负数。 </p><br><p> 由于是递归的，因此上面的代码包含对值的明显限制 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-27"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhgHO_cFZJToHv7gR2SkqK8Thy6ojw#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> n </script>  ：递归调用数据将累积在堆栈上，直到 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-29"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhgHO_cFZJToHv7gR2SkqK8Thy6ojw#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> n </script> 不会达到0。这可能会导致堆栈溢出 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-31"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/436698/&amp;usg=ALkJrhgHO_cFZJToHv7gR2SkqK8Thy6ojw#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8"> n </script>  。 </p><br><p> 如何取消此限制？ 有必要优化尾部递归：重写代码，以使递归调用变为<em>尾部</em> （即过程中的最后一个）。 这将使Scheme解释器可以执行优化-用迭代计算代替递归计算。 </p><br><p> 如果您使用上本书作者的建议，则可以获得以下内容： </p><br><pre> <code class="plaintext hljs">(define (factorial-classic-tco n) (define (iteration product counter) (if (&gt; counter n) product (iteration (* product counter) (+ counter 1)))) (iteration 1 1))</code> </pre> <br><p> 该代码是一个常见示例，从“计算机程序的结构和解释”这本书开始，通常在其上解释尾递归的优化。 </p><br><p> 这是经典。 但是Scheme本身就是灵活性，是否可以用根本不同的方式编写相同的东西？ 最好甚至更短？ 例如，根据条目 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-33"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34">n</span><span class="MJXp-mrow" id="MJXp-Span-35"><span class="MJXp-mo" id="MJXp-Span-36" style="margin-left: 0.278em; margin-right: 0.278em;">！</span></span><span class="MJXp-mo" id="MJXp-Span-37" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-38">1</span><span class="MJXp-mtext" id="MJXp-Span-39">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-42">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">t</span><span class="MJXp-mn" id="MJXp-Span-44">2</span><span class="MJXp-mtext" id="MJXp-Span-45">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-48">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49">t</span><span class="MJXp-mn" id="MJXp-Span-50">3</span><span class="MJXp-mtext" id="MJXp-Span-51">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-53">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-55">t</span><span class="MJXp-mrow" id="MJXp-Span-56"><span class="MJXp-mo" id="MJXp-Span-57" style="margin-left: 0.278em; margin-right: 0.278em;">〜</span></span><span class="MJXp-mtext" id="MJXp-Span-58">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-60">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-63">s</span><span class="MJXp-mrow" id="MJXp-Span-64"><span class="MJXp-mo" id="MJXp-Span-65" style="margin-left: 0.278em; margin-right: 0.278em;">〜</span></span><span class="MJXp-mtext" id="MJXp-Span-66">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-68">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-69">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-71">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> n！ = 1 \ cdot 2 \ cdot 3 \ cdot〜\ cdots〜\ cdot n </script> 形成一个序列 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-72"><span class="MJXp-mn" id="MJXp-Span-73">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> 1 </script> 之前 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-74"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-75">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> n </script>  （或来自 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-76"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> n </script> 之前 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-78"><span class="MJXp-mn" id="MJXp-Span-79">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> 1 </script>  ），然后通过乘法将其折叠？ 幸运的是，在Scheme中，这非常简单，这要归功于内置的<code>apply</code>过程，该过程将具有任意数量参数的过程应用于列表： </p><br><pre> <code class="plaintext hljs">(define (iota n) (define (iteration sequence i) (if (&gt; in) sequence (iteration (cons i sequence) (+ i 1)))) (iteration '() 1)) (define (factorial-fold n) (apply * (iota n)))</code> </pre> <br><p> 由于“代码和数据的统一性”（正如他们有时所说的Lisp家族的语言一样），Scheme以其方便的符号计算而闻名。 我们使用此功能：我们形成一个表达式来计算数字的阶乘 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-80"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-81">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> n </script> 然后计算： </p><br><pre> <code class="plaintext hljs">(define (factorial-eval n) (define expression `(* ,@(iota n))) (eval expression (interaction-environment)))</code> </pre> <br><p> 符号“单引号”表示准引号。 无需准引用，可以使用代码<code>(cons '* (iota n))</code>获得用于进一步计算的表达式。 单引号（引号，引号）表示<code>*</code>必须完全按名称（符号）而不是对应值（此处为-过程）的形式替换为表达式。 因此， <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-82"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-83">n</span><span class="MJXp-mo" id="MJXp-Span-84" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-85">3</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> n = 3 </script> 我们得到<code>(* 3 2 1)</code> 。 此列表是Scheme中的一个表达式。 它的价值可以在一个合适的环境中执行，最重要的是-在一个包含内置程序和程序中我们定义的程序的环境<code>(interaction-environment)</code>中。 实际上，这就是我们在<code>factorial-eval</code>主体中所做的事情。 </p><br><p>  Scheme支持延迟计算。 受Scheme严重影响的Haskell使用了一种惰性计算模型，即 在声明这些计算的结果之前，不会计算表达式的值。 这允许程序具有无穷列表等特殊的数据结构。 如果仅从中获取进一步计算所需的部分，则程序将不会循环运行： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; take <span class="hljs-number"><span class="hljs-number">4</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span> ..] [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>]</code> </pre> <br><p> 表达式<code>[1 ..]</code>生成一个无限的整数列表。  <code>take 4</code>表达式从此列表中获取前4个元素。 由于后续列表项保持无人认领，因此不会计算它们。 </p><br><p> 在Haskell获得 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-86"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87">n</span><span class="MJXp-mrow" id="MJXp-Span-88"><span class="MJXp-mo" id="MJXp-Span-89" style="margin-left: 0.278em; margin-right: 0.278em;">！</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> n！</script> 从无尽的列表中，您可以这样写： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">factorials</span></span> :: [<span class="hljs-type"><span class="hljs-type">Integer</span></span>] factorials = next <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> next n fact = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n' = n + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fact : next n' (fact * n') factorial :: <span class="hljs-type"><span class="hljs-type">Integer</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Integer</span></span> factorial n = factorials !! fromIntegral n</code> </pre> <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; take <span class="hljs-number"><span class="hljs-number">7</span></span> $ factorials [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">24</span></span>,<span class="hljs-number"><span class="hljs-number">120</span></span>,<span class="hljs-number"><span class="hljs-number">720</span></span>] ghci&gt; factorial <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">720</span></span></code> </pre> <br><p> 使用几种形式的Scheme <code>delay</code> / <code>force</code>让我们尝试做类似的事情。  <code>delay</code>关键字创建了一个对表达式值进行评估的承诺。  <code>force</code>关键字指示执行这些计算，然后计算并存储结果值。 重复访问时，不会执行新的计算，但是会返回先前计算的值。 </p><br><p> 在Lisp家族的语言中，列表是成对构造的。 为了构造无限列表，我们引入了“惰性对”的类型-一对，其中第一个元素是计算值，第二个是计算值的承诺。 为此，我们需要用懒惰的版本来补充Lisp家族语言（ <code>cons</code> ， <code>car</code> ， <code>cdr</code> ）的“神圣三位一体”： </p><br><pre> <code class="plaintext hljs">(define-syntax lazy-cons (syntax-rules () ((_ first second) (cons first (delay second))))) (define lazy-car car) (define (lazy-cdr lazy-pair) (force (cdr lazy-pair)))</code> </pre> <br><p>  lazy <code>lazy-cons</code>对的构造函数被实现为宏。 这样做是为了避免在创建该对的第二个元素时计算其值。 </p><br><p> 这个想法是创建一个无休止的值列表，然后从中获取所需的内容。 为此，请定义通过索引获取元素的过程的惰性版本： </p><br><pre> <code class="plaintext hljs">(define (lazy-list-ref lazy-list index) (if (zero? index) (lazy-car lazy-list) (lazy-list-ref (lazy-cdr lazy-list) (- index 1)))) (define (generate-factorials) (define (next nn!) (define n+1 (+ n 1)) (lazy-cons n! (next n+1 (* n! n+1)))) (next 0 1))</code> </pre> <br><p> 这里<code>n!</code>  <code>n+1</code>是变量的名称。 在Scheme中，与其他语言相比，很少有不能在标识符中使用的字符。 </p><br><p> 请注意，无限列表生成器<code>generate-factorials</code>不包含递归方法。 但是，它不会循环，因为调用它时，只会计算列表的开头，而尾部将由一个计算值的承诺表示。 </p><br><p> 现在您可以定义 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-90"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-91">n</span><span class="MJXp-mrow" id="MJXp-Span-92"><span class="MJXp-mo" id="MJXp-Span-93" style="margin-left: 0.278em; margin-right: 0.278em;">！</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> n！</script> 如何获得 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-94"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-95">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> n </script> 析因表的第th个元素： </p><br><pre> <code class="plaintext hljs">(define lazy-factorials (generate-factorials)) (define (factorial-lazy n) (lazy-list-ref lazy-factorials n))</code> </pre> <br><p> 可以用 此外，如果在解释程序的一个会话中计算了不同数量的阶乘，则计算将比严格版本中的计算更快，因为惰性列表中的某些值已经被计算出来。 </p><br><p> 顺便说一下，Scheme上的代码与Haskell上的代码非常接近。 因此，接收声明<code>!!</code> 大约对应于<code>lazy-list-ref</code>过程<code>lazy-list-ref</code>构造函数<code>:</code>对应于<code>lazy-cons</code> 。 相应地，因为Haskell尽管声称自己是一个惰性计算模型，但是与Scheme中的<code>delay</code> / <code>force</code>不同，它不记得计算出的值。 </p><br><p> 顺便说一句，为了提高生产率，您可以应用已经计算出的值的存储-存储。 我们将把计算出的值存储在一个关联列表中，其中键是数字，而值是它们的阶乘。 调用时，我们将在列表中查找已经计算出的值。 如果该值在列表中，我们将返回此存储的值。 如果该值不在列表中，我们将对其进行计算，将其放入列表中，然后才返回。 为了确保此列表始终与被调用函数一起使用，而不是在全局环境中，我们将其放置在静态变量中： </p><br><pre> <code class="plaintext hljs">(define factorial-memoized (let ((memo '())) (lambda (n) (let ((memoized (assq n memo))) (if memoized (cadr memoized) (if (zero? n) 1 (let ((computed (* n (factorial-memoized (- n 1))))) (set! memo (cons (list n computed) memo)) computed)))))))</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">方案中的静态变量</b> <div class="spoiler_text"><p> 查看代码 </p><br><pre> <code class="plaintext hljs">(define proc (let ((static-var initial-value)) (lambda args ...)))</code> </pre> <br><p> 是方案接受的使用静态变量创建过程的方式。 可以通过一个简短的示例方便地解释这种通知的原理-一个返回呼叫数量的过程： </p><br><pre> <code class="plaintext hljs">(define count (let ((n 0)) (lambda () (set! n (+ n 1)) n)))</code> </pre> <br><p> 在一个解释器会话中，第一个呼叫<code>(count)</code>将返回1，第二个-2，第三个-3，依此类推。 如何运作？ </p><br><p> 没有语法糖， <code>count</code>的定义如下所示： </p><br><pre> <code class="plaintext hljs">(define count ((lambda (n) (lambda () (set! n (+ n 1)) n)) 0))</code> </pre> <br><p> 因此，自由包含<code>n</code>不带参数<code>(lambda () (set! n (+ n 1)) n)</code>与名称<code>count</code>相关联。 事实证明， <code>n</code>在<code>(lambda () (set! n (+ n 1)) n)</code>的外部环境中定义的，这意味着<code>n</code>的值将在<code>count</code>调用之间保留。 程序启动时，由于将<code>(lambda (n) ...)</code>应用于参数0，因此将值<code>n</code>初始化为零<code>(lambda (n) ...)</code>因此，在全局环境中不存在<code>n</code> ，但始终可以从<code>count</code>访问。 </p></div></div><br><p> 通过在一个解释器会话中重复计算各种数字的阶乘，该实现还有望提高性能。 </p><br><p> 当然，尾递归优化也可以在这里进行： </p><br><pre> <code class="plaintext hljs">(define factorial-memoized-tco (let ((memo '())) (lambda (n) (define (iteration product counter) (cond ((&gt; counter n) product) (else (set! memo (cons (list counter product) memo)) (iteration (* product counter) (+ counter 1))))) (iteration 1 1))))</code> </pre> <br><p> 读者可能会说：“为什么这些舞蹈要用铃鼓呢？” 在命令式编程语言中，可以简单地编写相同的东西-通过循环，它可以快速运行并且没有不必要的内存开销。  Scheme具有用于命令式编程的子集，还具有用于组织循环的一种方法-do的一种<em>特殊形式</em> 。 在其帮助下编写的阶乘的计算过程可能如下所示： </p><br><pre> <code class="plaintext hljs">(define (factorial-do n) (define product 1) (do ((i 1 (+ i 1))) ((&gt; in) product) (set! product (* product i))))</code> </pre> <br><p>  <code>do</code>构造相当通用，这就是为什么它不太可读的原因。 以命令式的方式组织自己的周期不是更好吗？ 宏将帮助您： </p><br><pre> <code class="plaintext hljs">(define-syntax for (syntax-rules () ((_ (variable init test step) . body) (let loop ((variable init)) (if test (begin (begin . body) (loop step)))))))</code> </pre><br><p> 由于解释器优化了尾递归，我们得到了一个在命令式编程语言中习惯的循环。 通过优化尾递归，堆栈将不会增长。 </p><br><p> 为以下项定义阶乘： </p><br><pre> <code class="plaintext hljs">(define (factorial-for n) (define product 1) (for (i 1 (&lt;= in) (+ i 1)) (set! product (* product i))) product)</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">如何运作</b> <div class="spoiler_text"><p> 在此示例中，表达式<code>(for (i 1 (&lt;= in) (+ i 1)) (set! product (* product i)))</code>将与语法规则的模式<code>(_ (variable init test step) . body)</code>匹配。 将执行以下替换： </p><br><pre> <code class="plaintext hljs">for → _ i → variable 1 → init (&lt;= in) → test (+ i 1) → step (set! product (* product i)) → body</code> </pre> <br><p> 从这里，语法规则模板将生成以下代码： </p><br><pre> <code class="plaintext hljs">(define (factorial-for n) (define product 1) (let loop ((i 1)) ;   (if (&lt;= in) ;  (begin (begin (set! product (* product i))) ;  (loop (+ i 1))))) ;  for product)</code> </pre> </div></div><br><p> 还有另一个看起来与命令式<code>for</code>循环类似的选项-带有内置的<code>for-each</code>过程： </p><br><pre> <code class="plaintext hljs">(define (factorial-for-each n) (define product 1) (for-each (lambda (i) (set! product (* product i))) (iota n)) product)</code> </pre> <br><p> 强大的Scheme语言！ 性能如何？ </p><br><p> 我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GNU Guile</a>来衡量性能-在这种环境下，您可以最简单地衡量评估表达式所需的时间。 </p><br><p>  Guile的工作方式如下：将程序的源代码编译为字节码，然后由虚拟机执行。 这只是运行Scheme程序的一种实现，也是几种可能的方式之一，还有其他一些： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Racket</a> （使用JIT编译）， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Chicken Scheme</a> （使用“诚实的”解释或编译为C的子集）等。 显然，这些环境中程序的局限性和性能可能会略有不同。 </p><br><p> 我们将以一定值进行测量 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-96"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> n </script>  。 应该是什么 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-98"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> n </script>  ？ 因此，最大的 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-100"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-101">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> n </script> 将能够“应付”建议的选项。 使用默认的Guile 2.0设置，在具有Intel Core i5和4 GB RAM的PC上，我得到以下信息： </p><br><table><thead><tr><th> 程序 </th><th> 问题 </th></tr></thead><tbody><tr><td> <code>factorial-classic</code> </td> <td> 堆栈溢出 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-102"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-103">n</span><span class="MJXp-mo" id="MJXp-Span-104" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-105">10</span><span class="MJXp-mtext" id="MJXp-Span-106" style="color: red;">\，</span><span class="MJXp-mn" id="MJXp-Span-107">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> n> 10 \，000 </script></td></tr><tr><td> <code>factorial-classic-tco</code> </td> <td> 不（ <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-108"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-109">n</span><span class="MJXp-mo" id="MJXp-Span-110" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-111">100</span><span class="MJXp-mtext" id="MJXp-Span-112" style="color: red;">\，</span><span class="MJXp-mn" id="MJXp-Span-113">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-23-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-23"> n = 100 \，000 </script>  ） </td></tr><tr><td> <code>factorial-fold</code> </td> <td> 堆栈溢出 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-114"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-115">n</span><span class="MJXp-mo" id="MJXp-Span-116" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-117">10</span><span class="MJXp-mtext" id="MJXp-Span-118" style="color: red;">\，</span><span class="MJXp-mn" id="MJXp-Span-119">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-24"> n> 10 \，000 </script></td></tr><tr><td> <code>factorial-eval</code> </td> <td> 堆栈溢出 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-120"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-121">n</span><span class="MJXp-mo" id="MJXp-Span-122" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-123">8</span><span class="MJXp-mtext" id="MJXp-Span-124" style="color: red;">\，</span><span class="MJXp-mn" id="MJXp-Span-125">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-25-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-25"> n> 8 \，000 </script></td></tr><tr><td> <code>factorial-lazy</code> </td> <td> 在 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-126"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-127">n</span><span class="MJXp-mo" id="MJXp-Span-128" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-129">100</span><span class="MJXp-mtext" id="MJXp-Span-130" style="color: red;">\，</span><span class="MJXp-mn" id="MJXp-Span-131">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-26-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-26"> n = 100 \，000 </script> 使用交换分区并冻结 </td></tr><tr><td> <code>factorial-memoized</code> </td> <td> 堆栈溢出 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-132"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-133">n</span><span class="MJXp-mo" id="MJXp-Span-134" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-135">10000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-27"> n> 10000 </script> 仅在首次启动时 </td></tr><tr><td> <code>factorial-memoized-tco</code> </td> <td> 在 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-136"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-137">n</span><span class="MJXp-mo" id="MJXp-Span-138" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-139">1</span><span class="MJXp-mtext" id="MJXp-Span-140" style="color: red;">\，</span><span class="MJXp-mn" id="MJXp-Span-141">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-28"> n> 1 \，000 </script> 使用交换分区并冻结 </td></tr><tr><td> <code>factorial-do</code> </td> <td> 不（ <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-142"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-143">n</span><span class="MJXp-mo" id="MJXp-Span-144" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-145">100</span><span class="MJXp-mtext" id="MJXp-Span-146" style="color: red;">\，</span><span class="MJXp-mn" id="MJXp-Span-147">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-29-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-29"> n = 100 \，000 </script>  ） </td></tr><tr><td> <code>factorial-for</code> </td> <td> 不（ <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-148"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-149">n</span><span class="MJXp-mo" id="MJXp-Span-150" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-151">100</span><span class="MJXp-mtext" id="MJXp-Span-152" style="color: red;">\，</span><span class="MJXp-mn" id="MJXp-Span-153">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-30-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-30"> n = 100 \，000 </script>  ） </td></tr><tr><td> <code>factorial-for-each</code> </td> <td> 不（ <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-154"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-155">n</span><span class="MJXp-mo" id="MJXp-Span-156" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-157">100</span><span class="MJXp-mtext" id="MJXp-Span-158" style="color: red;">\，</span><span class="MJXp-mn" id="MJXp-Span-159">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-31-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-31"> n = 100 \，000 </script>  ） </td></tr></tbody></table><br><p> 从这里开始，在 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-160"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-161">n</span><span class="MJXp-mo" id="MJXp-Span-162" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-163">8</span><span class="MJXp-mtext" id="MJXp-Span-164" style="color: red;">\，</span><span class="MJXp-mn" id="MJXp-Span-165">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-32-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-32"> n = 8 \，000 </script>  。 结果显示在下表中，其中 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-166"><span class="MJXp-msubsup" id="MJXp-Span-167"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-168" style="margin-right: 0.05em;">t</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-169" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-170">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-171">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-172">n</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-33-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-33"> t_ {run} </script>  -交货时间 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-173"><span class="MJXp-msubsup" id="MJXp-Span-174"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-175" style="margin-right: 0.05em;">t</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-176" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-177">G</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-178">C</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-34-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-34"> t_ {GC} </script>  -垃圾收集器的运行时间以秒为单位。 <br> 对于所有过程，除了延迟和记忆化过程外，从三个开始的结果中获得运行时的最小值和垃圾收集器的相应时间。 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-179"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-180">n</span><span class="MJXp-mo" id="MJXp-Span-181" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-182">8</span><span class="MJXp-mtext" id="MJXp-Span-183" style="color: red;">\，</span><span class="MJXp-mn" id="MJXp-Span-184">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-35-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-35"> n = 8 \，000 </script>  。 <br> 对于记忆过程和惰性过程，将指示第一个调用的执行时间，然后指示三个调用中的较小者。 </p><br><table><thead><tr><th> 程序 </th><th><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-185"><span class="MJXp-msubsup" id="MJXp-Span-186"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-187" style="margin-right: 0.05em;">t</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-188" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-189">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-190">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-191">n</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-36-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-36"> t_ {run} </script> 与 </th><th><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-192"><span class="MJXp-msubsup" id="MJXp-Span-193"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-194" style="margin-right: 0.05em;">t</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-195" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-196">G</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-197">C</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-37-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-37"> t_ {GC} </script> 与 </th><th> 注意事项 </th></tr></thead><tbody><tr><td> <code>factorial-classic</code> </td> <td>  0.051 </td><td>  0,034 </td><td></td></tr><tr><td> <code>factorial-classic-tco</code> </td> <td>  0,055 </td><td>  0,041 </td><td></td></tr><tr><td> <code>factorial-fold</code> </td> <td>  0,065 </td><td>  0.059 </td><td></td></tr><tr><td> <code>factorial-eval</code> </td> <td>  0,070 </td><td>  0,040 </td><td></td></tr><tr><td> <code>factorial-lazy</code> </td> <td>  0,076 </td><td>  0,036 </td><td> 第一次打电话 </td></tr><tr><td> <code>factorial-lazy</code> </td> <td>  0.009 </td><td>  -- </td><td> 后续通话 </td></tr><tr><td> <code>factorial-memoized</code> </td> <td>  0,077 </td><td>  0,041 </td><td> 第一次打电话 </td></tr><tr><td> <code>factorial-memoized</code> </td> <td>  0.002 </td><td>  -- </td><td> 后续通话 </td></tr><tr><td> <code>factorial-memoized-tco</code> </td> <td>  0,077 </td><td>  0,041 </td><td> 第一次打电话 </td></tr><tr><td> <code>factorial-memoized-tco</code> </td> <td>  0.002 </td><td>  -- </td><td> 后续通话 </td></tr><tr><td> <code>factorial-do</code> </td> <td>  0,052 </td><td>  0,025 </td><td></td></tr><tr><td> <code>factorial-for</code> </td> <td>  0.059 </td><td>  0,044 </td><td></td></tr><tr><td> <code>factorial-for-each</code> </td> <td>  0,066 </td><td>  0,042 </td><td></td></tr></tbody></table><br><p> 我们有4个可以与大型 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-198"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-199">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-38-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-38"> n </script>  。 在 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-200"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-201">n</span><span class="MJXp-mo" id="MJXp-Span-202" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-203">100</span><span class="MJXp-mtext" id="MJXp-Span-204" style="color: red;">\，</span><span class="MJXp-mn" id="MJXp-Span-205">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-39-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-39"> n = 100 \，000 </script> 它们具有以下计算和垃圾回收时间： </p><br><table><thead><tr><th> 程序 </th><th><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-206"><span class="MJXp-msubsup" id="MJXp-Span-207"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-208" style="margin-right: 0.05em;">t</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-209" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-210">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-211">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-212">n</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-40-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-40"> t_ {run} </script> 与 </th><th><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-213"><span class="MJXp-msubsup" id="MJXp-Span-214"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-215" style="margin-right: 0.05em;">t</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-216" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-217">G</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-218">C</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-41-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-41"> t_ {GC} </script> 与 </th></tr></thead><tbody><tr><td> <code>factorial-classic-tco</code> </td> <td>  8,468 </td><td>  6,628 </td></tr><tr><td> <code>factorial-do</code> </td> <td>  8,470 </td><td>  6,632 </td></tr><tr><td> <code>factorial-for</code> </td> <td>  8,440 </td><td>  6,601 </td></tr><tr><td> <code>factorial-for-each</code> </td> <td>  9.998 </td><td>  7,985 </td></tr></tbody></table><br><p> 您可以看到它没有太大 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-219"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-220">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-42-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-42"> n </script> 最快，同时最短的是第一个。 相同的选择与阶乘的数学定义最完全一致。 尾递归优化选项在性能上并不逊色于它。 这两种选择都是该语言作者惯用的建议。 该结论在很大程度上是显而易见的：除非另有说明，否则至少对于算法或方法的第一种实现，最好采用这种语言“典型”的方法。 </p><br><p> 同时，使用Scheme语言，我们可以使用非常有限的一组原语（非常“最小的均值-最大的展示次数”）编写许多用于实现阶乘计算的选项。 因此，尽管它有很长的历史并且不太普及，但是仍然可以推荐这种语言用于研究编程：似乎您可以以<em>任何方便的</em> <em>方式</em> （和以<em>任何</em>方式）在<em>其</em>上实现任何东西。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN436698/">https://habr.com/ru/post/zh-CN436698/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN436688/index.html">这家IT巨头离开了数据中心芯片市场-告诉我们这对行业意味着什么</a></li>
<li><a href="../zh-CN436690/index.html">[问-答案]关于知识产权和数据保护</a></li>
<li><a href="../zh-CN436692/index.html">有限战争</a></li>
<li><a href="../zh-CN436694/index.html">我的Pascal编译器和波兰当代艺术</a></li>
<li><a href="../zh-CN436696/index.html">如何在单声道音轨上产生双耳声音-视频将有所帮助</a></li>
<li><a href="../zh-CN436700/index.html">反欺骗：人脸识别系统如何抵抗骗子？</a></li>
<li><a href="../zh-CN436704/index.html">我们如何选择收银机自动化秤的故事</a></li>
<li><a href="../zh-CN436708/index.html">物联网由什么组成</a></li>
<li><a href="../zh-CN436710/index.html">2019年恕我直言的gamedev市场趋势。 分权？</a></li>
<li><a href="../zh-CN436712/index.html">如何推广增量游戏？ 免费，快速，有效*</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>