<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏽 🚣🏾 👖 Harga komposisi di dunia javascript 🤥 👩🏾‍🏭 🧘🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gagasan bahwa dalam pengembangan logika bisnis yang kurang lebih kompleks harus diberikan prioritas pada komposisi objek, daripada pewarisan yang popu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Harga komposisi di dunia javascript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438404/">  Gagasan bahwa dalam pengembangan logika bisnis yang kurang lebih kompleks harus diberikan prioritas pada komposisi objek, daripada pewarisan yang populer di kalangan pengembang perangkat lunak dari berbagai jenis.  Pada gelombang popularitas berikutnya dari paradigma pemrograman fungsional yang diluncurkan oleh keberhasilan ReactJS, pembicaraan tentang manfaat solusi komposisional datang ke ujung depan.  Dalam posting ini ada sedikit tata letak di rak-rak teori komposisi objek dalam Javascript, contoh konkret, analisisnya dan jawaban atas pertanyaan berapa banyak keanggunan semantik yang harus dibayar pengguna (spoiler: banyak). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f30/874/502/f308745025666d09822337569aad1b1c.jpg" alt="V. Kandinsky - Komposisi X"><br>  <i>Vasily Kandinsky - "Komposisi X"</i> <br><a name="habracut"></a><br>  Pengembangan sukses selama bertahun-tahun dari pendekatan berorientasi objek terhadap pembangunan, sebagian besar di bidang akademik, telah menyebabkan ketidakseimbangan yang nyata dalam pikiran pengembang rata-rata.  Jadi, dalam banyak kasus, pemikiran pertama, jika perlu, untuk menggeneralisasi perilaku sejumlah entitas yang beragam adalah menciptakan kelas induk dan mewarisi perilaku ini.  Pendekatan penyalahgunaan ini mengarah pada beberapa masalah yang menyulitkan desain dan menghambat pengembangan. <br><br>  Pertama, kelas dasar yang dibebani dengan logika menjadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rapuh</a> - perubahan kecil dalam metodenya dapat berdampak fatal pada kelas turunan.  Salah satu cara untuk mengatasi situasi ini adalah dengan mendistribusikan logika di beberapa kelas, menciptakan hierarki warisan yang lebih kompleks.  Dalam hal ini, pengembang mendapatkan masalah lain - logika kelas induk digandakan dalam ahli waris sebagaimana diperlukan, dalam kasus persimpangan antara fungsionalitas kelas induk, tetapi, yang penting, tidak lengkap. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/fc2/3fa/4ac/fc23fa4ac64d720585bded474be46303.png" alt="gambar"></a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mail.mozilla.org/pipermail/es-discuss/2013-June/031614.html</a> <br><br>  Dan akhirnya, menciptakan hierarki yang cukup dalam, pengguna, ketika menggunakan entitas apa pun, dipaksa untuk menyeret semua leluhurnya beserta semua dependensi mereka, terlepas dari apakah ia akan menggunakan fungsionalitasnya atau tidak.  Masalah ketergantungan berlebihan pada lingkungan dengan tangan ringan Joe Armstrong, pencipta Erlang, disebut masalah gorila dan pisang: <br><br><blockquote>  Saya pikir kurangnya usabilitas datang dalam bahasa berorientasi objek, bukan bahasa fungsional.  Karena masalah dengan bahasa berorientasi objek adalah mereka memiliki semua lingkungan implisit yang mereka bawa.  Anda menginginkan pisang, tetapi yang Anda dapatkan adalah gorila yang memegang pisang dan seluruh hutan. </blockquote><br>  Komposisi objek dipanggil untuk menyelesaikan semua masalah ini sebagai alternatif pewarisan kelas.  Idenya sama sekali bukan hal baru, tetapi tidak menemukan pemahaman yang lengkap di antara pengembang.  Situasi di dunia front-end sedikit lebih baik, di mana struktur proyek perangkat lunak seringkali cukup sederhana dan tidak merangsang penciptaan skema hubungan berorientasi objek yang kompleks.  Namun, secara membabi buta mengikuti perjanjian Gang of Four, merekomendasikan bahwa komposisi lebih disukai daripada warisan, juga dapat memainkan trik pada kebijaksanaan inspirasional dari pengembang besar. <br><br>  Mentransfer definisi dari Pola Desain ke dunia dinamis Javascript, kita dapat meringkas tiga jenis komposisi objek: <b>agregasi</b> , <b>gabungan,</b> dan <b>delegasi</b> .  Patut dikatakan bahwa pemisahan ini dan konsep komposisi objek pada umumnya memiliki sifat yang murni teknis, sedangkan makna istilah-istilah ini memiliki persimpangan, yang menimbulkan kebingungan.  Jadi, misalnya, kelas warisan dalam Javascript diimplementasikan berdasarkan delegasi (warisan prototipe).  Oleh karena itu, setiap kasus lebih baik untuk dicadangkan dengan contoh kode langsung. <br><br>  <b>Agregasi</b> adalah gabungan objek yang dapat dihitung, masing-masing dapat diperoleh menggunakan pengidentifikasi akses yang unik.  Contohnya termasuk array, pohon, grafik.  Contoh yang baik dari dunia pengembangan web adalah pohon DOM.  Kualitas utama dari jenis komposisi ini dan alasan penciptaannya adalah kemampuan untuk dengan mudah menerapkan penangan kepada setiap anak dari komposisi. <br><br>  Contoh sintetis adalah larik objek yang bergantian menetapkan gaya untuk elemen visual sewenang-wenang. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> styles = [  { <span class="hljs-attr"><span class="hljs-attr">fontSize</span></span>: <span class="hljs-string"><span class="hljs-string">'12px'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fontFamily</span></span>: <span class="hljs-string"><span class="hljs-string">'Arial'</span></span> },  { <span class="hljs-attr"><span class="hljs-attr">fontFamily</span></span>: <span class="hljs-string"><span class="hljs-string">'Verdana'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fontStyle</span></span>: <span class="hljs-string"><span class="hljs-string">'italic'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fontWeight</span></span>: <span class="hljs-string"><span class="hljs-string">'bold'</span></span> },  { <span class="hljs-attr"><span class="hljs-attr">fontFamily</span></span>: <span class="hljs-string"><span class="hljs-string">'Tahoma'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fontStyle</span></span>: <span class="hljs-string"><span class="hljs-string">'normal'</span></span>} ];</code> </pre> <br>  Setiap objek gaya dapat diekstraksi oleh indeksnya tanpa kehilangan informasi.  Selain itu, menggunakan Array.prototype.map (), Anda dapat memproses semua nilai yang disimpan dengan cara yang diberikan. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFontFamily = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.fontFamily; styles.map(getFontFamily) <span class="hljs-comment"><span class="hljs-comment">//["Arial","Verdana","Tahoma"]</span></span></code> </pre> <br>  <b>Penggabungan</b> melibatkan perluasan fungsionalitas objek yang ada dengan menambahkan properti baru ke dalamnya.  Jadi, misalnya, nyatakan reduksi dalam kerja Redux.  Data yang diterima untuk memperbarui ditulis ke objek negara, memperluasnya.  Data tentang keadaan objek saat ini, tidak seperti agregasi, akan hilang jika tidak disimpan. <br><br>  Kembali ke contoh, secara bergantian menerapkan pengaturan di atas ke elemen visual, Anda dapat menghasilkan hasil akhir dengan menggabungkan parameter objek. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> concatenate = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, s</span></span></span><span class="hljs-function">) =&gt;</span></span> ({…a, …s}); styles.reduce(concatenate, {}) <span class="hljs-comment"><span class="hljs-comment">//{fontSize:"12px",fontFamily:"Tahoma",fontStyle:"normal",fontWeight:"bold"}</span></span></code> </pre> <br>  Nilai dari gaya yang lebih spesifik pada akhirnya akan menimpa status sebelumnya. <br><br>  Saat <b>mendelegasikan</b> , seperti yang Anda duga, satu objek didelegasikan ke yang lain.  Delegasi, misalnya, adalah prototipe dalam Javascript.  Contoh objek yang diturunkan mengarahkan panggilan ke metode induk.  Jika tidak ada properti atau metode yang diperlukan dalam instance array, itu akan mengarahkan panggilan ini ke Array.prototype, dan jika perlu, lanjut ke Object.prototype.  Dengan demikian, mekanisme pewarisan dalam Javascript didasarkan pada rantai delegasi prototipe, yang secara teknis versi (kejutan) dari komposisi. <br><br>  Menggabungkan berbagai objek gaya dengan delegasi dapat dilakukan sebagai berikut. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> delegate = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(a), b); styles.reduceRight(delegate, {}) <span class="hljs-comment"><span class="hljs-comment">//{"fontSize":"12px","fontFamily":"Arial"} styles.reduceRight(delegate, {}).fontWeight //bold</span></span></code> </pre> <br>  Seperti yang Anda lihat, properti delegasi tidak dapat diakses oleh enumerasi (misalnya, menggunakan Object.keys ()), tetapi hanya dapat diakses dengan akses eksplisit.  Fakta bahwa ini memberi kita adalah di akhir posting. <br><br>  Sekarang untuk spesifik.  Contoh kasus yang mendorong pengembang untuk menggunakan komposisi alih-alih pewarisan adalah dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komposisi Objek</a> Michael Rise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam Javascript</a> .  Di sini, penulis mempertimbangkan proses menciptakan hierarki karakter bermain peran.  Awalnya, diperlukan dua jenis karakter - seorang prajurit dan pesulap, yang masing-masing memiliki cadangan kesehatan tertentu dan memiliki nama.  Properti ini adalah umum dan dapat dipindahkan ke Karakter kelas induk. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.health = <span class="hljs-number"><span class="hljs-number">100</span></span>; } }</code> </pre> <br>  Prajurit dibedakan oleh fakta bahwa ia tahu cara menyerang, sambil menghabiskan staminanya, dan penyihir - kemampuan untuk merapal mantra, mengurangi jumlah mana. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fighter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stamina = <span class="hljs-number"><span class="hljs-number">100</span></span>; } fight() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string"> takes a mighty swing!`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stamina -  ; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mana = <span class="hljs-number"><span class="hljs-number">100</span></span>; } cast() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string"> casts a fireball!`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mana -  ; } }</code> </pre> <br>  Setelah menciptakan kelas Fighter dan Mage, keturunan Karakter, pengembang dihadapkan dengan masalah yang tidak terduga ketika ada kebutuhan untuk membuat kelas Paladin.  Karakter baru dibedakan oleh kemampuan iri untuk bertarung dan menyulap.  Begitu saja Anda dapat melihat beberapa solusi yang berbeda dalam kurangnya kasih karunia yang sama. <br><br><ol><li>  Anda dapat menjadikan Paladin keturunan Karakter dan mengimplementasikan keduanya fight () dan cast () di dalamnya dari awal.  Dalam kasus ini, prinsip KERING sangat dilanggar, karena masing-masing metode akan diduplikasi selama pembuatan dan selanjutnya akan membutuhkan sinkronisasi konstan dengan metode kelas Mage dan Fighter untuk melacak perubahan. </li><li>  Metode fight () dan cast () dapat diimplementasikan pada level kelas Charater sehingga ketiga tipe karakter memilikinya.  Ini adalah solusi yang sedikit lebih menyenangkan, namun, dalam hal ini, pengembang harus mendefinisikan kembali metode pertarungan () untuk penyihir dan metode pemain () untuk prajurit, menggantinya dengan bertopik kosong. </li></ol><br>  Dalam salah satu opsi, cepat atau lambat seseorang harus menghadapi masalah warisan yang disuarakan di awal posting.  Mereka dapat diselesaikan dengan pendekatan fungsional untuk implementasi karakter.  Cukup untuk mendorong bukan dari tipenya, tetapi dari fungsinya.  Pada intinya, kami memiliki dua fitur utama yang menentukan kemampuan karakter - kemampuan untuk bertarung dan kemampuan untuk menyulap.  Fitur-fitur ini dapat diatur menggunakan fungsi pabrik yang memperluas status yang mendefinisikan karakter (contoh komposisi adalah penggabungan). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canCast = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">cast</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">spell</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${state.name}</span></span></span><span class="hljs-string"> casts </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${spell}</span></span></span><span class="hljs-string">!`</span></span>); state.mana -  ; } }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canFight = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">fight</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${state.name}</span></span></span><span class="hljs-string"> slashes at the foe!`</span></span>); state.stamina -  ; } })</code> </pre> <br>  Dengan demikian, karakter ditentukan oleh himpunan fitur-fitur ini, dan properti awal, baik umum (nama dan kesehatan), dan pribadi (stamina dan mana). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fighter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = { name, <span class="hljs-attr"><span class="hljs-attr">health</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">stamina</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(state, canFight(state)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = { name, <span class="hljs-attr"><span class="hljs-attr">health</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">mana</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(state, canCast(state)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> paladin = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = { name, <span class="hljs-attr"><span class="hljs-attr">health</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">mana</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">stamina</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(state, canCast(state), canFight(state)); }</code> </pre> <br>  Semuanya indah - kode tindakan digunakan kembali, Anda dapat menambahkan karakter baru dengan mudah, tanpa menyentuh yang sebelumnya dan tanpa menggembungkan fungsionalitas objek apa pun.  Untuk menemukan lalat dalam salep dalam solusi yang diusulkan, cukup membandingkan kinerja solusi berdasarkan pewarisan (baca delegasi) dan solusi berdasarkan gabungan.  Buat sepersejuta juta instance dari karakter yang dibuat. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inheritanceArmy = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; i++) { inheritanceArmy.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fighter(<span class="hljs-string"><span class="hljs-string">'Fighter'</span></span> + i)); inheritanceArmy.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mage(<span class="hljs-string"><span class="hljs-string">'Mage'</span></span> + i)); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> compositionArmy = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; i++) { compositionArmy.push(fighter(<span class="hljs-string"><span class="hljs-string">'Fighter'</span></span> + i)); compositionArmy.push(mage(<span class="hljs-string"><span class="hljs-string">'Mage'</span></span> + i)); }</code> </pre> <br>  Dan membandingkan memori dan biaya komputasi antara warisan dan komposisi yang diperlukan untuk membuat objek. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/158/509/b8f/158509b8fb1d5dc214b2728f72145565.png" alt="gambar"><br><br>  Rata-rata, solusi menggunakan komposisi dengan penggabungan membutuhkan 100–150% lebih banyak sumber daya.  Hasil yang disajikan diperoleh di lingkungan NodeJS, Anda dapat melihat hasil untuk mesin browser dengan menjalankan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://medium.com/r/%3Furl%3D">tes</a> ini. <br><br>  Keuntungan dari solusi berdasarkan pewarisan-delegasi dapat dijelaskan dengan menghemat memori karena kurangnya akses implisit ke properti delegasi, serta menonaktifkan beberapa optimasi mesin untuk delegasi dinamis.  Pada gilirannya, solusi berbasis gabungan menggunakan metode Object.assign () yang sangat mahal, yang sangat mempengaruhi kinerjanya.  Menariknya, Firefox Quantum menunjukkan hasil Chromium yang berlawanan secara berlawanan - solusi kedua bekerja lebih cepat di Gecko. <br><br>  Tentu saja, sangat berguna untuk mengandalkan hasil tes kinerja hanya ketika menyelesaikan tugas-tugas yang agak melelahkan terkait dengan menciptakan sejumlah besar objek infrastruktur yang kompleks - misalnya, ketika bekerja dengan pohon elemen virtual atau mengembangkan perpustakaan grafis.  Dalam kebanyakan kasus, keindahan struktural dari suatu solusi, keandalan dan kesederhanaannya ternyata lebih penting, dan perbedaan kecil dalam kinerja tidak memainkan peran besar (operasi dengan elemen DOM akan membutuhkan lebih banyak sumber daya). <br><br>  Kesimpulannya, perlu dicatat bahwa jenis komposisi yang dipertimbangkan tidak unik dan saling eksklusif.  Delegasi dapat diimplementasikan menggunakan agregasi, dan pewarisan kelas menggunakan delegasi (seperti yang dilakukan dalam JavaScript).  Pada intinya, setiap kombinasi objek akan menjadi satu atau lain bentuk komposisi, dan pada akhirnya hanya kesederhanaan dan fleksibilitas dari solusi yang dihasilkan yang penting. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438404/">https://habr.com/ru/post/id438404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438394/index.html">Yii 2.0.16</a></li>
<li><a href="../id438396/index.html">Mengapa Anda harus memikirkan pemrograman fungsional</a></li>
<li><a href="../id438398/index.html">How I Keras in C ++ Diluncurkan</a></li>
<li><a href="../id438400/index.html">Ilmuwan Israel telah mengembangkan pengobatan universal melawan kanker</a></li>
<li><a href="../id438402/index.html">Neutralinojs - apa kamu? Atau cara UNIX di mana Anda tidak menunggu</a></li>
<li><a href="../id438406/index.html">Pengalaman ReactJS + MobX - DI</a></li>
<li><a href="../id438408/index.html">Awan dan negara: fitur nasional pasar cloud</a></li>
<li><a href="../id438412/index.html">Analisis 112.654 tugas tes dan tren di pasar tenaga kerja programmer pada tahun 2019</a></li>
<li><a href="../id438414/index.html">Peradaban Musim Semi, 3/5</a></li>
<li><a href="../id438416/index.html">Tentang hormon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>