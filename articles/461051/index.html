<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¶ üòê üë®üèº‚Äçüé§ Los 10 errores m√°s comunes que he encontrado en Go-projects üí™ üêÑ üå°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta publicaci√≥n es mi principal de los errores m√°s comunes que encontr√© en Go-projects. El orden no importa. 



 Valor desconocido de Enum 
 Echemos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Los 10 errores m√°s comunes que he encontrado en Go-projects</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461051/">  <b><i>Esta publicaci√≥n es mi principal de los errores m√°s comunes que encontr√© en Go-projects.</i></b>  El orden no importa. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b01/9ed/114/b019ed114553265d5cd0c773c2d2e2c6.jpg" alt="imagen"><br><br><h3>  Valor desconocido de Enum </h3><br>  Echemos un vistazo a un ejemplo simple: <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusOpen Status = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> StatusClosed StatusUnknown )</code> </pre> <br>  Aqu√≠ creamos un enumerador usando iota, lo que conducir√° a este estado: <br><br><pre> <code class="go hljs">StatusOpen = <span class="hljs-number"><span class="hljs-number">0</span></span> StatusClosed = <span class="hljs-number"><span class="hljs-number">1</span></span> StatusUnknown = <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <a name="habracut"></a><br>  Ahora imaginemos que este tipo de estado es parte de la solicitud JSON que se empaquetar√° / desempaquetar√°.  Podemos dise√±ar la siguiente estructura: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Request <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"Id"`</span></span> Timestamp <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"Timestamp"`</span></span> Status Status <span class="hljs-string"><span class="hljs-string">`json:"Status"`</span></span> }</code> </pre> <br>  Luego obtenemos el resultado de esta consulta: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1563362390</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Status"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  En general, nada especial: el estado se descomprimir√° en StatusOpen. <br>  Ahora, obtengamos otra respuesta en la que el valor de estado no est√© establecido: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>: <span class="hljs-number"><span class="hljs-number">1235</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1563362390</span></span> }</code> </pre> <br>  En este caso, el campo Estado de la estructura Solicitud se inicializar√° a cero (para uint32 es 0).  Por lo tanto, nuevamente obtenemos StatusOpen en lugar de StatusUnknown. <br><br>  En este caso, es mejor establecer primero el valor desconocido del enumerador, es decir  0: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusUnknown Status = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> StatusOpen StatusClosed )</code> </pre><br>  Si el estado no es parte de la solicitud JSON, se inicializar√° en StatusUnknown, como esperamos. <br><br><h3>  Benchmarking </h3><br>  La evaluaci√≥n comparativa correcta es bastante dif√≠cil.  Demasiados factores pueden influir en el resultado. <br><br>  Un error com√∫n es ser enga√±ado por las optimizaciones del compilador.  Veamos un ejemplo espec√≠fico de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca teivah / bitvector</a> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (math.MaxUint64&lt;&lt;j | ((<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i) - <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp; n }</code> </pre> <br>  Esta funci√≥n borra bits en un rango dado.  Podemos probar el rendimiento de esta manera: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkWrong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { clear(<span class="hljs-number"><span class="hljs-number">1221892080809121</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>) } }</code> </pre> <br>  En esta prueba, el compilador notar√° que clear no llama a ninguna otra funci√≥n, por lo que simplemente lo incrusta como est√°.  Una vez que est√° integrado, el compilador ver√° que no se producen efectos secundarios.  Por lo tanto, la llamada clara simplemente se eliminar√°, lo que conducir√° a resultados inexactos. <br><br>  Una soluci√≥n puede ser establecer el resultado en una variable global, como esta: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkCorrect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { r = clear(<span class="hljs-number"><span class="hljs-number">1221892080809121</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>) } result = r }</code> </pre> <br>  Aqu√≠ el compilador no sabr√° si la llamada crea un efecto secundario.  Por lo tanto, el punto de referencia ser√° preciso. <br><br><h3>  Punteros!  Los punteros est√°n en todas partes! </h3><br>  Pasar una variable por valor crear√° una copia de esta variable.  Mientras pasa por el puntero, simplemente copie la direcci√≥n en la memoria. <br><br>  En consecuencia, pasar un puntero siempre ser√° m√°s r√°pido, ¬øverdad? <br><br>  Si crees que s√≠, mira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este ejemplo</a> .  Este es un punto de referencia para una estructura de datos de 0.3 KB que primero transmitimos y recibimos por puntero, y luego por valor.  0.3 KB es un poco, sobre las estructuras de datos habituales con las que trabajamos todos los d√≠as que ocupan tanto. <br><br>  Cuando ejecuto estas pruebas en un entorno local, la transmisi√≥n de valor por valor es m√°s de 4 veces m√°s r√°pida.  Bastante inesperado, ¬øverdad? <br><br>  La explicaci√≥n de este resultado est√° relacionada con la comprensi√≥n de c√≥mo se produce la gesti√≥n de la memoria en Go.  No puedo explicarlo tan brillantemente como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">William Kennedy</a> , pero intentemos resumirlo en pocas palabras. <br><br>  Se puede colocar una variable en el mont√≥n o pila: <br><ul><li>  La pila contiene las variables actuales de este programa.  Tan pronto como la funci√≥n regrese, las variables se sacan de la pila. </li><li>  El mont√≥n contiene variables comunes (variables globales, etc.). </li></ul><br>  Veamos un ejemplo simple donde devolvemos un valor: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFooValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result foo <span class="hljs-comment"><span class="hljs-comment">// Do something return result }</span></span></code> </pre> <br>  Aqu√≠ la variable de resultado es creada por la rutina actual.  Esta variable se inserta en la pila actual.  Tan pronto como la funci√≥n regrese, el cliente recibir√° una copia de esta variable.  La variable en s√≠ se saca de la pila.  Todav√≠a existe en la memoria hasta que se sobrescriba otra variable, pero ya no se puede acceder a ella. <br>  Ahora el mismo ejemplo, pero con un puntero: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFooPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result foo <span class="hljs-comment"><span class="hljs-comment">// Do something return &amp;result }</span></span></code> </pre> <br>  La variable de resultado todav√≠a es creada por la rutina actual, pero el cliente recibir√° un puntero (una copia de la direcci√≥n de la variable).  Si la variable de resultado se extrajo de la pila, el cliente de esta funci√≥n no podr√° acceder a ella. <br><br>  En este escenario, el compilador Go generar√° la variable de resultado donde las variables se pueden compartir, es decir.  en un mont√≥n <br><br>  Otro script para pasar punteros: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { p := &amp;foo{} f(p) }</code> </pre> <br>  Como llamamos a f en el mismo programa, la variable p no necesita ser acumulada.  Simplemente se empuja a la pila, y una subfunci√≥n puede acceder a ella. <br><br>  Por ejemplo, de esta forma se obtiene un corte en el m√©todo de lectura de io.Reader.  Devolver un segmento (que es un puntero) lo coloca en un mont√≥n. <br><br>  ¬øPor qu√© la pila es tan r√°pida?  Hay dos razones: <br><ul><li>  No es necesario usar el recolector de basura en la pila.  Como ya dijimos, una variable simplemente se empuja despu√©s de ser creada, y luego se saca de la pila cuando la funci√≥n regresa.  No es necesario agitar un proceso complicado para devolver variables no utilizadas, etc. </li><li>  La pila pertenece a una rutina, por lo que no es necesario sincronizar el almacenamiento de la variable, como sucede con el almacenamiento en el mont√≥n, lo que tambi√©n conduce a un aumento del rendimiento. </li></ul><br>  En conclusi√≥n, cuando creamos una funci√≥n, nuestra acci√≥n predeterminada deber√≠a ser usar valores en lugar de punteros.  Un puntero solo debe usarse si queremos compartir una variable. <br><br>  Adem√°s, si sufrimos problemas de rendimiento, ¬øuna de las posibles optimizaciones podr√≠a ser verificar si los punteros ayudan en situaciones espec√≠ficas?  Se puede averiguar si el compilador genera una variable en el mont√≥n con el siguiente comando: <pre> <code class="bash hljs">go build -gcflags <span class="hljs-string"><span class="hljs-string">"-m -m"</span></span></code> </pre>  . <br>  Pero, nuevamente, para la mayor√≠a de nuestras tareas diarias, usar valores es lo mejor. <br><br><h3>  Anular para / cambiar o para / seleccionar </h3><br>  ¬øQu√© sucede en el siguiente ejemplo si f devuelve verdadero? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> f() { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Do something } }</span></span></code> </pre> <br>  Llamamos descanso.  Solo esta ruptura rompe el interruptor, no el bucle for. <br><br>  Mismo problema aqu√≠: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-ch: <span class="hljs-comment"><span class="hljs-comment">// Do something case &lt;-ctx.Done(): break } }</span></span></code> </pre> <br>  La ruptura est√° asociada con una instrucci√≥n select, no con un bucle for. <br><br>  Una posible soluci√≥n para interrumpir for / switch o for / select es usar una etiqueta: <br><br><pre> <code class="go hljs">loop: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-ch: <span class="hljs-comment"><span class="hljs-comment">// Do something case &lt;-ctx.Done(): break loop } }</span></span></code> </pre> <br><h3>  Manejo de errores </h3><br>  Go todav√≠a es joven, especialmente en el √°rea de manejo de errores.  Superar esta deficiencia es una de las innovaciones m√°s esperadas en Go 2. <br><br>  La biblioteca est√°ndar actual (anterior a Go 1.13) ofrece solo funciones para construir errores.  Por lo tanto, ser√° interesante echar un vistazo al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>paquete pkg / errors</i></a> . <br><br>  Esta biblioteca es una buena manera de seguir una regla que no siempre se respeta: <br><blockquote>  El error debe procesarse solo una vez.  El registro de errores es el manejo de errores </blockquote>  .  Por lo tanto, el error debe registrarse o lanzarse m√°s alto. <br><br>  En la biblioteca est√°ndar actual, este principio es dif√≠cil de observar, ya que es posible que queramos agregar contexto al error y tener alg√∫n tipo de jerarqu√≠a. <br><br>  Veamos un ejemplo con una llamada REST que conduce a un error en la base de datos: <br><br><pre> <code class="bash hljs">unable to server HTTP POST request <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> customer 1234 |_ unable to insert customer contract abcd |_ unable to commit transaction</code> </pre><br>  Si usamos pkg / errors, podemos hacer lo siguiente: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(customer Customer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Status</span></span></span></span> { err := insert(customer.Contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := dbQuery(contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to insert customer contract %s"</span></span>, contract.ID) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Do something then fail return errors.New("unable to commit transaction") }</span></span></code> </pre> <br>  El error inicial (si la biblioteca externa no lo devuelve) se puede crear utilizando errores. Nuevo.  La capa intermedia, insertar, envuelve este error y le agrega m√°s contexto.  Entonces el padre lo registra.  Por lo tanto, cada nivel devuelve o procesa un error. <br><br>  Tambi√©n podemos querer encontrar la causa del error, por ejemplo, para volver a llamar.  Supongamos que tenemos un paquete db de una biblioteca externa que tiene acceso a una base de datos.  Esta biblioteca puede devolver un error temporal llamado db.DBError.  Para determinar si necesitamos volver a intentarlo, debemos establecer la causa del error: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(customer Customer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Status</span></span></span></span> { err := insert(customer.Contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> errors.Cause(err).(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *db.DBError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retry(customer) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := db.dbQuery(contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to insert customer contract %s"</span></span>, contract.ID) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Esto se hace usando errores. Causa, que tambi√©n se incluye en <i>pkg / errors</i> : <br><br>  Uno de los errores comunes que encontr√© fue el uso de <i>pkg / errors</i> solo parcialmente.  Una verificaci√≥n de error, por ejemplo, se realiz√≥ de la siguiente manera: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *db.DBError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retry(customer) }</code> </pre> <br>  En este ejemplo, si db.DBError est√° envuelto, nunca har√° una segunda llamada. <br><br><h3>  Inicializaci√≥n de rebanada </h3><br>  A veces sabemos cu√°l ser√° la longitud final de la porci√≥n.  Por ejemplo, supongamos que queremos convertir un segmento Foo en un segmento Bar, lo que significa que estos dos segmentos tendr√°n la misma longitud. <br><br>  A menudo encuentro trozos inicializados de esta manera: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bars []Bar bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Slice no es una estructura m√°gica.  Debajo del cap√≥, implementa una estrategia para aumentar el tama√±o si no hay m√°s espacio libre.  En este caso, se crea autom√°ticamente una nueva matriz (con una mayor capacidad) y todos los elementos se copian en ella. <br><br>  Ahora imaginemos que necesitamos repetir esta operaci√≥n de aumentar el tama√±o varias veces, ya que nuestro [] Foo contiene miles de elementos.  La complejidad del algoritmo de inserci√≥n seguir√° siendo O (1), pero en la pr√°ctica esto afectar√° el rendimiento. <br><br>  Por lo tanto, si conocemos la longitud final, podemos: <br><br><ul><li>  Inicial√≠celo con una longitud predefinida: </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(foos []Foo)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span></span> { bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(foos)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, foo := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> foos { bars[i] = fooToBar(foo) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bars }</code> </pre> <br><ul><li>  O inicial√≠celo con una longitud de 0 y una capacidad predeterminada: </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(foos []Foo)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span></span> { bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(foos)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, foo := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> foos { bars = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(bars, fooToBar(foo)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bars }</code> </pre> <br>  ¬øCu√°l es la mejor opci√≥n?  El primero es un poco m√°s r√°pido.  Sin embargo, puede preferir este √∫ltimo porque es m√°s consistente: independientemente de si conocemos el tama√±o inicial, la adici√≥n de un elemento al final del segmento se realiza mediante el agregado. <br><br><h3>  Gesti√≥n del contexto </h3><br>  contexto. El contexto a menudo es mal entendido por los desarrolladores.  Seg√∫n la documentaci√≥n oficial: <br><blockquote>  El contexto lleva la fecha l√≠mite, la se√±al de cancelaci√≥n y otros valores a trav√©s de los l√≠mites de la API. <br>  Esta descripci√≥n es bastante general, por lo tanto, puede confundir al programador c√≥mo usarla correctamente. </blockquote><br>  Tratemos de resolverlo.  El contexto puede llevar: <br><ul><li>  Fecha l√≠mite: significa la duraci√≥n (por ejemplo, 250 ms) o la fecha y hora (por ejemplo, 2019-01-08 01:00:00), seg√∫n la cual creemos que si se alcanza, la acci√≥n actual debe cancelarse (solicitud de E / S ), esperando la entrada del canal, etc.). </li><li>  Cancelar se√±al (b√°sicamente &lt;-chan struct {}).  Aqu√≠ el comportamiento es similar.  Tan pronto como recibamos una se√±al, debemos detener el trabajo actual.  Por ejemplo, supongamos que recibimos dos solicitudes.  Uno para insertar datos y el otro para cancelar la primera solicitud (porque ya no es relevante, por ejemplo).  Esto se puede lograr utilizando el contexto cancelado en la primera llamada, que luego se cancelar√° tan pronto como recibamos la segunda solicitud. </li><li>  Lista de clave / valor (ambas basadas en el tipo de interfaz {}). </li></ul><br>  Dos puntos m√°s.  Primero, el contexto es componible.  Por lo tanto, podemos tener un contexto que lleve la fecha l√≠mite y la lista de clave / valor, por ejemplo.  Adem√°s, m√∫ltiples goroutines pueden compartir el mismo contexto, por lo que una se√±al de cancelaci√≥n puede potencialmente detener varios trabajos. <br><br>  Volviendo a nuestro tema, aqu√≠ hay un error que conoc√≠. <br><br>  La aplicaci√≥n Go se bas√≥ en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>urfave / cli</i></a> (si no lo sabe, esta es una buena biblioteca para crear aplicaciones de l√≠nea de comandos en Go).  Una vez iniciado, el desarrollador hereda un tipo de contexto de aplicaci√≥n.  Esto significa que cuando la aplicaci√≥n se detiene, la biblioteca utilizar√° el contexto para enviar una se√±al de cancelaci√≥n. <br><br>  Not√© que este contexto se transmiti√≥ directamente, por ejemplo, cuando se llam√≥ a un punto final gRPC.  Esto no es en absoluto lo que necesitamos. <br><br>  En cambio, queremos decirle a la biblioteca gRPC: cancele la solicitud cuando la aplicaci√≥n se detenga, o despu√©s de 100 ms, por ejemplo. <br><br>  Para lograr esto, simplemente podemos crear un contexto compuesto.  Si padre es el nombre del contexto de la aplicaci√≥n (creado por <i>urfave / cli</i> ), entonces simplemente podemos hacer esto: <br><br><pre> <code class="go hljs">ctx, cancel := context.WithTimeout(parent, <span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) response, err := grpcClient.Send(ctx, request)</code> </pre> <br>  Los contextos no son tan dif√≠ciles de entender y, en mi opini√≥n, esta es una de las mejores caracter√≠sticas del lenguaje. <br><br><h3>  No usar la opci√≥n -race </h3><br>  Probar una aplicaci√≥n Go sin la opci√≥n -race es un error que constantemente encuentro. <br><br>  Como est√° escrito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en este art√≠culo</a> , aunque Go fue " <i>dise√±ado para hacer que la programaci√≥n paralela sea m√°s simple y menos propensa a errores</i> ", todav√≠a sufrimos grandes problemas de concurrencia. <br><br>  Obviamente, el detector de carrera Go no ayudar√° con ning√∫n problema.  Sin embargo, es una herramienta valiosa, y siempre debemos incluirla al probar nuestras aplicaciones. <br><br><h3>  Usando el nombre del archivo como entrada </h3><br>  Otro error com√∫n es pasar el nombre del archivo a una funci√≥n. <br><br>  Supongamos que necesitamos implementar una funci√≥n para contar el n√∫mero de l√≠neas vac√≠as en un archivo.  La implementaci√≥n m√°s natural se ver√≠a as√≠: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { file, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to open %s"</span></span>, filename) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> file.Close() scanner := bufio.NewScanner(file) count := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> scanner.Scan() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> scanner.Text() == <span class="hljs-string"><span class="hljs-string">""</span></span> { count++ } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  El nombre del archivo se establece como una entrada, por lo que lo abrimos y luego implementamos nuestra l√≥gica, ¬øverdad? <br><br>  Ahora supongamos que queremos cubrir esta funci√≥n con pruebas unitarias.  Probamos con un archivo normal, un archivo vac√≠o, un archivo con un tipo diferente de codificaci√≥n, etc. Puede ser muy dif√≠cil de administrar. <br><br>  Adem√°s, si queremos implementar la misma l√≥gica, por ejemplo, para el cuerpo HTTP, necesitaremos crear otra funci√≥n para esto. <br><br>  Go viene con dos grandes abstracciones: io.Reader y io.Writer.  En lugar de pasar el nombre del archivo, simplemente podemos pasar io.Reader, que abstraer√° la fuente de datos. <br>  ¬øEs esto un archivo?  Cuerpo HTTP?  Byte buffer?  No importa, ya que seguiremos utilizando el mismo m√©todo de lectura. <br><br>  En nuestro caso, incluso podemos almacenar la entrada para leerla l√≠nea por l√≠nea.  Para hacer esto, puede usar bufio.Reader y su m√©todo ReadLine: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader *bufio.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { count := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { line, _, err := reader.ReadLine() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to read"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> io.EOF: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(line) == <span class="hljs-number"><span class="hljs-number">0</span></span> { count++ } } }</code> </pre> <br>  Ahora la responsabilidad de abrir el archivo ha sido delegada al cliente de conteo: <br><br><pre> <code class="go hljs">file, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to open %s"</span></span>, filename) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> file.Close() count, err := count(bufio.NewReader(file))</code> </pre> <br>  En una segunda implementaci√≥n, se puede llamar a una funci√≥n independientemente de la fuente de datos real.  Mientras tanto, esto facilitar√° nuestras pruebas unitarias, ya que simplemente podemos crear bufio.Reader desde la l√≠nea: <br><br><pre> <code class="go hljs">count, err := count(bufio.NewReader(strings.NewReader(<span class="hljs-string"><span class="hljs-string">"input"</span></span>)))</code> </pre> <br><h3>  Goroutinas y variables del ciclo </h3><br>  El √∫ltimo error com√∫n que encontr√© fue al usar goroutines con variables de bucle. <br><br>  ¬øCu√°l ser√° la conclusi√≥n del siguiente ejemplo? <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }() }</code> </pre> <br>  1 2 3 al azar?  No <br><br>  En este ejemplo, cada gorutina usa la misma instancia de una variable, por lo que generar√° 3 3 3 (muy probablemente). <br><br>  Hay dos soluciones a este problema.  El primero es pasar el valor de la variable i al cierre (funci√≥n interna): <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }(i) }</code> </pre> <br>  El segundo es crear otra variable dentro del ciclo for: <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { i := i <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }() }</code> </pre> <br>  Asignar i: = puede parecer un poco extra√±o, pero este dise√±o es perfectamente v√°lido.  Estar en un bucle significa estar en un alcance diferente.  Por lo tanto, i: = i crea otra instancia de la variable i.  Por supuesto, podemos llamarlo con un nombre diferente para facilitar la lectura. <br><br>  <i>Si conoce otros errores comunes, no dude en escribir sobre ellos en los comentarios.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461051/">https://habr.com/ru/post/461051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461041/index.html">¬øRedondeado o de √°ngulo agudo?</a></li>
<li><a href="../461043/index.html">Gesti√≥n de conflictos en un equipo: ¬øun acto de equilibrio o una necesidad vital?</a></li>
<li><a href="../461045/index.html">Obtenga un extracto de Rosreestr a trav√©s de FSIS USRN y python. Parte 1</a></li>
<li><a href="../461047/index.html">Escribir o no escribir. Cartas a las autoridades durante los eventos.</a></li>
<li><a href="../461049/index.html">ONYX BOOX Faust - El que busca no est√° obligado a vagar</a></li>
<li><a href="../461053/index.html">Conectamos mapas en l√≠nea al navegador en el tel√©fono inteligente. Parte 2 - tarjetas de vectores</a></li>
<li><a href="../461055/index.html">Rekko Challenge 2019: como fue</a></li>
<li><a href="../461057/index.html">Canales de Telegram sobre desarrollo de juegos</a></li>
<li><a href="../461059/index.html">Escribir una aplicaci√≥n de Android para fan√°ticos del cine - Parte 1 (creaci√≥n de prototipos)</a></li>
<li><a href="../461061/index.html">Aleaciones de magnesio, l√≠mites gemelos y segregaci√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>