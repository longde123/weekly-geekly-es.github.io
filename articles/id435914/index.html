<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ï üìµ üôÜüèº Pengemasan Aplikasi Inti ASP.NET Menggunakan Docker ü•® üë©‚Äçüöí üõ¢Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aplikasi Core ASP.NET benar-benar lintas platform dan dapat berjalan di nixes dan, karenanya, di Docker. Mari kita lihat bagaimana mereka dapat dikema...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengemasan Aplikasi Inti ASP.NET Menggunakan Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/435914/"><p>  Aplikasi Core ASP.NET benar-benar lintas platform dan dapat berjalan di nixes dan, karenanya, di Docker.  Mari kita lihat bagaimana mereka dapat dikemas untuk digunakan di Linux dan digunakan bersama dengan Nginx.  Detail di bawah potongan! </p><br><p><img src="https://habrastorage.org/webt/rv/zy/xx/rvzyxxq8mg8yreoka2rkkukpr3i.jpeg"><a name="habracut"></a></p><br><p>  <em>Catatan: kami melanjutkan serangkaian publikasi artikel versi lengkap dari majalah Hacker.</em>  <em>Ejaan dan tanda baca penulis disimpan.</em> </p><br><h2>  Tentang Docker </h2><br><p>  Hampir setiap orang pernah mendengar tentang arsitektur layanan mikro.  Konsep memecah aplikasi menjadi beberapa bagian bukan untuk mengatakan bahwa itu baru.  Namun, yang baru adalah yang lama terlupakan dan didaur ulang. </p><br><p>  Jika Anda mencoba berbicara tentang arsitektur dalam beberapa kata, maka aplikasi web dibagi menjadi beberapa bagian kesatuan - layanan.  Layanan tidak berinteraksi langsung satu sama lain dan tidak memiliki database umum.  Ini dilakukan untuk dapat mengubah setiap layanan tanpa konsekuensi bagi yang lain.  Layanan dikemas dalam wadah.  Di antara kontainer, Docker menguasai bola. </p><br><p>  Untuk menggambarkan apa Docker sangat sering disederhanakan menggunakan istilah "mesin virtual".  Jelas ada kesamaan, tetapi salah untuk mengatakannya.  Cara termudah untuk memahami perbedaan ini adalah dengan melihat gambar-gambar berikut dari dokumentasi buruh pelabuhan resmi: </p><br><p><img src="https://habrastorage.org/webt/xf/os/nu/xfosnujlxyttzdhimiuzf8tmcd8.png"></p><br><p><img src="https://habrastorage.org/webt/w4/y4/6e/w4y46e4boi3u-l8pwo70rs-7xmm.png"></p><br><p>  Kontainer menggunakan inti dari sistem operasi saat ini dan membaginya di antara mereka sendiri.  Sedangkan mesin virtual menggunakan hypervisor menggunakan sumber daya perangkat keras. <br>  Gambar Docker adalah objek hanya baca yang pada dasarnya menyimpan templat untuk membuat wadah.  Wadah adalah lingkungan di mana kode dieksekusi.  Gambar disimpan dalam repositori.  Sebagai contoh, repositori <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Docker Hub</a> resmi memungkinkan Anda untuk menyimpan hanya satu gambar secara pribadi.  Namun, gratis, jadi untuk ini Anda perlu berterima kasih kepada mereka. </p><br><h1>  INFO </h1><br><p>  Docker bukan satu-satunya perwakilan dari containerisasi.  Selain itu, ada teknologi lainnya.  Sebagai contoh: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rkt</a> (diucapkan 'roket') oleh CoreOS </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LXD</a> (diucapkan 'lexdi') oleh Ubuntu </p><br><p>  Wadah Windows - Anda tidak akan pernah menebak dari siapa pun. </p><br><p>  Sekarang kita telah membiasakan diri dengan teori, mari kita lanjutkan ke praktik. </p><br><p>  Tidak ada gunanya membongkar instalasi buruh pelabuhan, karena dapat diinstal pada banyak sistem operasi.  Saya hanya akan menunjukkan bahwa Anda dapat mengunduhnya untuk platform Anda dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Docker Store</a> .  Jika Anda menginstal Docker di Windows, maka virtualisasi harus diaktifkan di BIOS dan OS.  Anda dapat membaca tentang cara mengaktifkannya dalam 10-ke dalam artikel berikut: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menginstal Hyper-V di Windows10</a> </p><br><h2>  Membuat proyek yang didukung buruh pelabuhan </h2><br><p> Docker, tentu saja, adalah produk Linux, tetapi jika perlu, Anda dapat menggunakannya saat mengembangkan untuk Mac atau untuk Windows.  Saat membuat proyek di Visual Studio, untuk menambahkan dukungan buruh pelabuhan, cukup pilih kotak centang Aktifkan Dukungan Docker. </p><br><p>  Dukungan Docker dapat ditambahkan ke proyek yang ada.  Itu ditambahkan ke proyek dengan cara yang sama seperti berbagai komponen baru ditambahkan.  Menu konteks Tambah - Dukungan Docker. </p><br><p>  Jika docker diinstal dan dijalankan pada mesin Anda, konsol akan dibuka secara otomatis dan perintah akan dieksekusi </p><br><pre><code class="lua hljs">docker pull microsoft/aspnetcore:<span class="hljs-number"><span class="hljs-number">2.0</span></span></code> </pre> <br><p>  yang memulai proses mengunduh gambar.  Gambar ini sebenarnya kosong berdasarkan gambar yang akan Anda buat.  ASP.NET Core 2.1 menggunakan gambar yang berbeda - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">microsoft / dotnet: sdk</a> </p><br><p>  File-file berikut akan secara otomatis dibuat di direktori dengan solusi untuk Anda: <br>  .dockerignore (tidak termasuk file dan direktori dari gambar docker), docker-compose.yml (menggunakan file ini Anda dapat mengonfigurasi pelaksanaan beberapa layanan), docker-compose.override.yml (susunan tambahan docker-compose), docker-compose.dcproj ( file proyek untuk Visual Studio). </p><br><p>  File Dockerfile akan dibuat di direktori proyek.  Sebenarnya, dengan bantuan file ini kami membuat gambar kami.  Secara default (jika proyek ini disebut DockerServiceDemo) mungkin terlihat seperti ini: </p><br><pre> <code class="java hljs">FROM microsoft/aspnetcore:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS base WORKDIR /app EXPOSE <span class="hljs-number"><span class="hljs-number">80</span></span> FROM microsoft/aspnetcore-build:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS build WORKDIR /src COPY DockerServiceDemo/DockerServiceDemo.csproj DockerServiceDemo/ RUN dotnet restore DockerServiceDemo/DockerServiceDemo.csproj COPY . . WORKDIR /src/DockerServiceDemo RUN dotnet build DockerServiceDemo.csproj -c Release -o /app FROM build AS publish RUN dotnet publish DockerServiceDemo.csproj -c Release -o /app FROM base AS <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> WORKDIR /app COPY --from=publish /app . ENTRYPOINT [<span class="hljs-string"><span class="hljs-string">"dotnet"</span></span>, <span class="hljs-string"><span class="hljs-string">"DockerServiceDemo.dll"</span></span>]</code> </pre> <br><p>  Konfigurasi awal untuk .NET Core 2.0 tidak akan memungkinkan Anda untuk segera membangun gambar menggunakan perintah build docker.  Ini dikonfigurasi untuk meluncurkan file docker-compose dari direktori satu tingkat ke atas.  Agar konstruksi dapat berjalan dengan sukses, Dockerfile dapat dibawa ke tampilan yang sama: </p><br><pre> <code class="java hljs">FROM microsoft/aspnetcore:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS base WORKDIR /app EXPOSE <span class="hljs-number"><span class="hljs-number">80</span></span> FROM microsoft/aspnetcore-build:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS build WORKDIR /src COPY DockerServiceDemo.csproj DockerServiceDemo.csproj RUN dotnet restore DockerServiceDemo.csproj COPY . . WORKDIR /src RUN dotnet build DockerServiceDemo.csproj -c Release -o /app FROM build AS publish RUN dotnet publish DockerServiceDemo.csproj -c Release -o /app FROM base AS <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> WORKDIR /app COPY --from=publish /app . ENTRYPOINT [<span class="hljs-string"><span class="hljs-string">"dotnet"</span></span>, <span class="hljs-string"><span class="hljs-string">"DockerServiceDemo.dll"</span></span>]</code> </pre> <br><p>  Yang saya lakukan adalah menghapus direktori DockerServiceDemo tambahan. </p><br><p>  Jika Anda menggunakan Visual Studio Code, maka Anda harus membuat file secara manual.  Meskipun VS Code memiliki fungsionalitas tambahan dalam bentuk ekstensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Docker</a> , saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akan</a> menambahkan tautan ke manual tentang cara bekerja dengan buruh pelabuhan dari VS Code - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bekerja dengan Docker</a> .  Ya, artikel ini dalam bahasa Inggris, tetapi dengan gambar </p><br><h2>  Three Chords Docker </h2><br><p>  Untuk pekerjaan sehari-hari dengan buruh pelabuhan, hanya beberapa perintah yang cukup untuk diingat. </p><br><p>  Tim yang paling penting tentu saja adalah membangun citra.  Untuk melakukan ini, Anda perlu menggunakan bash / CMD / PowerShell untuk pergi ke direktori tempat Dockerfile berada dan jalankan perintah: </p><br><pre> <code class="python hljs">docker build -t your_image_name .</code> </pre> <br><p>  Di sini, setelah opsi -t, nama gambar Anda diatur.  Perhatian - di akhir perintah, spasi setelah spasi.  Titik ini berarti bahwa direktori saat ini sedang digunakan.  Gambar dapat ditandai dengan tag (nomor atau nama).  Untuk melakukan ini, beri tanda titik dua di belakang nama dan tentukan tag.  Jika tag tidak ditentukan, maka secara default akan ditetapkan dengan nama terbaru.  Untuk mengirim gambar ke repositori, perlu bahwa nama gambar menyertakan nama repositori.  Sesuatu seperti ini: </p><br><pre> <code class="python hljs">docker build -t docker_account_name/image_name:your_tag .</code> </pre> <br><p>  Di sini your_docker_account_name adalah nama akun hub docker Anda. </p><br><p>  Jika Anda membuat gambar hanya dengan nama lokal yang tidak termasuk repositori, maka Anda dapat menandai gambar dengan nama yang berbeda setelah konstruksi menggunakan perintah berikut: </p><br><pre> <code class="python hljs">docker tag image_name docker_account_name/image_name:your_tag</code> </pre> <br><p>  Untuk mengirim perubahan ke hub, Anda sekarang harus menjalankan perintah berikut: </p><br><pre> <code class="python hljs">docker push docker_account_name/image_name:your_tag</code> </pre> <br><p>  Sebelum ini, Anda harus masuk ke akun buruh pelabuhan.  Pada Windows, ini dilakukan dari UI aplikasi, tetapi pada * nix ini dilakukan oleh perintah: </p><br><pre> <code class="python hljs">docker login</code> </pre> <br><p>  Padahal, tiga tim tidak cukup.  Anda juga harus dapat memeriksa pengoperasian wadah.  Perintah yang digunakan untuk memulai wadah terlihat seperti ini: </p><br><pre> <code class="python hljs">docker run -it -p <span class="hljs-number"><span class="hljs-number">5000</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span> image_name</code> </pre> <br><p>  Opsi -itu akan membuat pseudo-TTY dan wadah Anda akan menanggapi permintaan.  Setelah menjalankan perintah, layanan akan tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http: // localhost: 5000 /</a> </p><br><p>  -p 5000: 80 mengaitkan port 5000 dari wadah dengan port 80 dari host. </p><br><p>  Selain itu, ada perintah seperti itu: </p><br><pre> <code class="python hljs">docker ps ‚Äìa</code> </pre> <br><p>  Tunjukkan daftar kontainer.  Karena sakelar -a telah ditambahkan, semua wadah akan ditampilkan, bukan hanya yang sedang berjalan. </p><br><pre> <code class="python hljs">docker rm container_name</code> </pre> <br><p>  Perintah ini akan menghapus wadah bernama container_name.  rm - kependekan untuk menghapus </p><br><pre> <code class="python hljs">docker logs container_name</code> </pre> <br><p>  Tampilkan log kontainer </p><br><pre> <code class="python hljs">docker rmi image_name</code> </pre> <br><p>  Menghapus gambar bernama image_name </p><br><h2>  Meluncurkan wadah melalui server proxy terbalik </h2><br><p>  Faktanya adalah bahwa aplikasi .NET Core sendiri menggunakan server web Kestrel mereka.  Server ini tidak direkomendasikan untuk produksi.  Mengapa  Ada beberapa penjelasan. <br>  Jika ada beberapa aplikasi yang berbagi IP dan port, maka Kestrel tidak akan dapat mendistribusikan lalu lintas.  Selain itu, server proxy terbalik memberikan lapisan keamanan tambahan, menyederhanakan penyeimbangan muatan dan pengaturan SSL, dan juga mengintegrasikan lebih baik ke dalam infrastruktur yang ada.  Bagi sebagian besar pengembang, alasan paling penting untuk kebutuhan proxy terbalik adalah keamanan tambahan. </p><br><p>  Pertama, kembalikan konfigurasi Dockerfile asli.  Setelah itu, kita akan berurusan dengan file docker-compose.yml dan mencoba menjalankan layanan kita sendiri.  Format file yml dibaca sebagai "yaml" dan merupakan singkatan dari "Yet Another Markup Language" atau dari "YAML Ain't Markup Language".  Entah bahasa markup lain, atau bukan bahasa markup sama sekali.  Entah bagaimana, semuanya tidak pasti. </p><br><p>  File komposisi buruh pelabuhan default saya terlihat seperti ini: </p><br><pre> <code class="python hljs">version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo: image: ${DOCKER_REGISTRY}dockerservicedemo build: context: . dockerfile: DockerServiceDemo/Dockerfile</code> </pre> <br><p>  File docker-compose.override.yml menambahkan beberapa pengaturan ke konfigurasi: <br>  versi: '3.4' </p><br><pre> <code class="python hljs">services: dockerservicedemo: environment: - ASPNETCORE_ENVIRONMENT=Development ports: - <span class="hljs-string"><span class="hljs-string">"80"</span></span></code> </pre> <br><p>  Kita dapat membangun solusi yang dibuat dengan menggunakan docker-compose build, dengan memanggil perintah docker-compose up, kita akan meluncurkan kontainer kita.  Apakah semuanya berfungsi?  Lalu lanjutkan ke langkah berikutnya.  Buat file nginx.info.  Konfigurasi akan kira-kira sebagai berikut: </p><br><pre> <code class="python hljs">worker_processes <span class="hljs-number"><span class="hljs-number">4</span></span>; events { worker_connections <span class="hljs-number"><span class="hljs-number">1024</span></span>; } http { sendfile on; upstream app_servers { server dockerservicedemo:<span class="hljs-number"><span class="hljs-number">80</span></span>; } server { listen <span class="hljs-number"><span class="hljs-number">80</span></span>; location / { proxy_pass http://app_servers; proxy_http_version <span class="hljs-number"><span class="hljs-number">1.1</span></span>; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } }</code> </pre> <br><p>  Di sini kami menunjukkan bahwa nginx akan mendengarkan pada port 80 (dengarkan 80;).  Dan permintaan yang diterima akan dialihkan ke port ke-80 dari host di wadah dockerservicedemo.  Selain itu, kami memberi tahu nginx header mana yang harus diteruskan. </p><br><p>  Kita dapat menggunakan http di nginx, dan mengakses situs web melalui https.  Ketika permintaan https melewati proxy http, banyak informasi dari https tidak diteruskan ke http.  Selain itu, saat menggunakan proxy, alamat IP eksternal hilang.  Agar informasi ini dapat dikirimkan dalam header, Anda perlu mengubah kode proyek ASP.NET kami dan menambahkan kode berikut ke awal metode Konfigurasi file Startup.cs: </p><br><pre> <code class="python hljs"> app.UseForwardedHeaders(new ForwardedHeadersOptions { ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto });</code> </pre> <br><p>  Sebagian besar server proxy menggunakan header X-Forwarded-For dan X-Forwarded-Proto.  Header inilah yang ditentukan sekarang dalam konfigurasi nginx. </p><br><p>  Sekarang termasuk gambar nginx dan file nginx.conf dalam konfigurasi doker-compose.  Perhatian dalam masalah spasi YAML: </p><br><pre> <code class="python hljs">version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo: image: ${DOCKER_REGISTRY}dockerservicedemo build: context: . dockerfile: DockerServiceDemo/Dockerfile ports: - <span class="hljs-number"><span class="hljs-number">5000</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span> proxy: image: nginx:latest volumes: - ./DockerServiceDemo/nginx.conf:/etc/nginx/nginx.conf ports: - <span class="hljs-number"><span class="hljs-number">80</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span></code> </pre> <br><p>  Di sini kita menambahkan proksi ke konfigurasi kita sebagai gambar nginx.  Kami melampirkan gambar ini file pengaturan eksternal.  Kami semacam memasangnya ke sistem file wadah menggunakan mekanisme yang disebut volume.  Jika Anda menambahkan di akhir: ro maka objek akan dipasang hanya-baca. </p><br><p>  Proxy mendengarkan port 80 eksternal dari mesin di mana wadah berjalan dan mengirimkan permintaan ke port 80 internal kontainer. </p><br><p>  Dengan menjalankan perintah doker-compose up, kita akan mengisi, yaitu, mengekstrak gambar nginx dari repositori dan mulai wadah kami bersama dengan wadah proxy.  Sekarang di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http: // localhost: 80 /</a> itu akan dapat diakses melalui nginx.  Pada port 5000, aplikasi "spin" juga di bawah Kestrel. </p><br><p>  Kami dapat memverifikasi bahwa permintaan ke aplikasi web melewati proksi terbalik.  Buka alat pengembang di browser Chrome dan buka tab Network.  Klik localhost di sini dan pilih tab Headers. </p><br><p><img src="https://habrastorage.org/webt/zx/xi/sp/zxxisp6hjwtbza8u5wlmgu54jqq.png"></p><br><h2>  Kami meluncurkan wadah melalui proxy dan HTTPS </h2><br><p>  ASP.NET Core 2.1 membawa serta peningkatan dalam dukungan HTTPS. <br>  Katakanlah middleware berikut memungkinkan Anda mengalihkan dari koneksi yang tidak aman ke koneksi yang aman: </p><br><pre> <code class="python hljs">app.UseHttpsRedirection();</code> </pre> <br><p>  Dan yang berikutnya memungkinkan Anda menggunakan Protokol Keamanan Transportasi Ketat HTTP - HSTS. </p><br><pre> <code class="python hljs">app.UseHsts();</code> </pre> <br><p>  HSTS adalah fitur dari protokol HTTP / 2, spesifikasi yang dirilis pada 2015.  Fungsionalitas ini didukung oleh browser modern dan menginformasikan bahwa situs web hanya menggunakan https.  Dengan demikian, perlindungan terhadap serangan downgrade terjadi selama penyerang dapat mengambil keuntungan dari situasi dengan menggunakan transisi ke protokol http tidak aman.  Misalnya, menurunkan TLS atau bahkan mengganti sertifikat. </p><br><p>  Biasanya, tipe serangan ini digunakan bersamaan dengan serangan man-in-the-middle.  Anda harus tahu dan ingat bahwa HSTS tidak menyelamatkan Anda dari situasi ketika pengguna mengunjungi situs menggunakan protokol http dan kemudian mengalihkan ke https.  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar preload Chrome yang</a> disebut, yang berisi tautan ke situs yang mendukung https.  Peramban lain (Firefox, Opera, Safari, Edge) juga mendukung daftar situs https yang dibuat berdasarkan daftar Chrome.  Tetapi semua daftar ini jauh dari semua situs. </p><br><p>  Pertama kali Anda menjalankan aplikasi Core pada Windows, Anda akan menerima pesan yang menyatakan bahwa sertifikat pengembang telah dibuat dan diinstal.  Dengan mengklik tombol dan menginstal sertifikat, Anda akan membuatnya dipercaya.  Dari baris perintah di macOS, Anda dapat menambahkan kepercayaan ke sertifikat menggunakan perintah: <br>  dotnet dev-certs https ‚Äìtrust </p><br><p>  Jika utilitas dev-certs tidak diinstal, Anda dapat menginstalnya dengan perintah: </p><br><pre> <code class="python hljs">dotnet tool install --<span class="hljs-keyword"><span class="hljs-keyword">global</span></span> dotnet-dev-certs</code> </pre> <br><p>  Cara menambahkan sertifikat ke tepercaya di Linux tergantung pada distribusinya. <br>  Untuk tujuan pengujian, kami menggunakan sertifikat pengembang.  Tindakan dengan sertifikat yang ditandatangani oleh CA serupa.  Jika diinginkan, Anda dapat menggunakan sertifikat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LetsEncrypt</a> gratis </p><br><p>  Anda dapat mengekspor sertifikat pengembang ke file menggunakan perintah </p><br><pre> <code class="python hljs">dotnet dev-certs https -ep ___.pfx</code> </pre> <br><p>  File harus disalin ke direktori% APPDATA% / ASP.NET / Https / di bawah Windows atau ke /root/.aspnet/https/ di bawah macOS / Linux. </p><br><p>  Agar wadah untuk mengambil jalur ke sertifikat dan kata sandinya, buat rahasia Pengguna dengan konten berikut: </p><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">"Kestrel"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"Certificates"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"Default"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"Path"</span></span>: <span class="hljs-string"><span class="hljs-string">"/root/.aspnet/https/__.pfx"</span></span>, <span class="hljs-string"><span class="hljs-string">"Password"</span></span>: <span class="hljs-string"><span class="hljs-string">"___"</span></span> } } } }</code> </pre> <br><p>  File ini menyimpan data yang tidak terenkripsi dan karena itu digunakan hanya selama pengembangan.  File dibuat di Visual Studio dengan memanggil menu konteks pada ikon proyek atau menggunakan utilitas rahasia pengguna di Linux. </p><br><p>  Pada Windows, file tersebut akan disimpan dalam direktori% APPDATA% \ Microsoft \ UserSecrets \ &lt;user_secrets_id&gt; \ secrets.json, dan pada MacOS dan Linux file itu akan disimpan di ~ / .microsoft / usersecrets / &lt;user_secrets_id&gt; /secrets.json </p><br><p>  Untuk menyimpan pengaturan untuk produksi, beberapa distribusi Linux dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">systemd.</a> Pengaturan disimpan di bawah atribut Layanan.  Misalnya, seperti ini: </p><br><pre> <code class="python hljs">[Service] Environment=<span class="hljs-string"><span class="hljs-string">"Kestrel _ Certificates _ Default _Path=/root/.aspnet/https/__.pfx"</span></span> Environment=<span class="hljs-string"><span class="hljs-string">"Kestrel _ Certificates _ Default _Password=___"</span></span></code> </pre> <br><p>  Selanjutnya, saya akan segera memberikan dan menganalisis versi konfigurasi buruh pelabuhan untuk proksi dan wadah melalui https. </p><br><p>  File penyusun Docker: </p><br><pre> <code class="python hljs">version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo21: image: ${DOCKER_REGISTRY}dockerservicedemo build: context: . dockerfile: DockerServiceDemo/Dockerfile  override: version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo: environment: - ASPNETCORE_ENVIRONMENT=Development - ASPNETCORE_URLS=https://+:<span class="hljs-number"><span class="hljs-number">44392</span></span>;http://+:<span class="hljs-number"><span class="hljs-number">80</span></span> - ASPNETCORE_HTTPS_PORT=<span class="hljs-number"><span class="hljs-number">44392</span></span> ports: - <span class="hljs-string"><span class="hljs-string">"59404:80"</span></span> - <span class="hljs-string"><span class="hljs-string">"44392:44392"</span></span> volumes: - ${APPDATA}/ASP.NET/Https:/root/.aspnet/https:ro - ${APPDATA}/Microsoft/UserSecrets:/root/.microsoft/usersecrets:ro proxy: image: nginx:latest volumes: - ./DockerServiceDemo/nginx.conf:/etc/nginx/nginx.conf - ./DockerServiceDemo/cert.crt:/etc/nginx/cert.crt - ./DockerServiceDemo/cert.rsa:/etc/nginx/cert.rsa ports: - <span class="hljs-string"><span class="hljs-string">"5001:44392"</span></span></code> </pre> <br><p>  Sekarang saya akan menggambarkan momen yang tidak bisa dipahami.  ASPNETCORE_URLS memungkinkan kita untuk tidak menunjukkan dalam kode aplikasi menggunakan aplikasi. Gunakan port yang sedang didengarkan aplikasi. </p><br><p>  ASPNETCORE_HTTPS_PORT melakukan pengalihan serupa dengan apa yang akan dilakukan oleh kode berikut: <br>  services.AddHttpsRedirection (options =&gt; options.HttpsPort = 44392) </p><br><p>  Artinya, lalu lintas dari permintaan http akan dialihkan ke port permintaan https tertentu. <br>  Menggunakan port ditunjukkan bahwa permintaan dari port eksternal 59404 akan dialihkan ke wadah ke-80, dan dari port eksternal 44392 ke 44392.  Secara teoritis, karena kami telah mengonfigurasi server proxy terbalik, kami dapat menghapus port dengan pengalihan ini. <br>  Menggunakan volume, direktori dengan sertifikat pfx dan aplikasi UserSecrets dipasang dengan kata sandi dan tautan ke sertifikat. </p><br><p>  Bagian proxy menunjukkan bahwa permintaan dari port eksternal 5001 akan dialihkan ke port nginx ke-44392.  Selain itu, file konfigurasi nginx dipasang, serta sertifikat dan kunci sertifikat. </p><br><p>  Agar mereka dapat membuat sertifikat pfx tunggal (yang sudah kita miliki) untuk membuat file crt dan rsa, Anda dapat menggunakan OpenSSL.  Pertama, Anda perlu mengekstrak sertifikat: </p><br><pre> <code class="python hljs">openssl pkcs12 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ./_.pfx -clcerts -nokeys -out domain.crt</code> </pre> <br><p>  Dan kemudian kunci pribadi: </p><br><pre> <code class="python hljs">openssl pkcs12 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ./_.pfx -nocerts -nodes -out domain.rsa</code> </pre> <br><p>  Konfigurasi nginx adalah sebagai berikut: </p><br><pre> <code class="python hljs">worker_processes <span class="hljs-number"><span class="hljs-number">4</span></span>; events { worker_connections <span class="hljs-number"><span class="hljs-number">1024</span></span>; } http { sendfile on; upstream app_servers { server dockerservicedemo:<span class="hljs-number"><span class="hljs-number">44392</span></span>; } server { listen <span class="hljs-number"><span class="hljs-number">44392</span></span> ssl; ssl_certificate /etc/nginx/cert.crt; ssl_certificate_key /etc/nginx/cert.rsa; location / { proxy_pass https://app_servers; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } }</code> </pre> <br><p>  Server proxy sedang mendengarkan pada port 44392.  Port ini menerima permintaan dari port host 5001.  Selanjutnya, proksi mengalihkan permintaan ke port 44392 dari wadah dockerdemoservice. </p><br><p>  Setelah memahami contoh-contoh ini, Anda akan mendapatkan latar belakang yang baik untuk bekerja dengan buruh pelabuhan, layanan microser dan nginx. </p><br><p>  Kami mengingatkan Anda bahwa ini adalah versi lengkap dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel dari majalah Hacker</a> .  Penulisnya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alexey Sommer</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435914/">https://habr.com/ru/post/id435914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435904/index.html">AI menerjemahkan aktivitas otak ke dalam ucapan</a></li>
<li><a href="../id435906/index.html">Penyimpanan Cluster Pacemaker + DRBD (Dual primer) + ctdb</a></li>
<li><a href="../id435908/index.html">Web asketis: prototipe pasar loak saat bepergian dan js</a></li>
<li><a href="../id435910/index.html">Mengapa BSD kalah dalam pertempuran dengan GNU / Linux?</a></li>
<li><a href="../id435912/index.html">Masalah utama pengembangan antarmuka modern</a></li>
<li><a href="../id435916/index.html">Meretas VK, otentikasi dua faktor tidak akan menyimpan</a></li>
<li><a href="../id435920/index.html">Buku Masakan Pengembang: Resep DDD (Bagian 4, Struktur)</a></li>
<li><a href="../id435922/index.html">Layanan Java, Spring, Kurento dan media. Bagian 2</a></li>
<li><a href="../id435924/index.html">Jaringan saraf menghasilkan gambar hidangan sesuai dengan resep untuk persiapan mereka</a></li>
<li><a href="../id435926/index.html">Jaringan saraf mengumpulkan fragmen temuan arkeologis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>