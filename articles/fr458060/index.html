<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê• üèà üìñ Cr√©ation d'un shader d'herbe dans le moteur Unity ü§õüèª üèµÔ∏è üòÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce tutoriel vous montrera comment √©crire un ombrage g√©om√©trique pour g√©n√©rer des brins d'herbe √† partir du haut du maillage entrant et utiliser la tes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©ation d'un shader d'herbe dans le moteur Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458060/"><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ce tutoriel vous montrera comment √©crire un ombrage g√©om√©trique pour g√©n√©rer des brins d'herbe √† partir du haut du maillage entrant et utiliser la tessellation pour contr√¥ler la densit√© de l'herbe. <br><br>  L'article d√©crit le processus √©tape par √©tape de l'√©criture d'un shader d'herbe dans Unity.  Le shader re√ßoit le maillage entrant et, √† partir de chaque sommet du maillage, g√©n√®re un brin d'herbe √† l'aide du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">shader g√©om√©trique</a> .  Par souci d'int√©r√™t et de r√©alisme, les brins d'herbe auront une <strong>taille</strong> et une <strong>rotation</strong> <strong>al√©atoires</strong> , et ils seront √©galement affect√©s par le <strong>vent</strong> .  Pour contr√¥ler la densit√© de l'herbe, nous utilisons la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tessellation</a> pour s√©parer le maillage entrant.  L'herbe pourra <strong>projeter</strong> et <strong>recevoir des</strong> ombres. <br><br>  <strong>Le projet termin√©</strong> est affich√© √† la fin de l'article.  Le fichier shader g√©n√©r√© contient un grand nombre de commentaires qui facilitent la compr√©hension. <br><a name="habracut"></a><br><h3>  Pr√©requis </h3><br>  Pour terminer ce didacticiel, vous aurez besoin de connaissances pratiques sur le moteur Unity et d'une compr√©hension initiale de la syntaxe et des fonctionnalit√©s des shaders. <br><br>  <a href="">T√©l√©chargez l'√©bauche du projet (.zip)</a> . <br><br><h2>  Se rendre au travail </h2><br>  T√©l√©chargez le brouillon du projet et ouvrez-le dans l'√©diteur Unity.  Ouvrez la sc√®ne <code>Main</code> , puis ouvrez le shader <code>Grass</code> dans votre √©diteur de code. <br><br>  Ce fichier contient un shader qui produit une couleur blanche, ainsi que certaines fonctions que nous utiliserons dans ce tutoriel.  Vous remarquerez que ces fonctions ainsi que le vertex shader sont inclus dans le bloc <code>CGINCLUDE</code> situ√© √† l' <em>ext√©rieur de</em> <code>SubShader</code> .  Le code plac√© dans ce bloc sera <strong>automatiquement inclus dans toutes les passes</strong> du shader;  cela vous sera utile plus tard car notre shader aura plusieurs passes. <br><br>  Nous allons commencer par √©crire un <strong>shader g√©om√©trique</strong> qui g√©n√®re des triangles √† partir de chaque sommet de la surface de notre maillage. <br><br><h2>  1. Shaders g√©om√©triques </h2><br>  Les shaders g√©om√©triques sont une partie facultative du pipeline de rendu.  Ils sont ex√©cut√©s <strong>apr√®s le</strong> vertex shader (ou le tessellation shader si la tessellation est utilis√©e) et avant que les sommets ne soient trait√©s pour le fragment shader. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef7/c01/458/ef7c01458cadf7cd0cf46695d7114f96.jpg"></div><br>  <i>Pipeline graphique Direct3D 11. Notez que dans ce diagramme, le shader de fragment est appel√© <em>pixel shader</em> .</i> <br><br>  Les shaders g√©om√©triques re√ßoivent une seule <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">primitive</a> en entr√©e et peuvent g√©n√©rer z√©ro, une ou plusieurs primitives.  Nous commencerons par √©crire un shader g√©om√©trique qui re√ßoit un <strong>sommet</strong> (ou <em>point</em> ) en entr√©e, et qui alimente <strong>un triangle</strong> repr√©sentant un brin d'herbe. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add inside the CGINCLUDE block. struct geometryOutput { float4 pos : SV_POSITION; }; [maxvertexcount(3)] void geo(triangle float4 IN[3] : SV_POSITION, inout TriangleStream&lt;geometryOutput&gt; triStream) { } ‚Ä¶ // Add inside the SubShader Pass, just below the #pragma fragment frag line. #pragma geometry geo</span></span></code> </pre> <br>  Le code ci-dessus d√©clare un shader g√©om√©trique appel√© <code>geo</code> avec deux param√®tres.  Le premier, <code>triangle float4 IN[3]</code> , indique qu'il faudra un triangle (compos√© de trois points) en entr√©e.  Le second, tel que <code>TriangleStream</code> , configure un shader pour produire un flux de triangles afin que chaque sommet utilise la structure <code>geometryOutput</code> pour transmettre ses donn√©es. <br><br><div class="spoiler">  <b class="spoiler_title">Nous avons dit ci-dessus que le shader recevra un sommet et produira un brin d'herbe.</b>  <b class="spoiler_title">Pourquoi alors obtenons-nous un triangle?</b> <div class="spoiler_text">  Il sera moins co√ªteux de prendre un <code></code> en entr√©e.  Cela peut √™tre fait comme suit. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">geo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point vertexOutput IN[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">], inout TriangleStream&lt;geometryOutput&gt; triStream)</span></span></span></span></code> </pre> <br>  Cependant, √©tant donn√© que notre maillage entrant (dans ce cas <code>GrassPlane10x10</code> , situ√© dans le dossier <code>Mesh</code> ) a une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">topologie en triangle</a> , cela entra√Ænera une incompatibilit√© entre la topologie du maillage entrant et la primitive d'entr√©e requise.  Bien que cela soit <strong>autoris√©</strong> dans DirectX HLSL, il n'est pas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autoris√© dans OpenGL</a> , donc une erreur sera affich√©e. </div></div><br>  De plus, nous ajoutons le dernier param√®tre entre crochets au-dessus de la d√©claration de fonction: <code>[maxvertexcount(3)]</code> .  Il indique au GPU que nous publierons (mais ne sommes pas <strong>oblig√©s</strong> de le faire) <em>pas plus de</em> 3 sommets.  Nous faisons √©galement en sorte que <code>SubShader</code> utilise un shader g√©om√©trique en le d√©clarant dans <code>Pass</code> . <br><br>  Notre shader g√©om√©trique ne fait encore rien;  pour dessiner un triangle, ajoutez le code suivant √† l'int√©rieur du shader g√©om√©trique. <br><br><pre> <code class="cpp hljs">geometryOutput o; o.pos = float4(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o); o.pos = float4(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o); o.pos = float4(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0db/534/ac1/0db534ac10c125955829fd53b9923cd7.gif"></div><br>  Cela a donn√© des r√©sultats tr√®s √©tranges.  Lorsque vous d√©placez la cam√©ra, il devient clair que le triangle est rendu dans l' <strong>espace √©cran</strong> .  C'est logique: puisque le shader g√©om√©trique est ex√©cut√© imm√©diatement avant le traitement des sommets, il enl√®ve au vertex shader la responsabilit√© des vertices √† afficher dans <strong>l'espace de troncature</strong> .  Nous allons changer notre code pour refl√©ter cela. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the return call in the vertex shader. //return UnityObjectToClipPos(vertex); return vertex; ‚Ä¶ // Update each assignment of o.pos in the geometry shader. o.pos = UnityObjectToClipPos(float4(0.5, 0, 0, 1)); ‚Ä¶ o.pos = UnityObjectToClipPos(float4(-0.5, 0, 0, 1)); ‚Ä¶ o.pos = UnityObjectToClipPos(float4(0, 1, 0, 1));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/221/912/b3e/221912b3e6bc0581126a0f415b6e79c5.png"></div><br>  Maintenant, notre triangle est rendu correctement dans le monde.  Cependant, il semble qu'un seul soit cr√©√©.  En fait, un triangle est <em>dessin√©</em> pour chaque sommet de notre maillage, mais les positions attribu√©es aux sommets du triangle sont <strong>constantes</strong> - elles ne changent pas pour chaque sommet entrant.  Par cons√©quent, tous les triangles sont situ√©s l'un au-dessus de l'autre. <br><br>  Nous allons r√©soudre ce probl√®me en <strong>compensant les</strong> positions des sommets sortants par rapport au point entrant. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the top of the geometry shader. float3 pos = IN[0]; ‚Ä¶ // Update each assignment of o.pos. o.pos = UnityObjectToClipPos(pos + float3(0.5, 0, 0)); ‚Ä¶ o.pos = UnityObjectToClipPos(pos + float3(-0.5, 0, 0)); ‚Ä¶ o.pos = UnityObjectToClipPos(pos + float3(0, 1, 0));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b2/ac4/84c/6b2ac484c5a033b18e88400e10191779.png"></div><br><div class="spoiler">  <b class="spoiler_title">Pourquoi certains sommets ne cr√©ent-ils pas un triangle?</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cab/447/d9c/cab447d9c4c82d8208a28e7cee2f7807.png"></div><br>  Bien que nous ayons d√©termin√© que la primitive entrante sera un <strong>triangle</strong> , un brin d'herbe n'est transmis que par l' <strong>un</strong> des points du triangle, en √©cartant les deux autres.  Bien s√ªr, nous pouvons transf√©rer un brin d'herbe √† partir des trois points entrants, mais cela conduira au fait que les triangles voisins cr√©ent excessivement des brins d'herbe les uns sur les autres. <br><br>  Ou vous pouvez r√©soudre ce probl√®me en prenant des maillages ayant le type de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">points</a> de topologie comme maillages entrants du shader g√©om√©trique. </div></div><br>  Les triangles sont d√©sormais dessin√©s correctement et leur base est situ√©e au sommet qui les √©met.  Avant de continuer, <code>GrassPlane</code> objet <code>GrassPlane</code> dans la sc√®ne et <code>GrassBall</code> objet <code>GrassBall</code> .  Nous voulons que l'herbe se g√©n√®re correctement sur diff√©rents types de surfaces, il est donc important de la tester sur des maillages de formes diff√©rentes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19b/f67/8fb/19bf678fbb6ce3c03956dbdf068004f0.png"></div><br>  Jusqu'√† pr√©sent, tous les triangles sont √©mis dans une seule direction, et non vers l'ext√©rieur de la surface de la sph√®re.  Pour r√©soudre ce probl√®me, nous allons cr√©er des brins d'herbe dans un <strong>espace tangent</strong> . <br><br><h2>  2. Espace tangent </h2><br>  Id√©alement, nous aimerions cr√©er des brins d'herbe en d√©finissant une largeur, une hauteur, une courbure et une rotation diff√©rentes, sans tenir compte de l'angle de la surface √† partir de laquelle le brin d'herbe est √©mis.  Autrement dit, nous d√©finissons un brin d'herbe dans un espace <strong>local au sommet qui l'√©met</strong> , puis le transformons pour qu'il soit <strong>local au maillage</strong> .  Cet espace est appel√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">espace tangent</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fd/8f7/c39/3fd8f7c394bf4eb18cb988aceafe342b.png"></div><br>  <i>Dans l'espace tangent, les axes <strong>X</strong> , <strong>Y</strong> et <strong>Z</strong> sont d√©finis par rapport √† la normale et √† la position de la surface (dans notre cas, les sommets).</i> <br><br>  Comme tout autre espace, nous pouvons d√©finir l'espace tangent d'un sommet avec trois vecteurs: <strong>droite</strong> , <strong>avant</strong> et <strong>haut</strong> .  √Ä l'aide de ces vecteurs, nous pouvons cr√©er une matrice pour transformer le brin d'herbe de l'espace tangent √† l'espace local. <br><br>  Vous pouvez acc√©der aux vecteurs de <strong>droite √† droite</strong> en ajoutant de nouvelles donn√©es de sommet en entr√©e. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. struct vertexInput { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct vertexOutput { float4 vertex : SV_POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; ‚Ä¶ // Modify the vertex shader. vertexOutput vert(vertexInput v) { vertexOutput o; o.vertex = v.vertex; o.normal = v.normal; o.tangent = v.tangent; return o; } ‚Ä¶ // Modify the input for the geometry shader. Note that the SV_POSITION semantic is removed. void geo(triangle vertexOutput IN[3], inout TriangleStream&lt;geometryOutput&gt; triStream) ‚Ä¶ // Modify the existing line declaring pos. float3 pos = IN[0].vertex;</span></span></code> </pre> <br>  Le troisi√®me vecteur peut √™tre calcul√© en prenant le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">produit vectoriel</a> entre deux autres.  Un produit vectoriel renvoie un vecteur <strong>perpendiculaire</strong> √† deux vecteurs entrants. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Place in the geometry shader, below the line declaring float3 pos. float3 vNormal = IN[0].normal; float4 vTangent = IN[0].tangent; float3 vBinormal = cross(vNormal, vTangent) * vTangent.w;</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Pourquoi le r√©sultat du produit vectoriel est-il multipli√© par la coordonn√©e de la tangente w?</b> <div class="spoiler_text">  Lors de l'exportation d'un maillage √† partir d'un √©diteur 3D, il contient g√©n√©ralement des binormaux (√©galement appel√©s <em>tangentes √† deux points</em> ) d√©j√† stock√©s dans les donn√©es de maillage.  Au lieu d'importer ces binormaux, Unity prend simplement la direction de chaque binormal et les affecte √† la coordonn√©e de la tangente <strong>w</strong> .  Cela vous permet d'√©conomiser de la m√©moire, tout en offrant la possibilit√© de recr√©er le binormal correct.  Une discussion d√©taill√©e de ce sujet peut √™tre trouv√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </div></div><br>  Ayant les trois vecteurs, nous pouvons cr√©er une matrice pour la transformation entre les espaces tangents et locaux.  Nous multiplierons chaque sommet du brin d'herbe par cette matrice avant de le passer √† <code>UnityObjectToClipPos</code> , qui attend un sommet dans l'espace local. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the lines declaring the three vectors. float3x3 tangentToLocal = float3x3( vTangent.x, vBinormal.x, vNormal.x, vTangent.y, vBinormal.y, vNormal.y, vTangent.z, vBinormal.z, vNormal.z );</span></span></code> </pre> <br>  Avant d'utiliser la matrice, nous transf√©rons le code de sortie de vertex √† la fonction afin de ne pas √©crire encore et encore les m√™mes lignes de code.  C'est ce qu'on appelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le principe DRY</a> , ou <strong>ne vous r√©p√©tez pas</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. geometryOutput VertexOutput(float3 pos) { geometryOutput o; o.pos = UnityObjectToClipPos(pos); return o; } ‚Ä¶ // Remove the following from the geometry shader. //geometryOutput o; //o.pos = UnityObjectToClipPos(pos + float3(0.5, 0, 0)); //triStream.Append(o); //o.pos = UnityObjectToClipPos(pos + float3(-0.5, 0, 0)); //triStream.Append(o); //o.pos = UnityObjectToClipPos(pos + float3(0, 1, 0)); //triStream.Append(o); // ...and replace it with the code below. triStream.Append(VertexOutput(pos + float3(0.5, 0, 0))); triStream.Append(VertexOutput(pos + float3(-0.5, 0, 0))); triStream.Append(VertexOutput(pos + float3(0, 1, 0)));</span></span></code> </pre> <br>  Enfin, nous multiplions les sommets de sortie par la matrice <code>tangentToLocal</code> , en les alignant correctement avec la normale de leur point d'entr√©e. <br><br><pre> <code class="cpp hljs">triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))));</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/3f8/286/c953f828675a9d4e202c0c9349d37f9d.png" alt="image"></div><br>  Cela ressemble plus √† ce dont nous avons besoin, mais pas tout √† fait raison.  Le probl√®me ici est qu'initialement, nous avons attribu√© la direction ¬´haut¬ª (haut) de l'axe <strong>Y</strong> ;  cependant, dans l'espace tangent, la direction vers le haut est g√©n√©ralement situ√©e le long de l'axe <strong>Z.</strong>  Nous allons maintenant effectuer ces modifications. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the position of the third vertex being emitted. triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0, 0, 1))));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cf/f51/ddb/0cff51ddbea12280cb78a1db9ada1786.png"></div><br><h2>  3. Aspect de l'herbe </h2><br>  Pour que les triangles ressemblent davantage √† des brins d'herbe, vous devez ajouter des couleurs et des variations.  On commence par ajouter un <strong>d√©grad√©</strong> descendant du haut du brin d'herbe. <br><br><h3>  3.1 d√©grad√© de couleurs </h3><br>  Notre objectif est de permettre √† l'artiste de d√©finir deux couleurs - haut et bas, et d'interpoler entre ces deux couleurs il bascule √† la base du brin d'herbe.  Ces couleurs sont d√©j√† d√©finies dans le fichier shader comme <code>_TopColor</code> et <code>_BottomColor</code> .  Pour leur bon √©chantillonnage, vous devez passer <strong>les coordonn√©es UV</strong> au fragment shader. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the geometryOutput struct. float2 uv : TEXCOORD0; ‚Ä¶ // Modify the VertexOutput function signature. geometryOutput VertexOutput(float3 pos, float2 uv) ‚Ä¶ // Add to VertexOutput, just below the line assigning o.pos. o.uv = uv; ‚Ä¶ // Modify the existing lines in the geometry shader. triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0.5, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(-0.5, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0, 0, 1)), float2(0.5, 1)));</span></span></code> </pre> <br>  Nous avons cr√©√© des coordonn√©es UV pour un brin d'herbe en forme de triangle, dont les deux sommets de la base sont situ√©s en bas √† gauche et √† droite, et la pointe sup√©rieure est situ√©e au centre en haut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/165/e39/932/165e399323aaa07e7c4cee728c0c9988.png"></div><br>  <i>Coordonn√©es UV des trois sommets des brins d'herbe.</i>  <i>Bien que nous peignions les brins d'herbe avec un d√©grad√© simple, une disposition similaire de textures vous permet de superposer des textures.</i> <br><br>  Maintenant, nous pouvons √©chantillonner les couleurs du haut et du bas dans le fragment shader avec UV, puis les interpoler avec <code>lerp</code> .  Nous devrons √©galement modifier les param√®tres du fragment shader, en faisant <code>geometryOutput</code> en entr√©e, et pas seulement la position de <code>float4</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the function signature of the fragment shader. float4 frag (geometryOutput i, fixed facing : VFACE) : SV_Target ‚Ä¶ // Replace the existing return call. return float4(1, 1, 1, 1); return lerp(_BottomColor, _TopColor, i.uv.y);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/596/510/51f/59651051f474907a88740e83bc9d4532.png"></div><br><h3>  3.2 Direction al√©atoire de la lame </h3><br>  Pour cr√©er de la variabilit√© et donner √† l'herbe un aspect plus naturel, nous allons faire en sorte que chaque brin d'herbe regarde dans une direction al√©atoire.  Pour ce faire, nous devons cr√©er une matrice de rotation qui fait tourner le brin d'herbe de fa√ßon al√©atoire autour de son axe vers le <strong>haut</strong> . <br><br>  Il y a deux fonctions dans le fichier shader qui nous aideront √† le faire: <code>rand</code> , qui g√©n√®re un nombre al√©atoire √† partir d'une entr√©e en trois dimensions, et <code>AngleAxis3x3</code> , qui re√ßoit l'angle (en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">radians</a> ) et renvoie une matrice qui fait pivoter cette valeur autour de l'axe sp√©cifi√©.  Cette derni√®re fonction fonctionne exactement de la m√™me mani√®re que la fonction C # <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quaternion.AngleAxis</a> (seul <code>AngleAxis3x3</code> renvoie une matrice, pas un quaternion). <br><br>  La fonction <code>rand</code> renvoie un nombre compris entre 0 et 1;  nous le multiplions par <strong>2 Pi</strong> pour obtenir la gamme compl√®te des valeurs angulaires. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring the tangentToLocal matrix. float3x3 facingRotationMatrix = AngleAxis3x3(rand(pos) * UNITY_TWO_PI, float3(0, 0, 1));</span></span></code> </pre> <br>  Nous utilisons la position <code>pos</code> entrante comme graine pour une rotation al√©atoire.  Pour cette raison, chaque brin d'herbe aura sa propre rotation, constante dans chaque cadre. <br><br>  La rotation peut √™tre appliqu√©e au brin d'herbe en le multipliant par la matrice <code>tangentToLocal</code> cr√©√©e.  Notez que la multiplication matricielle n'est <strong>pas</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commutative</a> ;  l'ordre des op√©randes est <strong>important</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring facingRotationMatrix. float3x3 transformationMatrix = mul(tangentToLocal, facingRotationMatrix); ‚Ä¶ // Replace the multiplication matrix operand with our new transformationMatrix. triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0.5, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(-0.5, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0, 0, 1)), float2(0.5, 1)));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09f/c2f/e80/09fc2fe8028b51f78989954e65812cd3.png"></div><br><h3>  3.3 Flexion avant al√©atoire </h3><br>  Si tous les brins d'herbe sont parfaitement align√©s, ils auront la m√™me apparence.  Cela peut convenir √† l'herbe bien entretenue, par exemple, sur une pelouse taill√©e, mais dans la nature, l'herbe ne pousse pas comme √ßa.  Nous allons cr√©er une nouvelle matrice pour faire pivoter l'herbe le long de l'axe <strong>X</strong> , ainsi qu'une propri√©t√© pour contr√¥ler cette rotation. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _BendRotationRandom("Bend Rotation Random", Range(0, 1)) = 0.2 ‚Ä¶ // Add to the CGINCLUDE block. float _BendRotationRandom; ‚Ä¶ // Add to the geometry shader, below the line declaring facingRotationMatrix. float3x3 bendRotationMatrix = AngleAxis3x3(rand(pos.zzx) * _BendRotationRandom * UNITY_PI * 0.5, float3(-1, 0, 0));</span></span></code> </pre> <br>  Encore une fois, nous utilisons la position du brin d'herbe comme une graine al√©atoire, cette fois en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">balayant</a> pour cr√©er une graine unique.  Nous multiplierons √©galement <code>UNITY_PI</code> par <strong>0,5</strong> ;  cela nous donnera un intervalle al√©atoire de 0 ... 90 degr√©s. <br><br>  Nous appliquons √† nouveau cette matrice par rotation, en multipliant tout dans le bon ordre. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the existing line. float3x3 transformationMatrix = mul(mul(tangentToLocal, facingRotationMatrix), bendRotationMatrix);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49c/122/534/49c122534d7298c0f9c646501a708daa.gif"></div><br><h3>  3.4 Largeur et hauteur </h3><br>  Alors que la taille du brin d'herbe est limit√©e √† une largeur de 1 unit√© et une hauteur de 1 unit√©.  Nous ajouterons des propri√©t√©s pour contr√¥ler la taille, ainsi que des propri√©t√©s pour ajouter une variation al√©atoire. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _BladeWidth("Blade Width", Float) = 0.05 _BladeWidthRandom("Blade Width Random", Float) = 0.02 _BladeHeight("Blade Height", Float) = 0.5 _BladeHeightRandom("Blade Height Random", Float) = 0.3 ‚Ä¶ // Add to the CGINCLUDE block. float _BladeHeight; float _BladeHeightRandom; float _BladeWidth; float _BladeWidthRandom; ‚Ä¶ // Add to the geometry shader, above the triStream.Append calls. float height = (rand(pos.zyx) * 2 - 1) * _BladeHeightRandom + _BladeHeight; float width = (rand(pos.xzy) * 2 - 1) * _BladeWidthRandom + _BladeWidth; ‚Ä¶ // Modify the existing positions with our new height and width. triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(width, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(-width, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0, 0, height)), float2(0.5, 1)));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35b/22e/f34/35b22ef34945a576100a152a0e25eec5.png"></div><br>  Les triangles sont maintenant beaucoup plus comme des brins d'herbe, mais aussi trop peu.  Il n'y a tout simplement pas assez de pics dans le maillage entrant pour cr√©er l'impression d'un champ dens√©ment envahi. <br><br>  Une solution consiste √† cr√©er un nouveau maillage plus dense, en utilisant C # ou dans un √©diteur 3D.  Cela fonctionnera, mais ne nous permettra pas de contr√¥ler dynamiquement la densit√© de l'herbe.  Au lieu de cela, nous diviserons le maillage entrant √† l'aide de la <strong>tessellation</strong> . <br><br><h2>  4. Pavage </h2><br>  <strong>La tessellation</strong> est une √©tape facultative du pipeline de rendu, effectu√©e apr√®s le vertex shader et avant le g√©om√©trique shader (le cas √©ch√©ant).  Sa t√¢che consiste √† subdiviser une surface entrante en plusieurs primitives.  La tessellation est impl√©ment√©e en deux √©tapes programmables: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les</a> shaders de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">coque</a> et de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">domaine</a> . <br><br>  Pour les shaders de surface, Unity a une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">impl√©mentation de pavage int√©gr√©e</a> .  Cependant, comme nous <strong>n'utilisons pas de</strong> shaders de surface, nous devrons impl√©menter nos propres shaders de shell et de domaine.  Dans cet article, je ne discuterai pas de la mise en ≈ìuvre de la tessellation en d√©tail, et nous utilisons simplement le fichier <code>CustomTessellation.cginc</code> existant.  Ce fichier est adapt√© de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article Catlike Coding</a> , qui est une excellente source d'informations sur la mise en ≈ìuvre de la tessellation dans Unity. <br><br>  Si nous incluons l'objet <code>TessellationExample</code> dans la sc√®ne, nous verrons qu'il contient d√©j√† du mat√©riel qui impl√©mente la tessellation.  La modification de la propri√©t√© <strong>Uniforme de pavage</strong> illustre l'effet de subdivision. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d8/8a7/f01/2d88a7f01e3a7462ffd0c8f20953b5ca.gif"></div><br>  Nous mettons en place une tessellation dans le shader pour contr√¥ler la densit√© de l'avion, et donc contr√¥ler le nombre de brins d'herbe g√©n√©r√©s.  Vous devez d'abord ajouter le fichier <code>CustomTessellation.cginc</code> .  Nous y ferons r√©f√©rence par son chemin <em>relatif</em> vers le shader. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add inside the CGINCLUDE block, below the other #include statements. #include "Shaders/CustomTessellation.cginc"</span></span></code> </pre> <br>  Si vous ouvrez <code>CustomTessellation.cginc</code> , vous remarquerez que les <code>vertexOutput</code> <code>vertexInput</code> et <code>vertexOutput</code> , ainsi que les vertex shaders, y sont d√©j√† d√©finis.  Pas besoin de les red√©finir dans notre shader d'herbe;  ils peuvent √™tre supprim√©s. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*struct vertexInput { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct vertexOutput { float4 vertex : SV_POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; vertexOutput vert(vertexInput v) { vertexOutput o; o.vertex = v.vertex; o.normal = v.normal; o.tangent = v.tangent; return o; }*/</span></span></code> </pre> <br>  Notez que le <code>CustomTessellation.cginc</code> vertex shader dans <code>CustomTessellation.cginc</code> passe simplement l'entr√©e directement √† l'√©tape de tessellation;  la fonction <code>vertexOutput</code> , appel√©e √† l'int√©rieur du shader de domaine, se charge de cr√©er la structure <code>vertexOutput</code> . <br><br>  Maintenant, nous pouvons ajouter <strong>des</strong> shaders de <strong>shell</strong> et de <strong>domaine</strong> au shader d'herbe.  Nous ajouterons √©galement une nouvelle propri√©t√© <code>_TessellationUniform</code> pour contr√¥ler la taille de l'unit√© - la variable correspondant √† cette propri√©t√© a d√©j√† √©t√© d√©clar√©e dans <code>CustomTessellation.cginc</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _TessellationUniform("Tessellation Uniform", Range(1, 64)) = 1 ‚Ä¶ // Add below the other #pragma statements in the SubShader Pass. #pragma hull hull #pragma domain domain</span></span></code> </pre> <br>  La modification de la propri√©t√© <strong>Tessellation Uniform</strong> nous permet d√©sormais de contr√¥ler la densit√© de l'herbe.  J'ai trouv√© que de bons r√©sultats sont obtenus avec une valeur de <strong>5</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/280/d93/c14/280d93c1420a9744bd56f2d2496f96ab.gif"></div><br><h2>  5. Le vent </h2><br>  Nous impl√©mentons le vent en √©chantillonnant la <strong>texture de distorsion</strong> .  Cette texture ressemblera √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une carte normale</a> , seulement il y aura seulement deux au lieu de trois canaux.  Nous utiliserons ces deux canaux comme directions du vent le long de <strong>X</strong> et <strong>Y.</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a58/aaa/687/a58aaa68742934ff1bddf1cbaf9564f5.png"></div><br>  Avant d'√©chantillonner la texture du vent, nous devons cr√©er une coordonn√©e UV.  Au lieu d'utiliser les coordonn√©es de texture affect√©es au maillage, nous appliquons la position du point entrant.  Gr√¢ce √† cela, s'il y a plusieurs mailles d'herbe dans le monde, l'illusion sera cr√©√©e qu'elles font toutes partie du m√™me syst√®me de vent.  Nous utilisons √©galement la <code>_Time</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">int√©gr√©e</a> <code>_Time</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">shader</a> pour faire d√©filer la texture du vent le long de la surface de l'herbe. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _WindDistortionMap("Wind Distortion Map", 2D) = "white" {} _WindFrequency("Wind Frequency", Vector) = (0.05, 0.05, 0, 0) ‚Ä¶ // Add to the CGINCLUDE block. sampler2D _WindDistortionMap; float4 _WindDistortionMap_ST; float2 _WindFrequency; ‚Ä¶ // Add to the geometry shader, just above the line declaring the transformationMatrix. float2 uv = pos.xz * _WindDistortionMap_ST.xy + _WindDistortionMap_ST.zw + _WindFrequency * _Time.y;</span></span></code> </pre> <br>  Nous appliquons l'√©chelle et le d√©calage de <code>_WindDistortionMap</code> √† la position, puis le <code>_Time.y</code> vers <code>_Time.y</code> , mis √† l'√©chelle vers <code>_WindFrequency</code> .  Nous allons maintenant utiliser ces UV pour √©chantillonner la texture et cr√©er une propri√©t√© pour contr√¥ler la force du vent. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _WindStrength("Wind Strength", Float) = 1 ‚Ä¶ // Add to the CGINCLUDE block. float _WindStrength; ‚Ä¶ // Add below the line declaring float2 uv. float2 windSample = (tex2Dlod(_WindDistortionMap, float4(uv, 0, 0)).xy * 2 - 1) * _WindStrength;</span></span></code> </pre> <br>  Notez que nous mettons √† l'√©chelle la valeur √©chantillonn√©e √† partir de la texture de l'intervalle 0 ... 1 √† l'intervalle -1 ... 1.  Ensuite, nous pouvons cr√©er un vecteur normalis√© indiquant la direction du vent. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float2 windSample. float3 wind = normalize(float3(windSample.x, windSample.y, 0));</span></span></code> </pre> <br>  Nous pouvons maintenant cr√©er une matrice pour tourner autour de ce vecteur et la multiplier par notre <code>transformationMatrix</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float3 wind. float3x3 windRotation = AngleAxis3x3(UNITY_PI * windSample, wind); ‚Ä¶ // Modify the existing line. float3x3 transformationMatrix = mul(mul(mul(tangentToLocal, windRotation), facingRotationMatrix), bendRotationMatrix);</span></span></code> </pre> <br>  Enfin, nous transf√©rons la texture <code>Wind</code> (situ√©e √† la racine du projet) dans le champ <strong>Wind Distortion Map</strong> du mat√©riau d'herbe dans l'√©diteur Unity.  Nous avons √©galement d√©fini le param√®tre de <strong>mosa√Øque</strong> de la texture sur <code>0.01, 0.01</code> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Si l'herbe n'est pas anim√©e dans la fen√™tre <strong>Sc√®ne</strong> , cliquez sur le bouton <strong>Basculer la skybox, le brouillard et divers autres effets</strong> pour activer les mat√©riaux anim√©s. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De loin, l'herbe semble droite, mais si on regarde de pr√®s le brin d'herbe, on remarque que tout le brin d'herbe tourne, c'est pourquoi la base n'est plus attach√©e au sol. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e9/148/51e/6e914851e888c448c30080a7abefae33.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La base du brin d'herbe n'est plus attach√©e au sol, mais l'intersecte (repr√©sent√©e en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rouge</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et pend au-dessus du plan du sol (indiqu√© par la </font><font style="vertical-align: inherit;">ligne </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verte</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons corriger cela en d√©finissant une deuxi√®me matrice de transformation, qui ne s'applique qu'√† deux sommets de la base. </font><font style="vertical-align: inherit;">Dans cette matrice </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne sera pas</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> matrice incluse </font></font><code>windRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>bendRotationMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, gr√¢ce √† laquelle la base est fix√©e √† la surface de l' </font><font style="vertical-align: inherit;">herbe.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float3x3 transformationMatrix. float3x3 transformationMatrixFacing = mul(tangentToLocal, facingRotationMatrix); ‚Ä¶ // Modify the existing lines outputting the base vertex positions. triStream.Append(VertexOutput(pos + mul(transformationMatrixFacing, float3(width, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrixFacing, float3(-width, 0, 0)), float2(1, 0)));</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Courbure des brins d'herbe </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©sormais, les brins d'herbe sont d√©finis par un triangle. √Ä grande distance, ce n'est pas un probl√®me, mais pr√®s du brin d'herbe, ils ont l'air tr√®s rigides et g√©om√©triques, plut√¥t qu'organiques et vivants. Nous allons r√©soudre ce probl√®me en construisant des brins d'herbe √† partir de plusieurs triangles et en les pliant le long de la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">courbe</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque brin d'herbe sera divis√© en plusieurs </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segments</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Chaque segment aura une forme rectangulaire et se composera de deux triangles, √† l'exception du segment sup√©rieur - ce sera un triangle d√©signant la pointe du brin d'herbe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, nous n'avons dessin√© que trois sommets, cr√©ant un seul triangle. Comment, s'il y a plus de sommets, le shader g√©om√©trique sait-il lesquels joindre et former des triangles? La r√©ponse est dans la structure des donn√©es</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bande de triangle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Les trois premiers sommets se rejoignent et forment un triangle, et chaque nouveau sommet forme un triangle avec les deux pr√©c√©dents.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/871/8ec/676/8718ec676d7efd819718bd25d5b27b54.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brin d'herbe subdivis√©, repr√©sent√© par une bande triangulaire et cr√©√© un sommet √† la fois. Apr√®s les trois premiers sommets, chaque nouveau sommet forme un nouveau triangle avec les deux sommets pr√©c√©dents.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ceci est non seulement plus efficace en termes d'utilisation de la m√©moire, mais vous permet √©galement de cr√©er facilement et rapidement des s√©quences de triangles dans votre code. Si nous voulions cr√©er plusieurs bandes de triangles, nous pourrions appeler </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">RestartStrip</font></a><font style="vertical-align: inherit;"> pour la </font></font><code>TriangleStream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonction </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Avant de commencer √† dessiner plus de sommets √† partir du shader g√©om√©trique, nous devons l'augmenter </font><font style="vertical-align: inherit;">. Nous utiliserons la conception </font><font style="vertical-align: inherit;">pour permettre √† l'auteur du shader de contr√¥ler le nombre de segments et de calculer le nombre de sommets affich√©s √† partir de celui-ci.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>maxvertexcount</code><font style="vertical-align: inherit;"></font><code>#define</code><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. #define BLADE_SEGMENTS 3 ‚Ä¶ // Modify the existing line defining the maxvertexcount. [maxvertexcount(BLADE_SEGMENTS * 2 + 1)]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialement, nous avons d√©fini le nombre de segments sur </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et mis √† jour </font></font><code>maxvertexcount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour calculer le nombre de sommets en fonction du nombre de segments. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cr√©er un brin d'herbe segment√©, nous utilisons un cycle </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Chaque it√©ration de la boucle ajoutera </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deux sommets</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gauche</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">droite</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Apr√®s avoir termin√© la pointe, nous ajoutons le dernier sommet √† la pointe du brin d'herbe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de faire cela, il sera utile de d√©placer une partie de la position de calcul des sommets des brins d'herbe du code dans la fonction, car nous utiliserons ce code plusieurs fois √† l'int√©rieur et √† l'ext√©rieur de la boucle. Ajoutez ce qui </font></font><code>CGINCLUDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suit </font><font style="vertical-align: inherit;">au bloc </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">geometryOutput </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateGrassVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 vertexPosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, float2 uv, float3x3 transformMatrix)</span></span></span><span class="hljs-function"> </span></span>{ float3 tangentPoint = float3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, height); float3 localPosition = vertexPosition + mul(transformMatrix, tangentPoint); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VertexOutput(localPosition, uv); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette fonction effectue les m√™mes t√¢ches car elle passe les arguments que nous avons pass√©s pr√©c√©demment </font></font><code>VertexOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour g√©n√©rer les sommets du brin d'herbe. </font><font style="vertical-align: inherit;">En obtenant une position, une hauteur et une largeur, il transforme correctement le sommet √† l'aide de la matrice transmise et lui assigne une coordonn√©e UV. </font><font style="vertical-align: inherit;">Nous mettrons √† jour le code existant pour que la fonction fonctionne correctement.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the existing code outputting the vertices. triStream.Append(GenerateGrassVertex(pos, width, 0, float2(0, 0), transformationMatrixFacing)); triStream.Append(GenerateGrassVertex(pos, -width, 0, float2(1, 0), transformationMatrixFacing)); triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonction a commenc√© √† fonctionner correctement et nous sommes pr√™ts √† d√©placer le code de g√©n√©ration de vertex dans la boucle </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ajoutez ce qui </font></font><code>float width</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suit </font><font style="vertical-align: inherit;">sous la ligne </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; BLADE_SEGMENTS; i++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = i / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)BLADE_SEGMENTS; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous annon√ßons un cycle qui sera ex√©cut√© une fois pour chaque brin d'herbe. </font><font style="vertical-align: inherit;">√Ä l'int√©rieur de la boucle, ajoutez une variable </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cette variable stockera une valeur dans la plage 0 ... 1, indiquant jusqu'o√π nous nous sommes d√©plac√©s le long du brin d'herbe. </font><font style="vertical-align: inherit;">Nous utilisons cette valeur pour calculer la largeur et la hauteur du segment √† chaque it√©ration de la boucle.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float t. float segmentHeight = height * t; float segmentWidth = width * (1 - t);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous montez un brin d'herbe, la hauteur augmente et la largeur diminue. </font><font style="vertical-align: inherit;">Maintenant, nous pouvons ajouter des appels √† la boucle </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour ajouter des sommets au flux de triangles. </font><font style="vertical-align: inherit;">Nous ajouterons √©galement un appel en </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dehors de la boucle pour cr√©er la pointe du brin d'herbe.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float segmentWidth. float3x3 transformMatrix = i == 0 ? transformationMatrixFacing : transformationMatrix; triStream.Append(GenerateGrassVertex(pos, segmentWidth, segmentHeight, float2(0, t), transformMatrix)); triStream.Append(GenerateGrassVertex(pos, -segmentWidth, segmentHeight, float2(1, t), transformMatrix)); ‚Ä¶ // Add just below the loop to insert the vertex at the tip of the blade. triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix)); ‚Ä¶ // Remove the existing calls to triStream.Append. //triStream.Append(GenerateGrassVertex(pos, width, 0, float2(0, 0), transformationMatrixFacing)); //triStream.Append(GenerateGrassVertex(pos, -width, 0, float2(1, 0), transformationMatrixFacing)); //triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetez un oeil √† la ligne avec la d√©claration </font></font><code>float3x3 transformMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ici, nous s√©lectionnons l'une des deux matrices de transformation: nous prenons </font></font><code>transformationMatrixFacing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour les sommets de la base et </font></font><code>transformationMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour toutes les autres.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/211/61c/02b21161cd4afc0cca35ae71ffe2570e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les brins d'herbe sont maintenant divis√©s en plusieurs segments, mais la surface des lames est toujours plate - de nouveaux triangles ne sont pas encore impliqu√©s. </font><font style="vertical-align: inherit;">Nous allons ajouter une lame de courbure de l' </font><font style="vertical-align: inherit;">herbe, d√©calant la position du sommet de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tout d'abord, nous devons modifier la fonction </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin qu'elle obtienne un d√©calage en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que nous appellerons </font></font><code>forward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the function signature of GenerateGrassVertex. geometryOutput GenerateGrassVertex(float3 vertexPosition, float width, float height, float forward, float2 uv, float3x3 transformMatrix) ‚Ä¶ // Modify the Y coordinate assignment of tangentPoint. float3 tangentPoint = float3(width, forward, height);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour calculer le d√©placement de chaque sommet, nous substituons une </font></font><code>pow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur </font><font style="vertical-align: inherit;">√† la fonction </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Apr√®s avoir atteint </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une puissance, son effet sur le d√©placement vers l'avant sera </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">non lin√©aire</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et transformera le brin d'herbe en courbe.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _BladeForward("Blade Forward Amount", Float) = 0.38 _BladeCurve("Blade Curvature Amount", Range(1, 4)) = 2 ‚Ä¶ // Add to the CGINCLUDE block. float _BladeForward; float _BladeCurve; ‚Ä¶ // Add inside the geometry shader, below the line declaring float width. float forward = rand(pos.yyz) * _BladeForward; ‚Ä¶ // Add inside the loop, below the line declaring segmentWidth. float segmentForward = pow(t, _BladeCurve) * forward; ‚Ä¶ // Modify the GenerateGrassVertex calls inside the loop. triStream.Append(GenerateGrassVertex(pos, segmentWidth, segmentHeight, segmentForward, float2(0, t), transformMatrix)); triStream.Append(GenerateGrassVertex(pos, -segmentWidth, segmentHeight, segmentForward, float2(1, t), transformMatrix)); ‚Ä¶ // Modify the GenerateGrassVertex calls outside the loop. triStream.Append(GenerateGrassVertex(pos, 0, height, forward, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit d'un morceau de code assez volumineux, mais tout le travail est effectu√© de la m√™me mani√®re que pour la largeur et la hauteur du brin d'herbe. </font><font style="vertical-align: inherit;">Avec des valeurs plus basses </font></font><code>_BladeForward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>_BladeCurve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous obtenons une pelouse bien entretenue et ordonn√©e, et des valeurs plus grandes donneront l'effet inverse.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1f/cbc/e43/c1fcbce43fa5e1c1be319dc1f5190f3d.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. √âclairage et ombres </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme derni√®re √©tape pour terminer le shader, nous ajouterons la possibilit√© de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projeter</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recevoir des</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ombres. </font><font style="vertical-align: inherit;">Nous ajouterons √©galement un √©clairage simple √† partir de la principale source de lumi√®re directionnelle.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.1 Projection d'ombres </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour projeter des ombres dans Unity, vous devez ajouter une deuxi√®me passe au shader. Ce passage sera utilis√© par les sources de lumi√®re cr√©ant des ombres dans la sc√®ne pour rendre la profondeur de l'herbe dans leur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">carte des ombres</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cela signifie que le shader g√©om√©trique devra √™tre lanc√© dans le passage d'ombre, afin que les brins d'herbe puissent projeter des ombres. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que le shader g√©om√©trique est √©crit √† l'int√©rieur des blocs </font></font><code>CGINCLUDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous pouvons l'utiliser dans toutes les passes du fichier. Cr√©ez un deuxi√®me passage qui utilisera les m√™mes shaders que le premier, √† l'exception du fragment shader - nous en d√©finirons un nouveau dans lequel nous √©crirons une macro qui traite la sortie.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the existing Pass. Pass { Tags { "LightMode" = "ShadowCaster" } CGPROGRAM #pragma vertex vert #pragma geometry geo #pragma fragment frag #pragma hull hull #pragma domain domain #pragma target 4.6 #pragma multi_compile_shadowcaster float4 frag(geometryOutput i) : SV_Target { SHADOW_CASTER_FRAGMENT(i) } ENDCG }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En plus de cr√©er un nouveau shader de fragment, il y a quelques diff√©rences importantes dans ce passage. </font><font style="vertical-align: inherit;">Le libell√© </font></font><code>LightMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">importe </font></font><code>ShadowCaster</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, non </font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- cela indique √† Unity que ce passage doit √™tre utilis√© pour rendre l'objet en textures ombr√©es. </font><font style="vertical-align: inherit;">Il existe √©galement une directive de pr√©processeur ici </font></font><code>multi_compile_shadowcaster</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il garantit que le shader compile toutes les options n√©cessaires pour projeter des ombres. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendez l'objet de jeu </font></font><code>Fence</code> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actif</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans la sc√®ne; </font><font style="vertical-align: inherit;">nous obtenons donc une surface sur laquelle les brins d'herbe peuvent projeter une ombre.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c57/640/6cf/c576406cf284fe41e4b04d8af264d96e.png"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.2 Obtention d'ombres </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une fois que Unity a rendu la carte des ombres du point de vue de la source de lumi√®re cr√©ant l'ombre, il lance un passage qui "recueille" les ombres dans la texture de l' </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espace d'√©cran</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pour √©chantillonner cette texture, nous devrons calculer les positions des sommets dans l'espace d'√©cran et les transf√©rer vers le fragment shader.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the geometryOutput struct. unityShadowCoord4 _ShadowCoord : TEXCOORD1; ‚Ä¶ // Add to the VertexOutput function, just above the return call. o._ShadowCoord = ComputeScreenPos(o.pos);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le fragment shader du passage, </font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous pouvons utiliser une macro pour obtenir une valeur </font></font><code>float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indiquant si la surface est dans l'ombre ou non. </font><font style="vertical-align: inherit;">Cette valeur se situe dans la plage 0 ... 1, o√π 0 est l'ombrage complet, 1 est l'√©clairage complet.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi la coordonn√©e UV de l'espace d'√©cran s'appelle _ShadowCoord? </font><font style="vertical-align: inherit;">Cela n'est pas conforme aux conventions de d√©nomination pr√©c√©dentes.</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De nombreux shaders Unity int√©gr√©s font des hypoth√®ses sur les noms de certains champs dans diverses structures de shaders (certains font m√™me des hypoth√®ses sur les noms des structures elles-m√™mes). </font><font style="vertical-align: inherit;">Il en va de m√™me pour la macro utilis√©e ci-dessous </font></font><code>SHADOW_ATTENUATION</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si nous extrayons le code source de cette macro </font></font><code>Autolight.cginc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous verrons que la coordonn√©e ombr√©e doit avoir un nom sp√©cifique.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SHADOW_ATTENUATION(a) unitySampleShadow(a._ShadowCoord)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si nous souhaitons cr√©er un autre nom pour cette coordonn√©e, ou pour une raison quelconque, nous en aurions besoin, nous pourrions simplement copier cette d√©finition dans notre propre shader. </font></font></div></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase pass's fragment shader, replacing the existing return call. return SHADOW_ATTENUATION(i); //return lerp(_BottomColor, _TopColor, i.uv.y);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, nous devons configurer le shader correctement pour recevoir les ombres. </font><font style="vertical-align: inherit;">Pour ce faire, nous allons ajouter une </font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">directive de pr√©processeur </font><font style="vertical-align: inherit;">√† la passe </font><font style="vertical-align: inherit;">afin qu'elle compile toutes les options de shader n√©cessaires.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase pass's preprocessor directives, below #pragma target 4.6. #pragma multi_compile_fwdbase</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90a/491/468/90a491468a1ad129d35bea03b0b51898.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir rapproch√© la cam√©ra, nous pouvons remarquer des artefacts √† la surface des brins d'herbe; </font><font style="vertical-align: inherit;">elles sont caus√©es par le fait que des brins d'herbe individuels se projettent des ombres sur eux-m√™mes. </font><font style="vertical-align: inherit;">Nous pouvons r√©soudre ce probl√®me en appliquant un </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©calage lin√©aire</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou en √©loignant l√©g√®rement les positions des sommets de l'espace de troncature de l'√©cran. </font><font style="vertical-align: inherit;">Nous utiliserons la macro Unity pour cela et l'inclurons dans la conception </font></font><code>#if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin que l'op√©ration soit effectu√©e uniquement dans le chemin de l'ombre.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add at the end of the VertexOutput function, just above the return call. #if UNITY_PASS_SHADOWCASTER // Applying the bias prevents artifacts from appearing on the surface. o.pos = UnityApplyLinearShadowBias(o.pos); #endif</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dca/ec0/d88/dcaec0d88eea1893b6a07eb45724a0b6.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir appliqu√© le d√©calage d'ombre lin√©aire, les artefacts d'ombre sous forme de rayures disparaissent de la surface des triangles.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi y a-t-il des artefacts le long des bords des brins d'herbe ombrag√©s?</font></font></b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08a/12e/af1/08a12eaf1af17fc9b35de7d07a64afca.png"></div><br>      (multisample anti-aliasing <strong>MSAA</strong> ) Unity <em> </em>     ,        .        ,  . <br><br>    ‚Äî  ,    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  Unity</a> .      (     );     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    Unity</a> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.3 √âclairage </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons impl√©menter l'√©clairage en utilisant un algorithme de calcul d'√©clairage diffus tr√®s simple et commun.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/404/3ae/452/4043ae452046c0b4b405aa88afe8d2b7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... o√π </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est la normale √† la surface, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est la direction normalis√©e de la source principale d'√©clairage directionnel et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est l'√©clairage calcul√©. </font><font style="vertical-align: inherit;">Dans ce didacticiel, nous </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'impl√©menterons pas d'</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √©clairage indirect. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour l'instant, les normales ne sont pas attribu√©es aux sommets des brins d'herbe. </font><font style="vertical-align: inherit;">Comme pour les positions des sommets, nous calculons d'abord les normales dans l' </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espace tangent</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puis les convertissons en locales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quantit√© de courbure de lame</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tous les brins d'herbe dans l'espace tangent sont dirig√©s dans une direction: directement en face de l'axe </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Comme premier passage de notre solution, nous calculons la normale, en supposant qu'il n'y a pas de courbure.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the GenerateGrassVertex function, belowing the line declaring tangentPoint. float3 tangentNormal = float3(0, -1, 0); float3 localNormal = mul(transformMatrix, tangentNormal);</span></span></code> </pre> <br> <code>tangentNormal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, d√©fini comme directement oppos√© √† l'axe </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , est transform√© par la m√™me matrice que celle utilis√©e pour convertir les points tangents en espace local. </font><font style="vertical-align: inherit;">Maintenant, nous pouvons le passer √† une fonction </font></font><code>VertexOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis √† une structure </font></font><code>geometryOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the return call in GenerateGrassVertex. return VertexOutput(localPosition, uv, localNormal); ‚Ä¶ // Add to the geometryOutput struct. float3 normal : NORMAL; ‚Ä¶ // Modify the existing function signature. geometryOutput VertexOutput(float3 pos, float2 uv, float3 normal) ‚Ä¶ // Add to the VertexOutput function to pass the normal through to the fragment shader. o.normal = UnityObjectToWorldNormal(normal);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez qu'avant la conclusion, nous transformons la normale en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espace mondial</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">L'unit√© transmet aux shaders la direction de la principale source de lumi√®re directionnelle dans l'espace mondial, cette transformation est donc n√©cessaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant visualiser les normales dans le fragment de shader </font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour v√©rifier le r√©sultat de notre travail.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase fragment shader. float3 normal = facing &gt; 0 ? i.normal : -i.normal; return float4(normal * 0.5 + 0.5, 1); // Remove the existing return call. //return SHADOW_ATTENUATION(i);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisqu'une </font></font><code>Cull</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur est assign√©e </font><font style="vertical-align: inherit;">dans notre shader </font></font><code>Off</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, les deux c√¥t√©s du brin d'herbe sont rendus. </font><font style="vertical-align: inherit;">Pour que la normale soit dirig√©e dans la bonne direction, nous utilisons un param√®tre auxiliaire </font></font><code>VFACE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que nous avons ajout√© au fragment shader. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'argument </font></font><code>fixed facing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renverra un </font><font style="vertical-align: inherit;">nombre </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">positif</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si nous affichons la face avant de la surface, et un </font><font style="vertical-align: inherit;">nombre </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√©gatif</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si c'est le contraire. </font><font style="vertical-align: inherit;">Nous utilisons cela dans le code ci-dessus pour retourner la normale si n√©cessaire.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/8ca/965/e1b8ca965ed8e80b539a9773d1adeb0c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quantit√© de courbure de lame est</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sup√©rieure √† 1, la position tangente </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><font style="vertical-align: inherit;">chaque sommet sera d√©cal√©e de la quantit√© </font></font><code>forward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transmise √† la fonction </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous utiliserons cette valeur pour mettre √† l'√©chelle proportionnellement l'axe </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des </font><font style="vertical-align: inherit;">normales.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the existing line in GenerateGrassVertex. float3 tangentNormal = normalize(float3(0, -1, forward));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, ajoutez le code au fragment shader pour combiner les ombres, l'√©clairage directionnel et l'√©clairage ambiant. </font><font style="vertical-align: inherit;">Je recommande d'√©tudier des informations plus d√©taill√©es sur la mise en ≈ìuvre de l'√©clairage personnalis√© dans les shaders dans mon </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tutoriel sur les toon shaders</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase fragment shader, below the line declaring float3 normal. float shadow = SHADOW_ATTENUATION(i); float NdotL = saturate(saturate(dot(normal, _WorldSpaceLightPos0)) + _TranslucentGain) * shadow; float3 ambient = ShadeSH9(float4(normal, 1)); float4 lightIntensity = NdotL * _LightColor0 + float4(ambient, 1); float4 col = lerp(_BottomColor, _TopColor * lightIntensity, i.uv.y); return col; // Remove the existing return call. //return float4(normal * 0.5 + 0.5, 1);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/894/d14/c14894d14edc336b770f4b94bedd3708.png"></div><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce didacticiel, l'herbe couvre une petite zone de 10 x 10 unit√©s. </font><font style="vertical-align: inherit;">Pour que le shader couvre de grands espaces ouverts tout en maintenant des performances √©lev√©es, des optimisations doivent √™tre introduites. </font><font style="vertical-align: inherit;">Vous pouvez appliquer la tessellation en fonction de la distance afin que moins de brins d'herbe soient √©loign√©s de la cam√©ra. </font><font style="vertical-align: inherit;">De plus, sur de longues distances, au lieu de brins d'herbe individuels, des groupes de brins d'herbe peuvent √™tre dessin√©s en utilisant un seul quadrilat√®re avec une texture superpos√©e.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/a05/e86/5a7a05e8690c152f9196bb3c94fada19.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture de l'herbe incluse dans </font><font style="vertical-align: inherit;">le </font><font style="vertical-align: inherit;">package d' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actifs standard</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> du moteur Unity. </font><font style="vertical-align: inherit;">De nombreux brins d'herbe sont dessin√©s sur un seul quadrilat√®re, ce qui r√©duit le nombre de triangles dans la sc√®ne. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous ne puissions pas utiliser nativement des shaders g√©om√©triques avec des shaders de surface, pour am√©liorer ou √©tendre les fonctionnalit√©s d'√©clairage et d'ombrage, si vous devez utiliser le mod√®le d'√©clairage Unity standard, vous pouvez √©tudier </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce r√©f√©rentiel GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui d√©montre la solution au probl√®me par un rendu retard√© et un remplissage manuel des tampons G. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code source de shader dans le r√©f√©rentiel GitHub</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Addition: coop√©ration </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sans interop√©rabilit√©, les effets graphiques peuvent sembler statiques ou sans vie aux joueurs. </font><font style="vertical-align: inherit;">Ce tutoriel est d√©j√† tr√®s long, donc je n'ai pas ajout√© de section sur l'interaction des objets du monde avec l'herbe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une impl√©mentation na√Øve d'herbes interactives contiendrait deux √©l√©ments: quelque chose dans le monde du jeu qui peut </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transmettre des donn√©es</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au shader pour lui dire avec quelle partie de l'herbe interagit, et coder dans le shader pour </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interpr√©ter</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ces donn√©es. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un exemple de la fa√ßon dont cela peut √™tre mis en ≈ìuvre avec de l'eau est pr√©sent√© </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il peut √™tre adapt√© pour travailler avec de l'herbe; </font><font style="vertical-align: inherit;">au lieu de dessiner des ondulations √† l'endroit o√π se trouve le personnage, vous pouvez tourner le brin d'herbe vers le bas pour simuler les effets des pas.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458060/">https://habr.com/ru/post/fr458060/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458046/index.html">Gradle Cheat Sheet</a></li>
<li><a href="../fr458048/index.html">La d√©l√©gation comme outil de gestion</a></li>
<li><a href="../fr458050/index.html">Comment √©tait le Mobius 2019 Piter (et un peu plus sur le prochain Mobius)</a></li>
<li><a href="../fr458052/index.html">AMA avec Habr.10. Dernier * num√©ro</a></li>
<li><a href="../fr458056/index.html">La grande interview de Martin Kleppmann: ¬´Comprendre l'avenir des syst√®mes de donn√©es distribu√©s¬ª</a></li>
<li><a href="../fr458062/index.html">Pr√©sentation de la plateforme UserGate</a></li>
<li><a href="../fr458064/index.html">PVS-Studio dans les nuages ‚Äã‚Äã- Ex√©cution de l'analyse sur Travis CI</a></li>
<li><a href="../fr458068/index.html">PVS-Studio pour Visual Studio</a></li>
<li><a href="../fr458070/index.html">PVS-Studio pour Visual Studio</a></li>
<li><a href="../fr458072/index.html">PVS-Studio passe aux nuages ‚Äã‚Äã- lancement de l'analyse sur Travis CI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>