<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤üèª ‚öúÔ∏è üôçüèΩ Latenzzahlen auf dem iPhone üíè üàµ üçë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Latenzzahlen, die jeder Programmierer kennen sollte - eine Tabelle mit "Verz√∂gerungen, die jeder Programmierer kennen sollte". Es enth√§lt die durchsch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Latenzzahlen auf dem iPhone</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/437590/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Latenzzahlen, die jeder Programmierer kennen sollte</a> - eine Tabelle mit "Verz√∂gerungen, die jeder Programmierer kennen sollte".  Es enth√§lt die durchschnittlichen Zeitwerte f√ºr die Durchf√ºhrung grundlegender Computeroperationen im Jahr 2012.  Es gibt mehrere alternative Ansichten f√ºr diese Tabelle, und hier ist eine davon. <br><br><img src="https://habrastorage.org/webt/oa/i4/ho/oai4hogxseqehs_ciso1lz9q_io.png"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> zur Schemaquelle</i> <br><br>  Aber was ist der Nutzen dieser Informationen f√ºr mobile Entwickler im Jahr 2019?  Es scheint, dass nein, aber <b>Dmitry Kurkin</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">SClown</a> ) vom Yandex.Navigator-Team dachte: "Wie w√ºrde der Tisch f√ºr ein modernes iPhone aussehen?"  Was dabei herauskam, in einer √ºberarbeiteten Textversion von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dmitrys</a> Bericht √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppsConf</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/cyzo48f0exw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Wof√ºr ist das? </h2><br>  Warum sollten Programmierer diese Nummern kennen?  Und sind sie f√ºr mobile Entwickler relevant?  Es gibt zwei Hauptaufgaben, die mit Hilfe dieser Zahlen gel√∂st werden k√∂nnen. <br><a name="habracut"></a><br><h3>  Die Zeitskala eines Computers verstehen </h3> <br>  Nehmen Sie eine einfache Situation - ein Telefongespr√§ch.  Wir k√∂nnen leicht erkennen, wann dieser Prozess schnell und wann er lang ist: Ein paar Sekunden sind sehr schnell, ein paar Minuten sind ein durchschnittliches Gespr√§ch und eine Stunde oder mehr ist sehr lang.  Beim Laden von Seiten ist es √§hnlich: In weniger als einer Sekunde - schnell, in wenigen Sekunden - ertr√§glich und eine Minute ist eine Katastrophe. Der Benutzer wartet m√∂glicherweise nicht auf den Download. <br><br>  Aber was ist mit Operationen wie dem Hinzuf√ºgen einer Nummer zu einem Array - der sehr ‚Äûschnellen Einf√ºgung‚Äú, √ºber die die Leute manchmal gerne in Interviews sprechen?  Wie viel kostet ein Smartphone?  Nanosekunden, Mikrosekunden oder Millisekunden?  Ich habe nur wenige Leute getroffen, die sagen k√∂nnten, dass 1 Millisekunde eine lange Zeit ist, aber in unserem Fall ist es so. <br><br><h3>  Das Verh√§ltnis der Geschwindigkeit verschiedener Computerkomponenten </h3><br>  Die Ausf√ºhrungszeit von Vorg√§ngen auf verschiedenen Ger√§ten kann zehn- oder hundertfach variieren.  Beispielsweise unterscheidet sich die Zugriffszeit auf den Hauptspeicher 100-mal vom Zugriff auf den L1-Cache.  Dies ist ein gro√üer Unterschied, aber nicht unendlich.  Wenn wir daf√ºr eine spezifische Bedeutung haben, k√∂nnen wir bei der Optimierung unserer Anwendungen bewerten, ob es einen Zeitgewinn gibt oder nicht. <br><br><img src="https://habrastorage.org/webt/km/q5/ze/kmq5zekztqx_yhwcoyrjomhjcy4.png"><br><br><h2>  "Latenzzahlen" im wirklichen Leben </h2><br>  Als ich diese Zahlen sah, interessierte mich der Unterschied zwischen Cache- und Speicherzugriff.  Wenn ich meine Daten sorgf√§ltig in 64 KByte lege, was nicht so klein ist, funktioniert mein Code 100-mal schneller - es ist schnell, alles wird fliegen! <br><br><img src="https://habrastorage.org/webt/-p/oh/fh/-pohfhloth8e4c-8sl2i5jdmbi4.png"><br><br>  Ich wollte sofort alles √ºberpr√ºfen, es meinen Kollegen zeigen und wo immer m√∂glich anwenden.  Ich habe mich entschieden, mit dem Standard-Tool von Apple zu beginnen - XCTest mit MeasureBlock.  Der Test war wie folgt organisiert: Er ordnete ein Array zu, f√ºllte es mit Zahlen, deren XOR'il und wiederholte den Algorithmus sicher zehnmal.  Danach habe ich mir angesehen, wie viel Zeit ein Element ben√∂tigt. <br><br><table><tbody><tr><td>  <b>Puffergr√∂√üe</b> </td><td>  <b>Gesamtzeit</b> </td><td>  <b>Zeit f√ºr eine Operation</b> </td></tr><tr><td>  50 kb </td><td>  1,5 ms </td><td>  30 ns </td></tr><tr><td>  500 kb </td><td>  12 ms </td><td>  24 ns </td></tr><tr><td>  5000 kb </td><td>  85 ms </td><td>  17 ns </td></tr></tbody></table><br>  Die Gr√∂√üe des Puffers erh√∂hte sich um das 100-fache, und die Zeit f√ºr die Operation erh√∂hte sich nicht nur nicht um das 100-fache, sondern verringerte sich fast um das 2-fache.  <i>Meine Herren, Offiziere, sie haben uns betrogen ?!</i> <br><br>  Nach einem solchen Ergebnis schlichen sich gro√üe Zweifel in mir ein, dass diese Zahlen im wirklichen Leben gesehen werden k√∂nnen.  Bei einer regul√§ren Anwendung ist es m√∂glicherweise nicht m√∂glich, diesen Unterschied zu erkennen.  Oder vielleicht ist auf der mobilen Plattform alles anders. <br><br>  Ich suchte nach einer M√∂glichkeit, den Leistungsunterschied zwischen Caches und Hauptspeicher zu erkennen.  W√§hrend der Suche stie√ü ich auf einen Artikel, in dem sich der Autor beschwerte, dass auf seinem Mac und iPhone ein Benchmark ausgef√ºhrt wurde und diese Verz√∂gerungen nicht angezeigt wurden.  Ich nahm dieses Werkzeug und bekam das Ergebnis - genau wie in einer Apotheke.  Die Speicherzugriffszeit nahm ziemlich deutlich zu, wenn die Puffergr√∂√üe die Gr√∂√üe des entsprechenden Caches √ºberschritt. <br><br><img src="https://habrastorage.org/webt/he/_q/k8/he_qk85tbetz4emjxbp5znbqidc.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LMbench</a> hat mir geholfen, diese Ergebnisse zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erzielen</a> .  Dies ist ein von Larry McVoy, einem der Entwickler des Linux-Kernels, erstellter Benchmark, mit dem Sie die Speicherzugriffszeit, die Kosten f√ºr das Wechseln von Threads und Dateisystemoperationen und sogar die Zeit messen k√∂nnen, die die Hauptprozessoroperationen ben√∂tigen: Addition, Subtraktion usw. Gem√§√ü diesem Benchmark Texas Instruments pr√§sentierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">interessante</a> Messdaten f√ºr seine Prozessoren.  LMBench ist in C geschrieben, daher war es nicht schwierig, es unter iOS auszuf√ºhren. <br><br><h2>  Speicherkosten </h2><br>  Mit einem so wunderbaren Werkzeug ausgestattet, entschied ich mich f√ºr √§hnliche Messungen, jedoch f√ºr ein tats√§chliches Mobilger√§t - f√ºr das iPhone.  Die Hauptmessungen wurden mit dem 5S durchgef√ºhrt, und dann erhielt ich die Ergebnisse, als andere Ger√§te in meine H√§nde fielen.  Wenn das Ger√§t nicht angegeben ist, ist es daher 5S. <br><br><h3>  Speicherzugriff </h3><br>  F√ºr diesen Test wird ein spezielles Array verwendet, das mit Elementen gef√ºllt ist, die aufeinander verweisen.  Jedes der Elemente ist ein Zeiger auf ein anderes Element.  Das Array wird nicht vom Index durchlaufen, sondern von √úberg√§ngen von einem Knoten zum anderen.  Diese Elemente sind √ºber das Array verteilt, sodass sie beim Zugriff auf ein neues Element so oft wie m√∂glich nicht im Cache, sondern aus dem RAM entladen wurden.  Diese Anordnung st√∂rt die Caches so weit wie m√∂glich. <br><br>  Sie haben das vorl√§ufige Ergebnis bereits gesehen.  Im Fall des L1-Cache sind es weniger als 10 Nanosekunden, im Fall von L2 sind es einige zehn Nanosekunden, und im Fall des Hauptspeichers steigt die Zeit auf Hunderte von Nanosekunden. <br><br><img src="https://habrastorage.org/webt/6u/dk/f0/6udkf0ihlo3lgfqhntfkzp3vshm.png"><br><br><h3>  Lese- und Schreibgeschwindigkeit </h3><br>  Drei Hauptoperationen werden gemessen: <br><br><ul><li>  Lesen ( <em>p [i] +</em> ) - Wir lesen die Elemente und addieren sie zum Gesamtbetrag. </li><li>  record ( <em>p [i] = 1</em> ) - in jedes Element wird eine konstante Zahl geschrieben; </li><li>  Lesen und Schreiben ( <em>p [i] = p [i] * 2</em> ) - Wir nehmen das Element heraus, √§ndern es und schreiben den neuen Wert zur√ºck. </li></ul><br>  Bei der Arbeit mit dem Puffer werden zwei Ans√§tze verwendet: Im ersten Fall wird nur jedes vierte Element verwendet, und im zweiten Fall werden alle Elemente nacheinander verwendet. <br><br><img src="https://habrastorage.org/webt/yr/ke/ia/yrkeiaf0vzc47trw7wc_hypse-s.png"><br><br>  Die h√∂chste Geschwindigkeit wird mit einer kleinen Puffergr√∂√üe erzielt, und dann gibt es klare Schritte entsprechend der Gr√∂√üe der L1- und L2-Caches.  Das Interessanteste ist, dass beim sequentiellen Lesen von Daten keine Geschwindigkeitsreduzierung auftritt.  Bei P√§ssen sind jedoch klare Schritte sichtbar. <br><br><img src="https://habrastorage.org/webt/2t/-d/_6/2t-d_68-oyjigkraj2mpirwjzfw.png"><br><br>  W√§hrend des sequentiellen Lesens gelingt es dem Betriebssystem, die erforderlichen Daten in den Cache zu laden, sodass ich f√ºr jede Puffergr√∂√üe nicht auf den Speicher zugreifen muss - alle erforderlichen Daten werden aus dem Cache abgerufen.  Dies erkl√§rt, warum ich den Zeitunterschied in meinem Basistest nicht gesehen habe. <br><br>  Die Ergebnisse von Messungen von Lese- und Schreibvorg√§ngen zeigten, dass es bei einer normalen Anwendung ziemlich schwierig ist, die gesch√§tzte Beschleunigung von 100 zu erhalten.  Einerseits speichert das System selbst Daten recht gut zwischen, und selbst bei gro√üen Arrays ist es sehr wahrscheinlich, dass wir Daten im Cache finden.  Andererseits kann das Arbeiten mit verschiedenen Variablen leicht den Zugriff auf den Speicher und den Verlust von Hunderten von gewonnenen Nanosekunden erfordern. <br><br><table><tbody><tr><td></td><td>  <b>L1</b> </td><td>  <b>L2</b> </td><td>  <b>Speicher</b> </td></tr><tr><td>  Latenzzahlen </td><td>  1 ns </td><td>  7 ns </td><td>  100 ns </td></tr><tr><td>  iPhone 5s </td><td>  7 ns </td><td>  30 ns </td><td>  240 ns </td></tr><tr><td>  iPhone 6s Plus </td><td>  5 ns </td><td>  12 ns </td><td>  200 ns </td></tr><tr><td>  iPhone X. </td><td>  2 ns </td><td>  12 ns </td><td>  146 ns </td></tr></tbody></table><br><h2>  Threading-Kosten </h2><br>  Als n√§chstes wollte ich √§hnliche Daten f√ºr die Arbeit mit Threads erhalten, <strong>um die Kosten f√ºr die Verwendung von Multithreading</strong> zu <strong>verstehen</strong> : Wie viel kostet es, einen Thread zu erstellen und von einem Thread zu einem anderen zu wechseln?  F√ºr uns sind dies h√§ufige Operationen, und ich m√∂chte den Verlust verstehen. <br><br><h3>  Instrumente.  Systemablaufverfolgung </h3><br>  System Trace hilft sehr dabei, die Arbeit von Threads in der Anwendung zu verfolgen.  Dieses Tool wurde auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WWDC 2016</a> ausf√ºhrlich beschrieben.  Das Tool hilft beim Erkennen von √úberg√§ngen nach Stream-Bedingungen und zeigt Daten zu Streams in drei Hauptkategorien an: Systemaufrufe, Arbeiten mit Speicher und Stream-Bedingungen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hs/gx/kq/hsgxkqsh5khfclg4gncfbksihya.png" width="500"></div><br><br><ol><li>  <strong>Systemaufrufe</strong>  Sie werden in Form von roten "W√ºrstchen" pr√§sentiert.  Wenn Sie darauf zeigen, sehen Sie den Namen der Systemmethode und die Dauer der Ausf√ºhrung.  In Anwendungsanwendungen tritt ein solcher Systemaufruf h√§ufig nicht direkt auf: Wir verwenden etwas, das wiederum bereits die Systemmethode aufruft.  Sie sollten sich nicht darauf verlassen, dass hier die Methoden aus Ihrem Code sichtbar sind. </li><li>  <strong>Speicheroperationen</strong> .  Sie werden in Form von blauen "W√ºrstchen" pr√§sentiert.  Dies umfasst Vorg√§nge wie Speicherzuweisung, Freigeben, Nullstellen usw. </li><li>  <strong>Der Zustand des Streams</strong> .  Blaue Farbe - Ein Thread wird ausgef√ºhrt, ein Prozessor f√ºhrt Code aus diesem Thread aus.  Grau - Der Thread ist aus irgendeinem Grund blockiert und kann die Ausf√ºhrung nicht fortsetzen.  Rot - Der Thread ist betriebsbereit, aber derzeit gibt es keinen freien Kernel, um seinen Code auszuf√ºhren.  Orange Farbe - Der Fluss wird f√ºr Arbeiten mit h√∂herer Priorit√§t unterbrochen. </li><li> <strong>Punkte von Interesse</strong> .  Dies sind spezielle Beschriftungen, die durch Aufrufen von <code>kdebug_signpost</code> nach Code angeordnet werden <code>kdebug_signpost</code> .  Beschriftungen k√∂nnen einzeln (eine bestimmte Stelle im Code) oder als Bereich (um die gesamte Prozedur hervorzuheben) sein.  Mit solchen Beschriftungen ist es viel einfacher, Mikrosekunden und Systemaufrufe mit Ihrer Anwendung zu korrelieren. </li></ol><br><h3>  Kosten f√ºr die Stream-Erstellung </h3><br>  Der erste Test ist die <strong>Ausf√ºhrung einer Aufgabe in einem neuen Thread</strong> .  Wir erstellen einen Thread mit einer bestimmten Prozedur und warten, bis er seine Arbeit abgeschlossen hat.  Wenn wir die Gesamtzeit mit der Zeit f√ºr die Prozedur selbst vergleichen, erhalten wir den Gesamtverlust, um die Prozedur in einem neuen Thread zu starten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m3/ln/wa/m3lnwaf0zdjx7b7suyujhp9eywu.png" width="600"></div><br><br>  In System Trace k√∂nnen Sie deutlich sehen, wie wirklich alles passiert: <br><br><img src="https://habrastorage.org/webt/wh/ta/qd/whtaqdwmfal7dyi4d-fs_22oir0.png"><br><br><ol><li>  Stream erstellen. </li><li>  Der neue Thread, in dem unsere Prozedur ausgef√ºhrt wird.  Die rote Zone am Anfang besagt, dass der Thread erstellt wurde, aber f√ºr einige Zeit nicht ausgef√ºhrt werden konnte, da es keinen freien Kern gab. </li><li>  Die Fertigstellung des Streams.  Interessanterweise ist das Thread-Vervollst√§ndigungsverfahren selbst noch gr√∂√üer als seine Erstellung.  Obwohl es scheint, dass das L√∂schen immer schneller ist. </li><li>  Warten auf den Abschluss des Verfahrens, das im urspr√ºnglichen Schema enthalten war, und es endet nach dem Ende des Streams - f√ºr eine Weile erkennt die Methode dies und meldet danach.  Diese Zeit ist etwas l√§nger als die Fertigstellung des Streams. </li></ol><br>  Das Erstellen eines Streams erfordert daher erhebliche Kosten: iPhone 5S - 230 Mikrosekunden, 6S - 50 Mikrosekunden.  <b>Die Fertigstellung des Streams dauert fast zweimal l√§nger als die Erstellung</b> , die Verkn√ºpfung dauert ebenfalls sp√ºrbar.  Bei der Arbeit mit dem Speicher haben wir Hunderte von Nanosekunden erhalten, was 100-mal weniger als zehn Mikrosekunden entspricht. <br><br><table><tbody><tr><td></td><td>  <b>Overhead</b> </td><td>  <b>erstellen</b> </td><td>  <b>Ende</b> </td><td>  <b>beitreten</b> </td></tr><tr><td>  iPhone 5s </td><td>  230 Œºs </td><td>  40 Œºs </td><td>  70 Œºs </td><td>  30 Œºs </td></tr><tr><td>  iPhone 6s Plus </td><td>  50 Œºs </td><td>  12 Œºs </td><td>  20 Œºs </td><td>  7 Œºs </td></tr></tbody></table><br><h3>  Semaphor-Schaltzeit </h3><br>  Der n√§chste Test sind <strong>Messungen an der Arbeit des Semaphors</strong> .  Wir haben 2 vorgefertigte Threads, und f√ºr jeden von ihnen gibt es ein Semaphor.  Streams signalisieren abwechselnd das Semaphor des Nachbarn und warten auf ihr eigenes.  Streams geben sich gegenseitig Signale, spielen Ping-Pong und beleben sich gegenseitig.  Diese doppelte Iteration ergibt eine doppelte Semaphorschaltzeit. <br><br><img src="https://habrastorage.org/webt/nf/de/iq/nfdeiqezf1edyugn_lkccjocndy.png"><br><br>  In System Trace sieht alles √§hnlich aus: <br><br><ol><li>  F√ºr das Semaphor des zweiten Stroms wird ein Signal gegeben.  Es ist ersichtlich, dass dieser Vorgang sehr kurz ist. </li><li>  Der zweite Thread wird entsperrt, das Warten auf sein Semaphor endet. </li><li>  F√ºr das Semaphor des ersten Stroms wird ein Signal gegeben. </li><li>  Der erste Thread wird entsperrt, das Warten auf sein Semaphor endet. </li></ol><br><img src="https://habrastorage.org/webt/0e/jn/mb/0ejnmb3dxvozsz-h0zaijdl_3xm.png"><br><br>  Die Schaltzeit betrug innerhalb von 10 Mikrosekunden.  Der Unterschied zum 50-fachen Erstellen eines Threads ist genau der Grund, warum Thread-Pools erstellt werden, und nicht f√ºr jede Prozedur ein neuer Thread. <br><br><h3>  Verluste beim Umschalten des System-Thread-Kontexts </h3><br>  In den beiden vorherigen Tests wurde die √úbertragung der Kontrolle zwischen den Threads vollst√§ndig kontrolliert - wir haben klar verstanden, wo und wo der √úbergang stattfinden sollte.  Es kommt jedoch h√§ufig vor, dass das System selbst von einem Thread zu einem anderen wechselt.  Wenn mehr Aufgaben parallel ausgef√ºhrt werden als die Kerne im Ger√§t, muss das Betriebssystem in der Lage sein, sich selbst zu wechseln, um allen Prozessoren Zeit zu geben. <br><br>  In diesem Test wollte ich den Verlust beim Starten zu vieler Threads messen.  Dazu wird ein Pool von 16 Threads erstellt, von denen jeder auf ein Semaphor wartet und sobald es ein Signal empf√§ngt, eine bestimmte Prozedur ausf√ºhrt und das Semaphor zur√ºcksigniert.  Der Haupt-Thread startet den gesamten Pool mit 16 Signalen und wartet danach 16 Signale als Antwort. <br><br><img src="https://habrastorage.org/webt/fv/ki/an/fvkiang1lid-dgw6bmddnudyjro.png"><br><br>  In System Trace k√∂nnen Sie sehen, dass die Bl√∂cke zuf√§llig verteilt sind, einige von ihnen sind viel l√§nger als die anderen.  Wenn mehrfaches Umschalten zu einer Verl√§ngerung der Ausf√ºhrungszeit der Operation f√ºhrt, sollte sich die durchschnittliche Ausf√ºhrungszeit infolgedessen erh√∂hen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ar/0b/r6/ar0br6h-8hm8qwmlyokuots92au.png" width="500"></div><br>  <b>Mit zunehmender Anzahl von Threads erh√∂ht sich jedoch die durchschnittliche Betriebszeit nicht.</b> <br><br>  Theoretisch sollte die durchschnittliche Zeit so lange eingehalten werden, wie die Last der Verarbeitungsleistung entspricht.  Das hei√üt, die Anzahl der Aufgaben entspricht der Anzahl der Kerne. <br><br><img src="https://habrastorage.org/webt/9r/8l/-p/9r8l-p83_ad6ibrit6ee2d67cwa.png"><br><br>  Wenn Sie viele Aufgaben parallel ausf√ºhren, f√ºhrt das Betriebssystem beim Wechsel von einer Aufgabe zur anderen zu zus√§tzlichen Verz√∂gerungen.  Dies sollte sich im Ergebnis widerspiegeln. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fe/0x/ko/fe0xko9wqlkfu5nt4n0fonqcrfs.png"></div><br>  In der Praxis funktioniert nicht nur unsere Anwendung auf dem Ger√§t, sondern es gibt immer noch viele parallele und Systemprozesse.  Selbst der einzige Thread in unserer Anwendung wird vom Umschalten betroffen sein, was zu Unterbrechungen und Verz√∂gerungen f√ºhrt.  Daher gibt es in allen Situationen Verz√∂gerungen, und es gibt keinen Unterschied, ob Aufgaben in Reihe erstellt oder parallel ausgef√ºhrt werden sollen. <br><br><img src="https://habrastorage.org/webt/by/io/c4/byioc4ax6qgcuwxpkmjhpfyaaeg.png"><br><br>  Unten finden Sie unsere Tabelle mit den Latenznummern mit Daten zu Flows und Semaphoren. <br><br><table><tbody><tr><td></td><td>  <b>L1</b> </td><td>  <b>L2</b> </td><td>  <b>Speicher</b> </td><td>  <b>Semaphor</b> </td></tr><tr><td>  Latenzzahlen </td><td>  1 ns </td><td>  7 ns </td><td>  100 ns </td><td>  25 ns </td></tr><tr><td>  iPhone 5s </td><td>  7 ns </td><td>  30 ns </td><td>  240 ns </td><td>  8 Œºs </td></tr><tr><td>  iPhone 6s Plus </td><td>  5 ns </td><td>  12 ns </td><td>  200 ns </td><td>  5 Œºs </td></tr><tr><td>  iPhone X. </td><td>  2 ns </td><td>  12 ns </td><td>  146 ns </td><td>  3,2 Œºs </td></tr></tbody></table><br><h2>  Dateikosten </h2><br>  Wir haben bereits Speicher und Threads - der Vollst√§ndigkeit halber ben√∂tigen wir nur Dateisystemoperationen. <br><br><h3>  Datei lesen </h3><br>  Der erste Test ist die <strong>Lesegeschwindigkeit</strong> - wie viel kostet das Lesen einer Datei?  Der Test besteht aus zwei Teilen.  Im ersten Schritt <strong>messen</strong> wir <strong>die Lesegeschwindigkeit</strong> unter Ber√ºcksichtigung des √ñffnens, Lesens und Schlie√üens der Datei.  Im zweiten Fall <strong>gehen</strong> wir <strong>davon aus, dass die Datei st√§ndig ge√∂ffnet ist</strong> : Wir positionieren uns irgendwo und lesen so viel, wie wir wollen. <br><br>  Die Ergebnisse werden unter zwei Gesichtspunkten korrekt angezeigt.  <strong>Wenn die Datei klein ist</strong> , bleibt nur wenig Zeit, um Daten aus der Datei zu lesen.  Bis zu einem Kilobyte sind 5,3 Mikrosekunden - egal: 1 Byte, 2 oder 1 KB - f√ºr alle 5,3 Œºs.  Daher k√∂nnen Sie nur bei gro√üen Dateien von Geschwindigkeit sprechen, wenn die festgelegte Zeit bereits vernachl√§ssigt werden kann.  Der Vorgang zum √ñffnen und Schlie√üen der Datei dauert f√ºr jede Dateigr√∂√üe ungef√§hr dieselbe Zeit - im Fall von 5S etwa 50 Mikrosekunden. <br><br><img src="https://habrastorage.org/webt/zv/na/-2/zvna-2en_axstzffeo9iru-bpuo.png"><br><br>  F√ºr die Lesegeschwindigkeit werden solche Graphen erhalten. <br><br><img src="https://habrastorage.org/webt/h4/2g/ri/h42griw_vpjjlfgkpxdbty3c8yw.png"><br><br>  F√ºr das iPhone X und eine Datei mit 1 MB kann die Geschwindigkeit 20 MB / s erreichen.  Interessanterweise ist das Lesen einer 1-MB-Datei effizienter.  Bei gro√üen Dateien scheinen die Cache-Gr√∂√üen betroffen zu sein.  Deshalb sinkt die Geschwindigkeit weiter und gleicht sich im Bereich von 10 Mb aus. <br><br><h3>  Dateien erstellen und l√∂schen </h3><br>  Der Test besteht aus dem Schritt des <strong>Erstellens einer Datei und des Schreibens von Daten</strong> sowie des <strong>L√∂schens der</strong> erstellten Dateien.  Das Ergebnis ist schrittweise: Bei kleinen Gr√∂√üen ist die Zeit stabil - etwa 7 Œºs - und w√§chst weiter.  Die Skala ist logarithmisch. <br><br><img src="https://habrastorage.org/webt/da/xn/sp/daxnspzyy0raugagyluwnkwjqhs.png"><br><br>  Ich war √ºberrascht, dass die Zeit, die zum L√∂schen einer gro√üen Datei ben√∂tigt wird, der Zeit entspricht, die zum Erstellen ben√∂tigt wird, da ich davon ausgegangen bin, dass das L√∂schen ein schneller Vorgang ist.  Es stellt sich heraus, dass f√ºr das iPhone das rechtzeitige L√∂schen mit dem Erstellen einer Datei vergleichbar ist.  Die √úbersichtstabelle sieht folgenderma√üen aus. <br><br><table><tbody><tr><td></td><td>  <b>L1</b> </td><td>  <b>L2</b> </td><td>  <b>Speicher</b> </td><td>  <b>Semaphor</b> </td><td>  <b>Festplatte</b> </td></tr><tr><td>  Latenzzahlen </td><td>  1 ns </td><td>  7 ns </td><td>  100 ns </td><td>  25 ns </td><td>  150 Œºs </td></tr><tr><td>  iPhone 5s </td><td>  7 ns </td><td>  30 ns </td><td>  240 ns </td><td>  8 Œºs </td><td>  5 Œºs </td></tr><tr><td>  iPhone 6s Plus </td><td>  5 ns </td><td>  12 ns </td><td>  200 ns </td><td>  5 Œºs </td><td>  4 Œºs </td></tr><tr><td>  iPhone X. </td><td>  2 ns </td><td>  12 ns </td><td>  146 ns </td><td>  3,2 Œºs </td><td>  1,3 Œºs </td></tr></tbody></table><br><h2>  Fazit </h2><br>  Basierend auf diesen Messungen haben wir jetzt eine Vorstellung davon, wie viel Zeit die grundlegenden iOS-Vorg√§nge ben√∂tigen: Der Zugriff auf den Speicher dauert Nanosekunden, das Arbeiten mit Dateien dauert Mikrosekunden, das Erstellen eines Streams dauert mehrere zehn Sekunden und das Umschalten dauert nur wenige Mikrosekunden. <br><br>  Um einen physisch wahrnehmbaren Hang in der Anwendung zu erhalten, muss die Ausf√ºhrungszeit der Prozedur 15 Millisekunden √ºberschreiten (die Zeit, die zum Aktualisieren des Bildschirms mit 60 fps ben√∂tigt wird).  Dies ist fast tausendmal gr√∂√üer als die meisten Messungen im Artikel.  In einem solchen Ma√üstab ist eine Millisekunde ziemlich viel, und eine Sekunde ist bereits "f√ºr immer". <br><br>  Tests haben gezeigt, dass die direkte Verwendung dieses Verh√§ltnisses trotz des gro√üen Zeitunterschieds beim Zugriff auf Speicher und Caches ziemlich schwierig ist.  Bevor Sie alle Ihre Daten unter L1 zusammenstellen, m√ºssen Sie sicherstellen, dass in Ihrem Fall wirklich ein Ergebnis erzielt wird. <br><br>  Gem√§√ü den Tests von Operationen mit Threads konnten wir sicherstellen, dass das Erstellen und Zerst√∂ren von Threads viel Zeit in Anspruch nimmt, aber das Ausf√ºhren einer gro√üen Anzahl paralleler Operationen keine zus√§tzlichen Kosten verursacht. <br><br>  Abschlie√üend m√∂chte ich Sie an die wichtigste Regel bei der Arbeit an der Leistung erinnern - <b>erst Messungen und erst dann Optimierung</b> ! <br><br>  Profilsprecher Dmitry Kurkin auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> . <br><br><blockquote>  Die Konvertierung und Umwandlung von AppsConf 2018-Berichten in Artikel erfolgt parallel zur <b>Vorbereitung</b> der brandneuen <b>Konferenz</b> 2019.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liste der akzeptierten Berichte enth√§lt</a> bisher nur 7 Themen. Diese Liste wird jedoch st√§ndig erweitert, sodass <b>vom 22. bis 23. April</b> eine coole Konferenz f√ºr Entwickler von Mobilger√§ten stattfindet. <br><br>  Folgen Sie Ver√∂ffentlichungen, abonnieren Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Youtube-Kanal</a> und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Newsletter</a> und diese Zeit vergeht schnell. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437590/">https://habr.com/ru/post/de437590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437580/index.html">Wie man sich in 5 Tagen an ein JavaScript-Lehrbuch oder an den ‚ÄûPalast der Erinnerung‚Äú im Alltag eines Programmierers erinnert</a></li>
<li><a href="../de437582/index.html">√úbersicht √ºber Vue.js 2.6</a></li>
<li><a href="../de437584/index.html">Die mathematischen Grundlagen des automatischen Layouts</a></li>
<li><a href="../de437586/index.html">Wir erstellen eine Sprachanwendung am Beispiel von Google Assistant</a></li>
<li><a href="../de437588/index.html">Macht es mehr Spa√ü, f√ºr Mobiltelefone als f√ºr das Internet zu entwickeln?</a></li>
<li><a href="../de437592/index.html">Asynchrone Task Execution Layer-Architektur</a></li>
<li><a href="../de437594/index.html">Wie ich die Ursache f√ºr Stottern und Frame-Skipping in allen Spielen beseitigt und versehentlich die Temperatur um 15 Grad gesenkt habe</a></li>
<li><a href="../de437596/index.html">OTRS: LDAP-Authentifizierung, Autorisierung und Synchronisation (FreeIPA, AD)</a></li>
<li><a href="../de437598/index.html">So speichern Sie das Spielsystem mithilfe der Virtualisierung vom Heim-PC</a></li>
<li><a href="../de437600/index.html">opencv4arts: Zeichne meine Stadt, Vincent</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>