<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕰️ 🙎 🤙🏻 An den Fingern: zugeordnete Typen in Rust und was ist ihr Unterschied zu Typargumenten 🚈 👨🏽 ✊🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Warum sind Rust Typen zugeordnet, und was ist der Unterschied zwischen ihnen und Typargumenten, auch Generika genannt, weil sie so ähnlich sind? Ist e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>An den Fingern: zugeordnete Typen in Rust und was ist ihr Unterschied zu Typargumenten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441444/"><p> Warum sind Rust Typen zugeordnet, und was ist der Unterschied zwischen ihnen und Typargumenten, auch Generika genannt, weil sie so ähnlich sind?  Ist es nicht genug, nur letzteres, wie in allen normalen Sprachen?  Für diejenigen, die gerade erst anfangen, Rust zu lernen, und insbesondere für Leute, die aus anderen Sprachen kommen ("Das sind Generika!" - der seit Jahren weise Javist wird sagen), stellt sich regelmäßig eine solche Frage.  Lass es uns richtig machen. </p><br><p>  TL; DR Ersteres steuert den aufgerufenen Code, letzteres den Anrufer. </p><a name="habracut"></a><br><h3 id="dzheneriki-vs-associirovannye-tipy">  Generika gegen zugehörige Typen </h3><br><p>  Wir haben also bereits Typargumente oder die beliebtesten Generika aller.  Es sieht ungefähr so ​​aus: </p><br><pre><code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, x: T); }</code> </pre> <br><p>  Hier ist <code>T</code> genau das Typargument.  Es scheint, dass dies für alle ausreichen sollte (wie 640 Kilobyte Speicher).  In Rust gibt es aber auch zugehörige Typen, etwa so: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//    fn bar(self, x: Self::Bar); }</span></span></code> </pre> <br><p>  Auf den ersten Blick die gleichen Eier, aber aus einem anderen Blickwinkel.  Warum mussten Sie eine andere Entität in die Sprache einführen?  (Was übrigens nicht in den frühen Versionen der Sprache war.) </p><br><p>  Typargumente sind genau <strong><em>Argumente</em></strong> . Dies bedeutet, dass sie an das Merkmal am Ort des Aufrufs übergeben werden und die Kontrolle darüber, welcher Typ anstelle von <code>T</code> , dem Aufrufer gehört.  Auch wenn wir <code>T</code> am Aufrufort nicht explizit angeben, <code>T</code> der Compiler dies für uns mithilfe der Typinferenz.  Das heißt, implizit wird dieser Typ vom Aufrufer abgeleitet und als Argument übergeben.  (Natürlich geschieht dies alles während der Kompilierung, nicht zur Laufzeit.) </p><br><p>  Betrachten Sie ein Beispiel.  Die Standardbibliothek verfügt über ein AsRef- <code>AsRef</code> , mit dem ein Typ für eine Weile vorgeben kann, ein anderer Typ zu sein, und einen Link zu sich selbst in einen Link zu etwas anderem konvertiert.  Vereinfacht ausgedrückt sieht dieses Merkmal so aus (in Wirklichkeit ist es etwas komplizierter, ich habe absichtlich alles Unnötige entfernt und nur das für das Verständnis notwendige Minimum übrig gelassen): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsRef</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_ref</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;T; }</code> </pre> <br><p>  Hier wird der Typ <code>T</code> vom Aufrufer als Argument übergeben, auch wenn dies implizit geschieht (wenn der Compiler diesen Typ für Sie ableitet).  Mit anderen Worten, es ist der Anrufer, der entscheidet, welcher neue Typ <code>T</code> vorgibt, unser Typ zu sein, der dieses Merkmal implementiert: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> foo = Foo::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bar: &amp;Bar = foo.as_ref();</code> </pre> <br><p>  Hier verwendet der Compiler unter Verwendung der Kenntnisse von <code>bar: &amp;Bar</code> die <code>AsRef&lt;Bar&gt;</code> , um die <code>as_ref()</code> -Methode <code>as_ref()</code> , da dies der vom Aufrufer benötigte <code>as_ref()</code> ist.  Es versteht sich von selbst, dass der <code>Foo</code> Typ das <code>AsRef&lt;Bar&gt;</code> AsRef <code>AsRef&lt;Bar&gt;</code> implementieren muss. Außerdem kann er so viele andere <code>AsRef&lt;T&gt;</code> implementieren, unter denen der Aufrufer die gewünschte auswählt. </p><br><p>  Beim zugehörigen Typ ist alles genau umgekehrt.  Der zugehörige Typ wird vollständig von denjenigen gesteuert, die dieses Merkmal implementieren, und nicht vom Anrufer. </p><br><p>  Ein häufiges Beispiel ist ein Iterator.  Angenommen, wir haben eine Sammlung und möchten einen Iterator daraus erhalten.  Welche Art von Werten sollte der Iterator zurückgeben?  Genau die in dieser Sammlung enthaltene!  Es ist nicht Sache des Anrufers, zu entscheiden, was der Iterator zurückgibt, und der Iterator selbst weiß besser, <em>was er genau</em> zurückgeben kann.  Hier ist der abgekürzte Code aus der Standardbibliothek: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Self::Item&gt;; }</code> </pre> <br><p>  Beachten Sie, dass der Iterator keinen Typparameter hat, mit dem der Aufrufer auswählen kann, was der Iterator zurückgeben soll.  Stattdessen wird der Typ des von der <code>next()</code> -Methode zurückgegebenen Werts vom Iterator selbst unter Verwendung des zugehörigen Typs bestimmt, aber er bleibt nicht bei Nägeln hängen, d. H.  Jede Iterator-Implementierung kann ihren Typ auswählen. </p><br><p>  Hör auf  Na und?  Trotzdem ist nicht klar, warum dies besser ist als ein Generikum.  Stellen Sie sich für einen Moment vor, wir verwenden das übliche Generikum anstelle des zugehörigen Typs.  Das Merkmal des Iterators sieht dann ungefähr so ​​aus: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericIterator</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;T&gt;; }</code> </pre> <br><p>  Aber erstens muss der Typ <code>T</code> an jeder Stelle, an der der Iterator erwähnt wird, immer wieder angegeben werden, und zweitens ist es jetzt möglich geworden, dieses Merkmal mehrmals mit verschiedenen Typen zu implementieren, was für den Iterator irgendwie seltsam aussieht.  Hier ist ein Beispiel: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyIterator</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> GenericIterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyIterator { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">unimplemented!</span></span>() } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> GenericIterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyIterator { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">unimplemented!</span></span>() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> iter = MyIterator; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lolwhat: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;_&gt; = iter.next(); <span class="hljs-comment"><span class="hljs-comment">// Error! Which impl of GenericIterator to use? }</span></span></code> </pre> <br><p>  Sehen Sie den Haken?  Wir können <code>iter.next()</code> nicht einfach ohne Kniebeugen nehmen und aufrufen - wir müssen dem Compiler explizit oder implizit <code>iter.next()</code> , welcher Typ zurückgegeben wird.  Und es sieht unangenehm aus: Warum sollten wir auf der Aufrufseite wissen (und dem Compiler mitteilen!), Welchen Typ der Iterator zurückgeben wird, während dieser Iterator besser wissen sollte, welchen Typ er zurückgibt ?!  Und das alles, weil wir das GenericIterator- <code>GenericIterator</code> zweimal mit einem anderen Parameter für denselben <code>MyIterator</code> , was aus Sicht der Iteratorsemantik auch lächerlich aussieht: Warum kann derselbe Iterator Werte unterschiedlichen Typs zurückgeben? </p><br><p>  Wenn wir zur Variante mit dem zugehörigen Typ zurückkehren, können all diese Probleme vermieden werden: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyIter</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyIter { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span> = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Self::Item&gt; { <span class="hljs-built_in"><span class="hljs-built_in">unimplemented!</span></span>() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> iter = MyIter; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = iter.next(); }</code> </pre> <br><p>  Hier gibt der Compiler zum einen den <code>value: Option&lt;String&gt;</code> korrekt aus <code>value: Option&lt;String&gt;</code> ohne unnötige Wörter, und zum anderen funktioniert es nicht, das <code>Iterator</code> <code>MyIter</code> für <code>MyIter</code> zweites Mal mit einem anderen Rückgabetyp zu implementieren und damit alles zu ruinieren. </p><br><p>  Zur Befestigung.  Eine Sammlung kann ein solches Merkmal implementieren, um sich selbst in einen Iterator verwandeln zu können: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntoIterator</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntoIter</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span>&lt;Item=Self::Item&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">into_iter</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Self::IntoIter; }</code> </pre> <br><p>  Und wieder ist es hier die Sammlung, die entscheidet, was Iterator sein wird, nämlich: ein Iterator, dessen Rückgabetyp mit dem Typ der Elemente in der Sammlung selbst übereinstimmt, und kein anderer. </p><br><h3 id="eschyo-bolee-na-palcah">  Mehr an den Fingern </h3><br><p>  Wenn die obigen Beispiele immer noch unverständlich sind, finden Sie hier eine noch weniger wissenschaftliche, aber verständlichere Erklärung.  Typargumente können als Eingabeinformationen betrachtet werden, die wir bereitstellen, damit das Merkmal funktioniert.  Zugehörige Typen können als "Ausgabe" -Informationen betrachtet werden, die uns das Merkmal liefert, damit wir die Ergebnisse seiner Arbeit verwenden können. </p><br><p>  Die Standardbibliothek kann mathematische Operatoren für ihre Typen (Addition, Subtraktion, Multiplikation, Division und dergleichen) überladen.  Dazu müssen Sie eines der entsprechenden Merkmale aus der Standardbibliothek implementieren.  Hier zum Beispiel, wie dieses Merkmal für die Additionsoperation aussieht (wieder vereinfacht): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Add</span></span></span></span>&lt;RHS&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, rhs: RHS) -&gt; Self::Output; }</code> </pre> <br><p>  Hier haben wir das <code>RHS</code> Argument "input" - dies ist der Typ, auf den wir die Additionsoperation mit unserem Typ anwenden werden.  Und es gibt ein "Ausgabe" -Argument <code>Add::Output</code> - dies ist der Typ, der sich aus der Addition ergibt.  Im allgemeinen Fall kann es sich von der Art der Begriffe unterscheiden, die wiederum auch von unterschiedlicher Art sein können (fügen Sie dem Blau Leckeres hinzu und werden Sie weich - aber was, ich mache das die ganze Zeit).  Der erste wird mit dem Argument type angegeben, der zweite mit dem zugehörigen Typ. </p><br><p>  Sie können eine beliebige Anzahl von Hinzufügungen mit unterschiedlichen Typen des zweiten Arguments implementieren, aber jedes Mal gibt es nur einen Ergebnistyp, der durch die Implementierung dieses Zusatzes bestimmt wird. </p><br><p>  Versuchen wir, dieses Merkmal zu implementieren: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Add; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>); <span class="hljs-meta"><span class="hljs-meta">#[derive(PartialEq, Debug)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span></span>(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Add&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Foo { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Bar; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, rhs: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; Bar { Bar(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, rhs) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = Foo(<span class="hljs-string"><span class="hljs-string">"test"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = x + <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      &lt;Foo as Add&gt;::add(42)  x assert_eq!(y, Bar("test", 42)); }</span></span></code> </pre> <br><p>  In diesem Beispiel wird der Typ der Variablen <code>y</code> durch den Additionsalgorithmus bestimmt, nicht durch den aufrufenden Code.  Es wäre sehr seltsam, wenn es möglich wäre, etwas wie <code>let y: Baz = x + 42</code> zu schreiben, dh die Additionsoperation zu zwingen, ein Ergebnis eines fremden Typs zurückzugeben.  Aus solchen <code>Add::Output</code> versichert uns der zugehörige Typ <code>Add::Output</code> . </p><br><h3 id="itogo">  Insgesamt </h3><br><p>  Wir verwenden Generika, bei denen es uns nichts ausmacht, mehrere Trait-Implementierungen für denselben Typ zu haben, und bei denen es akzeptabel ist, auf der Aufrufseite eine bestimmte Implementierung anzugeben.  Wir verwenden zugehörige Typen, bei denen wir eine "kanonische" Implementierung haben möchten, die selbst die Typen steuert.  Kombinieren und mischen Sie in den richtigen Proportionen, wie im letzten Beispiel. </p><br><p>  Ist die Münze ausgefallen?  Töte mich mit Kommentaren. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441444/">https://habr.com/ru/post/de441444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441428/index.html">PowerShell-Grundlagen: Definieren des Zeilenende mit einem bestimmten Zeichen</a></li>
<li><a href="../de441430/index.html">Zum ersten Mal probieren wir App Center aus und berichten über unsere Erfahrungen</a></li>
<li><a href="../de441436/index.html">Wissenschaftler haben mithilfe der CRISPR-Technik universelle Stammzellen gezüchtet</a></li>
<li><a href="../de441438/index.html">Unified Services goszakup.gov.kz - Version 2</a></li>
<li><a href="../de441442/index.html">YouTube hat Anti-Impfstoff-Anzeigen deaktiviert</a></li>
<li><a href="../de441446/index.html">Computer lernen: Wie man neue Fähigkeiten erlangt</a></li>
<li><a href="../de441448/index.html">Unmögliche Pfanne und andere Penrose-Kacheln gewinnen</a></li>
<li><a href="../de441450/index.html">Pentesting Azure - Gedanken zur Sicherheit im Cloud Computing</a></li>
<li><a href="../de441452/index.html">Drei Zen-reaktive Erweiterungen</a></li>
<li><a href="../de441454/index.html">Die NASA warnt SpaceX und Boeing vor Fehlern in Raumfahrzeugen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>