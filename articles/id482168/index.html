<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖖🏻 👍🏿 👥 "Saat jam menunjukkan pukul dua belas." Atau karangan bunga di browser 🏌️ 🤦🏿 🎇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Misalkan kita memiliki beberapa monitor. Dan kami ingin menggunakan monitor ini sebagai karangan bunga. Misalnya, buat mereka berkedip pada saat bersa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Saat jam menunjukkan pukul dua belas." Atau karangan bunga di browser</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482168/">  Misalkan kita memiliki beberapa monitor.  Dan kami ingin menggunakan monitor ini sebagai karangan bunga.  Misalnya, buat mereka berkedip pada saat bersamaan.  Atau mungkin secara serentak mengubah warnanya menurut semacam algoritma pintar.  Dan bagaimana jika Anda melakukannya di browser - maka Anda dapat menghubungkan ponsel cerdas dan tablet ke ini.  Semua itu ada di tangan. <br><br><img src="https://habrastorage.org/webt/yo/1c/a8/yo1ca85ahnnxg_5crc1hh84n9ng.jpeg"><br><br>  Dan, karena kami menggunakan browser, Anda juga dapat menambahkan desain suara.  Lagi pula, jika cukup akurat untuk menyinkronkan perangkat dalam waktu, maka Anda dapat memutar suara pada masing-masing seolah-olah satu sistem multichannel terdengar. <br><br><hr>  <i>Apa yang bisa ditemui ketika menyinkronkan Audio Web dan jam gameplay di dalam aplikasi javascript;</i>  <i>berapa banyak "jam" yang berbeda ada di javasctipt (tiga!) dan mengapa semuanya diperlukan, serta aplikasi <a href="http://habr.snowtime.fun/" rel="nofollow">siap pakai</a> untuk node.js di bawah kucing.</i> <a name="habracut"></a><hr><br><h2>  Periksa jamnya </h2><br>  Untuk garland online bersyarat, sinkronisasi jam yang akurat diperlukan.  Setelah semua, maka Anda dapat mengabaikan penundaan jaringan (bahkan terputus-putus).  Cukup memberi cap kontrol waktu dan menghasilkan perintah-perintah ini sedikit "ke masa depan".  Pada klien, mereka akan disangga dan kemudian dieksekusi secara sinkron dan tepat waktu. <br><br>  Atau Anda bahkan dapat melangkah lebih jauh - ambil algoritma acak deterministik lama yang baik dan gunakan satu seed yang umum (dikeluarkan oleh server satu kali, saat terhubung) pada semua perangkat.  Jika Anda menggunakan seed tersebut <i>bersama</i> dengan waktu yang tepat, Anda dapat sepenuhnya menentukan perilaku algoritma pada semua perangkat.  Bayangkan saja: pada kenyataannya, Anda tidak perlu jaringan atau server untuk secara unik dan sinkron mengubah keadaan.  Seed sudah berisi seluruh "perekaman video" tindakan sebelumnya.  Yang utama adalah waktu yang tepat. <br><br><img src="https://habrastorage.org/webt/kd/tx/tt/kdtxttvwqoqkb69jvoov077o8vs.gif"><br><hr>  <i>Setiap metode memiliki batas penerapannya.</i>  <i>Dengan input pengguna instan, tentu saja, tidak ada yang bisa dilakukan, tetap mengirimkannya "apa adanya".</i>  <i>Tapi semua yang bisa dihitung harus dihitung.</i>  <i>Dalam implementasi saya, saya menggunakan ketiga pendekatan, tergantung pada situasinya.</i> <hr><br><h2>  Subyektif "pada saat yang sama" </h2><br>  Idealnya, semuanya harus berbunyi "pada saat yang sama" - tidak lebih dari ± 10 ms perbedaan diperlukan untuk pasangan terburuk di antara perangkat gabungan.  Anda tidak dapat mengandalkan keakuratan seperti itu dari waktu sistem, dan metode standar untuk menyinkronkan waktu menggunakan protokol NTP tidak tersedia di browser.  Karena itu, kami akan mengarahkan server sinkronisasi kami.  Prinsipnya sederhana: helm "ping" dan terima "pong" dengan cap waktu server.  Jika Anda melakukan ini berkali-kali berturut-turut, Anda dapat secara statistik meratakan kesalahan dan mendapatkan waktu tunda rata-rata. <br><br><div class="spoiler">  <b class="spoiler_title">Kode: menghitung waktu server pada klien</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pingClientTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// performace.now() time when ping started let pongClientTime = 3; // performace.now() time when pong received let pongServerTime = 20; // server timstamp in pong answer let clientServerRawOffset = pongServerTime - pongClientTime; let pingPongOffset = pongClientTime - pingClientTime; // roundtrip let estimatedPingOffset = pingPongOffset / 2; // one-way let offset = clientServerRawOffset + estimatedPingOffset; console.log(estimatedPingOffset) // 1 console.log(offset); // 18 let sharedServerTime = performace.now() + offset;</span></span></code> </pre> <br></div></div><br><br>  Soket web dan solusi berdasarkannya paling cocok karena mereka tidak memerlukan waktu untuk membuat koneksi TCP, dan Anda dapat "berkomunikasi" dengan mereka dari dua arah.  Bukan UDP atau ICMP, tentu saja, tetapi jauh lebih cepat daripada koneksi dingin biasa menggunakan HTTP API.  Karena itu, socket.io.  Semuanya sangat mudah di sana: <br><br><div class="spoiler">  <b class="spoiler_title">Kode: implementasi socket.io</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// server socket.on('ping', (pongCallback) =&gt; { let pongServerTime = performace.now(); pongCallback(pongServerTime); }); //client const binSize = 100; let clientServerCalculatedOffset; function ping() { socket.emit('ping', pongCallback); const pingClientTime = performace.now(); function pongCallback(pongServerTime) { const pongClientTime = performace.now(); const clientServerRawOffset = pongServerTime - pongClientTime; const pingPongOffset = pongClientTime - pingClientTime; // roundtrip const estimatedPingOffset = pingPongOffset / 2; // one-way const offset = clientServerRawOffset + estimatedPingOffset; offsets.unshift(offset); offsets.splice(binSize); let offsetSum = 0; offsets.forEach((offset) =&gt; { offsetSum += offset; }); clientServerCalculatedOffset = offsetSum / offset.length(); } }</span></span></code> </pre> <br>  <i>Akan lebih baik, daripada menghitung rata-rata, untuk menghitung median - ini akan meningkatkan akurasi dengan koneksi yang tidak stabil.</i>  <i>Pilihan metode penyaringan terserah pembaca.</i>  <i>Saya sengaja menyederhanakan kode di sini demi skema.</i>  <i>Solusi lengkap saya dapat ditemukan di repositori.</i> <br></div></div><br><br><h2>  performance.now () </h2><br>  Biarkan saya mengingatkan Anda bahwa objek <code>performance</code> adalah API yang menyediakan akses ke timer resolusi tinggi.  Bandingkan: <br><br><ul><li>  <b><code>Date.now()</code></b> mengembalikan jumlah milidetik sejak 1 Januari 1970, dan melakukannya dalam bentuk <b>bilangan bulat</b> .  Artinya, kesalahan hanya dari pembulatan rata-rata adalah 0,5 ms.  Misalnya, pada satu operasi pengurangan <code>ab</code> Anda tidak berhasil “kehilangan” hingga 2 ms.  Selain itu, secara historis dan konseptual, meteran waktu itu sendiri tidak menjamin akurasi tinggi dan dipertajam untuk bekerja dengan skala waktu yang lebih besar. </li><li>  <b><code>performance.now()</code></b> mengembalikan jumlah milidetik <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp" rel="nofollow">sejak halaman web dibuka</a> . <br>  Ini adalah API yang relatif baru, "diasah" khusus untuk pengukuran interval waktu yang akurat.  Mengembalikan <b>nilai floating-point</b> , secara teoritis memberikan tingkat akurasi yang dekat dengan kemampuan OS itu sendiri. <br></li></ul><br><br>  Saya pikir informasi ini diketahui hampir semua pengembang javascript.  Tetapi tidak semua orang tahu bahwa ... <br><br><h2>  Momok </h2><br>  Karena serangan timing sensasional Specter pada tahun 2018, semuanya berjalan ke titik bahwa timer resolusi tinggi akan secara kasar dibuat jika tidak ada solusi lain untuk masalah kerentanan.  Firefox, mulai dari versi 60, membulatkan nilai pengatur waktu ini menjadi milidetik, dan Edge, bahkan lebih buruk. <br><br>  Inilah yang dikatakan <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now" rel="nofollow">MDN</a> : <br><br><blockquote>  Cap waktu sebenarnya bukan resolusi tinggi.  Untuk mengurangi ancaman keamanan seperti Spectre, browser saat ini membulatkan hasilnya ke berbagai tingkat.  (Firefox mulai membulatkan ke 1 milidetik di Firefox 60.) Beberapa browser mungkin juga sedikit mengacak cap waktu.  Presisi dapat meningkat lagi di rilis mendatang;  pengembang peramban masih menyelidiki serangan waktu ini dan cara terbaik untuk menguranginya. </blockquote><br>  Mari kita jalankan tes dan lihat grafiknya.  Ini adalah hasil pengujian pada interval 10 ms: <br><br><div class="spoiler">  <b class="spoiler_title">Kode uji: pengukuran waktu dalam satu siklus</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <br><h3>  Edge </h3><br><img src="https://habrastorage.org/webt/g2/t2/bs/g2t2bssr-dhq8cbyb95-pwjxclw.png"><br><div class="spoiler">  <b class="spoiler_title">statistik</b> <div class="spoiler_text">  Versi Browser: 44.17763.771.0 <br><br><h3>  Date.now () </h3>  Interval rata-rata: 1.0538336052202284 ms <br>  penyimpangan dari interval rata-rata, RMS: 0.7547819181245603 ms <br>  median interval: 1 ms <br><br><h3>  performance.now () </h3>  interval rata-rata: 1.567100970873786 ms <br>  penyimpangan dari interval rata-rata, RMS: 0.6748006785171455 ms <br>  interval median: 1,5015000000003056 ms <br></div></div><br><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/7y/6b/a_/7y6ba_0b_lgehjq2yko_60ip4am.png"><br><div class="spoiler">  <b class="spoiler_title">statistik</b> <div class="spoiler_text">  Versi Browser: 71.0 <br><br><h3>  Date.now () </h3>  interval rata-rata: 1.0168350168350169 ms <br>  penyimpangan dari interval rata-rata, RMS: 0,21645930182417966 ms <br>  median interval: 1 ms <br><br><h3>  performance.now () </h3>  Interval rata-rata: 1.0134453781512605 ms <br>  penyimpangan dari interval rata-rata, RMS: 0.1734108492762375 ms <br>  median interval: 1 ms <br></div></div><br><br><h3>  Chrome </h3><br><img src="https://habrastorage.org/webt/zv/_y/pp/zv_yppcegrbidigvmp6npdcwzf0.png"><br><div class="spoiler">  <b class="spoiler_title">statistik</b> <div class="spoiler_text">  Versi Browser: 79.0.3945.88 <br><br><h3>  Date.now () </h3>  interval rata-rata: 1.02442996742671 ms <br>  penyimpangan dari interval rata-rata, RMS: 0.49858684744444 ms <br>  median interval: 1 ms <br><br><h3>  performance.now () </h3>  interval rata-rata: 0,005555847229948915 ms <br>  penyimpangan dari interval rata-rata, RMS: 0,027497846727194235 ms <br>  interval median: 0,0050000089686363935 ms <br></div></div><br><br>  Oke, Chrome, perbesar hingga 1 msec. <br><br><img src="https://habrastorage.org/webt/2o/9m/ik/2o9mikwf_owbi8mn1saodrmd_e8.png"><br><br>  Jadi, Chrome masih bertahan, dan penerapannya <code>performance.now()</code> belum dicekik dan langkahnya indah 0,005 ms.  Di bawah Edge, timer <code>performance.now()</code> lebih kasar daripada <code>Date.now()</code> !  Di Firefox, kedua penghitung waktu memiliki akurasi milidetik yang sama. <br><br>  Pada tahap ini, beberapa kesimpulan sudah bisa ditarik.  Tetapi ada timer lain di javascript (yang tanpanya kita tidak bisa melakukannya tanpa). <br><br><h2>  Timer WebAudio API </h2><br>  Ini adalah binatang yang sedikit berbeda.  Ini digunakan untuk antrian audio yang tertunda.  Faktanya adalah bahwa peristiwa audio (memainkan catatan, mengelola efek) tidak dapat mengandalkan alat javascript asinkron standar: <code>setInterval</code> dan <code>setTimeout</code> - karena kesalahannya yang terlalu besar.  Dan ini bukan hanya kesalahan <i>nilai-nilai</i> timer (dengan yang kita bahas sebelumnya), tetapi ini adalah kesalahan yang mesin acara mengeksekusi peristiwa.  Dan itu sudah sekitar 5-25 ms, bahkan dalam kondisi rumah kaca. <br><br><div class="spoiler">  <b class="spoiler_title">Grafik untuk kasus asinkron di bawah spoiler</b> <div class="spoiler_text">  Hasil tes selama interval 100 ms: <br><br><div class="spoiler">  <b class="spoiler_title">Kode uji: pengukuran waktu dalam siklus asinkron</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">duration</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(); }, duration); }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInAsyncLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pause(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <br><h3>  Edge </h3><br><img src="https://habrastorage.org/webt/_z/im/h2/_zimh2thj4w5t2o_ounushbk94m.png"><br><div class="spoiler">  <b class="spoiler_title">statistik</b> <div class="spoiler_text">  Versi Browser: 44.17763.771.0 <br><br><h3>  Date.now () </h3>  Interval rata-rata: 25.59595959595959595 ms <br>  penyimpangan dari interval rata-rata, RMS: 10.12639235162126 ms <br>  median interval: 28 ms <br><br><h3>  performance.now () </h3>  Interval rata-rata: 25.862596938775525 ms <br>  penyimpangan dari interval rata-rata, RMS: 10.123711255512573 ms <br>  interval median: 27.027099999999336 ms <br></div></div><br><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/bm/pn/bs/bmpnbsvv3esgusduj0djwdvazg4.png"><br><div class="spoiler">  <b class="spoiler_title">statistik</b> <div class="spoiler_text">  Versi Browser: 71.0 <br><br><h3>  Date.now () </h3>  interval rata-rata: 1.6914893617021276 ms <br>  penyimpangan dari interval rata-rata, RMS: 0.6018870280772611 ms <br>  median interval: 2 ms <br><br><h3>  performance.now () </h3>  interval rata-rata: 1.7865168539325842 ms <br>  penyimpangan dari interval rata-rata, RMS: 0.6442818510935484 ms <br>  median interval: 2 ms <br></div></div><br><br><h3>  Chrome </h3><br><img src="https://habrastorage.org/webt/ig/my/wf/igmywf_jvwphlqdqm9qac2evy64.png"><br><div class="spoiler">  <b class="spoiler_title">statistik</b> <div class="spoiler_text">  Versi Browser: 79.0.3945.88 <br><br><h3>  Date.now () </h3>  interval rata-rata: 4.787878787878787888, ms <br>  penyimpangan dari interval rata-rata, RMS: 0.7557553886872682 ms <br>  median interval: 5 ms <br><br><h3>  performance.now () </h3>  interval rata-rata: 4.783989898979516 ms <br>  penyimpangan dari interval rata-rata, RMS: 0,6483716900974945 ms <br>  interval median: 4.750000000058208 ms <br></div></div><br></div></div><br><br>  Mungkin seseorang akan mengingat aplikasi audio HTML eksperimental pertama.  Sebelum WebAudio lengkap datang ke browser - mereka semua terdengar seperti sedikit mabuk, ceroboh.  Hanya karena mereka menggunakan <code>setTimeout</code> sebagai sequencer. <br><br>  WebAudio API modern, sebaliknya, memberikan resolusi dijamin hingga 0,02 ms (spekulasi berdasarkan frekuensi sampling 44100Hz).  Ini disebabkan oleh fakta bahwa mekanisme yang berbeda digunakan untuk pemutaran suara yang tertunda daripada <code>setTimeout</code> : <br><br><pre> <code class="javascript hljs">source.start(when);</code> </pre> <br>  Faktanya, setiap reproduksi sampel audio "tertunda".  Hanya untuk menghilangkannya "tidak ditunda", Anda harus menundanya "sampai sekarang". <br><br><pre> <code class="javascript hljs">source.start(audioCtx.currentTime);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Tentang musik yang dihasilkan perangkat lunak waktu-nyata</b> <div class="spoiler_text">  Jika Anda memainkan melodi yang disintesis-program dari catatan, maka catatan ini perlu ditambahkan sedikit di antrean pemutaran terlebih dahulu.  Kemudian, terlepas dari semua pembatasan dan penyimpangan non-fundamental dari timer, melodi akan bermain dengan sangat lancar. <br><br>  Dengan kata lain, melodi yang disintesis secara waktu nyata tidak boleh "diciptakan" secara waktu nyata, tetapi sedikit di muka. <br></div></div><br><br><h2>  Satu pengatur waktu untuk mengatur semuanya </h2><br>  Karena <code>audioCtx.currentTime</code> sangat stabil dan akurat, mungkin kita harus menggunakannya sebagai sumber utama waktu relatif?  Ayo jalankan tes lagi. <br><br><div class="spoiler">  <b class="spoiler_title">Kode uji: mengukur pengukuran waktu sinkron dalam satu siklus</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); a[i] = audioCtx.currentTime * <span class="hljs-number"><span class="hljs-number">1000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p, a } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <img src="https://habrastorage.org/webt/xo/or/r9/xoorr9ldh_oivoxxvbxj8yozwqc.png" align="left"> <code>audioCtx.currentTime</code> <br> <br><h3>  Edge </h3><br><img src="https://habrastorage.org/webt/rt/xx/u0/rtxxu0ckburybooxuw93uiya7-s.png"><br><div class="spoiler">  <b class="spoiler_title">statistik</b> <div class="spoiler_text">  Versi Browser: 44.17763.771.0 <br><br><h3>  Date.now () </h3>  Interval rata-rata: 1.037037037037037 ms <br>  penyimpangan dari interval rata-rata, RMS: 0,6166609846299806 ms <br>  median interval: 1 ms <br><br><h3>  performance.now () </h3>  interval rata-rata: 1.5447103117505993 ms <br>  penyimpangan dari interval rata-rata, RMS: 0.4390514285320851 ms <br>  interval median: 1,5015000000000782 ms <br><br><h3>  audioCtx.currentTime </h3>  interval rata-rata: 2.955751134714949 ms <br>  penyimpangan dari interval rata-rata, RMS: 0,6193645611529503 ms <br>  interval median: 2.902507781982422 ms <br><br></div></div><br><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/rr/v6/ws/rrv6wsi1tmnpdb8yf7y6wmfvyo8.png"><br><div class="spoiler">  <b class="spoiler_title">statistik</b> <div class="spoiler_text">  Versi Browser: 71.0 <br><br><h3>  Date.now () </h3>  interval rata-rata: 1,005128205128205 ms <br>  penyimpangan dari interval rata-rata, RMS: 0.12392867665225249 ms <br>  median interval: 1 ms <br><br><h3>  performance.now () </h3>  interval rata-rata: 1,00513698630137 ms <br>  penyimpangan dari interval rata-rata, RMS: 0,07148844433269844 ms <br>  median interval: 1 ms <br><br><h3>  audioCtx.currentTime </h3>  Firefox tidak memperbarui nilai timer audio dalam loop sinkronisasi <br><br></div></div><br><br><h3>  Chrome </h3><br><img src="https://habrastorage.org/webt/yx/wx/rk/yxwxrkmxhv3yzxzpzckvfhouz6y.png"><br><div class="spoiler">  <b class="spoiler_title">statistik</b> <div class="spoiler_text">  Versi Browser: 79.0.3945.88 <br><br><h3>  Date.now () </h3>  interval rata-rata: 1.0207612456747406 ms <br>  penyimpangan dari interval rata-rata, RMS: 0.49870223457982504 ms <br>  median interval: 1 ms <br><br><h3>  performance.now () </h3>  interval rata-rata: 0,005414502034674972 ms <br>  penyimpangan dari interval rata-rata, RMS: 0,027441293974958335 ms <br>  interval median: 0,004999999873689376 ms <br><br><h3>  audioCtx.currentTime </h3>  interval rata-rata: 3.0877599266656963 ms <br>  penyimpangan dari interval rata-rata, RMS: 1.1445555956407658 ms <br>  interval median: 2.9024943310650997 ms <br><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Grafik untuk kasus asinkron di bawah spoiler</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Kode uji: pengukuran waktu dalam siklus asinkron</b> <div class="spoiler_text">  Hasil tes selama interval 100 ms: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">duration</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(); }, duration); }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInAsyncLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pause(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <img src="https://habrastorage.org/webt/xo/or/r9/xoorr9ldh_oivoxxvbxj8yozwqc.png" align="left"> <code>audioCtx.currentTime</code> <br> <br><h3>  Edge </h3><br><img src="https://habrastorage.org/webt/3o/sz/az/3oszazaq71kxfdaftgn6v3z23xe.png"><br><div class="spoiler">  <b class="spoiler_title">statistik</b> <div class="spoiler_text">  Versi Browser: 44.17763.771.0 <br><br><h3>  Date.now (): </h3>  interval rata-rata: 24.505050505050505 ms <br>  deviasi dari interval rata-rata: 11.513166584195204 ms <br>  median interval: 26 ms <br><br><h3>  performance.now (): </h3>  interval rata-rata: 24.50935757575754 ms <br>  deviasi dari interval rata-rata: 11.679091435527388 ms <br>  interval median: 25.525499999999738 ms <br><br><h3>  audioCtx.currentTime: </h3>  Interval rata-rata: 24.76005164944396 ms <br>  deviasi dari interval rata-rata: 11.311571546205316 ms <br>  interval median: 26.121139526367187 ms <br><br></div></div><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/wf/4n/jn/wf4njn3z7u9uoxluprufhlbctai.png"><br><div class="spoiler">  <b class="spoiler_title">statistik</b> <div class="spoiler_text">  Versi Browser: 71.0 <br><br><h3>  Date.now (): </h3>  interval rata-rata: 1,6875 ms <br>  deviasi dari interval rata-rata: 0.6663410663216448 ms <br>  median interval: 2 ms <br><br><h3>  performance.now (): </h3>  interval rata-rata: 1.7234042553191489 ms <br>  deviasi dari interval rata-rata: 0.6588877688171075 ms <br>  median interval: 2 ms <br><br><h3>  audioCtx.currentTime: </h3>  interval rata-rata: 10.158730158730123 ms <br>  deviasi dari interval rata-rata: 1.4512471655330046 ms <br>  interval median: 8.707482993195299 ms <br><br></div></div><br><h3>  Chrome </h3><br><img src="https://habrastorage.org/webt/_s/hd/uh/_shduhzpetwube_gn6kxmwyobiu.png"><br><div class="spoiler">  <b class="spoiler_title">statistik</b> <div class="spoiler_text">  Versi Browser: 79.0.3945.88 <br><br><h3>  Date.now (): </h3>  Interval rata-rata: 4,585858585858586 ms <br>  deviasi dari interval rata-rata: 0,9102125516015199 ms <br>  median interval: 5 ms <br><br><h3>  performance.now (): </h3>  interval rata-rata: 4,592424242424955 ms <br>  deviasi dari interval rata-rata: 0.719936993603155 ms <br>  interval median: 4.605000001902226 ms <br><br><h3>  audioCtx.currentTime: </h3>  interval rata-rata: 10.12648022171832 ms <br>  deviasi dari interval rata-rata: 1,4508887886499262 ms <br>  interval median: 8.707482993197118 ms <br><br></div></div><br></div></div><br>  Yah, itu tidak akan berhasil.  "Di luar", timer ini adalah yang paling tidak akurat.  Firefox tidak memperbarui nilai timer di dalam loop.  Tetapi secara umum: resolusi adalah 3 ms dan jitter lebih buruk dan terlihat.  Mungkin nilai <code>audioCtx.currentTime</code> mencerminkan posisi di buffer cincin driver kartu audio.  Dengan kata lain, ini menunjukkan waktu minimum yang memungkinkan untuk menunda pemutaran dengan aman. <br><br>  Dan apa yang harus dilakukan?  Bagaimanapun, kita membutuhkan penghitung waktu yang akurat untuk menyinkronkan dengan server dan meluncurkan acara javascript di layar, dan penghitung audio untuk acara suara! <br><br>  Ternyata Anda harus menyinkronkan semua penghitung waktu satu sama lain: <br><br><ul><li>  Klien <code>audioCtx.currentTime</code> dengan klien <code>performance.now()</code> pada klien. </li><li>  Dan client <code>performance.now()</code> dengan <code>performance.now()</code> sisi server. </li></ul><br><h2>  Disinkronkan, disinkronkan </h2><br><img src="https://habrastorage.org/webt/f1/ph/o9/f1pho9gss4d40786nszfeicwrog.png" align="right">  Secara umum, ini cukup lucu jika Anda memikirkannya: Anda dapat memiliki dua sumber waktu A dan B, yang masing-masing sangat kasar dan berisik pada keluaran (A '= A + err <sub>A</sub> ; B' = B + err <sub>B</sub> ) sehingga dapat bahkan tidak dapat digunakan sendiri.  Tetapi perbedaan antara sumber asli yang tidak berisik dapat dipulihkan dengan sangat akurat. <br><br>  Karena jarak waktu sebenarnya antara jam ideal adalah konstan, mengambil pengukuran n kali, kita akan mengurangi kesalahan pengukuran sesekali kali.  Kecuali, tentu saja, jam berjalan pada kecepatan yang sama. <br><br><h2>  Ya tidak disinkronkan </h2><br>  Berita buruknya adalah tidak, mereka tidak pergi dengan kecepatan yang sama.  Dan saya tidak berbicara tentang perbedaan jam di server dan pada klien - ini bisa dimengerti dan diharapkan.  Apa yang lebih tak terduga: <code>audioCtx.currentTime</code> secara bertahap menyimpang dari <code>performance.now()</code> .  Itu ada di dalam klien.  Kita mungkin tidak melihat, tetapi kadang-kadang, di bawah beban, sistem audio mungkin tidak menelan sepotong kecil data dan (bertentangan dengan sifat buffer cincin) waktu audio akan bergeser relatif terhadap waktu sistem.  Ini jarang terjadi, itu tidak menjadi perhatian banyak orang: tetapi jika, misalnya, Anda meluncurkan dua video YouTube secara bersamaan di komputer yang berbeda, itu bukan fakta bahwa mereka akan berhenti bermain pada saat yang sama.  Dan intinya, tentu saja, bukan dalam iklan. <br><br>  Jadi, untuk operasi yang stabil dan sinkron.  Kita perlu memeriksa kembali semua jam <i>secara teratur</i> , menggunakan waktu server - sebagai referensi.  Dan kemudian trade-off muncul dalam berapa banyak pengukuran yang digunakan untuk rata-rata: semakin banyak - semakin akurat, tetapi semakin besar kemungkinan lompatan tajam pada <code>audioCtx.currentTime</code> jatuh ke jendela waktu di mana kita memfilter nilai.  Kemudian, jika kita, misalnya, menggunakan jendela menit, maka semua menit kita akan memiliki waktu berlalu.  Pilihan filter luas: <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BA%25D1%2581%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B3%25D0%25BB%25D0%25B0%25D0%25B6%25D0%25B8%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5" rel="nofollow">eksponensial</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25B0%25D0%25BD%25D0%25B0_(%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)" rel="nofollow">median</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D0%259A%25D0%25B0%25D0%25BB%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0" rel="nofollow">filter Kalman</a> , dll.  Tetapi pertukaran ini dalam hal apapun. <br><br><h2>  Jendela waktu </h2><br>  Dalam kasus sinkronisasi <code>audioCtx.currentTime</code> dengan <code>performance.now()</code> , dalam loop asinkron, agar tidak mengganggu UI, kita dapat mengambil satu pengukuran, katakanlah, 100 ms. <br>  Asumsikan bahwa kesalahan pengukuran err = errA + errB = 1 + 3 = 4 ms <br>  Dengan demikian, dalam 1 detik kita dapat menguranginya menjadi 0,4 ms, dan dalam 10 detik menjadi 0,04 ms.  Peningkatan hasil lebih lanjut tidak masuk akal, dan jendela yang bagus untuk penyaringan adalah: 1 - 10 detik. <br><br>  Dalam hal sinkronisasi jaringan, keterlambatan dan kesalahan sudah jauh lebih signifikan, tetapi tidak ada lompatan tajam dalam waktu, seperti dalam kasus <code>audioCtx.currentTime</code> .  Dan Anda dapat membiarkan diri Anda mengumpulkan statistik yang sangat bagus.  Toh, err untuk ping bisa sampai 500 ms.  Dan pengukuran itu sendiri bisa kita lakukan tidak begitu sering. <br><br>  Pada titik ini, saya mengusulkan untuk berhenti.  Jika ada yang tertarik, dengan senang hati saya akan memberi tahu Anda cara "menggambar burung hantu yang tersisa."  Tetapi sebagai bagian dari cerita tentang pengatur waktu, saya pikir kisah saya sudah berakhir. <br><br>  Dan saya ingin membagikan apa yang saya dapatkan.  Semua sama, tahun baru. <br><br><h2>  Apa yang terjadi </h2><br>  Penafian: Secara teknis, ini adalah situs PR di Habré, tetapi ini adalah sepenuhnya proyek nir-laba opensource yang saya berjanji tidak akan pernah: untuk memasang iklan, atau untuk menghasilkan uang dengan cara lain.  Sebaliknya, saya telah mengumpulkan lebih banyak contoh dari uang saya sekarang untuk bertahan dari kemungkinan perilaku.  Karena itu, tolong, orang-orang baik, jangan hancurkan aku dan jangan hubungi aku.  Ini semua murni menyenangkan. <br><br>  Selamat Tahun Baru, Habr! <br><br><hr><br><h3>  <a href="http://habr.snowtime.fun/" rel="nofollow">snowtime.fun</a> </h3>  Anda dapat memutar kenop dan mengontrol visualisasi, musik dan efek audio.  Jika Anda memiliki kartu video normal, buka pengaturan dan atur jumlah partikel menjadi 100%. <br><br>  Membutuhkan WebAudio dan WebGL. <br><br><hr><br><br>  <b>UPD:</b> Tidak berfungsi di Safari di bawah macOS Mojave.  Sayangnya, tidak ada cara untuk dengan cepat mengetahui apa yang terjadi, karena tidak adanya Safari itu sendiri.  iOS tampaknya berfungsi. <br><br>  <b>UPD2:</b> Jika <a href="http://snowtime.fun/" rel="nofollow">snowtime.fun</a> dan <a href="http://web.snowtime.fun/" rel="nofollow">web.snowtime.fun</a> tidak merespons, coba subdomain <a href="http://habr.snowtime.fun/" rel="nofollow">habr <b>.snowtime.fun</b></a> baru.  Dia memindahkan server ke pusat data lain, dan IP lama di-cache dalam DNS, <code>expire=1w</code> .  :( <br><br>  Repositori: <a href="https://bitbucket.org/barkalov/snowtime.fun/src" rel="nofollow">bitbucket</a> <br>  Saat menulis artikel ini, ilustrasi <a href="http://www.freepik.com/" rel="nofollow">macrovector / Freepik</a> digunakan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482168/">https://habr.com/ru/post/id482168/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482136/index.html">Bagaimana proyek monobrand bisa masuk ke TOP dengan mengalahkan agregator dan layanan internal mesin pencari?</a></li>
<li><a href="../id482140/index.html">Permainan papan untuk programmer muda berusia 4-10 tahun. Apa yang bisa ditemukan di pasaran pada akhir 2019</a></li>
<li><a href="../id482142/index.html">23 menit Pembenaran yang cerdik</a></li>
<li><a href="../id482156/index.html">Wawancara dengan Will Kurt tentang buku barunya, Bayesian Statistics - It's Great</a></li>
<li><a href="../id482158/index.html">Temui Ember Octane</a></li>
<li><a href="../id482170/index.html">Perang prosesor. Kisah kelinci biru dan kura-kura merah</a></li>
<li><a href="../id482176/index.html">Bagaimana konferensi @Kubernetes berlangsung pada 29 November: video dan hasil</a></li>
<li><a href="../id482178/index.html">Kisah seorang siswa Korea yang menerima hadiah dari kementerian untuk sistem pemantauan antrian</a></li>
<li><a href="../id482182/index.html">Masalah apa yang akan saya miliki jika saya berjuang untuk keseimbangan gender di bidang TI?</a></li>
<li><a href="../id482186/index.html">Hidup dan TI atau tahun ketika saya berhenti dari pekerjaan terakhir saya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>