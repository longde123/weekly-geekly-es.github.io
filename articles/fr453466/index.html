<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐽 🌩️ 👩🏾‍🔬 HolyJS 2019: débriefing de SEMrush (Partie 2) 🤱🏽 👨🏿 🧑🏾‍🤝‍🧑🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il s'agit de la deuxième partie de l'analyse des tâches de notre stand lors de la conférence HolyJS , tenue à Saint-Pétersbourg du 24 au 25 mai. Pour ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>HolyJS 2019: débriefing de SEMrush (Partie 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/semrush/blog/453466/"><img src="https://habrastorage.org/webt/lu/af/0g/luaf0gd14raqav4knnokeboltkk.jpeg"><br><br>  Il s'agit de la deuxième partie de l'analyse des tâches de notre stand lors de la conférence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HolyJS</a> , tenue à Saint-Pétersbourg du 24 au 25 mai.  Pour plus de contexte, il est recommandé de lire d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">abord</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">première partie de</a> ce document.  Et si l' <i>expression du</i> compte à <i>rebours</i> est déjà terminée, bienvenue à l'étape suivante. <br><a name="habracut"></a><br>  Contrairement à l'obscurantisme dans la première tâche, les deux suivantes ont déjà une idée de l'applicabilité des applications normales dans la vie.  JavaScript se développe encore assez rapidement et les solutions aux problèmes suggérés mettent en évidence certaines des nouvelles fonctionnalités du langage. <br><br><h2>  Tâche 2 ~ effectuée par les uns </h2><br>  Il a été supposé que le code s'exécuterait et imprimerait les réponses à la console en réponse à trois demandes, puis «terminé».  Mais quelque chose s'est mal passé ... Corrigez la situation. <br><br><pre><code class="javascript hljs">;(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = { [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetch(req); } } }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iter) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>); })();</code> </pre> <br><h4>  Problème de recherche </h4><br>  Qu'avons-nous ici?  Il s'agit d'un objet <i>iter</i> <i>itérable</i> qui a un symbole <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>Symbol.iterator</i></a> <i>bien connu</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>défini</i></a> par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une fonction de générateur</a> .  Un tableau <i>fs est</i> déclaré dans le corps de la fonction, dont les éléments tombent dans la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>fetch</i></a> à leur tour pour envoyer une requête et le résultat de chaque appel de fonction est retourné via <i>yield</i> .  Quelles demandes la fonction d' <i>extraction</i> envoie-t-elle?  Tous les éléments du tableau <i>fs</i> sont des chemins relatifs vers les ressources avec les nombres 1, 2 et 3, respectivement.  Ainsi, l'URL complète sera obtenue en concaténant <i>location.origin</i> avec le numéro suivant, par exemple: <br><br> <code>GET https://www.example.com/1 <br></code> <br>  Ensuite, nous voulons itérer l'objet <i>iter à</i> travers <i>for-of</i> , afin d'exécuter chaque demande tour à tour avec la sortie du résultat, après tout - imprimer «done».  Mais ça ne marche pas!  Le problème est que l' <i>extraction</i> est une chose asynchrone et renvoie une promesse, pas une réponse.  Par conséquent, dans la console, nous verrons quelque chose comme ceci: <br><br> <code>Promise {pending} <br> Promise {pending} <br> Promise {pending} <br> done <br></code> <br>  En fait, la tâche se résume à la réalisation de ces mêmes promesses. <br><br><h4>  Nous avons asynchrone / attend </h4><br>  La première pensée peut être de jouer avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>Promise.all</i></a> : donnez-lui notre objet <i>itérable</i> , <i>puis la</i> sortie vers la console est «terminée».  Mais il ne nous fournira pas l'exécution séquentielle des demandes (comme l'exige la condition), mais les enverra simplement toutes et attendra la dernière réponse avant la résolution générale. <br><br>  La solution la plus simple ici serait d' <i>attendre</i> dans le <i>for-of</i> body d'attendre la résolution de la prochaine promesse avant de sortir sur la console: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iter) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> res); }</code> </pre><br>  Pour <i>attendre que cela</i> fonctionne et que "done" soit affiché à la fin, vous devez rendre la fonction principale asynchrone via <i>async</i> : <br><br><pre> <code class="javascript hljs">;(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iter) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> res); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>); })();</code> </pre><br>  Dans ce cas, le problème a déjà été résolu (presque): <br><br> <code>GET 1st <br> Response 1st <br> GET 2nd <br> Response 2nd <br> GET 3rd <br> Response 3rd <br> done <br></code> <br><h4>  Itérateur et générateur asynchrones </h4><br>  Nous laisserons la fonction principale asynchrone, mais pour <i>wait</i> il y a une place plus élégante dans cette tâche que dans le corps <i>for-of</i> : c'est l'utilisation de l'itération asynchrone via <a href=""><i>for-wait-of</i></a> , à savoir: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iter) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res); }</code> </pre><br>  Tout fonctionnera!  Mais si vous passez à la description de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette <i>proposition</i></a> sur l'itération asynchrone, voici ce qui est intéressant: <br><br><blockquote>  Nous introduisons une variation de l'instruction d'itération for-of qui itère sur les objets itérables asynchrones.  Les instructions for-of asynchrones ne sont autorisées que dans les fonctions asynchrones et les fonctions du générateur asynchrone </blockquote><br>  Autrement dit, notre objet doit être non seulement <i>itérable</i> , mais <i>«asyncIterable»</i> via le nouveau symbole <i>bien connu</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>Symbol.asyncIterator</i></a> et, dans notre cas, déjà une fonction de générateur asynchrone: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = { [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.asyncIterator]: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(req); } } };</code> </pre><br>  Comment cela fonctionne-t-il alors sur un itérateur et un générateur réguliers?  Oui, juste implicitement, comme beaucoup plus dans cette langue.  Cette <i>attente</i> est délicate: si l'objet est seulement <i>itérable</i> , alors pendant l'itération asynchrone, il "convertit" l'objet en <i>asyncIterable</i> en <i>encapsulant</i> les éléments (si nécessaire) dans <i>Promise</i> avec l'attente de résolution.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Décrit</a> plus en détail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans l'article</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Axel Rauschmayer</a> . <br><br>  Probablement, grâce à <i>Symbol.asyncIterator,</i> ce sera toujours plus correct, car nous avons explicitement créé l'objet <i>asyncIterable</i> pour notre itération asynchrone via <i>for-wait-of</i> , tout en laissant la possibilité de compléter l'objet avec un itérateur régulier pour <i>for</i> <i>of</i> , si nécessaire.  Si vous voulez lire quelque chose d'utile et suffisant dans un article sur les itérations asynchrones en JavaScript, alors le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici</a> ! <br><br>  Le <i>for-of</i> asynchrone est encore partiellement en projet, mais il est déjà pris en charge par les navigateurs modernes (sauf Edge) et Node.js à partir de 10.x.  Si cela dérange quelqu'un, vous pouvez toujours écrire votre propre petit polyphile pour une chaîne de promesses, par exemple, pour un objet <i>itérable</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chain = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">promises, callback</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">it</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = it.next(); i.done ? resolve() : i.value.then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> { callback(res); next(it); }); }(promises[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]()) ); ;(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = { <span class="hljs-comment"><span class="hljs-comment">/* iterable */</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> chain(iter, <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>); })();</code> </pre><br>  De cette manière et de ces façons, nous avons compris l'envoi des demandes et le traitement des réponses à leur tour.  Mais dans ce problème, il y a un autre problème petit mais ennuyeux ... <br><br><h4>  Test de pleine conscience </h4><br>  Nous étions tellement emportés par tout cet asynchronisme que, comme cela arrive souvent, nous avons perdu de vue un petit détail.  Ces demandes sont-elles envoyées par notre script?  Voyons le <i>réseau</i> : <br><br> <code>GET https://www.example.com/0 <br> GET https://www.example.com/1 <br> GET https://www.example.com/2 <br></code> <br>  Mais nos nombres sont 1, 2, 3. Comme si une décrémentation s'était produite.  Pourquoi  Juste dans le code source de la tâche, il y a un autre problème avec l'itération, ici: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetch(req); }</code> </pre><br>  Ici, un <i>for-in est utilisé</i> , qui au lieu des valeurs de tableau contourne ses propriétés énumérées: et ce sont les indices des éléments de 0 à 2. La fonction <i>fetch</i> les mène toujours à des chaînes et, malgré l'absence de barre oblique avant (ce n'est plus un <i>chemin</i> ), elle résout relativement URL de la page actuelle.  Il est beaucoup plus facile de réparer que de remarquer.  Deux options: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetch(req); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fs = [<span class="hljs-string"><span class="hljs-string">'/1'</span></span>, <span class="hljs-string"><span class="hljs-string">'/2'</span></span>, <span class="hljs-string"><span class="hljs-string">'/3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetch(fs[req]); }</code> </pre><br>  Dans le premier, nous avons utilisé le même <i>for-of</i> pour parcourir les valeurs du tableau, dans le second - accès à l'élément du tableau par index. <br><br><h4>  La motivation </h4><br>  Nous avons envisagé 3 solutions: 1) par <i>attente</i> dans le corps <i>de for</i> , 2) par <i>attente de,</i> et 3) par le biais de notre polyfichier (fonction récursive, <i>pipeline de</i> canalisation, etc.).  Il est curieux que ces options aient divisé les participants à la conférence à peu près également et aucun favori évident n'a été révélé.  Dans les grands projets, pour de telles tâches réelles, une bibliothèque réactive (par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RxJS</a> ) est généralement utilisée, mais il convient de se rappeler des fonctionnalités natives modernes d'un langage à caractère asynchrone. <br><br>  Environ la moitié des participants n'ont pas remarqué d'erreurs dans l'itération de la liste des ressources, ce qui est également une observation intéressante.  En nous concentrant sur un problème non trivial mais évident, nous pouvons facilement ignorer cette apparence insignifiante, mais avec de graves conséquences potentielles. <br><br><h2>  Problème 3 ~ Facteur 19 </h2><br>  Combien de fois dans le record du nombre 2019!  (factorielle à partir de 2019) le nombre 19 se produit-il?  Avec la réponse, fournissez une solution JavaScript. <br><br><h4>  Problème de recherche </h4><br>  Le problème est en surface: nous avons besoin d'un enregistrement d'un très grand nombre pour y trouver le nombre de toutes les occurrences de la sous-chaîne «19».  Résolvant le problème sur les <i>nombres</i> , nous avons très rapidement rencontré <i>Infinity</i> (après 170) et n'avons rien obtenu.  De plus, le format de représentation des nombres <i>float64</i> garantit l'exactitude de seulement 15-17 caractères, et nous devons obtenir non seulement un enregistrement complet, mais aussi précis du nombre.  La principale difficulté est donc de déterminer la structure d'accumulation de ce grand nombre. <br><br><h4>  Grands entiers </h4><br>  Si vous suivez les innovations du langage, la tâche est résolue simplement: au lieu du <i>numéro de</i> type <i>,</i> vous pouvez utiliser le nouveau type <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>BigInt</i> (étape 3)</a> , qui vous permet de travailler avec des nombres de précision arbitraires.  Avec la fonction récursive classique pour le calcul factoriel et la recherche de correspondances via <i>String.prototype.split, la</i> première solution ressemble à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fn = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>n ? n * fn(n - <span class="hljs-number"><span class="hljs-number">1</span></span>n) : <span class="hljs-number"><span class="hljs-number">1</span></span>n; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn(<span class="hljs-number"><span class="hljs-number">2019</span></span>n).toString().split(<span class="hljs-string"><span class="hljs-string">'19'</span></span>).length - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 50</span></span></code> </pre><br>  Cependant, deux mille appels de fonction sur la pile peuvent déjà <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">être dangereux</a> .  Même si vous apportez la solution à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">récursivité de la queue</a> , l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>optimisation des appels de queue</i></a> ne prend toujours en charge que Safari.  Le problème factoriel est ici plus agréable à résoudre à travers un cycle arithmétique ou <i>Array.prototype.reduce</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([...Array(<span class="hljs-number"><span class="hljs-number">2019</span></span>)].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p, _, i</span></span></span><span class="hljs-function">) =&gt;</span></span> p * BigInt(i + <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>n).toString().match(<span class="hljs-regexp"><span class="hljs-regexp">/19/g</span></span>).length); <span class="hljs-comment"><span class="hljs-comment">// 50</span></span></code> </pre><br>  Cela peut sembler une procédure incroyablement longue.  Mais cette impression est trompeuse.  Si vous estimez, nous avons juste besoin de dépenser un peu plus de deux mille multiplications.  À i5-4590 3,30 GHz en chrome, le problème est résolu en moyenne en 4-5 ms (!). <br><br>  Une autre option pour rechercher des correspondances dans une chaîne avec le résultat d'un calcul est <i>String.prototype.match</i> par expression régulière avec l'indicateur de recherche globale: <i>/ 19 / g</i> . <br><br><h4>  Grande arithmétique </h4><br>  Mais que se passe-t-il si nous n'avons pas encore ce <i>BigInt</i> (et les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bibliothèques</a> aussi)?  Dans ce cas, vous pouvez faire vous-même la longue arithmétique.  Pour résoudre le problème, il nous suffit d'implémenter uniquement la fonction de multiplier grand par petit (nous multiplions par des nombres de 1 à 2019).  Nous pouvons contenir un grand nombre et le résultat de la multiplication, par exemple, dans la ligne: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @param {string} big * @param {number} int * @returns {string} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mult = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">big, int</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = <span class="hljs-string"><span class="hljs-string">''</span></span>, carry = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = big.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i -= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prod = big[i] * int + carry; res = prod % <span class="hljs-number"><span class="hljs-number">10</span></span> + res; carry = prod / <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">carry || </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span></span><span class="hljs-function">) + </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">; } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">console</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[...</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2019</span></span></span></span></span><span class="hljs-function">)].</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p, _, i</span></span></span><span class="hljs-function">) =&gt;</span></span> mult(p, i + <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">'1'</span></span>).match(<span class="hljs-regexp"><span class="hljs-regexp">/19/g</span></span>).length); <span class="hljs-comment"><span class="hljs-comment">// 50</span></span></code> </pre><br>  Ici, nous multiplions simplement la colonne en bits de la fin de la ligne au début, comme on nous l'a enseigné à l'école.  Mais la solution nécessite déjà environ 170 ms. <br><br>  Nous pouvons quelque peu améliorer l'algorithme en traitant plus d'un chiffre dans un enregistrement numérique à la fois.  Pour ce faire, nous modifions la fonction et en même temps allons dans les tableaux, afin de ne pas déranger les lignes à chaque fois: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @param {Array&lt;number&gt;} big * @param {number} int * @param {number} digits * @returns {Array&lt;number&gt;} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mult = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">big, int, digits = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = [], carry = <span class="hljs-number"><span class="hljs-number">0</span></span>, div = <span class="hljs-number"><span class="hljs-number">10</span></span> ** digits; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = big.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || carry; i -= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prod = (i &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : big[i] * int) + carry; res.push(prod % div); carry = prod / div | <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.reverse(); }</code> </pre><br>  Ici, les grands nombres sont représentés par un tableau, dont chaque élément stocke des informations sur les <i>chiffres</i> chiffres de l'enregistrement numérique, à l'aide de <i>nombre</i> .  Par exemple, le nombre 2016201720182019 avec <i>chiffres</i> = 3 sera représenté comme: <br><br> <code>'2|016|201|720|182|019' =&gt; [2,16,201,720,182,19] <br></code> <br>  Lors de la conversion en ligne avant une jointure, vous devez vous souvenir des zéros non significatifs.  La fonction <i>facteur</i> renvoie la factorielle calculée par une chaîne, en utilisant la fonction <i>mult</i> avec le nombre spécifié de chiffres traités à la fois dans la représentation "massive" du nombre lors du calcul: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factor = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n, digits = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> [...Array(n)].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p, _, i</span></span></span><span class="hljs-function">) =&gt;</span></span> mult(p, i + <span class="hljs-number"><span class="hljs-number">1</span></span>, digits), [<span class="hljs-number"><span class="hljs-number">1</span></span>]) .map(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'0'</span></span>.repeat(digits - el.length) + el) .join(<span class="hljs-string"><span class="hljs-string">''</span></span>) .replace(<span class="hljs-regexp"><span class="hljs-regexp">/^0+/</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(factor(<span class="hljs-number"><span class="hljs-number">2019</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>).match(<span class="hljs-regexp"><span class="hljs-regexp">/19/g</span></span>).length); <span class="hljs-comment"><span class="hljs-comment">// 50</span></span></code> </pre><br>  L'implémentation «à longueur de genou» via des tableaux s'est avérée plus rapide que via des chaînes, et avec des <i>chiffres</i> = 1, il calcule la réponse déjà en moyenne en 90 ms, <i>chiffres</i> = 3 en 35 ms, <i>chiffres</i> = 6 en seulement 20 ms.  Cependant, rappelez-vous qu'en augmentant le nombre de chiffres, nous approchons d'une situation où la multiplication de <i>nombre</i> par <i>nombre</i> "sous le capot" peut être en dehors du coffre-fort <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>MAX_SAFE_INTEGER</i></a> .  Vous pouvez jouer avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Quelle est la valeur maximale de <i>chiffres</i> que nous pouvons nous permettre pour cette tâche? <br><br>  Les résultats sont déjà assez indicatifs, <i>BigInt</i> est vraiment assez rapide: <br><br><img src="https://habrastorage.org/webt/qq/wb/-j/qqwb-jhmypgogtk94bg-pqnrxhy.png"><br><br><h4>  La motivation </h4><br>  C'est cool que 2/3 des participants à la conférence <i>aient</i> utilisé le nouveau type <i>BigInt</i> dans la solution (quelqu'un a admis que c'était la première expérience).  Le tiers restant des solutions contenait leurs propres implémentations d'arithmétique longue sur des chaînes ou des tableaux.  La plupart des fonctions implémentées multipliaient de grands nombres par de grandes, alors que pour une solution, il suffisait de se multiplier par un "petit" <i>nombre</i> et de passer un peu moins de temps.  D'accord, utilisez-vous déjà <i>BigInt</i> dans vos projets? <br><br><h2>  Remerciements </h2><br>  Ces deux jours de conférence ont été très chargés de discussions et d'apprentissage de quelque chose de nouveau.  Je remercie le comité de programme pour la prochaine conférence inoubliable et tous les participants pour leur réseautage unique et leur bonne humeur. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453466/">https://habr.com/ru/post/fr453466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453454/index.html">Radio définie par logiciel - comment ça marche? Partie 5</a></li>
<li><a href="../fr453456/index.html">Fonctionnement de la localisation dans Netflix - traduction</a></li>
<li><a href="../fr453458/index.html">Véritable programmation réactive dans Svelte 3.0</a></li>
<li><a href="../fr453460/index.html">Quand je suis fatigué du virtuel</a></li>
<li><a href="../fr453464/index.html">Futur quantique (suite)</a></li>
<li><a href="../fr453468/index.html">L'évolution des applications Web Java</a></li>
<li><a href="../fr453470/index.html">Vos monolithes distribués complotent derrière vous</a></li>
<li><a href="../fr453472/index.html">Vélo à partir du moniteur d'énergie PZEM004T et ESP8266, avec People's Monitoring</a></li>
<li><a href="../fr453474/index.html">Contrôlez un ordinateur via la télécommande d'un amplificateur à l'aide d'Arduino et de Node.js</a></li>
<li><a href="../fr453478/index.html">Nous étudions la santé des satellites Starlink Ilona Mask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>