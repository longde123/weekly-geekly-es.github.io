<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï† üë®üèø‚Äçüéì ‚ÜóÔ∏è Elaboramos un juego de desarrollo. Parte 1 üìõ üåª üíì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 La historia comenz√≥ con un hackathon basado en blockchain. Al comienzo del evento, conoc√≠ a un hombre que crea juegos de mesa como un p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elaboramos un juego de desarrollo. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451458/"><img src="https://habrastorage.org/webt/kj/iq/cp/kjiqcpn8xsrxhus_hsclhpi9w_w.jpeg" align="left"><h2>  <font color="#292e5b">Introduccion</font> </h2><br>  La historia comenz√≥ con un hackathon basado en blockchain.  Al comienzo del evento, conoc√≠ a un hombre que crea juegos de mesa como un pasatiempo (estaba en la prueba de uno de esos juegos), nos unimos y encontramos un equipo con el que "cegaron" un simple juego estrat√©gico durante el fin de semana.  El hackat√≥n pas√≥, pero el entusiasmo permaneci√≥.  Y se nos ocurri√≥ la idea de un juego de cartas multijugador sobre la felicidad, la comunidad mundial y las elecciones. <br><br>  En la serie de art√≠culos, reflejaremos nuestro camino para crear un juego, con una descripci√≥n del rastrillo que ya hemos pisado y lo haremos a medida que avancemos. <br clear="all">  Debajo del corte estar√°: <br><br><ul><li>  Resumen del juego </li><li> C√≥mo se tom√≥ la decisi√≥n sobre qu√© hacer backend.  ¬øD√≥nde va a "vivir" para que no lo pague en la etapa de desarrollo? </li><li>  Primeros pasos en el desarrollo: autenticaci√≥n de jugadores y organizaci√≥n de emparejamiento </li><li>  Planes adicionales </li></ul><a name="habracut"></a><br><h2>  <font color="#292e5b">¬øDe qu√© trata el juego?</font> </h2><br>  La humanidad est√° cansada de las guerras mundiales, el agotamiento de los recursos y la competencia constante.  Las facciones clave acordaron usar tecnolog√≠a moderna para seleccionar un solo liderazgo.  A la hora se√±alada, el electorado mundial debe decidir la elecci√≥n de una fracci√≥n que regir√° el planeta durante el pr√≥ximo milenio.  Las facciones clave participan en una lucha de poder "honesta".  En una sesi√≥n de juego, cada jugador representa una fracci√≥n. <br><br>  Este juego de cartas trata sobre elecciones.  Cada facci√≥n tiene un presupuesto para conducir la carrera electoral, fuentes de ingresos que aumentan el presupuesto y comienzan los votos.  Al comienzo del juego, el mazo con cartas de acci√≥n se mezcla y se entregan 4 cartas a cada participante.  Cada turno, los jugadores pueden realizar hasta dos acciones de juego.  Para usar la tarjeta, el jugador la pone sobre la mesa y, si es necesario, designa la meta y deduce del presupuesto el costo de usar la tarjeta.  Despu√©s del final de la ronda, el jugador solo puede quedarse con una de las cartas no utilizadas.  Al comienzo de cada ronda, los jugadores obtienen cartas del mazo, de modo que al comienzo de cada ronda, cada jugador tiene 4 cartas de acci√≥n disponibles. <br><br>  Al final de las rondas 3, 6 y 9, el jugador con el menor n√∫mero de votos es eliminado del juego.  Si varios jugadores tienen el mismo n√∫mero m√≠nimo de votos, entonces todos los jugadores con este resultado son eliminados del juego.  Las voces de estos jugadores van al grupo general del electorado. <br><br>  Al final de la ronda 12, el ganador es el que tiene m√°s votos. <br><br><h2>  <font color="#292e5b">Elegir una herramienta para el backend</font> </h2><br>  De la descripci√≥n del juego sigue: <br><br><ol><li>  Esto es multijugador </li><li>  Es necesario identificar de alguna manera a los jugadores y administrar cuentas </li><li>  La presencia de un componente social beneficiar√≠a al juego: amigos, comunidades (clanes), chats, logros (logros) </li><li>  Se requerir√°n tablas de clasificaci√≥n y funcionalidad de emparejamiento. </li><li>  La funcionalidad de gesti√≥n de torneos ser√° √∫til en el futuro </li><li>  Dado que el juego es un juego de cartas, debes administrar el cat√°logo de cartas, es posible que necesites almacenar cartas disponibles para el jugador y mazos compilados </li><li>  En el futuro, es posible que se requiera una econom√≠a en el juego, incluida la moneda del juego, el intercambio de bienes virtuales (tarjetas) </li></ol><br>  Mirando la lista de necesidades, inmediatamente llegu√© a la conclusi√≥n de que hacer mi propio backend en la etapa inicial no tiene sentido y busqu√© en Google qu√© otras opciones hay.  Entonces descubr√≠ que hay backends especializados en juegos en la nube, entre los que se destacan PlayFab (comprado por Microsoft) y GameSparks (comprado por Amazon). <br><br>  En general, son funcionalmente similares y cubren necesidades b√°sicas.  Adem√°s, su arquitectura interna es muy diferente, las mismas tareas se resuelven de manera un poco diferente y las correspondencias expl√≠citas en las caracter√≠sticas son dif√≠ciles de rastrear.  A continuaci√≥n se presentan las caracter√≠sticas positivas y negativas de cada plataforma y las consideraciones sobre el tema de elecci√≥n. <br><br><h3>  <font color="#9cc2ce">Playfab</font> </h3><br>  Caracter√≠sticas positivas: <br><br><ul><li>  Las cuentas de diferentes juegos se combinan en una cuenta maestra </li><li>  La econom√≠a del juego se describe sin una sola l√≠nea de c√≥digo, incluido el precio a una tienda virtual separada </li><li>  Interfaz de usuario amigable </li><li>  Microsoft adquiere producto despu√©s de la adquisici√≥n </li><li>  El costo de propiedad en la producci√≥n por suscripci√≥n de Indie Studio es de $ 99 (hasta 100k MAU), cuando el cambio a la suscripci√≥n Professional 1k MAU costar√° $ 8 (cuenta m√≠nima $ 300) </li></ul><br>  Caracter√≠sticas negativas: <br><br><ul><li>  El almacenamiento de datos del juego est√° estrictamente limitado, por ejemplo, en una suscripci√≥n gratuita para almacenar datos para una sesi√≥n de juego espec√≠fica (si entiendo todo correctamente, los grupos de entidades se utilizan para esto) 3 ranuras de 500 bytes cada una est√°n disponibles </li><li>  Para organizar el modo multijugador, debes conectar servidores de terceros que procesar√°n los eventos de los clientes y calcular√°n la l√≥gica del juego.  Este es Photon en su hardware o Azure Thunderhead, y necesita no solo organizar el servidor, sino tambi√©n actualizar su suscripci√≥n al menos a Indie Studio </li><li>  Es necesario soportar el hecho de que el c√≥digo de la nube sin autocompletar y no hay forma de dividirse en m√≥dulos (¬øo no lo encontr√≥?) </li><li>  No hay un depurador normal, solo puede escribir registros en CloudScript y ver </li></ul><br><h3>  <font color="#9cc2ce">Gamesparks</font> </h3><br>  Caracter√≠sticas positivas: <br><br><ul><li>  Juego de almacenamiento de datos.  No solo hay muchos lugares donde puede guardar datos (metadatos generales del juego, bienes virtuales, perfil de jugador, sesiones de jugadores m√∫ltiples, etc.), la plataforma tambi√©n proporciona una base de datos completa como un servicio que no est√° conectado a nada, Adem√°s, tanto MongoDB como Redis est√°n disponibles inmediatamente para diferentes tipos de datos.  En el entorno de desarrollo puedes almacenar 10 MB, en la batalla 10 GB </li><li>  El modo multijugador est√° disponible en una suscripci√≥n gratuita (Desarrollo) con un l√≠mite de 10 conexiones simult√°neas y 10 solicitudes por segundo. </li><li>  Trabajo conveniente con CloudCode, que incluye una herramienta integrada para pruebas y depuraci√≥n (Test Harness) </li></ul><br>  Caracter√≠sticas negativas: <br><br><ul><li>  La sensaci√≥n de que desde la compra de Amazon (invierno de 2018) la herramienta se ha estancado, no hay innovaciones </li><li>  Nuevamente, despu√©s de la adquisici√≥n de Amazon, los aranceles empeoraron; antes era posible usar hasta 10,000 MAU en producci√≥n de forma gratuita </li><li>  El costo de propiedad de producci√≥n comienza en $ 300 (suscripci√≥n est√°ndar) </li></ul><br><h3>  <font color="#9cc2ce">Reflexiones</font> </h3><br>  Primero tienes que verificar el concepto del juego.  Para hacer esto, quiero construir un prototipo de palos y cinta adhesiva sin inversiones monetarias y comenzar las pruebas de juego de la mec√°nica del juego.  Por lo tanto, en primer lugar al elegir, aprovecho la oportunidad para desarrollar y probar un mec√°nico con una suscripci√≥n gratuita. <br>  GameSparks cumple este criterio, pero PlayFab no, porque necesitar√° un servidor que maneje los eventos de los clientes del juego y una suscripci√≥n de nivel de estudio independiente ($ 99). <br><br>  Al mismo tiempo, acepto el riesgo de que Amazon no desarrolle GameSparks, lo que significa que puede "morir".  Dado esto y a√∫n el costo de propiedad en la producci√≥n, tengo en mente la necesidad potencial de moverme a otra plataforma o a mi propio backend. <br><br><h2>  <font color="#292e5b">Primeros pasos en el desarrollo.</font> </h2><br><h3>  <font color="#9cc2ce">Conexi√≥n y autenticaci√≥n</font> </h3><br>  Entonces, la elecci√≥n recay√≥ en GameSparks como un backend en la etapa de creaci√≥n de prototipos.  El primer paso es aprender c√≥mo conectarse a la plataforma y autenticar al jugador.  Un punto importante es que el usuario deber√≠a poder jugar sin registro y SMS inmediatamente despu√©s de instalar el juego.  Para hacer esto, GameSparks ofrece la opci√≥n de crear un perfil an√≥nimo llamando al m√©todo DeviceAuthenticationRequest, luego, sobre la base de un perfil an√≥nimo, puede hacer uno completo conect√°ndose, por ejemplo, con su cuenta de Google. <br><br>  Dado que tengo un TDD cerebral, comenc√© creando una prueba para conectar al cliente al juego.  Como en el futuro CloudCode deber√° escribirse en JS, har√© pruebas de integraci√≥n en JS usando mocha.js y chai.js.  La primera prueba result√≥ as√≠: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expect = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"chai"</span></span>).expect; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> GameClientModule = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"../src/gameClient"</span></span>); describe(<span class="hljs-string"><span class="hljs-string">"Integration test"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timeout(<span class="hljs-number"><span class="hljs-number">0</span></span>); it(<span class="hljs-string"><span class="hljs-string">"should connect client to server"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameClientModule.GameClient(); expect(gameClient.connected()).is.false; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient.connect(); expect(gameClient.connected()).is.true; }); })</code> </pre> <br>  Por defecto, el tiempo de espera en mocha.js es de 2 segundos, inmediatamente lo hago infinito, porque las pruebas son de integraci√≥n.  En la prueba, creo un cliente de juego que a√∫n no se ha implementado, verifico que no haya conexi√≥n con el servidor, llame al comando para conectarse al backend y verifique que el cliente se haya conectado correctamente. <br><br>  Para que la prueba se vuelva verde, debe descargar y agregar el SDK de GameSparks JS al proyecto, as√≠ como conectar sus dependencias (crypto-js y ws) y, por supuesto, implementar GameClientModule: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> GameSparks = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"../gamesparks-javascript-sdk-2018-04-18/gamesparks-functions"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"./config.json"</span></span>); exports.GameClient = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gamesparks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameSparks(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.connected = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> (gamesparks.connected === <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.connect = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ gamesparks.initPreview({ <span class="hljs-attr"><span class="hljs-attr">key</span></span>: config.gameApiKey, <span class="hljs-attr"><span class="hljs-attr">secret</span></span>: config.credentialSecret, <span class="hljs-attr"><span class="hljs-attr">credential</span></span>: config.credential, <span class="hljs-attr"><span class="hljs-attr">onInit</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(), <span class="hljs-attr"><span class="hljs-attr">onMessage</span></span>: onMessage, <span class="hljs-attr"><span class="hljs-attr">onError</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> reject(error), <span class="hljs-attr"><span class="hljs-attr">logger</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log }); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"GAME onMessage: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(message)); } }</code> </pre><br>  En la implementaci√≥n inicial del cliente del juego, las claves necesarias para la autorizaci√≥n t√©cnica para crear una conexi√≥n desde la aplicaci√≥n del cliente se leen desde la configuraci√≥n.  El m√©todo conectado envuelve el mismo campo del SDK.  Lo m√°s importante sucede en el m√©todo de conexi√≥n, devuelve una promesa con devoluciones de llamada para una conexi√≥n exitosa o un error, tambi√©n vincula el controlador onMessage a la misma devoluci√≥n de llamada.  onMessage actuar√° como el administrador de procesamiento de mensajes desde el backend, por ahora permita que registre mensajes en la consola. <br><br>  Parece que el trabajo se ha completado, pero la prueba sigue siendo roja.  Resulta que el SDK de GameSparks JS no funciona con node.js; para √©l, ves, carece del contexto del navegador.  Hag√°mosle pensar que ese nodo es Chrome en la amapola.  Vamos a gamesparks.js y al principio agregamos: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> === <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports) { <span class="hljs-comment"><span class="hljs-comment">// node.js var navigator = { userAgent: "Chrome/73.0.3683.103", vendor: "Google Inc.", platform: "Mac" }; var window = {}; window.setInterval = setInterval; // &lt;&lt;&lt;   KeepAlive  }</span></span></code> </pre><br>  La prueba se puso verde, avanzando. <br><br>  Como escrib√≠ anteriormente, un jugador deber√≠a poder comenzar a jugar inmediatamente tan pronto como ingrese al juego, mientras que quiero comenzar a acumular an√°lisis en la actividad.  Para hacer esto, nos unimos al identificador del dispositivo o a un identificador generado aleatoriamente.  Comprueba que esta ser√° una prueba: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"should auth two anonymous players"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameClientModule.GameClient(); expect(gameClient1.playerId).is.undefined; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameClientModule.GameClient(); expect(gameClient2.playerId).is.undefined; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.connect(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.authWithCustomId(<span class="hljs-string"><span class="hljs-string">"111"</span></span>); expect(gameClient1.playerId).is.equals(<span class="hljs-string"><span class="hljs-string">"5b5f5614031f5bc44d59b6a9"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.connect(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.authWithCustomId(<span class="hljs-string"><span class="hljs-string">"222"</span></span>); expect(gameClient2.playerId).is.equals(<span class="hljs-string"><span class="hljs-string">"5b5f6ddb031f5bc44d59b741"</span></span>); });</code> </pre><br>  Decid√≠ verificar de inmediato a 2 clientes para asegurarme de que cada cliente cree su propio perfil en el back-end.  Para hacer esto, el cliente del juego necesitar√° un m√©todo en el que pueda transferir un cierto identificador externo a GameSparks, y luego verificar que el cliente haya contactado con el perfil del jugador deseado.  Perfiles preparados de antemano en el portal GameSparks. <br><br>  Para la implementaci√≥n en GameClient agregue: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.playerId = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.authWithCustomId = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">customId</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requestData = { <span class="hljs-string"><span class="hljs-string">"deviceId"</span></span>: customId , <span class="hljs-string"><span class="hljs-string">"deviceOS"</span></span>: <span class="hljs-string"><span class="hljs-string">"NodeJS"</span></span> } sendRequest(<span class="hljs-string"><span class="hljs-string">"DeviceAuthenticationRequest"</span></span>, requestData) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.userId) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.playerId = response.userId; resolve(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(response)); } }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); }); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">requestType, requestData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) </span></span>{ gamesparks.sendWithData(requestType, requestData, (response) =&gt; resolve(response)); }); }</code> </pre><br>  La implementaci√≥n se reduce a enviar una solicitud de solicitud de autenticaci√≥n de dispositivo, recibir el identificador del jugador de la respuesta y colocarlo en la propiedad del cliente.  Inmediatamente, en un m√©todo separado, el ayudante envi√≥ solicitudes a GameSparks con un contenedor en una promis. <br><br>  Ambas pruebas son verdes, queda por agregar el cierre de la conexi√≥n y refactorizar. <br>  En GameClient, agregu√© un m√©todo que cierra la conexi√≥n al servidor (desconectar) y connectAsAnonymous combinando connect y authWithCustomId.  Por un lado, connectAsAnonymous viola el principio de responsabilidad √∫nica, pero no parece violar ... Al mismo tiempo, agrega usabilidad, porque en las pruebas a menudo ser√° necesario autenticar a los clientes.  ¬øQu√© opinas sobre esto? <br><br>  En las pruebas, agreg√≥ un m√©todo auxiliar de f√°brica que crea una nueva instancia del cliente del juego y se agrega a la matriz de clientes creados.  En el controlador especial de mocha, despu√©s de cada prueba en ejecuci√≥n para clientes en la matriz, llamo al m√©todo de desconexi√≥n y borro esta matriz.  Todav√≠a no me gustan las "cadenas m√°gicas" en el c√≥digo, as√≠ que agregu√© un diccionario con identificadores personalizados utilizados en las pruebas. <br><br>  El c√≥digo final se puede ver en el repositorio, un enlace que dar√© al final del art√≠culo. <br><br><h3>  <font color="#9cc2ce">Organizaci√≥n de b√∫squeda de juegos (emparejamiento)</font> </h3><br>  Comenzar√© con la funci√≥n de emparejamiento, que es muy importante para el modo multijugador.  Este sistema comienza a funcionar cuando presionamos el bot√≥n "Buscar un juego" en un juego.  Ella recoge rivales, o compa√±eros de equipo, o ambos (dependiendo del juego).  Como regla general, en tales sistemas, cada jugador tiene un indicador num√©rico MMR (Proporci√≥n de emparejamiento), una calificaci√≥n personal del jugador, que se utiliza para seleccionar a otros jugadores con el mismo nivel de habilidad. <br><br>  Para probar esta funcionalidad, se me ocurri√≥ la siguiente prueba: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"should find match"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient1 = newGameClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient2 = newGameClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient3 = newGameClient(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.connectAsAnonymous(playerCustomIds.id1); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.connectAsAnonymous(playerCustomIds.id2); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient3.connectAsAnonymous(playerCustomIds.id3); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.findStandardMatch(); expect(gameClient1.state) .is.equals(GameClientModule.GameClientStates.MATCHMAKING); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.findStandardMatch(); expect(gameClient2.state) .is.equals(GameClientModule.GameClientStates.MATCHMAKING); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient3.findStandardMatch(); expect(gameClient3.state) .is.equals(GameClientModule.GameClientStates.MATCHMAKING); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> sleep(<span class="hljs-number"><span class="hljs-number">3000</span></span>); expect(gameClient1.state) .is.equals(GameClientModule.GameClientStates.CHALLENGE); expect(gameClient1.challenge, <span class="hljs-string"><span class="hljs-string">"challenge"</span></span>).is.not.undefined; expect(gameClient1.challenge.challengeId).is.not.undefined; expect(gameClient2.state) .is.equals(GameClientModule.GameClientStates.CHALLENGE); expect(gameClient2.challenge.challengeId) .is.equals(gameClient1.challenge.challengeId); expect(gameClient3.state) .is.equals(GameClientModule.GameClientStates.CHALLENGE); expect(gameClient3.challenge.challengeId) .is.equals(gameClient1.challenge.challengeId); });</code> </pre><br>  Tres clientes est√°n conectados al juego (en el futuro es un m√≠nimo necesario para verificar algunos escenarios) y est√°n registrados para buscar el juego.  Despu√©s de registrar al tercer jugador en el servidor, se forma una sesi√≥n de juego y los jugadores deben conectarse a √©l.  Al mismo tiempo, el estado de los clientes cambia y aparece el contexto de la sesi√≥n del juego con el mismo identificador. <br><br>  Primero, prepara el backend.  En GameSparks hay una herramienta lista para personalizar la b√∫squeda de juegos, disponible en la ruta "Configurador-&gt; Partidos".  Creo uno nuevo y procedo con la configuraci√≥n.  Adem√°s de los par√°metros est√°ndar como el c√≥digo, el nombre y la descripci√≥n del partido, se indica el n√∫mero m√≠nimo y m√°ximo de jugadores necesarios para un modo de juego personalizado.  Asignar√© el c√≥digo "StandardMatch" al partido creado e indicar√© el n√∫mero de jugadores de 2 a 3. <br><br>  Ahora debe configurar las reglas para seleccionar jugadores en la secci√≥n "Umbrales".  Para cada umbral, se indican el tiempo de su acci√≥n, tipo (absoluto, relativo y en porcentaje) y l√≠mites. <br><br><img src="https://habrastorage.org/webt/tn/xb/i0/tnxbi0kpa9lb3gwhb3hlbpgs9og.png"><br><br>  Supongamos que un jugador con un MMR de 19 comienza a buscar. En el ejemplo anterior, los primeros 10 segundos ser√°n la selecci√≥n de otros jugadores con un MMR de 19 a 21. Si los jugadores no fueron seleccionados, el segundo borde de b√∫squeda se activa, lo que extiende el rango de b√∫squeda de 16 por los siguientes 20 segundos ( 19-3) a 22 (19 + 3).  A continuaci√≥n, se incluye el tercer umbral, dentro del cual se realizar√° una b√∫squeda durante 30 segundos en el rango de 14 (19-25%) a 29 (19 + 50%), mientras que el partido se considera completado si se ha acumulado el n√∫mero m√≠nimo requerido de jugadores (Aceptar marca m√≠nima Jugadores). <br><br>  De hecho, el mecanismo es m√°s complicado, ya que tiene en cuenta el MMR de todos los jugadores que lograron unirse a un partido en particular.  Analizar√© estos detalles cuando llegue el momento de establecer el modo de calificaci√≥n del juego (no en este art√≠culo).  Para el modo de juego est√°ndar, donde todav√≠a no planeo usar MMR, solo necesito un umbral de cualquier tipo. <br><br>  Cuando todos los jugadores han sido seleccionados, debe crear una sesi√≥n de juego y conectar a los jugadores.  En GameSparks, la funci√≥n de sesi√≥n del juego es "Desaf√≠o".  Como parte de esta entidad, los datos de la sesi√≥n del juego se almacenan y los mensajes se intercambian entre los clientes del juego.  Para crear un nuevo tipo de Desaf√≠o, debe seguir el camino "Configurador-&gt; Desaf√≠os".  All√≠ agrego un nuevo tipo con el c√≥digo "StandardChallenge" e indico que este tipo de sesi√≥n de juego es por turnos, es decir  Los jugadores se turnan, no simult√°neamente.  GameSparks al mismo tiempo toma el control de la secuencia de movimientos. <br><br>  Para que un cliente se registre para buscar un juego, puede utilizar una solicitud del tipo MatchmakingRequest, pero no lo recomendar√≠a, porque uno de los par√°metros requiere el MMR del jugador.  Esto puede conducir a un fraude por parte del cliente del juego, y el cliente no debe saber ning√∫n MMR, este es un negocio de back-end.  Para registrarme correctamente para la b√∫squeda del juego, creo un evento arbitrario desde el cliente.  Esto se hace en la secci√≥n "Configurador-&gt; Eventos".  Llamo al evento FindStandardMatch sin atributos.  Ahora necesita configurar la reacci√≥n a este evento, para esto voy a la secci√≥n del c√≥digo de la nube "Configurador-&gt; C√≥digo de la nube", all√≠ escribo el siguiente controlador para FindStandardMatch en la secci√≥n "Eventos": <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matchRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparkRequests.MatchmakingRequest(); matchRequest.matchShortCode = <span class="hljs-string"><span class="hljs-string">"StandardMatch"</span></span>; matchRequest.skill = <span class="hljs-number"><span class="hljs-number">0</span></span>; matchRequest.Execute();</code> </pre><br>  Este c√≥digo registra a un jugador en StandardMatch con un MMR de 0, por lo que cualquier jugador registrado para buscar un juego est√°ndar ser√° adecuado para crear una sesi√≥n de juego.  En la selecci√≥n de un partido de calificaci√≥n, podr√≠a haber una apelaci√≥n a los datos privados del perfil del jugador para obtener el MMR de este tipo de partido. <br><br>  Cuando hay suficientes jugadores para comenzar una sesi√≥n de juego, GameSparks enviar√° un mensaje de MatchFoundMessage a todos los jugadores seleccionados.  Aqu√≠ puede generar autom√°ticamente una sesi√≥n de juego y agregarle jugadores.  Para hacer esto, en "Mensajes de usuario-&gt; MatchFoundMessage" agregue el c√≥digo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matchData = Spark.getData(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Spark.getPlayer().getPlayerId() != matchData.participants[<span class="hljs-number"><span class="hljs-number">0</span></span>].id) { Spark.exit(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> challengeCode = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accessType = <span class="hljs-string"><span class="hljs-string">"PRIVATE"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (matchData.matchShortCode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"StandardMatch"</span></span>: challengeCode = <span class="hljs-string"><span class="hljs-string">"StandardChallenge"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: Spark.exit(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> createChallengeRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparkRequests.CreateChallengeRequest(); createChallengeRequest.challengeShortCode = challengeCode; createChallengeRequest.accessType = accessType; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tomorrow = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(); tomorrow.setDate(tomorrow.getDate() + <span class="hljs-number"><span class="hljs-number">1</span></span>); createChallengeRequest.endTime = tomorrow.toISOString(); createChallengeRequest.usersToChallenge = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> participants = matchData.participants; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numberOfPlayers = participants.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; numberOfPlayers; i++) { createChallengeRequest.usersToChallenge.push(participants[i].id) } createChallengeRequest.Send();</code> </pre><br>  El c√≥digo primero verifica que sea el primer jugador en la lista de participantes.  A continuaci√≥n, en nombre del primer jugador, se crea una instancia de StandardChallenge y se invita a los jugadores restantes.  Los jugadores invitados reciben un mensaje ChallengeIssuedMessage.  Aqu√≠ puede imaginar el comportamiento cuando se muestra una invitaci√≥n para unirse al juego en el cliente y requiere confirmaci√≥n enviando AcceptChallengeRequest, o puede aceptar la invitaci√≥n en modo silencioso.  As√≠ que lo har√©, para esto en "Mensajes de usuario-&gt; ChallengeIssuedMessage" agregar√© el siguiente c√≥digo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> challangeData = Spark.getData(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> acceptChallengeRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparkRequests.AcceptChallengeRequest(); acceptChallengeRequest.challengeInstanceId = challangeData.challenge.challengeId; acceptChallengeRequest.message = <span class="hljs-string"><span class="hljs-string">"Joining"</span></span>; acceptChallengeRequest.SendAs(Spark.getPlayer().getPlayerId());</code> </pre><br>  El siguiente paso, GameSparks distribuye el evento ChallengeStartedMessage.  El controlador global de este evento ("Mensajes globales-&gt; ChallengeStartedMessage") es un lugar ideal para inicializar una sesi√≥n de juego, me ocupar√© de esto cuando implemente la l√≥gica del juego. <br><br>  Ha llegado el momento de la aplicaci√≥n del cliente.  Cambios en el m√≥dulo del cliente: <br><br><pre> <code class="javascript hljs">exports.GameClientStates = { <span class="hljs-attr"><span class="hljs-attr">IDLE</span></span>: <span class="hljs-string"><span class="hljs-string">"Idle"</span></span>, <span class="hljs-attr"><span class="hljs-attr">MATCHMAKING</span></span>: <span class="hljs-string"><span class="hljs-string">"Matchmaking"</span></span>, <span class="hljs-attr"><span class="hljs-attr">CHALLENGE</span></span>: <span class="hljs-string"><span class="hljs-string">"Challenge"</span></span> } exports.GameClient = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.IDLE; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.challenge = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (message[<span class="hljs-string"><span class="hljs-string">"@class"</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">".MatchNotFoundMessage"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.IDLE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">".ChallengeStartedMessage"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.CHALLENGE; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.challenge = message.challenge; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"GAME onMessage: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(message)); } } onMessage = onMessage.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.findStandardMatch = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> eventData = { <span class="hljs-attr"><span class="hljs-attr">eventKey</span></span>: <span class="hljs-string"><span class="hljs-string">"FindStandardMatch"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { sendRequest(<span class="hljs-string"><span class="hljs-string">"LogEventRequest"</span></span>, eventData) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!response.error) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.MATCHMAKING; resolve(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(response.error); reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(response)); } }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(error)); }); }); } }</code> </pre><br>  De acuerdo con la prueba, aparecieron un par de campos en el cliente: estado y desaf√≠o.  El m√©todo onMessage ha adquirido un aspecto significativo y ahora responde a los mensajes sobre el inicio de una sesi√≥n de juego y a un mensaje de que no fue posible recoger un juego.  Tambi√©n se ha agregado el m√©todo findStandardMatch, que env√≠a la solicitud correspondiente al back-end.  La prueba es verde, pero estoy satisfecho, la selecci√≥n de juegos domin√≥. <br><br><h2>  <font color="#292e5b">Que sigue</font> </h2><br>  En los siguientes art√≠culos describir√© el proceso de desarrollo de la l√≥gica del juego, desde la inicializaci√≥n de una sesi√≥n de juego hasta el procesamiento de movimientos.  Analizar√© las caracter√≠sticas de almacenar diferentes tipos de datos: una descripci√≥n de los metadatos del juego, las caracter√≠sticas del mundo del juego, los datos de las sesiones del juego y los datos sobre los jugadores.  La l√≥gica del juego se desarrollar√° a trav√©s de dos tipos de pruebas: unidad e integraci√≥n. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Subir√© las fuentes en github en</a> porciones vinculadas a art√≠culos. <br><br>  Hay un entendimiento de que para avanzar efectivamente en la creaci√≥n de un juego, debes expandir nuestro equipo de entusiastas.  El artista / dise√±ador se unir√° pronto.  Y el gur√∫ en, por ejemplo, Unity3D, que har√° el frente para las plataformas m√≥viles, a√∫n no se ha encontrado. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/451458/">https://habr.com/ru/post/451458/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451446/index.html">Ayuda visual para el desarrollo de productos: dise√±o</a></li>
<li><a href="../451448/index.html">¬øPor qu√© puede ser necesario no hacer seguimiento?</a></li>
<li><a href="../451452/index.html">Build2019, comprendiendo lo que vimos</a></li>
<li><a href="../451454/index.html">Cambiamos el contenido de la aplicaci√≥n de notificaci√≥n iOS</a></li>
<li><a href="../451456/index.html">Almacenamiento de AERODISK ruso: prueba de carga. Exprimir IOPS</a></li>
<li><a href="../451460/index.html">Julia en el laberinto</a></li>
<li><a href="../451462/index.html">Escriba menos c√≥digo duplicado usando carpetas en Laravel</a></li>
<li><a href="../451464/index.html">Frontend Weekly Digest (6-12 de mayo de 2019)</a></li>
<li><a href="../451466/index.html">graphql - trampas</a></li>
<li><a href="../451468/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 364 (6 al 12 de mayo de 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>