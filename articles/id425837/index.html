<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§šğŸ¾ ğŸ›ï¸ ğŸ‘‡ğŸ¾ Salin semantik dan manajemen sumber daya dalam C ++ ğŸ§‘ğŸ½â€ğŸ¤â€ğŸ§‘ğŸ» ğŸ¦Œ ğŸ‘¨â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam C ++, programmer harus memutuskan bagaimana sumber daya yang digunakan akan dibebaskan, tidak ada alat otomatis seperti pengumpul sampah. Artike...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Salin semantik dan manajemen sumber daya dalam C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425837/"><hr><p>  <i>Dalam C ++, programmer harus memutuskan bagaimana sumber daya yang digunakan akan dibebaskan, tidak ada alat otomatis seperti pengumpul sampah.</i>  <i>Artikel ini membahas kemungkinan solusi untuk masalah ini, memeriksa secara terperinci potensi masalah, serta sejumlah masalah terkait.</i> <i><br></i> </p><hr><br><a name="habracut"></a><br><h1>  Daftar isi </h1><br><div class="spoiler">  <b class="spoiler_title">Daftar isi</b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1. Strategi kepemilikan salinan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Salin Strategi Larangan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Strategi Kepemilikan Eksklusif</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Strategi salin mendalam</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Strategi kepemilikan bersama</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2. Deep Copy Strategy - Masalah dan Solusi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Salin dalam rekaman</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mendefinisikan fungsi pertukaran negara untuk suatu kelas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghapus salinan perantara oleh kompiler</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi semantik perpindahan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Akomodasi vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyisipan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ringkasan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3. Opsi untuk menerapkan strategi kepemilikan bersama</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4. Strategi kepemilikan eksklusif dan semantik gerakan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5. Salin Strategi Larangan - Mulai Cepat</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6. Siklus hidup sumber daya dan objek pemilik sumber daya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengambilan sumber daya pada inisialisasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Opsi Manajemen Siklus Hidup Sumber Daya Lanjutan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6.2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Siklus Hidup Sumberdaya yang Diperpanjang</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6.2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengambilan sumber daya tunggal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6.2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menambah tipuan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kepemilikan bersama</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7. Ringkasan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aplikasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lampiran A. Nilai Tautan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lampiran B. Semantik Pengungsian</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Referensi</a> <br></p><br></div></div><br><a name="id-introdaction"></a><br><h1>  Pendahuluan </h1><br><p> Manajemen sumber daya adalah sesuatu yang harus dilakukan oleh seorang programmer C ++ sepanjang waktu.  Sumber daya termasuk blok memori, objek kernel OS, kunci multi-threaded, koneksi jaringan, koneksi database, dan sembarang objek yang dibuat dalam memori dinamis.  Akses ke sumber daya adalah melalui deskriptor, tipe deskriptor biasanya berupa pointer atau salah satu aliasnya ( <code>HANDLE</code> , dll.), Terkadang keseluruhan (deskriptor file UNIX).  Setelah menggunakan sumber daya, Anda harus melepaskannya, jika tidak cepat atau lambat suatu aplikasi yang tidak melepaskan sumber daya (dan mungkin aplikasi lain) akan kehabisan sumber daya.  Masalah ini sangat akut, kita dapat mengatakan bahwa salah satu fitur utama dari .NET, Java, dan beberapa platform lainnya adalah sistem manajemen sumber daya terpadu berdasarkan pengumpulan sampah. </p><br><p>  Fitur berorientasi objek dari C ++ secara alami mengarah ke solusi berikut: kelas yang mengelola sumber daya berisi deskriptor sumber daya sebagai anggota, menginisialisasi deskriptor ketika sumber daya ditangkap, dan membebaskan sumber daya dalam destruktor.  Tetapi setelah beberapa pemikiran (atau pengalaman) muncul pemahaman bahwa itu tidak begitu sederhana.  Dan masalah utama adalah semantik menyalin.  Jika kelas yang mengelola sumber daya menggunakan copy constructor yang dihasilkan oleh compiler default, maka setelah menyalin objek kita akan mendapatkan dua salinan pegangan dari sumber daya yang sama.  Jika satu objek membebaskan sumber daya, maka setelah itu objek kedua akan dapat mencoba menggunakan atau membebaskan sumber daya yang sudah dibebaskan, yang dalam hal apa pun tidak benar dan dapat mengarah pada perilaku yang tidak terdefinisi, yaitu, apa pun bisa terjadi, misalnya, penghentian program yang tidak normal. </p><br><p>  Untungnya, dalam C ++, seorang programmer dapat sepenuhnya mengendalikan proses penyalinan dengan mendefinisikan seorang copy constructor dan operator penugasan sendiri, yang memungkinkan kita untuk menyelesaikan masalah di atas, dan biasanya tidak dengan satu cara.  Implementasi penyalinan harus terkait erat dengan mekanisme pembebasan sumber daya, dan kami secara kolektif akan menyebutnya sebagai strategi penyalinan kepemilikan.  Apa yang disebut "aturan Tiga Besar" dikenal luas, yang menyatakan bahwa jika seorang programmer mendefinisikan setidaknya satu dari tiga operasi - copy constructor, copy copy operator atau destructor - maka ia harus mendefinisikan ketiga operasi.  Strategi kepemilikan salinan hanya menentukan bagaimana melakukan ini.  Ada empat strategi dasar kepemilikan salinan. </p><br><a name="id-1"></a><br><h1>  1. Strategi kepemilikan salinan dasar </h1><br><p>  Sebelum penangkapan sumber daya atau setelah rilis, deskriptor harus mengambil nilai khusus yang menunjukkan bahwa itu tidak terkait dengan sumber daya tersebut.  Biasanya ini nol, terkadang -1, dilemparkan ke tipe deskriptor.  Bagaimanapun, deskriptor seperti itu akan disebut nol.  Kelas yang mengelola sumber daya harus mengenali deskriptor nol dan tidak mencoba menggunakan atau membebaskan sumber daya dalam kasus ini. </p><br><a name="id-1-1"></a><br><h2>  1.1.  Salin Strategi Larangan </h2><br><p>  Ini adalah strategi paling sederhana.  Dalam hal ini, hanya dilarang menyalin dan menetapkan instance kelas.  Destuctor membebaskan sumber daya yang ditangkap.  Dalam C ++, untuk melarang penyalinan tidaklah sulit, kelas harus mendeklarasikan, tetapi tidak mendefinisikan, konstruktor penyalinan tertutup dan operator penyalinan salinan. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;);    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Upaya penyalinan digagalkan oleh kompiler dan tautan. </p><br><p>  Standar C ++ 11 menawarkan sintaks khusus untuk kasus ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Sintaks ini lebih visual dan memberikan pesan yang lebih mudah dipahami kepada kompiler ketika mencoba menyalin. </p><br><p>  Dalam versi sebelumnya dari perpustakaan standar (C ++ 98), kelas input / output stream ( <code>std::fstream</code> , dll.) <code>CFile</code> strategi copy-ban, dan pada Windows, banyak kelas dari MFC ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , dll.).  Di pustaka standar C ++ 11, beberapa kelas menggunakan strategi ini untuk mendukung sinkronisasi multi-utas. </p><br><a name="id-1-2"></a><br><h2>  1.2.  Strategi Kepemilikan Eksklusif </h2><br><p>  Dalam hal ini, ketika menerapkan penyalinan dan penugasan, deskriptor sumber daya bergerak dari objek sumber ke objek target, yaitu, tetap dalam satu salinan.  Setelah menyalin atau menugaskan, objek sumber memiliki deskriptor nol dan tidak dapat menggunakan sumber daya.  Destuctor membebaskan sumber daya yang ditangkap.  Istilah kepemilikan eksklusif atau ketat [Josuttis] juga digunakan untuk strategi ini, Andrei Alexandrescu menggunakan istilah menyalin destruktif.  Dalam C ++ 11, hal ini dilakukan sebagai berikut: penyalinan dan penyalinan biasa dilarang dengan cara yang dijelaskan di atas, dan semantik gerakan diimplementasikan, yaitu, konstruktor bergerak dan operator penugasan langkah ditentukan.  (Lebih lanjut tentang semantik gerakan nanti.) </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Dengan demikian, strategi kepemilikan eksklusif dapat dianggap sebagai perpanjangan dari strategi copy-ban. </p><br><p>  Di pustaka standar C ++ 11, strategi ini menggunakan smart pointer <code>std::unique_ptr&lt;&gt;</code> dan beberapa kelas lainnya, misalnya: <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , serta kelas yang sebelumnya menggunakan strategi larangan penyalinan ( <code>std::fstream</code> , dll.).  Di Windows, kelas MFC yang sebelumnya menggunakan strategi larangan-salin juga mulai menggunakan strategi kepemilikan eksklusif ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , dll.). </p><br><a name="id-1-3"></a><br><h2>  1.3.  Strategi salin mendalam </h2><br><p>  Dalam hal ini, Anda dapat menyalin dan menetapkan instance kelas.  Kita perlu mendefinisikan konstruktor salinan dan operator penugasan salinan, sehingga objek target menyalin sumber daya itu sendiri dari objek sumber.  Setelah itu, setiap objek memiliki salinan sumber dayanya, dapat menggunakan, memodifikasi, dan melepaskan sumber daya secara mandiri.  Destuctor membebaskan sumber daya yang ditangkap.  Terkadang untuk objek yang menggunakan strategi salin dalam, istilah nilai objek digunakan. </p><br><p>  Strategi ini tidak berlaku untuk semua sumber daya.  Ini dapat diterapkan ke sumber daya yang terkait dengan buffer memori, seperti string, tetapi tidak begitu jelas bagaimana menerapkannya pada objek kernel OS seperti file, mutex, dll. </p><br><p>  Strategi salin mendalam digunakan dalam semua jenis string objek, <code>std::vector&lt;&gt;</code> dan wadah lain dari perpustakaan standar. </p><br><a name="id-1-4"></a><br><h2>  1.4.  Strategi kepemilikan bersama </h2><br><p>  Dalam hal ini, Anda dapat menyalin dan menetapkan instance kelas.  Anda harus mendefinisikan pembuat salinan dan operator penugasan di mana deskriptor sumber daya (serta data lainnya) disalin, tetapi bukan sumber daya itu sendiri.  Setelah itu, setiap objek memiliki salinan deskriptor sendiri, dapat menggunakan, memodifikasi, tetapi tidak dapat melepaskan sumber daya, selama ada setidaknya satu objek lagi yang memiliki salinan deskriptor.  Sumber daya dibebaskan setelah objek terakhir yang memiliki salinan pegangan keluar dari ruang lingkup.  Bagaimana ini dapat diimplementasikan dijelaskan di bawah ini. </p><br><p>  Strategi kepemilikan bersama sering digunakan oleh smart pointer, dan juga wajar untuk menggunakannya untuk sumber daya yang tidak dapat diubah.  <code>std::shared_ptr&lt;&gt;</code> smart pointer mengimplementasikan strategi ini di pustaka standar C ++ 11. </p><br><a name="id-2"></a><br><h1>  2. Deep Copy Strategy - Masalah dan Solusi </h1><br><p>  Pertimbangkan templat untuk fungsi pertukaran status objek bertipe <code>T</code> di pustaka standar C ++ 98. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span></span>;    a = b;    b = tmp; }</code> </pre> <br><p>  Jika tipe <code>T</code> memiliki sumber daya dan menggunakan strategi penyalinan yang dalam, maka kami memiliki tiga operasi untuk mengalokasikan sumber daya baru, tiga operasi penyalinan, dan tiga operasi untuk membebaskan sumber daya.  Sementara dalam kebanyakan kasus operasi ini dapat dilakukan tanpa mengalokasikan sumber daya baru dan menyalin sama sekali, itu sudah cukup bagi objek untuk bertukar data internal, termasuk deskriptor sumber daya.  Ada banyak contoh serupa ketika Anda harus membuat salinan sementara sumber daya dan segera merilisnya.  Implementasi operasi sehari-hari yang tidak efektif seperti itu merangsang pencarian solusi untuk optimasi mereka.  Mari pertimbangkan opsi utama. </p><br><a name="id-2-1"></a><br><h2>  2.1.  Salin dalam rekaman </h2><br><p>  Copy on write (COW), juga disebut salinan ditangguhkan, dapat dilihat sebagai upaya untuk menggabungkan strategi copy dalam dan strategi kepemilikan bersama.  Awalnya, ketika menyalin objek, deskriptor sumber daya disalin, tanpa sumber daya itu sendiri, dan untuk pemilik sumber daya menjadi dibagikan dan hanya-baca, tetapi segera setelah beberapa pemilik perlu mengubah sumber daya bersama, sumber daya disalin dan kemudian pemilik ini bekerja dengan nya salinan.  Menerapkan KK memecahkan masalah pertukaran negara: alokasi sumber daya tambahan dan penyalinan tidak terjadi.  Menggunakan COW cukup populer ketika menerapkan string, misalnya, <code>CString</code> (MFC, ATL).  Diskusi tentang cara-cara yang mungkin untuk menerapkan KK dan masalah yang muncul dapat ditemukan di [Meyers1], [Sutter].  [Guntheroth] mengusulkan implementasi SAP menggunakan <code>std::shared_ptr&lt;&gt;</code> .  Ada masalah ketika menerapkan SAP dalam lingkungan multi-utas, itulah sebabnya mengapa dilarang menggunakan SAP untuk string dalam pustaka C ++ 11 standar, lihat [Josuttis], [Guntheroth]. </p><br><p>  Pengembangan gagasan KK mengarah ke skema manajemen sumber daya berikut: sumber daya tidak dapat diubah dan dikelola oleh objek menggunakan strategi kepemilikan bersama, jika perlu, untuk mengubah sumber daya, dibuat sumber daya baru yang dimodifikasi secara tepat, dan objek pemilik baru dikembalikan.  Skema ini digunakan untuk string dan objek tidak berubah lainnya pada platform .NET dan Java.  Dalam pemrograman fungsional, ini digunakan untuk struktur data yang lebih kompleks. </p><br><a name="id-2-2"></a><br><h2>  2.2.  Mendefinisikan fungsi pertukaran negara untuk suatu kelas </h2><br><p>  Diperlihatkan di atas betapa tidak efisiennya fungsi pertukaran negara dapat, dilaksanakan secara langsung, melalui penyalinan dan penugasan.  Dan itu digunakan cukup luas, misalnya, digunakan oleh banyak algoritma perpustakaan standar.  Agar algoritma tidak menggunakan <code>std::swap()</code> , tetapi fungsi lain yang secara khusus ditentukan untuk kelas, dua langkah harus dilakukan. </p><br><p>  1. Tentukan di kelas fungsi anggota <code>Swap()</code> (nama tidak penting) yang mengimplementasikan pertukaran status. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Anda harus memastikan bahwa fungsi ini tidak membuang pengecualian, dalam C ++ 11, fungsi tersebut harus dinyatakan sebagai <code>noexcept</code> . </p><br><p>  2. Dalam namespace yang sama dengan kelas <code>X</code> (biasanya dalam file header yang sama), tentukan fungsi <code>swap()</code> non-anggota) gratis <code>swap()</code> sebagai berikut (nama dan tanda tangan sangat mendasar): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; a, X&amp; b)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ a.Swap(b); }</code> </pre> <br><p>  Setelah itu, algoritma perpustakaan standar akan menggunakannya, bukan <code>std::swap()</code> .  Ini menyediakan mekanisme yang disebut lookup ketergantungan argumen (ADL).  Untuk lebih lanjut tentang ADL, lihat [Dewhurst1]. </p><br><p>  Di pustaka standar C ++, semua kontainer, pointer pintar, serta kelas lainnya menerapkan fungsi pertukaran negara seperti dijelaskan di atas. </p><br><p>  Fungsi anggota <code>Swap()</code> biasanya mudah didefinisikan: perlu untuk secara berurutan menerapkan operasi pertukaran negara ke database dan anggota, jika mereka mendukungnya, dan <code>std::swap()</code> jika tidak. </p><br><p>  Deskripsi di atas agak disederhanakan, yang lebih rinci dapat ditemukan di [Meyers2].  Diskusi tentang masalah yang berkaitan dengan fungsi pertukaran negara juga dapat ditemukan di [Sutter / Alexandrescu]. </p><br><p>  Fungsi pertukaran negara dapat dikaitkan dengan salah satu operasi dasar kelas.  Dengan menggunakannya, Anda dapat mendefinisikan operasi lain dengan anggun.  Sebagai contoh, operator penugasan salinan didefinisikan melalui salin dan <code>Swap()</code> sebagai berikut: </p><br><pre> <code class="cpp hljs">X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp; src) {    X tmp(src);    Swap(tmp);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  Template ini disebut salinan dan pertukaran idiom atau idiom Herb Sutter, untuk lebih jelasnya lihat [Sutter], [Sutter / Alexandrescu], [Meyers2].  Modifikasinya dapat diterapkan untuk mengimplementasikan semantik perpindahan, lihat bagian 2.4, 2.6.1. </p><br><a name="id-2-3"></a><br><h2>  2.3.  Menghapus salinan perantara oleh kompiler </h2><br><p>  Pertimbangkan kelasnya </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Dan fungsinya </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...    return X(/*  */); }</span></span></code> </pre> <br><p>  Dengan pendekatan langsung, pengembalian dari fungsi <code>Foo()</code> direalisasikan dengan menyalin contoh <code>X</code>  Tetapi kompiler dapat menghapus operasi penyalinan dari kode, objek dibuat langsung pada titik panggilan.  Ini disebut pengembalian nilai optimasi (RVO).  RVO telah digunakan oleh pengembang kompiler untuk beberapa waktu dan saat ini diperbaiki dalam standar C ++ 11.  Meskipun keputusan RVO dibuat oleh kompiler, programmer dapat menulis kode berdasarkan penggunaannya.  Untuk melakukan ini, diharapkan bahwa fungsi memiliki satu titik kembali dan jenis ekspresi yang dikembalikan cocok dengan jenis nilai balik fungsi.  Dalam beberapa kasus, disarankan untuk mendefinisikan konstruktor tertutup khusus yang disebut "konstruktor komputasional", untuk detail lebih lanjut lihat [Dewhurst2].  RVO juga dibahas dalam [Meyers3] dan [Guntheroth]. </p><br><p>  Kompiler dapat menghapus salinan perantara dalam situasi lain. </p><br><a name="id-2-4"></a><br><h2>  2.4.  Implementasi semantik perpindahan </h2><br><p>  Implementasi semantik bergerak terdiri dari mendefinisikan konstruktor bergerak yang memiliki parameter tipe rvalue-referensi ke sumber dan operator penugasan langkah dengan parameter yang sama. </p><br><p>  Di Perpustakaan Standar C ++ 11, templat fungsi pertukaran negara didefinisikan sebagai berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(a))</span></span></span></span>;    a = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b);    b = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(tmp); }</code> </pre> <br><p>  Sesuai dengan aturan untuk menyelesaikan kelebihan fungsi yang memiliki parameter dari tipe referensi nilai (lihat Lampiran A), dalam kasus ketika tipe <code>T</code> memiliki konstruktor bergerak dan operator penugasan bergerak, mereka akan digunakan, dan tidak akan ada alokasi sumber daya sementara dan penyalinan.  Jika tidak, operator penyalin dan penyalin salinan akan digunakan. </p><br><p>  Menggunakan semantik relokasi menghindari membuat salinan sementara dalam konteks yang jauh lebih luas daripada fungsi pertukaran negara yang dijelaskan di atas.  Semantik gerakan berlaku untuk nilai nilai apa pun, yaitu nilai sementara dan tidak bernama, serta nilai pengembalian fungsi jika dibuat secara lokal (termasuk nilai), dan RVO tidak diterapkan.  Dalam semua kasus ini, dijamin bahwa objek sumber tidak dapat digunakan dengan cara apa pun setelah pindah.  Semantik bergerak juga berlaku untuk nilai lvalue yang diterapkan transformasi <code>std::move()</code> .  Tetapi dalam kasus ini, programmer bertanggung jawab atas bagaimana objek sumber akan digunakan setelah pindah (contoh <code>std::swap()</code> ). </p><br><p>  Pustaka C ++ 11 standar telah dirancang ulang dengan mempertimbangkan semantik gerakan.  Banyak kelas telah menambahkan konstruktor bergerak dan operator penugasan langkah, serta fungsi anggota lainnya, dengan parameter referensi tipe nilai.  Misalnya, <code>std::vector&lt;T&gt;</code> memiliki versi <code>void push_back(T&amp;&amp; src)</code> yang kelebihan beban.  Semua ini memungkinkan dalam banyak kasus untuk menghindari membuat salinan sementara. </p><br><p>  Menerapkan semantik langkah tidak membatalkan definisi fungsi pertukaran negara untuk kelas.  Fungsi pertukaran negara yang didefinisikan secara khusus dapat lebih efisien daripada <code>std::swap()</code> .  Selain itu, konstruktor pemindahan dan operator penugasan pemindahan sangat mudah ditentukan dengan menggunakan fungsi anggota dari pertukaran status sebagai berikut (variasi salinan dan idiom pertukaran): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {<span class="hljs-comment"><span class="hljs-comment">/*    */</span></span>}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/*   */</span></span>}    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X()    {        Swap(src);    }    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>    {        X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//         Swap(tmp);        return *this;    } // ... };</span></span></code> </pre> <br><p>  Konstruktor bergerak dan operator penugasan langkah adalah fungsi-fungsi anggota yang sangat diinginkan untuk memastikan bahwa mereka tidak membuang pengecualian dan karenanya dinyatakan sebagai tidak <code>noexcept</code> .  Hal ini memungkinkan Anda untuk mengoptimalkan beberapa operasi dari wadah perpustakaan standar tanpa melanggar jaminan ketat tentang keselamatan pengecualian, untuk detail lebih lanjut lihat [Meyers3] dan [Guntheroth].  Template yang diusulkan memberikan jaminan seperti itu, asalkan konstruktor default dan fungsi anggota dari pertukaran negara tidak memberikan pengecualian. </p><br><p>  C ++ 11 standar menyediakan untuk kompiler secara otomatis menghasilkan konstruktor bergerak dan operator penugasan bergerak. Untuk melakukan ini, mereka harus dideklarasikan menggunakan konstruk <code>"=default"</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Operasi dilaksanakan dengan secara berurutan menerapkan operasi pindah ke pangkalan dan anggota kelas, jika mereka mendukung gerakan, dan menyalin operasi sebaliknya.  Jelas bahwa opsi ini jauh dari selalu dapat diterima.  Deskriptor mentah tidak bergerak, tetapi Anda biasanya tidak dapat menyalinnya.  Dalam kondisi tertentu, kompiler dapat secara independen menghasilkan konstruktor bergerak yang sama dan operator penugasan bergerak, tetapi lebih baik tidak menggunakan kesempatan ini, kondisi ini agak membingungkan dan dapat dengan mudah berubah ketika kelas disempurnakan.  Lihat [Meyers3] untuk detailnya. </p><br><p>  Secara umum, implementasi dan penggunaan semantik perpindahan cukup "tipis".  Kompiler dapat menerapkan penyalinan di mana programmer mengharapkan suatu langkah.  Berikut adalah beberapa aturan untuk menghilangkan atau setidaknya mengurangi kemungkinan situasi seperti itu. </p><br><ol><li>  Jika memungkinkan, gunakan larangan menyalin. </li><li>  Nyatakan konstruktor pemindahan dan pindahkan operator penugasan sebagai bukan <code>noexcept</code> . </li><li>  Menerapkan semantik gerakan untuk kelas dasar dan anggota. </li><li>  Menerapkan transformasi <code>std::move()</code> ke parameter fungsi tipe rvalue referensi. </li></ol><br><p>  Aturan 2 dibahas di atas.  4   ,   rvalue-  lvalue (.   ).        . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...    B(B&amp;&amp; src) noexcept; }; class D : public B { // ...    D(D&amp;&amp; src) noexcept; }; D::D(D&amp;&amp; src) noexcept    : B(std::move(src)) //  {/* ... */}</span></span></code> </pre> <br><p>      ,     .        6.2.1. </p><br><a name="id-2-5"></a><br><h2>  2.5.  vs.  </h2><br><p>     ,    RVO (.  2.3),        ,    .          ( ),       ,     .        ,    .    C++11  - <code>emplace()</code> , <code>emplace_front()</code> , <code>emplace_back()</code> ,   . ,    -      â€”   (variadic templates),         .  ,      C++11 â€”     . </p><br><p>    : </p><br><ol><li>  ,   ,   . </li><li>  ,  ,     . </li></ol><br><p>  ,         . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; vs; vs.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'X'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//  vs.emplace_back(3, '7');           // </span></span></code> </pre> <br><p>       <code>std::string</code> ,           .        .     ,  ,  .      ,       [Meyers3]. </p><br><a name="id-2-6"></a><br><h2>  2.6.  Ringkasan </h2><br><p>     ,    ,     .               -  .                   .   â€”     :    ,    .     ,       ,     ,  .      :     ,     ,  Â«Â»   . </p><br><p>      :       ,        ,       .NET  Java.             ,      <code>Clone()</code>  <code>Duplicate()</code> . </p><br><p>  -   -       ,         : </p><br><ol><li>    . </li><li>       . </li><li>   -       rvalue-. </li></ol><br><p>   .NET  Java   -    ,         ,   .NET      <code>IClonable</code> .    ,      . </p><br><a name="id-3"></a><br><h1> 3.       </h1><br><p>        ,    .      -    ,    .     ,    .        Windows:   ,   <code>HANDLE</code> ,  COM-.          <code>DuplicateHandle()</code> ,      <code>CloseHandle()</code> .  COM-  - <code>IUnknown::AddRef()</code>  <code>IUnknown::Release()</code> .   ATL    <code>ComPtr&lt;&gt;</code> ,  COM-  .    UNIX,       C,     <code>_dup()</code> ,      . </p><br><p>    C++11   <code>std::shared_ptr&lt;&gt;</code>    .  ,    ,      ,     ,   ,    . ,      .   <code>std::shared_ptr&lt;&gt;</code>    [Josuttis], [Meyers3]. </p><br><p>      :  -       ,          (  ).          (   )      ,              .   <code>std::shared_ptr&lt;&gt;</code>         <code>std::weak_ptr&lt;&gt;</code> .  . [Josuttis], [Meyers3]. </p><br><p>            - [Alexandrescu].    (   ) ,         [Schildt].          ,   . </p><br><p>        ( )    [Alger]. </p><br><p>            -.     [Josuttis]  [Alexandrescu]. </p><br><p>       -   .NET  Java.   ,    ,   ,         . </p><br><a name="id-4"></a><br><h1> 4.       </h1><br><p>          ,  C++   rvalue-   .    C++98    <code>std::auto_ptr&lt;&gt;</code> ,     ,     ,        .   ,       ,       (  ).  C++11   rvalue- ,         ,    .     C++11 <code>std::auto_ptr&gt;&lt;&gt;</code>        <code>std::unique_ptr&lt;&gt;</code> .           ,     [Josuttis], [Meyers3]. </p><br><p>        :   - ( <code>std::fstream</code> , etc.),       ( <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , etc.).  MFC     ,      ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.). </p><br><a name="id-5"></a><br><h1> 5.    â€”   </h1><br><p>         .    ,        . ,   ,  ,          .     ,     ,    ,     (    )    .   , ,     ,   .            ( )  ,    .           ,       .    â€”   .     6. </p><br><p>   ,     -  -,  Â«  Â»,   -     .         -    . ,   ,     ,     ,    -       .      Â«Â». </p><br><a name="id-6"></a><br><h1> 6.     -  </h1><br><p>     ,       - . ,       -.   . </p><br><a name="id-6-1"></a><br><h2> 6.1.     </h2><br><p>        -  .    ,  ,  : </p><br><ol><li>       .     ,    . </li><li>      . </li><li>    . </li></ol><br><p>      ,     , ,    .    C++11         . </p><br><p>          Â«   Â» (resource acquisition is initialization, RAII).  RAII         (          ), .,  [Dewhurst1].      Â«Â» RAII.         , , ,     (immutable) RAII. </p><br><a name="id-6-2"></a><br><h2> 6.2.       </h2><br><p> ,      RAII,    ,  ,    .              - ,    ,    -      .  ,       ,       ,        .      . </p><br><a name="id-6-2-1"></a><br><h3> 6.2.1.     </h3><br><p>  ,  ,  ,     ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>       . </li><li>    . </li></ol><br><p>    C++11      , ,  ,     .     ,  - <code>clear()</code> ,     ,    ,      .         . ,   <code>shrink_to_fit()</code> ,    ,     (. ). </p><br><p> ,      RAII,     , ,        .        ,      . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// RAII    X(const X&amp;) = delete;            //      X&amp; operator=(const X&amp;) = delete; //      X(/*  */);              //      ~X();                            //   //     X() noexcept;                    //       X(X&amp;&amp; src) noexcept              //      X&amp; operator=(X&amp;&amp; src) noexcept;  //    // ... };</span></span></code> </pre> <br><p>         . </p><br><pre> <code class="cpp hljs">X x;                    <span class="hljs-comment"><span class="hljs-comment">//  ""  x = X(/*  */); //   x = X(/*  */); //   ,   x = X();                //  </span></span></code> </pre> <br><p>     <code>std::thread</code> . </p><br><p>      2.4,           -  .  , -        -    .    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// RAII // ... public: // ,         X() noexcept;    X(X&amp;&amp; src) noexcept;    X&amp; operator=(X&amp;&amp; src) noexcept;    void Swap(X&amp; other) noexcept; //      void Create(/*  */); //      void Close() noexcept;        //   // ... }; X::X() noexcept {/*    */}</span></span></code> </pre> <br><p>       : </p><br><pre> <code class="cpp hljs">X::X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X() {    Swap(src); } X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {    X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//     Swap(tmp);    return *this; }</span></span></code> </pre> <br><p>   -    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> X::Create(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>) {    <span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*  */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//      Swap(tmp); } void X::Close() noexcept {    X tmp;    Swap(tmp); }</span></span></code> </pre> <br><p>   ,          ,    , -      .           ,  ,       ,   .               ,         . </p><br><p>          -     Â«  Â»,        ,   .         :      ,       ,      ( ).         :    ,   .        ,  :      ,          ,     .  ,            .       [Sutter], [Sutter/Alexandrescu], [Meyers2]. </p><br><p> ,   RAII                 . </p><br><a name="id-6-2-2"></a><br><h3> 6.2.2.    </h3><br><p>        RAII     .  ,  ,  ,    ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>    .    ,  . </li><li>      . </li><li>  . </li></ol><br><p>  Â«Â» RAII,   â€”          .      ,     ,    . 3.       .    Â«Â»,    . </p><br><a name="id-6-2-3"></a><br><h3> 6.2.3.    </h3><br><p>        â€”    .      RAII   ,       .         ,     .   ,   ,              (   -).  -       ( -).        6.2.1,         . </p><br><a name="id-6-3"></a><br><h2> 6.3.   </h2><br><p>     , -          RAII,     :            .      ,     ,   . </p><br><a name="id-conclusion"></a><br><h1> 7.  </h1><br><p> ,  ,     ,     ,    .  -        -. </p><br><p>  4   -: </p><br><ol><li>   . </li><li>   . </li><li>   . </li><li>   . </li></ol><br><p>         .      ,      - :   ,      , -    . </p><br><p>            ,    .  ,    ,     -,        ,     . </p><br><p>   -      .     .            ,                  (.  6.2.3).     ,      (.  6.2.1).         ,           .    ,       ,      .        ,       <code>std::shared_ptr&lt;&gt;</code> . </p><br><a name="id-apps"></a><br><h1>  Aplikasi </h1><br><a name="id-app-1"></a><br><h2>  . Rvalue- </h2><br><p> Rvalue-    C++ ,          ,    rvalue-.  rvalue-   <code>T</code>   <code>T&amp;&amp;</code> . </p><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_Value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    Int(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val) : m_Value(val) {}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Value; }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ m_Value = val; } };</code> </pre> <br><p>    , rvalue-  . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r0; <span class="hljs-comment"><span class="hljs-comment">// error C2530: 'r0' : references must be initialized</span></span></code> </pre> <br><p>   rvalue-   ++    ,       lvalue.  Contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Int&amp;&amp; r1 = i; <span class="hljs-comment"><span class="hljs-comment">// error C2440: 'initializing' : cannot convert from 'Int' to 'Int &amp;&amp;'</span></span></code> </pre> <br><p>      rvalue: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r2 = Int(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-comment"><span class="hljs-comment">// OK Int&amp;&amp; r3 = 5;       // OK</span></span></code> </pre> <br><p>  lvalue       rvalue-: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r4 = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Int&amp;&amp;&gt;(i); <span class="hljs-comment"><span class="hljs-comment">// OK</span></span></code> </pre> <br><p>      rvalue-    (  ) <code>std::move()</code> ,     (  <code>&lt;utility&gt;</code> ). </p><br><p> Rvalue      rvalue  ,     . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&amp; r5 = <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// OK int&amp; r6 = 2 * 2;  // error</span></span></code> </pre> <br><p>   rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; r.Get() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// : 7 r.Set(19); std::cout &lt;&lt; r.Get() &lt;&lt; '\n'; // : 19</span></span></code> </pre> <br><p> Rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">5</span></span>; Int&amp; x = r;           <span class="hljs-comment"><span class="hljs-comment">// OK const Int&amp; cx = r;    // OK</span></span></code> </pre> <br><p> Rvalue-     ,      .     ,      rvalue-,       rvalue . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// error, lvalue  Foo(std::move(i)); // OK Foo(Int(4));       // OK Foo(5);            // OK</span></span></code> </pre> <br><p>     ,      rvalue      rvalue-              ,       .        rvalue-. </p><br><p>   ,   ,   ,    rvalue-,   (ambiguous)  rvalue . </p><br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Int&amp;)</span></span></span></span>;</code> </pre> <br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(i)); // Foo(Int&amp;&amp;) Foo(Int(6));       // Foo(Int&amp;&amp;) Foo(9);            // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>       :  rvalue-     lvalue. </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; Foo(r);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(r)); // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>      ,    rvalue-,    lvalue     <code>std::move()</code> . .          2.4. </p><br><p>    ++11,   rvalue- â€”      -.      (lvalue/rvalue)   <code>this</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X();    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoIt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> &amp;</span></span>;  <span class="hljs-comment"><span class="hljs-comment">// this   lvalue    void DoIt() &amp;&amp;; // this   rvalue // ... }; X x; x.DoIt();   // DoIt() &amp; X().DoIt(); // DoIt() &amp;&amp;</span></span></code> </pre> <br><a name="id-app-2"></a><br><h2>  .   </h2><br><p>  ,            ( <code>std::string</code> , <code>std::vector&lt;&gt;</code> , etc.)       .         â€”    .     ,    rvalue-          .    ,   ,   -   ,    - ,    .       ,  ,       ,         rvalue,       lvalue.      ,        rvalue.    .         ,   (    lvalue),       RVO. </p><br><a name="id-refs"></a><br><h1>  Referensi </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> [Alexandrescu] <br> , .    C++.: .  dari bahasa inggris  - M.: LLC â€œSaya. Â», 2002. </p><br><p> [Guntheroth] <br> , .    C++.     .: .  dari bahasa inggris â€” .:  Â«-Â», 2017. </p><br><p> [Josuttis] <br> ,  .   C++:  , 2- .: .  dari bahasa inggris  - M.: LLC â€œSaya. Â», 2014. </p><br><p> [Dewhurst1] <br> ,  . C++.  , 2- .: .  dari bahasa inggris â€” .: -, 2013. </p><br><p> [Dewhurst2] <br> ,  .   C++.         .: .  dari bahasa inggris â€” .:  , 2012. </p><br><p> [Meyers1] <br> , .    C++. 35        .: .  dari bahasa inggris â€” .:  , 2000. </p><br><p> [Meyers2] <br> , .   C++. 55        .: .  dari bahasa inggris â€” .:  , 2014. </p><br><p> [Meyers3] <br> , .    C++: 42    C++11  C ++14.: .  dari bahasa inggris  - M.: LLC â€œSaya. Â», 2016. </p><br><p> [Sutter] <br> , .     C++.: .  dari bahasa inggris â€” :  Â«.. Â», 2015. </p><br><p> [Sutter/Alexandrescu] <br> , . , .    ++.: .  dari bahasa inggris  - M.: LLC â€œSaya. Â», 2015. </p><br><p> [Schildt] <br> , .    C++.: .  dari bahasa inggris â€” .: -, 2005. </p><br><p> [Alger] <br> , . C++:  .: .  dari bahasa inggris â€” .:  Â« Â«Â», 1999. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425837/">https://habr.com/ru/post/id425837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425827/index.html">Pelajaran Google+: proyek perlu memastikan bahwa batas-batas antara kepentingan pengguna dalam kehidupan nyata dihormati secara online</a></li>
<li><a href="../id425829/index.html">Bagaimana kami bertarung dengan Roskomnadzor dan apa yang terjadi</a></li>
<li><a href="../id425831/index.html">Peringatan RKN - Database Roskomnadzor di browser Anda</a></li>
<li><a href="../id425833/index.html">Alat untuk membantu Anda memilih ide terbaik untuk produk Anda.</a></li>
<li><a href="../id425835/index.html">â€œBreaking Bugsâ€ di Sberbank: cara memperbaiki tingkat bug tujuh hari per hari</a></li>
<li><a href="../id425839/index.html">Ulasan Konferensi Atlassian</a></li>
<li><a href="../id425843/index.html">Python untuk anak: memilih tutorial</a></li>
<li><a href="../id425845/index.html">Mengunci aplikasi secara otomatis di Google Play</a></li>
<li><a href="../id425847/index.html">Contoh menggunakan Microsoft Flow atau Cara memberi bunga kepada istri Anda</a></li>
<li><a href="../id425849/index.html">Amazon menyerah dan menaikkan gaji karyawan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>