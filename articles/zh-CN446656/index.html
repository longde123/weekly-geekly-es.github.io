<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐻 🤣 🐢 用神经声码器LPCNet进行1600bit / s语音编码 ⚱️ 🌯 ♥️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这是有关LPCNet的第一篇文章的续篇 。 在第一个演示中，我们提出了一种将信号处理和深度学习相结合的体系结构 ，以增强神经语音合成的有效性。 这次，我们将把LPCNet变成具有非常低比特率的神经语音编解码器（请参阅科学文章 ）。 它可以在当前设备甚至电话上使用。 

 神经声码器首次在电话的一个处...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>用神经声码器LPCNet进行1600bit / s语音编码</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446656/"><img src="https://habrastorage.org/getpro/habr/post_images/6ba/d56/c2e/6bad56c2eecd2e1aad4190ba40d1be74.jpg"><br><br> 这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关LPCNet</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一篇文章的续篇</a> 。 在第一个演示中，我们提出了一种将信号处理和深度学习相结合的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">体系结构</a> ，以增强神经语音合成的有效性。 这次，我们将把LPCNet变成具有非常低比特率的神经语音编解码器（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">科学文章</a> ）。 它可以在当前设备甚至电话上使用。 <br><br> 神经声码器首次在电话的一个处理器内核上实时工作，而不是在高速GPU上实时工作。 最终的1600 bps比特率大约是普通宽带编解码器的十倍。 其质量要比现有的具有非常低比特率的声码器好得多，并且可以与使用更高比特率的更传统的编解码器相媲美。 <br><a name="habracut"></a><br><h3> 波形编码器和声码器 </h3><br> 语音编解码器有两种大类型：波形编码器和声码器。 波形编码器包括Opus，AMR / AMR-WB和所有可用于音乐的编解码器。 他们尝试提供尽可能接近原始波形的解码波形-通常会考虑一些感知特征。 另一方面，声码器实际上是合成器。 编码器提取有关语音路径的音高和形状的信息，将该信息传递给解码器，然后他重新合成语音。 几乎就像语音识别，然后在语音合成器中读取文本一样，不同的是文本编码器比语音识别更简单/更快（并且传达了更多的信息）。 <br><br> 声码器自20世纪70年代就已经存在，但是由于其解码器执行语音合成，因此它们不可能比传统的语音合成系统好得多，后者直到最近听起来简直糟透了。 这就是为什么声码器通常以低于3 kB / s的速度使用的原因。 此外，波形编码器可提供最佳质量。 这种情况一直持续到最近，当诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WaveNet之</a>类的神经语音合成系统<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">出现时</a> 。 突然之间，合成听起来好多了，当然，有些人想<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从WaveNet制作声码器</a> 。 <br><br><h3>  LPCNet概述 </h3><br>  WaveNet产生非常高质量的语音，但是需要数百吉比特的计算能力。  LPCNet大大降低了计算复杂度。 声码器基于WaveRNN，它使用递归神经网络（RNN）和稀疏矩阵来改进WaveNet。  LPCNet通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">线性预测</a> （LPC）进一步增强了WaveRNN，在老式声码器中效果很好。 它根据先前样本的线性组合来预测样本，最重要的是，它使它比神经网络快许多倍。 当然，它不是通用的（否则70年代的声码器听起来不错），但是它可以大大减轻神经网络的负担。 这样一来，您可以使用比WaveRNN小的网络，而无需牺牲质量。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/652/8fc/7df/6528fc7df88256e797551173b11f5e1d.png"></div><br>  <i><font color="gray">让我们仔细看看LPCNet。</font></i>  <i><font color="gray">左侧的黄色部分每帧计算一次，其输出用于右侧的网络采样频率（蓝色）。</font></i>  <i><font color="gray">计算单元基于先前的样本和线性预测系数来预测时间t处的样本。</font></i> <br><br><h1> 压缩特性 </h1><br>  LPCNet从每帧20个字符的向量中合成语音，持续10 ms。 其中，有18个符号是表示频谱形状的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">倒频谱</a>系数。 其余两个描述高度：一个参数用于音调周期（音调周期），另一个参数用于<i>强度</i> （如果您通过音调引入延迟，则信号与自身的相关程度）。 如果以浮点值的形式存储参数，则在存储或传输期间，所有这些信息最多需要64 kbit / s。 这太多了，因为即使Opus编解码器也仅以16 kbit / s（对于16 kHz单声道）提供非常高质量的语音编码。 显然，您需要在此处应用强压缩。 <br><br><h3> 身高 </h3><br> 所有编解码器都严重依赖音调，但是与波形编码器不同，波形编码器仅“音调”有助于减少冗余，而声码器则没有后退。 如果您选择了错误的高度，它们将开始发出声音差（甚至难以辨认）的语音。  LPCNet编码器在不赘述的情况下（请参阅科学文章）正在努力避免在高度上犯错误。 搜索从搜索语音信号中的时间<i>相关性</i>开始。 参见下面的典型搜索工作原理。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e4/024/a6a/3e4024a6aac9fcd8cd1fb8eb750918e6.gif"><br>  <i><font color="gray">音调是重复音调的时间段。</font></i>  <i><font color="gray">动画会延迟搜索与信号x（n）及其副本x（nT）之间的最大相关性对应的步骤。</font></i>  <i><font color="gray">具有最大相关性的T值是高度的间距</font></i> <br><br> 该信息需要使用尽可能少的位进行编码，而不会降低结果的质量。 由于我们可以自然地以对数尺度感知频率（例如，每个音乐八度音阶将以前的频率加倍），因此在对数编码中这是有意义的。 在大多数人中，语音信号的高度在62.5到500 Hz之间（我们此处不尝试覆盖女高音）。 使用7位（128个可能的值），我们得到的分辨率约为四分之一音（与re和re之间的差是一个音）。 <br><br> 那么，高度完成了吗？ 好吧，不是那么快。 人们不像1960年代电影中的机器人那样说话。 即使在40毫秒的数据包内，音高也会有所不同。 您需要考虑到这一点，保留用于更改高度的参数的位：3位以对数据包开始和结束之间的差异进行编码，最多不超过2.5个半音。 最后，您需要编码音高阶跃的相关性，以区分元音和辅音（例如s和f）。 两位足够用于相关。 <br><br><h3> 倒谱 </h3><br> 音调包含语音的外部特征（韵律，情感，强调等），而频谱特征则决定<i>了</i>说话的<i>内容</i> （除了音调语言（例如中文，音调对于含义很重要）之外）。 对于任何元音，声带产生的声音几乎相同，但是声道的形状决定了将说出哪种声音。 语音路径充当过滤器，编码器的任务是评估该过滤器并将其传递给解码器。 如果将频谱转换为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">倒</a>频谱，则可以有效地做到这一点（是的，这是一个字母顺序改变的“频谱”，在数字信号处理中我们是可笑的家伙）。 <br><br> 对于16 kHz的输入信号，倒频谱基本上代表每10 ms 18个数字的向量，需要尽可能地对其进行压缩。 由于我们在40 ms的数据包中有四个这样的向量，并且它们通常彼此相似，因此我们希望尽可能地消除冗余。 这可以通过使用相邻向量作为预测变量并仅传达预测与实际值之间的差异来完成。 同时，如果其中一个消失了，我们不想过分依赖以前的软件包。 看来问题已经解决了... <br><br>  <font color="brown"><i>如果您只有锤子，那么一切看起来都像钉子-亚伯拉罕·马斯洛（Abraham Maslow）。</i></font> <br><br> 如果您<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用视频编解码器进行</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了</a>大量<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">工作</a> ，那么您可能会想到B帧的概念。 与视频编解码器不同，视频编解码器将一帧分为许多数据包，相反，我们在一个数据包中有许多帧。 我们首先对<i>关键帧</i> （即独立向量）和数据包的<b>末尾进行</b>编码。 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">矢量量化</a> （VQ）对该矢量进行编码，无需预测，占用37位：7代表总能量（第一倒频谱系数），30代表其他参数。 然后是（分层的）B帧。 在这两个关键字中（一个来自当前软件包，一个来自上一个关键字），可以预测它们之间的倒谱。 作为对实际值和预测之间的差异进行编码的预测器，可以选择两个关键帧之一或它们的平均值。 我们再次使用VQ并使用总共13位（包括预测变量的选择）对该向量进行编码。 现在我们只剩下两个向量和很少的位。 使用后3位可以简单地为其余向量选择预测变量。 当然，图中所有这些都容易理解： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/395/c02/530395c02aba2079c8e82e79f98071f4.png"></div><br>  <i><font color="gray">包k的倒谱预测和量化。</font></i>  <i><font color="gray">绿色向量被独立量化，蓝色向量被预测，红色向量使用预测而没有残留量化。</font></i>  <i><font color="gray">预测用箭头表示。</font></i> <br><br><h3> 全部放在一起 </h3><br> 加上以上所有内容，我们每40毫秒数据包可获得64位或每秒1600位。 如果要计算压缩率，则未压缩的宽带语音为256 kbps（16 kHz，每个样本16位），这意味着160倍的压缩率！ 当然，您始终可以使用量化器并获得较低或较高的比特率（对质量有相应的影响），但是您需要从某个地方开始。 这是一张表格，其中列出了这些位的位置。 <br><br><table><tbody><tr><td align="center" colspan="2">  <b>位分配</b> </td></tr><tr><td> 参量 </td><td> 位 </td></tr><tr><td> 节距 </td><td>  6 </td></tr><tr><td> 高度调制 </td><td>  3 </td></tr><tr><td> 海拔相关 </td><td>  2 </td></tr><tr><td> 能量 </td><td>  7 </td></tr><tr><td> 独立倒谱VQ（40毫秒） </td><td>  30 </td></tr><tr><td> 预测的VQ倒谱（20 ms） </td><td>  13 </td></tr><tr><td> 倒谱倒插（10 ms） </td><td>  3 </td></tr><tr><td> 合计 </td><td>  64 </td></tr></tbody></table><br> 每个数据包64位40 ms，每秒25个数据包，可获得1600 bps。 <br><br><h1> 实作 </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LPCNet源代码</a>在BSD许可下可用。 它包括一个简化编解码器使用的库。 请注意，开发尚未完成：格式和API都<b>必将</b>发生变化。 该存储库还具有一个<code>lpcnet_demo</code>演示应用程序，可以在其中轻松地从命令行测试编解码器。 有关完整说明，请参见README.md文件。 <br><br> 谁想要更深入地研究，可以选择训练新模型和/或将LPCNet用作其他应用程序的构建基块，例如语音合成（LPCNet只是合成器的一个组件，它不能自行执行合成）。 <br><br><h3> 性能表现 </h3><br> 神经语音合成需要大量资源。 在去年的ICASSP会议上，来自Google / DeepMind的Bastian Klein和同事提出<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了一个基于WaveNet的2400 bps编解码器</a> ，并从codec2接收了比特流。 尽管听起来很棒，但是数百吉比特的计算复杂性意味着，如果没有昂贵的GPU和认真的努力，就无法实时启动它。 <br><br> 相反，我们的1600 bit / s编解码器仅产生3 gigaflops，旨在在价格更便宜的设备上实时工作。 实际上，它现在可以在实际应用中使用。 为了进行优化，需要为AVX2 / FMA和Neon指令集编写一些代码（仅嵌入式代码，不带汇编器）。 因此，我们现在不仅可以在PC上，也可以在或多或少的现代手机上实时编码（尤其是解码）语音。 以下是x86和ARM处理器的性能。 <br><br><table><tbody><tr><td colspan="4" align="center"> 性能表现 </td></tr><tr><td> 中央处理器 </td><td> 频次 </td><td> 一核心的百分比 </td><td> 实时 </td></tr><tr><td>  AMD 2990WX（剥线器） </td><td>  3.0 GHz * </td><td>  14％ </td><td>  7.0倍 </td></tr><tr><td> 英特尔至强E5-2640 v4（Broadwell） </td><td>  2.4 GHz * </td><td>  20％ </td><td>  5.0倍 </td></tr><tr><td> 骁龙855（ <b>Galaxy S10</b>上为Cortex-A76） </td><td>  2.82 GHz </td><td>  31％ </td><td>  3.2倍 </td></tr><tr><td> 骁龙845（ <b>Pixel 3</b>上的Cortex-A75） </td><td>  2.5 GHz </td><td>  68％ </td><td>  1.47倍 </td></tr><tr><td>  AMD A1100（Cortex-A57） </td><td>  1.7 GHz的 </td><td>  102％ </td><td>  0.98倍 </td></tr><tr><td>  BCM2837（Raspberry Pi 3上的Cortex-A53） </td><td>  1.2 GHz </td><td>  310％ </td><td>  0.32倍 </td></tr><tr><td>  *涡轮模式 </td><td></td><td></td><td></td></tr></tbody></table><br><br> 这些数字很有趣。 尽管只显示了Broadwell和Threadripper，但是在x86平台上，Haswell和Skylake处理器具有类似的性能（考虑到时钟频率）。 但是，ARM处理器彼此之间明显不同。 即使考虑到频率差异，A76的速度也比A53快五到六倍：这是可以预料的，因为A53主要用于提高能源效率（例如，在big.LITTLE系统中）。 尽管如此，LPCNet可能仅使用一个内核就可以在现代电话上实时工作。 尽管在Raspberry Pi 3上实时运行它会很不错，但到目前为止，还没有，但是没有什么是不可能的。 <br><br> 在x86上，性能限制的原因是理论最大值的五倍。 如您所知，矩阵向量乘法运算的效率比矩阵矩阵运算低，因为每个运算的下载量更多-具体来说，每个FMA操作只有一个矩阵下载。 一方面，性能与二级缓存有关，后者每个周期仅提供16位。 另一方面，英特尔声称L2在Broadwell上每个周期最多可以放弃32位，在Skylake上每个周期最多可以放弃64位。 <br><br><h1> 结果 </h1><br> 我们进行了MUSHRA风格的音频测试，以比较编码质量。 测试条件： <br><br><ul><li>  <b>样本</b> ：原始（如果您获得比原始结果更好的结果，则您的测试显然存在问题） <br></li><li>  <b>1600 bps LPCNet</b> ：我们的演示 <br></li><li>  <b>未压缩的LPNet</b> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一篇文章中的</a> “具有122个等效单位的LPNet” <br></li><li>  <b>Opus 9000 bps宽带</b> ：Opus 1.3编码宽带音频的最低比特率 <br></li><li>  <b>2400 bps的MELP</b> ：低比特率的著名声码器（质量类似于编解码器2） <br></li><li>  <b>Speex 4000 bps</b> ：永远不要使用这种宽带声码器，但它是底部的一个很好的参考 </li></ul><br> 在第一个测试（第1组）中，我们有八个男人和两个女人的陈述的语音片段。 第一组中的文件属于用于训练的相同数据库（即，相同的记录条件），但是这些特定人员被排除在训练集中。 在第二个测试（第2组）中，我们使用了Opus测试中的一些文件（未压缩），在不同条件下录制声音，以确保LPCNet可以进行某种概括。 在这两个测试中，每个参与者100名，因此误差非常小。 请参阅下面的结果。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc6/e7d/cc5/dc6e7dcc5b08735cb492ad07bf7894af.svg"></div><br>  <i><font color="gray">两次测试的主观质量（MUSHRA）</font></i> <br><br> 总的来说，LPCNet的1600 bps看起来不错-比2400 bps的MELP更好，并且不落后于Opus 9000 bps。 同时，未压缩的LPCNet在9000 bps的质量上比Opus稍好。 这意味着可以在2000-6000 bps的比特率下提供比Opus更好的质量。 <br><br><h3> 听你自己 </h3><br> 以下是音频测试的示例： <br><br> 女人（1套） <br><br><ul><li>  <a href="">样例</a> </li><li>  <a href="">LPCNet 1600 bps</a> </li><li>  <a href="">未压缩的LPNet</a> </li><li>  <a href="">Opus 9000 bps</a> </li><li>  <a href="">MELP 2400 bps</a> </li><li>  <a href="">Speex 4000 bps</a> </li></ul><br> 男人（一套1） <br><br><ul><li>  <a href="">样例</a> </li><li>  <a href="">LPCNet 1600 bps</a> </li><li>  <a href="">未压缩的LPNet</a> </li><li>  <a href="">Opus 9000 bps</a> </li><li>  <a href="">MELP 2400 bps</a> </li><li>  <a href="">Speex 4000 bps</a> </li></ul><br> 混合（组2） <br><br><ul><li>  <a href="">样例</a> </li><li>  <a href="">LPCNet 1600 bps</a> </li><li>  <a href="">未压缩的LPNet</a> </li><li>  <a href="">Opus 9000 bps</a> </li><li>  <a href="">MELP 2400 bps</a> </li><li>  <a href="">Speex 4000 bps</a> </li></ul><br><br><h1> 可以在哪里使用？ </h1><br> 我们认为这本身就是一项很酷的技术，但它也有实际应用。 这里只是一些选择。 <br><br><h3> 连接不良的国家/地区的VoIP </h3><br> 并非每个人都总是有高速连接。 在某些国家/地区，通讯非常缓慢且不可靠。  1600位语音编解码器在这种情况下可以正常工作，甚至出于可靠性考虑甚至多次发送数据包。 当然，由于包头的开销（IP + UDP + RTP为40字节），最好制作更大的包：40、80或120 ms。 <br><br><h3> 业余/高频广播 </h3><br> 十年来， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">David Rowe</a>一直致力于无线电通信的语音编码。 他开发了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Codec2</a> ，它以700到3200 bps的速度传输语音。 在过去的一年中，David和我讨论了如何使用神经综合来改进Codec2，现在我们终于做到了。  David在他的博客中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">写</a>了他自己的基于LPCNet的编解码器实现与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FreeDV</a>集成的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实现</a> 。 <br><br><h3> 丢包可靠性更高 </h3><br> 以少量的比特编码质量好的比特流的能力对于在不可靠的信道上提供冗余很有用。  Opus具有称为LBRR的前向纠错（FEC）机制，该机制以较低的比特率编码前一帧并在当前帧中发送它。 它运作良好，但会增加大量开销。  1600 bit / s的流复制效率更高。 <br><br><h1> 计划 </h1><br> 使用LPCNet的可能性更多。 例如，改进现有编解码器（相同的Opus）。 与其他编解码器一样，Opus质量在非常低的比特率（低于8000 bps）下会迅速下降，因为波形编解码器没有足够的比特来匹配原始比特。 但是，传输的线性预测信息足以使LPCNet合成听起来不错的语音-优于Opus在此比特率下的表现。 此外，Opus传输的其余信息（残差预测）有助于LPCNet综合获得更好的结果。 从某种意义上讲，LPCNet可以用作精美的后置过滤器，以提高Opus（或其他任何编解码器）的质量，而无需更改位流（即，同时保持完全兼容性）。 <br><br><h1> 其他资源 </h1><br><ol><li>  J.-M. Valin， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">J.Skoglund</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用LPCNet的1.6 Kbps宽带神经声码器</a> ，已<i>发送至Interspeech 2019</i> ，arXiv： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1903.12087</a> 。 </li><li>  J.-M. Valin，J。Skoglund， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LPCNet：通过线性预测进行高级神经语音合成</a>  <i>ICASSP，2019</i> ，arXiv： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1810.11846</a> 。 </li><li>  A.van den Oord，S.Dileman，H.Zen，K.Simonyan，O.Vinyals， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">A.Graves</a> ，N.Kalkhbrenner， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">E.Senor</a> ，K.Kavukuglu， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WaveNet：未处理声音的生成模型</a> ，2016年。 </li><li>  N.Karlbrenner，E.Elsen，C.Simonyan，S.Nouri，N.Casagrande，E.Lockhart，F.Stimberg，A.van den Oord，S.Dileman，K。 </li><li>  V.B. Klein，F.S.K。Lim，A.Lyubs，J.Skoglund，F.Stimberg，K.Wang，T.S.Walters， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基于Wavenet的低比特率语音编码</a> ，2018年 </li><li>  LPCNet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的源代码</a> 。 </li><li>  David Rowe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基于LPCNet的FreeDV编解码器</a> 。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在irc.freenode.net</a>上加入关于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">#opus</a>开发的讨论（→ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Web界面</a> ） </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446656/">https://habr.com/ru/post/zh-CN446656/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN446644/index.html">如何在2019年运行SMM：Neil Patel的17个图表</a></li>
<li><a href="../zh-CN446646/index.html">InterSystems IRIS 2019.1发行版</a></li>
<li><a href="../zh-CN446648/index.html">使用Operator Framework开发Kubernetes运营商</a></li>
<li><a href="../zh-CN446650/index.html">测试人员要花多少钱，工资取决于什么？ 建立成功的质量检查专家的画像</a></li>
<li><a href="../zh-CN446654/index.html">我们如何保存代码审查</a></li>
<li><a href="../zh-CN446664/index.html">距SAP论坛2019只有2周的路程！ 那里会有什么？</a></li>
<li><a href="../zh-CN446666/index.html">充分利用图形计算器：TI-83上的游戏</a></li>
<li><a href="../zh-CN446668/index.html">适用于网络的Python：大三学生工作和成长需要了解的知识</a></li>
<li><a href="../zh-CN446674/index.html">我们为确定电磁波到达方向的MUSIC算法建模</a></li>
<li><a href="../zh-CN446676/index.html">为Commodore 116橡胶键盘制作缺失的琴键</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>