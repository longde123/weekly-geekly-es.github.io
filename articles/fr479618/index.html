<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåø üåº ‚ÜïÔ∏è Publication de Postgres Pro Standard 12.1 üêµ üöÜ ‚úãüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le SGBD Postgres Pro Standard est con√ßu pour livrer nos produits aux utilisateurs plus rapidement que nous ne pouvons le faire via PostgreSQL. Ces fon...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Publication de Postgres Pro Standard 12.1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/479618/">  Le SGBD Postgres Pro Standard est con√ßu pour livrer nos produits aux utilisateurs plus rapidement que nous ne pouvons le faire via PostgreSQL.  Ces fonctionnalit√©s qui ne sont pas encore incluses dans PostgreSQL, mais qui s'y trouvent sur un chemin solide, nous les incluons dans Postgres Pro Standard.  De plus, Postgres Pro Standard comprend certaines extensions qui sont demand√©es par nos clients, mais qui ne sont pas disponibles dans la distribution PostgreSQL standard. <br><br>  Parfois, il existe des exceptions lorsque, dans Postgres Pro Standard, √† la demande des utilisateurs et pour leur satisfaction, des fonctionnalit√©s moins triviales sont incluses, ce qui n'est bien plac√© que dans Postgres Pro Enterprise.  En particulier, c'est PTRACK, √† ce sujet ci-dessous. <br><br>  Pas tous, mais une bonne part des extensions et utilitaires suppl√©mentaires inclus dans Standard, a √©t√© d√©velopp√© par Postgres Professional.  Tous les correctifs Postgres Pro ont √©t√© invent√©s et mis en ≈ìuvre par nos propres efforts.  Commen√ßons par les am√©liorations qui ont n√©cessit√© une intervention dans le moteur de base de donn√©es. <br><a name="habracut"></a><br>  Postgres Pro Standard diff√®re de PostgreSQL √† deux niveaux: l'ensemble des extensions et des utilitaires qui se trouvent dans l'assemblage et le noyau lui-m√™me.  Certains correctifs utiles ont √©t√© appliqu√©s au noyau qui optimisent les performances (par exemple, un d√©tecteur de verrouillage sans freinage) et des correctifs qui augmentent l'efficacit√© des utilitaires et des extensions (par exemple, pour que pg_probackup fonctionne √† pleine puissance, le correctif PTRACK 2.0 est appliqu√©).  Les diff√©rences entre la version principale de Standard et PostgreSQL sont minimis√©es pour la plus grande compatibilit√© possible.  Disons que l'extension pg_pathman fait partie de Standard, mais elle peut √™tre t√©l√©charg√©e depuis le github, construite et install√©e sur la vanilla PostgreSQL, il n'y aura pas de probl√®mes de compatibilit√©. <br>  Commen√ßons par les changements dans le noyau. <br><br><h3>  V√©rification des versions ICU </h3><br>  Dans PostgreSQL, par d√©faut, ils sont utilis√©s pour comparer des cha√Ænes en les comparant √† l'aide de la biblioth√®que standard C. Mais il y a aussi la possibilit√© d'utiliser la biblioth√®que <a href="http://site.icu-project.org/">ICU</a> d√©velopp√©e par IBM dans le m√™me but.  Cette biblioth√®que est pr√©cieuse pour nous principalement parce qu'elle fournit un tri ind√©pendant de la plate-forme.  C'est pourquoi, par exemple, il est utilis√© dans 1C, et les assemblages PostgreSQL "pour un" fonctionnent depuis longtemps avec cette biblioth√®que. <br><br>  De plus, les comparaisons de cha√Ænes via l'ICU sont parfois plus rapides que via libc, et le nombre de caract√®res connus est plus important.  En g√©n√©ral, une biblioth√®que utile.  Postgres Pro Standard travaille avec lui depuis la toute premi√®re version (9.5).  Dans PostgreSQL, travailler avec ICU est possible depuis la version 10. <br><br>  La biblioth√®que est utile, mais vous devez garder √† l'esprit certaines situations d'urgence.  Supposons qu'un utilisateur de SGBD ait d√©cid√© de mettre √† niveau le syst√®me d'exploitation.  Avec le syst√®me d'exploitation, la biblioth√®que ICU peut √©galement √™tre mise √† niveau et l'ordre des mots dans le tri changera.  Apr√®s cela, imm√©diatement tous les index deviendront inutilisables: la recherche d'index donnera des r√©sultats incorrects.  Dans de tels cas, la base a d√©clar√© que la version de l'USI avait chang√© et s'√©tait arr√™t√©e. <br><br>  Mais c'est une d√©cision douloureusement difficile.  Apr√®s des discussions et une enqu√™te aupr√®s des clients, il a √©t√© d√©cid√© d'adoucir le comportement.  D√©sormais, seules les versions de COLLATION (r√®gles de tri) sont v√©rifi√©es.  Si les versions de COLLATION utilis√©es dans la base de donn√©es ont chang√©, la base de donn√©es √©met un avertissement au d√©marrage du SGBD, mais il ne s'arr√™te pas.  Il rappelle √©galement √† l'utilisateur au d√©but de chaque session. <br><br><h3>  Optimisation des verrous, jointures et GROUP BY </h3><br>  Le m√©canisme de d√©tection de blocage peut d√©grader les performances.  Le standard ne peut plus: le patch du noyau lui permet de fonctionner sans freinage.  Apr√®s des am√©liorations majeures du m√©canisme de v√©rification, ces probl√®mes n'apparaissent que sur un grand nombre de c≈ìurs et de connexions. <br><br>  Meilleure estimation du nombre de r√©sultats de jointures en pr√©sence d'indices appropri√©s. <br><br>  Vous pouvez maintenant utiliser des index appropri√©s pour grouper et trier les champs.  Cette fonctionnalit√© a d'abord √©t√© incluse dans Standard 11.1.1 et Enterprise 11.2.1.  Notre Standard 12 en poss√®de √©galement un. <br><br>  Fedor Sigaev, CTO de Postgres Professional, a offert ces correctifs utiles √† la communaut√©, ils sont √† l'√©tude et, esp√©rons-le, seront inclus dans la version PG 13. <br><br>  Nous illustrons l'optimisation du fonctionnement GROUP BY par des exemples: ils sont clairs et facilement reproductibles. <br><br>  L'int√©r√™t de ce patch est que Postgres n'a pas optimis√© l'ordre des champs list√©s dans GROUP BY.  Et le temps d'ex√©cution d√©pend de la s√©quence de regroupement (avec le m√™me r√©sultat de requ√™te).  Il y a des d√©tails dans la <a href="https://postgrespro.ru/list/thread-id/2388982">discussion</a> sur la liste de diffusion des <a href="https://postgrespro.ru/list/pgsql-hackers">pirates</a> . <br><br>  Si la valeur de la premi√®re colonne √† traiter est unique, rien d'autre ne doit √™tre compar√©.  Si vous partez d'une autre colonne, vous devez comparer. <br><br><br>  Se rendre au test: <br><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> id, i/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> p, format(<span class="hljs-string"><span class="hljs-string">'%60s'</span></span>, i%<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000000</span></span>) i;</code> </pre> <br><br>  Dans le champ de texte v, 60 espaces sont g√©n√©r√©s, suivis des chiffres 0 ou 1. Les entr√©es ressemblent √† ceci: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; id | p | v <span class="hljs-comment"><span class="hljs-comment">---------+--------+-------------------------------------------------------------- 1000000 | 500000 | 0 999999 | 499999 | 1 999998 | 499999 | 0 (3 rows)</span></span></code> </pre> <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">ANALYSE</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_hashagg=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_parallel_workers= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_parallel_workers_per_gather = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><br>  Regroupez les r√©sultats: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p, v;</code> </pre> <br><br>  Plan PostgreSQL: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------ GroupAggregate (cost=204036.84..218981.05 rows=494421 width=73) (actual time=843.999..1194.985 rows=1000000 loops=1) Group Key: p, v -&gt; Sort (cost=204036.84..206536.84 rows=1000000 width=65) (actual time=843.990..946.769 rows=1000000 loops=1) Sort Key: p, v Sort Method: external sort Disk: 73320kB -&gt; Seq Scan on btg (cost=0.00..22346.00 rows=1000000 width=65) (actual time=0.158..151.645 rows=1000000 loops=1) Planning time: 0.317 ms Execution time: 1250.086 ms (8 rows)</span></span></code> </pre> <br><br>  Maintenant dans l'ordre inverse: v, et alors seulement p: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> v, p; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------ GroupAggregate (cost=204036.84..218981.05 rows=494421 width=73) (actual time=2552.477..3353.890 rows=1000000 loops=1) Group Key: v, p -&gt; Sort (cost=204036.84..206536.84 rows=1000000 width=65) (actual time=2552.469..3111.516 rows=1000000 loops=1) Sort Key: v, p Sort Method: external merge Disk: 76264kB -&gt; Seq Scan on btg (cost=0.00..22346.00 rows=1000000 width=65) (actual time=0.082..126.578 rows=1000000 loops=1) Planning time: 0.060 ms Execution time: 3411.048 ms (8 rows)</span></span></code> </pre> <br><br>  Il s'av√®re que l'inverse est sensiblement plus lent.  En effet, le premier champ <code>v</code> analys√© avec un petit √©cart de valeurs.  Vous devez faire beaucoup de v√©rifications sur les champs restants (ici - le champ p). <br><br>  Voyons comment la m√™me requ√™te fonctionnera avec un correctif qui s√©lectionne l'ordre optimal pour le traitement des colonnes: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------- GroupAggregate (cost=237400.11..252417.09 rows=501698 width=73) (actual time=415.541..703.647 rows=1000000 loops=1) Group Key: p, v -&gt; Sort (cost=237400.11..239900.11 rows=1000000 width=65) (actual time=415.533..507.785 rows=1000000 loops=1) Sort Key: p, v Sort Method: external merge Disk: 73488kB -&gt; Seq Scan on btg (cost=0.00..22346.00 rows=1000000 width=65) (actual time=0.059..139.587 rows=1000000 loops=1) Planning Time: 0.123 ms Execution Time: 742.118 ms (8 rows)</span></span></code> </pre> <br><br>  Et dans l'ordre inverse: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------ GroupAggregate (cost=237400.11..252417.09 rows=501698 width=73) (actual time=414.322..714.593 rows=1000000 loops=1) Group Key: p, v -&gt; Sort (cost=237400.11..239900.11 rows=1000000 width=65) (actual time=414.312..517.707 rows=1000000 loops=1) Sort Key: p, v Sort Method: external merge Disk: 76384kB -&gt; Seq Scan on btg (cost=0.00..22346.00 rows=1000000 width=65) (actual time=0.071..129.835 rows=1000000 loops=1) Planning Time: 0.140 ms Execution Time: 753.031 ms (8 rows)</span></span></code> </pre> <br><br>  Le plan dit que √ßa et l√† l'ordre de traitement est le m√™me: Cl√© de tri: p, v.  En cons√©quence, le temps est approximativement le m√™me.  Comparez maintenant ce qui se passe lorsque l'index est utilis√©. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> btg(p, v); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_seqscan=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_bitmapscan=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> v, p ;</code> </pre> <br><br>  Dans PostgreSQL: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------- GroupAggregate (cost=0.55..74660.04 rows=494408 width=73) (actual time=0.013..391.317 rows=1000000 loops=1) Group Key: p, v -&gt; Index Only Scan using btg_p_v_idx on btg (cost=0.55..62216.16 rows=999974 width=65) (actual time=0.009..120.298 rows=1000000 loops=1) Heap Fetches: 0 Planning time: 0.078 ms Execution time: 442.923 ms (6 rows)</span></span></code> </pre> <br><br>  Et dans l'ordre inverse: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------ GroupAggregate (cost=243904.22..258848.04 rows=494408 width=73) (actual time=2558.485..3352.240 rows=1000000 loops=1) Group Key: v, p -&gt; Sort (cost=243904.22..246404.16 rows=999974 width=65) (actual time=2558.478..3110.242 rows=1000000 loops=1) Sort Key: v, p Sort Method: external merge Disk: 76264kB -&gt; Index Only Scan using btg_p_v_idx on btg (cost=0.55..62216.16 rows=999974 width=65) (actual time=0.011..133.563 rows=1000000 loops=1) Heap Fetches: 0 Planning time: 0.093 ms Execution time: 3409.335 ms (9 rows)</span></span></code> </pre> <br><br>  Maintenant en standard: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------- GroupAggregate (cost=0.55..74196.82 rows=501685 width=73) (actual time=0.150..412.174 rows=1000000 loops=1) Group Key: p, v -&gt; Index Only Scan using btg_p_v_idx on btg (cost=0.55..61680.16 rows=999974 width=65) (actual time=0.134..149.669 rows=1000000 loops=1) Heap Fetches: 0 Planning Time: 0.175 ms Execution Time: 448.635 ms (6 rows)</span></span></code> </pre> <br><br>  Et dans l'ordre inverse: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------- GroupAggregate (cost=0.55..74196.82 rows=501685 width=73) (actual time=0.014..307.258 rows=1000000 loops=1) Group Key: p, v -&gt; Index Only Scan using btg_p_v_idx on btg (cost=0.55..61680.16 rows=999974 width=65) (actual time=0.008..89.204 rows=1000000 loops=1) Heap Fetches: 0 Planning Time: 0.054 ms Execution Time: 337.766 ms (6 rows)</span></span></code> </pre> <br><br>  Le temps est de nouveau le m√™me, ce qui est naturel: en fait, les actions sont les m√™mes. <br><br><h3>  Remplacement d'un octet nul au d√©marrage </h3><br>  Postgres Pro n'accepte pas z√©ro octet (0x00) dans les donn√©es, donc avec COPY FROM ils doivent √™tre remplac√©s, <a href="https://postgrespro.ru/docs/postgrespro/12/runtime-config-compatible">sinon il y aura une erreur</a> .  Il s'agit du v√©ritable probl√®me rencontr√© par le client lors de l'importation de donn√©es √† partir d'un fichier CSV.  Sa solution consiste √† remplacer les octets nuls par le caract√®re ASCII donn√©.  Il doit √™tre diff√©rent des caract√®res QUOTE et DELIMITER utilis√©s lors de l'ex√©cution de COPY FROM;  sinon, le r√©sultat peut √™tre inattendu.  Par d√©faut, la valeur de la variable nul_byte_replacement_on_import (string) '\ 0', c'est-√†-dire qu'aucun remplacement n'est effectu√©. <br><br><h3>  WaitLSN </h3><br>  LSN est un <a href="https://postgrespro.ru/docs/postgrespro/12/sql-waitlsn">num√©ro s√©quentiel dans le journal</a> , c'est-√†-dire un pointeur vers une position dans le WAL (Log Sequence Number).  La commande WAITLSN attend de lire le LSN sp√©cifi√©.  Si l'application fonctionne avec le ma√Ætre et la r√©plique, vous devez vous assurer qu'ils sont synchrones de temps en temps.  WAITLSN est un m√©canisme interprocessus dans PostgrePro qui contr√¥le la synchronisation pendant la <a href="https://postgrespro.ru/docs/postgrespro/12/runtime-config-replication">r√©plication synchrone</a> .  Par d√©faut, le temps d'attente est illimit√©.  Vous pouvez abandonner l'attente en appuyant sur Ctrl + C ou en arr√™tant le serveur postgres.  Vous pouvez √©galement d√©finir le d√©lai d'expiration en ajoutant l'indicateur TIMEOUT ou v√©rifier l'√©tat du LSN cible sans attendre en utilisant l'indicateur NOWAIT. <br>  Supposons qu'une application effectue une certaine action, re√ßoit le num√©ro LSN du SGBD sur le ma√Ætre et souhaite maintenant s'assurer que les actions sur la r√©plique seront synchronis√©es avec le ma√Ætre, c'est-√†-dire  l'application peut √™tre s√ªre que ce qu'elle a enregistr√© sur l'assistant est d√©j√† arriv√© sur la r√©plique et qu'elle est pr√™te √† √™tre lue.  Par d√©faut, cela n'est g√©n√©ralement pas garanti.  WAITLSN vous permet de contr√¥ler cette interaction et de s√©lectionner un mode veille de INFINITELY par d√©faut, √† TIMEOUT et NOWAIT. <br><br><h3>  Relecture des variables de l'ancien recovery.conf </h3><br>  Sur un signal SIGHUP, PostgreSQL relit postgresql.conf, mais pas recovery.conf.  Un correctif de noyau relativement nouveau introduit dans Standard et Enterprise 10.4.1.  forc√© de relire et recovery.conf.  Mais dans Postgres 12, il n'y a aucun fichier recovery.conf: toutes ses variables sont transf√©r√©es vers postgresql.conf.  N√©anmoins, bien que le fichier entier soit relu, les variables de recovery.conf n'ont pas √©t√© red√©finies par SIGHUP, mais ont n√©cessit√© un red√©marrage de Postgres.  En Standard, cela n'est pas obligatoire: tout est lu et red√©fini. <br><br><h3>  Prise en charge de PTRACK </h3><br>  PTRACK 2.0 est un m√©canisme PTRACK repens√© pour les versions Standard et Enterprise 11 et ant√©rieures.  Au niveau du SGBD, cela a fonctionn√© gr√¢ce au patch du noyau, et maintenant l'extension ptrack a √©t√© ajout√©e au <a href="https://postgrespro.ru/docs/postgrespro/12/ptrack">patch</a> .  PTRACK 2.0 suit les modifications de la page de donn√©es et fournit une interface pour r√©cup√©rer ces informations.  Il peut √™tre utilis√© √† la fois √† des fins de diagnostic, par exemple, pour se faire une id√©e du degr√© de ¬´mutation¬ª de l'instance par rapport √† un moment pr√©cis, d√©fini comme un num√©ro s√©quentiel dans le journal (LSN) et pour cr√©er des sauvegardes incr√©mentielles. <br><br>  En r√®gle g√©n√©rale, la partie la plus difficile et ¬´co√ªteuse¬ª d'une proc√©dure de sauvegarde incr√©mentielle consiste √† isoler un sous-ensemble de pages modifi√©es de l'ensemble des pages d'un cluster.  √âtant donn√© que le serveur peut assumer cette t√¢che et fournir rapidement des informations sur les pages modifi√©es, le temps des sauvegardes incr√©mentielles √† l'aide de PTRACK est consid√©rablement r√©duit. <br><br>  PTRACK 2.0 utilise une table de hachage d'une taille sp√©cifi√©e dans la m√©moire partag√©e, p√©riodiquement synchronis√©e avec le fichier ptrack.map. <br><br>  En raison d'une modification fondamentale du m√©canisme de fonctionnement interne et d'une interface utilisateur incompatible avec les anciennes versions, l'extension ptrack n'est disponible que dans la 12e version de PostgresPro Standard et Enterprise, et sera disponible en tant que correctif et extension sur PostgreSQL 12. <br><br><h3>  Modification des commandes dans psql pour Windows </h3><br>  La prise en charge avanc√©e de la modification des commandes d'entr√©e dans psql pour Windows est impl√©ment√©e √† l'aide de WinEditLine.  Vous pouvez maintenant afficher simultan√©ment les caract√®res de diff√©rents alphabets (en particulier, le cyrillique est normalement affich√© sur les fen√™tres non russes). <br><br><h3>  Structure de package unifi√©e </h3><br><br>  La structure des packages de paquets binaires pour toutes les distributions Linux est unifi√©e afin de simplifier la migration entre eux et de permettre d'installer plusieurs produits diff√©rents bas√©s sur PostgreSQL sans aucun conflit.  Cela peut √™tre trouv√© dans le <a href="https://postgrespro.ru/docs/postgrespro/12/installation-bin">chapitre 16 de la</a> documentation. <br><br>  Maintenant sur les extensions: <br><br><h3>  dump_stat </h3><br>  Il est apparu d√®s 9,5.  Lors du transfert ou de la restauration de donn√©es, les statistiques accumul√©es ne sont g√©n√©ralement pas transf√©r√©es.  Si vous le r√©assemblez avec la commande ANALYSER, il sera ex√©cut√© pour l'ensemble du cluster, et non pour la base de donn√©es sp√©cifi√©e.  Cela peut n√©cessiter beaucoup de temps suppl√©mentaire pour les grandes bases de donn√©es. <br><br>  L'extension dump_stat <a href="https://postgrespro.ru/docs/postgrespro/12/dump-stat">fournit des fonctions</a> qui vous permettent de d√©charger et de restaurer le contenu de la table pg_statistic.  Lorsque vous effectuez un t√©l√©chargement / r√©cup√©ration de donn√©es, vous pouvez utiliser dump_stat pour transf√©rer des statistiques existantes vers un nouveau serveur, sans avoir √† ex√©cuter la commande ANALYSER pour l'ensemble du cluster. <br><br>  La fonction dump_statistic d√©charge le contenu du catalogue syst√®me pg_statistic.  Il produit un INSERT pour chaque tuple dans pg_statistic, √† l'exception de ceux qui contiennent des statistiques sur les tables dans les sch√©mas information_schema et pg_catalog. <br><br><h3>  jsquery </h3><br>  Rappelez-vous qu'il <a href="https://postgrespro.ru/docs/postgrespro/12/jsquery">s'agit d'une extension</a> pour travailler avec JSON (B), pas JS.  Il fournit un ensemble de fonctions pour traiter ces types de donn√©es.  Il s'agit d'un langage de requ√™te sp√©cial pour une recherche efficace, √† l'aide d'index, dans JSON (B).  Dans l' <a href="https://habr.com/ru/company/postgrespro/blog/448612/">article sur le hub,</a> vous pouvez voir quelques exemples de jsquery et d'autres m√©thodes de travail avec JSON (B), par exemple JSONPath (les deux d√©veloppements de notre soci√©t√©). <br><br><h3>  analyse_en ligne </h3><br>  Cette extension <a href="https://postgrespro.ru/docs/postgrespro/12/online-analyze">fournit un</a> ensemble de fonctions qui mettent √† jour imm√©diatement les statistiques dans les tables qui sont sp√©cifi√©es apr√®s les op√©rations INSERT, UPDATE, DELETE ou SELECT INTO qu'elles contiennent.  L'auteur de l'extension est Fedor Sigaev. <br><br>  Pour utiliser le module online_analyze, vous devez charger la biblioth√®que partag√©e: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">LOAD</span></span> <span class="hljs-string"><span class="hljs-string">'online_analyze'</span></span>;</code> </pre> <br><br>  Les mises √† jour des statistiques peuvent √™tre personnalis√©es.  Par exemple, d√©finissez un pourcentage de la taille de la table ou le nombre minimum (seuil) de modifications de ligne, apr√®s quoi les statistiques seront imm√©diatement collect√©es. <br><br><h3>  pg_pathman </h3><br>  L' <a href="https://postgrespro.ru/docs/postgrespro/12/pg-pathman">extension pg_pathman</a> dans Postgres Professional a √©t√© cr√©√©e plus t√¥t que dans le noyau PostgreSQL et a impl√©ment√© un ensemble complet de fonctions assez complet pour cr√©er des partitions.  Par cons√©quent, de nombreuses op√©rations avec des sections peuvent √™tre effectu√©es avec l'un et l'autre m√©canisme.  Il est seulement conseill√© de ne pas m√©langer les sections cr√©√©es par le partitionnement d√©claratif et pg_pathman. <br><br>  Cependant, de nombreuses op√©rations pg_pathman sont encore plus rapides et certaines fonctionnalit√©s manquent dans PostgreSQL.  Par exemple, cr√©ation (d√©coupe) automatique de sections.  Dans PostgreSQL, vous devez d√©finir les limites de chaque section.  Si nous remplissons des donn√©es pour lesquelles on ne sait pas √† l'avance combien de sections elles peuvent et doivent √™tre dispers√©es, il est pratique de simplement d√©finir l'intervalle et de laisser le logiciel couper les sections lui-m√™me - autant que n√©cessaire.  pg_pathman sait comment, PostgreSQL non.  Mais, √† partir de PG 11, il y a une section par d√©faut (par d√©faut), o√π vous pouvez vider tous les enregistrements qui ne tombent pas dans des sections avec des limites sp√©cifi√©es. <br><br>  Il existe un accord de base avec les dirigeants de la communaut√© PostgreSQL qui, √† l'avenir, sera le meilleur, tandis que les fonctionnalit√©s uniques de pg_pathman tomberont dans la branche principale.  Mais jusque-l√†, pg_pathman peut faciliter la vie des administrateurs de bases de donn√©es d'applications et des programmeurs d'applications. <br><br>  Cr√©ez une extension: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_pathman;</code> </pre> <br><br>  pg_pathman vous permet de diviser de grands tableaux en sections et fournit une API pratique - un ensemble de fonctions pour cr√©er des sections et travailler avec elles.  Par exemple, en utilisant la fonction <br><br><pre> <code class="pgsql hljs">create_range_partitions(relation <span class="hljs-type"><span class="hljs-type">REGCLASS</span></span>, expression <span class="hljs-type"><span class="hljs-type">TEXT</span></span>, start_value <span class="hljs-type"><span class="hljs-type">ANYELEMENT</span></span>, p_interval <span class="hljs-type"><span class="hljs-type">INTERVAL</span></span>, p_count <span class="hljs-type"><span class="hljs-type">INTEGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, partition_data <span class="hljs-type"><span class="hljs-type">BOOLEAN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>);</code> </pre> <br>  on peut demander <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_range_partitions(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-string"><span class="hljs-string">'dt'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'1 month'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>);</code> </pre> <br><br>  apr√®s quoi nous ajoutons des sections: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> add_range_partition(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'log_archive'</span></span>, <span class="hljs-string"><span class="hljs-string">'ts0'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> add_range_partition(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-02-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'log_1'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> add_range_partition(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-02-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-03-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span><span class="hljs-string"><span class="hljs-string">', log_2'</span></span>);</code> </pre> <br><br>  Le journal d'archivage sera cr√©√© dans l'espace table ts0, les autres sont par d√©faut.  Mais vous ne pouvez pas sp√©cifier de sections explicitement, mais faites confiance √† cette op√©ration SGBD en d√©finissant l'intervalle et en cr√©ant des sections en une seule √©tape: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_range_partitions(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-string"><span class="hljs-string">'dt'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'1 month'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>);</code> </pre> <br><br>  Sur une table simple, cela ressemblera √† ceci: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> pg_pathmania(id <span class="hljs-type"><span class="hljs-type">serial</span></span>, val <span class="hljs-type"><span class="hljs-type">float</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pg_pathmania(val) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> random() * <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_range_partitions(<span class="hljs-string"><span class="hljs-string">'pg_pathmania'</span></span>, <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>); test_parti=# \d+ pg_pathmania <span class="hljs-keyword"><span class="hljs-keyword">Table</span></span> "public.pg_pathmania" <span class="hljs-keyword"><span class="hljs-keyword">Column</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Collation</span></span> | Nullable | <span class="hljs-keyword"><span class="hljs-keyword">Default</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Storage</span></span> | S tats target | Description <span class="hljs-comment"><span class="hljs-comment">--------+------------------+-----------+----------+-----------------------+---------+------+------ id | integer | | not null | nextval('pg_pathmania_id_seq'::regclass) | plain | | val | double precision | | | | plain | | Child tables: pg_pathmania_1, pg_pathmania_10, pg_pathmania_11, pg_pathmania_12, pg_pathmania_13, pg_pathmania_14, pg_pathmania_15, pg_pathmania_16, pg_pathmania_17, pg_pathmania_18, pg_pathmania_19, pg_pathmania_2, pg_pathmania_20, pg_pathmania_21, pg_pathmania_3, pg_pathmania_4, pg_pathmania_5, pg_pathmania_6, pg_pathmania_7, pg_pathmania_8, pg_pathmania_9</span></span></code> </pre> <br><br>  Dans PostgreSQL, nous devions cr√©er chaque section avec notre propre √©quipe.  Dans de tels cas, bien s√ªr, ils √©crivent un script qui g√©n√®re automatiquement le code DDL requis.  Vous n'avez pas besoin d'√©crire de scripts dans pg_pathman, tout est d√©j√† l√†.  Mais ce n'est pas le plus int√©ressant.  Nous allons ins√©rer un enregistrement qui non seulement n'obtient pas d'ID dans aucune des sections existantes, mais ne tombe pas non plus dans la section la plus proche: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pg_pathmania(id, val) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2000</span></span>, <span class="hljs-number"><span class="hljs-number">277.835794724524</span></span>);</code> </pre> <br><br>  Encore une fois, v√©rifiez le contenu du tableau avec \ d + pg_pathmania: <br><br><pre> <code class="pgsql hljs">Child <span class="hljs-keyword"><span class="hljs-keyword">tables</span></span>: pg_pathmania_1, pg_pathmania_10, ... pg_pathmania_39, pg_pathmania_4, pg_pathmania_40, pg_pathmania_41,</code> </pre> <br><br>  Voici ce qui s'est pass√©: pg_pathman a vu que l'enregistrement avec id = 2000 ne tombe pas dans les sections d√©j√† cr√©√©es, a calcul√© combien elles doivent √™tre cr√©√©es, connaissant l'intervalle RANGE avec lequel la table a √©t√© partitionn√©e auparavant, et a cr√©√© la section o√π tombe le nouvel enregistrement, et, bien s√ªr, toutes les sections entre la limite sup√©rieure des anciennes sections et la limite inf√©rieure de la nouvelle section.  C'est tr√®s pratique, et dans les cas o√π les valeurs du champ de fractionnement des donn√©es mises √† jour sont mal pr√©dites, c'est un s√©rieux avantage de pg_pathman. <br><br><h3>  pg_query_state </h3><br>  Cette extension que nous avons d√©velopp√©e nous <a href="https://postgrespro.ru/docs/postgrespro/12/pg-query-state">permet de conna√Ætre l'</a> √©tat actuel des demandes dans le processus de diffusion.  Il existe depuis la version 9.5 et est d√ª √† la naissance des nombreuses demandes des administrateurs clients. <br><br>  Le fait est que EXPLAIN ANALYZE vous permet d'afficher les statistiques d'ex√©cution collect√©es √† partir de chaque n≈ìud de l'arborescence du plan, mais ces statistiques ne sont collect√©es qu'une fois la requ√™te termin√©e.  Mais dans la vie, h√©las, il y a des situations o√π vous devez regarder ce que la demande n'est pas encore termin√©e et peut-√™tre ne va pas se terminer.  pg_query_state vous permet d'afficher les statistiques actuelles d'une requ√™te ex√©cut√©e dans un processus de maintenance externe.  Dans ce cas, le format de la sortie r√©sultante est presque identique √† la sortie de la commande EXPLAIN ANALYZE habituelle. <br><br>  Utilitaires: <br><br><h3>  pgBouncer </h3><br>  <a href="http://www.pgbouncer.org/">Il s'agit d'</a> un <a href="https://postgrespro.ru/docs/postgrespro/12/pgbouncer">extracteur de connexion</a> si <a href="https://postgrespro.ru/docs/postgrespro/12/pgbouncer">populaire</a> qu'il serait √©trange d'en parler ici.  C'est juste qu'il fait partie de Standard, et il devra √™tre install√© s√©par√©ment dans le cas de vanilla PostgreSQL. <br><br><h3>  pg_probackup </h3><br>  <a href="https://postgrespro.ru/docs/postgrespro/12/app-pgprobackup">pg_probackup</a> est l'un de nos d√©veloppements les plus populaires.  Il s'agit d'un gestionnaire de sauvegarde et de r√©cup√©ration d√©velopp√© et mis √† jour principalement par Anastasia Lubennikova, Grigory Smolkin et la communaut√© des utilisateurs. <br><br>  Avantages comp√©titifs de pg_probackup: sauvegarde incr√©mentielle avec granularit√© de bloc (8 Ko), trois modes de sauvegarde incr√©mentielle (PAGE, DELTA, PTRACK), v√©rification d'int√©grit√© de la sauvegarde √† la demande, v√©rification de cluster PostgreSQL, compression de sauvegarde, r√©cup√©ration partielle, etc. <br><br>  Le mode de copie incr√©mentielle PTRACK, reposant sur <a href="https://postgrespro.ru/docs/postgrespro/12/ptrack">l'extension du m√™me nom</a> dans le cadre du m√©canisme repens√© - PTRACK 2.0 - est devenu encore plus rapide et est d√©sormais sans √©quivoque le plus rapide et le moins cher des modes pg_probackup. <br><br><h3>  pg_repack </h3><br>  <a href="https://postgrespro.ru/docs/postgrespro/12/app-pgrepack">pg_repack est un</a> utilitaire populaire, son fonctionnement est similaire √† VACUUM FULL ou <a href="https://postgrespro.ru/docs/postgrespro/12/sql-cluster">CLUSTER</a> .  Il reconditionne non seulement les tables, supprimant les vides, mais sait √©galement comment restaurer l'ordre physique des index clusteris√©s.  Contrairement √† CLUSTER et VACUUM FULL, il effectue ces op√©rations ¬´en d√©placement¬ª, sans verrous de table exclusifs et fonctionne g√©n√©ralement efficacement.  Il n'est pas inclus dans la version vanille. <br><br><h3>  pg_variables </h3><br>  √Ä propos de cette extension sur un habr il y a un <a href="https://habr.com/ru/company/postgrespro/blog/302200/">article</a> int√©ressant <a href="https://habr.com/ru/company/postgrespro/blog/302200/">de</a> notre employ√© Ivan Frolkov.  La raison de l'extension est que travailler avec des r√©sultats interm√©diaires est parfois g√™nant et co√ªteux.  L'article explore des alternatives.  Les plus courants sont les tables temporaires. <br><br>  En tant qu'entrep√¥t de donn√©es temporaire, l'extension pg_variables est beaucoup plus productive que les tables temporaires (les tests pgbench sont dans l'article), et c'est plus pratique: l'ensemble de donn√©es est d√©fini par une paire ¬´package - variable¬ª, qui peut √™tre pass√©e en tant que param√®tres, renvoy√©e par une fonction, etc. Il existe des fonctions set / get pour travailler avec des variables.  Ainsi, par exemple, vous pouvez stocker de nombreuses variables (package est le nom du package, et l'expression apr√®s la virgule d√©cimale est les variables de ce package: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pgv_set_int(<span class="hljs-string"><span class="hljs-string">'package'</span></span>,<span class="hljs-string"><span class="hljs-string">'#'</span></span>||n,n), n <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> gs(n);</code> </pre> <br><br>  Les variables ont une propri√©t√© int√©ressante: pas un bug ou un avantage, mais une fonctionnalit√©: les donn√©es stock√©es par le moyen d'extension existent en dehors des transactions - elles sont enregistr√©es √† la fois en cas de fixation d'une transaction et en cas de retour en arri√®re;  De plus, m√™me lors de l'ex√©cution d'une commande distincte, des donn√©es partielles peuvent √™tre obtenues: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pgv_insert(<span class="hljs-string"><span class="hljs-string">'package'</span></span>, <span class="hljs-string"><span class="hljs-string">'errs'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>(n)) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> gs(n) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span>/(n<span class="hljs-number"><span class="hljs-number">-3</span></span>)&lt;&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>; ERROR: there <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a <span class="hljs-type"><span class="hljs-type">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the variable "errs" <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> same key test_parti=# <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgv_select(<span class="hljs-string"><span class="hljs-string">'package'</span></span>,<span class="hljs-string"><span class="hljs-string">'errs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> r(i <span class="hljs-type"><span class="hljs-type">int</span></span>); i <span class="hljs-comment"><span class="hljs-comment">--- 1 2 (2 rows)</span></span></code> </pre> <br><br>  D'une part, cela n'est pas tr√®s pratique - dans certains cas, il est n√©cessaire de pr√©voir la suppression de donn√©es saisies incorrectement, mais dans d'autres, cela peut s'av√©rer tr√®s utile - par exemple, enregistrer certaines donn√©es m√™me en cas de retour en arri√®re d'une transaction.  La <a href="https://github.com/postgrespro/pg_variables">documentation</a> contient des d√©tails. <br><br>  En conclusion, quelques extensions suppl√©mentaires: <br><br><h3>  sr_plan, plantuner </h3><br>  <b>sr_plan</b> <a href="https://postgrespro.ru/docs/postgrespro/12/sr-plan">enregistre et restaure</a> les plans de requ√™te.  Incluez-le comme ceci: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> sr_plan.write_mode = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;</code> </pre> <br><br>  Apr√®s cela, les plans de toutes les requ√™tes suivantes seront stock√©s dans la table sr_plans jusqu'√† ce que cette variable soit d√©finie sur false.  Les plans de toutes les demandes, y compris les demandes r√©p√©t√©es, sont enregistr√©s. <br><br>  <b>plantuner</b> <a href="https://postgrespro.ru/docs/postgrespro/12/plantuner">prend en charge les</a> indications permettant au planificateur de connecter ou de d√©connecter les index sp√©cifi√©s lors de l'ex√©cution d'une requ√™te.  Il n'y a que deux variables GUC: enable_index / desable_index: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> plantuner.disable_index=<span class="hljs-string"><span class="hljs-string">'id_idx2'</span></span>;</code> </pre> <br><br><h3>  Extensions pour la recherche en texte int√©gral: shared_ispell, pg_tsparser </h3><br>  L'extension shared_ispell, qui vous permet de placer des <a href="https://postgrespro.ru/docs/postgrespro/12/hunspell-dict">dictionnaires</a> en m√©moire partag√©e, est en Standard et non en PostgreSQL.  Notre ensemble hunspell-dict a des dictionnaires pour les langues: <br><br><ul><li>  hunspell_en_us, </li><li>  hunspell_fr, </li><li>  hunspell_nl_nl, </li><li>  hunspell_ru_ru </li></ul><br><br>  L' <b>extension pg_tsparser</b> est <a href="https://postgrespro.ru/docs/postgrespro/12/pg-tsparser">un analyseur de</a> recherche de texte <a href="https://postgrespro.ru/docs/postgrespro/12/pg-tsparser">alternatif</a> .  Cette extension modifie la strat√©gie d'analyse de texte standard pour les mots comprenant des traits de soulignement, ainsi que les chiffres et les lettres s√©par√©s par des traits de soulignement.  En plus des parties individuelles du mot renvoy√© par d√©faut, pg_tsparser renvoie √©galement le mot entier.  Ceci est tr√®s important pour la documentation technique ou les articles comme celui-ci, dans lesquels se trouve le code du programme, et il contient des mots comme "pg_tsparser", "pg_probackup", "jsonb_build_object".  Cet analyseur per√ßoit ces mots non seulement comme un ensemble de composants, mais √©galement comme un seul jeton, et am√©liore ainsi la qualit√© de la recherche. <br><br><h3>  Extensions pour 1C </h3><br><ul><li>  <b><a href="https://postgrespro.ru/docs/postgrespro/12/mchar">mchar</a></b> est un type de donn√©es facultatif pour la compatibilit√© avec Microsoft SQL Server; </li><li>  <b><a href="https://postgrespro.ru/docs/postgrespro/12/fulleq">fulleq</a></b> - fournit un op√©rateur d'√©galit√© suppl√©mentaire pour la compatibilit√© avec Microsoft SQL Server; </li><li> <b><a href="https://postgrespro.ru/docs/postgrespro/12/fasttrun">fasttrun</a></b> ‚Äî  -     ,     pg_class. </li></ul><br><br>      ,    PostgresPro Standard  PostgreSQL.   ,     , , , <a href="https://postgrespro.ru/docs/postgrespro/12/index">  </a> . <br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479618/">https://habr.com/ru/post/fr479618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479590/index.html">Top 10 des soci√©t√©s de d√©veloppement d'applications en 2020</a></li>
<li><a href="../fr479592/index.html">Comment atteindre vos objectifs?</a></li>
<li><a href="../fr479598/index.html">Chat et chien nourrissent le robot</a></li>
<li><a href="../fr479600/index.html">Une autre DSL pour les validations</a></li>
<li><a href="../fr479602/index.html">Qu'est-ce que le g√©nome complet et pourquoi est-il n√©cessaire</a></li>
<li><a href="../fr479620/index.html">Logique inverse</a></li>
<li><a href="../fr479622/index.html">Fonctionnement du prototype de transactions anonymes sur la blockchain Waves</a></li>
<li><a href="../fr479624/index.html">Le gendar professionnel de Postgres, Oleg Bartunov, explique √† Faride Roslovets √† propos de PostgreSQL et des affaires en Russie</a></li>
<li><a href="../fr479626/index.html">R√©sonateur avec une torsion que les physiciens ne connaissent pas</a></li>
<li><a href="../fr479630/index.html">Battez-vous pour attirer l'attention</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>