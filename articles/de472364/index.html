<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏷️ 🍶 💔 PostgreSQL- und Datensatzkonsistenzeinstellungen für jede bestimmte Verbindung 👨🏿 👩🏾‍🚒 👨‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Übersetzung des Artikels wurde speziell für Studenten des Kurses "Datenbank" vorbereitet. Ist es interessant, sich in diese Richtung zu entwickeln...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL- und Datensatzkonsistenzeinstellungen für jede bestimmte Verbindung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/472364/"><p>  <em>Die Übersetzung des Artikels wurde speziell für Studenten des Kurses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Datenbank"</a> vorbereitet.</em>  <em>Ist es interessant, sich in diese Richtung zu entwickeln?</em>  <em>Wir laden Sie zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tag der offenen Tür ein</a> , an dem wir ausführlich über das Programm, die Merkmale des Online-Formats, die Kompetenzen und die Karriereaussichten sprechen, die die Absolventen nach der Ausbildung erwarten.</em> </p><br><p><img src="https://habrastorage.org/webt/gf/iy/te/gfiyteycddmeefan9z5h1nxdgu0.png"></p><br><p>  PostgreSQL- und Datensatzkonsistenzeinstellungen für jede bestimmte Verbindung <br>  Bei Compose müssen wir uns mit vielen Datenbanken auseinandersetzen, was uns die Möglichkeit gibt, mehr über deren Funktionalität und Nachteile zu erfahren.  Wenn wir lernen, die Funktionsmerkmale neuer Datenbanken zu lieben, denken wir manchmal darüber nach, wie gut es wäre, wenn ähnliche Funktionen in ausgereifteren Tools vorhanden wären, mit denen wir schon lange arbeiten.  Eine der neuen Funktionen, die PostgreSQL sehen wollte, war die benutzerdefinierte Schreibkonsistenz im gesamten Cluster.  Und wie sich herausstellte, haben wir es bereits und heute möchten wir Ihnen Informationen darüber mitteilen, wie Sie es verwenden können. <a name="habracut"></a></p><br><h1 id="zachem-mne-eto">  Wozu brauche ich das? </h1><br><p>  Wie sich ein Cluster verhalten soll, hängt von Ihrer Anwendung ab.  Nehmen Sie zum Beispiel einen Antrag auf Bezahlung von Rechnungen.  Sie benötigen eine 100% ige Konsistenz im Cluster, daher müssen Sie synchrone Commits aktivieren, damit Ihre Datenbank auf alle Änderungen wartet.  Wenn es sich bei Ihrer Anwendung jedoch um ein schnell wachsendes soziales Netzwerk handelt, bevorzugen Sie wahrscheinlich eine 100% ige Konsistenz mit einer schnellen Antwort.  Um dies zu erreichen, können Sie asynchrone Commits in Ihrem Cluster verwenden. </p><br><h2 id="znakomtes-kompromiss">  Treffen Sie den Kompromiss </h2><br><p>  Sie müssen Kompromisse zwischen Datenkonsistenz und Leistung eingehen.  PostgreSQL geht von der Konsistenz aus, da die Standardkonfiguration in diesem Fall vorhersehbar und ohne unerwartete Überraschungen ist.  Und jetzt werden wir uns mit Kompromissen vertraut machen. </p><br><h3 id="kompromiss-1-proizvoditelnost">  Kompromiss 1: Leistung </h3><br><p>  Wenn der PostgreSQL-Cluster keine Konsistenz erfordert, funktioniert er möglicherweise asynchron.  Die Aufzeichnung erfolgt an den Clusterleiter, und nach einigen Millisekunden werden Aktualisierungen an seine Replikate gesendet.  Wenn für einen PostgreSQL-Cluster Konsistenz erforderlich ist, sollte diese synchron funktionieren.  Der Datensatz wird im Leiter des Clusters erstellt, der Aktualisierungen an die Replikate sendet und auf die Bestätigung wartet, dass alle den Datensatz erstellt haben, bevor eine Bestätigung an den Client gesendet wird, der den Datensatz initiiert hat, dass er erfolgreich war.  Der praktische Unterschied zwischen diesen Ansätzen besteht darin, dass das asynchrone Verfahren zwei Netzwerksprünge erfordert, während das synchrone Verfahren vier erfordert. </p><br><h3 id="kompromiss-2-soglasovannost">  Kompromiss 2: Konsistenz </h3><br><p>  Das Ergebnis im Falle einer Fehlfunktion eines Leiters bei diesen beiden Ansätzen ist ebenfalls unterschiedlich.  Wenn die Arbeit asynchron ausgeführt wird, werden bei Auftreten eines solchen Fehlers nicht alle Datensätze von Replikaten festgeschrieben.  Wie viel wird verloren gehen?  Hängt von der Anwendung selbst und der Replikationseffizienz ab.  Durch die Compose-Replikation wird verhindert, dass das Replikat zum Leader wird, wenn die darin enthaltene Informationsmenge 1 MB geringer ist als im Leader, dh bis zu 1 MB Datensätze können möglicherweise während des asynchronen Betriebs verloren gehen. </p><br><p> Im synchronen Modus geschieht dies nicht.  Wenn der Leader ausfällt, werden alle Replikate aktualisiert, da alle auf dem Leader bestätigten Datensätze in den Replikaten bestätigt werden müssen.  Hier ist es - Kohärenz. </p><br><p>  Es ist sinnvoll, synchrones Verhalten in einer Anwendung zum Bezahlen von Rechnungen zu verwenden, wobei Konsistenz einen klaren Vorteil darin hat, einen Kompromiss zwischen Konsistenz und Leistung zu finden.  Das Wichtigste für eine solche Anwendung sind gültige Daten.  Denken Sie jetzt an das soziale Netzwerk, in dem die Hauptaufgabe darin besteht, die Aufmerksamkeit des Benutzers zu erhalten und auf Anfragen so schnell wie möglich zu reagieren.  In diesem Fall hat die Leistung mit weniger Netzwerksprüngen und weniger Wartezeiten Priorität.  Der Kompromiss zwischen Leistung und Konsistenz ist jedoch nicht der einzige, über den man nachdenken muss. </p><br><h3 id="kompromiss-3-sboi">  Kompromiss 3: Fehler </h3><br><p>  Es ist sehr wichtig zu verstehen, wie sich der Cluster während eines Fehlers verhält.  Stellen Sie sich eine Situation vor, in der ein oder mehrere Replikate fehlschlagen.  Wenn Commits asynchron verarbeitet werden, funktioniert der Leader weiterhin, dh er empfängt und verarbeitet Datensätze, ohne auf fehlende Replikate zu warten.  Wenn die Replikate zum Cluster zurückkehren, holen sie den Anführer ein.  Wenn bei der synchronen Replikation die Replikate nicht antworten, hat der Leiter keine Wahl und wartet weiterhin auf die Bestätigung des Commits, bis das Replikat zum Cluster zurückkehrt und den Datensatz akzeptieren und bestätigen kann. </p><br><h2 id="po-odnomu-soedineniyu-na-tranzakciyu">  Eine Verbindung pro Transaktion? </h2><br><p>  Jede Anwendung benötigt eine spezielle Kombination aus Konsistenz und Leistung.  Es sei denn natürlich, es handelt sich um unsere Abrechnungsanwendung, die wir für vollständig konsistent halten, oder um unsere fast kurzlebige Anwendung für soziale Netzwerke.  In allen anderen Fällen kann es vorkommen, dass einige Vorgänge synchron und andere asynchron sein müssen.  Möglicherweise möchten Sie nicht, dass das System darauf wartet, dass die an den Chat gesendete Nachricht geschlossen wird. Wenn die Zahlung jedoch in derselben Anwendung erfolgt, müssen Sie warten. </p><br><p>  Alle diese Entscheidungen werden natürlich vom Anwendungsentwickler getroffen.  Die richtigen Entscheidungen darüber, wann dieser oder jener Ansatz angewendet werden soll, helfen dabei, das Beste aus dem Cluster herauszuholen.  Es ist wichtig, dass der Entwickler auf SQL-Ebene für Verbindungen und Transaktionen zwischen ihnen wechseln kann. </p><br><h2 id="obespechenie-kontrolya-na-praktike">  Kontrolle in der Praxis </h2><br><p> Standardmäßig bietet PostgreSQL Konsistenz.  Dies wird durch den <code>synchronous_commit</code> gesteuert.  Standardmäßig ist es aktiviert, es stehen jedoch drei weitere Optionen zur Verfügung: <code>local</code> , <code>remote_write</code> oder <code>off</code> . </p><br><p>  Wenn der Parameter ausgeschaltet ist, werden alle synchronen Festschreibungen auch im lokalen System gestoppt.  Der Parameter in local bestimmt den Synchronmodus für das lokale System, Schreibvorgänge in Replikate sind jedoch asynchron.  <code>Remote_write</code> geht noch weiter: Schreibvorgänge in Replikate werden asynchron ausgeführt, aber zurückgegeben, wenn das Replikat den Datensatz akzeptiert, ihn aber nicht auf die Festplatte geschrieben hat. </p><br><p>  In Anbetracht der verfügbaren Optionen wählen wir das Verhalten aus. Wenn wir uns daran erinnern, dass es sich um synchrone Datensätze handelt, wählen wir <code>local</code> für asynchrone Festschreibungen über das Netzwerk aus, während lokale Festschreibungen synchron bleiben. </p><br><p>  Jetzt werden wir Ihnen gleich erklären, wie Sie dies konfigurieren. Stellen Sie sich jedoch vor, wir setzen <code>synchronous_commit</code> für den Server auf <code>local</code> .  Wir haben uns gefragt, ob es möglich ist, den Parameter <code>synchronous_commit</code> laufenden Betrieb zu ändern, und es hat sich herausgestellt, dass dies nicht nur möglich ist, sondern es gibt sogar zwei Möglichkeiten, dies zu tun.  Die erste besteht darin, Ihre Verbindungssitzung wie folgt einzurichten: </p><br><pre> <code class="plaintext hljs">SET SESSION synchronous_commit TO ON; // Your writes go here</code> </pre> <br><p>  Alle nachfolgenden Datensätze in der Sitzung bestätigen die Schreibvorgänge für die Replikate, bevor ein positives Ergebnis an den verbundenen Client zurückgegeben wird.  Es sei denn, Sie ändern die Einstellung <code>synchronous_commit</code> erneut.  Sie können den <code>SESSION</code> Teil des Befehls weglassen, da er den Standardwert hat. </p><br><p>  Der zweite Weg ist gut, wenn Sie nur sicherstellen möchten, dass Sie eine synchrone Replikation für eine einzelne Transaktion erhalten.  In vielen NoSQL-Datenbanken existiert das Konzept von Transaktionen nicht, aber es existiert in PostgreSQL.  In diesem Fall starten Sie die Transaktion und setzen <code>synchronous_commit</code> auf <code>on</code> bevor Sie in die Transaktion schreiben.  <code>COMMIT</code> die Transaktion mit einem beliebigen Wert des zu diesem Zeitpunkt festgelegten Parameters <code>synchronous_commit</code> Es ist jedoch am besten, die Variable im Voraus festzulegen, um sicherzustellen, dass andere Entwickler verstehen, dass die Datensätze nicht asynchron sind. </p><br><pre> <code class="plaintext hljs">BEGIN; SET LOCAL synchronous_commit TO ON; // Your writes go here COMMIT;</code> </pre> <br><p>  Alle Transaktions-Commits werden jetzt als in die Replikate geschrieben bestätigt, noch bevor die Datenbank eine positive Antwort an den verbundenen Client zurückgibt. </p><br><h2 id="nastroyka-postgresql">  PostgreSQL-Setup </h2><br><p>  Zuvor hatten wir uns ein PostgreSQL-System vorgestellt, bei dem <code>synchronous_commit</code> auf <code>local</code> .  Um dies auf der Serverseite zu realisieren, müssen Sie zwei Serverkonfigurationsparameter festlegen.  Ein weiterer <code>synchronous_standby_names</code> Parameter übernimmt, wenn <code>synchronous_commit</code> ist.  Es bestimmt, welche Replikate für synchrone Commits geeignet sind, und wir setzen es auf <code>*</code> , was bedeutet, dass alle Replikate aktiviert sind.  Diese Werte werden normalerweise in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konfigurationsdatei konfiguriert,</a> indem Folgendes hinzugefügt wird: </p><br><pre> <code class="plaintext hljs">synchronous_commit = local synchronous_standby_names='*'</code> </pre> <br><p>  Indem Sie den Parameter <code>synchronous_commit</code> auf <code>local</code> , erstellen wir ein System, in dem lokale Laufwerke synchron bleiben, Netzwerk-Replikat-Commits jedoch standardmäßig asynchron sind.  Es sei denn, wir beschließen natürlich, diese Commits wie oben gezeigt synchron zu machen. </p><br><p>  Wenn Sie die Entwicklung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">des Governor-Projekts verfolgt haben</a> , haben Sie möglicherweise einige kürzlich vorgenommene Änderungen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> ) festgestellt, mit denen Governor-Benutzer diese Parameter testen und ihre Konsistenz kontrollieren konnten. </p><br><h2 id="esche-para-slov">  Noch ein paar Worte ... </h2><br><p>  Noch vor einer Woche würde ich Ihnen sagen, dass es nicht möglich ist, PostgreSQL so fein abzustimmen.  Zu diesem Zeitpunkt bestand Kurt, ein Mitglied des Compose-Plattformteams, darauf, dass es eine solche Gelegenheit gab.  Er beruhigte meine Einwände und fand <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Folgendes</a> in der PostgreSQL-Dokumentation: </p><br><p><img src="https://habrastorage.org/webt/yu/-p/qn/yu-pqnp2g5_ipnofxejmnmkc_uq.png"></p><br><p>  <em>Dieser Parameter kann jederzeit geändert werden.</em>  <em>Das Verhalten für jede Transaktion wird durch die Einstellung bestimmt, die beim Festschreiben wirksam wird.</em>  <em>Daher ist es möglich und nützlich, dass Commits für einige Transaktionen synchron und für andere asynchron festgeschrieben werden.</em>  <em>Um beispielsweise zu erzwingen, dass eine einzelne Transaktion mit mehreren Anweisungen asynchron <code>multistatement</code> wird, wenn der Standardwert des Parameters umgekehrt ist, setzen Sie</em> <code>SET LOCAL synchronous_commit TO OFF</code> <em>in der Transaktion auf</em> <code>SET LOCAL synchronous_commit TO OFF</code> <em>.</em> </p><br><p>  Mit dieser kleinen Änderung in der Konfigurationsdatei haben wir den Benutzern die Möglichkeit gegeben, ihre Konsistenz und Leistung zu steuern. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472364/">https://habr.com/ru/post/de472364/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472354/index.html">Zwischen dem Stuhl und dem Monitor befindet sich die Hauptschwachstelle im System: VAP-Person</a></li>
<li><a href="../de472356/index.html">Microsoft vs IBM: Wichtige Änderungen in der Java-Unterstützung</a></li>
<li><a href="../de472358/index.html">30. Oktober um 17:00 Uhr Webinar „Bereitstellen des Kubernetes-Clusters in einer Stunde in der CROC-Cloud“</a></li>
<li><a href="../de472360/index.html">Scannen des Codes von Orchard CMS auf Fehler</a></li>
<li><a href="../de472362/index.html">Wir suchen und analysieren Fehler im Orchard CMS-Code</a></li>
<li><a href="../de472366/index.html">Neuer Pfadfinder-Algorithmus in Factorio</a></li>
<li><a href="../de472368/index.html">Sprachfischen: Wir analysieren Angriffsmethoden und Schutzmethoden gegen sie</a></li>
<li><a href="../de472372/index.html">Android-Automatisierung Super einfache Anleitung zum Erstellen Ihres ersten Espresso-Tests</a></li>
<li><a href="../de472374/index.html">Warum wir Server nach Island verlegt haben</a></li>
<li><a href="../de472378/index.html">Flash-Zuverlässigkeit: erwartet und unerwartet. Teil 2. XIV. Konferenz der USENIX Association. Dateispeichertechnologien</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>