<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🔬 🙌🏿 🧑🏾‍🤝‍🧑🏽 Java中的数据结构。 有用的助手类方法 👨 🕓 👨‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈ha！ 

 我是EPAM的软件工程师。 八年来，我一直在使用用Java编写的遗留代码（预期注释，我注意到对遗留的理解和容忍早在EPAM之前就开始了，总之，您将找到原因的答案）。 在工作中，我经常遇到相同的重复缺陷。 这促使我写了一个笔记，我想从数据结构和助手类Collections和Arrays...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java中的数据结构。 有用的助手类方法</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/epam_systems/blog/476098/"> 哈ha！ <br><br> 我是EPAM的软件工程师。 八年来，我一直在使用用Java编写的遗留代码（预期注释，我注意到对遗留的理解和容忍早在EPAM之前就开始了，总之，您将找到原因的答案）。 在工作中，我经常遇到相同的重复缺陷。 这促使我写了一个笔记，我想从数据结构和助手类<em>Collections</em>和<em>Arrays开始</em> 。 由于某些原因，一些开发人员忽略了它们的使用，但徒劳无功 <br><br>  Java开发人员通常必须处理各种数据结构。 它可以是数组，各种<em>Map</em>的集合或实现。 似乎与它们有关的一切都是清晰易懂的，但是有些小事情很容易被发现。 <br><br> 对于不了解这些细微差别的初学者和可能忘记其中一些细节的有经验的开发人员而言，本笔记可能很有用。 <br><br><img src="https://habrastorage.org/webt/5h/9_/k5/5h9_k5vuwkzxsydyntq7eb8yrf4.jpeg" alt="图片"><br>  <sup>照片由ammiel jr在Unsplash上​​拍摄</sup> <br><br><h1> 猫 </h1><br> 我想马上保留一下该材料与Java 8相关的内容。很明显，在Java 9+中某些事情已经做得更好，但是大多数大型项目最经常使用Java 8（有时是Java 6）的版本。 <br><a name="habracut"></a><br><h2> 获取基于数组的集合的最佳方法是什么？ </h2><br> 我建议从基于数组的集合的形成开始。 <br><br> 通常，此方法发生： <br><br><pre><code class="java hljs">Integer[] someArray = {<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>}; List&lt;Integer&gt; list = Arrays.asList(someArray);</code> </pre> <br> 当然可以，但是一切正常吗？ 还有其他解决方案吗？ <br><br> 立即想到此方法的两个缺点： <br><br><ul><li> 首先， <em>Arrays.asList</em>方法返回一个<em>List</em> 。 但是，如果我们需要<em>Collection的</em>另一个实现<em>怎么办？</em>  <em>Arrays.asList</em>不允许这样做，但可以考虑其他方法。 </li><li> 其次，通过调用<em>Arrays.asList</em>获得的<em>List</em>不支持调整大小。 我认为许多人都提出了处理此类清单的例外。 </li></ul><br> 在<em>Collections</em>接口上，可以找到<em>Arrays.asList</em>方法的替代方法<em>-Collections.addAll</em>方法。 使用方法如下： <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      (List, Set, ...) Collection&lt;Integer&gt; collection = ...; Integer[] someArray = {9, 10, 8, 7}; Collections.addAll(collection, someArray);</span></span></code> </pre><br> 或者简单地： <br><br><pre> <code class="java hljs">Collections.addAll(collection, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>);</code> </pre><br>  <em>Collections.addAll</em>方法在输入处接受<em>Collection</em>对象和一个数组。 除了数组，还可以指定用逗号分隔的元素。 <br><br> 与<em>Arrays.asList相比</em> ， <em>Collections.addAll</em>有什么好处？ <br><br><ul><li> 首先，在基于<em>Collections.addAll</em>数组创建集合时，它的工作速度比使用<em>Arrays.asList</em>输入的集合的<em>addAll</em>方法要快得多。 可以在此方法的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JavaDoc中</a>找到： <br><blockquote> 此便捷方法的行为与c.addAll（Arrays.asList（elements））的行为相同，但是在大多数情况下，此方法的运行速度可能明显更快。 </blockquote></li><li> 此外， <em>Collections.addAll</em>不仅适用于<em>List</em> ，而且适用于任何其他收藏。 </li><li> 使用此方法时，没有大小调整的问题。 </li></ul><br><h2> 打印数组，多维数组或集合的最简单方法是什么？ </h2><br> 让我们继续讨论获取数组和集合的打印表示形式的问题。 <br><br> 如果我们仅制作<em>System.out.println（someArray）</em> ，我们将得到如下内容： <br>  <em>[Ljava.lang.Integer; @ 6d06d69c。</em> <br> 在数组上使用<em>toString（）</em>方法时，预期会得到类似的结果。 <br> 要输出数组，请使用<em>Arrays.toString（...）</em>方法。 <br><br><pre> <code class="java hljs">Integer[] someArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer[]{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; System.out.println(Arrays.toString(someArray));</code> </pre><br> 该行的输出为： <br><br><pre> [1,2,3] 
</pre><br> 如果我们在谈论多维数组，则可以使用方法： <em>Arrays.deeptoString</em> 。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] a = { {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>} }; System.out.println(Arrays.deepToString(a));</code> </pre><br> 该代码段的输出将是： <br><br><pre>  [[1、2、3]，[4、5、6]] </pre><br><br> 因此，没有必要通过任何循环手动对数组进行排序以显示其元素；使用此方法就足够了。 <br><br> 至于<em>Map的</em>集合或实现，没有问题。 通常会输出除数组以外的所有数据结构。 <br><br> 假设有一个例子： <br><br><pre> <code class="java hljs">Collection&lt;Integer&gt; someCollection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;&gt;(); someCollection.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); someCollection.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); System.out.println(someCollection); Map&lt;Integer, String&gt; someMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); someMap.put(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"Some 1"</span></span>); someMap.put(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"Some 2"</span></span>); System.out.println(someMap);</code> </pre><br> 请注意，在下面的输出中，集合和<em>地图</em>均以易于阅读的格式显示： <br><br><pre> [1，2] 
 {1 =大约1，2 =大约2} 
</pre><br><br><h2> 相互比较数组有多容易？ </h2><br> 在某些情况下，您需要比较数组。  <em>Arrays</em>类中有一个方法可以进行这种比较。  <em>Arrays.equals</em>方法比较元素数并检查相应元素的等效性。 <br><br> 假设我们有一个<em>Element</em>类，其中包含一个字段并具有一定的相等性 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Element</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; Element element = (Element) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.equals(name, element.name); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.hash(name); } }</code> </pre><br> 定义三个数组： <br><br><pre> <code class="java hljs">Element[] firstElementArray = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"a"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"b"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"c"</span></span>) }; Element[] secondElementArray = {<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"c"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"b"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"a"</span></span>) }; Element[] thirdElementArray = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"a"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"b"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"c"</span></span>) };</code> </pre><br> 请注意，第一和第三数组的元素顺序相同。 <br> 现在，您可以使用<em>Arrays.equals</em>方法执行比较。 <br><br><pre> <code class="java hljs">System.out.println(<span class="hljs-string"><span class="hljs-string">"first equals to second? "</span></span> + Arrays.equals(firstElementArray, secondElementArray)); System.out.println(<span class="hljs-string"><span class="hljs-string">"second equals to third? "</span></span> + Arrays.equals(secondElementArray, thirdElementArray)); System.out.println(<span class="hljs-string"><span class="hljs-string">"first equals to third? "</span></span> + Arrays.equals(firstElementArray, thirdElementArray));</code> </pre><br> 结果如下： <br><br><pre>第一等于第二？ 错误的 
第二等于第三？ 错误的 
第一等于第三？ 是真的 
</pre><br><br><h2> 如何有效地复制数组？ </h2><br> 通常，您可以在代码中看到使用循环手动复制数组。 但是，有一个<em>System.arraycopy</em>方法可以更快地复制。 <br><br> 我建议看一个简单的例子： <br><br><pre> <code class="java hljs">Element[] elements = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"a"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"b"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"c"</span></span>) }; Element[] copyOfElements = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element[elements.length]; System.arraycopy(elements, <span class="hljs-number"><span class="hljs-number">0</span></span>, copyOfElements, <span class="hljs-number"><span class="hljs-number">0</span></span>, elements.length); System.out.println(Arrays.toString(copyOfElements));</code> </pre><br> 我们有一系列元素。 我们创建一个长度相同的空数组，并将所有元素从第一个复制到第二个。 结果，我们得出以下结论： <br><br><pre> [元素{name ='a'}，元素{name ='b'}，元素{name ='c'}] 
</pre><br><br><h2> 如何以不同的方式对数组或集合进行排序？ </h2><br> 可以使用<em>Arrays.sort（someArray）</em>方法对数组进行排序。 如果要以相反的顺序对数组进行排序，则可以将<em>Collections.reverseOrder（）</em>作为第二个参数传递给此方法的输入。 <br><br> 例如，有一个数组，我们先按顺序然后按相反顺序排序： <br><br><pre> <code class="java hljs">String[] someArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String[]{<span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>}; Arrays.sort(someArray); System.out.println(Arrays.toString(someArray)); Arrays.sort(someArray, Collections.reverseOrder()); System.out.println(Arrays.toString(someArray));</code> </pre><br> 结论如下： <br><br><pre> [a，b，c] 
 [c，b，a] 
</pre><br><br> 除了直接和反向排序外，有时还需要不管大小写对字符串数组进行排序。 通过将<em>String.CASE_INSENSITIVE_ORDER</em>作为第二个参数传递给<em>Arrays.sort，</em>很容易做到这一点。 <br><br> 不幸的是， <em>Collections.sort</em>仅允许对<em>List</em>实现进行排序。 <br><br><h2> 什么算法对Java进行排序？ </h2><br> 在Java中谈论排序时要提到的最后一件事是在Java中，“简单排序”用于最简单的类型，而“稳定合并”用于对象。 因此，在探查器表明有必要之前，您不应该花费资源来开发自己的排序方法实现。 <br><br><h2> 如果我们有一个数组并且该方法接受Iterable怎么办？ </h2><br> 我现在建议继续讨论这样一个问题，即将数组传递给需要<em>Iterable的方法</em> 。 让我提醒您， <em>Iterable</em>是一个包含<em>iterator（）</em>方法的接口，Iterator应该返回该方法。 <br><br> 如果有一个在输入处接受Iterable的方法，则无法像这样将数组转移到那里。 尽管您可以在<em>for</em>循环中遍历数组，但它不是<em>Iterable</em> 。 <br><br><pre> <code class="java hljs">String[] someArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String[]{<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String currentString : someArray) { ... }</code> </pre><br> 在此示例中，一切都很好。 但是如果有一种方法： <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someIteration</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;String&gt; iterable)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre><br> 该行将无法编译： <br><br><pre> <code class="java hljs">someIteration(someArray);</code> </pre><br> 在这种情况下，唯一的解决方法是将数组转换为集合，并已将其提供给这种方法。 <br><br><h2> 简要介绍一些有用的Collections方法 </h2><br><div class="scrollable-table"><table><tbody><tr><th> 方法 </th><th> 评注 </th></tr><tr><td>  <em>最大（集合）</em>和<em>最大（集合，比较器）</em> <br>  <em>min（集合）</em>和<em>min（集合，比较器）</em> <br></td><td> 请注意，您可以申请<em>比较器</em>的输入 <br></td></tr><tr><td>  <em>indexOfSubList（列表，列表）</em> <br></td><td> 查找一个列表（第二个参数）在另一个列表（第一个参数）中第一次出现的索引 <br></td></tr><tr><td>  <em>lastIndexOfSubList（列表，列表）</em> <br></td><td> 查找一个列表（第二个参数）在另一个列表（第一个参数）中最后一次出现的索引 <br></td></tr><tr><td>  <em>反向（列表）</em> <br></td><td> 以相反的顺序重新排列项目 <br></td></tr></tbody></table></div><br><h2> 什么值得一读？ </h2><br> 这只是使开发人员在使用数据结构时更轻松的工具的一小部分。 布鲁斯·埃克尔（Bruce Eckel）的书“ Java哲学”（第4版）中提供了馆藏本身的许多有趣之处以及使用它们的便捷工具。 但是，您应该小心，因为它遇到了无法在Java 7，Java 8和更高版本上播放的情况。 尽管本书对Java 6进行了描述，但是今天它的材料仍然很重要。 <br><br> 当然，“ Java哲学”不应受到限制。 读任何这些书都不会伤害任何Java开发人员： <br><br><ul><li>  “ Java。  《有效的编程》，约书亚·布洛赫（Joshua Bloch）。 </li><li>  “重构。 改进现有代码的设计，” Martin Fowler。 </li><li>  “清理代码。 创建，分析和重构”，Robert Martin。 </li><li>  Professional，Julian Kozmin等人的Spring 5。 </li><li>  “测试驱动的Java开发”，Viktor Farcic，Alex Garcia（尚未以俄语发布）。 </li></ul><br><h2> 结果如何？ </h2><br> 如果您提出了可以补充本文所写内容的有趣想法，请在评论中分享它们。 <br><br> 我还要祝愿那些使用旧版旧代码的人好运和耐心。 大多数重大项目都是遗留项目。 而且它们对客户的重要性很难被高估。 花费了一个多星期的时间来找出原因，消除了该错误所带来的胜利感并没有逊色于新功能实施结束时的感觉。 <br><br> 谢谢您的关注。 如果提出的任何建议有用，我将感到高兴。 <br> 一切成功！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN476098/">https://habr.com/ru/post/zh-CN476098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN476088/index.html">黑帽美国会议。 致富或丧命：使用Black Hat在互联网上赚钱。 第一部分</a></li>
<li><a href="../zh-CN476090/index.html">在区块链上确保2FA安全</a></li>
<li><a href="../zh-CN476092/index.html">关于“我是专业人士”奥林匹克运动会的“光子学”，“程序设计和IT”以及“信息和网络安全”指导</a></li>
<li><a href="../zh-CN476094/index.html">帝国时代的回归：关于帝国时代的一切IV</a></li>
<li><a href="../zh-CN476096/index.html">从I到Z的库存。我们考虑IT资产</a></li>
<li><a href="../zh-CN476100/index.html">计算机系统体系结构1部分。 逻辑门</a></li>
<li><a href="../zh-CN476102/index.html">使用PHP数组输入安全类型</a></li>
<li><a href="../zh-CN476104/index.html">不要使用免费的MTProxy和其他类型的免费代理...</a></li>
<li><a href="../zh-CN476106/index.html">“密码系统协议”：Diffie — Hellman，El-Gamal，MTI / A（0），STS</a></li>
<li><a href="../zh-CN476108/index.html">大脑可变</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>