<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õπüèæ üëè üë∞üèΩ Transici√≥n del monolito a los microservicios: historia y pr√°ctica. üÉè ‚ÜïÔ∏è üë©üèº‚Äçü§ù‚Äçüë®üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo hablar√© sobre c√≥mo el proyecto en el que trabajo pas√≥ de ser un gran monolito a un conjunto de microservicios. 

 El proyecto comenz√≥...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Transici√≥n del monolito a los microservicios: historia y pr√°ctica.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/458404/"> En este art√≠culo hablar√© sobre c√≥mo el proyecto en el que trabajo pas√≥ de ser un gran monolito a un conjunto de microservicios. <br><br>  El proyecto comenz√≥ su historia hace mucho tiempo, a principios de 2000. Las primeras versiones se escribieron en Visual Basic 6. Con el tiempo, qued√≥ claro que el desarrollo de este lenguaje en el futuro ser√≠a dif√≠cil de soportar, ya que el IDE y el lenguaje en s√≠ est√°n poco desarrollados.  A fines de la d√©cada de 2000, se decidi√≥ cambiar a un C # m√°s prometedor.  La nueva versi√≥n fue escrita en paralelo con el refinamiento de la anterior, gradualmente m√°s y m√°s c√≥digo estaba en .NET.  El backend en C # se centr√≥ inicialmente en la arquitectura del servicio, sin embargo, durante el desarrollo, se usaron bibliotecas compartidas con l√≥gica y los servicios se lanzaron en un solo proceso.  Result√≥ la aplicaci√≥n, que llamamos el "servicio monolito". <br><br>  Una de las pocas ventajas de este paquete era la capacidad de los servicios de llamarse entre s√≠ a trav√©s de una API externa.  Hab√≠a requisitos previos obvios para la transici√≥n a un servicio m√°s correcto y, en el futuro, la arquitectura de microservicios. <br><br>  Comenzamos nuestro trabajo de descomposici√≥n alrededor de 2015.  Todav√≠a no hemos alcanzado un estado ideal: hay partes de un gran proyecto que son dif√≠ciles de llamar monolitos, pero tampoco parecen microservicios.  Sin embargo, el progreso es sustancial. <br>  Hablar√© de √©l en el art√≠culo. <br><br><img src="https://habrastorage.org/webt/ha/af/ct/haafctbyxepfypvukpmypyt30ji.png"><br><a name="habracut"></a><br><h3>  Contenido </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Arquitectura y problemas de la soluci√≥n existente.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Expectativas de microservicio</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Problemas de transici√≥n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo cambiar de monolito a microservicios</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Primera forma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Segunda forma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tercera forma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cuarta forma</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajar con un DB</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ramificar tablas existentes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Departamento de procesamiento</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajando con c√≥digo fuente</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Problemas de infraestructura</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instalaci√≥n manual en ambientes.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Registro separado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prueba y depuraci√≥n de servicios relacionados</a> </li></ul></li></ul><br><br><a name="1"></a><h3>  <b>Arquitectura y problemas de la soluci√≥n existente.</b> </h3><br>  Inicialmente, la arquitectura ten√≠a el siguiente aspecto: la interfaz de usuario es una aplicaci√≥n separada, la parte monol√≠tica est√° escrita en Visual Basic 6, la aplicaci√≥n en .NET era un conjunto de servicios relacionados que funciona con una base de datos bastante grande. <br><br>  <b>Desventajas de la soluci√≥n anterior.</b> <br><br>  <u>Punto √∫nico de falla</u> <br>  Tuvimos un solo punto de falla: la aplicaci√≥n .NET se ejecut√≥ en un proceso.  Si alguno de los m√≥dulos fallaba, la aplicaci√≥n completa fallaba y ten√≠a que reiniciarlo.  Dado que estamos automatizando una gran cantidad de procesos para diferentes usuarios, debido a una falla en uno de ellos, algunos no pudieron funcionar por alg√∫n tiempo.  Y con un error de software, la redundancia tampoco ayud√≥. <br><br>  <u>La alineaci√≥n de mejoras</u> <br>  Este defecto es m√°s bien organizativo.  Nuestra aplicaci√≥n tiene muchos clientes y todos quieren finalizarla lo antes posible.  Anteriormente, era imposible hacer esto en paralelo, y todos los clientes hac√≠an cola.  Este proceso caus√≥ un efecto negativo en el negocio, ya que ten√≠an que demostrar que su tarea era valiosa.  Y el equipo de desarrollo pas√≥ tiempo organizando esta alineaci√≥n.  Esto tom√≥ mucho tiempo y esfuerzo, y el producto como resultado no pudo cambiar tan r√°pido como hubiera sido de √©l. <br><br>  <u>Uso inapropiado de los recursos.</u> <br>  Cuando colocamos servicios en un solo proceso, siempre copiamos completamente la configuraci√≥n de un servidor a otro.  Quer√≠amos colocar los servicios m√°s cargados por separado para no desperdiciar recursos y obtener una administraci√≥n m√°s flexible de nuestro esquema de implementaci√≥n. <br><br>  <u>Es dif√≠cil introducir tecnolog√≠a moderna</u> <br>  Un problema familiar para todos los desarrolladores: existe el deseo de introducir tecnolog√≠as modernas en el proyecto, pero no hay posibilidad.  Con una gran soluci√≥n monol√≠tica, cualquier actualizaci√≥n de la biblioteca actual, sin mencionar la transici√≥n a una nueva, se convierte en una tarea bastante trivial.  Lleva mucho tiempo demostrar al l√≠der del equipo que traer√° m√°s bonificaciones que nervios gastados. <br><br>  <u>La complejidad de emitir cambios</u> <br>  Este fue el problema m√°s grave: emitimos lanzamientos cada dos meses. <br>  Cada lanzamiento se convirti√≥ en un verdadero desastre para el banco, a pesar de las pruebas y los esfuerzos de los desarrolladores.  Business entendi√≥ que al comienzo de la semana algunas de las funcionalidades no funcionar√≠an para √©l.  Y los desarrolladores entendieron que estaban esperando una semana de incidentes graves. <br>  Todos ten√≠an el deseo de cambiar la situaci√≥n. <br><br><a name="2"></a><h3>  <b>Expectativas de microservicio</b> </h3><br>  <u>Entrega de componentes seg√∫n disponibilidad.</u>  Entrega de componentes a medida que est√°n disponibles debido a la descomposici√≥n de la soluci√≥n y la separaci√≥n de varios procesos. <br><br>  <u>Peque√±os equipos de comida.</u>  Esto es importante porque un gran equipo que trabajaba en un viejo monolito era dif√≠cil de manejar.  Tal equipo se vio obligado a trabajar de acuerdo con un proceso estricto, pero quer√≠a m√°s creatividad e independencia.  Solo peque√±os equipos pueden permit√≠rselo. <br><br>  <u>Aislamiento de servicios en procesos separados.</u>  Idealmente, quer√≠a aislar en contenedores, pero una gran cantidad de servicios escritos en .NET Framework se ejecutan solo en Windows.  Ahora hay servicios en .NET Core, pero hasta ahora son pocos. <br><br>  <u>Implementaci√≥n Flexibilidad.</u>  Me gustar√≠a combinar los servicios que necesitamos, y no como las fuerzas del c√≥digo. <br><br>  <u>Uso de nuevas tecnolog√≠as.</u>  Esto es interesante para cualquier programador. <br><br><a name="3"></a><h3>  <b>Problemas de transici√≥n</b> </h3><br>  Por supuesto, si fuera simple dividir un monolito en microservicios, no tendr√≠a que hablar de ello en conferencias y escribir art√≠culos.  En este proceso, hay muchas trampas, describir√© las principales que interfirieron con nosotros. <br><br>  <b>El primer problema</b> es t√≠pico de la mayor√≠a de los monolitos: la coherencia de la l√≥gica empresarial.  Cuando escribimos un monolito, queremos reutilizar nuestras clases para no escribir c√≥digo adicional.  Y al cambiar a microservicios, esto se convierte en un problema: todo el c√≥digo est√° muy bien conectado y es dif√≠cil separar los servicios. <br><br>  En el momento del inicio del trabajo, el repositorio ten√≠a m√°s de 500 proyectos y m√°s de 700 mil l√≠neas de c√≥digo.  Esta es una soluci√≥n bastante grande y el <b>segundo problema</b> .  No fue posible simplemente tomarlo y dividirlo en microservicios. <br><br>  <b>El tercer problema</b> es la falta de infraestructura necesaria.  De hecho, participamos en la copia manual del c√≥digo fuente a los servidores. <br><br><a name="4"></a><h3>  <b>C√≥mo cambiar de monolito a microservicios</b> </h3><br>  <u>Asignaci√≥n de microservicios</u> <br><br>  Primero, determinamos de inmediato por nosotros mismos que la separaci√≥n de microservicios es un proceso iterativo.  Siempre se nos ha requerido llevar a cabo el desarrollo de tareas comerciales en paralelo.  C√≥mo llevaremos a cabo esto t√©cnicamente ya es nuestro problema.  Por lo tanto, nos est√°bamos preparando para el proceso iterativo.  No funcionar√° de manera diferente si tiene una aplicaci√≥n grande, y no est√° lista para ser reescrita desde el principio. <br><br>  ¬øQu√© m√©todos utilizamos para aislar microservicios? <br><br><a name="5"></a>  <b>La primera forma</b> es portar m√≥dulos existentes como servicios.  En este sentido, tuvimos suerte: ya hab√≠a servicios formalizados que funcionaban en el protocolo WCF.  Fueron publicados en asambleas separadas.  Los movimos por separado, agregando un peque√±o lanzador a cada ensamblaje.  Fue escrito usando la maravillosa biblioteca Topshelf, que le permite ejecutar la aplicaci√≥n como un servicio y como una consola.  Esto es conveniente para la depuraci√≥n, ya que no se requieren proyectos adicionales en la soluci√≥n. <br><br>  Los servicios se conectaron de acuerdo con la l√≥gica empresarial, ya que utilizaron conjuntos comunes y trabajaron con una base de datos com√∫n.  Era dif√≠cil llamarlos microservicios en su forma pura.  Sin embargo, podr√≠amos emitir estos servicios por separado, en diferentes procesos.  Esto ya permiti√≥ reducir su influencia mutua, reduciendo el problema con el desarrollo paralelo y un √∫nico punto de falla. <br><br>  Construir con un host es solo una l√≠nea de c√≥digo en la clase Program.  Escondimos a Topshelf en una clase auxiliar. <br><br><pre><code class="plaintext hljs">namespace RBA.Services.Accounts.Host { internal class Program { private static void Main(string[] args) { HostRunner&lt;Accounts&gt;.Run("RBA.Services.Accounts.Host"); } } }</code> </pre> <br><a name="6"></a>  <b>La segunda forma de aislar microservicios:</b> crearlos para resolver nuevos problemas.  Si el monolito no crece al mismo tiempo, esto ya es excelente, lo que significa que nos estamos moviendo en la direcci√≥n correcta.  Para resolver nuevos problemas, tratamos de hacer servicios separados.  Si existiera esa oportunidad, entonces creamos m√°s servicios "can√≥nicos" que controlan completamente su modelo de datos, una base de datos separada. <br><br>  Nosotros, como muchos, comenzamos con los servicios de autenticaci√≥n y autorizaci√≥n.  Son perfectos para esto.  Son independientes, por regla general, tienen un modelo de datos separado.  Ellos mismos no interact√∫an con el monolito, solo √©l recurre a ellos para resolver algunos problemas.  En estos servicios, puede comenzar la transici√≥n a una nueva arquitectura, depurar la infraestructura en ellos, probar algunos enfoques relacionados con las bibliotecas de red, etc.  En nuestra organizaci√≥n, no hay equipos que no puedan hacer un servicio de autenticaci√≥n. <br><br><a name="7"></a>  <b>La tercera forma de aislar los microservicios</b> que utilizamos es un poco espec√≠fica para nosotros.  Esto est√° sacando la l√≥gica empresarial de la capa de interfaz de usuario.  Tenemos la aplicaci√≥n de IU de escritorio principal, como el backend, est√° escrita en C #.  Los desarrolladores peri√≥dicamente cometieron errores y llevaron a cabo en la UI partes de la l√≥gica que deber√≠a haber existido en el backend y reutilizado. <br><br>  Si observa un ejemplo real del c√≥digo de la parte de la interfaz de usuario, puede ver que la mayor parte de esta soluci√≥n contiene l√≥gica comercial real, que es √∫til en otros procesos, no solo para crear un formulario de interfaz de usuario. <br><br><img src="https://habrastorage.org/webt/7s/_e/rb/7s_erbatvtbzompywj94igyvwho.jpeg"><br><br>  La l√≥gica de la interfaz de usuario real es solo el √∫ltimo par de l√≠neas.  Lo transferimos al servidor para poder reutilizarlo, reduciendo as√≠ la interfaz de usuario y logrando la arquitectura correcta. <br><br><a name="8"></a>  <b>La cuarta forma m√°s importante de aislar microservicios</b> , que le permite reducir el monolito, es eliminar los servicios existentes con procesamiento.  Cuando sacamos los m√≥dulos existentes tal cual, el resultado no siempre es agradable para los desarrolladores, y el proceso comercial desde el momento en que se cre√≥ la funcionalidad podr√≠a quedar desactualizado.  Gracias a la refactorizaci√≥n, podemos respaldar un nuevo proceso comercial porque los requisitos comerciales cambian constantemente.  Podemos mejorar el c√≥digo fuente, eliminar defectos conocidos, crear un mejor modelo de datos.  Hay muchas ventajas. <br><br>  El departamento de servicios de procesamiento est√° inextricablemente vinculado al concepto de un contexto limitado.  Este es un concepto de dise√±o orientado a temas.  Significa una secci√≥n de modelo de dominio en la que todos los t√©rminos de un solo idioma se definen de manera √∫nica.  Considere el contexto de seguros y facturas como un ejemplo.  Tenemos una aplicaci√≥n monol√≠tica, y es necesario trabajar con la cuenta en el seguro.  Esperamos que el desarrollador encuentre la clase "Cuenta" existente en otro ensamblado, haga un enlace desde la clase "Seguro", y obtendremos un c√≥digo de trabajo.  Se respetar√° el principio DRY, la tarea mediante el uso del c√≥digo existente se realizar√° m√°s r√°pido. <br><br>  Como resultado, resulta que los contextos de cuentas y seguros est√°n conectados.  Cuando surgen nuevos requisitos, esta conexi√≥n interferir√° con el desarrollo, aumentando la complejidad de una l√≥gica empresarial ya compleja.  Para resolver este problema, debe encontrar los l√≠mites entre los contextos en el c√≥digo y eliminar sus violaciones.  Por ejemplo, en el contexto del seguro, es bastante posible que el n√∫mero de cuenta de 20 d√≠gitos del Banco Central y la fecha de apertura de la cuenta sean suficientes. <br><br>  Para separar estos contextos limitados entre s√≠ y comenzar el proceso de extracci√≥n de microservicios de una soluci√≥n monol√≠tica, utilizamos un enfoque como la creaci√≥n de API externas dentro de la aplicaci√≥n.  Si supi√©ramos que alg√∫n m√≥dulo deber√≠a convertirse en un microservicio, de alguna manera cambiar dentro del proceso, entonces inmediatamente realizamos llamadas a la l√≥gica, que pertenece a otro contexto limitado, a trav√©s de llamadas externas.  Por ejemplo, a trav√©s de REST o WCF. <br><br>  Decidimos por nosotros mismos que no evitar√≠amos el c√≥digo que requerir√≠a transacciones distribuidas.  En nuestro caso, result√≥ ser bastante f√°cil seguir esta regla.  Todav√≠a no nos hemos encontrado con situaciones en las que realmente se necesitan transacciones distribuidas de forma r√≠gida: la consistencia final entre los m√≥dulos es suficiente. <br><br>  Considere un ejemplo espec√≠fico.  Tenemos el concepto de una orquesta - transportadora, que procesa la esencia de la "aplicaci√≥n".  Se turna para crear un cliente, una cuenta y una tarjeta bancaria.  Si el cliente y la cuenta se crearon con √©xito, y la creaci√≥n de la tarjeta fall√≥, la aplicaci√≥n no pasa al estado "con √©xito" y permanece en el estado "tarjeta no creada".  En el futuro, la actividad en segundo plano lo recoger√° y terminar√°.  El sistema est√° en un estado de inconsistencia durante alg√∫n tiempo, pero esto, en general, nos conviene. <br><br>  Sin embargo, si surge una situaci√≥n en la que ser√° necesario guardar consistentemente parte de los datos, lo m√°s probable es que ampliemos el servicio para procesar esto en un solo proceso. <br><br>  Consideremos un ejemplo de asignaci√≥n de microservicios.  ¬øC√≥mo se puede llevar de manera relativamente segura a producci√≥n?  En este ejemplo, tenemos una parte separada del sistema: el m√≥dulo de servicio de salario, una de las secciones del c√≥digo del que nos gustar√≠a hacer microservicios. <br><br><img src="https://habrastorage.org/webt/g2/kn/he/g2knhebep6zxxcl-14mfdxd6xow.jpeg"><br><br>  En primer lugar, creamos un microservicio reescribiendo el c√≥digo.  Mejoramos algunos puntos que no nos conven√≠an.  Nos damos cuenta de los nuevos requisitos comerciales del cliente.  Agregamos al paquete entre la interfaz de usuario y el back-end API de Gateway, que proporcionar√° el desv√≠o de llamadas. <br><br><img src="https://habrastorage.org/webt/g4/eo/sw/g4eoswb9nmxcoom9tbsug5quwsu.png"><br><br>  A continuaci√≥n, lanzamos esta configuraci√≥n en funcionamiento, pero en el estado del piloto.  La mayor√≠a de nuestros usuarios a√∫n trabajan con procesos comerciales antiguos.  Para los nuevos usuarios, estamos desarrollando una nueva versi√≥n de una aplicaci√≥n monol√≠tica que este proceso ya no contiene.  De hecho, tenemos un mont√≥n de monolitos y microservicios trabajando en forma de piloto. <br><br><img src="https://habrastorage.org/webt/vw/hn/p3/vwhnp3x9xxb1qrnz9rqe-552mvs.jpeg"><br><br>  Con un piloto exitoso, entendemos que la nueva configuraci√≥n es realmente operativa, podemos eliminar el viejo monolito de la ecuaci√≥n y dejar la nueva configuraci√≥n en el lugar de la soluci√≥n anterior. <br><br><img src="https://habrastorage.org/webt/4w/pk/a3/4wpka3wcyexlk-ohyvab4vucbts.png"><br><br>  En total, utilizamos casi todos los m√©todos existentes para separar el c√≥digo fuente de un monolito.  Todos ellos nos permiten reducir el tama√±o de partes de la aplicaci√≥n y transferirlas a nuevas bibliotecas, mejorando el c√≥digo fuente. <br><br><a name="9"></a><h3>  <b>Trabajar con un DB</b> </h3><br>  La base de datos se puede dividir peor que el c√≥digo fuente, ya que contiene no solo el esquema actual, sino tambi√©n los datos hist√≥ricos acumulados. <br><br>  Nuestra base de datos, como muchas otras, ten√≠a otro inconveniente importante: su gran tama√±o.  Esta base de datos fue dise√±ada de acuerdo con la intrincada l√≥gica de negocios del monolito, y se han acumulado enlaces entre tablas de varios contextos limitados. <br><br>  En nuestro caso, adem√°s de todos los problemas (una gran base de datos, muchas relaciones, a veces fronteras incomprensibles entre tablas), surgi√≥ un problema en muchos proyectos grandes: el uso de la plantilla de base de datos compartida.  Los datos se tomaron de las tablas a trav√©s de la vista, a trav√©s de la replicaci√≥n, y se enviaron a otros sistemas donde se necesita esta replicaci√≥n.  Como resultado, no pudimos eliminar las tablas en un esquema separado, porque se usaron activamente. <br><br>  La separaci√≥n nos ayuda a dividirnos en contextos limitados en el c√≥digo.  Por lo general, nos da una idea bastante buena de c√≥mo dividimos los datos a nivel de la base de datos.  Entendemos qu√© tablas se relacionan con un contexto limitado y cu√°les se relacionan con otro. <br><br>  Aplicamos dos formas globales de particionar la base de datos: particionando las tablas existentes y particionando con el procesamiento. <br><br>  La separaci√≥n de las tablas existentes es un m√©todo que es bueno usar si la estructura de datos es de alta calidad, satisface los requisitos comerciales y se adapta a todos.  En este caso, podemos seleccionar tablas existentes en un esquema separado. <br><br>  Se necesita un departamento de procesamiento cuando el modelo de negocio ha cambiado mucho y las tablas ya no nos satisfacen por completo. <br><br><a name="10"></a>  <b>Separa las tablas existentes.</b>  Necesitamos determinar qu√© separaremos.  Sin este conocimiento, nada saldr√° de ello, y aqu√≠ la separaci√≥n de contextos limitados en el c√≥digo nos ayudar√°.  Como regla general, si puede comprender los l√≠mites de los contextos en el c√≥digo fuente, queda claro qu√© tablas deben incluirse en la lista para la separaci√≥n. <br><br>  Imagine que tenemos una soluci√≥n en la que dos m√≥dulos monol√≠ticos interact√∫an con una base de datos.  Necesitamos asegurarnos de que solo un m√≥dulo interact√∫e con la parte de las tablas separadas, y el otro comience a interactuar con √©l a trav√©s de la API.  Para empezar, es suficiente que solo se haga una entrada a trav√©s de la API.  Esta es una condici√≥n necesaria para que podamos hablar sobre la independencia de los microservicios.  Los enlaces de lectura pueden permanecer hasta que haya un gran problema. <br><br><img src="https://habrastorage.org/webt/ed/tk/ea/edtkeafsmsewkmmwbaxh-nicpou.jpeg"><br><br>  Como siguiente paso, ya podemos seleccionar una secci√≥n de c√≥digo que funcione con tablas separables con o sin procesamiento en un microservicio separado y ejecutarlo en un proceso separado, contenedor.  Este ser√° un servicio separado con comunicaci√≥n con la base de datos monol√≠tica y aquellas tablas que no est√°n directamente relacionadas con ella.  El monolito a√∫n interact√∫a con la parte desmontable para leer. <br><br><img src="https://habrastorage.org/webt/39/xe/qp/39xeqpzjbsxcjtdxwh8_jgt4uxa.jpeg"><br><br>  M√°s adelante eliminaremos esta conexi√≥n, es decir, leer los datos de la aplicaci√≥n monol√≠tica de las tablas separadas tambi√©n se transferir√° a la API. <br><br><img src="https://habrastorage.org/webt/qu/j9/hx/quj9hx6oj3ovg71xy_lge9ziovg.png"><br><br>  A continuaci√≥n, seleccionamos de la base de datos general las tablas con las que solo funciona el nuevo microservicio.  Podemos colocar tablas en un esquema separado o incluso en una base de datos f√≠sica separada.  Hubo una conexi√≥n para la lectura entre el microservicio y la base de datos de monolitos, pero no hay nada de qu√© preocuparse, en esta configuraci√≥n puede vivir durante mucho tiempo. <br><br><img src="https://habrastorage.org/webt/os/uc/zq/osuczqkdtaoxzmdmii1oni3qhlm.png"><br><br>  El √∫ltimo paso es eliminar completamente todas las conexiones.  En este caso, es posible que necesitemos migrar datos de la base de datos principal.  A veces queremos reutilizar en varias bases de datos algunos datos o directorios que se replican desde sistemas externos.  Peri√≥dicamente nos encontramos con esto. <br><br><img src="https://habrastorage.org/webt/9e/ws/m9/9ewsm976maj96yzqj_-atbml4ae.png"><br><br><a name="11"></a>  <b>Departamento de procesamiento.</b>  Este m√©todo es muy similar al primero, solo va en el orden inverso.  Inmediatamente tenemos una nueva base de datos y un nuevo microservicio que interact√∫a con el monolito a trav√©s de la API.  Pero al mismo tiempo, queda un conjunto de tablas de bases de datos que queremos eliminar en el futuro.  Ya no lo necesitaremos, en el nuevo modelo lo reemplazamos. <br><br><img src="https://habrastorage.org/webt/fy/ic/jx/fyicjxxkjagnsd_acgimthenabs.png"><br><br>  Para que este esquema funcione, lo m√°s probable es que necesitemos un per√≠odo de transici√≥n. <br><br>  Hay dos enfoques posibles. <br><br>  <b>Primero</b> : duplicamos todos los datos en las bases de datos nuevas y antiguas.  En este caso, tenemos redundancia de datos, puede haber problemas con la sincronizaci√≥n.  Pero luego podemos tomar dos clientes diferentes.  Uno funcionar√° con la nueva versi√≥n, el otro con la antigua. <br><br>  <b>Segundo</b> : compartimos datos de acuerdo con algunas caracter√≠sticas comerciales.  Por ejemplo, en nuestro sistema hab√≠a 5 productos almacenados en la base de datos anterior.  El sexto como parte de una nueva tarea comercial, colocamos una nueva base de datos.  Pero necesitamos la API de Gateway, que sincroniza estos datos y muestra al cliente d√≥nde y qu√© llevar. <br><br>  Ambos enfoques est√°n funcionando, elija seg√∫n la situaci√≥n. <br><br>  Despu√©s de asegurarnos de que todo funciona, la parte del monolito que funciona con las antiguas estructuras de bases de datos puede deshabilitarse. <br><br><img src="https://habrastorage.org/webt/1j/tf/tg/1jtftgwoy_c-bcfa8yddp5whppc.png"><br><br>  El √∫ltimo paso es eliminar las viejas estructuras de datos. <br><br><img src="https://habrastorage.org/webt/4r/4o/m_/4r4om_wgj3wwxi25mf45eg_umss.png"><br><br>  En resumen, podemos decir que tenemos problemas con la base de datos: es dif√≠cil trabajar con ella en comparaci√≥n con el c√≥digo fuente, es m√°s dif√≠cil de separar, pero esto puede y debe hacerse.  Encontramos algunas formas que permiten que esto se haga con bastante seguridad, sin embargo, es m√°s f√°cil cometer un error con los datos que con el c√≥digo fuente. <br><br><a name="12"></a><h3>  <b>Trabajando con c√≥digo fuente</b> </h3><br>  As√≠ era el diagrama del c√≥digo fuente cuando comenzamos a analizar un proyecto monol√≠tico. <br><br><img src="https://habrastorage.org/webt/wx/z2/2m/wxz22mn86ej9jfyhkjww7zmvnoe.png"><br><br>  Se puede dividir condicionalmente en tres capas.  Esta es una capa de m√≥dulos lanzados, complementos, servicios y actividades individuales.  De hecho, estos fueron los puntos de entrada dentro de la soluci√≥n monol√≠tica.  Todos ellos estaban fuertemente unidos con una capa com√∫n.  Ten√≠a una l√≥gica de negocios que se compart√≠a entre servicios y muchas conexiones.  Cada servicio y complemento utilizaba hasta 10 o m√°s conjuntos comunes, dependiendo de su tama√±o y la conciencia de los desarrolladores. <br><br>  Tuvimos suerte, ten√≠amos bibliotecas de infraestructura que pod√≠an usarse por separado. <br><br>  Algunas veces surgi√≥ una situaci√≥n en la que algunos de los objetos comunes no pertenec√≠an a esta capa, sino que eran bibliotecas de infraestructura.  Esto se decidi√≥ cambiando el nombre. <br><br>  M√°s preocupado por contextos limitados.  Sol√≠a ‚Äã‚Äãser que 3-4 contextos se mezclaron en un ensamblaje com√∫n y se usaron entre s√≠ dentro de las mismas funciones comerciales.  Era necesario comprender d√≥nde se puede dividir esto y en qu√© l√≠mites, y qu√© hacer a continuaci√≥n con el mapeo de esta separaci√≥n en ensambles de c√≥digo fuente. <br><br>  Hemos formulado varias reglas para el proceso de separaci√≥n de c√≥digo. <br><br>  <b>Primero</b> : ya no quer√≠amos compartir la l√≥gica empresarial entre servicios, actividades y complementos.  Quer√≠an hacer que la l√≥gica de negocios sea independiente en el marco de los microservicios.  Por otro lado, los microservicios, en el caso ideal, se perciben como servicios que existen de manera completamente independiente.  Creo que este enfoque es algo derrochador y es dif√≠cil lograrlo, porque, por ejemplo, los servicios en C # en cualquier caso estar√°n conectados por una biblioteca est√°ndar.  Nuestro sistema est√° escrito en C #, otras tecnolog√≠as a√∫n no se han utilizado.  Por lo tanto, decidimos que podemos permitirnos usar conjuntos t√©cnicos comunes.  Lo principal es que no tienen ning√∫n fragmento de l√≥gica empresarial.  Si tiene un contenedor conveniente sobre el ORM que usa, copiarlo de un servicio a otro es muy costoso. <br><br>  Nuestro equipo es fan√°tico del dise√±o orientado a temas, por lo que la "arquitectura de cebolla" es perfecta para nosotros.  La base de nuestros servicios no era una capa de acceso a datos, sino un ensamblaje con l√≥gica de dominio, que contiene solo l√≥gica de negocios y carece de conexiones de infraestructura.  Al mismo tiempo, podemos modificar independientemente el ensamblado del dominio para resolver los problemas asociados con los marcos. <br><br>  En esta etapa, nos encontramos con el primer problema grave.  Se supon√≠a que el servicio se refer√≠a a un ensamblaje de dominio, quer√≠amos hacer que la l√≥gica fuera independiente, y aqu√≠ el principio DRY interfiri√≥ fuertemente con nosotros.  Para evitar la duplicaci√≥n, los desarrolladores quer√≠an reutilizar las clases de los ensamblados vecinos y, como resultado, los dominios comenzaron a comunicarse entre s√≠ nuevamente.  Analizamos los resultados y decidimos que quiz√°s el problema tambi√©n se encuentre en el √°rea del dispositivo de almacenamiento del c√≥digo fuente.  Ten√≠amos un gran repositorio en el que yac√≠an todos los c√≥digos fuente.  La soluci√≥n para todo el proyecto fue muy dif√≠cil de ensamblar en una m√°quina local.  Por lo tanto, se crearon peque√±as soluciones separadas para las partes del proyecto, y nadie prohibi√≥ agregarles ning√∫n conjunto Com√∫n o de dominio y reutilizarlas.  La √∫nica herramienta que no nos permiti√≥ hacer esto fue el c√≥digo de revisi√≥n.  Pero a veces tambi√©n se estrellaba. <br><br>  Luego comenzamos a cambiar a un modelo con repositorios separados.  La l√≥gica empresarial ha dejado de fluir de un servicio a otro, los dominios se han vuelto verdaderamente independientes.  Los contextos limitados son m√°s claros.  ¬øC√≥mo reutilizamos las bibliotecas de infraestructura?  Los asignamos a un repositorio separado, luego los colocamos en los paquetes Nuget que colocamos en Artifactory.  Con cualquier cambio, el montaje y la publicaci√≥n se producen autom√°ticamente. <br><br><img src="https://habrastorage.org/webt/so/tk/g_/sotkg_uskgxq41d3swhkewhkzcy.png"><br><br>  Nuestros servicios comenzaron a referirse a los paquetes de infraestructura interna de la misma manera que a los externos.  Descargamos bibliotecas externas de Nuget.  Para trabajar con Artifactory, donde colocamos estos paquetes, utilizamos dos administradores de paquetes.  En repositorios peque√±os, tambi√©n usamos Nuget.  En repositorios con varios servicios, utilizamos Paket, que proporciona m√°s consistencia de versi√≥n entre m√≥dulos. <br><br><img src="https://habrastorage.org/webt/dr/0g/qe/dr0gqecxnqni4wcer4m1ogw-x70.png"><br><br>  Por lo tanto, trabajando en el c√≥digo fuente, cambiando ligeramente la arquitectura y compartiendo repositorios, hacemos que nuestros servicios sean m√°s independientes. <br><br><a name="13"></a><h3>  <b>Problemas de infraestructura</b> </h3><br>  La mayor√≠a de las desventajas de cambiar a microservicios est√°n relacionadas con la infraestructura.  Necesitar√° una implementaci√≥n automatizada, necesitar√° nuevas bibliotecas para la infraestructura. <br><br><a name="16"></a>  <b>Instalaci√≥n manual en ambientes.</b> <br><br>  Inicialmente, instalamos la soluci√≥n en el entorno manualmente.  Para automatizar este proceso, creamos una tuber√≠a de CI / CD.  Elegimos el proceso de entrega continua, porque la implementaci√≥n continua para nosotros a√∫n no es aceptable desde el punto de vista de los procesos comerciales.  Por lo tanto, el env√≠o a la operaci√≥n se lleva a cabo mediante el bot√≥n y para la prueba, autom√°ticamente. <br><br><img src="https://habrastorage.org/webt/vz/lp/yw/vzlpyw7h9ej1gdxvkzqwivl_gqu.png"><br><br>  Usamos Atlassian, Bitbucket para almacenar el c√≥digo fuente y Bamboo para el ensamblaje.  Nos gusta escribir scripts de ensamblaje en Cake porque es el mismo C #.  Los paquetes preparados llegan a Artifactory, y Ansible llega autom√°ticamente a los servidores de prueba, despu√©s de lo cual se pueden probar de inmediato. <br><br><img src="https://habrastorage.org/webt/-g/5p/dn/-g5pdnzpev-odvgxu-woy7qtcny.png"><br><br><a name="14"></a><h3>  <b>Registro separado</b> </h3><br>  En un momento, una de las ideas del monolito era la provisi√≥n de tala conjunta.  Tambi√©n necesit√°bamos comprender qu√© hacer con los registros individuales que se encuentran en los discos.  Los registros se nos escriben en archivos de texto.  Decidimos usar la pila ELK est√°ndar.  No escribimos directamente al ELK a trav√©s de proveedores, pero decidimos que finalizar√≠amos los registros de texto y anot√°bamos la ID de rastreo en ellos como un identificador, agregando el nombre del servicio para que estos registros pudieran analizarse. <br><br><img src="https://habrastorage.org/webt/e5/pd/ws/e5pdwsgrrb-9cpjhxabejxqdpt8.png"><br><br>  Usando Filebeat tenemos la oportunidad de recopilar nuestros registros de los servidores, luego convertirlos, usando Kibana para crear solicitudes en la interfaz de usuario y ver c√≥mo transcurri√≥ la llamada entre los servicios.  La identificaci√≥n de rastreo ayuda mucho en esto. <br><br><a name="15"></a><h3>  <b>Prueba y depuraci√≥n de servicios relacionados</b> </h3><br>  Inicialmente, no entend√≠amos completamente c√≥mo depurar los servicios desarrollados.  Todo era simple con el monolito, lo ejecutamos en la m√°quina local.  Al principio, intentaron hacer lo mismo con los microservicios, pero a veces para iniciar completamente un microservicio, debe iniciar varios otros, lo cual es inconveniente.  ,     ,          ,   .     ,     prod.  ,  ,          .  ,     ,        . <br><br>  ,     production- .      ,         . <br><br>           Specflow.      NUnit     Ansible.     ,      .   -    .  ,      ,     Jira. <br><br>      ,       .      JMeter,    ‚Äî InfluxDB,      ‚Äî Grafana. <br><br><h3> <b>  ?</b> </h3><br> -,     ¬´¬ª.    ,      production-,    -.        1,5 ,  ,        . <br><br>      .      ,       ,      .     . <br><br>     .        ,     . <br><br>  ,        .      ,      .     Scrum-.        ,    . <br><br><h3> <b></b> </h3><br><ul><li>       .     ,     ,    ,    .            . </li><li>    .        ,        ,     .    ,         , ,     Scrum. </li><li>  ‚Äî   .        .      .       legacy,      ,            . <br><br> <i> :</i>       .        . ,     ,     ,     ,        , , ,  ‚Äî   ,    .   .     ,     ,          . <br><br> PS    (    ) ‚Äì  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . <br>    . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458404/">https://habr.com/ru/post/458404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458390/index.html">Ceph - de "en la rodilla" a "producci√≥n" parte 2</a></li>
<li><a href="../458394/index.html">Asegurar protocolos inal√°mbricos utilizando LoRaWAN como ejemplo</a></li>
<li><a href="../458396/index.html">C√≥mo hice que el desarrollo en Vue.js sea conveniente con la representaci√≥n del lado del servidor</a></li>
<li><a href="../458398/index.html">Higiene del trabajo a distancia o los beneficios de la telepat√≠a.</a></li>
<li><a href="../458400/index.html">Arquitectura e implementaci√≥n de microservicios, paso a paso, parte 1</a></li>
<li><a href="../458406/index.html">M√°s de 30 preguntas sobre programas de utilidad y no de utilidad</a></li>
<li><a href="../458408/index.html">Semana de la seguridad 27: vulnerabilidades de la bomba de insulina</a></li>
<li><a href="../458410/index.html">C√≥mo desarrollar una estructura de tienda en l√≠nea basada en la agrupaci√≥n y la lematizaci√≥n de la sem√°ntica</a></li>
<li><a href="../458412/index.html">¬øBlockchain est√° aqu√≠ solo para relaciones p√∫blicas y publicidad?</a></li>
<li><a href="../458414/index.html">C√≥mo cambiar tu carrera, convertirte en un desarrollador frontend a los 30 a√±os y trabajar a tu gusto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>