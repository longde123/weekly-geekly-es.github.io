<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♐️ 👩‍👩‍👧‍👦 🚶🏾 Cara mengembalikan video untuk Remot Full Throttle Penuh. Bagian 2 👊🏼 🐂 👙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam posting saya sebelumnya , saya berbicara tentang bagaimana kami mengekstraksi konten dari file sumber FMV dan membuat alat untuk menganalisis se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara mengembalikan video untuk Remot Full Throttle Penuh. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422367/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1de/374/14c/1de37414cbdd0d9728e11244fd636b5f.png" alt="gambar"></div><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> saya sebelumnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> saya berbicara tentang bagaimana kami mengekstraksi konten dari file sumber FMV dan membuat alat untuk menganalisis sekitar 67 GB arsip untuk mencari komponen perantara yang digunakan untuk membuat FMV.  Bagian-bagian ini adalah dasar untuk membuat konten FMV remaster dan digunakan sebagai "gambar perakitan" untuk memulai proyek. <br><br>  Seperti yang dinyatakan dalam artikel sebelumnya, alur kerja remastering dibagi menjadi tiga cabang: remastering frame yang digambar tangan, remastering model 3D dan remastering suara.  Di bawah ini saya akan berbicara tentang fitur alur kerja dan trik yang kami gunakan untuk mengotomatisasi pembuatan bagian utama video. <br><a name="habracut"></a><br>  Kami meningkatkan ukuran semua frame yang digambar tangan asli agar sesuai dengan resolusi 4K (3840x2160).  Mempertimbangkan penambahan lebar adegan redone dan fakta bahwa game ditampilkan dalam piksel non-persegi, ini berarti bahwa semua sumber daya yang di-remaster harus dibuat dalam resolusi 4440x2400 piksel. <br><br>  Kami memutuskan untuk menggunakan Adobe Animate untuk mem-remaster semua frame FMV yang digambar dengan tangan, karena kami sudah memiliki alur kerja yang sudah jadi setelah mengembangkan Day of the Tentacle Remastered.  Tim seniman menguasai proses ini dengan baik, jadi kami tidak mempertimbangkan pilihan lain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e2/b57/098/3e2b57098e68ff84ee833c7b56a3ad35.gif"></div><br>  <em>Contoh membuat ulang bingkai yang digambar tangan</em> <br><br>  Model 3D asli dari arsip ada dalam 3D Studio Release 3. Untungnya, versi modern 3D Studio Max mampu mengimpor semua data dari jerat dan kerangka kunci sinematik menggunakan skrip otomatisasi lain.  Setelah itu, kami mengonversi file perantara ini untuk berfungsi di Autodesk Maya, tempat para seniman melakukan sihir remastering mereka. <br><br>  Untuk memberikan permukaan yang baru pada jerat gaya, diterapkan shader baru, tekstur berkualitas tinggi diterapkan, dan jerat ini secara signifikan ditambahkan untuk memberikan model tampilan yang lebih halus.  Selain itu, bingkai jendela diperluas untuk semua kamera input video agar sesuai dengan resolusi kerja 4440x2400 piksel, karena kamera asli dirancang untuk rasio aspek yang lebih sempit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df9/949/7bd/df99497bdfb6c540ef07e330cb9142b8.gif"></div><br>  <em>Contoh model 3D remastering</em> <br><br>  Mengenai audio, kami berhasil menemukan sebagian besar versi asli berkualitas tinggi, tetapi ada pengecualian.  Rekaman dari studio dubbing berbahasa Inggris dikemas ke dalam arsip, tetapi dubbing dalam bahasa lain, yang dilibatkan oleh mitra eksternal, tidak tersedia bagi kami.  Selain itu, kami berhasil menemukan musik asli The Gone Jackals, yang digunakan dalam FMV.  Beberapa versi efek suara (SFX) telah diganti dengan yang lebih "kencang" dengan jenis suara yang serupa. <br><br>  Di bawah ini adalah bagan alur yang secara kasar menjelaskan bagaimana kami memproses sumber daya sumber dan menautkannya dengan konten yang diremaster.  Frame video asli yang diekstraksi (menggunakan SanExtract.exe) digunakan sebagai "sumber" untuk perbandingan dengan semua file data arsip.  File manifes arsip dihasilkan menggunakan pencarian rekursif semua data arsip;  mereka digunakan untuk dengan cepat menemukan semua file unik dari jenis tertentu. <br><br>  Alat SanWrangler digunakan untuk membandingkan secara visual "sumber" bingkai dan data yang diarsipkan.  Pengguna dapat secara visual melampirkan file arsip ke bingkai asli dan menyimpannya sebagai peta ketergantungan dalam format XML.  Setelah membuat peta ketergantungan, cukup menggunakan skrip Python untuk secara otomatis menghasilkan bingkai yang diambil secara manual dari sumber daya file "menggambar" asli, serta "gambar rakitan" untuk Maya 3D.  File-file ini menjadi titik awal bagi tim seniman, yang kemudian melanjutkan ke remastering. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2d/fa0/30a/c2dfa030a1899e9fb679ebd17caf1ee2.png"></div><br>  <em>Mengekstraksi sumber daya asli dan menciptakan "gambar perakitan"</em> <br><br>  Ini adalah langkah pertama dari banyak langkah yang menghasilkan kami mendapatkan versi remaster FMV siap pakai.  Ya, tentu saja, sekarang kita memiliki titik awal dari semua file yang perlu diperbaiki, tetapi bagaimana menghubungkan semua fragmen ini bersama-sama? <br><br>  Di bawah ini saya akan berbicara tentang metode otomasi yang digunakan dalam alur kerja pembuatan FMV.  Metode-metode ini dapat digunakan tidak hanya untuk menghasilkan FMV dan berlaku tidak hanya untuk satu game;  Saya pikir mereka cukup universal, dan mereka dapat digunakan dalam banyak aspek pengembangan game. <br><br>  Seperti kebanyakan alur kerja pembuatan grafis, proses ini akan berulang.  Di suatu tempat di file sumber mungkin ada bug yang perlu diperbaiki oleh artis, dan kadang-kadang perlu untuk mengekspor kembali file yang bergantung pada sumber daya.  Saya pikir kita semua lebih suka pekerjaan ini dilakukan oleh komputer, daripada oleh orang yang cenderung kesalahan. <br><br>  Kami tahu persis bagaimana video untuk Full Throttle Remastered akan terlihat dan terdengar, jadi kami hanya perlu meningkatkan grafik dan suara mereka.  Semua video harus cocok dengan aslinya, bingkai demi bingkai, termasuk jalur kamera, volume suara, panning, dll.  Untuk mencapai ini, kami perlu tahu seperti apa alur kerja pembuatan FMV asli.  Dan 67 GB data dari arsip LucasArts ini mengandung banyak petunjuk tentang bagaimana semuanya bekerja dalam aslinya.  Mereka adalah awal yang baik bagi kami. <br><br><h1>  Proses pembuatan FMV asli </h1><br>  Mungkin terdengar sedikit nostalgia, tapi saya pikir penting untuk membahas aspek "arkeologi digital" dari remastering game ini.  Pada akhirnya, memahami proses pembuatan asli akan memungkinkan Anda untuk menjawab banyak pertanyaan dan memberikan petunjuk tentang bagaimana sumber daya berubah menjadi hasil akhir.  Dan saat membuat FMV baru yang dibuat ulang, kita perlu menerapkan transformasi yang sama ke sumber daya remaster asli kami sehingga produk jadi terlihat sedekat mungkin dengan aslinya.  Termasuk kami membutuhkan yang berikut: <br><br><ul><li>  Lokasi trek audio di timeline </li><li>  Pengaturan volume dan pan untuk trek audio saat bermain di game </li><li>  Komposisi bingkai dan penempatan setiap frame video dalam produk jadi </li></ul><br>  Alat yang disebut SMUSHFT (SMUSH untuk Full Throttle) memungkinkan pembuat FMV untuk menempatkan sumber daya video dan audio pada timeline, dan kemudian menyandikan film FMV yang dihasilkan (dalam format .san), yang dibaca oleh mesin permainan.  Semua video dibagi menjadi serangkaian bingkai yang direkatkan untuk menciptakan hasil akhir.  SMUSHFT memungkinkan pengguna untuk memindahkan sumber daya ini secara visual sepanjang garis waktu dan, jika perlu, mengulang video. <br><br>  Anda tidak dapat menyebutkan bahwa saya tidak berpartisipasi dalam pembuatan game asli.  Saya hanya bisa menebak bagaimana sumber daya asli dibuat, mempelajari data yang diarsipkan dan melihat format dan file yang dapat dieksekusi yang dikemas ke dalam data ini.  Tampaknya model 3D dibuat di Autodesk 3D Studio Release 3, dan bagian yang digambar tangan dibuat di DeluxePaint Animation v1.0.  Saya juga tidak tahu dari tahap mana generasi data gelombang untuk audio terdiri, tetapi masing-masing klip audio yang digunakan (dalam format .sad) berisi informasi tentang volume dan panning dengan bingkai kunci, yang digunakan untuk mencampur suara selama permainan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c03/921/61a/c0392161ae29aa540fe78d7a6485a232.png"></div><br>  <em>Proses pembuatan FMV asli</em> <br><br>  Setelah membuat bagian-bagian terpisah dari bingkai, proses menggabungkan bingkai dilakukan.  Proses ini menggabungkan rendering bingkai 3D dengan bingkai animasi yang digambar tangan (bersama dengan yang lainnya), menciptakan produk jadi yang digunakan oleh alat SMUSHFT (file .nut).  Setelah proyek siap untuk penyandian, video diproses dan hasil akhirnya (.san) sudah bisa diputar di mesin permainan. <br><br>  SMUSHFT melakukan penyandian akhir dari format file dari video asli (.san), dan setiap file video memiliki file proyek (.pro) yang menggambarkan perakitan video (suara, video, lokasi subtitle).  Kami ingin mengekstraksi informasi ini sehingga kami dapat menghasilkan file proyek Adobe Premiere Pro dan menggunakannya untuk menyandikan versi video yang dikonversi dalam resolusi 4K.  Untuk melakukan ini, kami perlu merekayasa balik file proyek SMUSHFT. <br><br><h1>  Membalik Format File Rekayasa </h1><br>  Sangat menyenangkan memiliki kode sumber, karena Anda bisa mempelajarinya dan memahami bagaimana file proyek dibuat / dibaca.  Tanpa kode sumber, Anda harus membuka file proyek dalam hex editor dan menganalisis pola di dalam file.  Ini persis seperti yang kami gunakan untuk mengekstrak konten yang bermanfaat dari file proyek SMUSHFT. <br><br>  Karena kami dapat menjalankan SMUSHFT asli di DOSBox, kami melihat antarmuka pengguna program, yang memberi kami petunjuk tentang format file.  Lihatlah screenshot dari pembukaan file .pro asli ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbb/854/63b/cbb85463b67ad09d81d939f442f9fdc0.png"></div><br>  <em>Contoh Proyek SMUSHFT</em> <br><br>  Di sini Anda dapat melihat yang berikut: ada sumber daya bernama dalam file (2027.NUT, 2027.SAD, IN_06A.NUT, dll.).  Sumber daya yang disebutkan seperti itu cenderung menampilkan karakter ASCII di dalam file.  Selain itu, ada penghitung bingkai di bagian atas timeline, dan di sebelah kiri timeline ada peningkatan jumlah lapisan.  Dan yang terakhir - setiap sumber daya pada timeline terletak pada nomor bingkai tertentu dan memiliki durasi tertentu.  Jika kami dapat mengekstrak informasi ini dari file proyek asli, ini akan memberi tahu kami di mana harus menempatkan sumber daya baru secara otomatis di timeline Adobe Premiere Pro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e5/de5/904/3e5de59049c14a72bb8373a0c72b48a0.png"></div><br>  <em>Proyek sampel Adobe Premiere Pro</em> <br><br>  Dengan membuka file proyek asli dalam hex editor, Anda bisa mendapatkan beberapa informasi yang sangat berguna.  Lihat contoh di atas dalam heksadesimal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5f/008/054/b5f00805485c3d4a8af811c4dc359063.png"></div><br>  <em>File Proyek SMUSHFT di Hex Editor</em> <br><br>  Kita dapat mulai melihat file .pro dengan hex editor (saya lebih suka Hexplorer) dan mencoba mencari pola.  Anda dapat dengan mudah menemukan sumber daya bernama dalam format ASCII dengan nol byte di akhir.  Kira-kira di area memori yang sama ada sekelompok nilai yang disimpan sebagai celana pendek (integer bita ganda).  Membandingkan angka yang ditampilkan dalam SMUSHFT dengan <br>  Angka-angka dari file proyek dalam format hex memberi kita dasar untuk dengan benar mengkonversi file proyek asli menjadi editor video modern seperti Adobe Premiere Pro. <br><br><h1>  Perangkat Otomasi </h1><br>  Sebagian besar alur kerja ini diotomatisasi dan tidak memerlukan intervensi manusia.  Salah satu alasan untuk ini adalah bahwa isi semua video sepenuhnya disalin dari aslinya;  sebenarnya, kami baru saja meningkatkan konten.  Dan oleh karena itu, kami praktis tidak memiliki kesempatan untuk sepenuhnya mengubah format FMV.  Kami hanya perlu menemukan cara untuk membuat ulang video menggunakan sumber daya resolusi tinggi, sambil meminimalkan waktu yang dihabiskan untuk produk. <br><br>  Pertama, saya harus mengatakan bahwa langkah awal yang serius sebelum mengotomatiskan seluruh proses harus menjadi percakapan dengan tim pembuat konten (grafik dan audio).  Alasannya adalah bahwa sebagian besar proses otomatisasi membutuhkan pembuat untuk mematuhi seperangkat aturan tertentu tentang menyiapkan proyek, lokasi file, alat yang digunakan, dll.  Dalam proyek kami, ini berarti bahwa kami harus mendiskusikan alat untuk membuat konten dari bingkai gambar tangan, model 3D dan suara, dan kemudian editor video untuk menggabungkan semua ini bersama-sama.  Itu juga perlu untuk menyepakati bagian mana dari alur kerja yang akan dilakukan secara manual dan mana yang akan otomatis. <br><br>  Akibatnya, kami memutuskan yang berikut: <br><br><ul><li>  Bingkai yang digambar secara manual akan dibuat dalam Adobe Animate dengan resolusi 4440x2400 piksel. </li><li>  Model dan animasi 3D akan dibuat dalam Autodesk Maya dan ditampilkan secara manual, juga dengan resolusi 4440x2400 piksel </li><li>  File audio akan dibuat dalam format .wav dengan parameter 48KHz dan 16-bit </li><li>  Fragmen video pada awalnya akan dihasilkan secara otomatis, dan artis akan dapat mengubah bagian apa pun yang ia butuhkan (dengan beberapa pengecualian) </li><li>  Tahap akhir dari penjahitan dan pengkodean FMV akan otomatis </li></ul><br>  Untuk membuat alat seotomatis mungkin, kami menggunakan beberapa metode.  Python dipilih sebagai "lem" yang menghubungkan semuanya, karena diperluas dengan baik oleh berbagai perpustakaan, dan kodenya mudah ditulis dan dipelihara.  Kami juga mengambil keuntungan dari dukungan internal untuk manipulasi file platform-independen (menyalin, memindahkan, menghapus). <br><br><h2>  Python - memanggil file yang dapat dieksekusi, mendapatkan hasil </h2><br>  Pustaka subproses Python ideal bagi kami, karena memungkinkan Anda untuk mengubah eksekusi file yang dapat dieksekusi lainnya dan bahkan menunggu penyelesaian tugas mereka.  Ini memungkinkan Anda untuk mendapatkan kode yang dikembalikan oleh program dan mengakses buffer stdout &amp; stderr. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess <span class="hljs-comment"><span class="hljs-comment"># The command to execute command = 'SanExtract.exe -f -i credits.san -o \"C:/output_dir/\" ' # Execute the command via subprocess child = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE) # Wait for process to complete, returns stdout &amp; stderr buffers stdout, stderr = child.communicate() # Retrieve the return code from the process return_code = child.returncode</span></span></code> </pre> <br>  <em>Contoh berinteraksi dengan file yang dapat dieksekusi di Python</em> <br><br><h2>  Python - Win32 API </h2><br>  Win32 API sangat berguna karena memberi kami akses untuk mengirimkan pesan keyboard dan mouse dari Windows dari skrip.  Misalnya, Anda dapat membuat fungsi yang mengklik mouse pada koordinat X, Y layar tertentu: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> win32api <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClickXY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x,y)</span></span></span><span class="hljs-function">:</span></span> win32api.SetCursorPos((x,y)) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN,x,y,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP,x,y,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <em>Contoh simulasi klik mouse Python</em> <br><br>  Anda bahkan dapat mengirim acara keystroke ke keyboard (dengan atau tanpa pengubah): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> win32api <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> win32con <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PressKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(code, modifierCode=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> modifierCode: win32api.keybd_event(modifierCode, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) win32api.keybd_event(code, <span class="hljs-number"><span class="hljs-number">0</span></span>, win32con.KEYEVENTF_EXTENDEDKEY | <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) time.sleep(<span class="hljs-number"><span class="hljs-number">0.021</span></span>) win32api.keybd_event(code, <span class="hljs-number"><span class="hljs-number">0</span></span>, win32con.KEYEVENTF_EXTENDEDKEY | win32con.KEYEVENTF_KEYUP, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> modifierCode: win32api.keybd_event(modifierCode, <span class="hljs-number"><span class="hljs-number">0</span></span>, win32con.KEYEVENTF_KEYUP, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <em>Contoh Simulasi Keyboard Python</em> <br><br>  Ada banyak kemungkinan lain, tetapi contoh di atas sangat membantu untuk mencapai tujuan kami.  Anda dapat mengirim acara keyboard ke program apa pun yang aktif dan itu akan mulai mengetiknya, seolah-olah kita memasukkan sesuatu dari keyboard, termasuk menekan tombol panas. <br><br><h2>  Python - visi komputer untuk mengklik tombol </h2><br>  Pengalaman yang paling unik adalah penggunaan perangkat lunak visi komputer dalam alat-alat yang tidak dapat diotomatisasi melalui skrip internal.  Sebagian besar alat modern memiliki dukungan skrip, tetapi masih memerlukan intervensi pengguna.  Misalnya, 3D Studio Max memungkinkan Anda menjalankan file MAXScript dari baris perintah.  Dalam kasus kami, kami menjalankan skrip untuk mengimpor file 3D mesh secara otomatis, setelah itu 3D Studio Max memulai secara otomatis dan menampilkan kotak dialog Shape Import, di mana pengguna harus mengklik tombol: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/b3e/4f9/ddcb3e4f9a830a8e72d9697eacf19b74.png"></div><br>  <em>Contoh kotak dialog Bentuk Impor</em> <br><br>  Jadi - kami menulis skrip untuk otomatisasi, dan sekarang kami harus duduk di depan layar, menekan tombol?  Alih-alih duduk di keyboard dan menunggu jendela sembul muncul, kita dapat membuat skrip mengambil tangkapan layar, menggunakan ikatan OpenCV ke Python untuk menemukan templat gambar tombol dan secara otomatis mengkliknya.  Inilah yang tampak seperti template gambar untuk contoh yang dijelaskan di atas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1e/67c/af3/b1e67caf30b4ea94761063bb6ead063c.png"></div><br>  <em>Template Gambar untuk ok_button.png</em> <br><br>  Perlu dicatat bahwa template gambar berisi fitur tambahan (teks untuk "Objek Tunggal" dan "Banyak Objek").  Ini memungkinkan kami untuk mendapatkan hasil pencarian yang lebih deterministik.  Berikut ini adalah contoh skrip Python yang digunakan untuk mengklik secara otomatis pada lokasi yang ditemukan dari templat gambar: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cv2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ImageGrab <span class="hljs-comment"><span class="hljs-comment"># "Constants" TEMPLATE_THRESHOLD = 0.25 CLICK_OFFSET = 20 # Read the template image to search for template_image = cv2.imread('images/ok_button.png', 0) # Screenshot the current desktop and load it to a cv2 format screen = ImageGrab.grab() screen.save('screen.png') screen_image = cv2.imread('screen.png', 0) # Search for the template within the screenshot and retrieve search results match_result = cv2.matchTemplate(screen_image, template_image, cv2.TM_SQDIFF_NORMED) min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(match_result) # If below the threshold, it's likely we know where to click if min_val &lt; TEMPLATE_THRESHOLD: ClickXY(min_loc[0]+CLICK_OFFSET, min_loc[1]+CLICK_OFFSET)</span></span></code> </pre> <br>  <em>Contoh mengklik elemen tampilan menggunakan OpenCV, ditulis dengan Python</em> <br><br>  Semua contoh di atas didasarkan pada Python.  Tetapi ada kalanya kita membutuhkan kontrol yang lebih tepat atas sistem jendela OS Windows.  Ini mendorong kami untuk mengembangkan alat asli menggunakan API Windows Automation. <br><br><h2>  Windows Native (C ++) - Windows Automation API </h2><br>  Windows Automation API menyediakan akses ke Microsoft Accessibility API (MSAA) yang lama serta API Otomasi Microsoft UI.  Anda dapat membaca lebih lanjut tentang ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman Microsoft</a> . <br><br>  Sebagai hasilnya, kami mencapai kenyataan bahwa kami dapat membuat permintaan ke elemen tertentu dari antarmuka Windows (tombol, bidang teks, tab, item menu), mencari tahu di mana elemen-elemen ini secara spasial terletak di layar dan klik / berinteraksi dengannya.  Windows SDK juga memiliki alat pengujian yang memungkinkan Anda melihat properti mana yang tersedia.  Mereka memungkinkan kami untuk mencari tahu apa yang dapat diotomatisasi di setiap program tertentu. <br><br>  Aplikasi Inspect.exe cukup berguna untuk menampilkan hierarki manajemen jendela program;  itu memberikan gambaran kasar tentang di mana objek seperti kontrol menu berada, dan bagaimana merujuk ke elemen jendela menggunakan panggilan API otomatisasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f2/d3f/650/0f2d3f650f30c4982f10d9d31b94c35c.png"></div><br>  <em>Contoh Inspect.exe</em> <br><br>  Setelah Anda mempelajari hierarki kontrol program Windows, Anda akan tahu cara menemukannya dari pegangan jendela utama dan mempelajari cara mengklik elemen yang berbeda melalui API: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;WinUser.h&gt; #include &lt;UIAutomation.h&gt; // Click on a sub-menu item given the Window &amp; Menu handles. void ClickSubMenu(HWND hwnd, HMENU hmenu, const char *pMenuName) { // Iterate through the menu items of the window int menu_item_count = GetMenuItemCount(hmenu); for(int menu_id = 0; menu_id &lt; menu_item_count; ++menu_id) { char menu_name[MAX_PATH]; int len = GetMenuString(hmenu, menu_id, reinterpret_cast&lt;LPSTR&gt;(&amp;menu_name[0]), sizeof(menu_name), MF_BYPOSITION); // Look for the specific menu you're searching for and click it // Make sure to set the window active before doing it... if(!strcmp(pMenuName, menu_name)) { // now get the rect and click the center RECT rect; BOOL success = GetMenuItemRect(hwnd, hmenu, menu_id, &amp;rect); if(success) { SetActiveWindow(hwnd); POINT point = GetMiddlePoint(rect); SetCursorPos(point.x, point.y); mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTDOWN, point.x, point.y, 0, 0); mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTUP, point.x, point.y, 0, 0); Sleep(DO_TASK_INTERVAL_WAIT_MS); } } } }</span></span></span></span></code> </pre> <br>  <em>Contoh mendorong kontrol jendela di C ++</em> <br><br>  Dan tentu saja, meneruskan penekanan tombol ke jendela aktif juga sederhana: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;WinUser.h&gt; #include &lt;UIAutomation.h&gt; // Type the character string to the given window handle static void TypeCharacters(HWND window_handle, const char *pString) { int len = strlen(pString); for(int count = 0; count &lt; len; ++count) { SendMessage(window_handle, WM_CHAR, (WPARAM)pString[count], (LPARAM)0); Sleep(CHARACTER_REPEAT_INTERVAL_MS); } }</span></span></span></span></code> </pre> <br>  <em>Contoh Simulasi Keyboard C ++</em> <br><br>  Tentu saja, API ini memiliki lebih banyak fitur.  Saya menemukan bahwa berkat alat Inspect.exe, Anda dapat menjelaskan elemen jendela program yang dapat diakses. <br><br><h2>  Format Teks Menengah </h2><br>  Bagian dari alur kerja kami adalah menyimpan file dalam bentuk teks dan mengubah nilai dalam file teks ini.  Pada akhirnya, alat-alat ini memiliki antarmuka pengguna untuk mengubah keadaan data tambahan.  Dan jika Anda tahu apa yang harus menjadi data tambahan ini, maka tidak perlu bekerja dengan alat ini, cukup ubah data tambahan.  Kuncinya adalah mengetahui cara memanipulasi data pendukung ini;  ketika mengubah format file eksklusif, ini bisa jadi menantang.  Bukankah lebih baik jika semua orang memiliki file teks sederhana yang dapat Anda kerjakan? <br><br>  Caranya adalah dengan menemukan cara di sekitar format file berpemilik yang digunakan oleh sebagian besar alat.  Solusinya biasanya adalah dengan menggunakan opsi Impor dan Ekspor yang ditemukan di sebagian besar alat komersial modern.  Berikut ini beberapa contohnya: <br><br>  Adobe Premiere Pro menyimpan file dalam format berpemilik, tetapi Anda dapat mengimpor / mengekspor proyek sebagai Final Cut Pro XML.  Setelah mengekspor ke XML, Anda dapat mengubah XML dengan cara yang kami butuhkan dan mengimpor kembali proyek kembali ke Adobe Premiere Pro. <br><br>  Contoh lain adalah koreksi referensi tekstur yang digunakan dalam format mesh 3D Autodesk 3D Studio Release 3 yang usang. Saat mengimpor file mesh asli, kami menyimpan mesh yang baru dikonversi ke file .fbx menengah menggunakan karakter ASCII.  Dalam format ini, Anda dapat memproses file teks dan mengganti semua baris tautan tekstur dengan yang benar. <br><br>  Adobe Animate / Flash cukup lucu karena ternyata file .fla sebenarnya sedikit “rusak” .zip.  Dalam bentuk terkompresi, mereka disimpan dalam format XFL, yang dapat merujuk ke objek XFL lainnya (misalnya, bitmap) dari folder lokal.  Insinyur utama Double Fine Oliver Franzke membuat skrip Python yang dimodifikasi untuk mengemas / unzip file .fla menggunakan ZIP sehingga kita dapat membuat / memodifikasi file-file ini. <br><br><h1>  Contoh Penggunaan </h1><br><h2>  Studio 3D Maks </h2><br>  Versi modern 3D Studio Max digunakan untuk mengimpor file .prj asli ke dalam adegan dan untuk menyimpan dalam format ASCII .fbx.  Untuk setiap file .prj yang perlu dikonversi, file MaxScript (.ms) secara otomatis dihasilkan dari skrip Python, yang terlihat seperti ini: <br><br><pre> <code class="bash hljs">importFile <span class="hljs-string"><span class="hljs-string">"G:\FullThrottle_Backup\FullThrottle_SourceAssets\BENBIKE.PRJ"</span></span> <span class="hljs-comment"><span class="hljs-comment">#noPrompt</span></span></code> </pre> <br>  <em>Contoh mengimpor model 3d menggunakan MaxScript</em> <br><br>  Setelah itu, file .ms ini hanya dipanggil oleh perintah Python untuk dijalankan di 3dsmax.exe: <br><br><pre> <code class="bash hljs">3dsmax.exe -U MAXScript <span class="hljs-string"><span class="hljs-string">"C:\FullThrottleRemastered\import_prj.ms"</span></span></code> </pre> <br>  <em>Contoh perintah konsol untuk memanggil file yang dapat dieksekusi dengan file MaxScript yang ditentukan</em> <br><br>  Seperti disebutkan di atas, dalam hal ini, 3D Studio Max membuka kotak dialog yang harus Anda klik.  Bundel OpenCV dengan Python membantu mengklik tombol di jendela ini sehingga file asli diimpor tanpa campur tangan pengguna.  Setelah mengimpor file, serangkaian tombol menu ditekan (menggunakan win32api Python) untuk meluncurkan file MAXScript lain yang mengekspor model sebagai file .fbx dalam format ASCII.  Karena .fbx disimpan sebagai file teks biasa, semua dependensi dependensi tekstur model digantikan oleh tautan ke gambar dalam format modern.  Kemudian, file .fbx yang dimodifikasi kembali secara otomatis dimuat ke 3DSMax dan diekspor sebagai file .max.  Pada titik ini, file .max dapat dikirim ke artis untuk remastering. <br><br><h2>  Adobe Animate / Flash </h2><br>  Adobe Animate / Flash digunakan untuk mem-remaster semua sumber daya FMV yang digambar tangan.  Kami mengambil frame yang digambar tangan asli (berukuran 320x200 piksel) yang ditemukan oleh alat SanWrangler dan menggunakannya sebagai "gambar rakitan".  Skala gambar diperbesar agar sesuai dengan 4440x2400 piksel, setelah itu file .fla dihasilkan secara otomatis menggunakan skrip Python. <br><br>  Maka itu sudah cukup untuk secara otomatis menghasilkan file .fla dari awal, menggunakan pengetahuan kita tentang format XFL Adobe Animate / Flash.  Kami dapat menggunakan tool kit yang sudah dibuat oleh Oliver Franzke untuk menghasilkan gambar rakitan dari file animasi yang digambar tangan. <br><br><h2>  Adobe Premiere Pro </h2><br>  API Windows Automation benar-benar membantu kami menentukan kontrol Premiere Pro yang ada di layar.  Dalam beberapa kasus, mereka tidak memiliki tombol cepat.  Setelah menerima koordinat dari item menu, perlu untuk memindahkan kursor ke koordinat ini dan mengirim acara klik mouse. <br><br>  Semua ini hebat, tetapi beberapa kontrol ditampilkan dengan cara lain, dan karenanya tidak terlihat oleh Windows Automation API.  Untuk kasus ini, kami memutuskan untuk menggunakan sekelompok OpenCV dan Python untuk dapat menggunakan OpenCV dalam lingkungan scripting.  Ini sangat berguna ketika bekerja dengan Adobe Premiere Pro: meskipun memiliki dukungan parsial untuk skrip JavaScript, jenis kontrol yang diperlukan tidak tersedia melalui API. <br><br>  Selain itu, file proyek Adobe Premiere Pro disimpan dalam format biner berpemilik.  Oleh karena itu, kami tidak bisa secara ajaib membuat file Premiere Pro, tetapi kami dapat menggunakan fungsi impor, yang memungkinkan kami untuk mengimpor data ke file Final Cut Pro, yang memiliki format XML.  Maka itu sudah cukup untuk menghasilkan file XML yang benar, memposisikan semua sumber daya pada timeline dengan tepat, dan kemudian secara otomatis mengimpor .xml Final Cut Pro ini untuk mengonversinya ke format yang diinginkan.  Lalu kita bisa meletakkan frame yang diekspor dalam antrian otomatis sehingga kita bisa menggabungkannya menjadi video jadi. <br><br><h1>  Semua tahapan </h1><br>  Di bawah ini adalah diagram blok umum yang menunjukkan semua bagian otomatis dari alur kerja baru.  Setiap segmen otomatis dikelilingi oleh persegi panjang bulat dengan informasi tambahan tentang teknik otomasi yang digunakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f26/2c7/7cf/f262c77cf9d06f1fb6828e356ce40cc8.png"></div><br>  <em>Diagram Alir Otomasi FMV Remaster yang Disederhanakan</em> <br><br>  Anda akan melihat bahwa sebagian besar pekerjaan dengan Adobe Premiere Pro memerlukan penggunaan Python, serta kode Windows asli khusus.  Alasannya adalah struktur kompleks jendela Premiere Pro, serta kebutuhan untuk menggunakan Windows Automation API asli untuk memastikan interaksi yang tepat dengan semua jendela anak yang tergantung pada aplikasi ini. <br><br><h1>  Semuanya bersama </h1><br>  Dengan menggunakan metode yang dijelaskan di atas, kami dapat mengonfigurasi beberapa mesin otomasi untuk membagi pekerjaan pada semua video menjadi beberapa bagian.  Juga, Slack Bot diintegrasikan ke dalam alur kerja untuk mengirim umpan balik tentang otomatisasi ke saluran Slack kami sesuai dengan status video yang melewati pipa pemrosesan, sehingga kami tahu kapan ada masalah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b5/36d/f19/9b536df197475f6235282ac084c2efc8.gif"></div><br>  <em>Contoh Otomatisasi Adobe Premiere Pro</em> <br><br><h1>  Masalah yang kita hadapi </h1><br>  Semua ini terdengar hebat, tetapi pada kenyataannya, ketika mengimplementasikan proyek, kami mengalami masalah.  Saya hanya akan mencantumkan poin utama. <br><br>  1) Iterasi pencampuran audio jadi.  Remastering semua file audio dilakukan secara bertahap.  Karena itu, ketika kami memiliki, misalnya, efek suara "BOOM!", Sound engineer tidak tahu di mana memasukkannya ke dalam campuran audio, jadi ia harus menunggu video dikodekan untuk mengetahui apa yang salah. <br><br>  2) Penyimpanan file perantara yang tidak terkompresi.  Bingkai disimpan dalam format terkompresi hingga saat terakhir pengkodean ke dalam video selesai.  Oleh karena itu, perlu untuk menyimpan sejumlah besar frame dalam penyimpanan lokal, beberapa di antaranya disimpan dalam sistem kontrol versi.  Peningkatan volume yang disimpan seperti itu sangat nyata dan bisa sangat mahal ketika menggunakan beberapa sistem kontrol versi (kami menggunakan Perforce). <br><br>  3) Waktu pimpin.  Bagian padat dari alur kerja diotomatisasi, dan ini memungkinkan para insinyur untuk melakukan hal-hal lain.  Namun, waktu yang dibutuhkan untuk membuat satu video bisa sangat lama.  Bagian yang paling memakan waktu adalah encoding frame dalam resolusi 4k.  Kami memiliki cara untuk menyelidiki keadaan sumber daya di dalam Perforce untuk memahami langkah-langkah apa yang perlu dilakukan lagi, tetapi metode ini tidak dibagi menjadi beberapa bagian seperti yang kita inginkan. <br><br><h1>  Langkah selanjutnya </h1><br>  Ya, artikel itu ternyata sangat banyak!  Meskipun implementasi alur kerja ini cukup spesifik untuk proyek ini, saya percaya bahwa metode otomatisasi tertentu dapat digunakan dalam mengembangkan game apa pun.  Setelah menemukan videonya, Anda dapat mempertimbangkan topik terkait - memainkan FMV selama eksekusi game.  Ini termasuk masalah seperti penyandian aliran audio multibahasa, serta sinkronisasi bingkai ketika memutar FMV asli.  Tunggu bagian ketiga artikel ini! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id422367/">https://habr.com/ru/post/id422367/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422353/index.html">Petunjuk TensorFlow Object Detection API</a></li>
<li><a href="../id422357/index.html">Pembelajaran mendalam untuk menentukan gaya dan genre lukisan</a></li>
<li><a href="../id422361/index.html">Sindrom perusahaan</a></li>
<li><a href="../id422363/index.html">Konferensi PyCon Russia 2018: video semua laporan dan presentasi</a></li>
<li><a href="../id422365/index.html">Yandex mengajukan keluhan terhadap keputusan pengadilan untuk menghapus tautan ke konten bajakan</a></li>
<li><a href="../id422369/index.html">Merancang dasbor untuk situs web analitik e-commerce Bagian 2: Email Newsletter. Dasbor strategis</a></li>
<li><a href="../id422371/index.html">Review sepeda listrik Twitter TW-E9L</a></li>
<li><a href="../id422373/index.html">Kami mengundang Anda ke pertemuan sumber terbuka pada bulan September (Moskow dan St. Petersburg)</a></li>
<li><a href="../id422375/index.html">Kontrak berbeda, atau untuk apa Anda mendaftar</a></li>
<li><a href="../id422377/index.html">ESP8266 + FLProg - Parameter sistem pengguna dan sinkronisasi dengan server waktu yang tepat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>