<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïØÔ∏è üÖ±Ô∏è üëá Bugs lors de l'utilisation du clavier syst√®me üöÅ üë≤üèæ üçå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En interagissant avec l'application, nous activons √† un moment donn√© le clavier du syst√®me pour taper un message ou remplir les champs requis. Avez-vo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bugs lors de l'utilisation du clavier syst√®me</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462515/">  <em>En interagissant avec l'application, nous activons √† un moment donn√© le clavier du syst√®me pour taper un message ou remplir les champs requis.</em>  <em>Avez-vous rencontr√© des situations o√π le clavier est affich√©, mais il n'y a pas de champ pour entrer un message, ou vice versa - il y a un clavier, o√π saisir du texte, n'est pas visible?</em>  <em>Les bogues peuvent √™tre li√©s √† des probl√®mes dans une application sp√©cifique, ainsi qu'√† des lacunes g√©n√©rales du clavier syst√®me.</em> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Konstantin Mordan</em></a> <em>, un d√©veloppeur iOS de Mail.ru, a tout vu dans son travail: apr√®s avoir analys√© les m√©thodes de contr√¥le du clavier dans iOS, il a d√©cid√© de partager les principaux bugs et approches qu'il a utilis√©s pour les d√©tecter et les corriger.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fb/wc/xg/fbwcxgdtopdtlj8_u7rkj1vnmne.jpeg" width="400"></div><br><br>  <i>Attention: sous la coupe, nous mettons beaucoup de gifs pour bien montrer les bugs.</i>  <i>Vous trouverez encore plus d'exemples dans le reportage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vid√©o</a> de Konstantin sur AppsConf.</i> <br><a name="habracut"></a><br><h1>  Impl√©mentation d'un appel clavier syst√®me </h1><br>  Commen√ßons par comprendre comment impl√©menter un appel au clavier en g√©n√©ral. <br><br>  Imaginez que vous d√©veloppez une application dont la t√¢che est d'assembler Aika (un personnage de South Park) en un Canadien entier √† l'aide du clavier.  Lorsque vous appuyez sur Aiku sur le ventre, le clavier part, soulevant ainsi les jambes de notre h√©ros √† la t√™te. <br><br>  Pour impl√©menter la t√¢che, vous pouvez utiliser <i>InputAccessoryView</i> ou traiter les notifications syst√®me. <br><br><h2>  InputAccessoryView </h2><br>  Regardons la premi√®re option. <br><br>  Dans le ViewController, cr√©ez une vue qui montera avec le clavier et donnez-lui un cadre.  Il est important que cette vue ne soit pas ajout√©e en tant que sous-vue.  Ensuite, nous <em>rempla√ßons les</em> propri√©t√©s <em>canBecomeFirstResponder</em> et retournons true.  Apr√®s avoir red√©fini la propri√©t√© UIResponder - <em>inputAccessoryView</em> et y mettre la vue.  Pour fermer le clavier, ajoutez <em>tapGesture</em> et dans son gestionnaire, <em>r√©initialisez le premier R√©pondeur</em> , que nous avons cr√©√© View. <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tummyView: <span class="hljs-type"><span class="hljs-type">UIView</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> frame = <span class="hljs-type"><span class="hljs-type">CGRect</span></span>(x: x, y: y, width: width, height: height) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v = <span class="hljs-type"><span class="hljs-type">TummyView</span></span>(frame: frame) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canBecomeFirstResponder: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input <span class="hljs-type"><span class="hljs-type">AccessoryView</span></span>: <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tummyView } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tapHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { tummyView.resignFirstResponder ( ) } }</code> </pre> <br>  La t√¢che est termin√©e et le syst√®me lui-m√™me traite les changements d'√©tat du clavier, l'affiche et ouvre la vue, qui en d√©pend. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ew/mu/nd/ewmundnnrpbdgjgwvk_frx4qv6o.gif" width="200"></div><br><br><h2>  Traitement des notifications syst√®me </h2><br>  Dans le cas du traitement des notifications, nous devrons traiter nous-m√™mes les notifications des groupes suivants: <br><br><ul><li>  quand le clavier sera / √©tait affich√©: keyboardWillShowNotification, keyboardDidShowNotification; </li><li>  quand le clavier sera / √©tait cach√©: keyboardWillHideNotification, keyboardDidHideNotification; </li><li>  lorsque le cadre du clavier sera / a √©t√© modifi√©: keyboardWilChangeFrameNotification, keyboardDidChangeFrameNotification. </li></ul><br>  Pour impl√©menter notre cas, prenons <em>keyboardWilChangeFrameNotification</em> , car cette notification est envoy√©e √† la fois lorsque le clavier est affich√© et lorsqu'il est masqu√©. <br><br>  Nous cr√©ons un <em>clavierTracker,</em> nous nous y abonnons pour recevoir une notification <em>keyboardWillChangeFrame</em> , et dans le gestionnaire, nous obtenons le cadre du clavier, le convertissons du syst√®me de coordonn√©es d'√©cran au syst√®me de coordonn√©es de la fen√™tre, calculons la hauteur du clavier et modifions la valeur Y de la vue, qui devrait √™tre augment√©e par le clavier, √† cette hauteur. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enable</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { notificationCenter.add0observer(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, seletor: #selector( keyboardWillChangeFrame), name: <span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardWillChangeFrameNotification, object: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardWillChangeFrame</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screenCoordinatedKeyboardFrame = (userInfo [ <span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardFrameEndUserInfoKey ] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSValue</span></span> ) .cgRectValue <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyboardFrame = window.convert ( screenCoordinatedKeyboardFrame, from: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windowHeight = window.frame.height <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyboardHeight = windowHeight - keyboardFrame.minY delegate.keyboardWillChange ( keyboardHeight ) } }</code> </pre> <br>  Sur ce, notre t√¢che est termin√©e, le clavier se l√®ve, ramassant Ike au Canadien. <br><br>  Comme nous pouvons le voir, la mise en ≈ìuvre du travail avec le clavier est assez facile dans les deux cas, donc chacun est libre de choisir la m√©thode appropri√©e par lui-m√™me.  Dans notre projet, nous avons fait un choix en faveur des notifications, donc d'autres exemples et informations seront associ√©s au traitement des notifications. <br><br><h2>  Recherche de bugs </h2><br>  Si la fa√ßon d'appeler le clavier est si simple, alors d'o√π viennent les bugs?  Bien s√ªr, si l'application reproduit uniquement le script d'ouverture et de fermeture du clavier, il n'y aura aucun probl√®me.  Mais si vous changez le cours habituel des choses, rappelez-vous que non seulement notre application peut utiliser le clavier, mais aussi d'autres, et que l'utilisateur peut √©galement basculer entre eux, alors les surprises ne peuvent √™tre √©vit√©es. <br><br>  Regardons un exemple.  Pour ce faire, utilisez notre application avec Ike: ouvrez le clavier, passez √† Notes, imprimez quelque chose et revenez √† l'application. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zm/nr/4n/zmnr4nm4u8tph3bf86jkr05ix5k.gif" width="200"></div><br><br>  Quels probl√®mes sont d√©j√† visibles?  Tout d'abord, il n'y a pas de clavier dans l'App Switcher, bien que lorsque vous avez r√©duit l'application, c'√©tait, et au lieu de cela, d'autres contenus sont visibles.  Deuxi√®mement, lorsque vous revenez √† l'application, le clavier n'est toujours pas l√† et les jambes d'Ike tombent sur l'√©cran. <br><br>  Voyons les raisons de ce comportement.  Comme nous nous en souvenons tous du diagramme du cycle de vie de l'application, les transitions d'une application d'un √©tat actif √† un √©tat inactif d'abord au premier plan puis en arri√®re-plan prennent du temps. <br><br>  Qu'en est-il du cycle de vie du clavier?  Sous iOS, pour chaque unit√© de temps, le clavier ne peut appartenir qu'√† une seule des applications en cours d'ex√©cution, mais toutes les applications sign√©es y re√ßoivent des notifications sur les modifications de l'√©tat du clavier. <br><br>  Lors du passage d'une application √† une autre, le syst√®me r√©initialise son premier r√©pondeur, qui agit comme un d√©clencheur pour masquer le clavier.  Le syst√®me envoie d'abord une notification keyboardWillHide pour que le clavier disparaisse, puis keyboardDidHideNotification.  La notification vole vers la deuxi√®me application.  Dans la nouvelle application, nous ouvrons le clavier: le syst√®me envoie keyboardWillShowNotification pour que le clavier apparaisse, puis envoie le keyboardDidShowNotification - une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©mo</a> , avec les phases du cycle. <br><br><img src="https://habrastorage.org/webt/gk/th/5c/gkth5chvrkyewmvhdrpc7eito9q.jpeg"><br><br>  Si vous regardez un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fragment du rapport</a> (√† partir de 8:39), vous verrez le moment o√π, apr√®s avoir cach√© le clavier, le syst√®me envoie keyboardDidHideNotification pour mettre la premi√®re application dans un √©tat inactif.  Lorsque vous basculez vers l'application sportive et lancez le clavier, le syst√®me envoie keyboardWillShowNotification.  Mais comme le processus de commutation et de d√©marrage est rapide et que le temps de transition entre les phases du cycle de vie peut √™tre plus long, la notification re√ßue traitera non seulement la demande de sport, mais √©galement la demande de bi√®re, qui n'a pas encore r√©ussi √† passer √† l'arri√®re-plan. <br><br>  Apr√®s avoir compris les raisons, trouvons maintenant une solution au probl√®me avec Ike. <br><br><h3>  Mauvaise d√©cision </h3><br>  La premi√®re chose qui me vient √† l'esprit est l'id√©e de se d√©sabonner / s'abonner aux notifications lors de la r√©duction / maximisation d'une application via activer / d√©sactiver KeyboardTracker. <br><br>  Pour vous d√©sinscrire, nous utilisons la m√©thode applicationWillResignActive ou un gestionnaire de notification similaire du syst√®me; pour vous abonner, nous utilisons applicationDidBecomeActive, mais pour ne rien manquer, nous notifierons √©galement la m√©thode applicationWillEnterForeground, qui est appel√©e lorsque l'application entre au premier plan mais ne devient pas encore active. <br><br>  Lorsque vous d√©marrez le clavier dans l'application, tout va probablement r√©ussir, mais avec des tests plus complexes, par exemple, ouvrir le clavier et essayer d'enregistrer la num√©rotation vocale, la solution ne fonctionnera pas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dy/0b/_e/dy0b_eiomhqtkuqimnsdew_es-c.gif" width="200"></div><br><br>  Qu'est-il arriv√©?  Apr√®s avoir cliqu√© sur le bouton de num√©rotation des messages vocaux, l'application firstResponder a √©t√© r√©initialis√©e, le clavier a √©t√© ferm√©, la m√©thode applicationWillResignActive a √©t√© appel√©e et nous nous sommes d√©sabonn√©s.  Apr√®s la fermeture de l'alerte, le syst√®me a restaur√© l'√©tat de l'application, mais avant l'appel de la m√©thode applicationWillEnterForeground, et en particulier de l'applicationDidBecomeActive. <br><br><h3>  Bonne d√©cision </h3><br>  Une autre solution est l'utilisation d'un bouillon de protection (Bool). <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wasTummyViewFirstResponderBeforeApp0idEnterBackground <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willResignActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { wasTextFieldFirstResponderBeforeAppDidEnterBackground = tummyView.isFirstResponder } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willEnterForeground</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> wasTextFieldFirstResponderBeforeAppDidEnterBackground { <span class="hljs-type"><span class="hljs-type">UIView</span></span>.performWithourAnimation { tummyView.becomeFirstResponder ( ) } } }</code> </pre> <br>  Nous nous souvenons si le clavier a √©t√© ouvert avant le sujet, comment l'application a cess√© d'√™tre active et dans la m√©thode applicationWillEnterForeground, nous restaurons l'√©tat pr√©c√©dent.  La seule chose qui reste √† corriger est le trou dans le s√©lecteur d'application. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jc/sl/oc/jcsloczny6akuricp8x0bzwvbxo.jpeg" width="400"></div><br><br><h2>  s√©lecteur d'application </h2><br>  Le s√©lecteur d'application affiche les instantan√©s d'application que le syst√®me fait une fois l'application mise en arri√®re-plan.  La capture d'√©cran montre que l'instantan√© de notre application a √©t√© r√©alis√© √† un moment o√π le clavier est d√©j√† utilis√© par une autre application.  Ce n'est pas critique, mais cela ne prend que quelques clics pour y rem√©dier. <br><br><h3>  Bonne solution </h3><br>  La solution peut √™tre emprunt√©e √† des applications bancaires qui ont appris √† cacher des donn√©es sensibles, et √† lire √©galement aupr√®s d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apple</a> . <br><br>  Vous pouvez masquer les donn√©es dans la m√©thode applicationDidEnterBackground, flouter et afficher l'√©cran de d√©marrage, et dans la m√©thode applicationWillEnterForeground, revenir √† la hi√©rarchie de vues habituelle. <br><br>  Cette option ne nous convient pas, car au moment o√π la m√©thode applicationDidEnterBackground est appel√©e, notre application n'a plus de clavier. <br><br><h3>  Bonne d√©cision </h3><br>  Nous utiliserons les m√©thodes famili√®res willResignActive, willEnterForeground et didBecomeActive. <br><br>  Bien que notre application dispose toujours d'un clavier, vous devrez cr√©er votre propre instantan√© de l'application dans la m√©thode willResignActive et le placer dans la hi√©rarchie. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willResignActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notificaton: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyWindow = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.keyWindow imageView = <span class="hljs-type"><span class="hljs-type">UIImageView</span></span>( frame: keyWindow.bounds) imageView.image = snapshot ( ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastSubview = keyWindow.subviews.last lastSubview( imageView) }</code> </pre> <br>  Dans les m√©thodes willEnterForeground et didBecomeActive, nous restaurons la hi√©rarchie des vues et supprimons notre instantan√©. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willEnterForeground</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { imageView.removeFromSuperview( ) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didBecomeActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { imageView.removeFromSuperview( ) }</code> </pre> <br>  En cons√©quence, nous avons corrig√© les deux cas: dans le s√©lecteur d'application, une belle image et le clavier ne sautent plus lors de la commutation.  Il semblerait que ce ne sont pas des choses aussi importantes, mais pour le d√©veloppement de produits, ces points sont extr√™mement importants. <br><br><h2>  Mauvaise nouvelle </h2><br>  Notre solution r√©ussie au probl√®me d'Ike concernait le cas o√π le clavier √©tait ouvert avant de minimiser l'application.  Si la commutation se produit sans √©tendre le clavier, nous verrons √† nouveau que les jambes de notre Ike sont tomb√©es en dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zm/nr/4n/zmnr4nm4u8tph3bf86jkr05ix5k.gif" width="200"></div><br><br>  Ce n'est pas seulement un probl√®me pour notre application, ce comportement est √©galement observ√© pour Facebook, qui fonctionne avec les notifications, et m√™me pour iMessage, qui utilise inputAccessoryView pour contr√¥ler le clavier.  Cela est d√ª au fait qu'avant de passer en arri√®re-plan, les applications parviennent √† traiter les notifications du clavier d'autres personnes. <br><br><h2>  fermeture interactive du clavier </h2><br>  Ajoutez des fonctionnalit√©s √† notre application avec Ike, en apprenant au programme √† masquer le clavier de mani√®re interactive. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/cy/1g/g6cy1gparlfmqc0abfaz7rd_rr0.gif" width="200"></div><br><br><h3>  Mauvaise d√©cision </h3><br>  Une fa√ßon de rendre cette fonctionnalit√© consiste √† modifier le cadre de la vue du clavier.  Nous cr√©ons panGestureRecognizer, dans son gestionnaire, nous calculons la nouvelle valeur de la coordonn√©e Y pour le clavier, en fonction de la position de notre doigt, trouvons la vue du clavier et la mettons √† jour avec la valeur de la coordonn√©e Y. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">panGestureHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> yPosition: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = value keyboardView( )?.frame.origin.y = yPosition }</code> </pre> <br>  Le clavier est affich√© dans une fen√™tre distincte, vous devez donc parcourir la totalit√© du tableau de fen√™tres dans l'application, v√©rifier pour chaque √©l√©ment du tableau s'il s'agit d'une fen√™tre de clavier et, si c'est le cas, en obtenir une vue qui montre le clavier. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windows = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.windows <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> view = windows.first { (window) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keyboardView( fromWindow: window) != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view }</code> </pre> <br>  Malheureusement, cette solution ne fonctionnera pas normalement sur iPhone X et sup√©rieur, car lorsque vous d√©placez votre doigt, vous pouvez l√©g√®rement toucher l'indicateur inf√©rieur, qui est responsable de la r√©duction de l'application.  Apr√®s cela, le masquage interactif cesse de fonctionner. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eg/-o/iv/eg-oiv8yrssufcejelvxqj4ksrq.gif" width="200"></div><br><br>  Le probl√®me r√©side dans le tableau des fen√™tres. <br><br><img src="https://habrastorage.org/webt/vc/u6/9o/vcu69oekot0zgl31iikyy_0refo.jpeg" width="600"><br><br>  Apr√®s le geste, le syst√®me cr√©e une nouvelle fen√™tre de clavier au-dessus de celle existante.  C'est impensable, mais vrai.  En cons√©quence, il s'av√®re que le tableau contient deux fen√™tres de clavier avec les m√™mes coordonn√©es, mais la premi√®re est masqu√©e. <br><br><img src="https://habrastorage.org/webt/pp/0v/ha/pp0vhay6ionyekifnsg-9jvnpzg.jpeg"><br><br>  Il s'av√®re que, en parcourant le tableau des fen√™tres, nous trouvons la premi√®re qui remplit les conditions, et commen√ßons √† travailler avec, malgr√© le fait qu'elle soit cach√©e. <br><br>  Comment est-ce r√©solu?  Tourner un tableau de fen√™tres. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">panGeastureHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> yPosition: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">0.0</span></span> keyboardView( )?.frame.origin.y = yPosition } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windows = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.windows.reversed( ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> view = windows.first { (window) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keyboardView( fromWindow: window) != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view }</code> </pre> <br><h2>  Fonctionnalit√©s du clavier sur iPad </h2><br>  Le clavier de l'iPad a un √©tat non ancr√© en plus de son √©tat habituel.  L'utilisateur peut le d√©placer sur l'√©cran, le diviser en deux parties et m√™me lancer l'application en mode slide over (au dessus de l'autre).  Bien s√ªr, il est important que dans tous ces modes le clavier fonctionne sans bugs. <br><br>  V√©rifions notre Hayke. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y1/4x/l5/y14xl5geuyxmkubopbkabplwbz4.gif"></div><br><br>  H√©las, ce n'est pas le cas actuellement.  Une fois que l'utilisateur a commenc√© √† d√©placer le clavier sur l'√©cran, les jambes d'Ike s'envolent au-dessus de sa t√™te et n'apparaissent en place qu'apr√®s la prochaine ouverture du clavier.  Essayons de le r√©parer sur un cas avec un clavier divis√©. <br><br><h3>  Raisons </h3><br>  Commen√ßons par analyser les notifications.  Apr√®s avoir cliqu√© sur le bouton fractionn√©, nous obtenons deux groupes de notifications - keyboardWillChangeFrameNotification, keyboardWillHideNotification, keyboardDidChangeFrameNotification, keyboardDidHideNotification.  La diff√©rence entre les groupes r√©side uniquement dans les coordonn√©es du clavier. <br><br>  Lorsque nous cliquons sur le bouton partag√©, le clavier diminue et le premier groupe de notifications arrive.  Lorsque le clavier s'est s√©par√© et est mont√© - nous avons re√ßu un deuxi√®me pack de notifications. <br><br>  L'important est que nous recevions des notifications indiquant que le clavier a disparu, mais pas qu'il s'affiche.  Ceci, soit dit en passant, est un autre avantage en faveur de l'utilisation de keyboardWillChangeFrameNotification. <br><br>  Pourquoi, alors, les jambes d'Ike s'envolent-elles d√®s que nous commen√ßons √† d√©placer le clavier sur l'√©cran? <br><br>  √Ä ce stade, le syst√®me nous envoie un keyboardWillChangeFrameNotification, mais les coordonn√©es qui s'y trouvent sont (0,0, 0,0, 0,0, 0,0), car le syst√®me ne sait pas √† quel point le clavier se trouvera une fois le mouvement termin√©. <br><br>  Si vous substituez des z√©ros dans le code actuel qui g√®re la modification du cadre du clavier, il s'av√®re que la hauteur du clavier est √©gale √† la hauteur de la fen√™tre.  C‚Äôest la raison pour laquelle les jambes d‚ÄôIke s‚Äô√©chappent de l‚Äô√©cran. <br><br><h3>  Bonne d√©cision </h3><br>  Pour r√©soudre notre probl√®me, nous allons d'abord apprendre √† comprendre quand le clavier est en mode non ancr√© et que l'utilisateur peut le d√©placer sur l'√©cran. <br><br>  Pour ce faire, il suffit de comparer la hauteur de la fen√™tre et le clavier maxY.  S'ils sont √©gaux, alors le clavier dans son √©tat normal, si maxY est inf√©rieur √† la hauteur de la fen√™tre, alors l'utilisateur d√©place le clavier.  Par cons√©quent, le code suivant appara√Æt dans keyboardTracker: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { notificationCenter.addObserver( <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, selector:#selector( keyboardWillChangeFrame), name:<span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardWillChangeFrameNotification, object:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardWillChangeFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screenCoordinatedKeyboardFrame = (userInfo[<span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardFrameEndUserInfoKey] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSValue</span></span>).cgRectValue <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leyboardFrame = window.convert ( screenCoordinatedKeyboardFrame, from: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windowHeight = window.frame.height <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyboardHeight = windowHeight - keyboardFrame.minY <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isKeyboardUnlocked = isIPad ( ) &amp;&amp; keyboardFrame/maxY &lt; windowHeight <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isKeyboardUnlocked { keyboardHeight = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } delegate.keyboardWillChange ( keyboardHeight) } }</code> </pre> <br>  Nous avons personnalis√© la hauteur √† z√©ro, et maintenant avec le mouvement du clavier, les jambes d'Ike descendent et y sont fix√©es. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/uv/u_/txuvu_-lhk01nhlzbcyfxc8g3k4.gif" width="400"></div><br><br>  Le seul malentendu qui subsiste est le fait que lors de la division du clavier, les jambes d'Ike ne tombent pas imm√©diatement.  Comment y rem√©dier? <br><br>  Nous apprendrons √† keyboardTracker √† fonctionner non seulement avec keyboardWillChangeFrameNotification, mais aussi avec keyboardDidChangeFrame.  Vous n'avez pas besoin d'√©crire de nouveau code, il suffit d'ajouter une v√©rification qu'il s'agit d'un iPad afin de ne pas faire de calculs inutiles. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardDidChangeFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isIPad ( ) == <span class="hljs-literal"><span class="hljs-literal">false</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/-n/nv/jd-nnvrctruwlczh4ytw2ckfllu.gif" width="400"></div><br><br><h2>  Comment d√©tecter les bugs? </h2><br><h3>  Journalisation abondante </h3><br>  Sur notre projet, les journaux sont √©crits au format suivant: entre crochets, le nom du module et du sous-module, auquel le journal appartient, puis le texte du journal lui-m√™me.  Par exemple, comme ceci: <br> <code>[keyboard][tracker] keyboardWillChangeFrame: calculated height - 437.9</code> <br> <br>  Dans le code, il ressemble √† ceci: un enregistreur est cr√©√© avec une balise de niveau sup√©rieur et transmis au tracker.  √Ä l'int√©rieur du tracker, un enregistreur avec une balise de deuxi√®me niveau, qui est utilis√© pour se connecter √† l'int√©rieur de la classe, est d√©riv√© de l'enregistreur. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(with logger: <span class="hljs-type"><span class="hljs-type">Logger</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.trackerLogger = logger.dequeue(withTag: <span class="hljs-string"><span class="hljs-string">"[tracker]"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardWillChangeFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> height = <span class="hljs-number"><span class="hljs-number">0.0</span></span> trackerLogger.debug(<span class="hljs-string"><span class="hljs-string">"\(#function): calculated height - \(height)"</span></span>) } }</code> </pre> <br>  J'ai donc promis l'int√©gralit√© du keyboardTracker, ce qui est bien.  Si les testeurs ont trouv√© des probl√®mes, j'ai pris le fichier journal et j'ai cherch√© exactement o√π les cadres ne correspondaient pas.  Cela a pris trop de temps, par cons√©quent, en plus de la journalisation, d'autres m√©thodes ont commenc√© √† √™tre appliqu√©es. <br><br><h3>  Chien de garde </h3><br>  Dans notre projet, Watchdog est utilis√© pour optimiser le flux d'interface utilisateur.  Cela a √©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dit par Dmitry Kurkin lors de l'un des derniers AppsConf</a> . <br><br>  Un chien de garde est un processus ou un thread qui <strong>surveille</strong> un autre processus ou thread.  Ce m√©canisme vous permet de surveiller l'√©tat du clavier et les vues qui en d√©pendent et de signaler les probl√®mes. <br><br>  Pour impl√©menter une telle fonctionnalit√©, nous cr√©ons une minuterie qui, une fois par seconde, v√©rifiera l'emplacement correct de la vue avec les jambes de Hayk ou l'enregistrera en cas d'erreur. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Watchdog</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timer: <span class="hljs-type"><span class="hljs-type">Timer?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { timer = <span class="hljs-type"><span class="hljs-type">Timer</span></span> ( timeInterval: <span class="hljs-number"><span class="hljs-number">1.0</span></span>, repeats: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, block: { ( timer ) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.woof ( ) } ) } }</code> </pre> <br>  Soit dit en passant, vous pouvez enregistrer non seulement les r√©sultats finaux, mais aussi des calculs interm√©diaires. <br><br>  En cons√©quence, une journalisation abondante + Watchdog a fourni des donn√©es pr√©cises sur le probl√®me, l'√©tat du clavier et r√©duit le temps de correction des bogues, mais cela n'a pas aid√© les utilisateurs b√™ta qui ont d√ª endurer des erreurs jusqu'√† la prochaine version. <br><br>  Mais que se passe-t-il si le chien de garde peut √™tre form√© non seulement pour trouver des probl√®mes, mais aussi pour les r√©soudre? <br><br>  Dans le code o√π le chien de garde conclut que les coordonn√©es de la vue ne convergent pas, nous ajoutons la m√©thode fixTummyPosition et mettons automatiquement les coordonn√©es en place. <br><br>  Dans cette option, beaucoup d'informations utiles sont accumul√©es dans mes journaux et les utilisateurs ne remarquent aucun probl√®me visuel.  Cela semble √™tre g√©nial, mais maintenant je ne peux pas d√©couvrir de probl√®mes avec le clavier. <br><br>  Il permet d'ajouter √† la m√©thode de surveillance la possibilit√© de g√©n√©rer un cache de test lorsqu'une erreur est d√©tect√©e.  Bien s√ªr, ce code est ajout√© sous la configuration de remout. <br><br>  Maintenant, apr√®s la prochaine version, vous pouvez activer la g√©n√©ration de crash de test et, si un utilisateur a des probl√®mes avec le clavier, son application plante et gr√¢ce aux journaux collect√©s, vous pouvez corriger les bugs. <br><br><h3>  Tableau de bord </h3><br>  La derni√®re astuce que nous avons introduite consiste √† envoyer des statistiques au moment o√π wahtchdog a enregistr√© les statistiques.  Sur la base des donn√©es obtenues, nous avons trac√© le nombre d'erreurs d√©tect√©es et apr√®s la premi√®re it√©ration, le nombre d'op√©rations a √©t√© r√©duit de quatre fois.  Bien s√ªr, il n'a pas √©t√© possible de r√©duire les probl√®mes √† z√©ro, mais les principales plaintes des utilisateurs ont cess√©. <br><br><blockquote>  La semaine prochaine, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Saint AppsConf</a> se tiendra √† Saint-P√©tersbourg, o√π vous pourrez poser des questions non seulement √† Konstantin, mais aussi √† de nombreux intervenants de la piste iOS. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462515/">https://habr.com/ru/post/fr462515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462505/index.html">Ne me trompez pas avec votre programmation fonctionnelle</a></li>
<li><a href="../fr462507/index.html">Quand le courrier est livr√©: lutter contre la perte de notifications push dans iOS</a></li>
<li><a href="../fr462509/index.html">Product Fest - Conf√©rence sur la gestion des produits informatiques √† laquelle vous souhaitez vous rendre</a></li>
<li><a href="../fr462511/index.html">Google Play Instantan√©. Refactoring √† vie</a></li>
<li><a href="../fr462513/index.html">D√©localisation: pr√©paration, s√©lection, d√©veloppement du territoire</a></li>
<li><a href="../fr462519/index.html">Le livre "Microservices. Mod√®les de d√©veloppement et de refactoring ¬ª</a></li>
<li><a href="../fr462523/index.html">Serveur d'autorisation √† deux facteurs LinOTP</a></li>
<li><a href="../fr462525/index.html">3CX lance de nouveaux softphones SIP pour iOS et Android avec cryptage vocal de bout en bout</a></li>
<li><a href="../fr462527/index.html">Comment un r√©seau neuronal SincNet alloue des fr√©quences importantes dans le son gr√¢ce √† la propagation arri√®re</a></li>
<li><a href="../fr462529/index.html">L'id√©e de la station lunaire de la NASA est mauvaise et bonne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>