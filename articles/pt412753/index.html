<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüî¨ üëäüèø üëãüèø Inicie a exibi√ß√£o no STM32 via LTDC ... nos registros üë®üèΩ‚Äç‚öïÔ∏è üë®‚Äçüë®‚Äçüë¶ üóÑÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sauda√ß√µes! Recentemente, um projeto precisava iniciar uma exibi√ß√£o que tivesse uma interface LVDS. Para implementar a tarefa, o controlador STM32F746 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inicie a exibi√ß√£o no STM32 via LTDC ... nos registros</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412753/"> Sauda√ß√µes!  Recentemente, um projeto precisava iniciar uma exibi√ß√£o que tivesse uma interface LVDS.  Para implementar a tarefa, o controlador STM32F746 foi selecionado, porque  J√° trabalhei bastante com ele e ele possui o m√≥dulo LTDC, que permite trabalhar diretamente com a tela sem um controlador.  Nesse caso, o controlador j√° est√° implementado dentro do microcontrolador.  Al√©m disso, o √∫ltimo argumento foi que havia a depura√ß√£o do STM32F746-Disco nessa pedra, que eu tinha em m√£os, o que significa que eu poderia come√ßar a trabalhar no projeto sem esperar a placa, os componentes etc. chegarem at√© mim. <br><br>  Hoje vou explicar como executar o m√≥dulo LTDC, trabalhando com registradores (CMSIS).  O HAL e outras bibliotecas n√£o gostam e n√£o usam por motivos religiosos, mas isso tamb√©m √© interessante.  Voc√™ ver√° que o aumento de perif√©ricos complexos nos registros √© t√£o simples quanto o SPI comum.  Interessante?  Ent√£o vamos l√°! <br><br><img src="https://habrastorage.org/webt/1q/dg/rd/1qdgrdp09rbyqcdhtzsvz8aqkbc.jpeg"><br><a name="habracut"></a><br><h2>  1. Um pouco sobre LTDC </h2><br>  Este m√≥dulo perif√©rico √© essencialmente um controlador, que geralmente fica do lado da tela, por exemplo, SSD1963 e similares.  Se observarmos a estrutura do LTDC, veremos que fisicamente este √© um barramento paralelo com 24 bits + um acelerador gr√°fico de hardware + uma matriz de dados na RAM, que na verdade √© um buffer de exibi√ß√£o (buffer de quadro). <br><br><img src="https://habrastorage.org/webt/wm/g-/7k/wmg-7k_nhwtycbwgiefmyyagmxo.png"><br><br>  Na sa√≠da, temos um barramento paralelo comum, que cont√©m 24 bits de cor (8 bits por cor do modelo RGB), linhas de sincroniza√ß√£o, uma linha on / off de exibi√ß√£o e rel√≥gio de pixel.  Este √∫ltimo, de fato, √© um sinal de rel√≥gio pelo qual os pixels s√£o carregados no visor, ou seja, se tivermos uma frequ√™ncia de 9,5 MHz, em 1 segundo podemos carregar 9,5 milh√µes de pixels.  Na teoria, √© claro, na pr√°tica, os n√∫meros s√£o um pouco mais modestos devido a hor√°rios e outras coisas. <br><br>  <u>Para uma introdu√ß√£o mais detalhada ao LTDC, aconselho a ler alguns documentos:</u> <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Uma vis√£o geral dos recursos do LTDC em F4, em nosso F7 tudo √© igual</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nota de aplica√ß√£o 4861. "Controlador de display LCD-TFT (LTDC) em MCUs STM32"</a> </li></ol><br><h2>  2. O que precisamos fazer? </h2><br>  Os microcontroladores ST ganharam popularidade por um bom motivo, o requisito mais importante para qualquer componente eletr√¥nico √© a documenta√ß√£o e tudo est√° bem com isso.  O site √© certamente terr√≠vel, mas vou deixar links para toda a documenta√ß√£o.  O fabricante evita o tormento e a inven√ß√£o da bicicleta, portanto, na p√°gina 520 do <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">manual de refer√™ncia RM0385,</a></i> s√£o fornecidas etapas em preto e branco, o que precisamos fazer: <br><br><img src="https://habrastorage.org/webt/bz/nx/ul/bznxulxfphrlrfmc_47lhv9wvgy.png"><br><br>  Na verdade, voc√™ n√£o precisa executar metade do descrito: n√£o √© necess√°rio iniciar ou j√° est√° configurado por padr√£o.  Para o in√≠cio m√≠nimo, que permite desenhar pixels, exibir figuras, gr√°ficos, texto etc., basta fazer o seguinte: <br><br><ul><li>  Ativar rel√≥gio LTDC </li><li>  Defina o sistema de rel√≥gio e a frequ√™ncia da sa√≠da de dados (pixel clock) </li><li>  Configurar portas de E / S (GPIO) para trabalhar com LTDC </li><li>  Configurar hor√°rios para o nosso modelo de exibi√ß√£o </li><li>  <s>Ajuste a polaridade dos sinais.</s>  <s>J√° feito por padr√£o</s> </li><li>  <s>Especifique a cor de fundo da tela.</s>  <s>Ainda n√£o o vemos, voc√™ pode deix√°-lo "em zeros"</s> </li><li>  Defina o tamanho real da √°rea vis√≠vel da tela para uma camada espec√≠fica </li><li>  Selecione o formato de cor: ARGB8888, RGB 888, RGB565 etc. </li><li>  Especifique o endere√ßo da matriz que atuar√° como um buffer de quadro </li><li>  Indique a quantidade de dados em uma linha (comprimento em largura) </li><li>  Indique o n√∫mero de linhas (altura da tela) </li><li>  Inclua a camada com a qual estamos trabalhando </li><li>  Ativar m√≥dulo LTDC </li></ul><br>  Assustador  E fiquei com medo, mas acabou funcionando por 20 minutos com todos os procedimentos.  H√° uma tarefa, o plano √© planejado e resta apenas cumpri-lo. <br><br><h2>  3. Configurando o sistema de rel√≥gio </h2><br>  O primeiro item que precisamos enviar um sinal de rel√≥gio para o m√≥dulo LTDC, √© feito escrevendo no registro RCC: <br><br><pre><code class="cpp hljs">RCC-&gt;APB2ENR |= RCC_APB2ENR_LTDCEN;</code> </pre> <br>  Em seguida, voc√™ precisa configurar a frequ√™ncia do rel√≥gio do quartzo externo (HSE) para uma frequ√™ncia de 216 MHz, ou seja, ao m√°ximo.  O primeiro passo √© ativar a fonte do rel√≥gio do ressonador de quartzo e aguardar o sinalizador pronto: <br><br><pre> <code class="cpp hljs">RCC-&gt;CR |= RCC_CR_HSEON; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!(RCC-&gt;CR &amp; RCC_CR_HSERDY));</code> </pre><br>  Agora defina o atraso para a mem√≥ria flash do controlador, como  ela n√£o sabe trabalhar na frequ√™ncia central.  Seu valor, como o restante dos dados, √© obtido no manual de refer√™ncia: <br><br><pre> <code class="cpp hljs">FLASH-&gt;ACR |= FLASH_ACR_LATENCY_5WS;</code> </pre><br>  Agora, para obter a frequ√™ncia desejada, vou dividir 25 MHz da entrada para 25 e obter 1 MHz.  Em seguida, apenas em PLL eu multiplico por 432, porque  no futuro, existe um divisor de frequ√™ncia com um valor m√≠nimo de / 2 e voc√™ precisa aplicar o dobro da frequ√™ncia a ele.  Depois disso, conectamos a entrada PLL ao nosso ressonador de quartzo (HSE): <br><br><pre> <code class="cpp hljs">RCC-&gt;PLLCFGR |= RCC_PLLCFGR_PLLM_0 | RCC_PLLCFGR_PLLM_3 | RCC_PLLCFGR_PLLM_4; RCC-&gt;PLLCFGR |= RCC_PLLCFGR_PLLN_4 | RCC_PLLCFGR_PLLN_5 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLN_8; RCC-&gt;PLLCFGR |= RCC_PLLCFGR_PLLSRC;</code> </pre><br>  Agora ative o PLL e aguarde o sinalizador pronto: <br><br><pre> <code class="cpp hljs">RCC-&gt;CR |= RCC_CR_PLLON; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == <span class="hljs-number"><span class="hljs-number">0</span></span>){}</code> </pre><br>  Atribu√≠mos a sa√≠da do nosso PLL como a fonte da frequ√™ncia do sistema e aguardamos o sinalizador pronto: <br><br><pre> <code class="cpp hljs">RCC-&gt;CFGR |= RCC_CFGR_SW_PLL; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((RCC-&gt;CFGR &amp; RCC_CFGR_SWS) != RCC_CFGR_SWS_1) {}</code> </pre><br>  Isso encerra a configura√ß√£o geral do rel√≥gio e passamos a definir a frequ√™ncia do rel√≥gio (PLLSAI) para nossa exibi√ß√£o (pixel clock).  O sinal para PLLSAI de acordo com a folha de dados √© obtido ap√≥s o divisor / 25, ou seja, na entrada, temos 1 MHz.  Precisamos obter uma frequ√™ncia de cerca de 9,5 MHz, para isso multiplicamos a frequ√™ncia de 1 MHz por 192 e, usando dois divisores por 5 e 4, obtemos o valor desejado PLLSAI = 1 MHz * 192/5/4 = 9,6 MHz: <br><br><pre> <code class="cpp hljs">RCC-&gt;PLLSAICFGR |= RCC_PLLSAICFGR_PLLSAIN_6 | RCC_PLLSAICFGR_PLLSAIN_7; RCC-&gt;PLLSAICFGR |= RCC_PLLSAICFGR_PLLSAIR_0 | RCC_PLLSAICFGR_PLLSAIR_2; RCC-&gt;DCKCFGR1 |= RCC_DCKCFGR1_PLLSAIDIVR_0; RCC-&gt;DCKCFGR1 &amp;= ~RCC_DCKCFGR1_PLLSAIDIVR_1;</code> </pre><br>  Como etapa final, habilitamos o PLLSAI para a exibi√ß√£o e aguardamos o sinalizador pronto para o trabalho: <br><br><pre> <code class="cpp hljs">RCC-&gt;CR |= RCC_CR_PLLSAION; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((RCC-&gt;CR &amp; RCC_CR_PLLSAIRDY) == <span class="hljs-number"><span class="hljs-number">0</span></span>) {}</code> </pre><br>  Isso completa a configura√ß√£o b√°sica do sistema de clock, para n√£o esquecer e depois n√£o sofrer, vamos ativar o clock em todas as portas de entrada / sa√≠da (GPIO).  N√£o temos energia da bateria, pelo menos para depura√ß√£o, portanto n√£o economizamos: <br><br><pre> <code class="cpp hljs">RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOAEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOBEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOCEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIODEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOEEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOFEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOGEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOHEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOJEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOKEN;</code> </pre><br><h2>  4. Configurando portas de E / S (GPIO) </h2><br>  A configura√ß√£o do gpio √© muito simples - temos todas as pernas do barramento LTDC para serem configuradas como uma sa√≠da alternativa e em alta frequ√™ncia.  Para fazer isso, no manual de refer√™ncia na p√°gina 201, temos esta dica: <br><br><img src="https://habrastorage.org/webt/m5/bw/e9/m5bwe9v-fev5yahji9hqc9iofno.png"><br><br>  A tabela indica quais bits nos registradores voc√™ precisa definir para obter a configura√ß√£o necess√°ria.  Vale a pena notar que todos os aparelhos est√£o desabilitados.  Onde procurar que fun√ß√£o alternativa incluir?  E para isso, v√° para a p√°gina 76 na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">folha</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dados</a> do nosso controlador e veja a tabela a seguir: <br><br><img src="https://habrastorage.org/webt/d1/6a/6-/d16a6-uye3sjdb7rrf_m-qnz2os.png"><br><br>  Como voc√™ pode ver, a l√≥gica da tabela √© simples: encontramos a fun√ß√£o de que precisamos, no nosso caso LTDC B0, depois olhamos para qual GPIO ela est√° (PE4, por exemplo) e, na parte superior, vemos o n√∫mero da fun√ß√£o alternativa que usaremos para configurar (AF14 conosco).  Para configurar nossa sa√≠da como uma sa√≠da push-pull com uma fun√ß√£o alternativa, LTDC B0, precisamos escrever o seguinte c√≥digo: <br><br><pre> <code class="cpp hljs">GPIOE-&gt;MODER &amp;= ~GPIO_MODER_MODER4; GPIOE-&gt;MODER |= GPIO_MODER_MODER4_1; GPIOE-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR4_1; GPIOE-&gt;AFR[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;= ~GPIO_AFRL_AFRL4_0; GPIOE-&gt;AFR[<span class="hljs-number"><span class="hljs-number">0</span></span>] |= GPIO_AFRL_AFRL4_1 | GPIO_AFRL_AFRL4_2 | GPIO_AFRL_AFRL4_3;</code> </pre><br>  Dei um exemplo para o pino PE4, que corresponde ao pino B0 no barramento LTDC, ou seja, √© um bit zero da cor azul.  Para todas as outras conclus√µes, a configura√ß√£o √© id√™ntica, apenas duas conclus√µes merecem aten√ß√£o especial, uma das prontas inclui uma tela e a outra a luz de fundo.  Eles s√£o configurados como uma sa√≠da push-pull normal, que todos usam para piscar um LED.  A configura√ß√£o √© assim: <br><br><pre> <code class="cpp hljs">GPIOK-&gt;MODER &amp;= ~GPIO_MODER_MODER3; GPIOK-&gt;MODER |= GPIO_MODER_MODER3_0;</code> </pre><br>  Essa configura√ß√£o √© para sa√≠da PK3, que liga e desliga nossa luz de fundo.  By the way, voc√™ tamb√©m pode empurr√°-lo para ajustar suavemente o brilho.  Para o PI12, que inclui uma tela (DISP), tudo √© igual.  A velocidade nesses 2 pinos √© baixa por padr√£o, porque  algumas a√ß√µes de alta frequ√™ncia n√£o s√£o necess√°rias a elas. <br><br>  Voc√™ pode observar todas as outras portas de E / S na placa de circuito da placa de depura√ß√£o ou no diagrama de circuito do seu pr√≥prio dispositivo. <br><br><h2>  5. Tempos e suas configura√ß√µes </h2><br>  Os tempos do ponto de vista f√≠sico s√£o atrasos comuns.  Eu acho que voc√™ observou repetidamente v√°rias pervers√µes do tipo delay (1) quando analisou exemplos de c√≥digo em displays com controladores SPI / I2C semelhantes ao ILI9341.  L√°, √© necess√°rio um atraso para que o controlador, por exemplo, tenha tempo para aceitar o comando, execut√°-lo e, em seguida, fazer alguma coisa com os dados.  No caso do LTDC, tudo √© o mesmo, apenas n√£o faremos muletas e por que n√£o - nosso pr√≥prio microcontrolador √© capaz de configurar os tempos necess√°rios no hardware.  Por que eles s√£o necess√°rios em uma tela onde n√£o h√° controlador?  Sim, √© fundamental que, depois de preencher a primeira linha de pixels, v√° para a pr√≥xima linha e retorne ao seu in√≠cio.  Isso se deve √† tecnologia de produ√ß√£o de displays e, portanto, cada modelo de display espec√≠fico possui seus pr√≥prios tempos. <br><br>  Para descobrir quais valores precisamos, acesse o site da ST e consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">diagrama da placa de depura√ß√£o STM32F746-Disco</a> .  A√≠ podemos ver que o display √© <i>RK043FN48H-CT672B</i> e a documenta√ß√£o para ele est√° dispon√≠vel, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Estamos mais interessados ‚Äã‚Äãna tabela na p√°gina 13 na se√ß√£o 7.3.1: <br><br><img src="https://habrastorage.org/webt/t7/fk/ou/t7fkoukmcua7rsnn6bmema1dhio.png"><br><br>  Esses s√£o nossos valores que precisaremos ao configurar.  Tamb√©m na documenta√ß√£o, h√° muito mais interessante, por exemplo, diagramas de sinal no barramento e assim por diante, que voc√™ pode precisar se, por exemplo, desejar aumentar a exibi√ß√£o para FPGA ou CPLD. <br><br>  V√° para as configura√ß√µes.  Antes de tudo, para n√£o manter esses valores em minha cabe√ßa, eu os organizarei na forma de define: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HSYNC ((uint16_t)30) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HBP ((uint16_t)13) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HFP ((uint16_t)32) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_VSYNC ((uint16_t)10) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_VBP ((uint16_t)2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_VFP ((uint16_t)2)</span></span></code> </pre><br>  H√° uma caracter√≠stica interessante.  <i>A largura do pulso de</i> temporiza√ß√£o, chamada <i>DISPLAY_HSYNC</i> , possui um valor na tabela apenas para a frequ√™ncia do clock de pixel de 5 MHz, mas para 9 e 12 MHz n√£o √©.  Esse tempo precisa ser selecionado para sua exibi√ß√£o, obtive esse valor de 30, quando nos exemplos do ST era diferente.  Na primeira partida, se houver um erro na configura√ß√£o, a imagem ser√° deslocada para a esquerda ou para a direita.  Se for para a direita, diminu√≠mos o tempo; se para a esquerda, aumentamos.  De fato, afeta a origem da zona vis√≠vel, que veremos mais adiante.  Lembre-se de que a seguinte figura da p√°gina 24 do nosso AN4861 ajudar√° a compreender todo o par√°grafo: <br><br><img src="https://habrastorage.org/webt/nu/cd/gc/nucdgcesjmx8gqq-bjwfnusk0vc.png"><br><br>  Uma pequena abstra√ß√£o √© conveniente aqui.  Temos 2 zonas de exibi√ß√£o: vis√≠vel e geral.  A zona vis√≠vel tem dimens√µes com uma resolu√ß√£o declarada de 480 por 272 pixels, e a zona total √© a vis√≠vel + nossos tempos, dos quais existem 3 em cada lado.  Tamb√©m vale a pena entender (isso n√£o √© mais uma abstra√ß√£o) que uma marca do sistema √© de 1 pixel, portanto a √°rea total √© de 480 pixels + HSYNC + HBP + HFP. <br><br>  Tamb√©m vale a pena perceber que quanto menos temporiza√ß√µes, melhor - a tela ser√° atualizada mais rapidamente e a taxa de quadros aumentar√° um pouco.  Portanto, ap√≥s a primeira execu√ß√£o, experimente os tempos e reduza-os o m√°ximo poss√≠vel, mantendo a estabilidade. <br><br>  Para definir os hor√°rios, criei uma pequena "folha de dicas" para o futuro dentro do projeto, tamb√©m ajudar√° voc√™ a entender qual figura espec√≠fica e onde escrev√™-la: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* *************************** Timings for TFT display********************************** * * HSW = (DISPLAY_HSYNC - 1) * VSH = (DISPLAY_VSYNC - 1) * AHBP = (DISPLAY_HSYNC + DISPLAY_HBP - 1) * AVBP = (DISPLAY_VSYNC + DISPLAY_VBP - 1) * AAW = (DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP - 1) * AAH = (DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP - 1) * TOTALW = (DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP + DISPLAY_VFP - 1) * TOTALH = (DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP + DISPLAY_HFP - 1) * */</span></span></code> </pre><br>  De onde veio essa "folha de dicas" ... Primeiro, voc√™ viu uma "f√≥rmula" semelhante alguns par√°grafos antes.  Em segundo lugar, v√° para a p√°gina 56 do nosso AN4861: <br><br><img src="https://habrastorage.org/webt/sz/zf/yc/szzfyccwyqfw_t9ki0dazyck3ys.png"><br><br>  √â verdade que espero que voc√™ entenda o significado f√≠sico dos hor√°rios antes do aparecimento desta folha de dicas e tenho certeza de que voc√™ mesmo poderia compil√°-la.  N√£o h√° nada complicado, e as imagens da RM e da AN ajudam a entender visualmente o efeito dos tempos no processo de forma√ß√£o da imagem. <br><br>  Agora √© hora de escrever um c√≥digo que configure esses tempos.  Na "folha de dicas" s√£o indicados os bits do registro no qual escrever, por exemplo, TOTALH, e ap√≥s o sinal ser igual √† f√≥rmula que fornece √† sa√≠da um determinado n√∫mero.  Ta bom  Ent√£o escrevemos: <br><br><pre> <code class="cpp hljs">LTDC-&gt;SSCR |= ((DISPLAY_HSYNC - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | (DISPLAY_VSYNC - <span class="hljs-number"><span class="hljs-number">1</span></span>)); LTDC-&gt;BPCR |= ((DISPLAY_HSYNC+DISPLAY_HBP<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | (DISPLAY_VSYNC+DISPLAY_VBP<span class="hljs-number"><span class="hljs-number">-1</span></span>)); LTDC-&gt;AWCR |= ((DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | (DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP - <span class="hljs-number"><span class="hljs-number">1</span></span>)); LTDC-&gt;TWCR |= ((DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP + DISPLAY_HFP <span class="hljs-number"><span class="hljs-number">-1</span></span>)&lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> |(DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP + DISPLAY_VFP - <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><br>  E isso √© tudo com hor√°rios!  Nesta se√ß√£o, voc√™ pode configurar apenas a cor de fundo.  Eu o tenho preto por padr√£o, ent√£o est√° escrito em zero.  Se voc√™ deseja alterar a cor da camada de plano de fundo (plano de fundo), tamb√©m pode escrever qualquer valor, por exemplo, <i>0xFFFFFFFF</i> e preencher tudo com branco: <br><br><pre> <code class="cpp hljs">LTDC-&gt;BCCR = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br>  H√° uma ilustra√ß√£o maravilhosa no <i>manual de refer√™ncia</i> que demonstra claramente que na verdade temos 3 camadas: fundo, camada 1 e camada 2. A camada de fundo √© "castrada" e s√≥ pode ser preenchida com uma cor espec√≠fica, mas tamb√©m pode ser incrivelmente √∫til design futuro da GUI.  Al√©m disso, esta ilustra√ß√£o demonstra claramente a prioridade das camadas, o que significa que veremos a cor de preenchimento no plano de fundo somente quando as camadas restantes estiverem vazias ou transparentes. <br><br>  Como exemplo, mostrarei uma das p√°ginas do projeto, onde durante a implementa√ß√£o do modelo o fundo foi preenchido com uma cor e o controlador n√£o redesenhou a p√°gina inteira, mas apenas setores individuais, que permitiram receber de 50 a 60 fps para muitas outras tarefas: <br><br><img src="https://habrastorage.org/webt/7b/yn/il/7byniliyqlnqy0yyzpfk8um7_mg.jpeg"><br><br><h2>  6. A parte final da configura√ß√£o do LTDC </h2><br>  As configura√ß√µes do LTDC s√£o divididas em duas se√ß√µes: a primeira √© comum para todo o m√≥dulo LTDC e est√° localizada no <i>grupo de</i> registros <i>LTDC</i> , e a segunda √© configurada em uma das duas camadas e est√° no grupo <i>LTDC_Layer1</i> e <i>LTDC_Layer2</i> . <br><br>  Fizemos as configura√ß√µes gerais no par√°grafo anterior, incluindo a defini√ß√£o dos tempos, a camada de fundo.  Agora passamos a definir as camadas e nossa lista requer o tamanho real da zona vis√≠vel da camada, descrita na forma de 4 coordenadas (x0, y0, x1, y2), que nos permitem obter as dimens√µes do ret√¢ngulo.  O tamanho da camada vis√≠vel pode ser menor que a resolu√ß√£o da tela, ningu√©m se incomoda em fazer o tamanho da camada 100 por 100 pixels.  Para ajustar o tamanho da zona vis√≠vel, escreva o seguinte c√≥digo: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;WHPCR |= (((DISPLAY_WIDTH + DISPLAY_HBP + DISPLAY_HSYNC - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (DISPLAY_HBP + DISPLAY_HSYNC)); LTDC_Layer2-&gt;WVPCR |= (((DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) |(DISPLAY_VSYNC + DISPLAY_VBP));</code> </pre><br>  Como voc√™ pode ver, tudo √© como nos hor√°rios.  Os pontos de partida (x0, y0) da zona vis√≠vel consistem na soma de dois tempos: HSYNC + HBP e VSYNC + VBP.  Para calcular as coordenadas do ponto final (x1, y1), a largura e a altura em pixels s√£o simplesmente adicionadas aos dados do valor. <br><br>  Agora voc√™ precisa configurar o formato dos dados recebidos.  A qualidade m√°xima √© obtida ao usar o formato ARGB8888, mas ao mesmo tempo obtemos a quantidade m√°xima de mem√≥ria ocupada.  Um pixel ocupa 32 bits ou 4 bytes, o que significa que a tela inteira ocupa 4 * 480 * 272 = 522.240 bytes, ou seja, metade da mem√≥ria flash do nosso controlador n√£o mais fraco.  N√£o tenha medo - conectar a SDRAM externa e a mem√≥ria Flash via QSPI resolve problemas de mem√≥ria e n√£o h√° restri√ß√µes nesse formato, n√≥s nos alegramos em boa qualidade.  Se voc√™ deseja economizar espa√ßo ou seu monitor n√£o suporta o formato de 24 bits, modelos mais adequados s√£o usados ‚Äã‚Äãpara isso, por exemplo, RGB565.  Um formato muito popular para monitores e c√¢meras, e mais importante ao us√°-lo, 1 pixel leva apenas 5 + 6 + 5 = 16 bits ou 2 bytes.  Consequentemente, a quantidade de mem√≥ria ocupada pela camada ser√° 2 vezes menor.  Por padr√£o, o controlador j√° possui o formato ARGB8888 configurado e fica assim: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;PFCR = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Se voc√™ precisar de um formato diferente do ARGB8888, v√° para as p√°ginas 533 e 534 no <i>manual de refer√™ncia</i> e selecione o formato desejado na lista abaixo: <br><br><img src="https://habrastorage.org/webt/be/fg/qa/befgqaa2-iokyso1coeqhaii9zu.png"><br><br>  Agora crie uma matriz e passe seu endere√ßo para o LTDC, ele se transformar√° em um buffer de quadro e ser√° um "reflexo" da nossa camada.  Por exemplo, voc√™ precisa preencher o 1¬∫ pixel na 1¬™ linha com a cor branca; para isso, basta escrever o valor da cor (0xFFFFFFFF) no primeiro elemento dessa matriz.  Precisa preencher o 1¬∫ pixel na 2¬™ linha?  Em seguida, tamb√©m escrevemos o valor da cor no elemento com o n√∫mero (480 + 1).  480 - fa√ßa uma quebra de linha e adicione o n√∫mero na linha que precisamos. <br><br>  Essa configura√ß√£o √© assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_WIDTH ((uint16_t)480) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HEIGHT ((uint16_t)272) const uint32_t imageLayer2[DISPLAY_WIDTH * DISPLAY_HEIGHT]; LTDC_Layer2-&gt;CFBAR = (uint32_t)imageLayer2;</span></span></code> </pre><br>  De uma maneira boa, ap√≥s configurar o LTDC, voc√™ tamb√©m precisar√° configurar o SDRAM para remover o modificador <i>const</i> e obter o buffer de quadro na RAM, porque  A pr√≥pria RAM do MK n√£o √© suficiente, mesmo para uma camada com 4 bytes.  Embora isso n√£o fa√ßa mal para testar a configura√ß√£o correta dos perif√©ricos. <br><br>  Em seguida, √© necess√°rio especificar o valor da camada alfa, ou seja, a transpar√™ncia da camada 2, para isso escrevemos um valor de 0 a 255, onde 0 √© uma camada completamente transparente, 255 √© totalmente opaco e 100% vis√≠vel: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;CACR = <span class="hljs-number"><span class="hljs-number">255</span></span>;</code> </pre> <br>  De acordo com o nosso plano, agora √© necess√°rio registrar o tamanho da nossa √°rea de exibi√ß√£o vis√≠vel em bytes, para isso escrevemos os valores correspondentes nos registros: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;CFBLR |= (((PIXEL_SIZE * DISPLAY_WIDTH) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (PIXEL_SIZE * DISPLAY_WIDTH + <span class="hljs-number"><span class="hljs-number">3</span></span>)); LTDC_Layer2-&gt;CFBLNR |= DISPLAY_HEIGHT;</code> </pre><br>  As duas √∫ltimas etapas permanecem, a saber, a inclus√£o da camada 2 e do pr√≥prio m√≥dulo perif√©rico LTDC.  Para fazer isso, escreva os bits correspondentes: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;CR |= LTDC_LxCR_LEN; LTDC-&gt;GCR |= LTDC_GCR_LTDCEN;</code> </pre><br>  Isso completa a configura√ß√£o do nosso m√≥dulo e voc√™ pode trabalhar com a nossa tela! <br><br><h2>  7. Um pouco sobre como trabalhar com o LTDC </h2><br>  Todo o trabalho com a tela agora se resume apenas √† grava√ß√£o de dados na matriz <i>imageLayer2</i> , ela tem um tamanho de 480 por 272 elementos, o que corresponde totalmente √† nossa resolu√ß√£o e sugere uma verdade simples - <b>1 elemento da matriz = 1 pixel na tela</b> . <br><br>  Como exemplo, escrevi uma imagem em uma matriz para a qual converti no <b>LCD Image Converter</b> , mas, na realidade, √© improv√°vel que suas tarefas sejam limitadas a isso.  Existem duas maneiras: usar uma GUI pronta e escrever voc√™ mesmo.  Para tarefas relativamente simples, como sa√≠da de texto, gr√°ficos e similares, aconselho que voc√™ escreva sua pr√≥pria GUI, isso levar√° um tempo e dar√° a voc√™ um entendimento completo de sua opera√ß√£o.  Quando a tarefa √© grande e dif√≠cil, e n√£o h√° tempo para desenvolver sua pr√≥pria GUI, aconselho que voc√™ preste aten√ß√£o nas solu√ß√µes prontas, por exemplo, uGFX e similares. <br><br>  S√≠mbolos de texto, linhas e outros elementos s√£o inerentemente matrizes de pixels; portanto, para implement√°-los, √© necess√°rio implementar a l√≥gica, mas voc√™ deve come√ßar com a fun√ß√£o mais b√°sica - "sa√≠da de pixel".  Deve levar tr√™s argumentos: a coordenada ao longo de X, a coordenada ao longo de Y e, consequentemente, a cor na qual o pixel fornecido √© pintado.  Pode ser assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ColorDisplay { RED = <span class="hljs-number"><span class="hljs-number">0xFFFF0000</span></span>, GREEN = <span class="hljs-number"><span class="hljs-number">0xFF00FF00</span></span>, BLUE = <span class="hljs-number"><span class="hljs-number">0xFF0000FF</span></span>, BLACK = <span class="hljs-number"><span class="hljs-number">0xFF000000</span></span>, WHITE = <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span> } Color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPixel</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> setX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> setY, Color Color)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> numBuffer = ((setY - <span class="hljs-number"><span class="hljs-number">1</span></span>) * DISPLAY_WIDTH) + setX; imageLayer2[numBuffer] = Color; }</code> </pre><br>  Depois que colocamos as coordenadas em uma fun√ß√£o, recalculamos-as no n√∫mero da matriz que corresponde √† coordenada especificada e, em seguida, escrevemos a cor recebida no elemento recebido.  Com base nessa fun√ß√£o, voc√™ j√° pode implementar fun√ß√µes para exibir geometria, texto e outras "vantagens" da GUI.  Eu acho que a ideia √© compreens√≠vel, mas como traz√™-la √† vida fica a seu crit√©rio. <br><br><h2>  Sum√°rio </h2><br>  Como voc√™ pode ver, a implementa√ß√£o de at√© perif√©ricos complexos em registros (CMSIS) n√£o √© uma tarefa dif√≠cil, voc√™ s√≥ precisa entender como ele funciona por dentro.  Claro, agora est√° na moda desenvolver firmware sem entender o que est√° acontecendo, mas esse √© um beco sem sa√≠da se voc√™ planeja se tornar um engenheiro, e n√£o ... <br><br>  Se voc√™ comparar o c√≥digo resultante com uma solu√ß√£o no HAL ou SPL, notar√° que o c√≥digo escrito nos registros √© mais compacto.  Adicionando alguns coment√°rios onde voc√™ precisar e agrupando-o em fun√ß√µes, obtemos legibilidade pelo menos t√£o boa quanto a do HAL / SPL, e se voc√™ se lembrar de que o <i>manual de refer√™ncia</i> registra documentos, usar o CMSIS √© mais conveniente. <br><br>  1) O projeto com fontes no TrueSTUDIO pode ser baixado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> <br><br>  2) Para quem est√° mais √† vontade olhando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> <br><br>  3) Baixe o utilit√°rio para converter imagens em c√≥digo LCD Image Converter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt412753/">https://habr.com/ru/post/pt412753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt412741/index.html">Como parar de ter medo de que a intelig√™ncia artificial o deixe sem trabalho</a></li>
<li><a href="../pt412743/index.html">Profiss√£o: Cyber ‚Äã‚ÄãDetective</a></li>
<li><a href="../pt412747/index.html">MIS. Armazenamento de dados m√©dicos</a></li>
<li><a href="../pt412749/index.html">A eletr√¥nica como arte: corrente el√©trica</a></li>
<li><a href="../pt412751/index.html">Calv√≠cie: Teoria e pr√°tica do tratamento, parte 1 "Minha di-hidrotestosterona, meu inimigo"</a></li>
<li><a href="../pt412755/index.html">O Telegram lan√ßou o servidor MTProto Proxy oficial</a></li>
<li><a href="../pt412757/index.html">L√¢mpadas LED no Jap√£o</a></li>
<li><a href="../pt412759/index.html">Novo servidor proxy MTProto-proxy do Telegram</a></li>
<li><a href="../pt412763/index.html">Usando a placa de recarga Firefly-RK3288 com o SoC RockChip RK3288 Sensor t√©rmico digital Microchip I2C - MCP9808</a></li>
<li><a href="../pt412765/index.html">Introdu√ß√£o ao novo sistema de cart√µes lado a lado da Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>