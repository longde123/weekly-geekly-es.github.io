<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÆ üéÖüèº üë©üèΩ‚Äçüöí WAL dans PostgreSQL: 1. Cache tampon üîò üçò üê¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La s√©rie pr√©c√©dente √©tait consacr√©e √† l' isolation et aux versions multiples de PostgreSQL, et aujourd'hui nous en commen√ßons une nouvelle - sur le m√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL dans PostgreSQL: 1. Cache tampon</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/458186/">  La s√©rie pr√©c√©dente √©tait consacr√©e √† l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">isolation et aux versions multiples de</a> PostgreSQL, et aujourd'hui nous en commen√ßons une nouvelle - <strong>sur le m√©canisme de</strong> journalisation en √©criture anticip√©e.  Permettez-moi de vous rappeler que le mat√©riel est bas√© sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des cours de formation</a> administrative que Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">pluzanov</a> et moi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">faisons</a> , mais ne les r√©p√©tez pas textuellement et sont destin√©s √† une lecture r√©fl√©chie et √† une exp√©rimentation ind√©pendante. <br><br>  Ce cycle comprendra quatre parties: <br><br><ul><li>  Cache tampon (cet article); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Journal pr√©enregistrement</a> - comment il est organis√© et comment il est utilis√© pendant la r√©cup√©ration; </li><li>  Enregistrement des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">points de contr√¥le</a> et des ant√©c√©dents - pourquoi sont-ils n√©cessaires et comment sont-ils configur√©s; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R√©glage du journal</a> - niveaux et t√¢ches √† r√©soudre, fiabilit√© et performances. </li></ul><br><h1>  Pourquoi la journalisation est-elle n√©cessaire? </h1><br>  Dans le processus, une partie des donn√©es trait√©es par le SGBD est stock√©e dans la RAM et √©crite sur le disque (ou tout autre support non volatile) de mani√®re diff√©r√©e.  Moins cela se produit, moins les entr√©es-sorties et le fonctionnement du syst√®me sont rapides. <br><br>  Mais que se passera-t-il en cas de panne, par exemple lorsque l'alimentation est coup√©e ou si une erreur se produit dans le code SGBD ou le syst√®me d'exploitation?  Tout le contenu de la RAM sera perdu et seules les donn√©es √©crites sur le disque resteront (avec certains types de pannes, le disque peut √©galement souffrir, mais dans ce cas, seule une copie de sauvegarde sera utile).  En principe, les E / S peuvent √™tre organis√©es de mani√®re √† ce que les donn√©es sur le disque soient toujours maintenues dans un √©tat coh√©rent, mais cela est difficile et pas trop efficace (pour autant que je sache, seul Firebird l'a fait). <br><br>  Habituellement, y compris PostgreSQL, les donn√©es √©crites sur le disque sont incoh√©rentes et lors de la r√©cup√©ration apr√®s une panne, des actions sp√©ciales sont requises pour restaurer la coh√©rence.  La journalisation est le m√©canisme m√™me qui rend cela possible. <br><a name="habracut"></a><br><h1>  Cache tampon </h1><br>  Curieusement, nous allons commencer √† parler de journalisation avec un cache tampon.  Le cache tampon n'est pas la seule structure stock√©e dans la RAM, mais l'une des plus importantes et des plus complexes.  Comprendre le principe de son fonctionnement est important en soi, d'ailleurs, dans cet exemple, nous allons nous familiariser avec la fa√ßon dont les donn√©es sont √©chang√©es entre la RAM et le disque. <br><br>  La mise en cache est utilis√©e partout dans les syst√®mes informatiques modernes; un seul processeur peut compter trois ou quatre niveaux de cache.  En g√©n√©ral, n'importe quel cache est n√©cessaire pour aplanir la diff√©rence de performances entre les deux types de m√©moire, dont l'un est relativement rapide, mais il n'est pas suffisant pour tout le monde, et l'autre est relativement lent, mais abondant.  Ainsi, le cache tampon lisse la diff√©rence entre le temps d'acc√®s √† la RAM (nanosecondes) et au disque (millisecondes). <br><br>  Notez que le syst√®me d'exploitation dispose √©galement d'un cache disque qui r√©sout le m√™me probl√®me.  Par cons√©quent, les SGBD tentent g√©n√©ralement d'√©viter la double mise en cache en acc√©dant directement au disque, en contournant le cache du syst√®me d'exploitation.  Mais dans le cas de PostgreSQL, ce n'est pas le cas: toutes les donn√©es sont lues et √©crites √† l'aide d'op√©rations de fichiers ordinaires. <br><br>  De plus, les baies de disques, et m√™me les disques eux-m√™mes, ont √©galement leur propre cache.  Ce fait nous est toujours utile lorsque nous abordons la question de la fiabilit√©. <br><br>  Mais revenons au cache de tampon du SGBD. <br><br>  Il est appel√© ainsi car il s'agit d'un tableau de <em>tampons</em> .  Chaque tampon est un emplacement pour une page de donn√©es (bloc), plus un en-t√™te.  Le titre, entre autres, contient: <br><br><ul><li>  emplacement sur le disque de la page dans le tampon (fichier et num√©ro de bloc); </li><li>  un signe que les donn√©es de la page ont chang√© et devraient t√¥t ou tard √™tre √©crites sur le disque (un tel tampon est appel√© <em>sale</em> ); </li><li>  nombre d'appels au tampon (nombre d'utilisation); </li><li>  indicateur d'√©pinglage du tampon (nombre de broches). </li></ul><br>  Le cache de tampon est situ√© dans la m√©moire partag√©e du serveur et est accessible √† tous les processus.  Pour travailler avec des donn√©es - lire ou modifier, - traite les pages lues dans le cache.  Pendant que la page est en cache, nous travaillons avec elle en RAM et √©conomisons sur les acc√®s disque. <br><br><img src="https://habrastorage.org/webt/1u/-j/fd/1u-jfdnjvzjwvrddgb7tbvohhge.png"><br><br>  Initialement, le cache contient des tampons vides, et tous sont li√©s dans la liste des tampons libres.  La signification du pointeur sur la ¬´prochaine victime¬ª deviendra claire un peu plus tard.  Pour trouver rapidement la page souhait√©e dans le cache, une table de hachage est utilis√©e. <br><br><h1>  Page de recherche dans le cache </h1><br>  Lorsqu'un processus doit lire une page, il essaie d'abord de la trouver dans le cache de tampon √† l'aide d'une table de hachage.  La cl√© de hachage est le num√©ro de fichier et le num√©ro de page √† l'int√©rieur du fichier.  Dans le panier correspondant de la table de hachage, le processus trouve le num√©ro de tampon et v√©rifie s'il contient vraiment la page souhait√©e.  Comme avec n'importe quelle table de hachage, les collisions sont possibles ici;  dans ce cas, le processus devra v√©rifier plusieurs pages. <br><br><blockquote>  L'utilisation d'une table de hachage a longtemps √©t√© critiqu√©e.  Cette structure vous permet de trouver rapidement le tampon sur la page, mais elle est compl√®tement inutile si, par exemple, vous devez trouver tous les tampons occup√©s par une table particuli√®re.  Mais personne n'a encore propos√© un bon substitut. <br></blockquote><br>  Si la page souhait√©e se trouve dans le cache, le processus doit ¬´geler¬ª le tampon en augmentant le nombre de broches (plusieurs processus peuvent le faire simultan√©ment).  Tant que le tampon est fixe (la valeur du compteur est sup√©rieure √† z√©ro), il est consid√©r√© que le tampon est utilis√© et que son contenu ne doit pas √™tre ¬´radicalement¬ª modifi√©.  Par exemple, une nouvelle version de la ligne peut appara√Ætre dans la page - cela ne d√©range personne en raison des r√®gles de multi-version et de visibilit√©.  Mais une autre page ne peut pas √™tre lue dans le tampon √©pingl√©. <br><br><h1>  √âviction </h1><br>  Il peut arriver que la page n√©cessaire ne soit pas trouv√©e dans le cache.  Dans ce cas, il doit √™tre lu depuis le disque vers un tampon. <br><br>  S'il reste des tampons libres dans le cache, le premier libre est s√©lectionn√©.  Mais t√¥t ou tard, ils se termineront (g√©n√©ralement, la taille de la base de donn√©es est sup√©rieure √† la m√©moire allou√©e au cache), puis vous devrez choisir l'un des tampons occup√©s, y forcer la page et en lire un nouveau sur l'espace libre. <br><br>  Le m√©canisme de pr√©emption est bas√© sur le fait qu'√† chaque acc√®s au tampon, les processus augmentent le nombre d'utilisations dans l'en-t√™te du tampon.  Ainsi, les tampons qui sont utilis√©s moins souvent que d'autres ont une valeur de compteur inf√©rieure et sont de bons candidats pour l'√©viction. <br><br>  L'algorithme de balayage d'horloge parcourt tous les tampons (en utilisant le pointeur vers la "prochaine victime"), diminuant ainsi le nombre d'acc√®s.  Pour l'√©viction, le premier tampon est s√©lectionn√©, ce qui: <br><br><ol><li>  a un compteur de hit z√©ro (nombre d'utilisation), </li><li>  et non fixe (nombre de broches nul). </li></ol><br>  Vous remarquerez peut-√™tre que si tous les tampons ont un compteur d'acc√®s diff√©rent de z√©ro, l'algorithme devra alors faire plus d'un cercle, en r√©initialisant les compteurs, jusqu'√† ce que l'un d'eux atteigne enfin z√©ro.  Pour √©viter les "cercles sinueux", la valeur maximale du compteur d'acc√®s est limit√©e √† 5. Mais malgr√© tout, avec une grande taille de cache de tampon, cet algorithme peut entra√Æner une surcharge importante. <br><br>  Une fois le tampon trouv√©, ce qui suit lui arrive. <br><br>  Le tampon est √©pingl√© pour montrer aux autres processus qu'il est utilis√©.  En plus de la fixation, d'autres moyens de blocage sont √©galement utilis√©s, mais nous en parlerons plus s√©par√©ment. <br><br>  Si le tampon s'est av√©r√© sale, c'est-√†-dire qu'il contient des donn√©es modifi√©es, la page ne peut pas √™tre simplement supprim√©e - elle doit d'abord √™tre enregistr√©e sur le disque.  Ce n'est pas une bonne situation, car le processus qui est sur le point de lire la page doit attendre l'enregistrement de donn√©es ¬´√©trang√®res¬ª, mais cet effet est att√©nu√© par les processus d'enregistrement de point de contr√¥le et d'arri√®re-plan, qui seront examin√©s plus tard. <br><br>  Ensuite, une nouvelle page est lue √† partir du disque dans le tampon s√©lectionn√©.  Le compteur du nombre d'appels est r√©gl√© sur un.  De plus, le lien vers la page charg√©e doit √™tre enregistr√© dans la table de hachage pour pouvoir √™tre retrouv√© ult√©rieurement. <br><br>  Maintenant, le lien vers la ¬´prochaine victime¬ª pointe vers le tampon suivant, et celui qui vient d'√™tre charg√© a le temps d'augmenter le compteur d'acc√®s jusqu'√† ce que le pointeur contourne tout le cache du tampon et revienne. <br><br><h1>  De mes propres yeux </h1><br>  Comme il est de coutume dans PostgreSQL, il existe une extension qui vous permet de regarder √† l'int√©rieur du cache de tampon. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_buffercache;</code> </pre> <br>  Cr√©ez un tableau et ins√©rez-y une ligne. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> cacheme( id <span class="hljs-type"><span class="hljs-type">integer</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> cacheme <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Qu'y aura-t-il dans le cache tampon?  Au minimum, une page doit y appara√Ætre avec une seule ligne ajout√©e.  Nous allons v√©rifier cela avec la requ√™te suivante, dans laquelle nous s√©lectionnons uniquement les tampons appartenant √† notre table (par le num√©ro de fichier relfilenode), et d√©codons le num√©ro de couche (relforknumber): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> bufferid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> relforknumber <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'fsm'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'vm'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> relfork, relblocknumber, isdirty, usagecount, pinning_backends <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'cacheme'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15735 | main | 0 | t | 1 | 0 (1 row)</code> </pre><br>  Il en est ainsi - il y a une page dans le tampon.  Il est sale (isdirty), le compteur d'acc√®s est √©gal √† un (usagecount) et il n'est fix√© par aucun processus (pinning_backends). <br><br>  Ajoutez maintenant une autre ligne et r√©p√©tez la requ√™te.  Pour enregistrer des lettres, nous ins√©rons une ligne dans une autre session et r√©p√©tons la longue requ√™te avec la commande <code>\g</code> . <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> cacheme <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15735 | main | 0 | t | 2 | 0 (1 row)</code> </pre><br>  Aucun nouveau tampon n'a √©t√© ajout√© - la deuxi√®me ligne tient sur la m√™me page.  Veuillez noter que le compteur d'utilisation a augment√©. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> cacheme;</code> </pre><pre> <code class="plaintext hljs">| id | ---- | 1 | 2 | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15735 | main | 0 | t | 3 | 0 (1 row)</code> </pre><br>  Et apr√®s avoir acc√©d√© √† la page pour la lecture, le compteur augmente √©galement. <br><br>  Et si vous nettoyez? <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> cacheme;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15731 | fsm | 1 | t | 1 | 0 15732 | fsm | 0 | t | 1 | 0 15733 | fsm | 2 | t | 2 | 0 15734 | vm | 0 | t | 2 | 0 15735 | main | 0 | t | 3 | 0 (5 rows)</code> </pre><br>  Le nettoyage a cr√©√© une carte de visibilit√© (une page) et une carte d'espace libre (trois pages - la taille minimale de cette carte). <br><br>  Eh bien et ainsi de suite. <br><br><h1>  R√©glage de la taille </h1><br>  La taille du cache est d√©finie par le param√®tre <em>shared_buffers</em> .  La valeur par d√©faut est ridicule 128 Mo.  C'est l'un des param√®tres qu'il est logique d'augmenter imm√©diatement apr√®s l'installation de PostgreSQL. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> setting, unit <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_settings <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'shared_buffers'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> setting | unit ---------+------ 16384 | 8kB (1 row)</code> </pre><br>  Gardez √† l'esprit que la modification d'un param√®tre n√©cessite un red√©marrage du serveur, car toute la m√©moire cache n√©cessaire est allou√©e au d√©marrage du serveur. <br><br>  Pour quelles raisons choisir la valeur appropri√©e? <br><br>  M√™me la plus grande base de donn√©es poss√®de un ensemble limit√© de donn√©es ¬´√† chaud¬ª, avec lesquelles un travail actif est effectu√© √† chaque instant.  Id√©alement, cet ensemble devrait √™tre plac√© dans le cache de tampon (plus un peu d'espace pour les donn√©es ¬´ponctuelles¬ª).  Si la taille du cache est plus petite, les pages activement utilis√©es se serrent constamment les unes les autres, cr√©ant une entr√©e-sortie excessive.  Mais l'augmentation inconsid√©r√©e du cache est √©galement une erreur.  Avec une grande taille, les frais g√©n√©raux de maintenance augmenteront et, en outre, la RAM est √©galement requise pour d'autres besoins. <br><br>  Ainsi, la taille optimale du cache tampon sera diff√©rente selon les syst√®mes: elle d√©pend des donn√©es, de l'application, de la charge.  Malheureusement, il n'y a pas une telle signification magique qui conviendra aussi bien √† tout le monde. <br><br>  La recommandation standard est de prendre 1/4 de la RAM en premi√®re approximation (pour Windows avant PostgreSQL 10, il √©tait recommand√© de choisir une taille plus petite). <br><br>  Et puis vous devez regarder la situation.  Il vaut mieux faire une exp√©rience: augmenter ou diminuer la taille du cache et comparer les performances du syst√®me.  Bien s√ªr, pour cela, il est n√©cessaire d'avoir un banc d'essai et de pouvoir reproduire la charge typique - dans l'environnement de production, de telles exp√©riences ressemblent √† un plaisir douteux. <br><br><blockquote>  N'oubliez pas de consulter le rapport de Nikolay Samokhvalov √† PgConf-2019: "Une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">approche industrielle de l'</a> optimisation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PostgreSQL: exp√©riences de base de donn√©es</a> " <br></blockquote><br>  Mais certaines informations sur ce qui se passe peuvent √™tre glan√©es directement sur un syst√®me en direct en utilisant la m√™me extension pg_buffercache - surtout, regardez sous le bon angle. <br><br>  Par exemple, vous pouvez √©tudier la distribution des tampons en fonction de leur degr√© d'utilisation: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> usagecount, count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> usagecount <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> usagecount;</code> </pre><pre> <code class="plaintext hljs"> usagecount | count ------------+------- 1 | 221 2 | 869 3 | 29 4 | 12 5 | 564 | 14689 (6 rows)</code> </pre><br>  Dans ce cas, de nombreuses valeurs de compteur vides sont des tampons libres.  Pas √©tonnant pour un syst√®me o√π rien ne se passe. <br><br>  Vous pouvez voir combien de tables de notre base de donn√©es sont mises en cache et √† quel point ces donn√©es sont utilis√©es activement (par utilisation active dans cette requ√™te, nous entendons des tampons avec un compteur d'utilisation sup√©rieur √† 3): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> c.relname, count(*) blocks, round( <span class="hljs-number"><span class="hljs-number">100.0</span></span> * <span class="hljs-number"><span class="hljs-number">8192</span></span> * count(*) / pg_table_size(c.oid) ) "% of rel", round( <span class="hljs-number"><span class="hljs-number">100.0</span></span> * <span class="hljs-number"><span class="hljs-number">8192</span></span> * count(*) <span class="hljs-keyword"><span class="hljs-keyword">FILTER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> b.usagecount &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) / pg_table_size(c.oid) ) "% hot" <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache b <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class c <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> pg_relation_filenode(c.oid) = b.relfilenode <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> b.reldatabase <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( <span class="hljs-number"><span class="hljs-number">0</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> datname = current_database()) ) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> b.usagecount <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> c.relname, c.oid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relname | blocks | % of rel | % hot ---------------------------+--------+----------+------- vac | 833 | 100 | 0 pg_proc | 71 | 85 | 37 pg_depend | 57 | 98 | 19 pg_attribute | 55 | 100 | 64 vac_s | 32 | 4 | 0 pg_statistic | 27 | 71 | 63 autovac | 22 | 100 | 95 pg_depend_reference_index | 19 | 48 | 35 pg_rewrite | 17 | 23 | 8 pg_class | 16 | 100 | 100 (10 rows)</code> </pre><br>  Ici, par exemple, on peut voir que la table vac occupe la plus grande place (nous l'avons utilis√©e dans l'un des sujets pr√©c√©dents), mais personne ne l'a abord√©e depuis longtemps et elle n'a pas encore √©t√© √©limin√©e simplement parce que les tampons libres ne sont pas encore √©puis√©s. <br><br>  Vous pouvez trouver d'autres sections qui fourniront des informations utiles √† la r√©flexion.  Il suffit de consid√©rer que de telles demandes: <br><br><ul><li>  doit √™tre r√©p√©t√© plusieurs fois: les chiffres varient dans certaines limites; </li><li>  il n'est pas n√©cessaire de l'ex√©cuter en permanence (dans le cadre de la surveillance) en raison du fait que l'extension bloque le fonctionnement avec le cache tampon pendant une courte p√©riode. </li></ul><br>  Et encore une chose.  Nous ne devons pas oublier que PostgreSQL travaille avec des fichiers via des appels r√©guliers au syst√®me d'exploitation et, par cons√©quent, il y a une double mise en cache: les pages tombent √† la fois dans le cache de tampon du SGBD et dans le cache du syst√®me d'exploitation.  Ainsi, le ¬´manque¬ª dans le cache de tampon n'entra√Æne pas toujours le besoin d'une v√©ritable E / S.  Mais la strat√©gie d'√©viction du syst√®me d'exploitation est diff√©rente de la strat√©gie du SGBD: le syst√®me d'exploitation ne sait rien de la signification des donn√©es lues. <br><br><h1>  D√©placement de masse </h1><br>  Dans les op√©rations qui effectuent une lecture ou une √©criture en masse de donn√©es, il existe un danger de d√©placer rapidement les pages utiles du cache de tampon avec des donn√©es "ponctuelles". <br><br>  Pour √©viter que cela ne se produise, les soi-disant <em>anneaux de tampon</em> sont utilis√©s pour de telles op√©rations - une petite partie du cache de tampon est allou√©e pour chaque op√©ration.  L'extrusion n'agit que dans l'anneau, de sorte que le reste des donn√©es du cache de tampon ne souffre pas. <br><br>  Pour la lecture s√©quentielle de grandes tables (dont la taille d√©passe le quart du cache de tampon), 32 pages sont allou√©es.  Si un autre processus a √©galement besoin de ces donn√©es lors de la lecture d'une table, il ne commence pas la lecture de la table en premier, mais se connecte √† un anneau tampon existant.  Apr√®s avoir num√©ris√©, il lit le d√©but ¬´manqu√©¬ª du tableau. <br><br>  Voyons √ßa.  Pour ce faire, cr√©ez un tableau de sorte qu'une ligne occupe une page enti√®re - il est plus pratique de compter.  La taille du cache de tampon par d√©faut est de 128 Mo = 16384 pages de 8 Ko.  Vous devez donc ins√©rer plus de 4096 lignes de page dans le tableau. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> big( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALWAYS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">1000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor=<span class="hljs-number"><span class="hljs-number">10</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> big(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'FOO'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4096</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Analysons le tableau. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> big; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 4097 (1 row)</code> </pre><br>  Nous devons maintenant red√©marrer le serveur pour vider le cache des donn√©es de la table lues par l'analyse. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Apr√®s le red√©marrage, lisez l'int√©gralit√© du tableau: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> big;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Aggregate (actual time=14.472..14.473 rows=1 loops=1) -&gt; Seq Scan on big (actual time=0.031..13.022 rows=4097 loops=1) Planning Time: 0.528 ms Execution Time: 14.590 ms (4 rows)</code> </pre><br>  Et assurez-vous que seulement 32 tampons sont occup√©s par des pages tabulaires dans le cache de tampons: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 32 (1 row)</code> </pre><br>  Si le balayage s√©quentiel est interdit, le tableau sera lu par index: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> big;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------------- Aggregate (actual time=50.300..50.301 rows=1 loops=1) -&gt; Index Only Scan using big_pkey on big (actual time=0.098..48.547 rows=4097 loops=1) Heap Fetches: 4097 Planning Time: 0.067 ms Execution Time: 50.340 ms (5 rows)</code> </pre><br>  Dans ce cas, l'anneau tampon n'est pas utilis√© et la table enti√®re appara√Æt dans le cache tampon (et presque tout l'index aussi): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 4097 (1 row)</code> </pre><br>  De la m√™me mani√®re, des anneaux de tampon sont utilis√©s pour le processus de nettoyage (√©galement 32 pages) et pour les op√©rations d'√©criture en bloc COPY IN et CREATE TABLE AS SELECT (g√©n√©ralement 2048 pages, mais pas plus de 1/8 du cache de tampon total). <br><br><h1>  Tables temporaires </h1><br>  Une exception √† la r√®gle g√©n√©rale est les tables temporaires.  √âtant donn√© que les donn√©es temporaires ne sont visibles que pour un seul processus, elles n'ont rien √† voir dans le cache de tampon partag√©.  De plus, les donn√©es temporaires n'existent que dans une seule session, il n'est donc pas n√©cessaire de les prot√©ger contre les pannes. <br><br>  Pour les donn√©es temporaires, un cache est utilis√© dans la m√©moire locale du processus propri√©taire de la table.  √âtant donn√© que ces donn√©es ne sont disponibles que pour un seul processus, elles n'ont pas besoin d'√™tre prot√©g√©es par des verrous.  Le cache local utilise l'algorithme pr√©emptif habituel. <br><br>  Contrairement au cache de tampon g√©n√©ral, la m√©moire du cache local est allou√©e selon les besoins, car les tables temporaires ne sont pas utilis√©es dans toutes les sessions.  La quantit√© maximale de m√©moire pour les tables temporaires dans une session est limit√©e par le param√®tre <em>temp_buffers</em> . <br><br><h1>  R√©chauffer le cache </h1><br>  Apr√®s le red√©marrage du serveur, un certain temps doit s'√©couler avant que le cache ne se "r√©chauffe" - accumule les donn√©es r√©ellement utilis√©es activement.  Parfois, il peut √™tre utile de lire imm√©diatement les donn√©es de certaines tables dans le cache, et une extension sp√©ciale est con√ßue pour cela: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_prewarm;</code> </pre><br>  Auparavant, une extension ne pouvait lire que certaines tables dans le cache du tampon (ou uniquement dans le cache du syst√®me d'exploitation).  Mais dans PostgreSQL 11, il a pu enregistrer l'√©tat actuel du cache sur le disque et le restaurer apr√®s un red√©marrage du serveur.  Pour en profiter, vous devez ajouter la biblioth√®que √† <em>shared_preload_libraries</em> et red√©marrer le serveur. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pg_prewarm'</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Le champ de red√©marrage, si le param√®tre <em>pg_prewarm.autoprewarm</em> n'a pas chang√©, le processus d'arri√®re-plan ma√Ætre autoprewarm d√©marrera automatiquement, ce qui une fois dans <em>pg_prewarm.autoprewarm_interval videra</em> la liste des pages du cache sur le disque (n'oubliez pas de prendre en compte le nouveau processus lors de la configuration de <em>max_parallel_processes</em> ). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span>, setting, unit <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_settings <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'pg_prewarm%'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> name | setting | unit ---------------------------------+---------+------ pg_prewarm.autoprewarm | on | pg_prewarm.autoprewarm_interval | 300 | s (2 rows)</code> </pre><br><pre> <code class="plaintext hljs">postgres$ ps -o pid,command --ppid `head -n 1 /var/lib/postgresql/11/main/postmaster.pid` | grep prewarm</code> </pre><pre> <code class="plaintext hljs">10436 postgres: 11/main: autoprewarm master</code> </pre><br>  Maintenant, il n'y a pas de grande table dans le cache: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 0 (1 row)</code> </pre><br>  Si nous supposons que tout son contenu est tr√®s important, nous pouvons le lire dans le cache tampon en appelant la fonction suivante: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_prewarm(<span class="hljs-string"><span class="hljs-string">'big'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_prewarm ------------ 4097 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 4097 (1 row)</code> </pre><br>  La liste des pages est sauvegard√©e dans le fichier autoprewarm.blocks.  Pour le voir, vous pouvez simplement attendre la premi√®re ex√©cution du processus ma√Ætre de bras automatique, mais nous l'initions manuellement: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> autoprewarm_dump_now();</code> </pre><pre> <code class="plaintext hljs"> autoprewarm_dump_now ---------------------- 4340 (1 row)</code> </pre><br>  Le nombre de pages supprim√©es est sup√©rieur √† 4097 - cela inclut les pages d'objets de catalogue syst√®me d√©j√† lues par le serveur.  Et voici le dossier: <br><br><pre> <code class="plaintext hljs">postgres$ ls -l /var/lib/postgresql/11/main/autoprewarm.blocks</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 102078  29 15:51 /var/lib/postgresql/11/main/autoprewarm.blocks</code> </pre><br>  Red√©marrez maintenant le serveur √† nouveau. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Et imm√©diatement apr√®s le lancement, notre table appara√Æt √† nouveau dans le cache. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 4097 (1 row)</code> </pre><br>  Cela fournit le m√™me processus ma√Ætre √† autoprewarm: il lit le fichier, divise les pages en bases de donn√©es, les trie (afin que la lecture √† partir du disque soit aussi coh√©rente que possible) et passe le travailleur autoprewarm au flux de travail s√©par√© pour le traitement. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä suivre</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458186/">https://habr.com/ru/post/fr458186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458158/index.html">√Ä la recherche d'ast√©ro√Ødes - Projet Hubble Asteroid Hunter</a></li>
<li><a href="../fr458160/index.html">Verrouillage prioritaire dans .NET</a></li>
<li><a href="../fr458168/index.html">Sommaire des actualit√©s de l'apprentissage automatique et de l'intelligence artificielle de juin</a></li>
<li><a href="../fr458176/index.html">La barri√®re des exaflops sera franchie en 2021</a></li>
<li><a href="../fr458180/index.html">Serveur DHCP de basculement bas√© sur Kea</a></li>
<li><a href="../fr458188/index.html">Comment j'ai fait un r√©seau social en 2019</a></li>
<li><a href="../fr458202/index.html">Jetez un ≈ìil √† SObjectizer si vous souhaitez utiliser Actors ou CSP dans votre projet C ++</a></li>
<li><a href="../fr458204/index.html">Comment √©valuer les performances de stockage sur Linux: analyse comparative √† l'aide d'outils ouverts</a></li>
<li><a href="../fr458206/index.html">Sublime Text 3 pour la mise en page du site. Personnalisez l'apparence et installez les plugins. Guide du d√©butant</a></li>
<li><a href="../fr458208/index.html">√âv√©nements num√©riques √† Moscou du 01 juillet au 07 juillet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>