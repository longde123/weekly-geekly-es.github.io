<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏽 🏪 🤛🏿 Probleme mit Koordinatormustern und was hat RouteComposer damit zu tun? 🖋️ 👩🏼‍🤝‍👨🏾 🤲🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich setze die Artikelserie über die RouteComposer- Bibliothek fort, die wir verwenden, und heute möchte ich über das Koordinatormuster sprechen. Ich w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Probleme mit Koordinatormustern und was hat RouteComposer damit zu tun?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446550/"><p>  Ich setze die Artikelserie über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RouteComposer-</a> Bibliothek fort, die wir verwenden, und heute möchte ich über das Koordinatormuster sprechen.  Ich wurde aufgefordert, diesen Artikel durch eine Diskussion über einen der Artikel über das Muster zu schreiben. Der Koordinator hier auf Habr. </p><br><p>  Das vor nicht allzu langer Zeit eingeführte Koordinatormuster erfreut sich bei iOS-Entwicklern immer größerer Beliebtheit, und im Allgemeinen ist klar, warum.  Weil die von <strong>UIKit bereitgestellten</strong> Tools kein universelles Durcheinander sind. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/304/47d/bd8/30447dbd8d2a0a39a34f7f6946a02383.png" alt="Bild"></p><a name="habracut"></a><br><p>  Ich habe bereits die Frage nach der Fragmentierung der Art und Weise aufgeworfen, wie ich die Ansicht von Controllern auf dem Stapel zusammenstelle. Um Wiederholungen zu vermeiden, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> einfach darüber lesen. </p><br><p> Seien wir ehrlich.  Irgendwann stellte Epole fest, dass sie durch das Einfügen der Controller in das Anwendungsentwicklungszentrum keine sinnvolle Möglichkeit zum Erstellen oder Übertragen von Daten zwischen ihnen bot. Nachdem sie die Lösung für dieses Problem den Entwicklern anvertraut hatte, wurde sie automatisch von Xcode und möglicherweise von den UISearchConnroller-Entwicklern vervollständigt. Irgendwann wurden uns Storyboards und Segues vorgestellt.  Dann erkannte Epolus, dass sie Anwendungen, die nur aus zwei Bildschirmen bestanden, selbst schrieb, und schlug in der nächsten Iteration die Möglichkeit vor, Storyboards in mehrere Komponenten aufzuteilen, da Xcode abstürzte, als das Storyboard eine bestimmte Größe erreichte.  Segues haben sich zusammen mit diesem Konzept in mehreren Iterationen geändert, die nicht sehr kompatibel miteinander sind.  Ihre Unterstützung ist eng in die massive <code>UIViewController</code> Klasse <code>UIViewController</code> , und am Ende haben wir das bekommen, was wir haben.  Das hier: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> segue.identifier == <span class="hljs-string"><span class="hljs-string">"showDetail"</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> indexPath = tableView.indexPathForSelectedRow { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> object = objects[indexPath.row] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSDate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> controller = (segue.destination <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>).topViewController <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">DetailViewController</span></span> controller.detailItem = object controller.navigationItem.leftBarButtonItem = splitViewController?.displayModeButtonItem controller.navigationItem.leftItemsSupplementBackButton = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } }</code> </pre> <br><p>  Die Anzahl der Force-Tycastcasts in diesem Codeblock ist erstaunlich, ebenso wie die Zeichenfolgenkonstanten in den Storyboards selbst, um zu verfolgen, welche Xcodes überhaupt keine Mittel bieten.  Und der geringste Wunsch, etwas im Navigationsprozess zu ändern, ermöglicht es Ihnen, das Projekt ohne Aufwand zu kompilieren, und es stürzt mit einem Knall in der Laufzeit ab, ohne die geringste Warnung von Xcode.  Hier ist so ein WYSIWYG am Ende stellte sich heraus.  Was Sie sehen, ist was Sie bekommen. </p><br><p>  Sie können lange über den Charme dieser grauen Pfeile in Storyboards streiten, die angeblich jemandem die Verbindungen zwischen den Bildschirmen zeigen, aber wie meine Praxis gezeigt hat, habe ich absichtlich mehrere bekannte Entwickler aus verschiedenen Unternehmen interviewt, sobald das Projekt über 5-6 Bildschirme hinaus gewachsen ist, haben die Leute es versucht fand eine zuverlässigere Lösung und begann schließlich, die Struktur des Stapels von View-Controllern in meinem Kopf zu behalten.  Und wenn Unterstützung für das iPad und andere Navigationsmodelle oder Unterstützung für Pushs hinzugefügt wurde, war dort alles traurig. </p><br><p>  Seitdem wurden mehrere Versuche unternommen, um dieses Problem zu lösen, von denen einige zu separaten Frameworks führten, andere zu separaten Architekturmustern, da die Erstellung von Ansichtscontrollern innerhalb des Ansichtscontrollers dieses massive und ungeschickte Stück Code noch mehr machte. </p><br><p>  Kehren wir zum Koordinatormuster zurück.  Aus offensichtlichen Gründen finden Sie die Beschreibung nicht auf Wikipedia, da es sich nicht um ein Standardprogrammier- / Entwurfsmuster handelt.  Es handelt sich vielmehr um eine Art Abstraktion, die vorschlägt, all diesen „hässlichen“ Code unter der Haube zu verstecken, um einen neuen Controller-Twist auf dem Stack zu erstellen und einzufügen, Links zum Controller-Container zu speichern und Daten zwischen Controllern zu übertragen.  Den am besten geeigneten Artikel, der diesen Prozess beschreibt, würde ich einen Artikel auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">raywenderlich.com nennen</a> .  Es wird nach der NSSpain-Konferenz 2015 populär, als die breite Öffentlichkeit darüber informiert wurde.  Was hier gesagt wurde, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Ich werde kurz beschreiben, woraus es besteht, bevor ich weitermache. </p><br><p>  Das Koordinatormuster in allen Interpretationen passt ungefähr in dieses Bild: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/554/4bb/f95/5544bbf95415d233060a7e4d515ff58d.png"></p><br><p>  Das heißt, der Koordinator ist ein Protokoll </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> }</code> </pre> <br><p>  Und der ganze hässliche Code soll in der Startfunktion versteckt sein.  Der Koordinator kann außerdem Links zu untergeordneten Koordinatoren haben, dh sie können kompositorisch erstellt werden, und Sie können beispielsweise eine Implementierung durch eine andere ersetzen.  Das heißt, es klingt ziemlich elegant. </p><br><p>  Die Irrtümer beginnen jedoch ziemlich bald: </p><br><ol><li>  Einige Implementierungen schlagen vor, den Koordinator von einem bestimmten Generierungsmuster in etwas Vernünftigeres zu verwandeln, den Stapel von Controllern zu beobachten und <em>ihn zu einem Delegaten des Containers zu machen</em> , z. B. <code>UINavigationController</code> , um das Klicken auf die Schaltfläche Zurück oder das Zurückwischen und Löschen des <code>UINavigationController</code> Koordinators zu verarbeiten.  Aus natürlichen Gründen kann nur ein Objekt ein Delegat sein, was die Kontrolle über den Container selbst einschränkt und dazu führt, dass diese Logik entweder beim Koordinator liegt oder die Notwendigkeit schafft, diese Logik weiter unten an jemanden weiter unten in der Liste zu delegieren. </li><li>  Oft <em>hängt</em> die Logik zum Erstellen des nächsten Controllers <em>von der Geschäftslogik ab</em> .  Um beispielsweise zum nächsten Bildschirm zu gelangen, muss der Benutzer am System angemeldet sein.  Dies ist eindeutig ein asynchroner Prozess, der das Generieren eines Zwischenbildschirms mit dem Anmeldeformular umfasst. Der Anmeldevorgang selbst kann erfolgreich beendet werden oder nicht.  Um zu vermeiden, dass der Koordinator in einen Massive Coordinator (ähnlich dem Massive View Controller) umgewandelt wird, müssen wir ihn zerlegen.  Das heißt, Sie müssen einen Koordinator-Koordinator erstellen. </li><li>  Ein weiteres Problem für Koordinatoren besteht darin, dass sie im Wesentlichen Wrapper für Container-View-Controller wie <code>UINavigationController</code> , <code>UITabBarController</code> usw. sind.  Und jemand sollte <em>Links zu diesen Controllern</em> bereitstellen.  Wenn bei Kinderkoordinatoren alles noch weniger klar ist, dann ist bei den Anfangskoordinatoren der Kette nicht alles so einfach.  Wenn Sie die Navigation ändern, beispielsweise für den A / B-Test, führt das Refactoring und die Anpassung solcher Koordinatoren zu separaten Kopfschmerzen.  Besonders wenn sich der Containertyp ändert. </li><li>  All dies wird noch komplizierter, wenn die Anwendung <em>externe Ereignisse unterstützt</em> , die View Controller generieren.  Zum Beispiel Push-Benachrichtigungen oder universelle Links (der Benutzer klickt auf den Link im Brief und fährt im entsprechenden Anwendungsbildschirm fort).  Hier ergeben sich andere Unsicherheiten, auf die das Koordinatormuster keine genaue Antwort hat.  Sie müssen genau wissen, auf welchem ​​Bildschirm sich der Benutzer gerade befindet, um ihm den nächsten Bildschirm anzuzeigen, der von einem externen Ereignis angefordert wird. <br>  Das einfachste Beispiel ist eine Chat-Anwendung, die aus 3 Bildschirmen besteht - einer Chat-Liste, dem Chat selbst, der in die Navigation des Chat-Listen-Controllers verschoben wird, und dem modal angezeigten Einstellungsbildschirm.  Der Benutzer kann sich auf einem dieser Bildschirme befinden, wenn er eine Push-Benachrichtigung erhält und darauf tippt.  Und hier beginnt die Unsicherheit: Wenn er in der Chat-Liste ist, müssen Sie einen Chat mit diesem bestimmten Benutzer starten. Wenn er bereits im Chat ist, müssen Sie ihn wechseln. Wenn er bereits im Chat mit diesem Benutzer ist, tun Sie nichts und aktualisieren Sie ihn, wenn der Benutzer eingeschaltet ist Einstellungsbildschirm - anscheinend müssen Sie die vorherigen Schritte schließen und befolgen.  Oder vielleicht nicht schließen und den Chat einfach modal über die Einstellungen anzeigen?  Und wenn sich die Einstellungen auf einer anderen Registerkarte befinden und nicht modal?  Diese <code>if/else</code> entweder über die Koordinatoren verteilt oder gehen in Form eines Stückes Spaghetti zu einem anderen Mega-Koordinator.  Außerdem handelt es sich entweder um aktive Iterationen auf dem Ansichtsstapel der Controller und um den Versuch, festzustellen, wo sich der Benutzer gerade befindet, oder um den Versuch, eine Anwendung zu erstellen, die seinen Status überwacht. Dies ist jedoch keine einfache Aufgabe, die nur auf der Art des Ansichts-Controller-Stapels selbst basiert. </li><li>  Und die Kirsche auf dem Kuchen sind <em>UIKit-Pannen</em> .  Ein triviales Beispiel: ein <code>UITabBarController</code> mit einem <code>UINavigationController</code> auf der zweiten Registerkarte mit einem anderen <code>UIViewController</code> .  Der Benutzer auf der ersten Registerkarte verursacht ein bestimmtes Ereignis, bei dem die Registerkarte <code>UINavigationController</code> und ein anderer Ansichtscontroller in seinen <code>UINavigationController</code> .  All dies muss in einer solchen Reihenfolge erfolgen.  Wenn der Benutzer zuvor noch nie eine zweite Registerkarte geöffnet hat und <code>UINavigationController</code> auf dem <code>viewDidLoad</code> nicht aufgerufen wurde, <code>viewDidLoad</code> die <code>push</code> Methode nicht und hinterlässt nur eine undeutliche Nachricht in der Konsole.  Das heißt, Koordinatoren können in diesem Beispiel nicht einfach zu Zuhörern von Ereignissen gemacht werden, sie müssen in einer bestimmten Reihenfolge arbeiten.  Sie müssen also voneinander Kenntnis haben.  Und dies widerspricht bereits der ersten Aussage des Koordinatormusters, dass die Koordinatoren nichts über die generierenden Koordinatoren wissen und nur mit den untergeordneten Koordinatoren verbunden sind.  Und schränkt auch ihre Austauschbarkeit ein. </li></ol><br><p>  Diese Liste kann fortgesetzt werden, aber im Allgemeinen ist klar, dass das Koordinatormuster eine eher begrenzte, schlecht skalierbare Lösung ist.  Wenn Sie es ohne rosa Brille betrachten, können Sie einen Teil der Logik, die normalerweise in massiven <code>UIViewController</code> , in eine andere Klasse <code>UIViewController</code> .  Alle Versuche, mehr als nur eine generative Fabrik zu schaffen und dort andere Logik einzuführen, enden nicht gut. </p><br><p>  Es ist erwähnenswert, dass es Bibliotheken gibt, die auf diesem Muster basieren und auf die eine oder andere Weise die oben genannten Nachteile teilweise abmildern können.  Ich würde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XCoordinator</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxFlow erwähnen</a> . </p><br><h2 id="chto-sdelali-my">  Was haben wir getan </h2><br><p>  Nachdem wir an dem Projekt mitgewirkt hatten, das wir von einem anderen Team zur Unterstützung und Entwicklung mit den Koordinatoren und ihrem vereinfachten „Urgroßmutter“ <em>-Router</em> im <em>VIPER-</em> Architekturansatz erhalten hatten, <em>kehrten</em> wir zu dem Ansatz zurück, der im vorherigen großen Projekt unseres Unternehmens gut funktioniert hatte.  Dieser Ansatz hat keinen Namen.  Es liegt an der Oberfläche.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unserer</a> Freizeit wurde es in eine separate <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RouteComposer-</a> Bibliothek kompiliert, die die Koordinatoren vollständig ersetzte und sich als flexibler erwies. </p><br><p>  Was ist dieser Ansatz?  Um mich auf den Stapel (Baum) zu verlassen, drehe ich die Controller so, wie sie sind.  Um keine unnötigen Entitäten zu erstellen, die überwacht werden müssen.  Speichern oder verfolgen Sie keine Bedingungen. </p><br><p>  Schauen wir uns die <em>UIKit-</em> Entitäten <em>genauer an</em> und versuchen herauszufinden, was wir unter dem Strich haben und <em>womit</em> wir arbeiten können: </p><br><ol><li>  <strong>Der Controller-Stack</strong> ist ein Baum.  Es gibt einen Root-View-Controller mit untergeordneten View-Controllern.  Modal dargestellte View-Controller sind ein Sonderfall von untergeordneten View-Controllern, da sie auch eine Bindung zum generierten View-Controller haben.  Es ist alles sofort verfügbar. </li><li>  Ich muss Entitäten von Controllern erstellen.  Sie haben alle unterschiedliche Konstruktoren und können mit Xib-Dateien oder Storyboards erstellt werden.  Sie haben unterschiedliche Eingabeparameter.  Aber sie sind sich darin einig, dass sie geschaffen werden müssen.  Hier können wir also das <strong>Factory-</strong> Muster verwenden, das weiß, wie der gewünschte Ansichts-Controller erstellt wird.  Jede Fabrik lässt sich leicht mit umfassenden Unit-Tests abdecken und ist unabhängig von anderen. </li><li>  Wir unterteilen die View Controller in zwei Klassen: 1. Zeigen Sie einfach die Controller an, 2. <strong>Container View Controller (Container View Controller)</strong> .  Container-View-Controller unterscheiden sich von normalen darin, dass sie untergeordnete View-Controller enthalten können - auch Container oder einfache.  Solche View Controller sind <code>UINavigationController</code> verfügbar: <code>UINavigationController</code> , <code>UITabBarController</code> usw., können aber auch vom Benutzer erstellt werden.  Wenn wir es ignorieren, finden wir die folgenden Eigenschaften in allen Containern: 1. Sie haben eine Liste aller Controller, die sie enthalten.  2. Ein oder mehrere Controller sind derzeit sichtbar.  3. Sie werden möglicherweise aufgefordert, einen dieser Controller sichtbar zu machen.  Dies ist alles, was <em>UIKit-</em> Controller <em>tun können</em> .  Sie haben nur verschiedene Methoden dafür.  Es gibt aber nur 3 Aufgaben. </li><li>  Um einen werkseitig erstellten Ansichtscontroller einzubetten, <code>UITabBarController.selectedViewController = ...</code> die übergeordnete Ansichtsmethode des Controllers <code>UINavigationController.pushViewController(...)</code> , <code>UITabBarController.selectedViewController = ...</code> , <code>UIViewController.present(...)</code> usw.  Möglicherweise stellen Sie fest, dass immer zwei Ansichtscontroller erforderlich sind, einer bereits auf dem Stapel und einer, der in den Stapel eingebettet werden muss.  Wickeln Sie dies in einen Wrapper und nennen Sie es <strong>Aktion (Aktion)</strong> .  Jede Aktion lässt sich leicht mit umfassenden Unit-Tests abdecken und ist unabhängig von den anderen. </li><li>  Aus dem oben Gesagten geht hervor, dass Sie mit vorbereiteten Entitäten die Konfigurationskette <em>Factory -&gt; Action -&gt; Factory -&gt; Action -&gt; Factory</em> erstellen und nach Abschluss einen Ansichtsbaum von Controllern beliebiger Komplexität erstellen können.  Sie müssen nur den Einstiegspunkt angeben.  Diese Eingabepunkte sind normalerweise entweder der <em>rootViewController</em> des <em>UIWindow</em> oder der aktuelle View Controller, der der extremste Zweig des Baums ist.  Das heißt, eine solche Konfiguration ist korrekt geschrieben als: <strong>Starten von ViewController -&gt; Aktion -&gt; Factory -&gt; ... -&gt; Factory</strong> . </li><li>  Zusätzlich zur Konfiguration benötigen Sie eine Entität, die weiß, wie die bereitgestellte Konfiguration gestartet und erstellt wird.  Wir werden es <strong>Router nennen</strong> .  Es hat keinen Status, es enthält keine Links.  Es verfügt über eine Methode, an die die Konfiguration übergeben wird, und führt die Konfigurationsschritte nacheinander aus. </li><li>  Fügen Sie dem Router Verantwortung hinzu, indem Sie der Konfigurationskette <strong>Interceptors-</strong> Klassen hinzufügen.  Es gibt drei Arten von Abfangjägern: 1. Wird vor dem Start der Navigation gestartet.  Wir entfernen die Aufgaben der Benutzerauthentifizierung im System und andere asynchrone Aufgaben im System.  2. Führen Sie zum Zeitpunkt der Erstellung des Ansichtscontrollers aus, um die Werte festzulegen.  3. Wird nach der Navigation und nach verschiedenen analytischen Aufgaben ausgeführt.  Jede Entität kann leicht durch Komponententests abgedeckt werden und weiß nicht, wie sie in der Konfiguration verwendet wird.  Sie hat nur eine Verantwortung und sie erfüllt sie.  Das heißt, die Konfiguration für die komplexe Navigation sieht möglicherweise wie <strong>folgt aus: [Aufgabe vor der Navigation ...] -&gt; ViewController starten -&gt; Aktion -&gt; (Factory + [ContextTask ...]) -&gt; ... -&gt; (Factory + [ContextTask ...]) -&gt; [Post NavigationTask ...]</strong> .  Das heißt, alle Aufgaben werden vom Router nacheinander ausgeführt, wobei wiederum kleine, leicht lesbare atomare Einheiten ausgeführt werden. </li><li>  Die letzte Aufgabe, die von der Konfiguration nicht gelöst werden kann, bleibt bestehen - dies ist der aktuelle Status der Anwendung.  Was ist, wenn wir nicht die gesamte Konfigurationskette, sondern nur einen Teil davon erstellen müssen, weil der Benutzer sie teilweise übergeben hat?  Diese Frage kann vom Tree of View Controller immer eindeutig beantwortet werden.  Denn wenn ein Teil der Kette bereits aufgebaut ist, befindet er sich bereits im Baum.  Dies bedeutet, dass der Router verstehen kann, welcher Teil der Kette fertiggestellt werden muss, wenn jede Fabrik in der Kette die Frage beantworten kann, ob sie gebaut wurde oder nicht.  Dies ist natürlich nicht die Aufgabe der Factory, daher wird eine andere atomare Entität eingeführt - der <strong>Finder.</strong> Jede Konfiguration sieht folgendermaßen aus: <strong>[Aufgabe vor der Navigation ...] -&gt; ViewController starten -&gt; Aktion -&gt; (Finder / Factory + [ContextTask ...]) -&gt; ... -&gt; (Finder / Factory + [ContextTask ...]) -&gt; [Post NavigationTask ...]</strong> .  Wenn der Router am Ende mit dem Lesen beginnt, teilt ihm einer der Finder mit, dass es bereits erstellt wurde, und der Router beginnt ab diesem Zeitpunkt, die Kette wieder aufzubauen.  Wenn sich keiner von ihnen im Baum befindet, müssen Sie die gesamte Kette vom ursprünglichen Controller aus erstellen. <br><img src="https://habrastorage.org/getpro/habr/post_images/f50/a64/213/f50a64213fa1654fbde33e53b31f4e43.gif" alt="Bild"></li><li>  Die Konfiguration muss stark typisiert sein.  Daher arbeitet jede Entität nur mit einem Typ von Controller-Ansicht, ein Typ von Daten und Konfiguration beruht vollständig auf der Fähigkeit von Swift, schnell mit <strong>zugeordneten</strong> Typen zu arbeiten.  Wir wollen uns auf den Compiler verlassen, nicht auf die Laufzeit.  Ein Entwickler kann die Eingabe absichtlich schwächen, aber nicht umgekehrt. </li></ol><br><p>  Ein Beispiel für eine solche Konfiguration: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> productScreen = <span class="hljs-type"><span class="hljs-type">StepAssembly</span></span>(finder: <span class="hljs-type"><span class="hljs-type">ProductViewControllerFinder</span></span>(), factory: <span class="hljs-type"><span class="hljs-type">ProductViewControllerFactory</span></span>()) .add(<span class="hljs-type"><span class="hljs-type">LoginInterceptor</span></span>&lt;<span class="hljs-type"><span class="hljs-type">UUID</span></span>&gt;()) <span class="hljs-comment"><span class="hljs-comment">// Have to specify the context type till https://bugs.swift.org/browse/SR-8719 is fixed .add(ProductViewControllerContextTask()) .add(ProductViewControllerPostTask(analyticsManager: AnalyticsManager.sharedInstance)) .using(UINavigationController.push()) .from(NavigationControllerStep()) .using(GeneralActions.presentModally()) .from(GeneralStep.current()) .assemble()</span></span></code> </pre> <br><p>  Die oben beschriebenen Elemente decken die gesamte Bibliothek ab und beschreiben den Ansatz.  Wir müssen nur noch die Kettenkonfigurationen bereitstellen, die der Router ausführt, wenn der Benutzer auf eine Schaltfläche klickt oder ein externes Ereignis eintritt.  Wenn es sich um verschiedene Gerätetypen handelt, z. B. iPhone oder iPad, stellen wir mithilfe des Polymorphismus unterschiedliche Übergangskonfigurationen bereit.  Wenn wir A / B-Tests haben, dasselbe.  Wir müssen zum Zeitpunkt des Starts der Navigation nicht über den Status der Anwendung nachdenken. Wir müssen sicherstellen, dass die Konfiguration anfangs korrekt geschrieben ist, und wir sind sicher, dass der Router sie irgendwie erstellen wird. </p><br><p>  Der beschriebene Ansatz ist komplizierter als eine bestimmte Abstraktion oder ein bestimmtes Muster, aber wir haben uns dem Problem noch nicht gestellt, wo es nicht ausreichen würde.  Natürlich erfordert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RouteComposer</a> einige Studien und Kenntnisse darüber, wie es funktioniert.  Dies ist jedoch viel einfacher als das Erlernen der Grundlagen von AutoLayout oder RunLoop.  Keine höhere Mathematik. </p><br><p>  Die Bibliothek sowie die Implementierung des ihr zur Verfügung gestellten Routers verwenden keine objektiven Tricks zur Laufzeit und folgen vollständig allen Cocoa Touch-Konzepten. Sie helfen nur dabei, den Kompositionsprozess in Schritte zu unterteilen und diese in der angegebenen Reihenfolge auszuführen.  Die Bibliothek wird mit den iOS-Versionen 9 bis 12 getestet. </p><br><p>  Weitere Details finden Sie in früheren Artikeln: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammensetzung der UIViewController und Navigation zwischen ihnen (und nicht nur) / Geek Magazine</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konfigurationsbeispiele für UIViewController mit dem RouteComposer / Geek-Magazin</a> </p><br><p>  Vielen Dank für Ihre Aufmerksamkeit.  Gerne beantworte ich Fragen in den Kommentaren. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446550/">https://habr.com/ru/post/de446550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446536/index.html">Warteschlangen und JMeter: Austausch mit Publisher und Subscriber</a></li>
<li><a href="../de446538/index.html">PhotoGuru wechselte zur "dunklen Seite" und "weiser"</a></li>
<li><a href="../de446544/index.html">Microsoft erweitert das Azure IP Advantage-Programm um neue IP-Vorteile für Azure IoT-Innovatoren und -Starts</a></li>
<li><a href="../de446546/index.html">Microsoft erweitert Azure IP Advantage um neue IP-Vorteile für Azure IoT-Innovatoren und -Starts</a></li>
<li><a href="../de446548/index.html">Analyse von Statistiken zu Werbekampagnen - Erstellen Sie eine neue Metrik im DataFrame (Python)</a></li>
<li><a href="../de446552/index.html">Arbeiten mit APDU-Befehlen anhand des Beispiel-EToken</a></li>
<li><a href="../de446554/index.html">Yandex Resident Program oder Wie man aus einem erfahrenen Backend ein ML-Ingenieur wird</a></li>
<li><a href="../de446558/index.html">Exotische Datenstrukturen: Modifizierte Merkle Patricia Trie</a></li>
<li><a href="../de446560/index.html">"Courtesy Exchange": die Essenz des Konflikts zwischen den beiden bekanntesten Streaming-Unternehmen</a></li>
<li><a href="../de446562/index.html">Asynchronität in der Programmierung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>