<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😇 🌽 🚟 Comment ne pas réécrire un projet dans Rust 🧔 🔆 👵🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dès que vous franchissez le seuil de douleur Borrow-Checker et réalisez que Rust vous permet de faire des choses inimaginables (et parfois dangereuses...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment ne pas réécrire un projet dans Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474666/"><p><img align="right" width="320" src="https://habrastorage.org/webt/dr/uk/dk/drukdkvyoebpgesff5zb_o1zplm.png">  Dès que vous franchissez le seuil de douleur <em>Borrow-Checker</em> et réalisez que Rust vous permet de faire des choses inimaginables (et parfois dangereuses) dans d'autres langues, vous pouvez également avoir le même désir irrésistible de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tout réécrire sur Rust</a> .  Bien que dans le meilleur des cas, cela soit tout à fait improductif (efforts de dilapidation sans signification pour plusieurs projets), dans le pire des cas, cela entraîne une diminution de la qualité du code (après tout, pourquoi vous considérez-vous plus expérimenté dans le domaine de l'utilisation de la bibliothèque que son auteur d'origine?) </p><br><p>  Il serait beaucoup plus utile de fournir une interface sécurisée pour la bibliothèque d'origine en réutilisant son code. </p><a name="habracut"></a><br><p> • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Premiers pas</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nous collectons chmlib-sys</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Écriture d'un wrapper sécurisé dans Rust</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rechercher des articles par nom</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contourner les éléments par filtre</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lecture du contenu des fichiers</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ajouter des exemples</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Table des matières du fichier CHM</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Déballage du fichier CHM sur le disque</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Et ensuite?</a> </p><br><blockquote>  Cet article présente un vrai projet.  J'ai dû extraire des informations des fichiers CHM existants, mais je n'ai pas eu le temps de comprendre le format.  La paresse est le moteur du progrès. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La <strong>caisse chmlib est</strong> publiée sur crates.io</a> , et son code source est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur GitHub</a> .  Si vous le trouvez utile ou rencontrez des problèmes, faites-le moi savoir <a href="">via le bugtracker</a> . </blockquote><br><h2 id="pervye-shagi">  Premiers pas </h2><br><p>  Pour commencer, il vaut la peine de comprendre comment le travail avec la bibliothèque a été initialement conçu. </p><br><blockquote>  Cela vous apprendra non seulement à l'utiliser, mais vous assurera également que tout se passe.  Si vous avez de la chance, vous trouverez même des tests et des exemples prêts à l'emploi. <br><br>  <strong>Ne sautez pas cette étape!</strong> </blockquote><p> Nous travaillerons avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CHMLib</a> , une bibliothèque C pour lire les fichiers <em>Microsoft Compiled HTML Help</em> ( <code>.chm</code> ). </p><br><p>  Commençons par créer un nouveau projet et connecter CHMLib en tant que sous-module git: </p><br><pre> <code class="plaintext hljs">$ git init chmlib &amp;&amp; cd chmlib Initialized empty Git repository in /home/michael/Documents/chmlib/.git/ $ touch README.md Cargo.toml $ cargo new --lib chmlib Created library `chmlib` package $ cargo new --lib chmlib-sys Created library `chmlib-sys` package $ cat Cargo.toml [workspace] members = ["chmlib", "chmlib-sys"] $ git submodule add git@github.com:jedwing/CHMLib.git vendor/CHMLib Cloning into '/home/michael/Documents/chmlib/vendor/CHMLib'... remote: Enumerating objects: 99, done. remote: Total 99 (delta 0), reused 0 (delta 0), pack-reused 99 Receiving objects: 100% (99/99), 375.51 KiB | 430.00 KiB/s, done. Resolving deltas: 100% (45/45), done.</code> </pre> <br><p>  Après cela, jetez un œil à ce qui se trouve à l'intérieur de l' <code>tree</code> : </p><br><pre> <code class="plaintext hljs">$ tree vendor/CHMLib vendor/CHMLib ├── acinclude.m4 ├── AUTHORS ├── ChangeLog ├── ChmLib-ce.zip ├── ChmLib-ds6.zip ├── configure.in ├── contrib │ └── mozilla_helper.sh ├── COPYING ├── Makefile.am ├── NEWS ├── NOTES ├── README └── src ├── chm_http.c ├── chm_lib.c ├── chm_lib.h ├── enum_chmLib.c ├── enumdir_chmLib.c ├── extract_chmLib.c ├── lzx.c ├── lzx.h ├── Makefile.am ├── Makefile.simple └── test_chmLib.c 2 directories, 23 files</code> </pre> <br><p>  Il semble que la bibliothèque utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GNU Autotools</a> pour construire.  Ce n'est pas bon, car tous les utilisateurs de la caisse chmlib (et leurs utilisateurs) devront installer Autotools. </p><br><blockquote>  Nous allons essayer de nous débarrasser de cette dépendance "contagieuse" en collectant le code C manuellement, mais plus à ce sujet plus tard. </blockquote><p>  Les fichiers lzx.h et lzx.c contiennent une implémentation de l'algorithme de compression <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LZX</a> .  En général, il serait préférable d'utiliser une sorte de bibliothèque liblzx pour obtenir des mises à jour gratuites et tout ça, mais il serait peut-être plus facile de compiler bêtement ces fichiers. </p><br><p>  enum_chmLib.c, enumdir_chmLib.c, extract_chmLib.c semblent être des exemples d'utilisation des fonctions chm_enumerate (), chm_enumerate_dir (), chm_retrieve_object ().  Cela vous sera utile ... </p><br><p>  Le fichier test_chmLib.c contient un autre exemple, cette fois en extrayant une page du fichier CHM sur le disque. </p><br><p>  chm_http.c implémente un simple serveur HTTP affichant un fichier .chm dans un navigateur.  Cela ne sera probablement plus utile. </p><br><p>  Nous avons donc trié tout ce qui se trouve dans le fournisseur / CHMLib / src.  Allons-nous récupérer la bibliothèque? </p><br><p>  Honnêtement, il est assez petit pour appliquer la méthode scientifique du poke. </p><br><pre> <code class="plaintext hljs">$ clang chm_lib.c enum_chmLib.c -o enum_chmLib /usr/bin/ld: /tmp/chm_lib-537dfe.o: in function `chm_close': chm_lib.c:(.text+0x8fa): undefined reference to `LZXteardown' /usr/bin/ld: /tmp/chm_lib-537dfe.o: in function `_chm_decompress_region': chm_lib.c:(.text+0x18ca): undefined reference to `LZXinit' /usr/bin/ld: /tmp/chm_lib-537dfe.o: in function `_chm_decompress_block': chm_lib.c:(.text+0x2900): undefined reference to `LZXreset' /usr/bin/ld: chm_lib.c:(.text+0x2a4b): undefined reference to `LZXdecompress' /usr/bin/ld: chm_lib.c:(.text+0x2abe): undefined reference to `LZXreset' /usr/bin/ld: chm_lib.c:(.text+0x2bf4): undefined reference to `LZXdecompress' clang: error: linker command failed with exit code 1 (use -v to see invocation)</code> </pre> <br><p>  D'accord, peut-être que ce LZX est toujours nécessaire ... </p><br><pre> <code class="plaintext hljs">$ clang chm_lib.c enum_chmLib.c lzx.c -o enum_chmLib</code> </pre> <br><p>  Euh ... tout? </p><br><p>  Pour m'assurer que le code fonctionne, j'ai téléchargé un exemple sur Internet: </p><br><pre> <code class="plaintext hljs">$ curl http://www.innovasys.com/static/hs/samples/topics.classic.chm.zip \ -o topics.classic.chm.zip $ unzip topics.classic.chm.zip Archive: topics.classic.chm.zip inflating: output/compiled/topics.classic.chm $ file output/compiled/topics.classic.chm output/compiled/topics.classic.chm: MS Windows HtmlHelp Data</code> </pre> <br><p>  Voyons comment enum_chmLib le gère: </p><br><pre> <code class="plaintext hljs">$ ./enum_chmLib output/compiled/topics.classic.chm output/compiled/topics.classic.chm: spc start length type name === ===== ====== ==== ==== 0 0 0 normal dir / 1 5125797 4096 special file /#IDXHDR ... 1 4944434 11234 normal file /BrowserView.html ... 0 0 0 normal dir /flash/ 1 532689 727 normal file /flash/expressinstall.swf 0 0 0 normal dir /Images/Commands/RealWorld/ 1 24363 1254 normal file /Images/Commands/RealWorld/BrowserBack.bmp ... 1 35672 1021 normal file /Images/Employees24.gif ... 1 3630715 200143 normal file /template/packages/jquery-mobile/script/ jquery.mobile-1.4.5.min.js ... 0 134 1296 meta file ::DataSpace/Storage/MSCompressed/Transform/ {7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/ InstanceData/ResetTable</code> </pre> <br><p>  Seigneur, <em>même ici</em> jQuery ¯ \ _ (ツ) _ / ¯ </p><br><h2 id="sobiraem-chmlib-sys">  Construire chmlib-sys </h2><br><p>  Nous en savons maintenant assez pour utiliser CHMLib dans la <strong>caisse</strong> chmlib <strong>-sys</strong> , qui est responsable de la construction de la bibliothèque native, de sa liaison avec le compilateur Rast et d'une interface avec les fonctions C. </p><br><p>  Pour créer la bibliothèque, vous devez écrire le fichier <code>build.rs</code> .  À l'aide de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">caisse <strong>cc</strong> ,</a> il appellera le compilateur C et fera d'autres amitiés pour que tout fonctionne ensemble comme il se doit. </p><br><blockquote>  Nous avons la chance de pouvoir déplacer la majeure partie du travail en cc, mais parfois c'est beaucoup plus difficile.  En savoir plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans la documentation des scripts d'assemblage</a> . </blockquote><p>  Ajoutez d'abord <strong>cc</strong> comme dépendance pour chmlib-sys: </p><br><pre> <code class="plaintext hljs">$ cd chmlib-sys $ cargo add --build cc Updating 'https://github.com/rust-lang/crates.io-index' index Adding cc v1.0.46 to build-dependencies</code> </pre> <br><p>  Ensuite, nous écrivons <code>build.rs</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib-sys/build.rs use cc::Build; use std::{env, path::PathBuf}; fn main() { let project_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap()) .canonicalize() .unwrap(); let root_dir = project_dir.parent().unwrap(); let src = root_dir.join("vendor").join("CHMLib").join("src"); Build::new() .file(src.join("chm_lib.c")) .file(src.join("lzx.c")) .include(&amp;src) .warnings(false) .compile("chmlib"); }</span></span></code> </pre> <br><p>  Vous devez également indiquer à Cargo que chmlib-sys est lié à la bibliothèque chmlib.  Cargo peut alors garantir que dans le graphique de dépendance entier, il n'y a qu'un seul rack, en fonction de la bibliothèque native spécifique.  Cela évite les messages d'erreur obscurs sur les caractères répétés ou l'utilisation accidentelle de bibliothèques incompatibles. </p><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/chmlib-sys/Cargo.toml +++ b/chmlib-sys/Cargo.toml @@ -3,7 +3,13 @@ name = "chmlib-sys" version = "0.1.0" authors = ["Michael Bryan &lt;michaelfbryan@gmail.com&gt;"] edition = "2018" description = "Raw bindings to the CHMLib C library" license = "LGPL" repository = "https://github.com/Michael-F-Bryan/chmlib" +links = "chmlib" +build = "build.rs" [dependencies] [build-dependencies] cc = { version = "1.0" }</span></span></code> </pre> <br><p>  Ensuite, nous devons déclarer toutes les fonctions exportées par la bibliothèque chmlib afin qu'elles puissent être utilisées à partir de Rast. </p><br><p>  C'est pour cela qu'il y a un merveilleux projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bindgen</a> .  Le fichier d'en-tête C est donné à l'entrée et le fichier avec les liaisons FFI pour Rast est sorti. </p><br><pre> <code class="plaintext hljs">$ cargo install bindgen $ bindgen ../vendor/CHMLib/src/chm_lib.h \ -o src/lib.rs \ --raw-line '#![allow(non_snake_case, non_camel_case_types)]' $ head src/lib.rs /* automatically generated by rust-bindgen */ #![allow(non_snake_case, non_camel_case_types)] pub const CHM_UNCOMPRESSED: u32 = 0; pub const CHM_COMPRESSED: u32 = 1; pub const CHM_MAX_PATHLEN: u32 = 512; pub const CHM_PARAM_MAX_BLOCKS_CACHED: u32 = 0; pub const CHM_RESOLVE_SUCCESS: u32 = 0; pub const CHM_RESOLVE_FAILURE: u32 = 1; $ tail src/lib.rs extern "C" { pub fn chm_enumerate_dir( h: *mut chmFile, prefix: *const ::std::os::raw::c_char, what: ::std::os::raw::c_int, e: CHM_ENUMERATOR, context: *mut ::std::os::raw::c_void, ) -&gt; ::std::os::raw::c_int; }</code> </pre> <br><blockquote>  Je recommande fortement de lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le manuel d'utilisation de Bindgen</a> si vous avez besoin de réparer quelque chose dans son échappement. </blockquote><p>  À ce stade, il sera utile d'écrire un test de fumée qui vérifiera que tout fonctionne comme prévu et que nous pouvons réellement appeler les fonctions de la bibliothèque C d'origine. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib-sys/tests/smoke_test.rs //    Path  char*     . //  , OsStr ( Path)  Windows  [u16]  , //        char*. #![cfg(unix)] use std::{ffi::CString, os::unix::ffi::OsStrExt, path::Path}; #[test] fn open_example_file() { let project_dir = Path::new(env!("CARGO_MANIFEST_DIR")); let sample_chm = project_dir.parent().unwrap().join("topics.classic.chm"); let c_str = CString::new(sample_chm.as_os_str().as_bytes()).unwrap(); unsafe { let handle = chmlib_sys::chm_open(c_str.as_ptr()); assert!(!handle.is_null()); chmlib_sys::chm_close(handle); } }</span></span></code> </pre> <br><p>  <code>cargo test</code> dit que tout semble être en ordre: </p><br><pre> <code class="plaintext hljs">$ cargo test Finished test [unoptimized + debuginfo] target(s) in 0.03s Running ~/chmlib/target/debug/deps/chmlib_sys-2ffd7b11a9fd8437 running 1 test test bindgen_test_layout_chmUnitInfo ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out Running ~/chmlib/target/debug/deps/smoke_test-f7be9810412559dc running 1 test test open_example_file ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out Doc-tests chmlib-sys running 0 tests test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</code> </pre> <br><h2 id="pishem-bezopasnuyu-obyortku-na-rust">  Écrire un wrapper sécurisé dans Rust </h2><br><p>  <em>Techniquement et techniquement,</em> nous pouvons maintenant appeler CHMLib depuis Rasta, mais cela nécessite un tas <strong>dangereux</strong> .  Cela peut fonctionner pour un métier hackneyed, mais pour la publication sur crates.io, il vaut la peine d'écrire un wrapper sécurisé pour tout le code dangereux. </p><br><p>  Si vous regardez l'API chmlib-sys en utilisant <code>cargo doc --open</code> , vous pouvez voir de nombreuses fonctions qui prennent <strong><code>*mut ChmFile</code></strong> comme premier argument.  Ceci est similaire aux objets et aux méthodes. </p><br><div class="spoiler">  <b class="spoiler_title">Fichier d'en-tête CHMLib</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* $Id: chm_lib.h,v 1.10 2002/10/09 01:16:33 jedwin Exp $ */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*************************************************************************** * chm_lib.h - CHM archive manipulation routines * * ------------------- * * * * author: Jed Wing &lt;jedwin@ugcs.caltech.edu&gt; * * version: 0.3 * * notes: These routines are meant for the manipulation of microsoft * * .chm (compiled html help) files, but may likely be used * * for the manipulation of any ITSS archive, if ever ITSS * * archives are used for any other purpose. * * * * Note also that the section names are statically handled. * * To be entirely correct, the section names should be read * * from the section names meta-file, and then the various * * content sections and the "transforms" to apply to the data * * they contain should be inferred from the section name and * * the meta-files referenced using that name; however, all of * * the files I've been able to get my hands on appear to have * * only two sections: Uncompressed and MSCompressed. * * Additionally, the ITSS.DLL file included with Windows does * * not appear to handle any different transforms than the * * simple LZX-transform. Furthermore, the list of transforms * * to apply is broken, in that only half the required space * * is allocated for the list. (It appears as though the * * space is allocated for ASCII strings, but the strings are * * written as unicode. As a result, only the first half of * * the string appears.) So this is probably not too big of * * a deal, at least until CHM v4 (MS .lit files), which also * * incorporate encryption, of some description. * ***************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*************************************************************************** * * * This program is free software; you can redistribute it and/or modify * * it under the terms of the GNU Lesser General Public License as * * published by the Free Software Foundation; either version 2.1 of the * * License, or (at your option) any later version. * * * ***************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> INCLUDED_CHMLIB_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> INCLUDED_CHMLIB_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __cplusplus extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RWE 6/12/1002 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> PPC_BSTR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wtypes.h&gt; #endif #ifdef WIN32 #ifdef __MINGW32__ #define __int64 long long #endif typedef unsigned __int64 LONGUINT64; typedef __int64 LONGINT64; #else typedef unsigned long long LONGUINT64; typedef long long LONGINT64; #endif /* the two available spaces in a CHM file */ /* NB: The format supports arbitrarily many spaces, but only */ /* two appear to be used at present. */ #define CHM_UNCOMPRESSED (0) #define CHM_COMPRESSED (1) /* structure representing an ITS (CHM) file stream */ struct chmFile; /* structure representing an element from an ITS file stream */ #define CHM_MAX_PATHLEN (512) struct chmUnitInfo { LONGUINT64 start; LONGUINT64 length; int space; int flags; char path[CHM_MAX_PATHLEN+1]; }; /* open an ITS archive */ #ifdef PPC_BSTR /* RWE 6/12/2003 */ struct chmFile* chm_open(BSTR filename); #else struct chmFile* chm_open(const char *filename); #endif /* close an ITS archive */ void chm_close(struct chmFile *h); /* methods for ssetting tuning parameters for particular file */ #define CHM_PARAM_MAX_BLOCKS_CACHED 0 void chm_set_param(struct chmFile *h, int paramType, int paramVal); /* resolve a particular object from the archive */ #define CHM_RESOLVE_SUCCESS (0) #define CHM_RESOLVE_FAILURE (1) int chm_resolve_object(struct chmFile *h, const char *objPath, struct chmUnitInfo *ui); /* retrieve part of an object from the archive */ LONGINT64 chm_retrieve_object(struct chmFile *h, struct chmUnitInfo *ui, unsigned char *buf, LONGUINT64 addr, LONGINT64 len); /* enumerate the objects in the .chm archive */ typedef int (*CHM_ENUMERATOR)(struct chmFile *h, struct chmUnitInfo *ui, void *context); #define CHM_ENUMERATE_NORMAL (1) #define CHM_ENUMERATE_META (2) #define CHM_ENUMERATE_SPECIAL (4) #define CHM_ENUMERATE_FILES (8) #define CHM_ENUMERATE_DIRS (16) #define CHM_ENUMERATE_ALL (31) #define CHM_ENUMERATOR_FAILURE (0) #define CHM_ENUMERATOR_CONTINUE (1) #define CHM_ENUMERATOR_SUCCESS (2) int chm_enumerate(struct chmFile *h, int what, CHM_ENUMERATOR e, void *context); int chm_enumerate_dir(struct chmFile *h, const char *prefix, int what, CHM_ENUMERATOR e, void *context); #ifdef __cplusplus } #endif #endif /* INCLUDED_CHMLIB_H */</span></span></span></span></code> </pre> </div></div><br><p>  Commençons par le type de données, qui appelle chm_open () dans le constructeur et chm_close () dans le destructeur. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chm_open</span></span></span></span>(filename: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c_char) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chmFile; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chm_close</span></span></span></span>(h: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chmFile);</code> </pre> <br><p>  Pour simplifier la gestion des erreurs, nous utilisons la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>caisse thiserror</strong></a> , que <code>std::error::Error</code> implémente automatiquement. </p><br><pre> <code class="plaintext hljs">$ cd chmlib $ cargo add thiserror</code> </pre> <br><p>  Maintenant, vous devez comprendre comment transformer <code>std::path::Path</code> en <code>*const c_char</code> .  Malheureusement, ce n'est pas si facile à faire en raison de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">diverses</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blagues</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">avec compatibilité</a> . </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs use thiserror::Error; use std::{ffi::CString, path::Path}; #[cfg(unix)] fn path_to_cstring(path: &amp;Path) -&gt; Result&lt;CString, InvalidPath&gt; { use std::os::unix::ffi::OsStrExt; let bytes = path.as_os_str().as_bytes(); CString::new(bytes).map_err(|_| InvalidPath) } #[cfg(not(unix))] fn path_to_cstring(path: &amp;Path) -&gt; Result&lt;CString, InvalidPath&gt; { //  ,  Windows CHMLib  CreateFileA(),   //       ASCII.   ...   // ,          ? let rust_str = path.as_os_str().as_str().ok_or(InvalidPath)?; CString::new(rust_str).map_err(|_| InvalidPath) } #[derive(Error, Debug, Copy, Clone, PartialEq)] #[error("Invalid Path")] pub struct InvalidPath;</span></span></code> </pre> <br><p>  Définissez maintenant la structure du <strong>ChmFile</strong> .  Il stocke un pointeur non nul sur chmlib_sys :: chmFile.  Si chm_open () renvoie un pointeur nul, cela signifie qu'elle n'a pas pu ouvrir le fichier en raison d'une sorte d'erreur. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs use std::{ffi::CString, path::Path, ptr::NonNull}; #[derive(Debug)] pub struct ChmFile { raw: NonNull&lt;chmlib_sys::chmFile&gt;, } impl ChmFile { pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;ChmFile, OpenError&gt; { let c_path = path_to_cstring(path.as_ref())?; // ,   c_path  unsafe { let raw = chmlib_sys::chm_open(c_path.as_ptr()); match NonNull::new(raw) { Some(raw) =&gt; Ok(ChmFile { raw }), None =&gt; Err(OpenError::Other), } } } } impl Drop for ChmFile { fn drop(&amp;mut self) { unsafe { chmlib_sys::chm_close(self.raw.as_ptr()); } } } /// The error returned when we are unable to open a [`ChmFile`]. #[derive(Error, Debug, Copy, Clone, PartialEq)] pub enum OpenError { #[error("Invalid path")] InvalidPath(#[from] InvalidPath), #[error("Unable to open the ChmFile")] Other, }</span></span></code> </pre> <br><p>  Pour vous assurer qu'il n'y a pas de fuite de mémoire, exécutez un test simple sous <strong>Valgrind</strong> .  Il créera un ChmFile et le publiera immédiatement. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs #[test] fn open_valid_chm_file() { let sample = sample_path(); //   let chm_file = ChmFile::open(&amp;sample).unwrap(); //      drop(chm_file); } fn sample_path() -&gt; PathBuf { let project_dir = Path::new(env!("CARGO_MANIFEST_DIR")); let sample = project_dir.parent().unwrap().join("topics.classic.chm"); assert!(sample.exists()); sample }</span></span></code> </pre> <br><p>  Valgrind dit qu'il n'y a plus de mémoire non comptabilisée: </p><br><pre> <code class="plaintext hljs">$ valgrind ../target/debug/deps/chmlib-8d8c740d578324 open_valid_chm_file ==8953== Memcheck, a memory error detector ==8953== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==8953== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info ==8953== Command: ~/chmlib/target/debug/deps/chmlib-8d8c740d578324 open_valid_chm_file ==8953== running 1 test test tests::open_valid_chm_file ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out ==8953== ==8953== HEAP SUMMARY: ==8953== in use at exit: 0 bytes in 0 blocks ==8953== total heap usage: 249 allocs, 249 frees, 43,273 bytes allocated ==8953== ==8953== All heap blocks were freed -- no leaks are possible ==8953== ==8953== For counts of detected and suppressed errors, rerun with: -v ==8953== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</code> </pre> <br><h3 id="poisk-elementov-po-imeni">  Rechercher des éléments par nom </h3><br><p>  Ensuite, la fonction chm_resolve_object (): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CHM_RESOLVE_SUCCESS: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CHM_RESOLVE_FAILURE: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* resolve a particular object from the archive */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chm_resolve_object</span></span></span></span>( h: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chmFile, objPath: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c_char, ui: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chmUnitInfo ) -&gt; c_int;</code> </pre> <br><p>  La recherche peut échouer, donc chm_resolve_object () renvoie un code d'erreur signalant le succès ou l'échec, et les informations sur l'objet trouvé seront enregistrées par le pointeur transmis à <strong>chmUnitInfo</strong> . </p><br><p>  Le type <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>std::mem::MaybeUninit</code></a> créé juste pour notre cas avec le paramètre out <strong>ui</strong> . </p><br><p>  Pour l'instant, laissons la structure UnitInfo vide - c'est l'équivalent Rust de la structure chmUnitInfo C.  Nous ajouterons les champs lorsque nous commencerons à lire à partir de ChmFile. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs impl ChmFile { ... /// Find a particular object in the archive. pub fn find&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Option&lt;UnitInfo&gt; { let path = path_to_cstring(path.as_ref()).ok()?; unsafe { //   chmUnitInfo   let mut resolved = MaybeUninit::&lt;chmlib_sys::chmUnitInfo&gt;::uninit(); //  -  let ret = chmlib_sys::chm_resolve_object( self.raw.as_ptr(), path.as_ptr(), resolved.as_mut_ptr(), ); if ret == chmlib_sys::CHM_RESOLVE_SUCCESS { //    "resolved"   Some(UnitInfo::from_raw(resolved.assume_init())) } else { None } } } } #[derive(Debug)] pub struct UnitInfo; impl UnitInfo { fn from_raw(ui: chmlib_sys::chmUnitInfo) -&gt; UnitInfo { UnitInfo } }</span></span></code> </pre> <br><blockquote>  Notez que ChmFile :: find () accepte <strong><code>&amp;mut self</code></strong> , bien que le code sur le Rast ne contienne pas de changement d'état explicite.  Le fait est que l'implémentation C utilise toutes sortes de fseek () pour se déplacer dans le fichier, donc l'état interne change toujours pendant la recherche. </blockquote><p>  Vérifions ChmFile :: find () sur le fichier expérimental que nous avons précédemment téléchargé: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs #[test] fn find_an_item_in_the_sample() { let sample = sample_path(); let chm = ChmFile::open(&amp;sample).unwrap(); assert!(chm.find("/BrowserView.html").is_some()); assert!(chm.find("doesn't exist.txt").is_none()); }</span></span></code> </pre> <br><h3 id="obhod-elementov-po-filtru">  Filtrer les éléments de contournement </h3><br><p>  CHMLib fournit une API pour afficher le contenu d'un fichier CHM via un filtre de masque de bits. </p><br><p>  Prenez la caisse de bitflags pratique pour travailler avec des masques et des drapeaux: </p><br><pre> <code class="plaintext hljs">$ cargo add bitflags Updating 'https://github.com/rust-lang/crates.io-index' index Adding bitflags v1.2.1 to dependencies</code> </pre> <br><p>  Et définissez les cases à cocher <strong>Filtrer en</strong> fonction des constantes de chm_lib.h: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs bitflags::bitflags! { pub struct Filter: c_int { /// A normal file. const NORMAL = chmlib_sys::CHM_ENUMERATE_NORMAL as c_int; /// A meta file (typically used by the CHM system). const META = chmlib_sys::CHM_ENUMERATE_META as c_int; /// A special file (starts with `#` or `$`). const SPECIAL = chmlib_sys::CHM_ENUMERATE_SPECIAL as c_int; /// It's a file. const FILES = chmlib_sys::CHM_ENUMERATE_FILES as c_int; /// It's a directory. const DIRS = chmlib_sys::CHM_ENUMERATE_DIRS as c_int; } }</span></span></code> </pre> <br><p>  Nous avons également besoin d'un adaptateur <code>extern "C"</code> pour les fermetures Rastovyh, qui peut être passé à C sous la forme d'un pointeur vers une fonction: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs unsafe extern "C" fn function_wrapper&lt;F&gt;( file: *mut chmlib_sys::chmFile, unit: *mut chmlib_sys::chmUnitInfo, state: *mut c_void, ) -&gt; c_int where F: FnMut(&amp;mut ChmFile, UnitInfo) -&gt; Continuation, { //      FFI- let result = panic::catch_unwind(|| { //   ManuallyDrop    `&amp;mut ChmFile` //        ( double-free). let mut file = ManuallyDrop::new(ChmFile { raw: NonNull::new_unchecked(file), }); let unit = UnitInfo::from_raw(unit.read()); //  state      let closure = &amp;mut *(state as *mut F); closure(&amp;mut file, unit) }); match result { Ok(Continuation::Continue) =&gt; { chmlib_sys::CHM_ENUMERATOR_CONTINUE as c_int }, Ok(Continuation::Stop) =&gt; chmlib_sys::CHM_ENUMERATOR_SUCCESS as c_int, Err(_) =&gt; chmlib_sys::CHM_ENUMERATOR_FAILURE as c_int, } }</span></span></code> </pre> <br><blockquote>  <code>function_wrapper</code> contient un code dangereux et délicat à utiliser: <br><br><ul><li>  Le pointeur d' <code>state</code> <strong>doit</strong> pointer vers l'instance de fermeture F. </li><li>  Le code Rasta exécuté par une fermeture peut provoquer la panique.  Il ne doit pas traverser la frontière entre Rast et C, car la promotion de la pile dans différentes langues est un comportement non défini.  Une éventuelle panique doit être interceptée à l'aide de <code>std::panic::catch_unwind()</code> . </li><li>  Un pointeur vers chmlib_sys :: chmFile passé à function_wrapper est également stocké dans le ChmFile appelant.  Pendant la durée de l'appel, vous devez vous assurer que seule la fermeture peut manipuler chmlib_sys :: chmFile, sinon une condition de concurrence critique peut se produire. </li><li>  La fermeture doit être passée <code>&amp;mut ChmFile</code> , et pour cela, vous devrez créer un objet temporaire sur la pile en utilisant le pointeur existant.  Cependant, si le destructeur ChmFile s'exécute dans ce cas, alors chmlib_sys :: chmFile sera libéré trop tôt.  Pour résoudre ce problème, il existe <code>std::mem::ManuallyDrop</code> . </li></ul><br></blockquote><p>  Voici comment function_wrapper est utilisé pour implémenter <code>ChmFile::for_each()</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs impl ChmFile { ... /// Inspect each item within the [`ChmFile`]. pub fn for_each&lt;F&gt;(&amp;mut self, filter: Filter, mut cb: F) where F: FnMut(&amp;mut ChmFile, UnitInfo) -&gt; Continuation, { unsafe { chmlib_sys::chm_enumerate( self.raw.as_ptr(), filter.bits(), Some(function_wrapper::&lt;F&gt;), &amp;mut cb as *mut _ as *mut c_void, ); } } /// Inspect each item within the [`ChmFile`] inside a specified directory. pub fn for_each_item_in_dir&lt;F, P&gt;( &amp;mut self, filter: Filter, prefix: P, mut cb: F, ) where P: AsRef&lt;Path&gt;, F: FnMut(&amp;mut ChmFile, UnitInfo) -&gt; Continuation, { let path = match path_to_cstring(prefix.as_ref()) { Ok(p) =&gt; p, Err(_) =&gt; return, }; unsafe { chmlib_sys::chm_enumerate_dir( self.raw.as_ptr(), path.as_ptr(), filter.bits(), Some(function_wrapper::&lt;F&gt;), &amp;mut cb as *mut _ as *mut c_void, ); } } }</span></span></code> </pre> <br><blockquote>  Remarquez comment le paramètre F interagit avec la fonction générique function_wrapper.  Cette technique est souvent utilisée lorsque vous devez passer la fermeture Rust via FFI pour coder dans une autre langue. </blockquote><br><h3 id="chtenie-soderzhimogo-faylov">  Lecture du contenu du fichier </h3><br><p>  La dernière fonction dont nous avons besoin est responsable de la lecture du fichier à l'aide de chm_retrieve_object (). </p><br><p>  Son implémentation est assez banale.  Ceci est similaire à un trait std :: io :: Read typique, à l'exception d'un décalage de fichier explicite. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs impl ChmFile { ... pub fn read( &amp;mut self, unit: &amp;UnitInfo, offset: u64, buffer: &amp;mut [u8], ) -&gt; Result&lt;usize, ReadError&gt; { let mut unit = unit.0.clone(); let bytes_written = unsafe { chmlib_sys::chm_retrieve_object( self.raw.as_ptr(), &amp;mut unit, buffer.as_mut_ptr(), offset, buffer.len() as _, ) }; if bytes_written &gt;= 0 { Ok(bytes_written as usize) } else { Err(ReadError) } } } #[derive(Error, Debug, Copy, Clone, PartialEq)] #[error("The read failed")] pub struct ReadError;</span></span></code> </pre> <br><p>  Bien sûr, il serait bien d'avoir un message d'erreur plus détaillé que «échec de lecture», mais à en juger par le code source, chm_retrieve_object () ne fait pas de distinction particulière entre les erreurs: </p><br><ul><li>  renvoie 0 lorsque le fichier est lu jusqu'à la fin; </li><li>  renvoie 0 pour les arguments invalides: pointeurs nuls ou dépassement des limites; </li><li>  renvoie -1 si le système ne lit pas correctement les fichiers (et remplit errno); </li><li>  renvoie -1 pour les erreurs de décompression, sans distinguer la corruption des données et, par exemple, l'impossibilité d'allouer de la mémoire pour un tampon temporaire via malloc (). </li></ul><br><p>  Vous pouvez tester ChmFile :: read () en utilisant des fichiers au contenu connu: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs #[test] fn read_an_item() { let sample = sample_path(); let mut chm = ChmFile::open(&amp;sample).unwrap(); let filename = "/template/packages/core-web/css/index.responsive.css"; //        let item = chm.find(filename).unwrap(); //      let mut buffer = vec![0; item.length() as usize]; let bytes_written = chm.read(&amp;item, 0, &amp;mut buffer).unwrap(); //      assert_eq!(bytes_written, item.length() as usize); // ...  ,    let got = String::from_utf8(buffer).unwrap(); assert!(got.starts_with( "html, body, div#i-index-container, div#i-index-body" )); }</span></span></code> </pre> <br><h2 id="dobavlyaem-primery">  Ajouter des exemples </h2><br><p>  Nous avons couvert la plupart des API de la bibliothèque CHMLib et beaucoup en auraient fini avec cela, considérant que le portage s'est terminé avec succès.  Cependant, ce serait bien de rendre notre rack encore plus convivial.        —  ,    Rust  Go       ( ,  <em>rustdoc</em>  <em>godoc</em>     ). </p><br><p>  ,  CHMLib    ,        . </p><br><p>       , ,         . </p><br><h3 id="oglavlenie-chm-fayla">  CHM- </h3><br><p>    CHM-         . </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* $Id: enum_chmLib.c,v 1.7 2002/10/09 12:38:12 jedwin Exp $ */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*************************************************************************** * enum_chmLib.c - CHM archive test driver * * ------------------- * * * * author: Jed Wing &lt;jedwin@ugcs.caltech.edu&gt; * * notes: This is a quick-and-dirty test driver for the chm lib * * routines. The program takes as its input the paths to one * * or more .chm files. It attempts to open each .chm file in * * turn, and display a listing of all of the files in the * * archive. * * * * It is not included as a particularly useful program, but * * rather as a sort of "simplest possible" example of how to * * use the enumerate portion of the API. * ***************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*************************************************************************** * * * This program is free software; you can redistribute it and/or modify * * it under the terms of the GNU Lesser General Public License as * * published by the Free Software Foundation; either version 2.1 of the * * License, or (at your option) any later version. * * * ***************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"chm_lib.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; /* * callback function for enumerate API */ int _print_ui(struct chmFile *h, struct chmUnitInfo *ui, void *context) { static char szBuf[128]; memset(szBuf, 0, 128); if(ui-&gt;flags &amp; CHM_ENUMERATE_NORMAL) strcpy(szBuf, "normal "); else if(ui-&gt;flags &amp; CHM_ENUMERATE_SPECIAL) strcpy(szBuf, "special "); else if(ui-&gt;flags &amp; CHM_ENUMERATE_META) strcpy(szBuf, "meta "); if(ui-&gt;flags &amp; CHM_ENUMERATE_DIRS) strcat(szBuf, "dir"); else if(ui-&gt;flags &amp; CHM_ENUMERATE_FILES) strcat(szBuf, "file"); printf(" %1d %8d %8d %s\t\t%s\n", (int)ui-&gt;space, (int)ui-&gt;start, (int)ui-&gt;length, szBuf, ui-&gt;path); return CHM_ENUMERATOR_CONTINUE; } int main(int c, char **v) { struct chmFile *h; int i; for (i=1; i&lt;c; i++) { h = chm_open(v[i]); if (h == NULL) { fprintf(stderr, "failed to open %s\n", v[i]); exit(1); } printf("%s:\n", v[i]); printf(" spc start length type\t\t\tname\n"); printf(" === ===== ====== ====\t\t\t====\n"); if (! chm_enumerate(h, CHM_ENUMERATE_ALL, _print_ui, NULL)) printf(" *** ERROR ***\n"); chm_close(h); } return 0; }</span></span></span></span></code> </pre> </div></div><br><p>  _print_ui()    Rust.         UnitInfo  ,      ,     . </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/examples/enumerate-items.rs fn describe_item(item: UnitInfo) { let mut description = String::new(); if item.is_normal() { description.push_str("normal "); } else if item.is_special() { description.push_str("special "); } else if item.is_meta() { description.push_str("meta "); } if item.is_dir() { description.push_str("dir"); } else if item.is_file() { description.push_str("file"); } println!( " {} {:8} {:8} {}\t\t{}", item.space(), item.start(), item.length(), description, item.path().unwrap_or(Path::new("")).display() ); }</span></span></code> </pre> <br><p>  main()       ,  ,   describe_item()  ChmFile::for_each(). </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/examples/enumerate-items.rs fn main() { let filename = env::args() .nth(1) .unwrap_or_else(|| panic!("Usage: enumerate-items &lt;filename&gt;")); let mut file = ChmFile::open(&amp;filename).expect("Unable to open the file"); println!("{}:", filename); println!(" spc start length type\t\t\tname"); println!(" === ===== ====== ====\t\t\t===="); file.for_each(Filter::all(), |_file, item| { describe_item(item); Continuation::Continue }); }</span></span></code> </pre> <br><p>          : </p><br><pre> <code class="plaintext hljs">$ cargo run --example enumerate-items topics.classic.chm &gt; rust-example.txt $ cd vendor/CHMLib/src $ clang chm_lib.c enum_chmLib.c lzx.c -o enum_chmLib $ cd ../../.. $ ./vendor/CHMLib/src/enum_chmLib topics.classic.chm &gt; c-example.txt $ diff -u rust-example.txt c-example.txt $ echo $? 0</code> </pre> <br><p> diff ,   ,   ,     ,    .    -   ,     diff. </p><br><pre> <code class="diff hljs">diff --git a/chmlib/examples/enumerate-items.rs b/chmlib/examples/enumerate-items.rs index e68fa58..ef855ac 100644 --- a/chmlib/examples/enumerate-items.rs +++ b/chmlib/examples/enumerate-items.rs @@ -36,6 +36,10 @@ fn describe_item(item: UnitInfo) { description.push_str("file"); } + if item.length() % 7 == 0 { + description.push_str(" :)"); + } + println!( " {} {:8} {:8} {}\t\t{}", item.space(),</code> </pre> <br><p>     : </p><br><pre> <code class="diff hljs">$ cargo run --example enumerate-items topics.classic.chm &gt; rust-example.txt $ diff -u rust-example.txt c-example.txt --- rust-example.txt 2019-10-20 16:51:53.933560892 +0800 +++ c-example.txt 2019-10-20 16:40:42.007053966 +0800 @@ -1,9 +1,9 @@ topics.classic.chm: spc start length type name <span class="hljs-comment"><span class="hljs-comment">=== ===== ====== ==== ==== - 0 0 0 normal dir :) / + 0 0 0 normal dir / 1 5125797 4096 special file /#IDXHDR - 0 0 0 special file :) /#ITBITS + 0 0 0 special file /#ITBITS 1 5104520 148 special file /#IVB 1 5132009 1227 special file /#STRINGS 0 1430 4283 special file /#SYSTEM @@ -13,9 +13,9 @@ ...</span></span></code> </pre> <br><p> ! </p><br><h3 id="raspakovka-chm-fayla-na-disk">  CHM-   </h3><br><p>  ,     CHMLib,   «»   . </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* $Id: extract_chmLib.c,v 1.4 2002/10/10 03:24:51 jedwin Exp $ */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*************************************************************************** * extract_chmLib.c - CHM archive extractor * * ------------------- * * * * author: Jed Wing &lt;jedwin@ugcs.caltech.edu&gt; * * notes: This is a quick-and-dirty chm archive extractor. * ***************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*************************************************************************** * * * This program is free software; you can redistribute it and/or modify * * it under the terms of the GNU Lesser General Public License as * * published by the Free Software Foundation; either version 2.1 of the * * License, or (at your option) any later version. * * * ***************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"chm_lib.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #ifdef WIN32 #include &lt;windows.h&gt; #include &lt;direct.h&gt; #define mkdir(X, Y) _mkdir(X) #define snprintf _snprintf #else #include &lt;unistd.h&gt; #include &lt;sys/stat.h&gt; #include &lt;sys/types.h&gt; #endif struct extract_context { const char *base_path; }; static int dir_exists(const char *path) { #ifdef WIN32 /* why doesn't this work?!? */ HANDLE hFile; hFile = CreateFileA(path, FILE_LIST_DIRECTORY, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile != INVALID_HANDLE_VALUE) { CloseHandle(hFile); return 1; } else return 0; #else struct stat statbuf; if (stat(path, &amp;statbuf) != -1) return 1; else return 0; #endif } static int rmkdir(char *path) { /* * strip off trailing components unless we can stat the directory, or we * have run out of components */ char *i = strrchr(path, '/'); if(path[0] == '\0' || dir_exists(path)) return 0; if (i != NULL) { *i = '\0'; rmkdir(path); *i = '/'; mkdir(path, 0777); } #ifdef WIN32 return 0; #else if (dir_exists(path)) return 0; else return -1; #endif } /* * callback function for enumerate API */ int _extract_callback(struct chmFile *h, struct chmUnitInfo *ui, void *context) { LONGUINT64 ui_path_len; char buffer[32768]; struct extract_context *ctx = (struct extract_context *)context; char *i; if (ui-&gt;path[0] != '/') return CHM_ENUMERATOR_CONTINUE; /* quick hack for security hole mentioned by Sven Tantau */ if (strstr(ui-&gt;path, "/../") != NULL) { /* fprintf(stderr, "Not extracting %s (dangerous path)\n", ui-&gt;path); */ return CHM_ENUMERATOR_CONTINUE; } if (snprintf(buffer, sizeof(buffer), "%s%s", ctx-&gt;base_path, ui-&gt;path) &gt; 1024) return CHM_ENUMERATOR_FAILURE; /* Get the length of the path */ ui_path_len = strlen(ui-&gt;path)-1; /* Distinguish between files and dirs */ if (ui-&gt;path[ui_path_len] != '/' ) { FILE *fout; LONGINT64 len, remain=ui-&gt;length; LONGUINT64 offset = 0; printf("--&gt; %s\n", ui-&gt;path); if ((fout = fopen(buffer, "wb")) == NULL) { /* make sure that it isn't just a missing directory before we abort */ char newbuf[32768]; strcpy(newbuf, buffer); i = strrchr(newbuf, '/'); *i = '\0'; rmkdir(newbuf); if ((fout = fopen(buffer, "wb")) == NULL) return CHM_ENUMERATOR_FAILURE; } while (remain != 0) { len = chm_retrieve_object(h, ui, (unsigned char *)buffer, offset, 32768); if (len &gt; 0) { fwrite(buffer, 1, (size_t)len, fout); offset += len; remain -= len; } else { fprintf(stderr, "incomplete file: %s\n", ui-&gt;path); break; } } fclose(fout); } else { if (rmkdir(buffer) == -1) return CHM_ENUMERATOR_FAILURE; } return CHM_ENUMERATOR_CONTINUE; } int main(int c, char **v) { struct chmFile *h; struct extract_context ec; if (c &lt; 3) { fprintf(stderr, "usage: %s &lt;chmfile&gt; &lt;outdir&gt;\n", v[0]); exit(1); } h = chm_open(v[1]); if (h == NULL) { fprintf(stderr, "failed to open %s\n", v[1]); exit(1); } printf("%s:\n", v[1]); ec.base_path = v[2]; if (! chm_enumerate(h, CHM_ENUMERATE_ALL, _extract_callback, (void *)&amp;ec)) printf(" *** ERROR ***\n"); chm_close(h); return 0; }</span></span></span></span></code> </pre> </div></div><br><p>               . ,     . </p><br><p>     extract().    ,              . </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/examples/extract.rs fn extract( root_dir: &amp;Path, file: &amp;mut ChmFile, item: &amp;UnitInfo, ) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { if !item.is_file() || !item.is_normal() { //      return Ok(()); } let path = match item.path() { Some(p) =&gt; p, //     ,   None =&gt; return Ok(()), }; let mut dest = root_dir.to_path_buf(); // :  CHM       (  "/"), //     root_dir     "/". dest.extend(path.components().skip(1)); //     if let Some(parent) = dest.parent() { fs::create_dir_all(parent)?; } let mut f = File::create(dest)?; let mut start_offset = 0; // CHMLib      &amp;[u8]    (, //      ),       //      let mut buffer = vec![0; 1 &lt;&lt; 16]; loop { let bytes_read = file.read(item, start_offset, &amp;mut buffer)?; if bytes_read == 0 { //     break; } else { //      start_offset += bytes_read as u64; f.write_all(&amp;buffer)?; } } Ok(()) }</span></span></code> </pre> <br><p>  main()  ,  extract(),         . </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/examples/extract.rs fn main() { let args: Vec&lt;_&gt; = env::args().skip(1).collect(); if args.len() != 2 || args.iter().any(|arg| arg.contains("-h")) { println!("Usage: extract &lt;chm-file&gt; &lt;out-dir&gt;"); return; } let mut file = ChmFile::open(&amp;args[0]).expect("Unable to open the file"); let out_dir = PathBuf::from(&amp;args[1]); file.for_each(Filter::all(), |file, item| { match extract(&amp;out_dir, file, &amp;item) { Ok(_) =&gt; Continuation::Continue, Err(e) =&gt; { eprintln!("Error: {}", e); Continuation::Stop }, } }); }</span></span></code> </pre> <br><p>      CHM-    HTML-,      -. </p><br><pre> <code class="plaintext hljs">$ cargo run --example extract -- ./topics.classic.chm ./extracted $ tree ./extracted ./extracted ├── default.html ├── BrowserForward.html ... ├── Images │ ├── Commands │ │ └── RealWorld │ │ ├── BrowserBack.bmp ... ├── script │ ├── _community │ │ └── disqus.js │ ├── hs-common.js ... └── userinterface.html $ firefox topics.classic/default.html ( default.html  Firefox)</code> </pre> <br><p>  JavaScript   ( -    Microsoft Help),   ,     . </p><br><h2 id="chto-dalshe">  Et ensuite? </h2><br><p>  chmlib    ,    ,     crates.io. </p><br><p>        : </p><br><ul><li>    ChmFile::for_each()  ChmFile::for_each_item_in_dir() ,          ,     . </li><li>   ,          ChmFile       <code>Continuation::Continue</code>   . ,     <code>F: FnMut(&amp;mut ChmFile, UnitInfo) -&gt; C</code>  <code>C: Into&lt;Continuation&gt;</code> ,    <code>impl From&lt;()&gt; for Continuation</code> . </li><li>      (,     extract())      ChmFile::for_each()   .         <code>impl&lt;E&gt; From&lt;Result&lt;(), E&gt;&gt; for Continuation where E: Error + 'static</code> . </li><li> -               <code>std::fs::File</code> .      ,     ChmFile::read()     - <code>std::io::Writer</code> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474666/">https://habr.com/ru/post/fr474666/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474654/index.html">Poignée de main SSH en termes simples.</a></li>
<li><a href="../fr474656/index.html">Reversim MIPS et Golang - les bases de l'inverse. Résolution des problèmes de marche arrière avec r0ot-mi. 2e partie</a></li>
<li><a href="../fr474658/index.html">Douleur au poignet et souris d'ordinateur</a></li>
<li><a href="../fr474662/index.html">Test bêta: Devdiction for Developers - une plateforme pour apprendre l'anglais</a></li>
<li><a href="../fr474664/index.html">Pour augmenter l'attention, notre cerveau n'augmente pas la concentration, mais utilise des filtres d'information</a></li>
<li><a href="../fr474668/index.html">Actions GitHub en tant que CI / CD pour un site sur un générateur statique et des pages GitHub</a></li>
<li><a href="../fr474672/index.html">React, JSX, importation de modules ES (y compris dynamiques) dans un navigateur sans Webpack</a></li>
<li><a href="../fr474674/index.html">Vision industrielle et médecine</a></li>
<li><a href="../fr474676/index.html">L'algorithme d'interaction de centaines de milliers de particules uniques sur le GPU, dans GLES3 et WebGL2</a></li>
<li><a href="../fr474678/index.html">Khronos Group a créé un référentiel unifié avec des exemples Vulkan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>