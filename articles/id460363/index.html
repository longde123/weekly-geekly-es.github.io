<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎀 📑 🛰️ 7 faktor yang hilang dalam pendekatan 12 Factor App 🐂 🍓 ♈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan perev. : Kegembiraan yang dialami para pemimpin tim kami ketika mereka melihat materi ini di blog IBM Cloud - semacam "perpanjangan" dari Apli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>7 faktor yang hilang dalam pendekatan 12 Factor App</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/460363/"><img src="https://habrastorage.org/webt/2a/cg/zi/2acgziblbzalmpe4jsfclgm5bqm.png"><br><br>  <i><b>Catatan</b></i>  <i><b>perev.</b></i>  <i>: Kegembiraan yang dialami para pemimpin tim kami ketika mereka melihat materi ini di blog IBM Cloud - semacam "perpanjangan" dari Aplikasi Dua Belas-Faktor yang legendaris, - berbicara untuk dirinya sendiri.</i>  <i>Pertanyaan-pertanyaan yang diajukan oleh penulis tidak hanya dari telinga, tetapi benar-benar vital, yaitu</i>  <i>relevan dalam kehidupan sehari-hari.</i>  <i>Pemahaman mereka berguna tidak hanya untuk insinyur DevOps, tetapi juga untuk pengembang yang membuat aplikasi modern yang berjalan di Kubernetes.</i> <br><br>  Metodologi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi 12 faktor yang</a> terkenal adalah seperangkat aturan yang didefinisikan dengan jelas untuk mengembangkan layanan-layanan mikro.  Mereka banyak digunakan untuk menjalankan, skala, dan menyebarkan aplikasi.  Di platform IBM Cloud Private, kami mengikuti 12 prinsip yang sama ketika mengembangkan aplikasi yang dipaketkan.  Artikel “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes &amp; aplikasi 12 faktor</a> ” membahas secara spesifik penggunaan 12 faktor ini (semuanya didukung oleh model orkestrasi wadah Kubernetes). <br><br>  Berpikir tentang prinsip-prinsip pengembangan layanan wadah kemas yang bekerja di bawah kendali Kubernetes, kami sampai pada kesimpulan berikut: 12 faktor di atas sepenuhnya benar, tetapi yang lain juga sangat penting untuk mengatur lingkungan produksi: <a name="habracut"></a><br><br><ul><li>  <i>diamati</i> </li><li>  <b>prediktabilitas</b> <i>(</i> <b>dapat</b> <i>dijadwalkan)</i> ; </li><li>  <b>dapat diperbarui</b> <i>(dapat</i> <b>diperbarui</b> <i>)</i> ; </li><li>  <b>hak minimum</b> </li><li>  <b>pengendalian</b> <i>(dapat diaudit)</i> ; </li><li>  <b>keamanan</b> <i>(diamankan)</i> ; </li><li>  <b>terukur</b> </li></ul><br>  Mari kita memikirkan prinsip-prinsip ini dan mencoba mengevaluasi signifikansinya.  Untuk menjaga keseragaman, kami menambahkannya ke yang sudah ada - karenanya, kami akan mulai dengan XIII ... <br><br><h2>  Prinsip XIII: Observabilitas </h2><br>  <b>Aplikasi harus memberikan informasi tentang status dan indikator mereka saat ini.</b> <br><br>  Sistem terdistribusi dapat menjadi sulit untuk dikelola karena banyak layanan mikro terintegrasi ke dalam suatu aplikasi.  Bahkan, berbagai roda gigi harus bergerak bersamaan agar mekanisme (aplikasi) bekerja.  Jika kegagalan terjadi di salah satu layanan microser, sistem akan secara otomatis mendeteksi dan memperbaikinya.  Kubernetes menyediakan mekanisme penyelamatan yang sangat baik, seperti <i>tes</i> kesiapan dan <i>keaktifan</i> . <br><br>  Dengan bantuan mereka, Kubernetes memastikan bahwa aplikasi tersebut siap menerima lalu lintas.  Jika kesiapan gagal, Kubernetes berhenti mengirimkan lalu lintas ke pod sampai pengujian berikutnya menunjukkan bahwa pod siap. <br><br>  Misalkan kita memiliki aplikasi yang terdiri dari 3 layanan mikro: frontend, logika bisnis, dan database.  Agar aplikasi berfungsi, sebelum menerima lalu lintas, frontend harus memastikan bahwa logika bisnis dan basis data siap.  Ini dapat dilakukan dengan menggunakan tes kesiapan - ini memungkinkan Anda untuk memastikan bahwa semua dependensi berfungsi. <br><br>  Animasi menunjukkan bahwa permintaan ke pod tidak dikirim sampai tes kesiapan menunjukkan kesiapannya: <br><br><img src="https://habrastorage.org/webt/lo/uu/zz/louuzz5pv2lt-wuj82-cqa1j0ne.gif"><br>  <i>Uji Kesiapan Beraksi: Kubernetes menggunakan probe kesiapan untuk memeriksa apakah pod siap menerima lalu lintas</i> <br><br>  Ada tiga jenis tes: menggunakan HTTP, permintaan TCP, dan perintah.  Anda dapat mengontrol konfigurasi tes, misalnya, menunjukkan frekuensi mulai, ambang batas keberhasilan / kegagalan dan berapa lama menunggu jawaban.  Dalam hal tes liveness, Anda perlu menetapkan satu parameter yang sangat penting - <b><code>initialDelaySeconds</code></b> .  Pastikan tes dimulai hanya setelah aplikasi siap.  Jika parameter ini diatur secara tidak benar, aplikasi akan terus-menerus restart.  Inilah cara penerapannya: <br><br><pre> <code class="plaintext hljs">livenessProbe: # an http probe httpGet: path: /readiness port: 8080 initialDelaySeconds: 20 periodSeconds: 5</code> </pre> <br>  Melalui tes keaktifan, Kubernetes memeriksa untuk melihat apakah aplikasi Anda berjalan.  Jika aplikasi berfungsi normal, maka Kubernetes tidak melakukan apa pun.  Jika "mati", Kubernetes menghapus pod dan memulai yang baru sebagai balasannya.  Ini sesuai dengan kebutuhan layanan mikro tanpa kewarganegaraan dan daur ulangnya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">faktor IX, Disposabilitas</a> ).  Animasi di bawah ini mengilustrasikan situasi di mana Kubernetes me-restart pod setelah gagal tes keaktifan: <br><br><img src="https://habrastorage.org/webt/ie/cl/j6/ieclj6m2qrr6kgegoy5yup-dvtg.gif"><br>  <i>Uji keaktifan dalam aksi: Kubernet memeriksa apakah polong "hidup" dengannya</i> <br><br>  Keuntungan besar dari tes ini adalah bahwa Anda dapat menggunakan aplikasi dalam urutan apa pun tanpa khawatir tentang ketergantungan. <br><br>  Namun, kami menemukan bahwa tes ini tidak cukup untuk lingkungan produksi.  Biasanya, aplikasi memiliki metrik sendiri yang perlu dilacak, misalnya, jumlah transaksi per detik.  Klien menetapkan ambang batas untuknya dan mengonfigurasi pemberitahuan.  IBM Cloud Private mengisi celah ini dengan tumpukan pemantauan Prometheus dan Grafana yang sangat aman dengan sistem kontrol akses berbasis peran.  Lihat bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemantauan IBM Cloud Private cluster</a> untuk informasi lebih lanjut. <br><br>  Prometheus mengumpulkan data target dari metrik titik akhir.  Aplikasi Anda harus menentukan metrik titik akhir menggunakan anotasi berikut: <br><br><pre> <code class="plaintext hljs">prometheus.io/scrape: 'true'</code> </pre> <br>  Setelah itu, Prometheus secara otomatis mendeteksi titik akhir dan mengumpulkan metrik darinya (seperti yang ditunjukkan dalam animasi berikut): <br><br><img src="https://habrastorage.org/webt/k-/at/5l/k-at5lvq2tpxupqg5w_73cv3xv0.gif"><br>  <i>Koleksi metrik khusus</i> <br><br>  <i><b>Catatan</b></i>  <i><b>perev.</b></i>  <i>: Akan lebih benar untuk mengarahkan panah ke arah yang berlawanan, karena Prometheus berjalan dan menentukan titik akhir, dan Grafana sendiri mengambil data dari Prometheus, tetapi dalam arti ilustrasi umum ini tidak terlalu kritis.</i> <br><br><h2>  Prinsip XIV: Dapat diprediksi </h2><br>  <b>Aplikasi harus menyediakan prediksi kebutuhan sumber daya.</b> <br><br>  Bayangkan bahwa seorang pemandu telah memilih tim Anda untuk bereksperimen dengan proyek Kubernetes.  Anda bekerja keras untuk menciptakan lingkungan yang sesuai.  Hasilnya adalah aplikasi yang menunjukkan waktu respons dan kinerja yang patut dicontoh.  Kemudian tim lain bergabung dengan pekerjaan itu.  Dia menciptakan aplikasi dan meluncurkannya di lingkungan yang sama.  Setelah meluncurkan aplikasi kedua, kinerja yang pertama tiba-tiba menurun.  Dalam hal ini, alasan perilaku ini harus dicari dalam sumber daya komputasi (CPU dan memori) yang tersedia untuk wadah Anda.  Probabilitas tinggi dari kekurangan mereka.  Timbul pertanyaan: bagaimana menjamin alokasi sumber daya komputasi yang dibutuhkan oleh aplikasi? <br><br>  Kubernetes memiliki opsi luar biasa yang memungkinkan Anda untuk mengatur sumber daya minimum dan menetapkan batasan untuk wadah.  Minimum dijamin.  Jika sebuah wadah membutuhkan sumber daya, Kubernetes menjalankannya hanya pada host yang dapat disediakan oleh sumber daya ini.  Di sisi lain, batas atas memastikan bahwa selera wadah tidak pernah melebihi nilai tertentu. <br><br><img src="https://habrastorage.org/webt/qr/pk/qg/qrpkqgcmtzsog7xnqcrjasq8xbm.png"><br>  <i>Minimum dan batasan untuk wadah</i> <br><br>  Cuplikan kode YAML berikut menunjukkan penyetelan sumber daya komputasi: <br><br><pre> <code class="plaintext hljs">resources: requests: memory: "64Mi" cpu: "150m" limits: memory: "64Mi" cpu: "200m"</code> </pre> <br>  <i><b>Catatan</b></i>  <i><b>perev.</b></i>  <i>: Untuk informasi lebih lanjut tentang penyediaan sumber daya di Kubernetes, permintaan dan batasan, lihat laporan terbaru kami dan ulasannya, “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Autoscaling dan Manajemen Sumberdaya di Kubernetes,</a> ” serta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi K8</a> .</i> <br><br>  Peluang menarik lainnya untuk administrator di lingkungan produksi adalah menetapkan kuota untuk <i>namespace</i> .  Jika kuota disetel, Kubernetes tidak akan membuat kontainer yang permintaan / batasannya tidak ditentukan di namespace ini.  Contoh pengaturan kuota untuk namespace dapat dilihat pada gambar di bawah ini: <br><br><img src="https://habrastorage.org/webt/dw/rx/rt/dwrxrtirmxdelzgilu3lurdj3n0.png"><br>  <i>Kuota untuk ruang nama</i> <br><br><h2>  Prinsip XV.  Pembaruan </h2><br>  <b>Aplikasi harus memperbarui format data dari generasi sebelumnya.</b> <br><br>  Seringkali ada kebutuhan untuk menambal aplikasi produksi yang berfungsi untuk menghilangkan kerentanan atau memperluas fungsionalitas.  Penting bahwa pembaruan berlangsung tanpa gangguan dalam pekerjaan.  Kubernetes menyediakan <i>mekanisme</i> pembaruan bergulir yang memungkinkan Anda untuk memperbarui aplikasi Anda tanpa downtime.  Dengan menggunakan mekanisme ini, Anda dapat memperbarui melalui pod pada satu waktu tanpa menghentikan seluruh layanan.  Berikut ini adalah representasi skematis dari proses ini (di atasnya aplikasi diperbarui ke versi kedua): <br><br><img src="https://habrastorage.org/webt/vm/ww/7a/vmww7ae4pwsdd5xoafuapdxwjgq.gif"><br><br>  Contoh deskripsi YAML yang sesuai: <br><br><pre> <code class="plaintext hljs">minReadySeconds: 5 strategy: # ,      type: RollingUpdate rollingUpdate: maxSurge: 1 maxUnavailable: 1</code> </pre> <br>  Perhatikan <code>maxSurge</code> dan <code>maxSurge</code> : <br><br><ul><li>  <code>maxUnavailable</code> - parameter opsional yang menetapkan jumlah maksimum pod yang mungkin tidak tersedia selama proses pembaruan.  Meskipun bersifat opsional, tetap bernilai menetapkan nilai tertentu untuk menjamin ketersediaan layanan; </li><li>  <code>maxSurge</code> adalah parameter opsional tetapi penting lainnya.  Ini menetapkan jumlah maksimum pod yang dapat dibuat melebihi jumlah yang diinginkan. </li></ul><br><h2>  Prinsip XVI: Hak Istimewa Minimum </h2><br>  <b>Kontainer harus bekerja dengan minimum hak istimewa.</b> <br><br>  Kedengarannya pesimistis, tetapi Anda harus menganggap setiap resolusi dalam wadah sebagai kerentanan potensial (lihat ilustrasi).  Misalnya, jika wadah berjalan sebagai root, maka siapa pun yang memiliki akses ke sana dapat menyuntikkan proses berbahaya di sana.  Kubernetes menyediakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kebijakan Keamanan Pod</a> (PSP) untuk membatasi akses ke sistem file, port host, kemampuan Linux, dan banyak lagi.  IBM Cloud Private menawarkan satu set PSP yang siap pakai yang terikat pada wadah ketika mereka disediakan di namespace.  Untuk informasi lebih lanjut, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan ruang nama dengan Kebijakan Keamanan Pod</a> . <br><br><img src="https://habrastorage.org/webt/g1/rs/e5/g1rse5fyeoqhmh8i6rxz7n6kado.png"><br>  <i>Semua resolusi adalah vektor serangan potensial</i> <br><br><h2>  Prinsip XVII: Pengendalian </h2><br>  <b>Anda perlu tahu siapa, apa, di mana, dan kapan untuk semua operasi kritis misi.</b> <br><br>  Kontrol sangat penting untuk operasi apa pun dengan kluster atau aplikasi Kubernetes.  Misalnya, jika aplikasi memproses transaksi kartu kredit, Anda harus mengaktifkan audit agar memiliki kontrol jejak setiap transaksi.  IBM Cloud Private menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cloud Auditing Data Federation</a> (CADF) standar industri, yang tidak sesuai dengan implementasi cloud tertentu.  Untuk informasi lebih lanjut, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pencatatan audit di IBM Cloud Private</a> . <br><br>  Acara CADF berisi data berikut: <br><br><ul><li>  <code>initiator_id</code> - ID pengguna yang melakukan operasi; </li><li>  <code>target_uri</code> - target CADF URI (misalnya: data / keamanan / proyek); </li><li>  <code>action</code> - <code>action</code> akan dilakukan, biasanya <code>operation: resource_type</code> . </li></ul><br><h2>  Prinsip XVIII: Keamanan (identifikasi, jaringan, ruang lingkup, sertifikat) </h2><br>  <b>Diperlukan untuk melindungi aplikasi dan sumber daya dari orang asing.</b> <br><br>  Item ini layak mendapat artikel terpisah.  Cukuplah untuk mengatakan bahwa aplikasi produksi memerlukan perlindungan ujung ke ujung.  IBM Cloud Private mengambil langkah-langkah berikut untuk memastikan keamanan lingkungan produksi: <br><br><ul><li>  otentikasi: verifikasi identitas; </li><li>  otorisasi: pemeriksaan akses pengguna terotentikasi; </li><li>  manajemen sertifikat: bekerja dengan sertifikat digital, termasuk pembuatan, penyimpanan, dan pembaruan; </li><li>  perlindungan data: memastikan keamanan data yang dikirimkan dan disimpan; </li><li>  keamanan dan isolasi jaringan: mencegah akses ke jaringan oleh pengguna dan proses yang tidak sah; </li><li>  penasihat kerentanan: mengidentifikasi kerentanan dalam gambar; </li><li>  Penasihat Mutasi: Deteksi mutasi dalam wadah. </li></ul><br>  Untuk informasi lebih lanjut, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IBM Cloud Private Security Guide</a> . <br><br>  Catatan khusus adalah manajer sertifikat.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan ini di IBM Cloud Private</a> didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek</a> open <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">source Jetstack</a> .  Manajer Sertifikat memungkinkan Anda mengeluarkan dan mengelola sertifikat untuk layanan yang berjalan di IBM Cloud Private.  Ini mendukung sertifikat publik dan ditandatangani sendiri, terintegrasi penuh dengan <i>kubectl</i> dan kontrol akses berbasis peran. <br><br><h2>  Prinsip XIX: Dapat diukur </h2><br>  <b>Penggunaan aplikasi harus dapat diukur untuk keperluan kuota dan penyelesaian antar departemen.</b> <br><br>  Pada akhirnya, perusahaan harus membayar biaya TI (lihat gambar di bawah).  Sumber daya komputasi yang didedikasikan untuk menjalankan wadah harus dapat diukur, dan organisasi yang menggunakan cluster harus bertanggung jawab.  Pastikan untuk mengikuti Prinsip XIV - Prediktabilitas.  IBM Cloud Private menawarkan layanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akuntansi</a> yang mengumpulkan data tentang sumber daya komputasi untuk setiap wadah dan menggabungkannya di tingkat namespace untuk perhitungan lebih lanjut (sebagai bagian dari showbacks atau tolak bayar). <br><br><img src="https://habrastorage.org/webt/_i/j1/y_/_ij1y_opmepkpidymexgnbf-l78.png"><br>  <i>Penggunaan aplikasi harus dapat diukur</i> <br><br><h2>  Kesimpulan </h2><br>  Saya harap Anda menyukai topik yang diangkat dalam artikel ini, dan Anda mencatat faktor-faktor yang sudah Anda gunakan dan pikirkan tentang faktor-faktor yang masih ada di sela-sela. <br><br>  Untuk informasi lebih lanjut, saya sarankan Anda membiasakan diri dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rekaman</a> kinerja kami di KubeCon 2019 di Shanghai.  Di dalamnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Michael Elder</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saya</a> membahas 12 + 7 prinsip untuk orkestrasi wadah berbasis Kubernetes. <br><br><h2>  PS dari penerjemah </h2><br>  Baca juga di blog kami: <br><br><ul><li>  "Layanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mikro: ukuran penting, bahkan jika Anda memiliki Kubernetes</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7 praktik terbaik untuk pengoperasian kontainer menurut Google</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Monitoring dan Kubernetes (review dan laporan video)</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kematian kegilaan microservice pada tahun 2018.</a> " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460363/">https://habr.com/ru/post/id460363/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460351/index.html">werf - alat kami untuk CI / CD di Kubernetes (ulasan dan laporan video)</a></li>
<li><a href="../id460353/index.html">Jaringan saraf di gelas. Tidak membutuhkan daya, mengenali angka</a></li>
<li><a href="../id460355/index.html">Menyelamatkan tenggelam adalah urusan kami: bagaimana menghadapi penurunan motivasi tim</a></li>
<li><a href="../id460359/index.html">Kursus 2 Desainer Game Muda: Menyeimbangkan Perkembangan dan Dinamika tanpa Matematika</a></li>
<li><a href="../id460361/index.html">FAQ Hebat tentang keamanan siber sistem informasi medis</a></li>
<li><a href="../id460365/index.html">Jejak terdistribusi: kami melakukan semua yang salah</a></li>
<li><a href="../id460367/index.html">Chaos Engineering: seni kehancuran yang disengaja. Bagian 1</a></li>
<li><a href="../id460373/index.html">Di Balik Terpal Halaman Turbo: Arsitektur Teknologi Unduhan Cepat Halaman Web</a></li>
<li><a href="../id460375/index.html">Buku "Pembelajaran Mesin untuk Bisnis dan Pemasaran"</a></li>
<li><a href="../id460377/index.html">Menggunakan Liquibase untuk mengelola struktur database dalam aplikasi Spring Boot. Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>