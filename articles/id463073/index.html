<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©â€ğŸ‘©â€ğŸ‘¦ ğŸ‘™ ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ QUIC in action: bagaimana Uber menerapkannya untuk mengoptimalkan kinerja ğŸŒ¿ ğŸ‘©ğŸ½â€ğŸ¤â€ğŸ‘©ğŸ¼ ğŸ––ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Protokol QUIC sangat menarik untuk ditonton, jadi kami senang menulis tentangnya. Tetapi jika publikasi sebelumnya tentang QUIC lebih bersifat histori...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>QUIC in action: bagaimana Uber menerapkannya untuk mengoptimalkan kinerja</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/463073/">  Protokol QUIC sangat menarik untuk ditonton, jadi kami senang menulis tentangnya.  Tetapi jika publikasi sebelumnya tentang QUIC lebih bersifat historis (sejarah lokal, jika Anda suka) sifat dan bahan, maka hari ini kami senang untuk mempublikasikan interpretasi yang berbeda - kami akan berbicara tentang penerapan sebenarnya dari protokol pada tahun 2019.  Dan ini bukan tentang infrastruktur kecil yang berbasis di garasi bersyarat, tetapi tentang Uber, yang bekerja hampir di seluruh dunia.  Bagaimana para insinyur perusahaan sampai pada keputusan untuk menggunakan QUIC dalam produksi, bagaimana mereka menguji dan apa yang mereka lihat setelah masuk ke dalam produksi - di bawah potongan. <br><blockquote> Gambar dapat diklik.  Selamat membaca! </blockquote><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/t-/vf/ou/t-vfouxapcoi45iq_uugxs3-4lo.png"></a> </div> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a> <a name="habracut"></a><br>  Uber adalah skala global, yaitu 600 kota kehadiran, di mana setiap aplikasi bergantung sepenuhnya pada Internet nirkabel dari lebih dari 4.500 operator seluler.  Pengguna mengharapkan aplikasi berfungsi tidak hanya cepat, tetapi secara real time - untuk memastikan ini, aplikasi Uber membutuhkan latensi rendah dan koneksi yang sangat andal.  Sayangnya, tumpukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HTTP / 2</a> tidak terasa nyaman di jaringan nirkabel yang dinamis dan rawan kehilangan.  Kami menyadari bahwa dalam kasus ini, kinerja rendah terkait langsung dengan implementasi TCP di kernel sistem operasi. <br><br>  Untuk mengatasi masalah tersebut, kami menerapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">QUIC</a> , protokol modern dengan multiplexing saluran, yang memberi kami kontrol lebih besar atas kinerja protokol transport.  Kelompok kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IETF</a> saat ini menstandarisasi QUIC sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HTTP / 3</a> . <br><br>  Setelah pengujian terperinci, kami sampai pada kesimpulan bahwa penerapan QUIC dalam aplikasi kami akan membuat penundaan "tail" lebih sedikit dibandingkan dengan TCP.  Kami mengamati penurunan kisaran 10-30% untuk lalu lintas HTTPS pada contoh aplikasi pengemudi dan penumpang.  QUIC juga memberi kami kendali ujung ke ujung atas paket khusus. <br><br>  Pada artikel ini, kami berbagi pengalaman kami tentang mengoptimalkan TCP untuk aplikasi Uber menggunakan tumpukan yang mendukung QUIC. <br><br><h2>  Kata terakhir dari teknologi: TCP </h2><br>  Saat ini, TCP adalah protokol transportasi yang paling banyak digunakan untuk mengirimkan lalu lintas HTTPS di Internet.  TCP menyediakan aliran byte yang andal, sehingga mengatasi kemacetan jaringan dan kehilangan lapisan tautan.  Meluasnya penggunaan TCP untuk lalu lintas HTTPS dijelaskan oleh keberadaan sebelumnya (hampir setiap OS berisi TCP), ketersediaan pada sebagian besar infrastruktur (misalnya, pada penyeimbang beban, proksi dan CDN HTTPS) dan fungsionalitas out-of-box, yang tersedia di sebagian besar platform dan jaringan. <br><br>  Sebagian besar pengguna menggunakan aplikasi kami saat bepergian, dan penundaan ekor TCP jauh dari persyaratan waktu-nyata lalu lintas HTTPS kami.  Sederhananya, pengguna di seluruh dunia telah menghadapi ini - Gambar 1 menunjukkan penundaan di kota-kota besar: <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/z1/4r/dr/z14rdrs2ba8rzmrb8akbtadvqxy.png"></a> </div><br>  <font color="grey">Gambar 1. Besarnya keterlambatan "tail" bervariasi di kota-kota utama tempat Uber beroperasi.</font> <br><br>  Terlepas dari kenyataan bahwa ada lebih banyak penundaan di jaringan India dan Brasil daripada di AS dan Inggris, penundaan ekor jauh lebih besar daripada penundaan rata-rata.  Dan ini berlaku bahkan untuk AS dan Inggris Raya. <br><br><h2>  Kinerja TCP melalui udara </h2><br>  TCP dibuat untuk jaringan <b>kabel</b> , dengan penekanan pada tautan yang dapat diprediksi dengan baik.  Namun, jaringan <b>nirkabel</b> memiliki karakteristik dan kesulitannya sendiri.  Pertama, jaringan nirkabel rentan terhadap kehilangan karena gangguan dan pelemahan sinyal.  Misalnya, jaringan Wi-Fi sensitif terhadap gelombang mikro, bluetooth, dan gelombang radio lainnya.  Jaringan seluler menderita kehilangan sinyal ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">path loss</a> ) karena refleksi / penyerapan sinyal oleh benda dan bangunan, serta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gangguan</a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menara sel</a> tetangga.  Hal ini menyebabkan lebih signifikan (4-10 kali) dan berbagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penundaan round-trip (RTT)</a> dan kehilangan paket dibandingkan dengan koneksi kabel. <br><br>  Untuk mengatasi fluktuasi dan kerugian bandwidth, jaringan seluler biasanya menggunakan buffer besar untuk ledakan lalu lintas.  Ini dapat menyebabkan prioritas yang berlebihan, yang berarti penundaan lebih lama.  Sangat sering, TCP memperlakukan urutan seperti kehilangan karena peningkatan batas waktu, sehingga TCP cenderung melakukan relai dan dengan demikian mengisi buffer.  Masalah ini dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bufferbloat</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buffer jaringan yang berlebihan, pembengkakan buffer</a> ), dan ini merupakan masalah yang sangat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serius dari</a> Internet modern. <br><br>  Akhirnya, kinerja jaringan seluler bervariasi tergantung pada operator, wilayah, dan waktu.  Pada Gambar 2, kami mengumpulkan penundaan rata-rata lalu lintas HTTPS ke sel dalam rentang 2 kilometer.  Data dikumpulkan untuk dua operator seluler terbesar di Delhi, India.  Seperti yang Anda lihat, kinerja bervariasi dari sel ke sel.  Juga, kinerja satu operator berbeda dari kinerja yang kedua.  Ini dipengaruhi oleh faktor-faktor seperti pola akses jaringan, dengan mempertimbangkan waktu dan lokasi, mobilitas pengguna, serta infrastruktur jaringan, dengan mempertimbangkan kepadatan menara dan rasio jenis jaringan (LTE, 3G, dll.). <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/ln/vz/ya/lnvzyai54p_xde2mfcr50ddoopa.png"></a> </div><br>  <font color="grey">Gambar 2. Penundaan untuk contoh radius 2 km.</font>  <font color="grey">Delhi, India.</font> <br><br>  Juga, kinerja jaringan seluler bervariasi dari waktu ke waktu.  Gambar 3 menunjukkan median keterlambatan pada hari dalam seminggu.  Kami juga mengamati perbedaan pada skala yang lebih kecil - dalam satu hari dan satu jam. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/xu/oo/u_/xuoou_03qrdllnyebxvrpiwa1iy.png"></a> </div><br>  <font color="grey">Gambar 3. Penundaan tail dapat sangat bervariasi pada hari yang berbeda, tetapi dengan operator yang sama.</font> <br><br>  Semua hal di atas mengarah pada fakta bahwa kinerja TCP tidak efisien dalam jaringan nirkabel.  Namun, sebelum mencari alternatif untuk TCP, kami ingin mengembangkan pemahaman yang akurat tentang hal-hal berikut: <br><ul><li>  Apakah TCP penyebab utama keterlambatan ekor dalam aplikasi kita? </li><li>  Apakah jaringan modern mengalami keterlambatan pulang pergi yang signifikan dan bervariasi? </li><li>  Apa efek dari kehilangan kinerja RTT dan TCP? </li></ul><br><h2>  Analisis kinerja TCP </h2><br>  Untuk memahami bagaimana kami menganalisis kinerja TCP, mari kita ingat secara singkat bagaimana TCP mentransfer data dari pengirim ke penerima.  Pertama, pengirim membuat koneksi TCP dengan melakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jabat tangan</a> tiga arah: pengirim mengirim paket SYN, menunggu paket SYN-ACK dari penerima, kemudian mengirim paket ACK.  Lintasan tambahan kedua dan ketiga digunakan untuk membuat koneksi TCP.  Penerima mengakui tanda terima dari setiap paket (ACK) untuk memastikan pengiriman yang andal. <br><br>  Jika suatu paket atau ACK hilang, pengirim mengirim ulang setelah batas waktu (RTO, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">batas waktu pengiriman ulang</a> ).  RTO dihitung secara dinamis berdasarkan berbagai faktor, misalnya, penundaan RTT yang diharapkan antara pengirim dan penerima. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/-w/nf/g8/-wnfg8rew9-lbfsaxfw6k9fnnxi.png"></a> </div><br>  <font color="grey">Gambar 4. Pertukaran paket TCP / TLS termasuk mekanisme transmisi ulang.</font> <br><br>  Untuk menentukan bagaimana TCP bekerja dalam aplikasi kami, kami memantau paket TCP dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tcpdump</a> selama seminggu pada traffic traffic yang datang dari server perbatasan India.  Kemudian kami menganalisis koneksi TCP menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tcptrace</a> .  Selain itu, kami membuat aplikasi Android yang mengirimkan lalu lintas yang ditiru ke server uji, sebanyak mungkin meniru lalu lintas nyata.  Smartphone dengan aplikasi ini dibagikan kepada beberapa karyawan yang mengumpulkan log selama beberapa hari. <br><br>  Hasil dari kedua percobaan itu konsisten satu sama lain.  Kami melihat penundaan RTT yang tinggi;  nilai ekor hampir 6 kali lebih tinggi dari nilai median;  nilai rata-rata aritmatika penundaan - lebih dari 1 detik.  Banyak koneksi yang hilang, menyebabkan TCP mentransmisikan kembali 3,5% dari semua paket.  Di daerah dengan kemacetan, seperti bandara dan stasiun kereta, kami mengamati kerugian 7%.  Hasil tersebut menimbulkan keraguan pada kebijaksanaan konvensional bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skema transmisi ulang canggih yang</a> digunakan dalam jaringan seluler secara signifikan mengurangi kehilangan transportasi.  Di bawah ini adalah hasil tes dari aplikasi "simulator": <br><div class="scrollable-table"><table><tbody><tr><th>  Metrik jaringan </th><th>  Nilai-nilai </th></tr><tr><td>  <b>RTT, milidetik [50%, 75%, 95%, 99%]</b> </td><td>  [350, 425, 725, 2300] </td></tr><tr><td>  <b>Perbedaan RTT, detik</b> </td><td>  ~ 1,2 s rata-rata </td></tr><tr><td>  <b>Paket hilang dalam koneksi yang tidak stabil</b> </td><td>  Rata-rata ~ 3,5% (7% di daerah dengan kemacetan) </td></tr></tbody></table></div><br>  Hampir setengah dari koneksi ini memiliki setidaknya satu paket yang hilang, yang sebagian besar adalah paket SYN dan SYN-ACK.  Sebagian besar implementasi TCP menggunakan nilai RTO 1 detik untuk paket SYN, yang meningkat secara eksponensial untuk kerugian selanjutnya.  Waktu pemuatan aplikasi dapat meningkat karena fakta bahwa TCP akan memerlukan lebih banyak waktu untuk membuat koneksi. <br><br>  Dalam hal paket data, RTO tinggi sangat mengurangi pemanfaatan jaringan yang bermanfaat dengan adanya kerugian sementara pada jaringan nirkabel.  Kami menemukan bahwa waktu pengiriman ulang rata-rata adalah sekitar 1 detik dengan penundaan hampir 30 detik.  Keterlambatan tinggi di tingkat TCP menyebabkan waktu tunggu dan coba ulang HTTPS, yang selanjutnya meningkatkan latensi dan ketidakefisienan jaringan. <br><br>  Sementara persentil ke-75 dari RTT yang diukur adalah sekitar 425 ms, persentil ke-75 untuk TCP hampir 3 detik.  Ini mengisyaratkan bahwa kerugian memaksa TCP untuk membuat 7-10 lintasan agar berhasil mengirim data.  Ini mungkin disebabkan oleh perhitungan RTO yang tidak efektif, ketidakmampuan TCP untuk dengan cepat menanggapi hilangnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paket terakhir</a> di jendela, dan ketidakefisienan algoritma kontrol kemacetan, yang tidak membedakan antara kehilangan dan kehilangan nirkabel karena kelebihan jaringan.  Di bawah ini adalah hasil uji TCP loss: <br><div class="scrollable-table"><table><tbody><tr><th>  Statistik kehilangan paket TCP </th><th>  Nilai </th></tr><tr><td>  Persentase koneksi dengan setidaknya 1 paket loss </td><td>  45% </td></tr><tr><td>  Persentase koneksi dengan kehilangan selama pembuatan koneksi </td><td>  30% </td></tr><tr><td>  Persentase koneksi dengan kehilangan selama pertukaran data </td><td>  76% </td></tr><tr><td>  Distribusi Keterlambatan Pengiriman Ulang, Detik [50%, 75%, 95%, 99%] </td><td>  [1, 2,8, 15, 28] </td></tr><tr><td>  Distribusi transmisi ulang untuk satu paket atau segmen TCP </td><td>  [1,3,6,7] </td></tr></tbody></table></div><br><h2>  Aplikasi QUIC </h2><br>  Awalnya dirancang oleh Google, QUIC adalah protokol transportasi multi-utas, modern yang berjalan di atas UDP.  Saat ini, QUIC sedang dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proses standardisasi</a> (kami sudah menulis bahwa ada dua versi QUIC, yang penasaran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat mengikuti tautan</a> - kira-kira Penerjemah).  Seperti yang ditunjukkan pada Gambar 5, QUIC dihosting di bawah HTTP / 3 (sebenarnya, HTTP / 2 di atas QUIC - ini adalah HTTP / 3, yang sekarang sangat standar).  Itu sebagian menggantikan HTTPS dan lapisan TCP, menggunakan UDP untuk membentuk paket.  QUIC hanya mendukung transfer data yang aman, karena TLS sepenuhnya terintegrasi dalam QUIC. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y4/an/qg/y4anqgxplkww-bc3thmjykbdg2i.png"></div><br>  <font color="grey">Gambar 5: QUIC bekerja di bawah HTTP / 3, menggantikan TLS, yang dulu bekerja di bawah HTTP / 2.</font> <br><br>  Di bawah ini kami mencantumkan alasan yang meyakinkan kami untuk menggunakan QUIC untuk memperkuat TCP: <br><ul><li>  <b>Pengaturan koneksi 0-RTT.</b>  QUIC memungkinkan penggunaan kembali otorisasi dari koneksi sebelumnya, mengurangi jumlah jabat tangan keamanan.  Di masa depan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TLS1.3</a> akan mendukung 0-RTT, tetapi jabat tangan TCP tiga arah masih akan diperlukan. </li><li>  <b>Mengatasi pemblokiran HoL.</b>  HTTP / 2 menggunakan satu koneksi TCP untuk setiap klien untuk meningkatkan kinerja, tetapi ini dapat menyebabkan blok HoL (head-of-line).  QUIC menyederhanakan multiplexing dan mengirimkan permintaan ke aplikasi secara independen satu sama lain. </li><li>  <b>manajemen kemacetan.</b>  QUIC ada di level aplikasi, membuatnya lebih mudah untuk memperbarui algoritma transport utama, yang mengontrol pengiriman, berdasarkan parameter jaringan (jumlah kehilangan atau RTT).  Sebagian besar implementasi TCP menggunakan algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CUBIC</a> , yang tidak optimal untuk lalu lintas sensitif yang tertunda.  Algoritma yang baru dikembangkan seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BBR</a> memodelkan jaringan dengan lebih akurat dan mengoptimalkan latensi.  QUIC memungkinkan Anda untuk menggunakan BBR dan memperbarui algoritme ini karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">meningkatkan</a> . </li><li>  <b>menebus kerugian.</b>  QUIC memanggil dua TLP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tail loss probe</a> ) sebelum RTO kebakaran - bahkan ketika kerugiannya sangat mencolok.  Ini berbeda dari implementasi TCP.  TLP mengirim ulang terutama paket terakhir (atau baru, jika ada) untuk memicu pengisian cepat.  Pemrosesan tail tail sangat berguna untuk bagaimana Uber bekerja dengan jaringan, yaitu untuk transmisi data yang pendek, episodik, dan sensitif terhadap penundaan. </li><li>  <b>ACK dioptimalkan.</b>  Karena setiap paket memiliki nomor seri yang unik, tidak ada masalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membedakan antara</a> paket ketika mereka disampaikan.  Paket ACK juga mengandung waktu untuk memproses paket dan menghasilkan ACK sisi klien.  Fitur-fitur ini memastikan bahwa QUIC menghitung RTT lebih akurat.  QUIC ACK mendukung hingga 256 rentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NACK</a> , membantu pengirim menjadi lebih tangguh untuk bertukar paket dan menggunakan lebih sedikit byte dalam proses.  ACK selektif ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SACK</a> ) dalam TCP tidak menyelesaikan masalah ini dalam semua kasus. </li><li>  <b>migrasi koneksi.</b>  Koneksi QUIC diidentifikasi oleh ID 64-bit, jadi jika klien mengubah alamat IP, Anda dapat terus menggunakan ID dari koneksi lama pada alamat IP baru, tanpa gangguan.  Ini adalah praktik yang sangat umum untuk aplikasi seluler ketika pengguna beralih antara Wi-Fi dan koneksi seluler. </li></ul><br><h2>  Alternatif untuk QUIC </h2><br>  Kami melihat pendekatan alternatif untuk menyelesaikan masalah sebelum memilih QUIC. <br><br>  Pertama-tama, kami mencoba menggunakan TPC PoP (Points of Presence) untuk menyelesaikan koneksi TCP yang lebih dekat dengan pengguna.  Pada dasarnya, PoP mengakhiri koneksi TCP dengan perangkat seluler yang lebih dekat ke jaringan seluler dan proksi lalu lintas ke infrastruktur asli.  Menutup TCP lebih dekat, kita berpotensi mengurangi RTT dan memastikan bahwa TCP akan lebih responsif terhadap lingkungan nirkabel yang dinamis.  Namun, percobaan kami menunjukkan bahwa sebagian besar, RTT dan kerugian berasal dari jaringan seluler dan penggunaan PoP tidak memberikan peningkatan kinerja yang signifikan. <br><br>  Kami juga melihat ke arah penyetelan parameter TCP.  Mengkonfigurasi TCP stack pada server tepi heterogen kami sulit karena TCP memiliki implementasi yang berbeda di berbagai versi OS.  Sulit untuk mengimplementasikan ini dan menguji berbagai konfigurasi jaringan.  Mengonfigurasi TCP secara langsung pada perangkat seluler tidak dimungkinkan karena kurangnya otoritas.  Lebih penting lagi, chip seperti koneksi dengan 0-RTT dan peningkatan prediksi RTT sangat penting untuk arsitektur protokol, dan oleh karena itu tidak mungkin untuk mencapai manfaat yang signifikan hanya dengan mengkonfigurasi TCP. <br><br>  Akhirnya, kami mengevaluasi beberapa protokol berbasis UDP yang memecahkan masalah streaming video - kami ingin tahu apakah protokol ini akan membantu dalam kasus kami.  Sayangnya, mereka tidak memiliki banyak pengaturan keamanan, dan mereka juga membutuhkan koneksi TCP tambahan untuk metadata dan mengontrol informasi. <br><br>  Penelitian kami menunjukkan bahwa QUIC hampir merupakan satu-satunya protokol yang dapat membantu masalah lalu lintas Internet, dengan tetap mempertimbangkan keamanan dan kinerja. <br><br><h2>  Integrasi QUIC ke dalam platform </h2><br>  Untuk berhasil mengintegrasikan QUIC dan meningkatkan kinerja aplikasi dalam kondisi komunikasi yang buruk, kami mengganti tumpukan lama (HTTP / 2 melalui TLS / TCP) dengan protokol QUIC.  Kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka</a> jaringan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cronet</a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proyek Chromium</a> , yang berisi protokol Google versi asli - gQUIC.  Implementasi ini juga terus ditingkatkan untuk mengikuti spesifikasi IETF terbaru. <br><br>  Pertama, kami mengintegrasikan Cronet ke aplikasi Android kami untuk menambahkan dukungan QUIC.  Integrasi dilakukan untuk meminimalkan biaya migrasi.  Alih-alih mengganti sepenuhnya tumpukan jaringan lama yang menggunakan pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://square.github.io/ok">OkHttp</a> , kami mengintegrasikan Cronet DI BAWAH kerangka OkHttp API.  Dengan mengintegrasikan dengan cara ini, kami menghindari perubahan dalam panggilan jaringan kami (yang digunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Retrofit</a> ) di tingkat API. <br><br>  Mirip dengan pendekatan ke perangkat Android, kami menerapkan Cronet dalam aplikasi Uber untuk iOS, memotong lalu lintas HTTP dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API</a> jaringan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NSURLProtocol</a> .  Abstraksi ini, disediakan oleh iOS Foundation, memproses data URL khusus protokol dan memastikan bahwa kami dapat mengintegrasikan Cronet ke aplikasi iOS kami tanpa biaya migrasi yang signifikan. <br><br><h2>  Quic Diselesaikan di Google Cloud Balancers </h2><br>  Di sisi backend, terminasi QUIC disediakan oleh infrastruktur penyeimbang Beban Google Cloud, yang menggunakan header <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alt-svc</a> sebagai respons untuk mendukung QUIC.  Secara umum, penyeimbang menambahkan header alt-svc ke setiap permintaan HTTP dan sudah memvalidasi dukungan QUIC untuk domain.  Ketika klien Cronet menerima respons HTTP dengan tajuk ini, ia menggunakan QUIC untuk permintaan HTTP berikutnya ke domain ini.  Segera setelah penyeimbang menyelesaikan QUIC, infrastruktur kami secara eksplisit mengirimkan tindakan ini melalui HTTP2 / TCP ke pusat data kami. <br><br><h2>  Kinerja: Hasil </h2><br>  Performa luar biasa adalah alasan utama kami mencari protokol yang lebih baik.  Pertama, kami membuat dudukan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">emulasi jaringan</a> untuk mengetahui bagaimana QUIC akan berperilaku dengan profil jaringan yang berbeda.  Untuk menguji operasi QUIC di jaringan nyata, kami bereksperimen di sekitar New Delhi menggunakan lalu lintas jaringan yang diemulasikan sangat mirip dengan panggilan HTTP dalam aplikasi penumpang. <br><br><h3>  Eksperimen 1 </h3><br>  Inventaris untuk eksperimen: <br><ul><li>  Perangkat uji Android dengan tumpukan OkHttp dan Cronet untuk memastikan bahwa kami mengirim lalu lintas HTTPS melalui TCP dan QUIC, masing-masing; </li><li>  server emulasi berbasis Java yang mengirimkan jenis HTTPS header yang sama dalam tanggapan dan memuat perangkat klien untuk menerima permintaan dari mereka; </li><li>  Proxy cloud yang secara fisik terletak dekat dengan India untuk menyelesaikan koneksi TCP dan QUIC.  Sementara kami menggunakan proxy terbalik pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NGINX</a> untuk menyelesaikan TCP, sulit untuk menemukan proxy reverse open source untuk QUIC.  Kami membuat proxy terbalik untuk QUIC sendiri, menggunakan tumpukan QUIC dasar dari Chromium dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menerbitkannya</a> dalam kromium sebagai sumber terbuka. </li></ul><br> <a href=""><img src="https://habrastorage.org/webt/vp/qt/sx/vpqtsxbastzm3um6hjwcdz2giv8.png" width="49%"></a> <a href=""><img src="https://habrastorage.org/webt/qc/ti/vz/qctivzpddsppzzfxhfqbkgzopyk.png" width="49%"></a> <br>  <font color="grey">Gambar 6. Set perjalanan untuk tes TCP vs QUIC terdiri dari perangkat Android dengan OkHttp dan Cronet, proksi cloud untuk mengakhiri koneksi, dan server emulasi.</font> <br><br><h3>  Eksperimen 2 </h3><br>  Ketika Google menyediakan QUIC menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://cloud.google.com/blog/products/gcp/introducing-quic-support-">Google Cloud Load Balancing</a> , kami menggunakan inventaris yang sama, tetapi dengan satu modifikasi: alih-alih NGINX, kami mengambil Google balancers untuk menyelesaikan koneksi TCP dan QUIC dari perangkat, serta untuk mengarahkan lalu lintas HTTPS ke server emulasi .  Balancers didistribusikan di seluruh dunia, tetapi gunakan server PoP yang paling dekat dengan perangkat (berkat geolokasi). <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/bl/ec/v-/blecv-4m260dn8_ufg9d0tuq5e4.png"></a> </div><br>  <font color="grey">Gambar 7. Dalam percobaan kedua, kami ingin membandingkan penundaan penyelesaian TCP dan QUIC: menggunakan Google Cloud dan menggunakan proxy cloud kami.</font> <br><br>  Akibatnya, beberapa wahyu menunggu kami: <br><ul><li>  <b>Pemutusan PoP meningkatkan kinerja TCP.</b>  Karena penyeimbang melengkapi koneksi TCP lebih dekat ke pengguna dan dioptimalkan dengan sempurna, ini menghasilkan RTT yang lebih rendah, yang meningkatkan kinerja TCP.    QUIC   ,     TCP      ( 10-30 ). </li><li> <b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  (hops)</a> .</b>   QUIC-     (   50  ),   ,     â€“ 15%-    20%-   99   TCP.    ,      â€“    (bottleneck)   . </li></ul><br> <a href=""><img src="https://habrastorage.org/webt/ne/co/7c/neco7cpjmlkjsp0uxdnwfez9cuk.png" width="49%"></a> <a href=""><img src="https://habrastorage.org/webt/zd/gl/2d/zdgl2d_tftg33ztgy_t90ikfcui.png" width="49%"></a> <br> <font color="grey"> 8.    ,  QUIC   TCP.</font> <br><br><h2>   </h2><br>  ,    QUIC   Android  iOS-.   A/B ,    QUIC    Uber.  ,          ,       . <br><br>        (95  99 )       â€“ LTE, 3G, 2G. <br> <a href=""><img src="https://habrastorage.org/webt/-7/p7/11/-7p711t91dffb4aoecw6f_woexw.png" width="49%"></a> <a href=""><img src="https://habrastorage.org/webt/oo/q4/gr/ooq4grp5mldwwmiyxyy8poqyqug.png" width="49%"></a> <br> <font color="grey"> 9.    QUIC  TCP  .</font> <br><br><h2>   </h2><br> ,    â€“  QUIC           ,    ,  : <br><br><h3>   </h3><br>      ,  ,   80%    QUIC  <b></b> ,     15%    QUIC  TCP.  ,    - ,   Cronet    TCP  ,        UDP-    .      ,        QUIC. <br><br><h3>  QUIC </h3><br>       ,     .        .   ,     ,        TCP  QUIC   .           QUIC-  . <br><br>                 ,           . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463073/">https://habr.com/ru/post/id463073/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463061/index.html">Aturan untuk menyiapkan tata letak dalam Figma</a></li>
<li><a href="../id463063/index.html">Kami berurusan dengan antarmuka di Go</a></li>
<li><a href="../id463067/index.html">Pertama bagian depan, dan kemudian bagian belakang (suatu hari nanti)</a></li>
<li><a href="../id463069/index.html">Bereaksi Panduan Animasi Dasar</a></li>
<li><a href="../id463071/index.html">Apa dampak pemadaman internet?</a></li>
<li><a href="../id463075/index.html">Lisensi Open Source Baru</a></li>
<li><a href="../id463083/index.html">Melindungi cadangan iPhone</a></li>
<li><a href="../id463085/index.html">Sistem Akses File Jarak Jauh Kandang</a></li>
<li><a href="../id463089/index.html">Penerapan sistem pencarian perusahaan untuk desainer mekanik menggunakan platform Low-Code</a></li>
<li><a href="../id463095/index.html">Kenapa tidak SQL?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>