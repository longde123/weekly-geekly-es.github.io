<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏽 🤛🏽 🏍️ 类JavaScript JavaScript序列化支持 ⛹🏽 💵 🏸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="序言 


 当前，我正在开发Javascript模式编辑器，在此工作过程中，我遇到了本文将要解决的问题，即复杂数据对象的序列化和反序列化。 


在不涉及项目细节的情况下，我注意到根据我的想法，方案是从基类继承的元素（顶点）的数组。 因此，每个子类都实现其自己的逻辑。 此外，顶点包含彼此的链接（箭...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>类JavaScript JavaScript序列化支持</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413113/"><h3 id="prolog"> 序言 </h3><br><p> 当前，我正在开发Javascript模式编辑器，在此工作过程中，我遇到了本文将要解决的问题，即复杂数据对象的序列化和反序列化。 </p><br><p>在不涉及项目细节的情况下，我注意到根据我的想法，方案是从基类继承的元素（顶点）的数组。 因此，每个子类都实现其自己的逻辑。 此外，顶点包含彼此的链接（箭头），这些链接也需要保留。 从理论上讲，顶点可以直接引用自己，也可以通过其他顶点引用。 标准JSON.stringify无法序列化这样的数组，因此我决定创建自己的序列化程序来解决上述两个问题： </p><br><ol><li> 能够在序列化期间保存类信息，并在反序列化期间恢复它。 </li><li> 保存和还原对象链接的能力，包括 循环的。 </li></ol><br><p> 阅读更多有关该问题的陈述及其解决方案的信息。 </p><a name="habracut"></a><br><h3 id="proekt-serializatora-na-github">  Github序列化器项目 </h3><br><p> 链接到github项目： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">link</a> 。 <br> 复杂的示例也位于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">test-src</a>文件夹中。 </p><br><p> 递归序列化器： <a href="">link</a> 。 <br> 平面序列化器： <a href="">link</a> 。 </p><br><h3 id="postanovka-zadachi"> 问题陈述 </h3><br><p> 正如我已经指出的，最初的任务是为编辑器序列化任意电路。 为了不浪费时间描述编辑器，我们将任务设置得更容易。 假设我们要使用ES6 Javascript类对简单算法方案进行正式描述，然后对该方案进行序列化和反序列化。 </p><br><p> 在互联网上，我找到了确定两个值中最大值的最简单算法的合适图片： </p><br><p><img src="https://habrastorage.org/webt/dk/fa/yk/dkfaykajbnvk5ma4djpceof1wps.png" alt="图片"></p><br><p> 在这里我必须说我不是Java语言开发人员，而我的“本机”语言是C＃，因此解决问题的方法取决于C＃中面向对象开发的经验。 查看此图，我看到以下类型的顶点（条件名称和特殊角色不起作用）： </p><br><ul><li> 开始顶点（开始） </li><li> 最终高峰（完成） </li><li> 队长（指挥官） </li><li> 赋值顶点（让） </li><li> 验证验证顶部（如果有） </li></ul><br><p> 这些顶点在数据集或语义上有一些区别，但是它们都是从基本顶点（节点）继承的。 在相同的地方，在Node类中，描述了links字段，其中包含到其他顶点的链接，并且addLink方法允许添加这些链接。 所有类的完整代码都可以在<a href="">这里</a>找到。 </p><br><p> 让我们编写从图片中收集电路的代码，然后尝试序列化结果。 </p><br><div class="spoiler">  <b class="spoiler_title">算法设计代码</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   let start = new Schema.Start(); let input = new Schema.Command(' A, B'); let check = new Schema.If('A &gt; B'); let maxIsA = new Schema.Let('Max', 'A'); let maxIsB = new Schema.Let('Max', 'B'); let output = new Schema.Command(' Max'); let finish = new Schema.Finish(); //   start.addLink(input); input.addLink(check); check.addLink(maxIsA, { condition: 'true' }); check.addLink(maxIsB, { condition: 'false' }); maxIsA.addLink(output); maxIsB.addLink(output); output.addLink(finish); //    ( ) let schema = [ start, input, check, maxIsA, maxIsB, output, finish ];</span></span></code> </pre> </div></div><br><p> 如果我们使用JSON.stringify序列化此模式，我们将得到可怕的结果。 我将给出结果的前几行，并在其中添加我的评论： </p><br><div class="spoiler">  <b class="spoiler_title">JSON.stringify结果</b> <div class="spoiler_text"><pre> <code class="hljs objectivec">[ <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"d9c8ab69-e4fa-4433-80bb-1cc7173024d6"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-string"><span class="hljs-string">"links"</span></span>: { <span class="hljs-string"><span class="hljs-string">"2e3d482b-187f-4c96-95cd-b3cde9e55a43"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"2e3d482b-187f-4c96-95cd-b3cde9e55a43"</span></span>, <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"f87a3913-84b0-4b70-8927-6111c6628a1f"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-string"><span class="hljs-string">"links"</span></span>: { <span class="hljs-string"><span class="hljs-string">"4f623116-1b70-42bf-8a47-da1e9be5e4b2"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"4f623116-1b70-42bf-8a47-da1e9be5e4b2"</span></span>, <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"94a47403-13ab-4c83-98fe-3b201744c8f2"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"If"</span></span>, <span class="hljs-string"><span class="hljs-string">"links"</span></span>: { ...</code> </pre> </div></div><br><p> 因为 第一个顶点包含到第二个顶点的链接，也包含到第二个顶点的链接，然后由于其序列化，整个电路被序列化。 然后，第二个峰被序列化，所有与之相关的序列，依此类推。 您可以仅通过标识符从此哈希还原原始链接，但是如果任何一个顶点直接或通过其他顶点引用自身，则它们将无济于事。 在这种情况下，序列化程序将<u>引发Uncaught TypeError：将循环结构转换为JSON</u>错误。 如果不清楚，下面是生成此错误的最简单示例： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//jsfiddle.net/L4guo86w/</a> 。 </p><br><p> 此外，JSON不包含有关源类的任何信息，因此无法了解序列化之前每个顶点的类型。 </p><br><p> 意识到这些问题后，我上网了，开始寻找现成的解决方案。 有很多，但大多数都非常笨重，或者需要对可序列化类进行特殊描述，因此决定自己制造一辆自行车。 是的，我喜欢自行车。 </p><br><h3 id="koncepciya-serializatora"> 序列化器概念 </h3><br><p> 本部分适用于那些想与我一起创建序列化算法的人，尽管实际上是这样。 </p><br><h4 id="sohranenie-informacii-o-tipah-dannyh"> 保存数据类型信息 </h4><br><p>  Javascript的问题之一是缺少可在C＃或Java（属性和反射）等语言中实现奇迹的元数据。 另一方面，我不需要具有定义可序列化字段，验证和其他芯片列表的功能的超复杂序列化。 因此，主要思想是向对象添加有关其类型的信息，并使用普通的JSON.stringify对其进行序列化。 </p><br><p> 在寻找解决方案时，我遇到了一篇有趣的文章，其标题翻译为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ 6种在JSON中添加类型信息的错误方法”</a> 。 实际上，这些方法非常好，我选择了第5种方法。如果您懒于阅读本文，但是我强烈建议您这样做，那么我将简要描述该方法：序列化一个对象时，我们将其包装在另一个对象中名称格式为<code>"@&lt;type&gt;"</code>的字段，该值是对象的数据。 反序列化期间，我们提取类型名称，从构造函数中重新创建对象，然后读取其字段的数据。 </p><br><p> 如果我们从上面的示例中删除链接，则标准JSON.stringify会像这样对数据进行序列化： </p><br><div class="spoiler">  <b class="spoiler_title">JSON.stringify</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"d04d6a58-7215-4102-aed0-32122e331cf4"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {} }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5c58c3fc-8ce1-45a5-9e44-90d5cebe11d3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> }, ... }</code> </pre> </div></div><br><p> 我们的序列化器将像这样包装它： </p><br><div class="spoiler">  <b class="spoiler_title">序列化结果</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"d04d6a58-7215-4102-aed0-32122e331cf4"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {} } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5c58c3fc-8ce1-45a5-9e44-90d5cebe11d3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } }, ... }</code> </pre> </div></div><br><p> 当然，有一个缺点：序列化程序必须知道其可以序列化的类型，并且对象本身不应包含名称以狗开头的字段。 但是，第二个问题是通过与开发人员达成协议或用其他符号替换狗符号来解决的，而第一个问题是用一行代码解决的（下面将作为示例）。 我们确切知道将要序列化的内容，对吗？ </p><br><h4 id="reshenie-problemy-so-ssylkami"> 解决链接问题 </h4><br><p> 就算法而言，它仍然更简单，但是更难以实现。 </p><br><p> 当序列化在序列化器中注册的类的实例时，我们会将它们存储在缓存中并为其分配一个序列号。 如果将来再次遇到该实例，那么在第一个定义中，我们将添加此数字（字段名称将采用<code>"@&lt;type&gt;|&lt;index&gt;"</code> ），并在序列化的位置以对象的形式插入链接 </p><br><pre> <code class="hljs json"> { <span class="hljs-attr"><span class="hljs-attr">"@&lt;type&gt;"</span></span>: &lt;index&gt; }</code> </pre> <br><p> 因此，在反序列化期间，我们将查看该字段的确切值。 如果这是一个数字，那么我们将根据该数字从缓存中提取对象。 否则，这是他的第一个定义。 </p><br><p> 让我们将链接从方案的第一顶部返回到第二顶部，并查看结果： </p><br><div class="spoiler">  <b class="spoiler_title">序列化结果</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"a26a3a29-9462-4c92-8d24-6a93dd5c819a"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"25fa2c44-0446-4471-a013-8b24ffb33bac"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Link"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"25fa2c44-0446-4471-a013-8b24ffb33bac"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command|1"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"4f4f5521-a2ee-4576-8aec-f61a08ed38dc"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } } } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }, ... }</code> </pre> </div></div><br><p> 乍一看似乎不太清楚，因为 首先在Link通信对象的第一个顶点内定义第二个顶点，但是这种方法起作用很重要。 此外，我创建了序列化器的第二个版本，该版本绕过树的深度不是宽度，而是宽度，从而避免了这种“梯子”。 </p><br><h3 id="sozdanie-serializatora"> 创建序列化器 </h3><br><p> 本部分适用于有兴趣实施上述思想的人员。 </p><br><h4 id="zagotovka-serializatora"> 序列化器空白 </h4><br><p> 像其他任何方法一样，我们的序列化器将有两种主要方法-序列化和反序列化。 另外，我们将需要一种方法来告诉序列化程序应该序列化的类（注册）和不应该序列化的类（忽略）。 为了不对DOM元素，JQuery对象或任何其他无法序列化或不需要序列化的数据类型进行序列化，后者是必需的。 例如，在我的编辑器中，我存储了对应于顶点或链接的可视元素。 它是在初始化期间创建的，并且当然不应该落入数据库中。 </p><br><div class="spoiler">  <b class="spoiler_title">序列化程序外壳程序代码</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._nameToCtor = []; <span class="hljs-comment"><span class="hljs-comment">//    this._ctorToName = []; //    this._ignore = [Element]; //    } /** *   * @param {string} alias  * @param {Function} ctor  */ register(alias, ctor) { if (typeof ctor === 'undefined' &amp;&amp; typeof alias === 'function') { //    -  ctor = alias; alias = ctor.name; } this._nameToCtor[alias] = ctor; this._ctorToName[ctor] = alias; } /** *     * @param {Function} ctor  */ ignore(ctor) { if (this._ignore.indexOf(ctor) &lt; 0) { this._ignore.push(ctor); } } /** *   * @param {any} val  * @param {Function} [replacer]       * @param {string} [space]   * @returns {string}  */ serialize(val, replacer, space) { return JSON.stringify(new SerializationContext(this).serialize(val), replacer, space); } /** *     json * @param {any} val    json * @returns {any}  */ deserialize(val) { //     if (isString(val)) val = JSON.parse(val); return new DeserializationContext(this).deserialize(val); } }</span></span></code> </pre> </div></div><br><p> 说明 </p><br><p> 要注册一个类，您必须通过以下两种方式之一将其构造函数传递给register方法： </p><br><ol><li> 注册（MyClass） </li><li> 注册（'MyNamespace.MyClass'，MyClass） </li></ol><br><p> 在第一种情况下，类名称将从构造函数的名称中提取（IE中不支持），在第二种情况下，您自己指定名称。 第二种方法是可取的，因为 允许您使用名称空间，第一种是设计使然，可以使用重新定义的序列化逻辑来注册内置Javascript类型。 </p><br><p> 对于我们的示例，序列化器的初始化如下： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Schema <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schema'</span></span>; ... <span class="hljs-comment"><span class="hljs-comment">//   let serializer = new Serializer(); //   Object.keys(Schema).forEach(key =&gt; serializer.register(`Schema.${key}`, Schema[key]));</span></span></code> </pre> <br><p>  Schema对象包含所有顶点类的描述，因此类注册代码仅占一行。 </p><br><h4 id="kontekst-serializacii-i-deserializacii"> 序列化和反序列化的上下文 </h4><br><p> 您可能已经注意到了神秘的SerializationContext和DeserializationContext类。 是由他们来完成所有工作，并且主要是为了将数据与不同的序列化/反序列化过程分离开来，因为 对于每个呼叫，他们都需要存储中间信息-序列化对象的缓存和链接的序列号。 </p><br><h4 id="serializationcontext"> 序列化上下文 </h4><br><p> 我将仅详细分析递归序列化器，因为 它们的“扁平”对象在某种程度上更加复杂，并且仅在处理对象树的方法上有所不同。 </p><br><p> 让我们从构造函数开始： </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  * @param {Serializer} ser  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(ser) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__proto__.__proto__ = ser; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache = []; <span class="hljs-comment"><span class="hljs-comment">//    this.index = 0; //     }</span></span></code> </pre> <br><p> 我<code>this.__proto__.__proto__ = ser;</code>解释这条神秘线： <code>this.__proto__.__proto__ = ser;</code> <br> 在构造函数的输入处，我们接受序列化程序本身的对象，并且此行从其继承我们的类。 这允许通过<code>this</code>访问序列化器数据。 <br> 例如， <code>this._ignore</code>引用序列化程序本身的被忽略类的列表（“黑名单”），这非常有用。 否则，我们将不得不编写类似<code>this._serializer._ignore</code> 。 </p><br><p> 主要序列化方法： </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {any} val  * @returns {string}  */</span></span> serialize(val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(val)) { <span class="hljs-comment"><span class="hljs-comment">//  return this.serializeArray(val); } else if (isObject(val)) { //  if (this._ignore.some(e =&gt; val instanceof e)) { //   return undefined; } else { return this.serializeObject(val); } } else { //   return val; } }</span></span></code> </pre> <br><p> 应该注意的是，我们处理的数据有三种基本类型：数组，对象和简单值。 如果对象的构造函数在“黑名单”中，则该对象不会序列化。 </p><br><p> 阵列序列化： </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {Array} val  * @returns {Array}  */</span></span> serializeArray(val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serialize(item); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> e !== <span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) res.push(e); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br><p> 您可以通过map编写较短的文字，但这并不重要。 只有一件事很重要-检查未定义的值。 如果数组中存在不可序列化的类，那么如果不进行此检查，它将以未定义的形式落入数组中，这不是很好。 同样在我的实现中，数组被序列化而没有键。 从理论上讲，您可以优化用于序列化关联数组的算法，但是出于这些目的，我更喜欢使用对象。 另外，JSON.stringify也不喜欢关联数组。 </p><br><p> 对象序列化： </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {Object} val  * @returns {Object}  */</span></span> serializeObject(val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._ctorToName[val.constructor]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name) { <span class="hljs-comment"><span class="hljs-comment">//     if (!val.__uuid) val.__uuid = ++uuid; let cached = this.cache[val.__uuid]; if (cached) { //     if (!cached.index) { //     cached.index = ++this.index; let key = Object.keys(cached.ref)[0]; let old = cached.ref[key]; cached.ref[`@${name}|${cached.index}`] = old; delete cached.ref[key]; } //     return { [`@${name}`]: cached.index }; } else { let res; let cached = { ref: { [`@${name}`]: {} } }; this.cache[val.__uuid] = cached; if (typeof val.serialize === 'function') { //     res = val.serialize(); } else { //   res = this.serializeObjectInner(val); } cached.ref[Object.keys(cached.ref)[0]] = res; return cached.ref; } } else { //   return this.serializeObjectInner(val); } }</span></span></code> </pre> </div></div><br><p> 显然，这是串行器最困难的部分，它的核心。 让我们拆开。 </p><br><p> 首先，我们检查类构造函数是否已在序列化程序中注册。 如果不是，则这是一个简单的对象，将为其调用<code>serializeObjectInner</code>实用程序方法。 </p><br><p> 否则，我们检查对象是否被分配了唯一标识符<strong>__uuid</strong> 。 这是所有序列化程序都通用的简单计数器变量，用于在缓存中保留对类实例的引用。 您可以不使用它，而将实例本身本身不带密钥存储在高速缓存中，但是要检查对象是否存储在高速缓存中，则必须遍历整个高速缓存，这里足以检查密钥。 我认为就浏览器中对象的内部实现而言，这更快。 另外，我故意不序列化以两个下划线<strong>开头的</strong>字段，因此<strong>__uuid</strong>字段不会像其他私有类字段那样落入生成的json中。 如果这对于您的任务不可接受，则可以更改此逻辑。 </p><br><p> 接下来，通过<strong>__uuid</strong>的值<strong>，</strong>我们找到一个对象，该对象描述了高速缓存（ <strong>cached</strong> ）中类的实例。 </p><br><p> 如果存在这样的对象，则该值已在前面进行了序列化。 在这种情况下，如果之前没有这样做，我们将为该对象分配一个序列号： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cached.index) { <span class="hljs-comment"><span class="hljs-comment">//     cached.index = ++this.index; let key = Object.keys(cached.ref)[0]; let old = cached.ref[key]; cached.ref[`@${name}|${cached.index}`] = old; delete cached.ref[key]; }</span></span></code> </pre> <br><p> 该代码看起来很混乱，可以通过为我们序列化的所有类分配一个数字来简化代码。 但是对于调试和感知结果，最好将数字仅分配给将来有链接的那些类。 </p><br><p> 分配编号后，我们根据算法返回链接： </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     return { [`@${name}`]: cached.index };</span></span></code> </pre> <br><p> 如果对象是第一次序列化的，我们将创建其缓存的实例： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cached = { <span class="hljs-attr"><span class="hljs-attr">ref</span></span>: { [<span class="hljs-string"><span class="hljs-string">`@</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">`</span></span>]: {} } }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache[val.__uuid] = cached;</code> </pre> <br><p> 然后序列化它： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> val.serialize === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//     res = val.serialize(); } else { //   res = this.serializeObjectInner(val); } cached.ref[Object.keys(cached.ref)[0]] = res;</span></span></code> </pre> <br><p> 该类将检查序列化接口的实现（将在后面讨论），以及<code>Object.keys(cached.ref)[0]</code>的构造。 事实是，cached.ref存储了指向包装对象<code>{ "@&lt;type&gt;[|&lt;index&gt;]": &lt;&gt; }</code> ，但是对象字段的名称对我们来说是未知的，因为 在此阶段，我们尚不知道名称是否包含对象编号（索引）。 该构造仅提取对象的第一个也是唯一的字段。 </p><br><p> 最后，序列化对象内部的实用方法： </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {Object} val  * @returns {Object}  */</span></span> serializeObjectInner(val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(val)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(isString(key) &amp;&amp; key.startsWith(<span class="hljs-string"><span class="hljs-string">'__'</span></span>))) { <span class="hljs-comment"><span class="hljs-comment">//  ,      res[key] = this.serialize(val[key]); } } return res; }</span></span></code> </pre> <br><p> 我们创建一个新对象，并将字段从旧对象复制到其中。 </p><br><h4 id="deserializationcontext"> 反序列化上下文 </h4><br><p> 反序列化过程以相反的顺序进行，不需要特殊注释。 </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="hljs powershell">/** *   */ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeserializationContext</span></span></span></span> { /** *  * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {Serializer} ser  */ constructor(ser) { this.__proto__.__proto__ = ser; this.cache = []; //    } /** *   json * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {any} val  json * @returns {any}  */ deserialize(val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Array.isArray(val)) { //  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.deserializeArray(val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isObject(val)) { //  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.deserializeObject(val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } } /** *   * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {Object} val  * @returns {Object}  */ deserializeArray(val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val.map(item =&gt; this.deserialize(item)); } /** *   * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {Array} val  * @returns {Array}  */ deserializeObject(val) { let res = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let key of Object.getOwnPropertyNames(val)) { let <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = val[<span class="hljs-type"><span class="hljs-type">key</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isString(key) &amp;&amp; key.startsWith(<span class="hljs-string"><span class="hljs-string">'@'</span></span>)) { //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isInteger(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) { //  res = this.cache[<span class="hljs-type"><span class="hljs-type">data</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { console.error(`     <span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>}`); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   let [<span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-type"><span class="hljs-type">id</span></span>] = key.substr(<span class="hljs-number"><span class="hljs-number">1</span></span>).split(<span class="hljs-string"><span class="hljs-string">'|'</span></span>); let ctor = this._nameToCtor[<span class="hljs-type"><span class="hljs-type">name</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctor) { //     res = new ctor(); //   ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id) this.cache[<span class="hljs-type"><span class="hljs-type">id</span></span>] = res; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typeof res.deserialize === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { //     res.deserialize(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let key of Object.getOwnPropertyNames(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) { res[<span class="hljs-type"><span class="hljs-type">key</span></span>] = this.deserialize(data[<span class="hljs-type"><span class="hljs-type">key</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //    console.error(`  <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$</span></span></span><span class="hljs-string">{name}"</span></span>  .`); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val[<span class="hljs-type"><span class="hljs-type">key</span></span>]; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   res[<span class="hljs-type"><span class="hljs-type">key</span></span>] = this.deserialize(val[<span class="hljs-type"><span class="hljs-type">key</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } }</code> </pre> </div></div><br><h3 id="dopolnitelnye-vozmozhnosti"> 附加功能 </h3><br><h4 id="interfeys-serializacii"> 序列化介面 </h4><br><p>  Javascript中没有接口支持，但是我们可以同意，如果该类实现了序列化和反序列化方法，则这些方法将分别用于序列化/反序列化。 </p><br><p> 另外，Javascript允许您为内置类型实现这些方法，例如，对于Date： </p><br><div class="spoiler">  <b class="spoiler_title">将日期序列化为ISO格式</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.prototype.serialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toISOString(); }; <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.prototype.deserialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(val); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setDate(date.getDate()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setTime(date.getTime()); };</code> </pre> </div></div><br><p> 最主要的是要记住注册日期类型： <code>serializer.register(Date);</code>  。 </p><br><p> 结果： </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"@Date"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-06-02T20:41:06.861Z"</span></span> }</code> </pre> <br><p> 唯一的限制：序列化的结果不应为整数，因为 在这种情况下，它将被解释为对该对象的引用。 </p><br><p> 同样，您可以将简单的类序列化为字符串。 将描述颜色的Color类序列化为<code>#rrggbb</code>行的示例在<a href="">github上</a> 。 </p><br><h4 id="ploskiy-serializator"> 平面序列化器 </h4><br><p> 亲爱的读者，尤其是对您来说，我写了<a href="">序列化</a>器的<a href="">第二个版本</a> ，它没有深度地递归遍历对象树，而是使用队列遍历对象的宽度。 </p><br><p> 为了进行比较，我将给出在两种情况下我们方案的前两个顶点的序列化示例。 </p><br><div class="spoiler">  <b class="spoiler_title">递归序列化器（深度序列化）</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5ec74f26-9515-4789-b852-12feeb258949"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"102c3dca-8e08-4389-bc7f-68862f2061ef"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Link"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"102c3dca-8e08-4389-bc7f-68862f2061ef"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command|1"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"447f6299-4bd4-48e4-b271-016a0d47fc0e"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } } } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ]</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">平面串行器（串行化范围）</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"1412603f-24c2-4513-836e-f2b0c0392483"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"b94ac7e5-d75f-44c1-960f-a02f52c994da"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Link"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"b94ac7e5-d75f-44c1-960f-a02f52c994da"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command|1"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"a93e452e-4276-4d6a-86a1-0681226d79f0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } } ]</code> </pre> </div></div><br><p> 就个人而言，我甚至比第一个更喜欢第二个选项，但应记住选择一个选项不能使用另一个选项。 都是关于链接的。 请注意，在平面串行器中，指向第二个顶点的链接位于其描述之前。 </p><br><h3 id="plyusy-i-minusy-serializatora"> 序列化程序的优缺点 </h3><br><p> 优点： </p><br><ul><li> 序列化器代码非常简单和紧凑（大约300行，其中一半是注释）。 </li><li> 序列化器易于使用，不需要第三方库。 </li><li> 内置了对序列化接口的支持，以实现对类的任意序列化。 </li><li> 结果令人愉悦，令人赏心悦目（IMHO）。 </li><li> 用其他语言开发类似的序列化器/反序列化器不是问题。 如果序列化的结果在背面处理，则可能需要这样做。 </li></ul><br><p> 缺点： </p><br><ul><li> 序列化程序需要注册可以序列化的类。 </li><li> 对对象的字段名有一些限制。 </li><li> 序列化器是用Java语言编写的noob，因此可能包含错误和错误。 </li><li> 大量数据的性能可能会受到影响。 </li></ul><br><p> 另外要注意的是，代码是用ES6编写的。 当然，可以转换为Javascript的早期版本，但是我没有检查结果代码与不同浏览器的兼容性。 </p><br><h3 id="drugie-moi-publikacii"> 我的其他出版物 </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用功能解释器在.NET上对项目进行本地化</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用基于模型的数据填充文本模板。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">.NET使用动态字节码（IL）函数的实现</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413113/">https://habr.com/ru/post/zh-CN413113/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413103/index.html">3CX v15.5 Update 5 Beta和REST与AmoCRM集成发布</a></li>
<li><a href="../zh-CN413105/index.html">物联网提供商的说明。 LoraWAN中的激活和安全性</a></li>
<li><a href="../zh-CN413107/index.html">Svelto.ECS项目Wiki的翻译。 适用于Unity3D的ECS框架</a></li>
<li><a href="../zh-CN413109/index.html">如何构建SaaS产品集成平台：Poster Cloud Checkout体验</a></li>
<li><a href="../zh-CN413111/index.html">STM32 + NetBeans =？</a></li>
<li><a href="../zh-CN413117/index.html">如何在bash中安全编程</a></li>
<li><a href="../zh-CN413119/index.html">上周第317天（2018年5月28日至6月3日）的前端世界摘要</a></li>
<li><a href="../zh-CN413121/index.html">莫斯科接班照片之旅</a></li>
<li><a href="../zh-CN413123/index.html">加入NoSQL数据库</a></li>
<li><a href="../zh-CN413125/index.html">基因疗法为肌肉萎缩的小患者提供了生存的机会</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>