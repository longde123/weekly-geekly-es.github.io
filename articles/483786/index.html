<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙏🏾 😂 ✒️ Clasificación híbrida 🕵🏼 🍳 ☁️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como todos saben, la ordenación puede basarse en intercambios, inserciones, selección, fusión y distribución. 

 Pero si se combinan diferentes método...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Clasificación híbrida</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/483786/"> <a href="https://habr.com/ru/company/edison/blog/483786/"><img width="694" height="321" src="https://habrastorage.org/webt/ql/cs/2p/qlcs2psim6ksv4hbrwrndioyifi.png"></a> <br><br>  Como todos saben, la ordenación puede basarse en intercambios, inserciones, selección, fusión y distribución. <br><br>  Pero si se combinan diferentes métodos en el algoritmo, entonces pertenece a la clase de clases híbridas. <a name="habracut"></a><habracut text=""></habracut><blockquote> <a href="https://www.edsd.ru/" title="Software EDISON - desarrollo web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Software EDISON - desarrollo web"></a> <br clear="right">  Este artículo fue escrito con el apoyo de EDISON. <br><br>  Nos dedicamos a la <a href="https://www.edsd.ru/ru/o_kompanii/novosti/dorabotka-i-soprovozhdenie-sajta-na-1s-bitriks">finalización y el mantenimiento de sitios en 1C-Bitrix</a> , así como al <a href="https://www.edsd.ru/ru/proekty/mobilnye_prilozhenija">desarrollo de aplicaciones móviles Android e iOS</a> . <br><br>  ¡Nos encanta la teoría de los algoritmos!  ;-) </blockquote>  Recordemos rápidamente qué algoritmos de clasificación de clases tienen y cuáles son las características de cada uno de ellos. <br><br><h4>  Clases de intercambio </h4><img align="right" width="350" height="132" src="https://habrastorage.org/webt/ay/2k/km/ay2kkmr3ipze-pdbcmxfjgdp-le.png"><br>  Los elementos de la matriz se comparan en pares entre sí y se realizan intercambios por pares desordenados. <br><br>  El representante más efectivo de esta clase es el legendario <b>tipo rápido</b> . <br><br><h4>  Clases de inserción </h4><img align="right" width="398" height="102" src="https://habrastorage.org/webt/tm/hd/35/tmhd35egnxxtisoa_zd8d_ucggi.png"><br>  Los elementos de la parte no ordenada de la matriz se insertan en sus lugares en el área ordenada. <br><br>  De esta clase, la <b>clasificación por inserciones simples se</b> usa con mayor frecuencia.  Aunque este algoritmo tiene una complejidad promedio de O ( <b>n <sup>2</sup></b> ), esta clasificación funciona muy rápidamente con arreglos casi ordenados; en ellos la complejidad llega a O ( <b>n</b> ).  Además, esta clasificación es una de las mejores opciones para procesar matrices pequeñas. <br><br>  <b>Ordenar usando el árbol de búsqueda binario</b> también pertenece a esta clase. <br><br><h4>  Ordenar por selección </h4><img align="right" width="300" height="100" src="https://habrastorage.org/webt/gp/bh/ho/gpbhhomuobutgbg6l-r9basjzlg.png"><br>  En el área desordenada, se selecciona el elemento mínimo / máximo, que se transfiere al final / principio de la parte no ordenada de la matriz. <br><br>  La clasificación con una elección simple funciona muy lentamente (en promedio O ( <b>n <sup>2</sup></b> )), pero en esta clase hay una <b>clasificación</b> difícil <b>por un montón</b> (también conocido como <b>clasificación piramidal</b> ), que tiene una complejidad temporal de O ( <b>n</b> log <b>n</b> ), y, lo cual es muy valioso, No hay casos degenerados de esta clasificación, independientemente de los datos entrantes.  Por cierto, esta clasificación tampoco tiene los mejores casos para los datos entrantes. <br><br><h4>  Combinar clasificaciones </h4><br>  Las áreas ordenadas se toman en la matriz y se fusionan, es decir, las subcadenas ordenadas más pequeñas se combinan en una subcadena ordenada más grande. <br><br><div style="text-align:center;"><img width="677" height="50" src="https://habrastorage.org/webt/qm/mh/vn/qmmhvnkmevjb34akg2dxjquef90.png"></div><br><br>  Si se ordenan dos submatrices, combinarlas es una operación fácil de implementar y rápida.  La otra cara de la moneda es que la fusión casi siempre requiere el costo de memoria adicional de O ( <b>n</b> ), aunque se conoce un número extremadamente pequeño de opciones de clasificación de fusión particularmente sofisticadas, donde el costo de la memoria es O (1). <br><br><h4>  Ordenar por distribución </h4><br>  Los elementos de la matriz se distribuyen y redistribuyen en clases hasta que la matriz acepta un estado ordenado. <br><br>  Los elementos se dispersan en grupos, ya sea en función de su valor (los llamados <b>ordenamientos de conteo</b> ) o en función del valor de los dígitos individuales (estos ya son <b>ordenamientos bit a bit</b> ). <br><br><div style="text-align:center;"><img width="657" height="219" src="https://habrastorage.org/webt/42/ch/6z/42ch6zg2eg2zfkqbmgxmte9arii.png"></div><br><br>  <b>La clasificación de cubos</b> también pertenece a esta clase. <br><br>  Una característica de la clasificación por distribución es que no utilizan comparaciones por pares de elementos entre ellos, o que tales comparaciones están presentes en pequeña medida.  Por lo tanto, la ordenación por distribución suele adelantarse a la velocidad, por ejemplo, la ordenación rápida.  Por otro lado, la ordenación por distribución a menudo requiere mucha memoria adicional, ya que los grupos de elementos redistribuidos constantemente deben almacenarse en algún lugar. <br><br><hr><hr><hr><hr><hr><br>  Las disputas sobre qué clasificación es <i>la mejor</i> son muy frecuentes, pero el hecho es que no existe y no puede ser un algoritmo ideal para todas las ocasiones.  Por ejemplo, la ordenación rápida es realmente muy rápida (pero no la más rápida) en la mayoría de las situaciones, pero también se encuentra con casos degenerados en los que se produce un bloqueo.  La ordenación por inserciones simples es lenta, pero para las matrices casi ordenadas evitará fácilmente otros algoritmos.  La ordenación del montón funciona bastante rápido con cualquier dato entrante, pero no tan rápido como otras clasificaciones bajo ciertas condiciones y no hay forma de acelerar la pirámide.  La ordenación por fusión es más lenta que la ordenación rápida, sin embargo, si hay subarreglos ordenados en la matriz, entonces es más rápido fusionarlos que por ordenación rápida.  Si la matriz tiene muchos elementos repetidos o si ordenamos las filas, lo más probable es que la mejor opción sea ordenar por distribución.  Cada método es especialmente bueno en su situación más favorable. <br><br>  Sin embargo, los programadores continúan inventando las clasificaciones más rápidas del mundo, sintetizando los métodos más efectivos de diferentes clases.  Veamos qué tan exitoso es para ellos. <br><br>  Dado que en el artículo se mencionan muchos algoritmos no triviales, solo cubro brevemente los principios básicos de su trabajo, sin sobrecargar el artículo con animaciones y explicaciones detalladas.  En el futuro habrá artículos separados, donde habrá dibujos animados para cada algoritmo y matices sutiles detallados. <br><br><hr><hr><hr><hr><hr><br><h2>  Insertar + Fusionar </h2><br>  Una conclusión puramente empírica es que la fusión y / o inserción se usan con mayor frecuencia en híbridos.  En la mayoría de las clasificaciones, se encuentra uno u otro método, o ambos juntos.  Y hay una explicación lógica para esto. <br><br>  Los inventores de clasificación a menudo se esfuerzan por crear algoritmos paralelos que ordenan simultáneamente diferentes partes de una matriz.  La mejor manera de lidiar con varias submatrices ordenadas es fusionarlas; esta será la más rápida. <br><br>  Los algoritmos modernos a menudo usan recursividad.  Durante un descenso recursivo, la matriz generalmente se divide en dos partes; en el nivel más bajo, se ordena la matriz.  Al regresar a niveles más altos de recursión, surge la cuestión de combinar submatrices ordenadas en niveles más bajos. <br><br>  En cuanto a los insertos, en los algoritmos híbridos en ciertas etapas a menudo se obtienen subarreglos aproximadamente ordenados, que se llevan mejor al pedido final con la ayuda de insertos. <br><br>  Este grupo contiene tipos híbridos, en los que hay una fusión e inserción, y estos métodos se usan de manera muy diferente. <br><br><h3>  Ordenar por inserción de fusión <br>  Algoritmo de Ford Johnson :: Algoritmo de Ford-Johnson </h3><br><h4>  <i>Fusionar + Insertar</i> </h4><img align="right" width="200" height="285" src="https://habrastorage.org/webt/pr/io/c-/prioc-ed14huk3as3gadpjccxks.jpeg"><br clear="left">  Una forma muy antigua, ya en 1959.  Se describe en detalle en el trabajo inmortal de Donald Knuth, "El arte de la programación", Volumen 3, "Clasificación y búsqueda", Capítulo 5, "Clasificación", Sección 5.3, "Clasificación óptima", subsección, "Clasificación con un número mínimo de comparaciones" y parte "Clasificación por inserciones y fusión". . <br><br>  La clasificación ahora no tiene ningún valor práctico, pero es interesante para aquellos que aman la teoría de los algoritmos.  Se considera el problema de encontrar una manera de ordenar <b>n</b> elementos con el menor número de comparaciones.  Se propone una modificación heurística no trivial para la clasificación de inserción (una inserción de este tipo que no encontrará en ningún otro lugar) utilizando <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B0_%25D0%25AF%25D0%25BA%25D0%25BE%25D0%25B1%25D1%2581%25D1%2582%25D0%25B0%25D0%25BB%25D1%258F">números de Jacobstal</a> para minimizar el número de comparaciones.  Hasta la fecha, también se sabe que esta no es la mejor opción y que puede esquivar aún más hábilmente y obtener incluso menos comparaciones.  En general, la clasificación académica estándar no es de uso práctico, pero para los conocedores del género es un placer desmontar tales trucos con un sesgo algebraico. <br><br><h3>  Tim Sort :: Timsort </h3><br><h4>  <i>Insertar + Fusionar</i> </h4><img align="right" width="530" height="192" src="https://habrastorage.org/webt/cu/mf/fu/cumfful_rsg9ipz1yryimfpldxi.jpeg"><br clear="left">  <i>Publicado por Tim Peters hace 15 años y ahora</i> <br><br>  Esta clasificación en Habré se recuerda muy a menudo. <br>  Tesis: en una matriz, se buscan subarreglos pequeños casi ordenados para los que se utiliza la clasificación de inserción.  Estas submatrices se fusionan usando merge. <br><br>  La fusión en TimSort es la parte más interesante: la fusión ascendente clásica se optimiza aún más para diferentes situaciones.  Por ejemplo, se sabe que la fusión es más eficiente si las submatrices unidas tienen aproximadamente el mismo tamaño.  En TimSort, si los tamaños son muy diferentes, luego de acciones adicionales hay un ajuste (podemos decir que parte de los elementos "fluirán" del subconjunto más grande a uno más pequeño, después de lo cual la fusión continuará en el modo estándar).  También se proporcionan varias situaciones insidiosas, por ejemplo, si en un subconjunto todos los elementos serán menores que en otro.  En este caso, la comparación de elementos de ambas submatrices estará inactiva.  El procedimiento de fusión modificado "notará" un desarrollo indeseable de eventos en el tiempo, y si está "convencido" de una opción pesimista mediante la búsqueda binaria, cambiará a una opción de procesamiento más óptima. <br><br>  En promedio, esta clasificación funciona un poco más lento que QuickSort, sin embargo, si la matriz entrante contiene un número suficiente de subsecuencias ordenadas de elementos, entonces la velocidad aumenta significativamente y aquí TimSort se adelanta al resto. <br><br><h3>  Clasificación de fusión de bloques :: Clasificación de fusión de bloques <br>  Wiki-sort :: Wiki-sort <br>  Holy Grail Sort :: Grailsort </h3><br><h4>  <i>Insertos + Fusionar + Cubos</i> </h4><img align="right" width="343" height="240" src="https://habrastorage.org/webt/bz/ev/g6/bzevg6rsbv563fjqzz-hsqpfeso.gif"><br clear="left">  <i>Animación de clasificación de fusión de bloques de Wikipedia.</i> <br><br>  Este es un algoritmo muy nuevo (2008) y al mismo tiempo muy prometedor.  El hecho es que el problema relativamente importante de la fusión es el costo de la memoria adicional.  Por lo general, donde existe la fusión, también hay complejidad de memoria O ( <b>n</b> ). <br><br>  Pero WikiSort está diseñado para que la fusión ocurra sin el uso de memoria adicional, entre los tipos de fusión, en este sentido, esta es una instancia muy rara.  Además, el algoritmo es estable.  Bueno, si la clasificación de fusión convencional tiene la mejor velocidad algorítmica O ( <b>n</b> log <b>n</b> ), entonces en la clasificación wiki este indicador es O ( <b>n</b> ).  Hasta hace poco, se creía que fusionar la clasificación con ese conjunto de características era imposible en principio, pero los programadores chinos sorprendieron a todos. <br><br>  El algoritmo es muy complicado de explicar en un par de oraciones.  Pero algún día escribiré un habrast separado sobre él. <br><br>  Inicialmente, el algoritmo se llamaba sin nombre Block Merge Sort, sin embargo, con la mano ligera de Tim Peters, que estudió la clasificación en detalle (para determinar si algunas de sus ideas deberían transferirse a TimSort), el nombre WikiSort se adhirió a él. <br><br>  El habruiser prematuro que partió <a href="https://habr.com/ru/users/mrrl/" class="user_link">Mrrl</a> trabajó independientemente durante varios años en la clasificación de fusión, que sería simultáneamente rápido con cualquier dato entrante, económico en memoria y estable.  <a href="https://habr.com/ru/post/205290/">Sus búsquedas creativas fueron exitosas</a> y más tarde llamó al algoritmo desarrollado una clasificación del Santo Grial (ya que satisface todos los altos requisitos de "clasificación perfecta").  La mayoría de las ideas de este algoritmo son similares a las implementadas en WikiSort, aunque estos tipos no son idénticos y se desarrollan independientemente uno del otro. <br><br><h3>  Clasificación de tabla hash :: Clasificación de tabla hash </h3><br><h4>  <i>Distribución + Insertar + Fusionar</i> </h4><br>  La matriz se divide recursivamente por la mitad, hasta que el número de elementos en las submatrices resultantes alcanza un cierto valor umbral.  En el nivel más bajo de recursión, se produce una distribución aproximada (usando una tabla hash) y la submatriz se ordena por inserciones.  Luego hay un retorno recursivo a niveles más altos, las mitades ordenadas se combinan mediante la fusión. <br><br>  <a href="https://habr.com/ru/post/478654/">Hablé un</a> poco más sobre este algoritmo hace un <a href="https://habr.com/ru/post/478654/">mes</a> . <br><br><hr><hr><hr><hr><hr><br><h2>  Ordenación rápida como primaria </h2><br>  Después de fusionarse e insertarse, el tercer lugar en el desfile de éxito híbrido está firmemente en manos de la clasificación rápida favorita de todos. <br><br>  Este es un algoritmo muy eficiente, pero también hay casos degenerados.  Algunos inventores están tratando de hacer que QuickSort sea completamente invulnerable a cualquier dato entrante incorrecto y sugieren complementarlo con ideas fuertes de otros tipos. <br><br><h3>  Clasificación introspectiva :: Introsort, Clasificación introspectiva, std :: sort </h3><br><h4>  <i>Rápido + montón + insertos</i> </h4><img align="right" width="395" height="470" src="https://habrastorage.org/webt/kq/om/vq/kqomvqs3ugrvl1xdnrw0vm54jnu.png"><br clear="left">  La ordenación en montón funciona de manera algo más lenta que la ordenación rápida, pero al mismo tiempo, a diferencia de QuickSort, no tiene casos degenerados: la complejidad del tiempo algorítmico promedio, mejor y peor es O ( <b>n</b> log <b>n</b> ). <br><br>  Por lo tanto, David Musser propuso estar a salvo durante la clasificación rápida: si hay demasiado anidamiento, esto se considera un ataque al sistema, que deslizó una matriz "mala".  Se produce el cambio a la clasificación por un montón, que no es megabyte, pero tampoco es lento para hacer frente <nobr><i>a</i></nobr> los datos entrantes. <br><br>  C ++ tiene un algoritmo llamado std :: sort, que es una implementación de ordenación introspectiva.  Una pequeña adición: si en el siguiente nivel de recursión el <nobr>número de elementos de la submatriz es ≤ 16</nobr> , entonces la clasificación de inserción se aplica a la submatriz. <br><br><h3>  Multikey sort :: Multikey sort <br>  Bitwise Quick Sort :: Clasificación rápida de Radix </h3><br><h4>  <i>Rápido + rangos</i> </h4><br>  Ordenación rápida, solo los valores de los elementos de la matriz se comparan entre sí, pero sus dígitos individuales (primero, organizamos los dígitos más altos de esta manera, nos movemos de los más pequeños a ellos). <br><br>  O más o menos: esta es una ordenación de bits por orden superior, la ordenación dentro del siguiente bit se lleva a cabo de acuerdo con el algoritmo de ordenación rápida. <br><br><h3>  Scatter Sort :: Spreadsort </h3><br><h4>  <i>Rápido + fusión + cubos + descargas</i> </h4><br>  Gestalt de quicksort, merge sort, bucket sort y bitwise sort. <br><br>  En pocas palabras, no lo explique.  Analizaremos este algoritmo en detalle en uno de los siguientes artículos. <br><br><hr><hr><hr><hr><hr><br><h2>  Otros híbridos </h2><br><h3>  Tipo de conteo de árboles </h3><br><h4>  <i>Contando + árbol</i> </h4><br>  El algoritmo <a href="https://habr.com/ru/post/418355/">propuesto por el</a> usuario <a href="https://habr.com/ru/users/alexanderusatov/" class="user_link">AlexanderUsatov</a> .  Contando el orden, el número de claves contadas se almacena en un árbol equilibrado. <br><br><h3>  J-sort :: J-sort </h3><br><h4>  <i>Montón + insertos</i> </h4><br>  <a href="https://habr.com/ru/post/221095/">Ya escribí</a> sobre esta clasificación hace <a href="https://habr.com/ru/post/221095/">5 años</a> .  Todo es bastante simple: primero en la matriz, necesita construir una pila no creciente una vez, y luego hacer exactamente lo contrario: construir una vez no decreciente.  Como resultado de la primera operación, el mínimo estará en el primer lugar de la matriz, y los elementos pequeños en su conjunto se moverán significativamente al principio.  En el segundo caso, el máximo estará en el último lugar y los elementos grandes migrarán hacia el final de la matriz.  En general, obtenemos una matriz casi ordenada con la que hacemos qué.  Así es, ordena los insertos. <br><br><div style="text-align:center;"><img width="646" height="304" src="https://habrastorage.org/webt/uv/ed/ud/uvedudkaitwonk4bfuy2alkkvwk.gif"></div><br><br><hr><hr><hr><hr><hr><br><h2>  Referencias </h2><br><img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png">  <a href="https://en.wikipedia.org/wiki/Merge-insertion_sort">Inserción</a> <a href="https://en.wikipedia.org/wiki/Block_sort">de fusión</a> , <a href="https://en.wikipedia.org/wiki/Block_sort">fusión de bloque</a> , <a href="https://en.wikipedia.org/wiki/Timsort">Tim</a> , <a href="https://en.wikipedia.org/wiki/Introsort">introspectivo</a> , <a href="https://en.wikipedia.org/wiki/Spreadsort">propagación</a> , <a href="https://en.wikipedia.org/wiki/Multi-key_quicksort">multiciclo</a> <br><br><img width="30" height="30" src="https://habrastorage.org/webt/fn/cd/py/fncdpynfktllvkdjtmpif0kd1zc.png">  <a href="https://github.com/Mrrl/GrailSort">Grial</a> <br><br><img width="30" height="30" src="https://habrastorage.org/webt/jw/w-/qu/jww-queszzqnwmoa2hm-kfwu-9o.png">  <a href="https://habr.com/ru/post/205290/">Grial</a> , <a href="https://habr.com/ru/post/203032/">Hash Table</a> , <a href="https://habr.com/ru/post/418355/">Count / Tree</a> , <a href="https://habr.com/ru/post/221095/">J</a> <br><br><h3>  Artículos de la serie: </h3><br><ul><li>  <a href="https://habr.com/post/414447/">Aplicación Excel AlgoLab.xlsm</a> </li><li>  <a href="https://habr.com/post/414653/">Clases de intercambio</a> </li><li>  <a href="https://habr.com/post/415935/">Clases de inserción</a> </li><li>  <a href="https://habr.com/post/422085/">Ordenar por selección</a> </li><li>  <a href="https://habr.com/ru/post/431964/">Combinar clasificaciones</a> </li><li>  <a href="https://habr.com/ru/post/472466/">Ordenar por distribución</a> </li><li>  <strong>Clasificación híbrida</strong> <br><ul><li>  Insertar orden de fusión </li><li>  Tim Sort </li><li>  Ordenar Wiki </li><li>  Orden de dispersión </li></ul><br></li></ul>  De todas las clasificaciones que se presentan aquí, en la aplicación Excel de AlgoLab solo se implementa actualmente la animación Jsort. </div></div><p>Source: <a href="https://habr.com/ru/post/483786/">https://habr.com/ru/post/483786/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../483774/index.html">El resumen de eventos para profesionales de recursos humanos en TI para enero de 2020</a></li>
<li><a href="../483776/index.html">Introducción al método diferencial semántico en 5 minutos.</a></li>
<li><a href="../483778/index.html">Semana de la seguridad 03: Principios responsables del informe de errores</a></li>
<li><a href="../483780/index.html">¿Qué es la holgura y cómo funciona?</a></li>
<li><a href="../483784/index.html">Cómo hacer una aplicación multiinquilino a partir de una aplicación no inquilina</a></li>
<li><a href="../483788/index.html">La pequeña nación isleña gana gracias a Twitch</a></li>
<li><a href="../483790/index.html">Notas del proveedor de IoT. Tecnología y economía LoRaWAN en alumbrado urbano</a></li>
<li><a href="../483794/index.html">Dejando ir: por qué no deberías tomar kontroffer</a></li>
<li><a href="../483796/index.html">Parámetros opcionales en repositorios de datos de Spring</a></li>
<li><a href="../483798/index.html">Cómo automatizar la redacción de anuncios en Google Ads</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>