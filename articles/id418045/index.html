<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕳️ 🙅🏽 👨‍🏭 Menggunakan fungsi JavaScript untuk membuat model 3D 🖐🏿 🌝 🍊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini membahas penggunaan perpustakaan geometri fungsi WebGeometry untuk membangun model polyhedra kompleks. Perpustakaan ditulis dalam Javascri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan fungsi JavaScript untuk membuat model 3D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418045/">  Artikel ini membahas penggunaan perpustakaan geometri fungsi WebGeometry untuk membangun model polyhedra kompleks.  Perpustakaan ditulis dalam Javascript.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan ke GitHub</a> dengan contoh yang memberikan contoh sederhana menggunakan perpustakaan.  Komentar dan kritik dipersilahkan. <br><br><img src="https://habrastorage.org/webt/u8/6o/95/u86o95ibyus3rjrq5haqqqfipku.png"><br><br>  Pustaka ThreeJS digunakan untuk menampilkan model yang dihitung sebelumnya menggunakan fungsi dari pustaka WebGeometry.  Kanvas HTML5 digunakan untuk menampilkan elemen model flat individual dan menampilkan informasi pendukung. <br><a name="habracut"></a><br>  Teknologi dan perpustakaan WebGL yang dibuat atas dasar, seperti ThreeJS dan BadylonJS, digunakan di Internet untuk mengimplementasikan berbagai tujuan yang berkaitan dengan grafik 3D.  Tetapi pada dasarnya mereka digunakan untuk menampilkan model tiga dimensi siap pakai di browser (yang sebelumnya dibuat, misalnya, dalam <em>3ds Max</em> atau program <em>Blender</em> ).  Jika kita dihadapkan dengan tugas membuat model parametrik, yaitu model yang, dalam proses menampilkan objek jadi di browser, kita dapat mengubah elemen individu dengan menetapkan parameter model yang sesuai (misalnya, meningkatkan sudut wajah tertentu), kita harus memiliki satu set fungsi geometris yang akan memungkinkan Anda untuk membuat model sehingga di masa depan ada kemungkinan memvariasikan secara interaktif bentuk elemen individu dari model atau keseluruhan model.  Untuk mengatasi masalah ini, kita memerlukan satu set fungsi dalam bahasa Javascript yang akan mengimplementasikan metode yang digunakan dalam geometri analitik.  Perpustakaan harus memiliki fungsi untuk membuat garis, bidang dan lingkaran, menemukan titik (atau garis) dari persimpangan mereka, membuat bidang miring, dan banyak lagi.  Pustaka ThreeJS dan BadylonJS memiliki beberapa fitur ini, tetapi jumlah tindakan yang dilakukan dengannya tidak akan memungkinkan Anda untuk menyelesaikan semua tugas yang muncul saat membangun model parametrik.  Ada beberapa perpustakaan Javascript yang lebih murni matematika.  Dari jumlah tersebut, <em>glMatrix</em> dan <em>Sylvester</em> paling banyak digunakan.  Pustaka <em>glMatrix</em> terutama ditujukan untuk bekerja dengan vektor, matriks, dan angka empat, tetapi tidak ada fungsi untuk bekerja dengan garis dan bidang di dalamnya.  Perpustakaan <em>Sylvester</em> memiliki fungsi-fungsi ini, tetapi mereka hadir dalam jumlah yang agak terbatas.  Namun, ada beberapa buku yang menggambarkan implementasi metode geometri analitik dalam C / C ++.  Program C / C ++ yang sesuai dapat digunakan sebagai prototipe untuk membuat perpustakaan matematika dalam Javascript.  Oleh karena itu, ketika saya memutuskan untuk membuat model parametrik tiga dimensi potongan berlian untuk menampilkannya di browser, perpustakaan ThreeJS dipilih oleh saya hanya untuk menampilkan model yang sudah dihitung - itu tidak digunakan untuk menghitung bentuk model.  Untuk perhitungan formulir itu sendiri, perpustakaan WebGeometry dibuat.  Pustaka ini didasarkan pada fungsi geometrik yang sebelumnya digunakan dalam C / C ++, yang saya terjemahkan ke dalam bahasa Javascript.  Mari kita perhatikan tahapan membangun model piramida (pemotongan berlian tipe Piramida). <br><br>  Pada <b>tahap pertama,</b> kita perlu menggambar tampilan yang diinginkan dari model dan kemudian nomor simpulnya.  Gambar di bawah ini menunjukkan penomoran simpul dan nama elemen potong yang termasuk dalam model potongan piramida. <br><br><img src="https://habrastorage.org/webt/di/_x/vn/di_xvn89nuebeswhpcqh5qmar3a.png"><br><br>  Setelah itu, diperlukan untuk membentuk wajah dari simpul bernomor.  Misalnya, untuk wajah situs dan wajah mahkota, tulis urutan simpul berikut (simpul pertama yang diduplikasi memberi sinyal bahwa wajah telah berakhir): <br><br><pre><code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  0 -  0, 4, 7, 3, 0, //  1 -  1, 5, 4, 0, 1, //  2 -  2, 6, 5, 1, 2, //  3 -  3, 7, 6, 2, 3, //  4 - </span></span></code> </pre> <br>  Wajah harus berlawanan arah jarum jam.  File pyramid_index.js berisi kode sumber untuk melintasi semua wajah piramida dan komentar terperinci.  Hasil perayapan ditulis ke array index_cut. <br><br>  Pada <b>tahap kedua,</b> kita bisa mewarnai wajah model.  Langkah ini opsional jika kita tidak membutuhkan pewarnaan.  Misalkan kita ingin mewarnai model piramida sebagai berikut: <br><br><img src="https://habrastorage.org/webt/o8/h4/zz/o8h4zzu7_zxqbmjnrxqfuvobru4.png"><br><br>  Untuk tujuan ini, file pyramid_colors.js dibuat di mana fungsi facet_colors () berada, yang menulis warna semua wajah ke array warna. <br><br>  Pada <b>tahap ketiga</b> , setelah semua simpul diberi nomor dan urutan traversal dari semua simpul dari wajah dicatat, perlu untuk mengatur parameter model dan kemudian menghitung koordinat semua simpulnya.  Tentu saja, diasumsikan bahwa kita telah menguraikan algoritma konstruksi untuk diri kita sendiri dan menemukan bagaimana semua wajah model akan ditempatkan di ruang angkasa.  Untuk piramida, kita akan memilih parameter berikut, yang akan menentukan ukuran dari masing-masing bagiannya, dan keseluruhan model secara keseluruhan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DEGREE = <span class="hljs-number"><span class="hljs-number">0.01745329251994</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      var lw = 1.2; //  /  var r = 0.06; //     var angleA = 50*DEGREE; //    A  var angleB = 60*DEGREE; //    B  var hCrown = 0.3; //   var anglePav = 60*DEGREE; //    A </span></span></code> </pre><br>  Pilihan parameter ditentukan oleh pengembang model.  Misalnya, alih-alih mengatur dua parameter untuk dua sudut kemiringan mahkota, Anda dapat menentukan parameter tunggal untuk dua sudut sekaligus - maka sudut ini akan selalu sama.  Anda dapat memasukkan parameter yang menentukan ukuran situs.  Dalam hal ini, diperlukan untuk tidak mengatur tinggi mahkota, atau untuk tidak mengatur kemiringan wajahnya.  Pilihan lain untuk memilih parameter adalah membuat beberapa parameter dapat dihitung.  Dalam hal ini, ketika mengubah beberapa parameter, beberapa lainnya mungkin mengubah nilai awal mereka.  Sebagai contoh, jika kita mengasumsikan bahwa untuk piramida kita telah menentukan satu parameter untuk mengatur sudut kemiringan permukaan koronal, parameter lain untuk ketinggian mahkota dan parameter lain yang akan mengatur ukuran area, maka ketika mengubah sudut wajah kita akan dipaksa untuk mengubah ukuran area atau tinggi mahkota.  Di sisi lain, jika Anda mengubah parameter yang menetapkan ukuran pad, maka nilai parameter yang menetapkan tinggi atau kemiringan permukaan koronal akan secara otomatis berubah.  Opsi yang terkait dengan penerapan parameter yang dihitung dalam program ini, serta dalam konstruksi model potongan lain yang disajikan di situs, tidak digunakan. <br><br>  Pada <b>tahap keempat</b> , koordinat simpul dari model dihitung.  Data awal untuk perhitungan adalah nilai-nilai parameter model dan bagaimana kita membayangkan penampilannya.  File pyramid_verts.js berisi teks sumber (dengan komentar terperinci) dari fungsi perhitungan vertex model, yang disebut VerticesCalculation.  Dengan perhitungan ini bahwa fungsi perpustakaan WebGeometry digunakan dalam fungsi ini.  Hasil penghitungan koordinat titik dimasukkan dalam array titik.  Perhatikan bahwa dalam program untuk menemukan koordinat simpul, urutan angka yang terpisah digunakan untuk simpul yang membentuk korona (empat simpul), simpul yang membentuk korset (empat simpul) dan simpul yang membentuk paviliun (dalam model piramida, hanya simpul yang termasuk dalam paviliun).  Pilihan penomoran verteks tambahan ini digunakan untuk orientasi yang lebih mudah oleh programmer di antara simpul yang terpotong, karena jumlah simpul sangat sering melebihi 100. <br><br>  Pada <b>tahap kelima,</b> setelah perhitungan koordinat simpul selesai, diperlukan untuk pemrograman membangun polyhedron (polyhedron) dari model.  Data awal untuk konstruksinya adalah susunan index_cut, warna, dan simpul yang sebelumnya dibuat.  Model polyhedron dapat direpresentasikan secara sederhana sebagai satu set wajah yang mengikat polyhedron di ruang angkasa.  Fungsi CreatePolyhedron ada di file polyhedron.js.  Sebagai hasil dari pekerjaan fungsi ini, array poligon (poligon) dibuat yang terdiri dari model tiga dimensi.  Setiap poligon dijelaskan oleh fungsi berikut (pada kenyataannya, ini adalah fungsi konstruktor yang dipanggil oleh operator baru saat membuat poligon baru): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Polygon</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.IndexFacet = []; <span class="hljs-comment"><span class="hljs-comment">//      //    this.IndexFacet_1 = []; //      //    this.VertexFacet; // ,    //    this.EdgeFacet = []; // ,  , //    (    //  ) this.IndexTriangle = []; // ,    // ,     this.VertexTriangle = []; // ,    //   ,     this.Faces = []; //      }</span></span></code> </pre><br>  Karena WebGL dan pustaka ThreeJS dibuat berdasarkan kerjanya dengan primitif triangular, ia di-triangulasi untuk setiap sisi model.  Diasumsikan bahwa semua wajah model adalah poligon cembung.  Pada akhirnya, fungsi CreatePolyhedron mengambil semua langkah yang diperlukan untuk membuat struktur data yang sepenuhnya menggambarkan semua wajah polyhedron sedemikian rupa sehingga mereka dapat diteruskan ke fungsi perpustakaan ThreeJS untuk menampilkan model di layar. <br><br>  Pada <b>tahap keenam</b> , model ditampilkan di layar menggunakan fungsi ThreeJS.  Secara standar, adegan, renderer, dan kamera dibuat.  Untuk memeriksa model potongan dari semua sisi, program Piramida menggunakan elemen orbitControls.  Saat membuat model potongan lain, untuk memeriksa potongan dari semua sisi, saya tidak menggunakan orbitControls, tetapi memperkenalkan kemampuan untuk memutar model itu sendiri.  Kemudian kami membuat model jerat.  Anda dapat melakukan dua hal. <br><br>  Dalam metode pertama, kami mempertimbangkan model potongan sebagai satu set jerat wajah yang terpisah.  Dalam hal ini, setiap wajah adalah objek 3D yang terpisah.  Dengan representasi model ini, proses pemilihan wajah individu menggunakan elemen Three.JS, yang memiliki nama raycaster, cukup sederhana.  Juga, metode ini dapat dilengkapi dengan pembuatan jerat segmen yang membatasi setiap wajah. <br><br>  Dengan cara kedua, kami menganggap model potongan sebagai objek tunggal, diwakili oleh hanya satu jala yang segera mencakup semua wajah model.  Metode ini nyaman digunakan saat menampilkan model menggunakan shader.  Metode ini tidak digunakan dalam model potongan Pyramid, tetapi digunakan untuk membuat Octagon, Brilliant, dan model potongan lainnya yang dapat dilihat di situs web saya. <br><br>  Pada <b>tahap ketujuh</b> , tombol dan fungsi yang melekat padanya dibuat yang memungkinkan Anda untuk mengubah nilai parameter yang menentukan bentuk dan ukuran model.  Ketika tombol ditekan, fungsi dipanggil yang menambah atau mengurangi nilai parameter yang sesuai.  Ini berarti bahwa Anda perlu menghitung ulang koordinat dari simpul model.  Setelah penghitungan ulang, kebenaran dari model yang baru dibangun diperiksa.  Misalnya, ditentukan apakah beberapa nilai di luar toleransi.  Dalam hal model potongan intan, ini biasanya dilakukan untuk memeriksa apakah potongan cembung tetap setelah pembangunan kembali.  Memeriksa tonjolan adalah sebagai berikut.  Melalui masing-masing wajah pesawat ditarik di mana wajah ini terletak, dan kemudian posisi setiap simpul model relatif terhadap pesawat ini ditentukan.  Semua simpul harus terletak di sisi yang sama dari bidang ini.  Jika model dianggap salah, maka parameter dikembalikan ke nilai aslinya dan model dibangun kembali.  Untuk model potongan yang memiliki korset non-cembung (hanya elemen dari beberapa potongan ini, seperti Jantung, mungkin bukan cembung), cembung diperiksa secara terpisah untuk mahkota dan secara terpisah untuk paviliun.  Namun, rundist dikeluarkan dari cek.  Untuk model sederhana, Anda dapat membatasi diri pada pemeriksaan parameter sederhana.  Sebagai contoh, jika kita membangun model rumah, maka atapnya tidak boleh lebih dari ketinggian tertentu di muka.  Oleh karena itu, cukup dengan mengatur batasan parameter ini dalam besarnya, kami memperoleh hasil yang diinginkan.  Setelah tombol parameter ditambahkan, sangat diinginkan untuk secara visual menampilkan nilai setiap parameter ketika ia berubah setelah mengklik tombol.  Untuk melakukan ini, kanvas dua dimensi HTML5 dibuat dan di sebelah tombol terkait nilai parameter ditampilkan di atasnya. <br><br>  Dengan demikian, kami memeriksa semua tahap membangun model menggunakan contoh Piramida.  Untuk piramida (dan juga untuk semua model lain di situs), saya membuat program lain Pyramid_text.html.  Contoh program ini menunjukkan bagaimana Anda dapat menampilkan teks tiga dimensi untuk penomoran simpul suatu model.  Jika seseorang ingin tahu bagaimana model rumit dibangun, maka Anda harus mempertimbangkan membangun model <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(lihat GitHub)</a> dalam urutan berikut: <br>  <b>Octagon</b> .  Model yang menunjukkan penciptaan pesawat dengan berbagai cara dan bekerja dengan pesawat ini.  Saat membuat model, metode yang digunakan saat bekerja dengan vektor dan garis dalam ruang juga digunakan. <br><br>  <b>Cemerlang</b> .  Ini adalah potongan berlian klasik dan paling umum.  Beberapa elemen membangun model tiga dimensi dari potongan ini digunakan di masa depan ketika membuat aspek MoonMarquise, MoonPear dan Heart.  Bagaimana korset potongan ini, yang memiliki bentuk superellipse, dihitung, ditampilkan secara terpisah di program BrilliantGirdlt.html.  Dalam program ini, garis korset dibangun di atas kanvas dua dimensi (kanvas). <br><br>  <b>MoonMarquise</b> .  Potongan marquise, seperti Brilliant, adalah salah satu potongan berlian klasik.  Tidak seperti sisi sederhana dari tipe ini (Marquise), yang disebut "aspek bulan" ditambahkan ke sisi MoonMarquise Pavilion.  Pemotong MoonMarquise dibentuk oleh dua busur elips.  Konstruksi rinci korset ini di atas kanvas ditampilkan dalam program MarquiseGirdle.html.  Teks program ini memiliki komentar terperinci tentang konstruksi.  Kami mencatat satu titik mengenai perhitungan garis korset - ia menggunakan properti garis singgung ke elips.  Misalnya, dianggap dalam buku "Kursus Geometri Analitik" (penulis buku ini adalah N.I. Muskhelishvili). <br>  <b>MoonPear</b>  Kerapu potong MoonPear dibentuk oleh busur tiga elips.  Pembangunannya didasarkan pada konstruksi korset potongan Marquise, tetapi lebih kompleks.  Untuk melihat garis korset Marquise dan cara membagi gundist menjadi segmen, jalankan program PearGirdle.html. <br><br>  <b>Hati</b>  Potongan "hati" adalah salah satu potongan klasik, tetapi memiliki, berbeda dengan sebagian besar jenis potongan, bentuk korset non-cembung.  Rudist potongan jantung terdiri dari dua girdle cut Pear yang dimiringkan satu sama lain.  Di kanvas, Anda dapat melihat garis korset dengan menjalankan program HeartGirdle.html.  Membangun luka Jantung cukup sulit. <br><br>  <b>Maltese Cross</b> .  Pemotong potongan "Maltese Cross" dibuat dalam bentuk "bantal" (bantal).  Stek dengan korset seperti itu baru-baru ini menyebar luas.  Garis korset ini terdiri dari delapan lingkaran konjugasi lingkaran - empat busur utama yang membatasi bantal di empat sisi dan empat busur berukuran lebih kecil yang berpasangan dengan busur utama bantal di sudut-sudut korset.  Dengan menjalankan program CushionGirdle_1.html dan CushionGirdle_2.html, Anda dapat melihat bentuk garis korset, hasil kerja dari semua parameter yang menentukan bentuknya dan pembagian korset ke dalam segmen. <br><br>  <b>Bintang Pentagonal</b> .  Pemotong bintang pentagonal dibentuk oleh garis bertuliskan nama epitrochoid.  Epitrochoid adalah kurva yang berhubungan dengan sikloid.  Dalam program Wavy_Pentagon_Girdle.html, dengan mengubah nilai-nilai parameter, Anda dapat mengubah "undulasi" korset dan bahkan mengubah pentagon menjadi poligon dengan jumlah tonjolan yang berbeda ("kelopak").  Namun, harus diingat bahwa model potongan ini sendiri dibangun untuk nilai parameter "Jumlah kelopak" sama dengan 5. <br><br>  Seperti yang disebutkan sebelumnya, untuk semua model di atas, program dibuat menampilkan jumlah simpul potong.  Dalam program ini, saklar dibuat antara tampilan seluruh simpul dari model dan indikasi nomor simpul untuk mahkota, korset dan paviliun secara terpisah.  Misalkan dalam model potongan Malta Anda ingin membuat pesawat melewati simpul dengan angka 84, 88 dan 145. Alih-alih menggunakan angka-angka ini untuk mengidentifikasi titik-titik di mana pesawat melewati ketika membuat pesawat menggunakan fungsi CreatePlaneThreePoints, rekaman menggunakan terpisah penomoran puncak untuk korset dan paviliun: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> plane = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Plane3D(); plane.CreatePlaneThreePoints(girdle[<span class="hljs-number"><span class="hljs-number">68</span></span>], girdle[<span class="hljs-number"><span class="hljs-number">72</span></span>], crown[<span class="hljs-number"><span class="hljs-number">1</span></span>]);</code> </pre><br>  Perlu dicatat bahwa program yang menampilkan nomor model simpul bekerja sangat lambat (setidaknya di komputer saya).  Mungkin diperlukan beberapa detik sebelum output dari nomor model titik selesai. <br><br>  Untuk meringkas semua hal di atas, menurut pendapat saya, pilihan polyhedra (model potong) untuk mendemonstrasikan operasi fungsi geometrik adalah salah satu pilihan terbaik.  Setelah memeriksa karya contoh-contoh di atas, kita dapat melanjutkan ke penciptaan objek geometris yang terkait dengan bidang aktivitas yang sama sekali berbeda dari pemodelan pemotongan berlian. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418045/">https://habr.com/ru/post/id418045/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418031/index.html">Penumpukan massal model ML dalam produksi: nyata atau tidak?</a></li>
<li><a href="../id418035/index.html">Memperkenalkan Timeline di Unity</a></li>
<li><a href="../id418037/index.html">Penguji seluler bersiap-siap. Selamat datang di Rapat Pengujian Avito Mobile</a></li>
<li><a href="../id418041/index.html">Sekitar 500 juta perangkat IoT rentan terhadap serangan melalui spoofing DNS</a></li>
<li><a href="../id418043/index.html">Bagaimana saya tidak berangkat ke AS dan menjadi Presiden di Rusia</a></li>
<li><a href="../id418047/index.html">Pengusaha terbaik di bidang TI: hasil pertama dari layanan penilaian di My Circle</a></li>
<li><a href="../id418049/index.html">Bagaimana saya memutar kembali sistem sebulan yang lalu dan mendapatkan semuanya kembali? Pengalaman menggunakan ESXi. Atau bagaimana tidak melakukannya</a></li>
<li><a href="../id418051/index.html">Cara memperbaiki kantor terbuka: aturan perpustakaan</a></li>
<li><a href="../id418053/index.html">Kirim dalam setengah jam</a></li>
<li><a href="../id418055/index.html">Antarmuka game dan apa yang dimakannya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>