<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜî üï∫üèº üë©‚Äçüë©‚Äçüëß Conectando CryptoPro a Mono üôÜüèº üë©üèº‚ÄçüöÄ üßöüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En relaci√≥n con la transici√≥n a Linux, se hizo necesario portar uno de nuestros sistemas de servidor escritos en C # a Mono. El sistema funciona con f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conectando CryptoPro a Mono</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423163/"><p>  En relaci√≥n con la transici√≥n a Linux, se hizo necesario portar uno de nuestros sistemas de servidor escritos en C # a Mono.  El sistema funciona con firmas digitales mejoradas, por lo que una de las tareas a las que nos enfrentamos fue probar el rendimiento de los certificados GOST de CryptoPro en mono.  CryptoPro ha implementado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CSP</a> para Linux durante bastante tiempo, pero el primer intento de usarlo demostr√≥ que las clases de criptograf√≠a Mono nativas (similares a las de la base .Net - X509Store, X509Certificate2, etc.) no solo no funcionan con claves de invitado, sino que incluso no los veo en sus b√≥vedas.  Debido a esto, el trabajo con criptograf√≠a tuvo que conectarse directamente a trav√©s de las bibliotecas CryptoPro. </p><br><a name="habracut"></a><br><h2>  Instalaci√≥n de certificado </h2><br><p>  Antes de implementar el c√≥digo, debe instalar el certificado y asegurarse de que funciona correctamente. </p><br><div class="spoiler">  <b class="spoiler_title">Instalaci√≥n de certificado</b> <div class="spoiler_text"><p>  El componente CryptoPro CSP versi√≥n 3.9 se instal√≥ en Centos 7 en la carpeta / opt / cprocsp.  Para evitar conflictos entre las utilidades mono y CryptoPro con el mismo nombre (por ejemplo, certmgr), la ruta a la carpeta no se agreg√≥ a las variables de entorno y todas las utilidades se llamaron en la ruta completa. </p><br><p> Primero, definimos una lista de lectores: <br> <code>/opt/cprocsp/bin/amd64/csptest -enum -info -type PP_ENUMREADERS | iconv -f cp1251</code> </p> <br><p>  Si no hay un lector de la carpeta en el disco (HDIMAGE) entre la lista, p√≥ngalo: <br> <code>/opt/cprocsp/sbin/amd64/cpconfig -hardware reader -add HDIMAGE store</code> </p> <br><p>  Luego puede crear contenedores con la forma '\\. \ HDIMAGE \ {container name}' ya sea creando un nuevo contenedor con claves: <br> <code>/opt/cprocsp/bin/amd64/csptest -keyset -provtype 75 -newkeyset -cont '\\.\HDIMAGE\test'</code> </p> <br><p>  o creando la carpeta / var / opt / cprocsp / keys / root / {container name} .000, que contiene el conjunto est√°ndar de archivos de contenedor CryptoPro (* .key, * .mask, etc.). </p><br><p>  Despu√©s de eso, el certificado del contenedor se puede instalar en el almac√©n de certificados: <br> <code>/opt/cprocsp/bin/amd64/certmgr -inst mMy -cont '\\.\HDIMAGE\{ }'</code> </p> <br><p>  El certificado instalado se puede ver con el siguiente comando: <br> <code>/opt/cprocsp/bin/amd64/certmgr -list mMy</code> </p> <br><p>  El funcionamiento del certificado se puede verificar de la siguiente manera: <br> <code>/opt/cprocsp/bin/amd64/cryptcp ‚Äì sign -norev -thumbprint {} {} { }</code> <br> <code>/opt/cprocsp/bin/amd64/cryptcp ‚Äì verify -norev { }</code> </p> <br><p>  Si todo est√° bien con el certificado, puede proceder a la conexi√≥n en el c√≥digo. </p><br></div></div><br><h2>  Conexi√≥n en c√≥digo </h2><br><p>  A pesar del proceso de portabilidad a Linux, se supon√≠a que el sistema continuar√≠a funcionando en el entorno de Windows, por lo que, externamente, el trabajo con criptograf√≠a deb√≠a realizarse a trav√©s de m√©todos generales de la forma "byte [] SignData (byte [] _arData, X509Certificate2 _pCert)", que deber√≠a funcionar igual que tanto en Linux como en Windows. </p><br><p>  El an√°lisis de los m√©todos de las bibliotecas de criptograf√≠a result√≥ exitoso, porque CryptoPro implement√≥ la biblioteca "libcapi20.so", que imita completamente las bibliotecas de cifrado est√°ndar de Windows: "crypt32.dll" y "advapi32.dll".  Quiz√°s, por supuesto, no del todo, pero todos los m√©todos necesarios para trabajar con criptograf√≠a est√°n disponibles all√≠, y casi todos funcionan. </p><br><p>  Por lo tanto, formamos dos clases est√°ticas "WCryptoAPI" y "LCryptoAPI", cada una de las cuales importar√° el conjunto de m√©todos necesarios de la siguiente manera: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(LIBCAPI20, SetLastError = true)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CertCloseStore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCertStore, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iFlags</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br><p>  La sintaxis de conexi√≥n para cada uno de los m√©todos se puede crear de forma independiente, o usar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio</a> web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pinvoke</a> , o copiar de fuentes .Net (clase <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CAPISafe</a> ).  Desde el mismo m√≥dulo, puede dibujar constantes y estructuras asociadas con la criptograf√≠a, cuya presencia siempre facilita la vida al trabajar con bibliotecas externas. </p><br><p>  Y luego formamos la clase est√°tica "UCryptoAPI" que, dependiendo del sistema, llamar√° al m√©todo de una de dos clases: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_iFlags"&gt; (  0)&lt;/param&gt; * &lt;param name="_hCertStore"&gt;   &lt;/param&gt; * &lt;returns&gt;   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CertCloseStore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCertStore, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iFlags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fIsLinux) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LCryptoAPI.CertCloseStore(_hCertStore, _iFlags); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WCryptoAPI.CertCloseStore(_hCertStore, _iFlags); } <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt;**/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fIsLinux { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iPlatform = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) Environment.OSVersion.Platform; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (iPlatform == <span class="hljs-number"><span class="hljs-number">4</span></span>) || (iPlatform == <span class="hljs-number"><span class="hljs-number">6</span></span>) || (iPlatform == <span class="hljs-number"><span class="hljs-number">128</span></span>); } }</code> </pre><br><p>  Por lo tanto, utilizando los m√©todos de la clase UCryptoAPI, puede implementar c√≥digo casi uniforme para ambos sistemas. </p><br><h3>  B√∫squeda de certificados </h3><br><p>  El trabajo con criptograf√≠a generalmente comienza con una b√∫squeda de certificados, para esto en crypt32.dll hay dos m√©todos CertOpenStore (abre el almac√©n de certificados especificado) y un simple CertOpenSystemStore (abre los certificados personales del usuario).  Debido al hecho de que trabajar con certificados no se limita a los certificados de usuario personales, conectamos el primero: </p><br><div class="spoiler">  <b class="spoiler_title">B√∫squeda de certificados</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  (   )&lt;/summary&gt; * &lt;param name="_pFindType"&gt; &lt;/param&gt; * &lt;param name="_pFindValue"&gt; &lt;/param&gt; * &lt;param name="_pLocation"&gt; &lt;/param&gt; * &lt;param name="_pName"&gt; &lt;/param&gt; * &lt;param name="_pCert"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_fVerify"&gt; &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindCertificateCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _pFindValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError, StoreLocation _pLocation = StoreLocation.CurrentUser, StoreName _pName = StoreName.My, X509FindType _pFindType = X509FindType.FindByThumbprint, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _fVerify = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; IntPtr hCert = IntPtr.Zero; GCHandle hInternal = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GCHandle(); GCHandle hFull = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GCHandle(); IntPtr hSysStore = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   hSysStore = UCryptoAPI.CertOpenStore(UCConsts.AR_CERT_STORE_PROV_SYSTEM[fIsLinux.ToByte()], UCConsts.PKCS_7_OR_X509_ASN_ENCODING, IntPtr.Zero, UCUtils.MapX509StoreFlags(_pLocation, OpenFlags.ReadOnly), UCConsts.AR_CRYPTO_STORE_NAME[(int)_pName]); if (hSysStore == IntPtr.Zero) { _sError = UCConsts.S_ERR_STORE_OPEN.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 1)     if ((_pFindType == X509FindType.FindByThumbprint) || (_pFindType == X509FindType.FindBySerialNumber)) { byte[] arData = _pFindValue.FromHex(); CRYPTOAPI_BLOB cryptBlob; cryptBlob.cbData = arData.Length; hInternal = GCHandle.Alloc(arData, GCHandleType.Pinned); cryptBlob.pbData = hInternal.AddrOfPinnedObject(); hFull = GCHandle.Alloc(cryptBlob, GCHandleType.Pinned); } else { byte[] arData; if(fIsLinux) arData = Encoding.UTF8.GetBytes(_pFindValue); else arData = Encoding.Unicode.GetBytes(_pFindValue); hFull = GCHandle.Alloc(arData, GCHandleType.Pinned); } // 2)  IntPtr hPrev = IntPtr.Zero; do { hCert = UCryptoAPI.CertFindCertificateInStore(hSysStore, UCConsts.PKCS_7_OR_X509_ASN_ENCODING, 0, UCConsts.AR_CRYPT_FIND_TYPE[(int)_pFindType, fIsLinux.ToByte()], hFull.AddrOfPinnedObject(), hPrev); // 2.1)   if(hPrev != IntPtr.Zero) UCryptoAPI.CertFreeCertificateContext(hPrev); // 2.2)    if(hCert == IntPtr.Zero) return UConsts.E_NO_CERTIFICATE; // 2.3)    X509Certificate2 pCert = new ISDP_X509Cert(hCert); if (!_fVerify || pCert.ISDPVerify()) { hCert = IntPtr.Zero; _pCert = pCert; return UConsts.S_OK; } hPrev = hCert; //    hCert = IntPtr.Zero; } while(hCert != IntPtr.Zero); return UConsts.E_NO_CERTIFICATE; } catch (Exception E) { _sError = UCConsts.S_FIND_CERT_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { //      if(hInternal.IsAllocated) hInternal.Free(); if(hFull.IsAllocated) hFull.Free(); if (hCert != IntPtr.Zero) UCryptoAPI.CertFreeCertificateContext(hCert); UCryptoAPI.CertCloseStore(hSysStore, 0); } }</span></span></code> </pre><br></div></div><br>  La b√∫squeda se lleva a cabo en varias etapas: <br><ol><li>  apertura de almacenamiento; </li><li>  formaci√≥n de la estructura de datos por la cual estamos buscando; </li><li>  b√∫squeda de certificados; </li><li>  si es necesario, luego la verificaci√≥n del certificado (descrito en una secci√≥n separada) </li><li>  cerrar el repositorio y liberar la estructura desde el punto 2 (ya que en todas partes hay trabajo con memoria .Net no administrada, no se har√° nada para limpiarlo); </li></ol><br><p>  Hay algunos puntos sutiles al buscar certificados. </p><br><p>  CryptoPro en Linux funciona con cadenas ANSI y en Windows con UTF8, por lo tanto: </p><br><ol><li>  al conectar el m√©todo de abrir almacenamiento en Linux, es necesario indicar expl√≠citamente el tipo de c√°lculo de referencias [In, MarshalAs (UnmanagedType.LPStr)] para el par√°metro del c√≥digo de almacenamiento; </li><li>  pasando la cadena de b√∫squeda (por ejemplo, por el nombre del Asunto) se debe convertir en un conjunto de bytes con diferentes codificaciones; </li><li>  para todas las constantes criptogr√°ficas que tienen variaciones seg√∫n el tipo de cadena (por ejemplo, CERT_FIND_SUBJECT_STR_A y CERT_FIND_SUBJECT_STR_W) en Windows, debe seleccionar * _W y en Linux * _A; </li></ol><br><p>  El m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MapX509StoreFlags</a> se puede tomar directamente de las fuentes de Microsoft sin cambios, simplemente forma una m√°scara final basada en banderas .Net. </p><br><p>  El valor por el cual se realiza la b√∫squeda depende del tipo de b√∫squeda (consulte con MSDN para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CertFindCertificateInStore</a> ), el ejemplo muestra las dos opciones m√°s utilizadas: para el formato de cadena (nombres Asunto, Emisor, etc.) y binario (huella digital, n√∫mero de serie). </p><br><p>  El proceso de creaci√≥n de un certificado de IntPtr en Windows y Linux es muy diferente.  Windows crear√° el certificado de una manera simple: <br></p><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X509Certificate2(hCert);</code> </pre> <p></p><br><p>  en Linux, debe crear un certificado en dos pasos: <br></p><pre> <code class="cs hljs">X509Certificate2(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X509Certificate(hCert));</code> </pre> <p></p><br><p>  En el futuro, necesitamos acceso a hCert para el trabajo, y deber√≠a almacenarse en el objeto de certificado.  En Windows, se puede recuperar m√°s tarde de la propiedad Handle, pero Linux convierte la estructura CERT_CONTEXT que sigue al enlace hCert en un enlace a la estructura x509_st (OpenSSL) y lo registra en Handle.  Por lo tanto, vale la pena crear un heredero de X509Certificate2 (ISDP_X509Cert en el ejemplo), que almacenar√° hCert en ambos sistemas en un campo separado. </p><br><p>  No olvide que este es un enlace a un √°rea de memoria no administrada y debe liberarse despu√©s del final del trabajo.  Porque  en .Net 4.5 X509Certificate2 no es desechable: la limpieza con el m√©todo CertFreeCertificateContext debe realizarse en el destructor. </p><br><h3>  Formaci√≥n de firma </h3><br><p>  Cuando se trabaja con certificados GOST, las firmas desconectadas con un firmante casi siempre se usan.  Para crear dicha firma, se requiere un bloque de c√≥digo bastante simple: </p><br><div class="spoiler">  <b class="spoiler_title">Formaci√≥n de firma</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt; * &lt;param name="_arData"&gt;  &lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_arRes"&gt; &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SignDataCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arData, X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// 0)   CRYPT_SIGN_MESSAGE_PARA pParams = new CRYPT_SIGN_MESSAGE_PARA(); pParams.cbSize = Marshal.SizeOf(typeof(CRYPT_SIGN_MESSAGE_PARA)); pParams.dwMsgEncodingType = (int)(UCConsts.PKCS_7_OR_X509_ASN_ENCODING); pParams.pSigningCert = _pCert.getRealHandle(); pParams.cMsgCert = 1; pParams.HashAlgorithm.pszObjId = _pCert.getHashAlgirtmOid(); IntPtr pGlobData = Marshal.AllocHGlobal(_arData.Length); GCHandle pGC = GCHandle.Alloc(_pCert.getRealHandle(), GCHandleType.Pinned); try { pParams.rgpMsgCert = pGC.AddrOfPinnedObject(); Marshal.Copy(_arData, 0, pGlobData, _arData.Length); uint iLen = 50000; byte[] arRes = new byte[iLen]; // 1)   if (!UCryptoAPI.CryptSignMessage(ref pParams, true, 1, new IntPtr[1] { pGlobData }, new uint[1] { (uint)_arData.Length }, arRes, ref iLen)) { _sError = UCConsts.S_MAKE_SIGN_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } Array.Resize(ref arRes, (int)iLen); _arRes = arRes; return UConsts.S_OK;; } catch (Exception E) { _sError = UCConsts.S_MAKE_SIGN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { pGC.Free(); Marshal.FreeHGlobal(pGlobData); } }</span></span></code> </pre></div></div><br><p>  Durante el trabajo del m√©todo, se forma una estructura con par√°metros y se llama al m√©todo de firma.  La estructura de par√°metros puede permitirle guardar certificados en la firma para formar una cadena completa (los campos cMsgCert y rgpMsgCert, el primero almacena el n√∫mero de certificados, la segunda lista de enlaces a las estructuras de estos certificados). </p><br><p>  El m√©todo de firma puede recibir uno o m√°s documentos para la firma simult√°nea con una firma.  Esto, por cierto, no contradice la Ley Federal 63 y es muy conveniente, porque es poco probable que el usuario est√© contento de la necesidad de hacer clic en el bot√≥n "firmar" varias veces. </p><br><p>  La peculiaridad principal de este m√©todo es que no funciona en el modo de dos llamadas, lo cual es t√≠pico para la mayor√≠a de los m√©todos de biblioteca que funcionan con grandes bloques de memoria (el primero con nulo, devuelve la longitud de b√∫fer requerida, el segundo llena el b√∫fer).  Por lo tanto, es necesario crear un b√∫fer grande y luego acortarlo a su longitud real. </p><br><p>  El √∫nico problema grave es la b√∫squeda del OID del algoritmo hash (resumen) utilizado al firmar; en forma expl√≠cita, no est√° en el certificado (solo existe el algoritmo de la firma en s√≠).  Y si en Windows puede especificarlo con una cadena vac√≠a, se recuperar√° autom√°ticamente, pero Linux se negar√° a firmar si el algoritmo no es el mismo. </p><br><p>  Pero hay un truco: en la informaci√≥n sobre el algoritmo de firma (estructura CRYPT_OID_INFO), el OID de firma se almacena en pszOID y el identificador del algoritmo hash se almacena en Algid.  Y convertir Algid a OID ya es una cuesti√≥n t√©cnica: </p><br><div class="spoiler">  <b class="spoiler_title">Obteniendo el OID del algoritmo hash</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; OID   &lt;/summary&gt; * &lt;param name="_hCertHandle"&gt; &lt;/param&gt; * &lt;param name="_sOID"&gt;  OID&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashAlgoritmOID</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCertHandle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sOID, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _sOID = <span class="hljs-string"><span class="hljs-string">""</span></span>; IntPtr hHashAlgInfo = IntPtr.Zero; IntPtr hData = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { CERT_CONTEXT pContext = (CERT_CONTEXT)Marshal.PtrToStructure(_hCertHandle, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CERT_CONTEXT)); CERT_INFO pCertInfo = (CERT_INFO)Marshal.PtrToStructure(pContext.pCertInfo, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CERT_INFO)); <span class="hljs-comment"><span class="hljs-comment">//  AlgID //  UCryptoAPI.CertAlgIdToOID  Windows   ,   byte[] arData = BitConverter.GetBytes(UCryptoAPI.CertOIDToAlgId(pCertInfo.SignatureAlgorithm.pszObjId)); hData = Marshal.AllocHGlobal(arData.Length); Marshal.Copy(arData, 0, hData, arData.Length); //  OID hHashAlgInfo = UCryptoAPI.CryptFindOIDInfo(UCConsts.CRYPT_OID_INFO_ALGID_KEY, hData, UCConsts.CRYPT_HASH_ALG_OID_GROUP_ID); if (hHashAlgInfo == IntPtr.Zero) { _sError = UCConsts.S_NO_HASH_ALG_ERR.Frm( Marshal.GetLastWin32Error()); return UConsts.E_GEN_EXCEPTION; } CRYPT_OID_INFO pHashAlgInfo = (CRYPT_OID_INFO)Marshal.PtrToStructure(hHashAlgInfo, typeof(CRYPT_OID_INFO)); _sOID = pHashAlgInfo.pszOID; return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_DETERM_HASH_ALG_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { Marshal.FreeHGlobal(hData); } }</span></span></code> </pre></div></div><br><p>  Despu√©s de leer cuidadosamente el c√≥digo, puede sorprenderse de que el identificador del algoritmo se obtenga de una manera simple (CertOIDToAlgId) y que el Oid sea complicado (CryptFindOIDInfo).  Ser√≠a l√≥gico suponer el uso de m√©todos tanto complejos como simples, y en Linux ambas opciones funcionan con √©xito.  Sin embargo, en Windows, la dif√≠cil opci√≥n de obtener un identificador y simplemente obtener un OID es inestable, por lo que un h√≠brido tan extra√±o ser√≠a una soluci√≥n estable. </p><br><h3>  Verificaci√≥n de firma </h3><br><p>  La verificaci√≥n de la firma se lleva a cabo en dos etapas, al principio se verifica la firma y luego se verifica el certificado con el que se gener√≥ (cadena, fecha de firma, etc.). <br>  Adem√°s de al firmar, debe especificar el conjunto de datos a firmar, los par√°metros de firma y la firma en s√≠: </p><br><div class="spoiler">  <b class="spoiler_title">Verificaci√≥n de firma</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;      &lt;/summary&gt; * &lt;returns&gt;&lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CRYPT_VERIFY_MESSAGE_PARA </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStdSignVerifyPar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CRYPT_VERIFY_MESSAGE_PARA pVerifyParams = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CRYPT_VERIFY_MESSAGE_PARA(); pVerifyParams.cbSize = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Marshal.SizeOf(pVerifyParams); pVerifyParams.dwMsgEncodingType = UCConsts.PKCS_7_OR_X509_ASN_ENCODING; pVerifyParams.hCryptProv = <span class="hljs-number"><span class="hljs-number">0</span></span>; pVerifyParams.pfnGetSignerCertificate = IntPtr.Zero; pVerifyParams.pvGetArg = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pVerifyParams; } <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_arData"&gt;,   &lt;/param&gt; * &lt;param name="_pSign"&gt;&lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_fVerifyOnlySign"&gt;  &lt;/param&gt; * &lt;param name="_pRevMode"&gt;  &lt;/param&gt; * &lt;param name="_pRevFlag"&gt;  &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * &lt;remarks&gt;   &lt;/remarks&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckSignCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _pSign, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _fVerifyOnlySign = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, X509RevocationMode _pRevMode = X509RevocationMode.Online, X509RevocationFlag _pRevFlag = X509RevocationFlag.ExcludeRoot</span></span></span><span class="hljs-function">)</span></span>{ _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; IntPtr pHData = Marshal.AllocHGlobal(_arData.Length); GCHandle pCertContext = GCHandle.Alloc(IntPtr.Zero, GCHandleType.Pinned); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Marshal.Copy(_arData, <span class="hljs-number"><span class="hljs-number">0</span></span>, pHData, _arData.Length); CRYPT_VERIFY_MESSAGE_PARA pVerParam = UCUtils.GetStdSignVerifyPar(); <span class="hljs-comment"><span class="hljs-comment">// 0)   bool fRes = UCryptoAPI.CryptVerifyDetachedMessageSignature( ref pVerParam, //   0, //   _pSign, //  _pSign.Length, //   1, // -    new IntPtr[1] { pHData }, //   new int[1] { _arData.Length }, //    pCertContext.AddrOfPinnedObject());//    if (!fRes) { _sError = UCConsts.S_SIGN_CHECK_ERR.Frm(Marshal.GetLastWin32Error().ToString("X")); return UConsts.E_CRYPTO_ERR; } // 1)   _pCert = new ISDP_X509Cert((IntPtr)pCertContext.Target); if (_pCert == null) { _sError = UCConsts.S_SIGN_CHECK_CERT_ERR; return UConsts.E_CRYPTO_ERR; } // 2)   if (!_fVerifyOnlySign) { List&lt;DateTime&gt; pDates; // 2.1)    int iRes = GetSignDateTimeCP(_pSign, out pDates, ref _sError); // 2.2)    iRes = _pCert.ISDPVerify(ref _sError, pDates[0], _pRevMode, _pRevFlag); if (iRes != UConsts.S_OK) return iRes; } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_SIGN_CHECK_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION;; } finally { Marshal.FreeHGlobal(pHData); if ((_pCert == null) &amp;&amp; pCertContext.IsAllocated &amp;&amp; ((IntPtr)pCertContext.Target != IntPtr.Zero)) UCryptoAPI.CertFreeCertificateContext((IntPtr)pCertContext.Target); pCertContext.Free(); } }</span></span></code> </pre></div></div><br><p>  Por conveniencia, el proceso de formar una estructura con par√°metros se ha movido a un m√©todo separado (GetStdSignVerifyPar).  Despu√©s de eso, se verifica la firma en s√≠ y se extrae el primer firmante (para bien, ser√≠a necesario extraer todo, pero una firma que contenga varios firmantes sigue siendo ex√≥tica). </p><br><p>  Despu√©s de extraer el certificado del firmante, lo convertiremos a nuestra clase y lo verificaremos (si se especifica en los par√°metros del m√©todo).  Para la verificaci√≥n, se utiliza la fecha de firma del primer firmante (consulte la secci√≥n sobre la extracci√≥n de informaci√≥n de la firma y la secci√≥n sobre la verificaci√≥n del certificado). </p><br><h2>  Extraer informaci√≥n de firma </h2><br><p>  A menudo, los sistemas criptogr√°ficos requieren una representaci√≥n impresa de la firma.  En cada caso, es diferente, por lo que es mejor crear una clase de informaci√≥n sobre la firma, que contendr√° la informaci√≥n en una forma conveniente para su uso y con su ayuda proporcionar√° una presentaci√≥n impresa.  En .Net existe tal clase: SignedCms, sin embargo, su an√°logo en mono con las firmas de CritoPro se niega a funcionar en el primero, en segundo lugar contiene el modificador sellado y en tercer lugar casi todas sus propiedades est√°n protegidas contra escritura, por lo que debe crear su propio an√°logo. </p><br><p>  La firma en s√≠ contiene dos elementos principales: una lista de certificados y una lista de firmantes.  La lista de certificados puede estar vac√≠a o puede contener todos los certificados para verificaci√≥n, incluidas las cadenas completas.  La lista de firmantes indica el n√∫mero de firmas reales.  La comunicaci√≥n entre ellos se lleva a cabo por el n√∫mero de serie y el editor (Emisor).  Te√≥ricamente, en una firma puede haber dos certificados de diferentes editores con el mismo n√∫mero de serie, pero en la pr√°ctica esto puede ser descuidado y buscado solo por el n√∫mero de serie. </p><br><p>  La lectura de la firma es la siguiente: </p><br><div class="spoiler">  <b class="spoiler_title">Extraer informaci√≥n de firma</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;&lt;/summary&gt; * &lt;param name="_arSign"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arSign, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { IntPtr hMsg = IntPtr.Zero; <span class="hljs-comment"><span class="hljs-comment">// 0)   try { hMsg = UCryptoAPI.CryptMsgOpenToDecode(UCConsts.PKCS_7_OR_X509_ASN_ENCODING, UCConsts.CMSG_DETACHED_FLAG, 0, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero); if (hMsg == IntPtr.Zero) { _sError = UCConsts.S_CRYP_MSG_FORM_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 1)   if (!UCryptoAPI.CryptMsgUpdate(hMsg, _arSign, (uint)_arSign.Length, true)) { _sError = UCConsts.S_CRYP_MSG_SIGN_COPY_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 2)   (PKCS7 SignedData) uint iMessType = UCUtils.GetCryptMsgParam&lt;uint&gt;(hMsg, UCConsts.CMSG_TYPE_PARAM); if (UCConsts.CMSG_SIGNED != iMessType) { _sError = UCConsts.S_CRYP_MSG_SIGN_TYPE_ERR.Frm(iMessType, UCConsts.CMSG_SIGNED); return UConsts.E_CRYPTO_ERR; } // 3)    fpCertificates = UCUtils.GetSignCertificates(hMsg); // 4)   uint iSignerCount = UCUtils.GetCryptMsgParam&lt;uint&gt;(hMsg, UCConsts.CMSG_SIGNER_COUNT_PARAM); for (int i = 0; i &lt; iSignerCount; i++) { ISDPSignerInfo pInfo = new ISDPSignerInfo(); fpSignerInfos.Add(pInfo); int iRes = pInfo.Decode(hMsg, i, this, ref _sError); if (iRes != UConsts.S_OK) return iRes; } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_SIGN_INFO_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hMsg != IntPtr.Zero) UCryptoAPI.CryptMsgClose(hMsg); } }</span></span></code> </pre></div></div><br><p>  La firma se analiza en varias etapas, primero se forma la estructura del mensaje (CryptMsgOpenToDecode), luego se ingresan los datos reales de la firma (CryptMsgUpdate).  Queda por verificar que se trata de una firma real y primero obtener una lista de certificados y luego una lista de firmantes.  La lista de certificados se recupera secuencialmente: </p><br><div class="spoiler">  <b class="spoiler_title">Obtener una lista de certificados</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;     &lt;/summary&gt; * &lt;param name="_hMsg"&gt;Handle &lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> X509Certificate2Collection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSignCertificates</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hMsg</span></span></span><span class="hljs-function">)</span></span> { X509Certificate2Collection certificates = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X509Certificate2Collection(); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iCnt = GetCryptMsgParam&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt;(_hMsg, UCConsts.CMSG_CERT_COUNT_PARAM); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iCnt; i++) { IntPtr hInfo = IntPtr.Zero; IntPtr hCert = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iLen = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetCryptMsgParam(_hMsg, UCConsts.CMSG_CERT_PARAM, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hInfo, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> iLen)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; hCert = UCryptoAPI.CertCreateCertificateContext(UCConsts.PKCS_7_OR_X509_ASN_ENCODING, hInfo, iLen); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hCert != IntPtr.Zero) { certificates.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ISDP_X509Cert(hCert)); hCert = IntPtr.Zero; } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hInfo != IntPtr.Zero) Marshal.FreeHGlobal(hInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hInfo != IntPtr.Zero) Marshal.FreeHGlobal(hCert); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> certificates; }</code> </pre></div></div><br><p>  Primero, el n√∫mero de certificados se determina a partir del par√°metro CMSG_CERT_COUNT_PARAM, y luego la informaci√≥n sobre cada certificado se recupera secuencialmente.  El proceso de creaci√≥n del contexto del certificado y sobre la base del propio certificado completa el proceso de creaci√≥n. </p><br><p>  Recuperar los datos del firmante es m√°s dif√≠cil.  Contienen una indicaci√≥n del certificado y una lista de par√°metros de firma (por ejemplo, la fecha de la firma).  El proceso de extracci√≥n de datos es el siguiente: </p><br><div class="spoiler">  <b class="spoiler_title">Recuperando informaci√≥n del firmante</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;   &lt;/summary&gt; * &lt;param name="_hMsg"&gt;Handler &lt;/param&gt; * &lt;param name="_iIndex"&gt; &lt;/param&gt; * &lt;param name="_pSignedCms"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hMsg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iIndex, ISDPSignedCms _pSignedCms, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1)   uint iLen = 0; // 2)  IntPtr hInfo = IntPtr.Zero; try { if (!UCryptoAPI.CryptMsgGetParam(_hMsg, UCConsts.CMSG_SIGNER_INFO_PARAM, (uint)_iIndex, IntPtr.Zero, ref iLen)) { _sError = UCConsts.S_ERR_SIGNER_INFO_LEN.Frm(_iIndex, Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } hInfo = Marshal.AllocHGlobal((int)iLen); if (!UCryptoAPI.CryptMsgGetParam(_hMsg, UCConsts.CMSG_SIGNER_INFO_PARAM, (uint)_iIndex, hInfo, ref iLen)) { _sError = UCConsts.S_ERR_SIGNER_INFO.Frm(_iIndex, Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } CMSG_SIGNER_INFO pSignerInfo = (CMSG_SIGNER_INFO) Marshal.PtrToStructure(hInfo, typeof(CMSG_SIGNER_INFO)); // 2.1)   byte[] arSerial = new byte[pSignerInfo.SerialNumber.cbData]; Marshal.Copy(pSignerInfo.SerialNumber.pbData, arSerial, 0, arSerial.Length); X509Certificate2Collection pLocCerts = _pSignedCms.pCertificates.Find(X509FindType.FindBySerialNumber, arSerial.Reverse().ToArray().ToHex(), false); if (pLocCerts.Count != 1) { _sError = UCConsts.S_ERR_SIGNER_INFO_CERT.Frm(_iIndex); return UConsts.E_NO_CERTIFICATE; } fpCertificate = pLocCerts[0]; fpSignedAttributes = UCUtils.ReadCryptoAttrsCollection(pSignerInfo.AuthAttrs); return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_ERR_SIGNER_INFO_READ.Frm(_iIndex, E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hInfo != IntPtr.Zero) Marshal.FreeHGlobal(hInfo); } }</span></span></code> </pre></div></div><br><p>        ,       CMSG_SIGNER_INFO.                 .  ,       . </p><br><p>       ,     ‚Äî   (        ,     ). </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;   &lt;/summary&gt; * &lt;param name="_pAttrs"&gt; &lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CryptographicAttributeObjectCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadCryptoAttrsCollection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CRYPT_ATTRIBUTES _pAttrs</span></span></span><span class="hljs-function">)</span></span> { CryptographicAttributeObjectCollection pRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CryptographicAttributeObjectCollection(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _pAttrs.cAttr; i++) { IntPtr hAttr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntPtr((<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)_pAttrs.rgAttr + (i * Marshal.SizeOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CRYPT_ATTRIBUTE)))); CRYPT_ATTRIBUTE pAttr = (CRYPT_ATTRIBUTE) Marshal.PtrToStructure(hAttr, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CRYPT_ATTRIBUTE)); CryptographicAttributeObject pAttrInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CryptographicAttributeObject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Oid(pAttr.pszObjId), GetAsnEncodedDataCollection(pAttr)); pRes.Add(pAttrInfo); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pRes; }</code> </pre></div></div><br><p>        Oid ‚Äì   (     ASN.1).       : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;      &lt;/summary&gt; * &lt;param name="_sName"&gt;&lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Pkcs9AttributeObject </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pkcs9AttributeFromOID</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (_sName) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> UCConsts.S_SIGN_DATE_OID : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pkcs9SigningTime(); <span class="hljs-comment"><span class="hljs-comment">// case UConsts.S_CONTENT_TYPE_OID : return new Pkcs9ContentType(); -&gt;&gt;  Mono  // case UConsts.S_MESS_DIGEST_OID : return new Pkcs9MessageDigest(); default: return new Pkcs9AttributeObject(); } } /**&lt;summary&gt;  ASN&lt;/summary&gt; * &lt;param name="_pAttr"&gt;&lt;/param&gt; * &lt;returns&gt;&lt;/returns&gt; * **/ internal static AsnEncodedDataCollection GetAsnEncodedDataCollection (CRYPT_ATTRIBUTE _pAttr) { AsnEncodedDataCollection pRes = new AsnEncodedDataCollection(); Oid pOid = new Oid(_pAttr.pszObjId); string sOid = pOid.Value; for (uint i = 0; i &lt; _pAttr.cValue; i++) { checked { IntPtr pAttributeBlob = new IntPtr((long)_pAttr.rgValue + (i * Marshal.SizeOf(typeof(CRYPTOAPI_BLOB)))); Pkcs9AttributeObject attribute = new Pkcs9AttributeObject(pOid, BlobToByteArray(pAttributeBlob)); Pkcs9AttributeObject customAttribute = Pkcs9AttributeFromOID(sOid); if (customAttribute != null) { customAttribute.CopyFrom(attribute); attribute = customAttribute; } pRes.Add(attribute); } } return pRes; }</span></span></code> </pre></div></div><br><p>         Pkcs9AttributeObject.   ,      mono          .       Mono       . </p><br><p>        ‚Äî        ‚Äî   SignedCms,        . </p><br><h3>  </h3><br><p>       ,   ,         .                 (,      ,       ). </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_arInput"&gt;  &lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;param name="_arRes"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;   ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EncryptDataCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arInput, X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   CRYPT_ENCRYPT_MESSAGE_PARA pParams = new CRYPT_ENCRYPT_MESSAGE_PARA(); pParams.dwMsgEncodingType = UCConsts.PKCS_7_OR_X509_ASN_ENCODING; pParams.ContentEncryptionAlgorithm.pszObjId = _pCert.getEncodeAlgirtmOid(); pParams.cbSize = Marshal.SizeOf(pParams); // 1)   int iLen = 0; if (!UCryptoAPI.CryptEncryptMessage(ref pParams, 1, new IntPtr[] { _pCert.getRealHandle() }, _arInput, _arInput.Length, null, ref iLen)) { _sError = UCConsts.S_CRYPT_ENCODE_LEN_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 2)     _arRes = new byte[iLen]; if (!UCryptoAPI.CryptEncryptMessage(ref pParams, 1, new IntPtr[] {_pCert.getRealHandle() }, _arInput, _arInput.Length, _arRes, ref iLen)) { _sError = UCConsts.S_CRYPT_ENCODE_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_CRYPT_ENCODE_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } }</span></span></code> </pre></div></div><br><p>       ‚Äî  ,     .     , ,      . </p><br><p>       ,              ,    . </p><br><p>      .     ,            (    ).        : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; OID   &lt;/summary&gt; * &lt;param name="_hCertHandle"&gt; &lt;/param&gt; * &lt;param name="_sOID"&gt;  OID&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEncodeAlgoritmOID</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCertHandle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sOID, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fNeedRelease = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _sOID = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iKeySpec = <span class="hljs-number"><span class="hljs-number">0</span></span>; IntPtr hCrypto = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)    if (!UCryptoAPI.CryptAcquireCertificatePrivateKey(_hCertHandle, 0, IntPtr.Zero, ref hCrypto, ref iKeySpec, ref fNeedRelease)) { _sError = UCConsts.S_CRYPTO_PROV_INIT_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } uint iLen = 1000; byte[] arData = new byte[1000]; uint iFlag = 1; //  // 1)      while (UCryptoAPI.CryptGetProvParam(hCrypto, UCConsts.PP_ENUMALGS, arData, ref iLen, iFlag)){ iFlag = 2; //  PROV_ENUMALGS pInfo = ConvertBytesToStruct&lt;PROV_ENUMALGS&gt;(arData); // 2)   OID     byte[] arDataAlg = BitConverter.GetBytes(pInfo.aiAlgid); IntPtr hDataAlg = Marshal.AllocHGlobal(arDataAlg.Length); try { Marshal.Copy(arDataAlg, 0, hDataAlg, arDataAlg.Length); IntPtr hHashAlgInfo2 = UCryptoAPI.CryptFindOIDInfo(UCConsts.CRYPT_OID_INFO_ALGID_KEY, hDataAlg, UCConsts.CRYPT_ENCRYPT_ALG_OID_GROUP_ID); // 2.1)  -  if (hHashAlgInfo2 != IntPtr.Zero) { CRYPT_OID_INFO pHashAlgInfo2 = (CRYPT_OID_INFO)Marshal.PtrToStructure(hHashAlgInfo2, typeof(CRYPT_OID_INFO)); _sOID = pHashAlgInfo2.pszOID ; return UConsts.S_OK; } } finally { Marshal.FreeHGlobal(hDataAlg); } } // 3)   -  _sError = UCConsts.S_NO_ENCODE_ALG_ERR; return UConsts.E_CRYPTO_ERR; } catch (Exception E) { _sError = UCConsts.S_DETERM_ENCODE_ALG_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; }finally { if((hCrypto != IntPtr.Zero) &amp;&amp; fNeedRelease) UCryptoAPI.CryptReleaseContext(hCrypto, 0); } }</span></span></code> </pre></div></div><br><p>             .        ( , , ,   .),      .          (UCConsts.CRYPT_ENCRYPT_ALG_OID_GROUP_ID).     ‚Äî    . </p><br><p>               (    ). </p><br><h3>  </h3><br><p>  ,   ,               .        .       ‚Äî  ,      : </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_arInput"&gt;  &lt;/param&gt; * &lt;param name="_arRes"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;returns&gt;  ,  UCOnsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecryptDataCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arInput, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; IntPtr hSysStore = UCryptoAPI.CertOpenSystemStore(IntPtr.Zero, UCConsts.AR_CRYPTO_STORE_NAME[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)StoreName.My]); GCHandle GC = GCHandle.Alloc(hSysStore, GCHandleType.Pinned); IntPtr hOutCertL = IntPtr.Zero; IntPtr hOutCert = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   CRYPT_DECRYPT_MESSAGE_PARA pParams = new CRYPT_DECRYPT_MESSAGE_PARA(); pParams.dwMsgAndCertEncodingType = UCConsts.PKCS_7_OR_X509_ASN_ENCODING; pParams.cCertStore = 1; pParams.rghCertStore = GC.AddrOfPinnedObject(); pParams.cbSize = Marshal.SizeOf(pParams); int iLen = 0; // 1)     if (!UCryptoAPI.CryptDecryptMessage(ref pParams, _arInput, _arInput.Length, null, ref iLen, ref hOutCertL)) { _sError = UCConsts.S_DECRYPT_LEN_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 2)    _arRes = new byte[iLen]; if (!UCryptoAPI.CryptDecryptMessage(ref pParams, _arInput, _arInput.Length, _arRes, ref iLen, ref hOutCert)) { _sError = UCConsts.S_DECRYPT_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 3)     if (hOutCert != IntPtr.Zero) _pCert = new ISDP_X509Cert(hOutCert); if(_pCert != null) hOutCert = IntPtr.Zero; //    return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_DECRYPT_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if (hOutCertL != IntPtr.Zero) UCryptoAPI.CertFreeCertificateContext(hOutCertL); if (hOutCert != IntPtr.Zero) UCryptoAPI.CertFreeCertificateContext(hOutCert); GC.Free(); UCryptoAPI.CertCloseStore(hSysStore, 0); } }</span></span></code> </pre></div></div><br><p>     ,          .         ,    ( Linux    ). </p><br><h3>   </h3><br><p>      ,         ,  ,       ,      .          ,   .       : </p><br><ol><li>   ( ,    ,  . .); </li><li>    ‚Äî       ; </li><li>     ‚Äî         ; <br></li><li>     ,  ,         (CRL); </li></ol><br><p>        ,       . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ya est√° claro en la introducci√≥n, verificar la validez del certificado es una de las tareas m√°s dif√≠ciles. </font><font style="vertical-align: inherit;">Es por eso que la biblioteca tiene muchos m√©todos para implementar cada uno de los elementos individualmente. </font><font style="vertical-align: inherit;">Por lo tanto, para simplificar, recurrimos a las fuentes .Net para el m√©todo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X509Certificate2.Verify ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y las tomamos como base.</font></font></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La verificaci√≥n consta de dos etapas: </font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> formar una cadena de certificados hasta la ra√≠z; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verifique cada uno de los certificados que contiene (por revocaci√≥n, tiempo, etc.); </font></font></li></ol><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dicha verificaci√≥n debe realizarse antes de firmar y cifrar en la fecha actual, y en el momento de la verificaci√≥n de la firma en la fecha de la firma. </font><font style="vertical-align: inherit;">El m√©todo de verificaci√≥n en s√≠ es peque√±o:</font></font></p><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verificaci√≥n de certificado</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_iRevFlag"&gt; &lt;/param&gt; * &lt;param name="_iRevMode"&gt; &lt;/param&gt; * &lt;param name="_hPolicy"&gt;   &lt;/param&gt; * &lt;param name="_hCert"&gt; &lt;/param&gt; * &lt;param name="_iCTLTimeout"&gt;   &lt;/param&gt; * &lt;param name="_rOnDate"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VerifyCertificate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCert, X509RevocationMode _iRevMode, X509RevocationFlag _iRevFlag, DateTime _rOnDate, TimeSpan _iCTLTimeout, IntPtr _hPolicy, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_hCert == IntPtr.Zero) { _sError = UCConsts.S_CRYPTO_CERT_CHECK_ERR; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UConsts.E_NO_CERTIFICATE; } CERT_CHAIN_POLICY_PARA pPolicyParam = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CERT_CHAIN_POLICY_PARA(Marshal.SizeOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CERT_CHAIN_POLICY_PARA))); CERT_CHAIN_POLICY_STATUS pPolicyStatus = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CERT_CHAIN_POLICY_STATUS(Marshal.SizeOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CERT_CHAIN_POLICY_STATUS))); <span class="hljs-comment"><span class="hljs-comment">// 1)   IntPtr hChain = IntPtr.Zero; try { int iRes = BuildChain(new IntPtr(UCConsts.HCCE_CURRENT_USER), _hCert, __iRevMode, _iRevFlag, _rOnDate, _iCTLTimeout, ref hChain, ref _sError); if (iRes != UConsts.S_OK) return iRes; // 2)   if (UCryptoAPI.CertVerifyCertificateChainPolicy(_hPolicy, hChain, ref pPolicyParam, ref pPolicyStatus)) { if (pPolicyStatus.dwError != 0) { _sError = UCConsts.S_CRYPTO_CHAIN_CHECK_ERR.Frm(pPolicyStatus.dwError); return UConsts.E_CRYPTO_ERR; } } else{ _sError = UCConsts.S_CRYPTO_CHAIN_CHECK_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_CRYPTO_CERT_VERIFY_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hChain != IntPtr.Zero) UCryptoAPI.CertFreeCertificateChain(hChain); } }</span></span></code> </pre></div></div><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, se forma una cadena usando el m√©todo BuildChain, y luego se verifica. </font><font style="vertical-align: inherit;">Durante la formaci√≥n de la cadena, se forman la estructura de par√°metros, la fecha de verificaci√≥n y las banderas de verificaci√≥n:</font></font></p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;    &lt;/summary&gt; * &lt;param name="_hChain"&gt;  &lt;/param&gt; * &lt;param name="_iRevFlag"&gt; &lt;/param&gt; * &lt;param name="_iRevMode"&gt; &lt;/param&gt; * &lt;param name="_hChainEngine"&gt; &lt;/param&gt; * &lt;param name="_hCert"&gt; &lt;/param&gt; * &lt;param name="_rCTLTimeOut"&gt;   &lt;/param&gt; * &lt;param name="_rOnDate"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildChain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hChainEngine, IntPtr _hCert, X509RevocationMode _iRevMode, X509RevocationFlag _iRevFlag, DateTime _rOnDate, TimeSpan _rCTLTimeOut, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntPtr _hChain, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)    if (_hCert == IntPtr.Zero) { _sError = UCConsts.S_CRYPTO_CERT_CHAIN_ERR; return UConsts.E_NO_CERTIFICATE; } // 1)  CERT_CHAIN_PARA pChainParams = new CERT_CHAIN_PARA(); pChainParams.cbSize = (uint) Marshal.SizeOf(pChainParams); IntPtr hAppPolicy = IntPtr.Zero; IntPtr hCertPolicy = IntPtr.Zero; try { // 2)    pChainParams.dwUrlRetrievalTimeout = (uint)Math.Floor(_rCTLTimeOut.TotalMilliseconds); // 3)   FILETIME pVerifyTime = new FILETIME(_rOnDate.ToFileTime()); // 4)   uint _iFlags = MapRevocationFlags(_iRevMode, _iRevFlag); // 5)   if (!UCryptoAPI.CertGetCertificateChain(_hChainEngine, _hCert, ref pVerifyTime, IntPtr.Zero, ref pChainParams, _iFlags, IntPtr.Zero, ref _hChain)) { _sError = UCConsts.S_CRYPTO_CHAIN_BUILD_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } } catch(Exception E) { _sError = UCConsts.S_CRYPTO_CHAIN_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { Marshal.FreeHGlobal(hAppPolicy); Marshal.FreeHGlobal(hCertPolicy); } return UConsts.S_OK; }</span></span></code> </pre></div></div><br><p>          ,    Microsoft.  hCertPolicy  hAppPolicy   OID-,    ,     .   ,  ,     . </p><br><p>            (,   ). </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MapRevocationFlags</a> ‚Äî      .Net   ‚Äî   uint    . </p><br><h3>  Conclusi√≥n </h3><br><p>               : </p><br><ol><li>  10 ; </li><li>  ; </li><li>  byte[] {1, 2, 3, 4, 5}; </li><li>   ; </li><li>   ; </li><li>  byte[] {1, 2, 3, 4, 5}; </li><li>   ; </li></ol><br><p>      Windows   Linux  1-, 10-  50- ,     Linux    .   Linux     -   -  (   ,    ),   ¬´¬ª .       (deadlock-)   (             ¬´Access Violation¬ª). </p><br><p>           UCryptoAPI    .     fpCPSection  object        : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> fpCPSection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_hCryptMsg"&gt;  &lt;/param&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CryptMsgClose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCryptMsg</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (pCPSection) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fIsLinux) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LCryptoAPI.CryptMsgClose(_hCryptMsg); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WCryptoAPI.CryptMsgClose(_hCryptMsg); } } <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;     &lt;/summary&gt;**/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> pCPSection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fpCPSection;} }</code> </pre><br><p>   ,         Linux- . </p><br><p>         mono     Issuer  Subject . , ,    mono   X500DistinguishedName    .  , mono      (     ),           (impl.issuerName  impl.subjectName).         (Reflection)      X500DistinguishedName,       CERT_CONTEXT . </p><br><h2>  Referencias </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>  CAPILite </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> c      # </li><li>  .Net: <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CAPIBase</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">X509Certificate2</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SignedCMS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SignerInfo</a> </li></ol><br></li><li>  mono: <br><ol><li>  <a href="">X509Certificate2</a> </li><li>  <a href="">X509CertificateImplBtls</a> </li></ol><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423163/">https://habr.com/ru/post/es423163/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423153/index.html">Gu√≠a de Node.js, Parte 2: JavaScript, V8, algunos trucos de desarrollo</a></li>
<li><a href="../es423155/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 8: Modelo de seguridad de red, parte 2</a></li>
<li><a href="../es423157/index.html">Usando la funci√≥n connect () de react-redux</a></li>
<li><a href="../es423159/index.html">¬°Feliz d√≠a del programador! Ama a tus desarrolladores</a></li>
<li><a href="../es423161/index.html">La empresa quiere datos personales</a></li>
<li><a href="../es423165/index.html">Dibujo din√°mico de malla en Unreal Engine 4</a></li>
<li><a href="../es423167/index.html">Lo que Mark Zuckerberg habla sobre los problemas de Facebook. Lo principal del art√≠culo de The New Yorker</a></li>
<li><a href="../es423169/index.html">Inicio del d√≠a (julio-agosto de 2018)</a></li>
<li><a href="../es423171/index.html">C√≥mo Discord sirve simult√°neamente 2.5 millones de chats de voz usando WebRTC</a></li>
<li><a href="../es423173/index.html">Tiempo m√≠nimo - dolor m√°ximo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>