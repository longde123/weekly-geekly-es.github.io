<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏽 🤳🏼 👩🏽‍🤝‍👩🏻 Bicara tentang PAKE 🏼 🐦 📟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sekarang mari kita bicara tentang keamanan informasi. Publikasi ini didedikasikan untuk peluncuran kursus "Keamanan Informasi Kriptografis" , yang aka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bicara tentang PAKE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/453334/">  Sekarang mari kita bicara tentang keamanan informasi.  Publikasi ini didedikasikan untuk peluncuran kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Keamanan Informasi Kriptografis"</a> , yang akan dimulai pada 30 Mei.  Ayo pergi. <br><br>  Aturan pertama PAKE: jangan pernah bicara tentang PAKE.  Aturan kedua PAKE menyatakan bahwa aturan pertama adalah omong kosong, karena PAKE atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Password Key Authenticated Key Exchange</a> (rus. Pertukaran kunci dengan otentikasi kata sandi) adalah salah satu teknologi paling berguna yang praktis tidak pernah digunakan di mana pun.  Ini harus dilaksanakan sedapat mungkin, tetapi tidak sesederhana itu. <br><br><img src="https://habrastorage.org/webt/gk/qt/xa/gkqtxaksei42embld2iyquekz44.png"><br><br><a name="habracut"></a><br>  Untuk memahami mengapa kita berbicara tentang omong kosong, mari kita lihat masalah sebenarnya. <br><br>  Misalkan saya bekerja dengan server yang menyimpan kata sandi pengguna.  Ada cara tradisional untuk menyimpan - hashing setiap kata sandi pengguna dan menyimpan hasilnya dalam basis data kata sandi.  Ada banyak ide tentang cara menangani proses hash.  Rekomendasi yang paling umum saat ini adalah menggunakan fungsi hashing kata sandi memory-hard (seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">scrypt</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">argon2</a> (dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">garam unik</a> ) untuk setiap kata sandi), dan kemudian menyimpan hasil hash.  Ada beberapa pendapat berbeda tentang fungsi hash mana yang harus digunakan dan apakah itu dapat menggunakan beberapa nilai rahasia (disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"pepper"</a> ), tetapi untuk saat ini kita tidak akan membicarakannya. <br><br>  Terlepas dari pendekatan yang Anda pilih, semua solusi ini memiliki satu kelemahan: <br>  <i>Ketika pengguna kembali untuk masuk ke situs, ia masih perlu mengirim kata sandi (terbuka) ke server untuk melakukan verifikasi</i> . <br><br>  Kebutuhan ini dapat menyebabkan konsekuensi yang tidak menyenangkan jika server Anda pernah dikompromikan atau jika pengembang Anda membuat beberapa kesalahan bodoh.  Misalnya, pada awal tahun lalu, Twitter meminta semua penggunanya (dan ini 330 juta!) Untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengubah kata sandi</a> - karena ternyata perusahaan tersebut menyimpan kata sandi teks (tanpa hash). <br><br>  Saat ini, masalah masuk tidak dengan cara apa pun bertentangan dengan manfaat hashing kata sandi.  Namun, Anda perlu menemukan solusi yang lebih baik: di mana kata sandi tidak akan pernah dikirim ke server dalam teks yang jelas.  Alat kriptografi yang akan membantu kita mencapai ini adalah PAKE, dan khususnya, protokol baru yang disebut OPAQUE, yang akan kita bahas di akhir artikel ini. <br><br><h2>  Apa itu PAKE? </h2><br>  Protokol PAKE, yang pertama kali diusulkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bellovin dan Merritt</a> , adalah sejenis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">protokol pertukaran kunci</a> .  Protokol pertukaran kunci (atau "perjanjian kunci") dirancang untuk membantu kedua pihak (sebut saja klien dan server) menyepakati kunci bersama menggunakan kriptografi kunci publik.  Protokol pertukaran kunci paling awal (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Diffie-Hellman</a> klasik) tidak sah, yang membuatnya rentan terhadap serangan seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">man-in-the-middle</a> .  Fitur khas dari protokol PAKE adalah klien mengautentikasi ke server dengan kata sandi.  Untuk alasan yang jelas, diasumsikan bahwa kata sandi atau hashnya sudah diketahui oleh server, yang memungkinkan verifikasi. <br><br>  Jika hanya itu yang dibutuhkan, protokol PAKE akan mudah dibangun.  Tetapi yang membuat PAKE sangat berguna adalah PAKE juga memberikan perlindungan kata sandi klien.  Jaminan yang lebih serius dapat dirumuskan sebagai berikut: setelah upaya untuk memasuki sistem (berhasil atau tidak berhasil), klien dan server hanya akan tahu jika kata sandi klien cocok dengan nilai yang diharapkan oleh server, dan tidak ada lagi informasi tambahan.  Ini adalah pertahanan yang cukup bagus.  Faktanya, ini tidak berbeda dari apa yang kami butuhkan dari bukti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengungkapan nol</a> . <br><br><img src="https://habrastorage.org/webt/fv/s6/kt/fvs6ktjjxphiyeae5k13gtw0w4y.png"><br><blockquote>  Representasi ideal dari protokol PAKE.  Input dari kedua sisi termasuk beberapa keacakan, yang tidak ditampilkan di sini.  Eavesdropper tidak perlu mengetahui kunci rahasia bersama K, yang itu sendiri acak dan bukan fungsi kata sandi. </blockquote><br>  Tentu saja, masalah nyata dengan PAKE adalah bahwa banyak pengembang tidak ingin menjalankan protokol "pertukaran kunci" sejak awal!  Mereka hanya ingin memastikan pengguna mengetahui kata sandi. <br><br>  Hal yang hebat tentang PAKE adalah bahwa use case "hanya login" cukup mudah dijalankan.  Misalkan saya memiliki protokol PAKE standar yang memungkinkan klien dan server menyetujui kunci umum K. Jika dia tahu kata sandi yang benar (dan hanya dalam hal ini), maka yang perlu kita implementasikan adalah pemeriksaan sederhana yang diterima kedua pihak kunci yang sama.  (Ini dapat dilakukan, misalnya, jika para pihak menggunakannya untuk menghitung beberapa fungsi kriptografi dan memverifikasi hasilnya.) Dengan demikian, PAKE dapat berguna bahkan jika Anda hanya ingin memverifikasi kata sandi. <br><br><h2>  SRP: PAKE, sekitar waktu itu sudah lupa </h2><br>  Konsep PAKE tampaknya memberikan keuntungan keamanan yang jelas atas pendekatan naif yang kita gunakan saat ini untuk memasuki server.  Dan metode itu sendiri sudah tua, dalam arti bahwa PAKE telah dikenal sejak 1992!  Meskipun demikian, cahaya tidak pernah melihatnya.  Mengapa ini terjadi? <br><br>  Ada beberapa alasan yang jelas.  Yang paling jelas terkait dengan keterbatasan Internet: jauh lebih mudah untuk meletakkan formulir kata sandi di halaman web daripada menerapkan kriptografi mewah di browser.  Namun, penjelasan ini tidak cukup.  Bahkan aplikasi asli jarang menerapkan PAKE untuk operasi login.  Penjelasan lain yang mungkin terkait dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paten</a> , meskipun sebagian besar sudah berakhir.  Bagi saya, ada dua kemungkinan alasan untuk tidak memiliki PAKE: <br><br><ul><li>  Kurangnya implementasi PAKE berkualitas tinggi dalam bahasa populer, yang membuatnya sulit untuk digunakan; </li><li>  Spesialis kriptografi tidak menyampaikan esensi dan nilai pekerjaan mereka dengan buruk, sehingga kebanyakan orang bahkan tidak tahu bahwa PAKE ada sama sekali. </li></ul><br>  Terlepas dari kenyataan bahwa saya mengatakan bahwa PAKE tidak digunakan sekarang, masih ada pengecualian pada aturan. <br><br>  Ada satu protokol hebat yang dikembangkan pada tahun 1998 oleh Tom Wu (jangan dikelirukan dengan Tim Wu), yang disebut "SRP" (kependekan dari "Secure Remote Password").  Faktanya, ini hanya PAKE tiga tahap dengan beberapa fungsi tambahan yang tidak diimplementasikan pada karya pertama.  Sejauh yang saya tahu, SRP berbeda karena itu adalah protokol PAKE paling umum di dunia.  Saya akan memberikan dua bukti dari pernyataan ini: <br><br><ol><li>  SRP distandarisasi sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ciphersuite TLS</a> dan diimplementasikan di perpustakaan seperti, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenSSL</a> , meskipun tampaknya tidak ada yang menggunakannya secara khusus. </li><li>  Apple menggunakan SRP secara ekstensif dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">iCloud Key Vault-nya</a> </li></ol><br>  Fakta kedua dengan sendirinya bisa menjadikan SRP salah satu protokol kriptografi yang paling banyak digunakan di dunia, jumlah perangkat yang perangko Apple begitu besar.  Dan tidak ada yang lucu. <br><br>  Fakta bahwa industri telah menerima SRP tentu baik, tetapi di sisi lain, dan tidak terlalu.  Sebagian besar karena meskipun dukungan PAKE keren, SRP sendiri bukan implementasi PAKE terbaik.  Saya berpikir untuk pergi ke hutan diskusi tentang SRP, tetapi pidato ini sudah berjalan lama, dan saya menyimpang dari cerita tentang protokol yang sangat bagus, yang akan kita bicarakan di bawah ini.  Jika Anda masih tertarik dengan diskusi tentang SRP, saya membawanya ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Alih-alih detail yang tidak perlu ini, izinkan saya menulis ringkasan singkat tentang pemikiran saya tentang SRP: <br><br><ol><li>  SRP melakukan beberapa hal dengan benar.  Pertama, tidak seperti PAKE versi sebelumnya, Anda tidak perlu menyimpan kata sandi mentah di server (atau, yang setara, hash yang dapat digunakan oleh penyerang alih-alih kata sandi).  Sebagai gantinya, server menyimpan "verifier," yang merupakan fungsi satu arah dari hash kata sandi.  Ini berarti bahwa kebocoran basis data kata sandi tidak memungkinkan penyerang untuk segera mengganti pengguna hanya jika ia tidak melakukan serangan kamus yang lebih mahal.  (Nama teknis untuk ini adalah PAKE “asimetris”.) </li><li>  Ada berita yang lebih baik, versi SRP saat ini (v4 v6a) belum diretas! </li><li>  Namun (jangan tersinggung oleh pengembang) arsitektur protokol SRP benar-benar gila, dan versi sebelumnya diretas beberapa kali - itulah sebabnya kami sekarang memiliki versi 6a.  Plus, "bukti keselamatan" dalam artikel penelitian asli sebenarnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak membuktikan apa-apa</a> . </li><li>  SRP saat ini didasarkan pada bilangan bulat (akhir), dan karena berbagai alasan (lihat ayat 3 di atas) arsitekturnya jelas tidak dapat ditransfer ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kurva</a> elips.  Ini membutuhkan lebih banyak bandwidth dan perhitungan, sehingga SRP tidak dapat mengambil keuntungan dari banyak peningkatan kinerja yang telah kami kembangkan dalam pengaya seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Curve25519</a> . </li><li>  SRP rentan terhadap serangan pra-komputasi karena memberikan garam pengguna kepada penyerang yang dapat memulai sesi SRP.  Ini berarti bahwa saya dapat meminta server untuk garam Anda dan membangun kamus hash kata sandi potensial sebelum server dikompromikan. </li><li>  Terlepas dari semua kekurangan ini, SRP sangat sederhana, dan juga dilengkapi dengan kode kerja.  Selain itu, OpenSSL memiliki kode kerja yang bahkan terintegrasi dengan TLS, yang membuatnya relatif mudah diimplementasikan. </li></ol><br>  Dari semua poin ini, yang terakhir hampir pasti bertanggung jawab atas (relatif) tingkat keberhasilan komersial yang SRP raih dibandingkan protokol PAKE lainnya.  Dia tidak sempurna, tetapi nyata.  Inilah yang ingin saya sampaikan kepada pakar keamanan kriptografi. <br><br><h2>  OPAQUE: PAKE generasi baru </h2><br>  Ketika saya mulai berpikir tentang PAKE beberapa bulan yang lalu, saya tidak bisa tidak mencatat bahwa sebagian besar implementasi yang ada berkinerja buruk.  Mereka juga memiliki masalah, seperti dalam SRP, baik mengharuskan pengguna untuk menyimpan kata sandi (atau kata sandi efektif) di server, atau "garam" ditunjukkan kepada penyerang, memberikan kesempatan untuk melakukan serangan sebelum menghitung. <br><br>  Kemudian, pada awal tahun lalu, Jarecki, Kravczyk dan Xu mengungkapkan kepada dunia sebuah protokol baru yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OPAQUE</a> .  Ini memiliki sejumlah keunggulan signifikan: <br><br><ol><li>  Itu dapat diimplementasikan bahkan jika ada masalah Diffie-Hellman dan logaritma diskrit.  Ini berarti bahwa, tidak seperti SRP, ia dapat dengan mudah dipakai menggunakan kurva elips yang efektif. </li><li>  Bahkan lebih baik: OPAQUE tidak mengungkapkan garam kepada penyerang.  Dia memecahkan masalah ini dengan menggunakan "PRF pelupa" untuk menggabungkan garam dengan kata sandi sehingga klien tidak menerima garam dan server tidak menerima kata sandi. </li><li> OPAQUE berfungsi dengan fungsi hashing kata sandi apa pun.  Karena semua pekerjaan hashing dilakukan pada klien, OPAQUE sebenarnya dapat mengambil beban dari server, membebaskan layanan online, misalnya, untuk menggunakan pengaturan keamanan yang sangat produktif, misalnya, mengkonfigurasi <code>scrypt</code> dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak RAM</a> . </li><li>  Dalam hal jumlah dan eksponen pesan, OPAQUE tidak jauh berbeda dengan SRP.  Tetapi karena ini dapat diimplementasikan dengan parameter yang lebih efisien, kemungkinan akan bekerja jauh lebih efisien. </li><li>  Tidak seperti SRP, OPAQUE memiliki bukti keamanan yang masuk akal (dalam model yang sangat kuat). </li></ol><br>  Bahkan ada proposal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Internet Draft</a> untuk OPAQUE, yang bisa Anda baca di sini.  Sayangnya, saat ini saya tidak tahu apa-apa tentang kualitas implementasi kode, kecuali bahwa sudah ada beberapa implementasi potensial.  Saya harap masalah ini segera beres. <br>  Protokol OPAQUE lengkap tercantum di bawah ini.  Di sisa bagian ini, saya akan berbicara tentang cara kerjanya. <br><br>  <b>Masalah 1: Menjaga garam tetap rahasia.</b>  Seperti yang saya sebutkan di atas, masalah utama dengan PAKE versi sebelumnya adalah kebutuhan untuk mentransfer garam dari server ke klien (masih belum diautentikasi).  Ini memungkinkan penyerang melakukan serangan sebelum menghitung di mana ia dapat membuat kamus berdasarkan data yang diterima. <br><br>  Masalahnya di sini adalah bahwa garam biasanya diteruskan ke fungsi hash (mis. Scrypt) bersama dengan kata sandi.  Secara intuitif, seseorang perlu menghitung fungsi ini.  Jika itu adalah server, maka server akan melihat kata sandi, yang membunuh makna apa pun.  Jika ini klien, maka dia butuh garam. <br><br>  Secara teoritis, Anda dapat mengatasi masalah ini dengan menghitung fungsi hashing kata sandi menggunakan protokol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komputasi dua pihak yang aman (2PC)</a> .  Dalam praktiknya, solusi semacam itu hampir pasti tidak akan efektif, terutama karena fungsi hashing kata sandi rumit dan menghabiskan waktu.  Ini akan sangat meningkatkan kompleksitas sistem 2PC mana pun. <br><br>  OPAQUE menjalankannya sebagai berikut.  Itu meninggalkan hash kata sandi di sisi klien, tetapi tidak menunjukkan garam.  Sebagai gantinya, ia menggunakan protokol dua arah khusus yang disebut PRF pelupa untuk menghitung garam lain (sebut saja itu salt2) sehingga klien dapat menggunakan salt2 dalam fungsi hash tetapi tidak dapat mengakses garam asli. <br><br>  Ini berfungsi seperti ini: <br><blockquote>  <i>Server menyimpan "garam", dan klien memiliki kata sandi.salt2 = PRF (garam, kata sandi), ini dihitung antara klien dan server menggunakan protokol di mana klien tidak akan pernah mengenali garam dan server akan mengetahui kata sandi.</i>  <i>Klien menerima salt2K = PasswordHash (salt2, kata sandi) - dan semua ini dipertimbangkan pada klien.</i> </blockquote><br>  Implementasi aktual dari pelupa PRF dapat dilakukan dengan menggunakan beberapa elemen kelompok dan eksponen.  Bahkan lebih baik, jika klien memasukkan kata sandi yang salah, maka protokol menerima nilai dummy "salt2", yang tidak mengatakan apa-apa tentang nilai sebenarnya dari garam. <br><br>  <b>Masalah 2: Bukti bahwa klien menerima kunci yang benar K.</b> Tentu saja, saat ini klien telah menerima kunci K, tetapi server tidak tahu apa itu.  Server juga tidak tahu apakah ini kunci yang benar. <br><br>  Solusi OPAQUE didasarkan pada ide lama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gentry, Mackenzie dan Ramzan</a> .  Ketika pengguna pertama kali masuk ke server, server menghasilkan kunci publik dan pribadi yang dapat diandalkan untuk protokol perjanjian aman (misalnya, HMQV) dan mengenkripsi kunci pribadi yang diterima di bawah K bersama dengan kunci publik server.  Hasil cipher terotentikasi (dan kunci publik) disimpan dalam basis data kata sandi. <br><br>  <b><i>C = Enkripsi (K, kunci rahasia klien | kunci publik server)</i></b> <br><br><img src="https://habrastorage.org/webt/9z/tb/uk/9ztbukhcywebjlgyrlbbaltk-0a.png"><br>  <i>Versi lengkap dari protokol OPAQUE, kutipan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> .</i> <br><br>  Ketika klien ingin mengautentikasi menggunakan protokol OPAQUE, server mengirimkan kode <b>C yang</b> tersimpan.  Jika klien memasukkan kata sandi yang benar pada tahap pertama, ia bisa mendapatkan <b>K</b> , dan mendekripsi sandi ini.  Kalau tidak, itu tidak berguna.  Menggunakan kunci rahasia kabel, dia sekarang dapat menjalankan protokol perjanjian standar dengan kunci yang diautentikasi untuk menyelesaikan jabat tangan.  (Server memeriksa input klien dengan memeriksa mereka terhadap salinan kunci publik klien, dan klien melakukan hal yang sama.) <br><br>  <b>Sekarang mari kita kumpulkan semuanya.</b>  Semua langkah ini dapat digabungkan menjadi satu protokol, yang memiliki jumlah langkah yang sama dengan SRP.  Jika Anda tidak memperhatikan langkah-langkah verifikasi, itu akan terlihat seperti protokol di atas.  Pada prinsipnya, idenya hanya dalam dua pesan: satu dari klien, dan yang kedua dikirim kembali ke server. <br><br>  Aspek terakhir dari karya OPAQUE adalah bahwa ia memiliki bukti keamanan yang baik yang memberitahu kita bahwa protokol yang dihasilkan dapat dianggap aman jika kita mengambil satu atau lebih logaritma diskrit dalam model oracle acak, yang merupakan asumsi standar, yang tampaknya merupakan asumsi standar, yang tampaknya , terjadi di pengaturan yang kami gunakan. <br><br><h2>  Kesimpulan </h2><br>  Jadi, singkatnya, kami memiliki teknologi andal yang dapat membuat proses penggunaan kata sandi jauh lebih mudah, dan juga memungkinkan kami untuk menanganinya dengan lebih efisien - dengan banyak parameter hashing dan lebih banyak beban kerja di sisi klien.  Mengapa ini tidak digunakan di mana-mana?  Mungkin dalam beberapa tahun ke depan semuanya akan berubah.  Waktu akan memberi tahu. <br><br>  Menurut tradisi yang ada, kami menunggu komentar Anda dan mengundang Anda untuk mengunjungi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hari buka pintu</a> , yang akan diadakan pada tanggal 27 Mei oleh guru kami, cryptanalyst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Elena Kirshanova</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453334/">https://habr.com/ru/post/id453334/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453324/index.html">Diode sebagai penyearah</a></li>
<li><a href="../id453326/index.html">Cara mengotomatisasi manajemen infrastruktur TI - bahas tiga tren</a></li>
<li><a href="../id453328/index.html">Sepuluh tahun di situs terpencil</a></li>
<li><a href="../id453330/index.html">Apa yang harus dilakukan jika RAM rusak. Anamnesis dan metode perawatan</a></li>
<li><a href="../id453332/index.html">Tentang metode aneh menghemat ruang hard disk</a></li>
<li><a href="../id453336/index.html">Panduan Pemilihan Mesin Pembakaran CNC</a></li>
<li><a href="../id453338/index.html">Rust 1.35.0 Rilis: Implementasi Karakter Fungsional dan Inovasi Lainnya</a></li>
<li><a href="../id453340/index.html">Perl 5.30 dirilis</a></li>
<li><a href="../id453342/index.html">Mitos tentang karyawan jarak jauh yang kami hancurkan sendiri</a></li>
<li><a href="../id453346/index.html">Teknologi penyimpanan dan perlindungan data - hari ketiga di VMware EMPOWER 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>