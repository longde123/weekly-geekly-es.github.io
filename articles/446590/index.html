<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüç≥ üëàüèº üö∂üèº 39 nuevas funciones estar√°n disponibles en Java 12 ü¶ë ‚ô®Ô∏è üôÖüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De una maravillosa entrevista sobre Habr√©: "Simon Ritter es una persona que trabaj√≥ en Java desde el principio y contin√∫a haciendo esto como subdirect...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>39 nuevas funciones estar√°n disponibles en Java 12</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446590/"><blockquote>  De una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">maravillosa entrevista</a> sobre Habr√©: "Simon Ritter es una persona que trabaj√≥ en Java desde el principio y contin√∫a haciendo esto como subdirector t√©cnico de Azul, una empresa que trabaja en la m√°quina virtual Zing JVM y uno de los mejores recolectores de basura, C4 (Compactaci√≥n continua simult√°nea) Coleccionista) ¬ª <br>  A continuaci√≥n se muestra una traducci√≥n de su art√≠culo sobre las nuevas caracter√≠sticas de JDK 12 y algunas dificultades que puede encontrar al migrar a una nueva compilaci√≥n. </blockquote><p> Escrib√≠ varias publicaciones de blog que enumeran todos los cambios para cada una de las √∫ltimas versiones de Java ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JDK 10</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JDK 11</a> ).  Ahora explorar√© el lado oscuro de JDK 12, centr√°ndome en algunas de las trampas que pueden causar problemas si quieres portar la aplicaci√≥n a esta versi√≥n. </p><br><img src="https://habrastorage.org/webt/0e/rn/j0/0ernj0wwnqnwdejls6zvzjup5k8.png"><br><p><a name="habracut"></a>  JDK 12 tiene la menor cantidad de nuevas caracter√≠sticas de todas las versiones de Java hasta la fecha (cont√© 109 en JDK 10 y 90 en JDK 11).  Esto no est√° mal: debido a los ciclos de lanzamiento, algunas versiones contendr√°n m√°s cambios y otras menos. </p><br><p>  Dividir√© nuevas funciones en √°reas l√≥gicas obvias: Java, bibliotecas, JVM y otras funciones JDK. </p><br><h2>  Cambios de idioma </h2><br><p>  La funci√≥n que yo (y supongo que muchas otras personas) considerar√© m√°s visible en JDK 12 es la nueva declaraci√≥n de cambio ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JEP 325</a> ).  Este es tambi√©n el primer cambio de idioma que se utilizar√° como una funci√≥n para "previsualizar".  La idea de "vista previa" se introdujo a principios de 2018 como parte de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JEP 12</a> .  Esta es esencialmente una forma de habilitar versiones beta de nuevas caracter√≠sticas usando las opciones de l√≠nea de comandos.  Con la vista previa, a√∫n es posible realizar cambios basados ‚Äã‚Äãen los comentarios de los usuarios y, en el peor de los casos, eliminar por completo una funci√≥n si no se recibi√≥ correctamente.  La clave para previsualizar las funciones es que no est√°n incluidas en la especificaci√≥n Java SE.  Sobre el nuevo interruptor hay una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">muy buena traducci√≥n</a> en Habr√©. <br>  En JDK 12, un interruptor se ha convertido en una expresi√≥n que eval√∫a su "contenido" para producir un resultado.  Explicar√© de inmediato que esto no afecta la compatibilidad con versiones anteriores, por lo que no necesita cambiar ning√∫n c√≥digo que use switch como operador. </p><br><p>  Usar√© el ejemplo de JEP, ya que es simple y claro: </p><br><div class="spoiler">  <b class="spoiler_title">Interruptor viejo</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numLetters; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (day) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MONDAY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FRIDAY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SUNDAY: numLetters = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TUESDAY: numLetters = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> THURSDAY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SATURDAY: numLetters = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WEDNESDAY: numLetters = <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Huh? "</span></span> + day); }</code> </pre> </div></div><br><p>  Como puede ver, asignamos el d√≠a de la semana al nombre del <code>day</code> variable, luego asignamos el valor <code>numLetters</code> .  Ahora que ese interruptor es un operador, podemos hacer la asignaci√≥n una vez (reduciendo significativamente la probabilidad de un c√≥digo err√≥neo) usando el resultado de la declaraci√≥n del interruptor: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numLetters = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (day) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MONDAY, FRIDAY, SUNDAY -&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TUESDAY -&gt; <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> THURSDAY, SATURDAY -&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WEDNESDAY -&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Huh? "</span></span> + day); };</code> </pre> <br><p>  Notar√° r√°pidamente dos cambios de sintaxis.  Los desarrolladores de OpenJDK se toparon con una funci√≥n de sintaxis poco conocida llamada lista separada por comas.  Adem√°s, el operador de expresi√≥n lambda <code>-&gt;</code> facilita la devoluci√≥n del valor.  Todav√≠a puedes usar <code>break</code> con un valor si realmente quieres esto.  Hay varios otros detalles sobre esta caracter√≠stica, pero probablemente sea m√°s f√°cil leer JEP. </p><br><h2>  Bibliotecas </h2><br><p>  Hay un cambio que me parece muy √∫til.  Tambi√©n hay una serie de secundarios. </p><br><h3>  colector de tee </h3><br><p>  La API de Streams, como de costumbre, tiene un nuevo recopilador, proporcionado por la clase de utilidad de recopiladores.  Se puede obtener un nuevo colector utilizando el m√©todo <code>teeing()</code> .  El colector de salida toma tres argumentos: dos colectores y una bifunci√≥n.  Para comprender el trabajo de este coleccionista, recomiendo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este art√≠culo sobre Habr√©</a> . <br>  Para entender c√≥mo hace esto, dibuj√© un diagrama: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/821/2db/503/8212db5034c04db49aed57dd44697b22.jpg" alt="imagen"><br><p>  Todos los valores de la secuencia de entrada se pasan a cada recopilador.  El resultado de cada recopilador se pasa como argumentos a BiFunction para generar el resultado final. </p><br><p>  Un ejemplo simple es calcular el valor promedio (s√≠, s√© que ya hay recolectores para esto, como <code>averagingInt()</code> , pero este es un ejemplo simple para ayudar a comprender el concepto). </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* Assume Collectors is statically imported */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> average = Stream.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) .collect(teeing( summingDouble(i -&gt; i), counting(), (sum, n) -&gt; sum / n) );</code> </pre> <br><p>  El primer recopilador calcula la suma de la secuencia de entrada y el segundo, el n√∫mero de elementos.  BiFunction divide la suma por el n√∫mero de elementos para obtener el valor promedio. </p><br><h3>  java.io </h3><br><p>  <code>InputStream skipNBytes(long n)</code> : omite y descarta exactamente n bytes del flujo de entrada InputStream.  Si n es cero o menos, los bytes no se omiten. </p><br><h3>  java.lang </h3><br><p>  Ha aparecido un nuevo paquete, java.lang.constant, que forma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte de la API JVM constante, JEP 334</a> . </p><br><p>  Cada archivo de clase Java tiene un grupo persistente que almacena operandos para instrucciones de c√≥digo de bytes en la clase.  Es dif√≠cil para los desarrolladores manipular archivos de clase debido a problemas al cargar clases.  La API JVM constante proporciona tipos de referencia simb√≥licos para describir cada forma de una constante (clase, constante cargable, <code>MethodHandle</code> , <code>MethodHandle</code> constante, <code>MethodType</code> constante). </p><br><p>  Tambi√©n influy√≥ en varias otras clases.  Todas las siguientes clases ahora tienen un m√©todo <code>describeConstable()</code> : </p><br><ul><li>  Clase </li><li>  Doble </li><li>  Enum </li><li>  Flotador </li><li>  Entero </li><li>  Largo </li><li>  Cadena </li><li>  Metodolog√≠a </li><li>  MethodType </li><li>  Varhandle </li></ul><br><p>  Como brit√°nico, me parece bastante divertido.  El t√©rmino Constable, <code>describeConstable</code> usado desde el siglo XI, y as√≠ es como a menudo nos referimos a los oficiales de polic√≠a.  Tambi√©n es el nombre del famoso artista del siglo XVIII, John Constable.  Esto me hace preguntarme si el m√©todo <code>describeTurner()</code> estar√° en una versi√≥n futura.  Obviamente, en este caso es una abreviatura de la <code>Constant Table</code> , no relacionada con un oficial de leyes o un paisajista. </p><br><p>  Las siguientes clases ahora incluyen el m√©todo <code>resolveConstantDesc()</code> : </p><br><ul><li>  Doble </li><li>  Enum.EnumDesc </li><li>  Flotador </li><li>  Entero </li><li>  Largo </li><li>  Cadena </li></ul><br><h3>  java.lang.Character </h3><br><p>  Las clases internas se han actualizado para incluir nuevos bloques Unicode.  Siempre me gusta ver lo que la gente ha encontrado para agregar a Unicode, aqu√≠ hay algunos ejemplos: </p><br><ul><li>  S√≠mbolos de ajedrez </li><li>  Numeros mayas </li><li>  El sogdiano es un idioma iran√≠ oriental que ya no se usaba en el siglo XI. </li><li>  Old Sogdian es una versi√≥n anterior (y, sospecho, a√∫n m√°s limitada) de Sogdian </li></ul><br><h3>  java.lang.Class </h3><br><p>  <code>arrayType()</code> devuelve <code>Class</code> para el tipo de matriz cuyo tipo de componente se describe en esta <code>Class</code> .  Esto se puede verificar usando <code>jshell</code> : </p><br><pre> <code class="bash hljs">jshell&gt; (new String[2]).getClass().getName() <span class="hljs-variable"><span class="hljs-variable">$11</span></span> ==&gt; <span class="hljs-string"><span class="hljs-string">"[Ljava.lang.String;"</span></span> jshell&gt; (new String[2]).getClass().arrayType() <span class="hljs-variable"><span class="hljs-variable">$12</span></span> ==&gt; class [[Ljava.lang.String; jshell&gt; <span class="hljs-string"><span class="hljs-string">"foo"</span></span>.getClass().arrayType() <span class="hljs-variable"><span class="hljs-variable">$15</span></span> ==&gt; class [Ljava.lang.String;</code> </pre> <br><p>  No estoy muy seguro de cu√°l es el significado de este m√©todo, ya que todo lo que hace es agregar una <code>Class</code> al tipo que representa esta clase. </p><br><p>  <code>componentType()</code> , igual que <code>getComponentType()</code> .  La pregunta comienza: ¬øpor qu√© agregar un m√©todo redundante? </p><br><p>  <code>descriptorString()</code> : nuevamente, devuelve el mismo resultado que <code>getName()</code> .  Sin embargo, es necesario porque <code>Class</code> ahora implementa la interfaz <code>TypeDescriptor</code> asociada con la nueva API JVM constante. </p><br><h3>  lava.lang.String </h3><br><p>  <code>indent()</code> : agrega una serie de espacios iniciales a una cadena.  Si el par√°metro es negativo, este n√∫mero de espacios iniciales se eliminar√° (si es posible). </p><br><p>  <code>transform()</code> : aplica la funci√≥n proporcionada a una cadena.  El resultado puede no ser una cadena. </p><br><h3>  java.lang.invoke </h3><br><p>  <code>VarHandle</code> ahora tiene <code>toString()</code> para devolver una descripci√≥n compacta. </p><br><p>  <code>java.net.SecureCacheResponse</code> y <code>java.net.ssl.HttpsConnection</code> tienen un nuevo m√©todo, <code>getSSLSession()</code> que devuelve <code>Optional</code> contiene la <code>SSLSession</code> utilizada en la conexi√≥n. </p><br><h3>  java.nio.files </h3><br><p>  La clase <code>Files</code> tiene un nuevo m√©todo, <code>mismatch()</code> , que encuentra y devuelve la posici√≥n del primer byte de discordancia en el contenido de dos archivos, o -1L si no hay discordancia. </p><br><h3>  java.text </h3><br><p>  Hay una nueva clase <code>CompactNumberFormat</code> .  Esta es una subclase de <code>NumberFormat</code> que formatea un n√∫mero decimal en forma compacta.  Un ejemplo de una forma compacta, <code>1M</code> lugar de <code>1000000</code> , por lo tanto, requiere dos en lugar de nueve caracteres.  <code>NumberFormat</code> y <code>java.text.spi.NumberFormatProvider</code> se han ampliado para incluir el nuevo m√©todo <code>getCompactNumberInstance()</code> .  Tambi√©n hay una nueva enumeraci√≥n, <code>NumberFormatStyle</code> que tiene dos significados: LARGO y CORTO. </p><br><h3>  java.util.concurrent </h3><br><p>  CompletionStage ahora incluye varios formularios sobrecargados con tres m√©todos: </p><br><ul><li>  excepcionalmente </li><li>  excepcionalmente </li><li>  excepcionalmenteComposeAsync </li></ul><br><p>  Estos m√©todos ampl√≠an las posibilidades de crear un nuevo <code>CompletionStage</code> partir de uno existente, <code>CompletionStage</code> si el actual finaliza con una excepci√≥n.  Consulte la documentaci√≥n de la API para m√°s detalles. </p><br><h3>  javax.crypto </h3><br><p>  La clase <code>Cipher</code> tiene un nuevo m√©todo <code>toString()</code> que devuelve una cadena que contiene la transformaci√≥n, el modo y el proveedor de <code>Cipher</code> . </p><br><h3>  javax.naming.ldap.spi </h3><br><p>  Este es un nuevo paquete en JDK 12 y contiene dos clases: <code>LdapDnsProvider</code> , que es la clase de proveedor para las b√∫squedas de DNS durante las operaciones LDAP, y <code>LdapDnsProviderResults</code> que encapsula el resultado de la b√∫squeda de DNS para la URL de LDAP. </p><br><h3>  Columpio </h3><br><p>  Swing todav√≠a se est√° actualizando!  S√≠, <code>filechooser.FileSystemView</code> ahora tiene un nuevo m√©todo <code>getChooserShortcutPanelFiles()</code> .  Devuelve una matriz de archivos que representan los valores para mostrar de forma predeterminada en la barra de acceso directo de selecci√≥n de archivos. </p><br><h2>  JVM cambios </h2><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JEP 189: Shenandoah</a> : recolector de basura de tiempo de pausa bajo </h3><br><p>  Shenandoah es un proyecto de investigaci√≥n anunciado por Red Hat en 2014 que se centra en los requisitos de aplicaciones de baja latencia para la administraci√≥n de memoria en la JVM.  Sus objetivos son un tiempo de pausa m√°ximo de 1..10 ms para un mont√≥n de m√°s de 20 GB ( <del>  por lo tanto no est√° destinado a aplicaciones peque√±as </del>  - como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">respondi√≥ uno de los desarrolladores de Shenandoah</a> , esto no es as√≠ y hace un excelente trabajo con peque√±as aplicaciones).  Este recolector est√° dise√±ado para funcionar en paralelo con subprocesos de aplicaciones, por lo tanto, evite los problemas que vemos en la mayor√≠a de los recolectores de basura. </p><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JEP 344: Colecciones mixtas G1</a> </h3><br><p>  Este cambio est√° destinado a mejorar el comportamiento del recopilador G1 cuando alcanza el objetivo de retraso establecido.  G1 divide el espacio de almacenamiento din√°mico (antiguo y antiguo) en regiones.  La idea es que en la generaci√≥n anterior no es necesario recolectar basura en una sola operaci√≥n.  Cuando G1 necesita recolectar basura, selecciona las regiones que define.  Esto se llama un kit de recolecci√≥n.  Antes de JDK 12, cuando comenz√≥ el trabajo en el set, todo el trabajo ten√≠a que completarse, en esencia, como una operaci√≥n at√≥mica.  El problema era que, a veces, debido a cambios en el uso del espacio de almacenamiento din√°mico de la aplicaci√≥n, el conjunto de recopilaci√≥n result√≥ ser demasiado grande y tard√≥ demasiado tiempo en recopilarse, lo que llev√≥ al hecho de que no se alcanz√≥ el tiempo de pausa. </p><br><p>  En JDK 12, si G1 identifica esta situaci√≥n, interrumpir√° la recopilaci√≥n de datos hasta la mitad si esto no afecta la capacidad de la aplicaci√≥n para continuar asignando espacio para nuevos objetos.  El efecto neto de G1 ser√° mejor cuando se alcanza un breve tiempo de pausa. </p><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JEP 346: devuelve r√°pidamente la memoria asignada no utilizada de G1</a> </h3><br><p>  Esta es otra mejora de rendimiento para G1, pero otra est√° relacionada con la forma en que la JVM interact√∫a con el resto del sistema.  Obviamente, se necesita memoria para el mont√≥n JVM, y al inicio, solicita memoria del asignador de memoria virtual del sistema operativo.  Cuando se inicia la aplicaci√≥n, puede haber ocasiones en que la cantidad de memoria requerida para el almacenamiento din√°mico caiga, y parte de la memoria asignada se puede devolver al sistema operativo para que otras aplicaciones la utilicen. </p><br><p>  G1 ya hace esto, pero solo puede hacerlo en uno de dos lugares.  Primero, durante una colecci√≥n completa, y segundo, durante uno de los ciclos paralelos.  G1 intenta no realizar una recopilaci√≥n completa y, con un uso bajo de memoria, puede haber per√≠odos significativos entre los ciclos de recopilaci√≥n.  Esto lleva al hecho de que G1 puede mantener una memoria fija durante mucho tiempo. </p><br><p>  En JDK 12, G1 intentar√° peri√≥dicamente continuar o ejecutar un ciclo paralelo mientras la aplicaci√≥n est√° inactiva para determinar el uso general del mont√≥n de Java.  La memoria no utilizada se puede devolver al sistema operativo de manera m√°s oportuna y predecible. </p><br><p>  El nuevo indicador de l√≠nea de comando <code>-XX:G1PeriodicGCInterval</code> se puede usar para establecer el n√∫mero de milisegundos entre las comprobaciones. </p><br><p>  Esta caracter√≠stica conducir√° a un uso m√°s conservador de la memoria JVM para aplicaciones que han estado inactivas por largos per√≠odos de tiempo. </p><br><h2>  Otras nuevas caracter√≠sticas de JDK </h2><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JEP 230: Kit de microbenchmarking</a> </h3><br><p>  El arn√©s de microbenchmarking de Java (JMH) fue desarrollado por Alexey Shipilev cuando trabajaba en Oracle y proporciona una amplia plataforma para desarrollar pruebas de rendimiento para aplicaciones Java.  Alexey hizo un trabajo excepcional ayudando a las personas a evitar muchos errores simples que cometen al tratar de analizar el rendimiento de la aplicaci√≥n: calentamiento, evitar excepciones, etc. </p><br><p>  Ahora JMH se puede incluir en OpenJDK.  Cualquiera que est√© interesado en trabajar en el JDK y cambiar el c√≥digo puede usar esto para comparar el rendimiento antes y despu√©s de sus cambios, as√≠ como para comparar el rendimiento en diferentes versiones.  Se incluyen varias pruebas para permitir la prueba;  El dise√±o de JMH es tal que es f√°cil agregar nuevas pruebas donde se necesita. </p><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JEP 340: un puerto Aarch64, no dos</a> </h3><br><p>  OpenJDK tiene dos puertos para la arquitectura Arm64, uno proporcionado por Oracle y el otro por Red Hat.  Como esto no era necesario, y Oracle dej√≥ de admitir Arm para sus archivos binarios JDK, se decidi√≥ usar solo el puerto Red Hat, que todav√≠a es compatible y desarrollado. </p><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JEP 341: archivos CDS predeterminados</a> </h3><br><p>  La clase Data Sharing (CDS) sol√≠a ser una caracter√≠stica comercial en Oracle JDK.  Con una transici√≥n reciente realizada en JDK 11 para eliminar todas las diferencias funcionales entre Oracle JDK y OpenJDK, se incluy√≥ en OpenJDK. </p><br><p>  Para usar CDS, necesita un archivo creado para las clases que se cargan cuando se inicia la aplicaci√≥n.  JDK 12 para plataformas de 64 bits ahora tiene el archivo <code>classes.jsa</code> en el directorio <code>lib/server</code> .  Este es el archivo CDS para "clases predeterminadas".  Supongo que significa todas las clases p√∫blicas en m√≥dulos JDK;  No pude encontrar una manera de desempacarlo para verificarlo.  Como CDS est√° habilitado de forma predeterminada, lo que equivale a la opci√≥n <code>-Xshare:auto</code> en la l√≠nea de comandos, los usuarios se beneficiar√°n de los tiempos de inicio de aplicaciones mejorados. </p><br><h2>  Conclusiones </h2><br><p>  JDK 12 proporciona una peque√±a cantidad de nuevas funciones y API, siendo la <code>switch</code> la m√°s interesante para los desarrolladores.  Los usuarios de G1 seguramente apreciar√°n las mejoras de rendimiento. </p><br><p>  Con la nueva versi√≥n del lanzamiento, recomendar√≠a a todos los usuarios que prueben sus aplicaciones en este lanzamiento.  Hacer un seguimiento de los cambios incrementales lo ayudar√° a evitar sorpresas si decide pasar a la pr√≥xima versi√≥n de soporte a largo plazo. </p><br><p>  Tenemos compilaciones gratuitas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JDK 12 para Zulu Community Edition</a> para ayudarte con tus pruebas.  Aseg√∫rate de probarlos. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446590/">https://habr.com/ru/post/446590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446572/index.html">Editor.js es un excelente editor que guarda el c√≥digo fuente en formato JSON</a></li>
<li><a href="../446576/index.html">Sustituci√≥n de importaciones, o c√≥mo los helic√≥pteros rusos hicieron algo mal</a></li>
<li><a href="../446578/index.html">Lenguaje de programaci√≥n basado en postales</a></li>
<li><a href="../446582/index.html">Reflexiones sobre el alojamiento solar para abejas</a></li>
<li><a href="../446588/index.html">Comprobaci√≥n del c√≥digo fuente de Roslyn</a></li>
<li><a href="../446592/index.html">Comprobando el c√≥digo fuente de Roslyn</a></li>
<li><a href="../446598/index.html">Recreando Fuentes CRT</a></li>
<li><a href="../446602/index.html">Corriente DC m√°xima a trav√©s del transistor de efecto de campo</a></li>
<li><a href="../446604/index.html">ESET: Nuevos esquemas de entrega de puerta trasera Oceanberg de Cybergroup</a></li>
<li><a href="../446606/index.html">Comprueba lo bueno que eres en tecnolog√≠a aditiva</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>