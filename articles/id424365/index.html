<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👢 ❤️ 📘 Cara kerja stack trace pada ARM 🤹🏿 😦 😼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat siang Beberapa hari yang lalu saya mengalami masalah kecil dalam proyek kami - di interrupt handler gdb, stack stack untuk Cortex-M ditampilka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara kerja stack trace pada ARM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/424365/">  Selamat siang  Beberapa hari yang lalu saya mengalami masalah kecil dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek kami</a> - di interrupt handler gdb, stack stack untuk Cortex-M ditampilkan secara tidak benar.  Oleh karena itu, sekali lagi berguna untuk mencari tahu, dan dengan cara apa saya bisa mendapatkan jejak stack untuk ARM?  Apa flag kompilasi yang memengaruhi keterlacakan stack pada ARM?  Bagaimana ini diterapkan di kernel Linux?  Berdasarkan penelitian, saya memutuskan untuk menulis artikel ini. <br><a name="habracut"></a><br>  Mari kita lihat dua metode jejak tumpukan utama di kernel Linux. <br><br><h4>  Tumpuk bersantai melalui bingkai </h4><br>  Mari kita mulai dengan pendekatan sederhana yang dapat ditemukan di kernel Linux, tetapi yang saat ini memiliki status usang dalam GCC. <br><br>  Bayangkan bahwa suatu program sedang berjalan pada stack dalam RAM, dan pada titik tertentu kita menghentikannya dan ingin memunculkan stack panggilan.  Misalkan kita memiliki pointer ke instruksi saat ini yang dijalankan oleh prosesor (PC), serta pointer saat ini ke bagian atas tumpukan (SP).  Sekarang, untuk "melompati" tumpukan ke fungsi sebelumnya, Anda perlu memahami fungsi apa itu dan di mana kita harus melompat ke fungsi ini.  ARM menggunakan Link Register (LR) untuk tujuan ini. <br><blockquote>  Link Register (LR) adalah register R14.  Ini menyimpan informasi kembali untuk subrutin, panggilan fungsi, dan pengecualian.  Saat diatur ulang, prosesor menetapkan nilai LR ke 0xFFFFFFFF <br></blockquote>  Selanjutnya, kita perlu naik tumpukan dan memuat nilai-nilai baru register LR dari tumpukan.  Struktur frame tumpukan untuk kompiler adalah sebagai berikut: <br><br><pre><code class="hljs smalltalk">/* <span class="hljs-type"><span class="hljs-type">The</span></span> stack backtrace structure is as follows: fp points to here: | save code pointer | [fp] | return link value | [fp, #<span class="hljs-number"><span class="hljs-number">-4</span></span>] | return sp value | [fp, #<span class="hljs-number"><span class="hljs-number">-8</span></span>] | return fp value | [fp, #<span class="hljs-number"><span class="hljs-number">-12</span></span>] [| saved r10 value |] [| saved r9 value |] [| saved r8 value |] ... [| saved r0 value |] r0-r3 are not normally saved in a <span class="hljs-type"><span class="hljs-type">C</span></span> function. */</code> </pre> <br>  Deskripsi ini diambil dari file header GCC gcc / gcc / config / arm / arm.h. <br><br>  Yaitu  kompiler (dalam kasus kami GCC) entah bagaimana dapat diinformasikan bahwa kami ingin melakukan jejak stack.  Dan kemudian dalam prolog masing-masing fungsi kompiler akan menyiapkan semacam struktur tambahan.  Anda dapat melihat bahwa di dalam struktur ini terdapat nilai “berikutnya” dari register LR yang kita butuhkan, dan, yang paling penting, itu berisi alamat frame berikutnya <code>| return fp value | [fp, #-12]</code> <code>| return fp value | [fp, #-12]</code> <br><br>  Mode kompiler ini ditentukan oleh opsi -mapcs-frame.  Ada disebutkan dalam deskripsi opsi tentang "Menentukan -fomit-frame-pointer dengan opsi ini menyebabkan frame tumpukan tidak dihasilkan untuk fungsi daun."  Di sini, fungsi daun dipahami sebagai fungsi yang tidak membuat panggilan ke fungsi lain, sehingga dapat dibuat sedikit lebih mudah. <br><br>  Anda juga mungkin bertanya-tanya apa yang harus dilakukan dengan fungsi assembler dalam kasus ini.  Sebenarnya, tidak ada yang rumit - Anda harus memasukkan makro khusus.  Dari file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tools / objtool / Documentation / stack-validation.txt</a> di kernel Linux: <br><blockquote>  Setiap fungsi yang dapat dipanggil harus dijelaskan dengan ELF <br>  jenis fungsi.  Dalam kode asm, ini biasanya dilakukan menggunakan <br>  Macro ENTRY / ENDPROC. <br></blockquote>  Tetapi dokumen yang sama membahas bahwa ini juga merupakan kerugian nyata dari pendekatan ini.  Utilitas objtool memeriksa apakah semua fungsi dalam kernel ditulis dalam format yang benar untuk jejak stack. <br><br>  Berikut ini adalah fungsi membuka gulungan tumpukan dari kernel Linux: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(CONFIG_FRAME_POINTER) &amp;&amp; !defined(CONFIG_ARM_UNWIND) int notrace unwind_frame(struct stackframe *frame) { unsigned long high, low; unsigned long fp = frame-&gt;fp; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    ,    */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore the registers from the stack frame */</span></span></span><span class="hljs-meta"> frame-&gt;fp = *(unsigned long *)(fp - 12); frame-&gt;sp = *(unsigned long *)(fp - 8); frame-&gt;pc = *(unsigned long *)(fp - 4); return 0; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Tapi di sini saya ingin menandai baris dengan yang <code>defined(CONFIG_ARM_UNWIND)</code> .  Dia mengisyaratkan bahwa kernel Linux juga menggunakan implementasi lain dari relax_frame, dan kita akan membicarakannya sedikit kemudian. <br><br>  Opsi <i>-mapcs-frame</i> hanya valid untuk set instruksi ARM.  Tetapi diketahui bahwa mikrokontroler ARM memiliki satu set instruksi - Jempol (Jempol-1 dan Jempol-2, lebih tepatnya), digunakan terutama untuk seri Cortex-M.  Untuk mengaktifkan pembuatan bingkai untuk mode Thumb, gunakan <i>flag -mtpcs-frame</i> dan <i>-mtpcs-leaf-frame.</i>  Intinya, ini adalah analog dari -mapcs-frame.  Menariknya, opsi-opsi ini saat ini hanya berfungsi untuk Cortex-M0 / M1.  Untuk beberapa waktu saya tidak tahu mengapa saya tidak bisa mengkompilasi gambar yang diinginkan untuk Cortex-M3 / M4 / ....  Setelah saya membaca kembali semua opsi gcc untuk ARM dan mencari di Internet, saya menyadari bahwa ini mungkin bug.  Oleh karena itu, saya naik langsung ke kode sumber kompiler <i>arm-none-eabi-gcc</i> .  Setelah mempelajari bagaimana kompiler menghasilkan frame untuk ARM, Thumb-1 dan Thumb-2, saya sampai pada kesimpulan bahwa mereka melewati Thumb-2, yaitu saat ini frame dihasilkan hanya untuk Thumb-1 dan ARM.  Setelah membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bug</a> , pengembang GCC menjelaskan bahwa standar untuk ARM telah berubah beberapa kali dan flag-flag ini sangat ketinggalan jaman, tetapi untuk beberapa alasan mereka semua masih ada di kompiler.  Di bawah ini adalah disassembler dari fungsi untuk mana frame dihasilkan. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ my_func2(<span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><pre> <code class="hljs delphi"><span class="hljs-number"><span class="hljs-number">00008134</span></span> &lt;my_func&gt;: <span class="hljs-number"><span class="hljs-number">8134</span></span>: b084 sub sp, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">8136</span></span>: b580 push <span class="hljs-comment"><span class="hljs-comment">{r7, lr}</span></span> <span class="hljs-number"><span class="hljs-number">8138</span></span>: aa06 add r2, sp, <span class="hljs-string"><span class="hljs-string">#24</span></span> <span class="hljs-number"><span class="hljs-number">813</span></span>a: <span class="hljs-number"><span class="hljs-number">9203</span></span> str r2, [sp, <span class="hljs-string"><span class="hljs-string">#12</span></span>] <span class="hljs-number"><span class="hljs-number">813</span></span>c: <span class="hljs-number"><span class="hljs-number">467</span></span>a mov r2, pc <span class="hljs-number"><span class="hljs-number">813</span></span>e: <span class="hljs-number"><span class="hljs-number">9205</span></span> str r2, [sp, <span class="hljs-string"><span class="hljs-string">#20</span></span>] <span class="hljs-number"><span class="hljs-number">8140</span></span>: <span class="hljs-number"><span class="hljs-number">465</span></span>a mov r2, fp <span class="hljs-number"><span class="hljs-number">8142</span></span>: <span class="hljs-number"><span class="hljs-number">9202</span></span> str r2, [sp, <span class="hljs-string"><span class="hljs-string">#8</span></span>] <span class="hljs-number"><span class="hljs-number">8144</span></span>: <span class="hljs-number"><span class="hljs-number">4672</span></span> mov r2, lr <span class="hljs-number"><span class="hljs-number">8146</span></span>: <span class="hljs-number"><span class="hljs-number">9204</span></span> str r2, [sp, <span class="hljs-string"><span class="hljs-string">#16</span></span>] <span class="hljs-number"><span class="hljs-number">8148</span></span>: aa05 add r2, sp, <span class="hljs-string"><span class="hljs-string">#20</span></span> <span class="hljs-number"><span class="hljs-number">814</span></span>a: <span class="hljs-number"><span class="hljs-number">4693</span></span> mov fp, r2 <span class="hljs-number"><span class="hljs-number">814</span></span>c: b082 sub sp, <span class="hljs-string"><span class="hljs-string">#8</span></span> <span class="hljs-number"><span class="hljs-number">814</span></span>e: af00 add r7, sp, <span class="hljs-string"><span class="hljs-string">#0</span></span></code> </pre><br>  Sebagai perbandingan, disassembler dengan fungsi yang sama untuk instruksi ARM <br><br><pre> <code class="hljs go"><span class="hljs-number"><span class="hljs-number">000081f</span></span>8 &lt;my_func&gt;: <span class="hljs-number"><span class="hljs-number">81f</span></span>8: e1a0c00d mov ip, sp <span class="hljs-number"><span class="hljs-number">81f</span></span>c: e92dd800 push {fp, ip, lr, pc} <span class="hljs-number"><span class="hljs-number">8200</span></span>: e24cb004 sub fp, ip, #<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">8204</span></span>: e24dd008 sub sp, sp, #<span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br>  Pada pandangan pertama, sepertinya ini adalah hal yang sangat berbeda.  Tetapi pada kenyataannya, frame persis sama, faktanya adalah bahwa dalam mode Thumb, instruksi push hanya memungkinkan register rendah (r0 - r7) dan register lr untuk ditumpuk.  Untuk semua register lain, ini harus dilakukan dalam dua tahap melalui instruksi mov dan str, seperti pada contoh di atas. <br><br><h4>  Tumpuk bersantai melalui pengecualian </h4><br>  Pendekatan alternatif adalah tumpukan unwinding berdasarkan Exception Handling ABI untuk standar ARM Architecture ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EHABI</a> ).  Faktanya, contoh utama penggunaan standar ini adalah penanganan pengecualian dalam bahasa seperti C ++.  Informasi yang disiapkan oleh kompiler untuk penanganan pengecualian juga dapat digunakan untuk melacak tumpukan.  Mode ini diaktifkan dengan opsi GCC <i>-feksepsi</i> (atau <i>-funwind-frame</i> ). <br><br>  Mari kita lihat lebih dekat bagaimana ini dilakukan.  Untuk mulai dengan, dokumen ini (EHABI) memaksakan persyaratan tertentu pada kompiler untuk menghasilkan tabel tambahan .ARM.exidx dan .ARM.extab.  Ini adalah bagaimana bagian .ARM.exidx ini didefinisikan dalam sumber kernel Linux.  Dari <a href="">lengkungan</a> file <a href="">/ arm / kernel / vmlinux.lds.h</a> : <br><br><pre> <code class="hljs tex">/* Stack unwinding tables */ #define ARM_UNWIND_SECTIONS <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>. = ALIGN(8); <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>.ARM.unwind_idx : { <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>__start_unwind_idx = .; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>*(.ARM.exidx*) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>__stop_unwind_idx = .; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>} <span class="hljs-tag"><span class="hljs-tag">\</span></span></code> </pre><br>  Standar "Penanganan Pengecualian ABI untuk Arsitektur ARM" mendefinisikan setiap elemen dari tabel .ARM.exidx sebagai struktur berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unwind_idx</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> addr_offset; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> insn; };</code> </pre> <br>  Elemen pertama adalah offset relatif terhadap fungsi awal, dan elemen kedua adalah alamat dalam tabel instruksi yang perlu ditafsirkan dengan cara khusus untuk memutar tumpukan lebih lanjut.  Dengan kata lain, setiap elemen dari tabel ini hanyalah urutan kata dan setengah kata, yang merupakan urutan instruksi.  Kata pertama menunjukkan jumlah instruksi yang harus diselesaikan untuk memutar tumpukan ke frame berikutnya. <br><br>  Petunjuk ini dijelaskan dalam standar EHABI yang telah disebutkan: <br><br><img src="https://habrastorage.org/webt/x9/3d/hx/x93dhxr8vqlkj-c_wcqk-ht1_m0.png"><br><br>  Lebih lanjut, implementasi utama penerjemah ini di Linux ada di file <a href="">arch / arm / kernel / melepas.c</a> <br><br><div class="spoiler">  <b class="spoiler_title">Penerapan fungsi relax_frame</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unwind_frame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct stackframe *frame)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> low; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unwind_idx</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">idx</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unwind_ctrl_block</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctrl</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   ,   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   ARM.exidx    ,   PC */</span></span> idx = unwind_find_idx(frame-&gt;pc); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!idx) { pr_warn(<span class="hljs-string"><span class="hljs-string">"unwind: Index not found %08lx\n"</span></span>, frame-&gt;pc); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -URC_FAILURE; } ctrl.vrs[FP] = frame-&gt;fp; ctrl.vrs[SP] = frame-&gt;sp; ctrl.vrs[LR] = frame-&gt;lr; ctrl.vrs[PC] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx-&gt;insn == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* can't unwind */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -URC_FAILURE; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((idx-&gt;insn &amp; <span class="hljs-number"><span class="hljs-number">0x80000000</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* prel31 to the unwind table */</span></span> ctrl.insn = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> *)prel31_to_addr(&amp;idx-&gt;insn); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((idx-&gt;insn &amp; <span class="hljs-number"><span class="hljs-number">0xff000000</span></span>) == <span class="hljs-number"><span class="hljs-number">0x80000000</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* only personality routine 0 supported in the index */</span></span> ctrl.insn = &amp;idx-&gt;insn; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { pr_warn(<span class="hljs-string"><span class="hljs-string">"unwind: Unsupported personality routine %08lx in the index at %p\n"</span></span>, idx-&gt;insn, idx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -URC_FAILURE; } <span class="hljs-comment"><span class="hljs-comment">/*       ,    - * ,       */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* check the personality routine */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*ctrl.insn &amp; <span class="hljs-number"><span class="hljs-number">0xff000000</span></span>) == <span class="hljs-number"><span class="hljs-number">0x80000000</span></span>) { ctrl.byte = <span class="hljs-number"><span class="hljs-number">2</span></span>; ctrl.entries = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*ctrl.insn &amp; <span class="hljs-number"><span class="hljs-number">0xff000000</span></span>) == <span class="hljs-number"><span class="hljs-number">0x81000000</span></span>) { ctrl.byte = <span class="hljs-number"><span class="hljs-number">1</span></span>; ctrl.entries = <span class="hljs-number"><span class="hljs-number">1</span></span> + ((*ctrl.insn &amp; <span class="hljs-number"><span class="hljs-number">0x00ff0000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { pr_warn(<span class="hljs-string"><span class="hljs-string">"unwind: Unsupported personality routine %08lx at %p\n"</span></span>, *ctrl.insn, ctrl.insn); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -URC_FAILURE; } ctrl.check_each_pop = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ,      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ctrl.entries &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> urc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ctrl.sp_high - ctrl.vrs[SP]) &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ctrl.vrs)) ctrl.check_each_pop = <span class="hljs-number"><span class="hljs-number">1</span></span>; urc = unwind_exec_insn(&amp;ctrl); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (urc &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctrl.vrs[SP] &lt; low || ctrl.vrs[SP] &gt;= ctrl.sp_high) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -URC_FAILURE; } <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ,       */</span></span> frame-&gt;fp = ctrl.vrs[FP]; frame-&gt;sp = ctrl.vrs[SP]; frame-&gt;lr = ctrl.vrs[LR]; frame-&gt;pc = ctrl.vrs[PC]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> URC_OK; }</code> </pre><br></div></div><br>  Ini adalah implementasi dari fungsi escape_frame, yang digunakan jika opsi CONFIG_ARM_UNWIND diaktifkan.  Saya memasukkan komentar dengan penjelasan dalam bahasa Rusia langsung ke teks sumber. <br><br>  Berikut ini adalah contoh bagaimana elemen tabel .ARM.exidx mencari fungsi kernel_start di Embox: <br><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> arm<span class="hljs-literal"><span class="hljs-literal">-none</span></span><span class="hljs-literal"><span class="hljs-literal">-eabi</span></span><span class="hljs-literal"><span class="hljs-literal">-readelf</span></span> <span class="hljs-literal"><span class="hljs-literal">-u</span></span> build/base/bin/embox Unwind table index <span class="hljs-string"><span class="hljs-string">'.ARM.exidx'</span></span> at offset <span class="hljs-number"><span class="hljs-number">0</span></span>xaa6d4 contains <span class="hljs-number"><span class="hljs-number">2806</span></span> entries: &lt;...&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>x1c3c &lt;kernel_start&gt;: @<span class="hljs-number"><span class="hljs-number">0</span></span>xafe40 Compact model index: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>x9b vsp = r11 <span class="hljs-number"><span class="hljs-number">0</span></span>x40 vsp = vsp - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>x84 <span class="hljs-number"><span class="hljs-number">0</span></span>x80 pop {r11, r14} <span class="hljs-number"><span class="hljs-number">0</span></span>xb0 finish <span class="hljs-number"><span class="hljs-number">0</span></span>xb0 finish &lt;...&gt;</code> </pre><br>  Dan ini dia disassemblernya: <br><br><pre> <code class="hljs cs"><span class="hljs-number"><span class="hljs-number">00001</span></span>c3c &lt;kernel_start&gt;: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel_start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-number"><span class="hljs-number">1</span></span>c3c: e92d4800 push {fp, lr} <span class="hljs-number"><span class="hljs-number">1</span></span>c40: e28db004 <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> fp, sp, <span class="hljs-meta"><span class="hljs-meta">#4 &lt;...&gt;</span></span></code> </pre><br>  Mari kita melalui langkah-langkahnya.  Kami melihat tugas <code>vps = r11</code> .  (R11 ini adalah FP) dan kemudian <code>vps = vps - 4</code> .  Ini sesuai dengan instruksi <code>add fp, sp, #4</code> .  Selanjutnya muncul pop {r11, r14}, yang sesuai dengan instruksi <code>push {fp, lr}</code> .  Instruksi <code>finish</code> melaporkan akhir eksekusi (jujur, saya masih tidak mengerti mengapa ada dua instruksi selesai di sana). <br><br>  Sekarang mari kita lihat berapa banyak memori yang dirakit dengan flag flag <i>-funwind-frames.</i> <br>  Untuk percobaan, saya mengkompilasi Embox untuk platform STM32F4-Discovery.  Berikut adalah hasil objdump: <br><br><div class="spoiler">  <b class="spoiler_title">Dengan bendera -funwind-frames:</b> <div class="spoiler_text"> <code>Sections: <br> Idx Name Size VMA LMA File off Algn <br> 0 .text 0005a600 08000000 08000000 00004000 2**14 <br> CONTENTS, ALLOC, LOAD, CODE <br> 1 .ARM.exidx 00003fd8 0805a600 0805a600 0005e600 2**2 <br> CONTENTS, ALLOC, LOAD, READONLY, DATA <br> 2 .ARM.extab 000049d0 0805e5d8 0805e5d8 000625d8 2**2 <br> CONTENTS, ALLOC, LOAD, READONLY, DATA <br> 3 .rodata 0003e380 08062fc0 08062fc0 00066fc0 2**5 <br></code> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Tanpa bendera:</b> <div class="spoiler_text"> <code>Sections: <br> Idx Name Size VMA LMA File off Algn <br> 0 .text 00058b1c 08000000 08000000 00004000 2**14 <br> CONTENTS, ALLOC, LOAD, CODE <br> 1 .ARM.exidx 00000008 08058b1c 08058b1c 0005cb1c 2**2 <br> CONTENTS, ALLOC, LOAD, READONLY, DATA <br> 2 .rodata 0003e380 08058b40 08058b40 0005cb40 2**5 <br></code> <br></div></div><br>  Sangat mudah untuk menghitung bahwa bagian .ARM.exidx dan .ARM.extab menempati sekitar 1/10 dari ukuran .text.  Setelah itu, saya mengumpulkan gambar yang lebih besar - untuk ARM Integrator CP berdasarkan ARM9, dan ada bagian ini 1/12 dari ukuran bagian .text.  Tetapi jelas bahwa rasio ini dapat bervariasi dari satu proyek ke proyek lainnya.  Juga ternyata ukuran gambar yang menambahkan flag -macps-frame lebih kecil dari opsi pengecualian (yang diharapkan).  Jadi, misalnya, ketika ukuran bagian .text adalah 600 Kb, ukuran total .ARM.exidx + .ARM.extab adalah 50 Kb, dan ukuran kode tambahan dengan flag -mapcs-frame hanya 10 Kb.  Tetapi jika kita melihat di atas, apa prolog besar dihasilkan untuk Cortex-M1 (ingat, melalui mov / str?), Maka menjadi jelas bahwa dalam kasus ini praktis tidak ada perbedaan, yang berarti tidak mungkin menggunakan <i>-mtpcs-frame</i> untuk mode Thumb setidaknya masuk akal. <br><br><h4>  Apakah jejak stack diperlukan untuk ARM sekarang?  Apa alternatifnya? </h4><br>  Pendekatan ketiga adalah melacak tumpukan menggunakan debugger.  Tampaknya banyak sistem operasi untuk bekerja dengan FreeRTOS, mikrokontroler NuttX saat ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyarankan</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opsi</a> penelusuran khusus ini atau menawarkan untuk menonton disassembler. <br><br>  Sebagai hasilnya, kami sampai pada kesimpulan bahwa jejak tumpukan untuk lengan dalam waktu berjalan sebenarnya tidak digunakan di mana pun.  Ini mungkin konsekuensi dari keinginan untuk membuat kode yang paling efisien saat bekerja, dan untuk mengambil tindakan debugging (yang termasuk promosi tumpukan) secara offline.  Di sisi lain, jika OS sudah menggunakan kode C ++, maka sangat mungkin untuk menggunakan implementasi tracing melalui .ARM.exidx. <br><br>  Nah dan ya, masalah dengan output stack yang salah dalam interupsi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Embox</a> diselesaikan dengan sangat sederhana, ternyata cukup untuk menyimpan register LR di stack. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424365/">https://habr.com/ru/post/id424365/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424349/index.html">"Kalender Tester" untuk bulan September. Optimalkan Tes</a></li>
<li><a href="../id424353/index.html">Latar Belakang: Negara mesin pencari Internet Sputnik dan sejarahnya yang kompleks</a></li>
<li><a href="../id424355/index.html">Cetakan injeksi: cara kerjanya</a></li>
<li><a href="../id424361/index.html">Bagaimana gamifikasi meningkatkan pengalaman pengguna</a></li>
<li><a href="../id424363/index.html">“Jika Anda ingin membuat sesuatu yang benar-benar keren, Anda perlu menggali lebih dalam dan tahu bagaimana kode Anda bekerja di sistem, di perangkat keras”</a></li>
<li><a href="../id424367/index.html">Perjuangan untuk sumber daya, bagian 2: Kami bermain dengan pengaturan Cgroups</a></li>
<li><a href="../id424369/index.html">File favorit saya di basis kode Chromium</a></li>
<li><a href="../id424371/index.html">Menyebarkan vCloud Extender</a></li>
<li><a href="../id424373/index.html">Tempat Bekerja di TI, Edisi 1: Voximplant</a></li>
<li><a href="../id424375/index.html">Ulasan Mayku FormBox Vacuum Moulder: Biarkan Bagian Menyebar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>