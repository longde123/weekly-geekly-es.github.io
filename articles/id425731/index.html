<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒƒ ğŸ¤¼ â¤µï¸ Rahasia komputasi GPU yang mustahil ğŸ§œğŸ½ ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ ğŸ’ªğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengalaman kami dalam menggunakan cluster komputasi 480 AMD RX 480 GPU untuk memecahkan masalah matematika. Sebagai masalah, kami mengambil bukti teor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rahasia komputasi GPU yang mustahil</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/combox/blog/425731/"> Pengalaman kami dalam menggunakan cluster komputasi 480 AMD RX 480 GPU untuk memecahkan masalah matematika.  Sebagai masalah, kami mengambil bukti teorema dari sebuah artikel oleh Profesor A. Chudnov  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dekomposisi siklik set yang memisahkan diagram dan kelas permainan siklik dengan hasil yang terjamin</a> ."  Tugasnya adalah menemukan jumlah minimum peserta dalam satu koalisi dalam game koalisi tipe Nim, yang menjamin kemenangan salah satu pihak. <br><br><img src="https://habrastorage.org/webt/jc/gm/wj/jcgmwjouxeywvjyjlxa8vec5s5c.jpeg"><br><a name="habracut"></a><br><h3>  Pengembangan CPU </h3><br>  Prosesor pertama yang benar-benar mendapat distribusi massal adalah 8086 dari Intel, dikembangkan pada tahun 1978.  Kecepatan clock 8086 hanya 8 MHz.  Beberapa tahun kemudian, prosesor pertama muncul di dalamnya yang ada 2, 4 dan bahkan 8 core.  Setiap inti memungkinkan kodenya dieksekusi secara independen dari yang lain.  Sebagai perbandingan, prosesor Intel Core i9-7980XE modern beroperasi pada frekuensi 2,6 GHz dan berisi 18 core.  Seperti yang Anda lihat, kemajuan tidak berhenti! <br><br><h3>  Pengembangan GPU </h3><br>  Bersamaan dengan perkembangan prosesor sentral, kartu video juga dikembangkan.  Pada dasarnya, karakteristik mereka penting untuk permainan komputer, di mana teknologi baru sangat berwarna dan rendering gambar 3D secara bertahap mendekati kualitas fotografi.  Pada awal pengembangan permainan komputer, perhitungan gambar dilakukan pada CPU, tetapi daya cipta pengembang grafis 3D segera tercapai, yang berhasil mengoptimalkan bahkan hal-hal yang jelas (contoh yang baik dari ini adalah <i>InvSqrt ()</i> ).  Jadi, prosesor-prosesor dengan seperangkat instruksi khusus untuk melakukan perhitungan 3D mulai muncul dalam kartu video.  Seiring waktu, jumlah tim tersebut tumbuh, yang, di satu sisi, memungkinkan bekerja lebih fleksibel dan efisien dengan gambar, dan di sisi lain, mempersulit proses pengembangan. <br><br>  Sejak 1996, akselerator grafis S3 ViRGE, 3dfx Voodoo, Diamond Monster dan lainnya mulai diproduksi.  Pada tahun 1999, nVidia merilis prosesor GeForce 256, memperkenalkan istilah GPU - prosesor grafis.  Ini sudah universal, dapat menangani perhitungan geometris, transformasi koordinat, penempatan titik pencahayaan, dan bekerja dengan poligon.  Perbedaan antara GPU dan chip grafis lainnya adalah di dalamnya, di samping perintah khusus, ada satu set perintah standar yang dengannya Anda dapat menerapkan algoritma rendering Anda sendiri.  Ini memberikan keuntungan yang signifikan, karena memungkinkan untuk menambahkan efek khusus, dan bukan hanya yang sudah diprogram ke dalam kartu video.  Dimulai dengan GeForce 8000/9000, prosesor aliran muncul di GPU - komputer yang sudah lengkap.  Jumlah mereka berkisar antara 16 hingga 128 tergantung pada modelnya.Dalam terminologi modern, mereka disebut unit shader terpadu, atau hanya unit shader.  AMD Vega 64 GPU yang diproduksi hari ini memuat 4096 unit shader, dan frekuensi clocknya bisa mencapai 1.536 MHz! <br><br><h3>  Apa yang terkandung dalam GPU? </h3><br><img align="right" src="https://habrastorage.org/webt/my/rm/lc/myrmlcjalz2qiygw-qg-vdp4o18.png">  Arsitektur GPU berbeda dari CPU dalam sejumlah besar inti dan satu set instruksi minimalis yang terutama ditujukan untuk komputasi vektor.  Pada tingkat arsitektur, masalah operasi paralel sejumlah besar core dan akses simultan ke memori telah diselesaikan.  GPU modern terdiri dari 2 hingga 4 ribu unit shader, yang digabungkan menjadi unit komputasi (Compute Unit).  Dalam komputasi paralel, masalah akses simultan ke memori sangat akut.  Jika masing-masing prosesor aliran mencoba menulis ke sel memori, maka perintah-perintah ini akan berakhir di kunci dan mereka harus antri, yang akan sangat mengurangi kinerja.  Oleh karena itu, stream prosesor menjalankan instruksi dalam kelompok-kelompok kecil: sementara satu kelompok melakukan perhitungan, yang lain memuat register, dll.  Anda juga dapat menggabungkan inti ke dalam kelompok kerja dengan memori bersama dan mekanisme sinkronisasi internal. <br><br>  Fitur penting lain dari GPU adalah keberadaan register vektor dan vektor ALU, yang dapat melakukan operasi secara bersamaan untuk beberapa komponen vektor.  Ini terutama diperlukan untuk grafik 3D, tetapi karena dunia kita tiga dimensi, tidak ada yang mencegah kita menggunakannya untuk banyak perhitungan fisik.  Dengan adanya ALU vektor gratis, mereka juga dapat digunakan untuk menghitung jumlah skalar. <br><br><h3>  Mereka sangat berbeda, CPU dan GPU </h3><br>  Untuk pengoperasian penuh sistem komputasi, kedua jenis perangkat ini penting.  Misalnya, kami menjalankan program langkah demi langkah, suatu algoritma sekuensial tertentu.  Tidak ada cara untuk melakukan langkah kelima dari algoritma, sehingga data untuk itu dihitung pada langkah empat.  Dalam hal ini, lebih efisien menggunakan CPU dengan cache besar dan kecepatan clock tinggi.  Tetapi ada seluruh kelas tugas yang cocok untuk paralelisasi.  Dalam hal ini, efektivitas GPU jelas.  Contoh paling umum adalah menghitung piksel dari gambar yang diberikan.  Prosedur untuk setiap piksel hampir sama, data tentang objek dan tekstur 3D terletak di RAM kartu video, dan setiap prosesor aliran dapat secara mandiri menghitung bagian gambarnya sendiri. <br><br>  Berikut adalah contoh dari tugas modern - melatih jaringan saraf.  Sejumlah besar neuron identik perlu dilatih, yaitu, untuk mengubah koefisien berat masing-masing neuron.  Setelah perubahan seperti itu, perlu untuk melewati urutan uji melalui jaringan saraf untuk pelatihan dan mendapatkan vektor kesalahan.  Perhitungan semacam itu sangat cocok untuk GPU.  Setiap prosesor aliran dapat berperilaku seperti neuron dan selama perhitungan tidak perlu membangun solusi secara berurutan, semua perhitungan kami akan terjadi secara bersamaan.  Contoh lain adalah perhitungan aliran aerodinamis.  Penting untuk mengetahui perilaku yang mungkin dari jembatan yang dirancang di bawah pengaruh angin, untuk mensimulasikan stabilitas aerodinamisnya, untuk menemukan tempat pemasangan yang optimal untuk fairing untuk menyesuaikan aliran udara atau untuk menghitung hambatan terhadap resonansi angin.  Ingat "jembatan menari" yang terkenal di Volgograd?  Saya pikir tidak ada yang mau berada di jembatan saat itu ... <br><br>  Perilaku aliran udara di setiap titik dapat dijelaskan oleh persamaan matematika yang sama dan menyelesaikan persamaan ini secara paralel pada sejumlah besar inti. <br><br><h3>  GPU ada di tangan programmer </h3><br>  Untuk melakukan perhitungan pada GPU, bahasa khusus dan kompiler digunakan.  Ada beberapa kerangka kerja untuk melakukan komputasi GPU umum: OpenCL, CUDA, C ++ AMP, OpenACC.  Dua yang pertama banyak digunakan, tetapi penggunaan CUDA hanya dibatasi oleh GPU nVidia. <br><br>  OpenCL dirilis pada 2009 oleh Apple.  Belakangan, Intel, IBM, AMD, Google dan nVidia bergabung dengan Khronos Group dan mengumumkan dukungan mereka untuk standar bersama.  Sejak itu, versi standar baru muncul setiap satu setengah hingga dua tahun dan masing-masing membawa perbaikan yang lebih dan lebih serius. <br><br>  Sampai saat ini, bahasa OpenCL C ++ versi 2.2 sesuai dengan standar C ++ 14, mendukung eksekusi simultan beberapa program dalam perangkat, interaksi di antara mereka melalui antrian internal dan saluran pipa, dan memungkinkan pengelolaan buffer dan memori virtual yang fleksibel. <br><br><h3>  Tugas nyata </h3><br>  Masalah yang menarik dari teori permainan, dalam solusi yang kami ambil bagian, adalah bukti teorema dari sebuah artikel oleh Profesor A. Chudnov  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dekomposisi siklik set yang memisahkan diagram dan kelas permainan siklik dengan hasil yang terjamin</a> ."  Tugasnya adalah menemukan jumlah minimum peserta dalam satu koalisi dalam game koalisi tipe Nim, yang menjamin kemenangan salah satu pihak. <br><br>  Dari sudut pandang matematika, ini adalah pencarian untuk urutan siklik dukungan.  Jika Anda mewakili urutan dalam bentuk daftar nol dan yang, maka pemeriksaan untuk dukungan dapat diimplementasikan oleh operasi bitwise logis.  Dari sudut pandang pemrograman, urutan seperti itu adalah register yang panjang, misalnya, 256 bit.  Cara paling andal untuk memecahkan masalah ini adalah memilah-milah semua opsi kecuali yang tidak mungkin karena alasan yang jelas. <br><br>  Tujuan penyelesaian masalah adalah masalah pemrosesan sinyal yang efektif (deteksi, sinkronisasi, pengukuran koordinat, pengkodean, dll.). <br><br>  Kompleksitas penyelesaian masalah ini adalah memilah-milah sejumlah besar opsi.  Sebagai contoh, jika kita mencari solusi untuk n = 25, maka ini adalah 25 bit, dan jika n = 100, maka ini sudah 100 bit.  Jika kita mengambil jumlah semua kombinasi yang mungkin, maka untuk n = 25 itu adalah 2 ^ 25 = 33 554 432, dan untuk n = 100 itu sudah 2 ^ 100 = 1 267 650 600 228 229 401 496 703 205 376 kombinasi.  Peningkatan kompleksitas hanyalah kolosal! <br><br>  Tugas ini diparalelkan dengan baik, yang artinya ideal untuk kluster GPU kami. <br><br><h3>  Pemrogram vs Matematika </h3><br>  Awalnya, matematikawan menyelesaikan masalah ini dalam Visual Basic di Excel, sehingga mereka berhasil mendapatkan solusi utama, tetapi rendahnya kinerja bahasa scripting tidak memungkinkan kita untuk bergerak jauh ke depan.  Keputusan untuk n = 80 memakan waktu satu setengah bulan ... Kami menundukkan kepala di depan orang-orang yang sabar ini. <br><br>  Tahap pertama, kami mengimplementasikan algoritma tugas di C dan meluncurkannya di CPU.  Dalam prosesnya, ternyata banyak yang bisa dioptimalkan saat bekerja dengan urutan bit. <br>  Selanjutnya, kami mengoptimalkan area pencarian dan menghilangkan duplikasi.  Juga, analisis kode assembler yang dihasilkan oleh kompiler dan optimalisasi kode untuk fitur kompiler memberikan hasil yang baik.  Semua ini memungkinkan untuk mencapai peningkatan signifikan dalam kecepatan perhitungan. <br><br>  Tahap optimasi berikutnya adalah pembuatan profil.  Pengukuran waktu eksekusi berbagai bagian kode menunjukkan bahwa di beberapa cabang algoritma, beban pada memori meningkat secara signifikan, dan percabangan program yang berlebihan terungkap.  Karena cacat "kecil" ini, hampir sepertiga daya CPU tidak digunakan. <br><br>  Aspek yang sangat penting untuk menyelesaikan masalah tersebut adalah keakuratan penulisan kode.  Tidak ada yang tahu jawaban yang benar untuk masalah ini dan, karenanya, tidak ada vektor uji.  Hanya ada bagian pertama dari rangkaian solusi yang telah ditemukan oleh ahli matematika.  Keandalan solusi baru hanya dapat dijamin oleh keakuratan kode penulisan. <br><br>  Jadi tahap mempersiapkan program untuk solusi pada GPU telah tiba dan kode telah dimodifikasi untuk bekerja di beberapa utas.  Program kontrol sekarang terlibat dalam tugas pengiriman antar utas.  Di lingkungan multi-utas, kecepatan perhitungan telah meningkat 5 kali!  Ini dicapai karena operasi simultan dari 4 utas dan kombinasi fungsi. <br><br>  Pada tahap ini, keputusan membuat perhitungan yang benar hingga n = 80 dalam 10 menit, sedangkan di Excel, perhitungan ini membutuhkan waktu satu setengah bulan!  Sedikit kemenangan! <br><br><h3>  GPU dan OpenCL </h3><br>  Diputuskan untuk menggunakan OpenCL versi 1.2 untuk memastikan kompatibilitas maksimum antara platform yang berbeda.  Debugging awal dilakukan pada CPU Intel, kemudian pada GPU Intel.  Kemudian mereka beralih ke GPU dari AMD. <br><br>  Standar OpenCL 1.2 mendukung variabel integer 64 bit.  Dimensi 128-bit secara terbatas didukung oleh AMD, tetapi dikompilasi menjadi dua angka 64-bit.  Untuk alasan kompatibilitas dan untuk mengoptimalkan kinerja, diputuskan untuk menghadirkan angka 256-bit sebagai kelompok angka 32-bit, operasi bitwise logis yang dilakukan pada GPU ALU internal secepat mungkin. <br>  Program OpenCL berisi kernel - fungsi yang merupakan titik masuk dari suatu program.  Data untuk diproses diunduh dari CPU ke RAM kartu video dan ditransfer ke kernel dalam bentuk buffer - pointer ke array data input dan output.  Mengapa sebuah array?  Kami melakukan komputasi kinerja tinggi, kami membutuhkan banyak tugas yang dilakukan secara bersamaan.  Kernel berjalan pada perangkat dalam banyak hal.  Setiap inti tahu pengenalnya dan mengambil bagian inputnya sendiri dari buffer bersama.  Kasus di mana solusi paling sederhana adalah yang paling efektif.  OpenCL tidak hanya bahasa, tetapi juga kerangka kerja yang komprehensif di mana semua rincian komputasi ilmiah dan game dipikirkan secara menyeluruh.  Ini membuat hidup lebih mudah bagi pengembang.  Misalnya, Anda dapat memulai banyak utas, pengelola tugas akan menempatkannya di perangkat itu sendiri.  Tugas-tugas yang tidak memulai eksekusi segera akan diantrikan dan diluncurkan saat unit komputasi menjadi bebas.  Setiap instance kernel memiliki ruang sendiri di buffer output, di mana ia menempatkan respons setelah menyelesaikan pekerjaan. <br><br>  Tugas utama manajer OpenCL adalah untuk memastikan eksekusi paralel dari beberapa instance kernel.  Pengalaman ilmiah dan praktis yang terakumulasi selama beberapa dekade diterapkan di sini.  Sementara beberapa core memuat data ke dalam register, bagian lain saat ini bekerja dengan memori atau melakukan perhitungan - sebagai hasilnya, inti GPU selalu terisi penuh. <br>  Kompilator OpenCL melakukan pekerjaan optimalisasi, tetapi lebih mudah bagi pengembang untuk memengaruhi kinerja.  Optimalisasi GPU berjalan dalam dua arah - mempercepat eksekusi kode dan kemungkinan memparalelkannya.  Seberapa baik kode diparalelkan oleh kompiler tergantung pada beberapa hal: jumlah register awal yang ditempati (yang terletak di memori GPU paling lambat - global), ukuran kode yang dikompilasi (Anda harus memasukkan cache 32 kb), jumlah vektor dan register skalar yang digunakan. <br><br><h3>  GPU ComBox A-480 atau Satu Juta Cores </h3><br>  Ini adalah bagian paling menarik dari proyek ini, ketika kami beralih dari Excel ke cluster komputasi yang terdiri dari 480 kartu grafis AMD RX 480. Besar, cepat, efisien.  Benar-benar siap untuk memenuhi tugas dan mendapatkan hasil yang belum pernah dilihat dunia sebelumnya. <br><br>  Saya ingin mencatat bahwa pada semua tahap meningkatkan dan mengoptimalkan kode, kami mulai mencari solusi dari awal dan membandingkan jawaban dari versi baru dengan yang sebelumnya.  Ini memungkinkan kami untuk memastikan bahwa optimasi dan peningkatan kode tidak memperkenalkan kesalahan ke dalam solusi.  Di sini Anda perlu memahami bahwa tidak ada jawaban yang benar di akhir buku pelajaran, dan tidak ada seorang pun di dunia yang mengetahuinya. <br>  Peluncuran pada cluster mengkonfirmasi asumsi kami pada kecepatan solusi: pencarian untuk urutan n&gt; 100 memakan waktu sekitar satu jam.  Sungguh menakjubkan melihat bagaimana solusi baru pada cluster ComBox A-480 dalam beberapa menit, sementara pada CPU butuh berjam-jam. <br><br>  Hanya dalam dua jam dari cluster komputasi, kami mendapatkan semua solusi hingga n = 127.  Pemeriksaan solusi menunjukkan bahwa jawaban yang diperoleh dapat diandalkan dan sesuai dengan teorema Profesor A. Chudnov yang dinyatakan dalam artikel <br><br><h3>  Evolusi kecepatan </h3><br>  Jika Anda melihat peningkatan kinerja dalam penyelesaian masalah, hasilnya kira-kira sebagai berikut: <br><br><ul><li>  satu setengah bulan hingga n = 80 di Excel; </li><li>  satu jam ke n = 80 pada Core i5 dengan program C ++ yang dioptimalkan; </li><li>  10 menit hingga n = 80 pada Core i5 menggunakan multithreading; </li><li>  10 menit hingga n = 100 pada satu GPU AMD RX 480; </li><li>  120 menit hingga n = 127 pada ComBox A-480. </li></ul><br><h3>  Prospek dan masa depan </h3><br>  Banyak tugas di persimpangan sains dan praktik yang tertunda untuk membuat hidup kita lebih baik.  Pasar penyewaan daya komputasi baru saja muncul, dan kebutuhan akan komputasi paralel terus tumbuh. <br><br>  Kemungkinan aplikasi komputasi paralel: <br><br><ul><li>  tugas kontrol otomatis kendaraan dan drone; </li><li>  perhitungan karakteristik aerodinamik dan hidrodinamik; </li><li>  pengenalan suara dan gambar visual; </li><li>  pelatihan jaringan saraf; </li><li>  tugas astronomi dan astronotika; </li><li>  statistik dan analisis korelasi data; </li><li>  melipatgandakan senyawa protein-protein; </li><li>  diagnosis dini penyakit menggunakan AI. </li></ul><br>  Arah terpisah adalah komputasi awan pada GPU.  Misalnya, raksasa seperti Amazon, IBM dan Google menyewakan daya komputasi mereka ke GPU.  Hari ini kita dapat mengatakan dengan yakin bahwa masa depan komputasi paralel berkinerja tinggi akan menjadi milik kelompok GPU. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425731/">https://habr.com/ru/post/id425731/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425719/index.html">Seledri dalam proyek sibuk: sedikit latihan</a></li>
<li><a href="../id425723/index.html">Facebook secara aktif mengembangkan layanan untuk mencari pekerjaan dan merekrut karyawan di jejaring sosial</a></li>
<li><a href="../id425725/index.html">Case Nintendo Patents - Game Boy</a></li>
<li><a href="../id425727/index.html">Sampai waktu berikutnya</a></li>
<li><a href="../id425729/index.html">Hackathon Pro Welcome: bagaimana amal pertama SmartMail Hack</a></li>
<li><a href="../id425737/index.html">Peta di atas meja: cara memilih penyedia peta untuk aplikasi seluler</a></li>
<li><a href="../id425739/index.html">Microsoft mengumumkan Project xCloud - layanan streaming game mutakhir</a></li>
<li><a href="../id425741/index.html">Docotic.Pdf: Masalah apa yang terdeteksi oleh PVS-Studio dalam proyek dewasa?</a></li>
<li><a href="../id425743/index.html">Psikoterapi Mars di rumah Saturnus dan injeksi psilocybin homeopati</a></li>
<li><a href="../id425747/index.html">Apa yang terjadi pada "Timur dan timnya" atau pemikiran tentang Kemitraan Teknisi Militan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>