<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏼 😟 🖱️ Penyortiran "topologis" grafik dengan siklus 📎 🗃️ ‼️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Judul lengkap dari artikel seharusnya adalah "Penyortiran" topologis "berkelanjutan dari grafik dengan siklus dalam O(|V| + |e| log |e|) dalam waktu d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penyortiran "topologis" grafik dengan siklus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451208/"> Judul lengkap dari artikel seharusnya adalah "Penyortiran" topologis "berkelanjutan dari grafik dengan siklus dalam <code>O(|V| + |e| log |e|)</code> dalam waktu dan <code>O(|V|)</code> dalam memori tanpa rekursi," tetapi saya diberitahu apa itu berlebihan. <br><a name="habracut"></a><br>  Penafian: Saya seorang programmer, bukan ahli matematika, jadi bahasa yang tidak akurat mungkin ada di beberapa tempat, di mana Anda bisa dan harus menendang. <br><br><h3>  Esensi dari tugas </h3><br>  Saya akan menganalisis kata-kata dari masalah, solusi yang ingin saya bagikan, di beberapa bagian. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penyortiran topologis</a></b> adalah urutan simpul dari grafik asiklik terarah di mana masing-masing simpul dari mana tepi keluar lebih awal dari simpul di mana tepi ini masuk.  Ada dua nuansa penting di sini: grafik dapat memiliki <em>lebih dari satu</em> pemesanan seperti itu dan hanya berlaku untuk grafik <em>asiklik</em> .  Matematikawan tidak peduli, tetapi programmer terkadang menginginkan determinisme dan sedikit lebih dari "Maaf, Anda memiliki siklus di sini, Anda tidak akan memiliki penyortiran." <br><br>  Oleh karena itu, kami menambahkan persyaratan <b>stabilitas</b> : sepasang simpul, urutan di antaranya tidak ditentukan oleh tepi grafik, harus ditentukan oleh urutan di mana simpul-simpul ini sampai pada input algoritma.  Akibatnya, pengulangan yang berulang tidak akan mengubah urutan simpul. <br><br>  Dengan kurangnya <b>rekursi,</b> semuanya sederhana, komputer secara signifikan lebih lemah daripada mesin Turing dan memori (dan terutama tumpukan) telah terbatas.  Oleh karena itu, dalam pemrograman terapan, biasanya algoritma berulang lebih disukai daripada yang rekursif. <br><br>  Dan akhirnya, saya akan mendefinisikan apa yang saya sebut pengurutan "topologis" jika ada <b>siklus</b> dalam grafik.  Ini adalah urutan simpul, yang bertepatan dengan pemilahan topologi yang sebenarnya, jika masing-masing siklus diganti oleh satu simpul, dan simpul siklus itu sendiri, sesuai dengan persyaratan stabilitas, terletak relatif satu sama lain dalam urutan asli. <br><br>  Dan sekarang <s>dengan semua sampah ini kami akan mencoba untuk lepas landas.</s> Saya akan melakukan semuanya dalam kerangka waktu dan batasan memori yang ditunjukkan di awal posting. <br><br><h3>  Cari solusinya </h3><br>  Jika Anda melihat algoritma pengurutan topologi yang ada ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma Kahn</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencarian dalam</a> ), ternyata semuanya, jika ada siklus, katakan "Saya tidak bisa" dan berhenti bekerja. <br><br>  Karenanya, mari kita lanjutkan dengan algoritma yang dapat melakukan sesuatu yang dapat dipahami dengan siklus.  Sebagai contoh, <em>temukan</em> mereka.  Di antara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma yang</a> tercantum di Wikipedia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk menemukan siklus dalam grafik</a> , perhatian diberikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada algoritma Taryan</a> .  Ini berisi komentar yang menarik bahwa, sebagai produk sampingan, algoritma menghasilkan penyortiran topologi <em>terbalik</em> dari grafik: <br><blockquote>  Sementara tidak ada yang istimewa tentang urutan node dalam setiap komponen yang terhubung kuat, satu sifat yang berguna dari algoritma adalah bahwa tidak ada komponen yang terhubung kuat akan diidentifikasi sebelum penggantinya.  Oleh karena itu, <em>urutan pengidentifikasian komponen yang terhubung kuat merupakan jenis topologi terbalik DAG yang dibentuk oleh komponen yang terhubung kuat</em> . </blockquote>  Benar, algoritmanya bersifat rekursif dan tidak jelas apa yang dimilikinya dengan stabilitas, tetapi ini jelas merupakan gerakan ke arah yang benar.  Pembacaan lebih dekat dari Wikipedia mengungkapkan referensi ke artikel <a href="">Algoritma hemat-ruang untuk menemukan komponen yang sangat terhubung</a> , yang ditulis oleh kawan David Pierce, di mana tidak hanya terdapat algoritma imperatif, tetapi juga mengurangi kebutuhan memori dibandingkan dengan klasik. Algoritma Tarjan.  Bonusnya adalah <a href="">implementasi dari algoritma di Jawa</a> .  Harus mengambil! <br><br><div class="spoiler">  <b class="spoiler_title">Algoritma PEA_FIND_SCC3 (V, E) dari artikel Pierce</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/wq/44/il/wq44iloqbs-c5f4qxqabj710a2c.png"><br></div></div><br>  Jadi, kami memiliki daftar simpul pada input dan (terima kasih kepada Pierce) indeks tertentu dari komponen konektivitas kuat yang dimiliki oleh simpul ini pada output.  Langkah selanjutnya adalah mengurutkan simpul secara stabil sesuai dengan nomor seri komponennya.  Ada algoritma untuk tugas semacam itu, yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penghitungan sortir</a> , yang melakukan ini dalam waktu <code>O(n)</code> . <br><br>  Dalam proses mengumpulkan algoritme menjadi tumpukan, ternyata fakta bahwa adalah wajar untuk memberikan penyortiran topologi <em>terbalik</em> untuk itu sebenarnya sangat luar dari Taryan - maka cabang-cabang tetangga dari grafik (tidak memiliki hubungan urutan di antara mereka) akan nomor mundur, maka potongan-potongan grafik tidak akan mundur. memiliki koneksi di antara mereka sendiri, ternyata berada dalam urutan terbalik ... <br><br><h3>  Jawabannya </h3><br>  Jadi solusi terakhir: <br><br><ol><li>  Kami menomori simpul dari daftar asli. <code>O(|V|)</code> </li><li>  Kami mengurutkan tepi setiap simpul sesuai dengan jumlah simpul yang menjadi ujungnya. <code>O(|e| log |e|)</code> </li><li>  Dengan menggunakan algoritma Pierce, kami menemukan dan menomori komponen koneksi yang kuat. <code>O(|V|)</code> </li><li>  Dengan menggunakan pengurutan dengan menghitung, kami mengurutkan simpul berdasarkan jumlah komponen yang sangat terhubung yang mereka terima. <code>O(|V|)</code> </li></ol><br>  <a href="">Kode GitHub, Java, domain publik</a> .  Dapat dicatat bahwa untuk memastikan stabilitas penyortiran, algoritma Pierce sedikit dimodifikasi dan memotong simpul dalam urutan terbalik. <br><br><h3>  Tapi kenapa ??? </h3><br>  Dan sekarang latar belakangnya, mengapa semua ini dibutuhkan.  Saat memuat / membongkar pustaka dinamis (.so), glibc perlu memutuskan untuk menginisialisasi variabel statis mana.  Variabel tergantung satu sama lain, tergantung pada fungsi yang berbeda, dll.  Secara umum, semua ini membentuk grafik di mana ada siklus dan yang harus disortir. <br><br>  Sekali waktu, kode yang agak suboptimal yang melakukan tugas untuk <code>O(n^2)</code> terlibat dalam tugas ini.  Dan secara umum, ini tidak terlalu mengganggu siapa pun, sampai pada tahun 2012 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diketahui</a> bahwa kode tersebut tidak berfungsi dengan benar dan dalam beberapa kasus salah. <br><br>  Orang-orang kasar dari RedHat berpikir, berpikir dan mengacaukan beberapa siklus dari atas.  Kasing bermasalah diperbaiki, tetapi algoritme mulai bekerja untuk <code>O(n^3)</code> , dan ini sudah menjadi nyata dan pada beberapa aplikasi mulai butuh beberapa puluh detik, yang merupakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bug</a> pada 2013.  Juga, penulis bug menemukan kasus di mana algoritma dengan <code>O(n^3)</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">juga salah</a> .  Dia menyarankan menggunakan algoritma Taryan, meskipun patch dengan koreksi belum pernah dirancang. <br><br>  Dan waktu berlalu, glibc tanpa ampun melambat dan pada 2015 ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">upaya lain untuk memperbaiki algoritme</a> .  Sayangnya, tidak berhasil, algoritma dipilih <code>O(n^2)</code> , selain membingungkan cabang-cabang grafik, di mana urutannya tidak ditentukan. <br><br>  Hari ini adalah tahun 2019, glibc masih melambat.  Menilai dari berapa banyak waktu yang saya perlukan untuk memperbaiki masalah, peluang saya untuk menyelesaikannya secara signifikan lebih rendah dari 100%.  Ini semakin diperparah oleh fakta bahwa hal-hal terjadi di C, tanpa dukungan IDE, dalam kode gaya pengkodean GNU, pelari uji gila ("jika Anda ingin menjalankan tes lagi, cukup hapus file .out yang sesuai").  Dan agar glibc dapat melihat tambalan Anda, Anda harus melalui prosedur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penetapan hak cipta</a> , mengeluarkan tambalan dengan benar dan iblis tahu apa lagi.  Oleh karena itu, untuk setidaknya menghapus masalah menciptakan suatu algoritma yang memecahkan masalah, posting ini ditulis. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451208/">https://habr.com/ru/post/id451208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451196/index.html">Pemisahan profil pelanggan dan freelancer</a></li>
<li><a href="../id451198/index.html">Peran Augmented Reality Dan Virtual Reality Di NBA</a></li>
<li><a href="../id451200/index.html">Secara otomatis memperoleh sertifikat SSL oleh Let's Encrypt menggunakan tantangan DNS-01 dan AWS</a></li>
<li><a href="../id451204/index.html">Editor teks gratis untuk kolaborasi</a></li>
<li><a href="../id451206/index.html">Apa yang terjadi dengan repositori RDF sekarang?</a></li>
<li><a href="../id451210/index.html">Integrasi Jira dengan GitLab</a></li>
<li><a href="../id451212/index.html">Sistem perlindungan busur dengan kemampuan untuk beroperasi pada sinyal saat ini</a></li>
<li><a href="../id451214/index.html">Dasar-dasar kecerdasan buatan modern: bagaimana cara kerjanya, dan apakah itu akan menghancurkan masyarakat kita tahun ini?</a></li>
<li><a href="../id451216/index.html">Cara menonaktifkan Windows Defender sepenuhnya di Windows 10</a></li>
<li><a href="../id451218/index.html">Business Intelligence dalam bahasa Rusia - Quintets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>