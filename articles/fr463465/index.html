<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçü§ù‚Äçüë®üèø üë∫ ‚õπüèæ Le livre ¬´JavaScript expressif. Programmation web moderne. 3e √©dition ‚ò™Ô∏è üïØÔ∏è üë©üèΩ‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, habrozhiteli! Ce livre vous permettra d'approfondir le sujet, d'apprendre √† √©crire du code beau et efficace. Vous d√©couvrirez la syntaxe, les f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le livre ¬´JavaScript expressif. Programmation web moderne. 3e √©dition</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/463465/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/hj/ac/jw/hjacjwa9yynefuv1iquueauasum.jpeg" align="left" alt="image"></a>  Salut, habrozhiteli!  Ce livre vous permettra d'approfondir le sujet, d'apprendre √† √©crire du code beau et efficace.  Vous d√©couvrirez la syntaxe, les fonctions fl√©ch√©es et asynchrones, l'it√©rateur, les cha√Ænes de mod√®le et la port√©e du bloc. <br><br>  Marein Haverbeke - praticienne.  Acqu√©rir de l'exp√©rience et apprendre la langue √† travers une multitude d'exemples √† travers des exercices et des projets de formation.  Tout d'abord, vous vous familiariserez avec la structure du langage JavaScript, la gestion des structures, des fonctions et des structures de donn√©es, puis √©tudierez la gestion des erreurs et la correction des bogues, la modularit√© et la programmation asynchrone, puis passez √† la programmation du navigateur. <br><a name="habracut"></a><br><h3>  Donnez votre avis sur ce livre </h3><br>  Ce livre est divis√© en trois grandes parties.  Les 12 premiers chapitres traitent du langage JavaScript.  Les sept chapitres suivants traitent des navigateurs et de la fa√ßon dont JavaScript est utilis√© pour les programmer.  Enfin, deux chapitres sont consacr√©s √† Node.js, un autre environnement de programmation JavaScript. <br><br>  Tout au long du livre, vous rencontrerez cinq chapitres de projets qui d√©crivent de plus grands exemples de programmes afin que vous puissiez ressentir le go√ªt d'une vraie programmation.  Dans l'ordre de leur apparition, nous travaillerons √† la cr√©ation d'un robot de livraison, d'un langage de programmation, d'une plateforme de jeu, d'un √©diteur graphique raster et d'un site dynamique. <br><br>  La partie linguistique du livre commence par quatre chapitres qui vous pr√©senteront la structure de base du langage JavaScript.  Vous en apprendrez plus sur les structures de contr√¥le (comme le mot-cl√© while, que vous avez d√©j√† vu dans l'introduction), les fonctions (√©crire vos propres blocs de construction) et les structures de donn√©es.  Apr√®s cela, vous pouvez √©crire les programmes les plus simples.  De plus, les chapitres 5 et 6 d√©crivent comment utiliser les fonctions et les objets pour √©crire du code plus abstrait et contr√¥ler sa complexit√©. <br><br>  Apr√®s le chapitre du premier projet, la partie linguistique du livre sera poursuivie - les chapitres suivants sont consacr√©s √† la d√©tection et √† la correction des erreurs, aux expressions r√©guli√®res (un outil important pour travailler avec du texte), √† ‚Äã‚Äãla modularit√© (une autre d√©fense contre la complexit√©) et √† la programmation asynchrone (travailler avec des √©v√©nements qui durent pour certains temps).  La premi√®re partie du livre compl√®te le chapitre du deuxi√®me projet. <br><br>  La deuxi√®me partie, les chapitres 13 √† 19, d√©crit les outils auxquels un navigateur compatible JavaScript a acc√®s.  Vous apprendrez √† afficher des √©l√©ments √† l'√©cran (chapitres 14 et 17), √† r√©pondre aux entr√©es de l'utilisateur (chapitre 15) et √† les partager sur le r√©seau (chapitre 18).  Cette partie contient √©galement deux chapitres de projets. <br><br>  Apr√®s cela, Node.js est d√©crit au chapitre 20 et un petit site est cr√©√© au chapitre 21 √† l'aide de cet outil. <br><br><h3>  Extrait.  Sommation avec r√©duction </h3><br>  Une autre chose courante qui est souvent effectu√©e avec les tableaux est de calculer une valeur unique en fonction d'eux.  Un cas particulier de ceci est l'exemple que nous avons d√©j√† utilis√© avec la sommation d'un ensemble de nombres.  Un autre exemple est de trouver la police contenant le plus de caract√®res. <br><br>  Une op√©ration d'ordre sup√©rieur qui impl√©mente ce mod√®le est appel√©e raccourci (parfois aussi appel√©e convolution).  Cette op√©ration cr√©e la valeur en r√©cup√©rant √† plusieurs reprises un √©l√©ment du tableau et en le combinant avec la valeur actuelle.  Lors de la sommation des nombres, nous partons de z√©ro, puis ajoutons chaque √©l√©ment suivant √† la somme. <br><br>  Les param√®tres de la fonction de r√©duction, en plus du tableau, sont une fonction de combinaison et une valeur initiale.  Cette fonction est un peu plus compliqu√©e que le filtre et la carte, alors regardez-la de plus pr√®s: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array, combine, start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> current = start; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> element <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> array) { current = combine(current, element); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(reduce([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], (a, b) =&gt; a + b, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 10</span></span></code> </pre> <br>  La m√©thode standard pour travailler avec des tableaux r√©duits, qui, bien s√ªr, correspond √† cette fonction, pr√©sente une commodit√© suppl√©mentaire.  Si le tableau contient au moins un √©l√©ment, vous pouvez omettre l'argument de d√©but.  La m√©thode s√©lectionne le premier √©l√©ment du tableau comme valeur initiale et d√©marre la r√©duction √† partir du deuxi√®me √©l√©ment. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 10</span></span></code> </pre> <br>  Pour utiliser r√©duire (deux fois) pour trouver la police avec le plus de caract√®res, nous pouvons √©crire quelque chose comme ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">characterCount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">script</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> script.ranges.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">count, [</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-function"><span class="hljs-params">, to]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count + <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">to ‚Äî </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span></span><span class="hljs-function">); }, 0); } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">console</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SCRIPTS.reduce((a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> characterCount(a) &lt; characterCount(b) ? b : a; })); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí {name: "Han", ...}</span></span></code> </pre> <br>  La fonction characterCount r√©duit les plages affect√©es √† cette police en calculant la somme de leurs tailles.  Faites attention √† l'utilisation de la d√©structuration dans la liste des param√®tres de la fonction de r√©duction.  Ensuite, le deuxi√®me appel √† r√©duire utilise le r√©sultat pr√©c√©dent pour rechercher la police la plus grande, en comparant √† plusieurs reprises les deux polices et en renvoyant la plus grande. <br><br>  La police Han a plus de 89 000 caract√®res qui lui sont attribu√©s dans la norme Unicode, ce qui en fait le plus grand syst√®me d'√©criture de notre ensemble de donn√©es.  Han est une police parfois utilis√©e pour les textes chinois, japonais et cor√©ens.  Leurs langues ont de nombreux caract√®res communs, bien qu'elles soient √©crites diff√©remment.  Le Consortium Unicode (situ√© aux √âtats-Unis) a d√©cid√© de consid√©rer ces caract√®res comme un syst√®me d'enregistrement unique afin de sauvegarder les codes de caract√®res.  Cela s'appelle Han Unification et est toujours tr√®s ennuyeux pour certaines personnes. <br><br><h3>  Composabilit√© </h3><br>  R√©fl√©chissons: comment pourrions-nous r√©√©crire l'exemple pr√©c√©dent (trouver la plus grande police) sans fonctions d'ordre sup√©rieur?  Le code suivant n'est pas bien pire. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> biggest = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> script <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> SCRIPTS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (biggest == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || characterCount(biggest) &lt; characterCount(script)) { biggest = script; } } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(biggest); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí {name: "Han", ...}</span></span></code> </pre> <br>  Plusieurs liaisons suppl√©mentaires sont apparues et le programme est devenu quatre lignes plus longues.  Mais ce code est encore assez clair. <br><br>  Les fonctions d'ordre sup√©rieur commencent √† √™tre vraiment utiles lorsque vous devez composer des op√©rations.  √Ä titre d'exemple, nous allons √©crire un code qui calcule l'ann√©e moyenne de cr√©ation de polices de langues vivantes et mortes dans un ensemble de donn√©es. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">average</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b) / array.length; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(average( SCRIPTS.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.living).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.year)))); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 1188 console.log(Math.round(average( SCRIPTS.filter(s =&gt; !s.living).map(s =&gt; s.year)))); // ‚Üí 188</span></span></code> </pre> <br>  Ainsi, les scripts de langues mortes dans Unicode sont en moyenne plus anciens que les scripts de langues vivantes. <br><br>  Ce ne sont pas des statistiques particuli√®rement importantes ou surprenantes.  J'esp√®re cependant que le code utilis√© pour le calculer est facile √† lire.  Cela peut √™tre imagin√© comme un convoyeur: nous commen√ßons par analyser toutes les polices, filtrer les vivants (ou morts), prendre les ann√©es de leur cr√©ation, calculer la valeur moyenne et arrondir le r√©sultat. <br><br>  Ce calcul pourrait √©galement √™tre repr√©sent√© comme un grand cycle. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>, count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> script <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> SCRIPTS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (script.living) { total += script.year; count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(total / count)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 1188</span></span></code> </pre> <br>  Mais dans ce code, il est plus difficile de comprendre quoi et comment est calcul√©.  Et comme les r√©sultats interm√©diaires ne sont pas pr√©sent√©s comme des valeurs coh√©rentes, il faudrait faire beaucoup plus de travail pour s√©parer quelque chose comme la moyenne dans une fonction distincte. <br><br>  En termes de ce que l'ordinateur fait r√©ellement, ces deux approches sont √©galement fondamentalement diff√©rentes.  Le premier cr√©e de nouveaux tableaux lorsque le filtre et la carte sont ex√©cut√©s, tandis que le second ne calcule que certains nombres, faisant moins de travail.  Habituellement, vous pouvez vous permettre une option plus lisible, mais si vous devez traiter de tr√®s grands tableaux et le faire plusieurs fois, un style moins abstrait peut vous donner un gain de vitesse suppl√©mentaire. <br><br><h3>  Cha√Ænes et codes de caract√®res </h3><br>  Une utilisation des ensembles de donn√©es consiste √† d√©terminer dans quelle police un morceau de texte donn√© est tap√©.  Regardons un programme qui fait cela. <br><br>  Rappelez-vous que pour chaque police, il existe un tableau de plages de codes de caract√®res.  Par cons√©quent, connaissant le code de caract√®re, nous pourrions utiliser la fonction suivante pour trouver la police correspondante (le cas √©ch√©ant): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">characterScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> script <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> SCRIPTS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (script.ranges.some(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-function"><span class="hljs-params">, to]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> code &gt;= <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> &amp;&amp; code &lt; to; })) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> script; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(characterScript(<span class="hljs-number"><span class="hljs-number">121</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí {name: "Latin", ...}</span></span></code> </pre> <br>  La m√©thode some est une autre fonction d'ordre sup√©rieur.  Il prend une fonction de test et signale s'il renvoie vrai pour n'importe quel √©l√©ment du tableau. <br><br>  Mais comment obtenir les codes de caract√®res sous forme de cha√Æne? <br><br>  Dans le chapitre 1, j'ai mentionn√© qu'en JavaScript, les cha√Ænes sont repr√©sent√©es comme des s√©quences de nombres de 16 bits.  Ce sont les soi-disant unit√©s de code.  Initialement, on supposait qu'en Unicode le code de caract√®re sera plac√© dans un tel bloc (ce qui donne un peu plus de 65 000 caract√®res).  Quand il est devenu clair que cela ne suffisait pas, beaucoup ont commenc√© √† s'opposer √† la n√©cessit√© d'utiliser plus de m√©moire pour stocker un caract√®re.  Pour r√©soudre ce probl√®me, le format UTF-16 utilis√© dans les cha√Ænes JavaScript a √©t√© invent√©.  Dans ce document, les caract√®res les plus courants occupent une unit√© de code 16 bits, et le reste - deux unit√©s de code. <br><br>  Aujourd'hui, il est g√©n√©ralement admis que l'UTF-16 √©tait une mauvaise id√©e.  Il semble √™tre cr√©√© pour produire des erreurs.  Vous pouvez facilement √©crire un programme pour lequel les unit√©s de code et les caract√®res sont identiques.  Et si votre langue maternelle n'utilise pas de caract√®res qui occupent deux unit√©s de code, ce programme fonctionnera correctement.  Mais, d√®s que quelqu'un essaie d'utiliser un tel programme pour un alphabet moins courant, par exemple pour les caract√®res chinois, il se casse imm√©diatement.  Heureusement, apr√®s l'√©mergence des √©motic√¥nes, deux unit√©s de code ont commenc√© √† √™tre utilis√©es partout pour le codage des caract√®res, et la charge de r√©soudre de tels probl√®mes a √©t√© r√©partie plus √©quitablement. <br><br>  Malheureusement, les op√©rations √©videntes avec des cha√Ænes JavaScript, telles que l'obtention de leur longueur via la propri√©t√© length et l'acc√®s √† leur contenu √† l'aide de crochets, ne concernent que les unit√©s de code. <br><br><img src="https://habrastorage.org/webt/3j/es/v4/3jesv4isii9yakfk56ng-ezxo_i.png" alt="image"><br><br>  La m√©thode JavaScript charCodeAt ne renvoie pas le code de caract√®re complet, mais une unit√© de code.  La m√©thode codePointAt qui appara√Æt plus tard renvoie le caract√®re Unicode complet.  Nous pourrions donc l'utiliser pour obtenir des caract√®res d'une cha√Æne.  Mais l'argument pass√© √† codePointAt est toujours un index dans une s√©quence d'unit√©s de code.  Ainsi, afin d'it√©rer sur tous les caract√®res d'une cha√Æne, nous devons encore r√©soudre la question de savoir si une ou deux unit√©s de code occupent un caract√®re. <br><br>  Dans le chapitre pr√©c√©dent, j'ai mentionn√© que la boucle for / of peut √©galement √™tre utilis√©e pour les cha√Ænes.  Comme codePointAt, ce type de boucle est apparu √† un moment o√π les programmeurs ont clairement compris les probl√®mes de l'UTF-16.  Lorsque vous appliquez cette boucle √† une cha√Æne, elle donne de vrais caract√®res, pas des unit√©s de code. <br><br><img src="https://habrastorage.org/webt/bh/8v/n_/bh8vn_vzqr45dpffqo7mlseo_wq.png" alt="image"><br><br>  Si vous avez un caract√®re (qui est une cha√Æne d'une ou deux unit√©s de code), pour obtenir son code, vous pouvez utiliser codePointAt (0). <br><br><h3>  Reconnaissance de texte </h3><br>  Nous avons une fonction characterScript et un moyen d'√©num√©rer correctement les caract√®res dans une boucle.  L'√©tape suivante consiste √† compter le nombre de caract√®res appartenant √† chaque police.  Ici, nous avons besoin d'une abstraction de comptage: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items, groupName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counts = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> items) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = groupName(item); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> known = counts.findIndex(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> c.name == name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (known == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { counts.push({name, <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>}); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { counts[known].count++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counts; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(countBy([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>], n =&gt; n &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí [{name: false, count: 2}, {name: true, count: 3}]</span></span></code> </pre> <br>  La fonction countBy accepte une collection (tout ce qui peut √™tre tri√© dans une boucle for / of) et une fonction qui calcule le nom du groupe pour un √©l√©ment donn√©.  La fonction countBy renvoie un tableau d'objets, chacun contenant le nom du groupe et le nombre d'√©l√©ments trouv√©s pour lui. <br><br>  Cette fonction utilise une autre m√©thode de travail avec les tableaux - findIndex.  Cette m√©thode est quelque peu similaire √† indexOf, mais au lieu de rechercher une valeur sp√©cifique, elle trouve la premi√®re valeur pour laquelle la fonction donn√©e renvoie true.  Si l'√©l√©ment n'est pas trouv√©, findIndex, comme indexOf, renvoie ‚Äì1. <br><br>  En utilisant countBy, nous pouvons √©crire une fonction qui indique quelles polices ont √©t√© utilis√©es dans ce morceau de texte. <br><br><img src="https://habrastorage.org/webt/fz/ph/l_/fzphl_qnjsxe6dmsr5rbetd1lam.png" alt="image"><br><br>  La fonction compte d'abord les caract√®res par nom de police, en utilisant characterScript pour leur donner un nom, et retourne la cha√Æne ¬´none¬ª pour les caract√®res qui n'appartiennent √† aucune police.  L'appel du filtre supprime l'entr√©e "none" du tableau r√©sultant, car nous ne sommes pas int√©ress√©s par ces caract√®res. <br><br>  Pour pouvoir calculer des pourcentages, nous devons d'abord obtenir le nombre total de caract√®res appartenant √† la police que nous pouvons calculer en utilisant la m√©thode de r√©duction.  Si aucun de ces caract√®res n'est trouv√©, la fonction renvoie une cha√Æne sp√©cifique.  Sinon, il convertit les r√©sultats du comptage en cha√Ænes lisibles √† l'aide de map, puis les combine √† l'aide de join. <br><br><h3>  R√©sum√© </h3><br>  La possibilit√© de transmettre des valeurs fonctionnelles √† d'autres fonctions est un aspect tr√®s utile de JavaScript.  Cela vous permet de cr√©er des fonctions qui simulent des calculs avec des espaces.  Par la suite, lors de l'appel de telles fonctions dans le code, ces ¬´lacunes¬ª sont remplies de valeurs fonctionnelles. <br><br>  Pour les tableaux, il existe un certain nombre de m√©thodes utiles d'ordre sup√©rieur.  La m√©thode forEach peut √™tre utilis√©e pour parcourir les √©l√©ments d'un tableau.  La m√©thode de filtrage renvoie un nouveau tableau contenant uniquement des √©l√©ments qui satisfont √† la condition de la fonction pr√©dicative.  La conversion de tableau en ex√©cutant une fonction pour chaque √©l√©ment se fait √† l'aide de map.  Pour combiner tous les √©l√©ments d'un tableau en une seule valeur, vous pouvez utiliser r√©duire.  La m√©thode some v√©rifie si un √©l√©ment correspond √† une fonction pr√©dicative donn√©e.  Enfin, la m√©thode findIndex recherche la position du premier √©l√©ment qui correspond au pr√©dicat. <br><br>  ¬ªPlus d'informations sur le livre sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de l'√©diteur</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contenu</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Extrait</a> <br><br>  25% de r√©duction sur les colporteurs - <b>JavaScript</b> <br>  Lors du paiement de la version papier du livre, un livre √©lectronique est envoy√© par e-mail. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr463465/">https://habr.com/ru/post/fr463465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr463447/index.html">Astra Linux 1.6 (Smolensk). Le syst√®me est-il pr√™t √† fonctionner avec des utilisateurs ordinaires? Exemples de b√©quilles</a></li>
<li><a href="../fr463455/index.html">Des milliers de choses √† corriger en Java √† partir de la premi√®re version: une grande interview avec Sergey Kuksenko d'Oracle</a></li>
<li><a href="../fr463459/index.html">Erreurs cach√©es avec les transitions d'√©l√©ment partag√©</a></li>
<li><a href="../fr463461/index.html">Ce qui est et ce qui n'est pas dans Go. Partie 1</a></li>
<li><a href="../fr463463/index.html">M√©thode pour cr√©er un effet DRAG et DROP</a></li>
<li><a href="../fr463469/index.html">Chat Schrodinger sans bo√Æte: le probl√®me du consensus dans les syst√®mes distribu√©s</a></li>
<li><a href="../fr463471/index.html">Fonctionnalit√© bascule: vues, avantages et utilisation avec eux dans .NET</a></li>
<li><a href="../fr463473/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 16. R√©seautage dans un petit bureau</a></li>
<li><a href="../fr463481/index.html">Math√©matiques discr√®tes pour WMS: algorithme de compression des marchandises dans les cellules (partie 1)</a></li>
<li><a href="../fr463483/index.html">Collaboration sur les documents, chat d'entreprise mis √† jour et application mobile: Nouveaut√©s de Zextras Suite 3.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>