<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏾 🌒 🤴 11 façons (de ne pas) devenir victime de piratage à Kubernetes 🧓🏻 🖋️ 📦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Remarque perev. : L'original de cet article a été publié sur le blog officiel de Kubernetes et écrit par Andrew Martin, l'un des fondateurs de la jeun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>11 façons (de ne pas) devenir victime de piratage à Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/417905/">  <i><b>Remarque</b></i>  <i><b>perev.</b></i>  <i>: L'original de cet article a été publié sur le blog officiel de Kubernetes et écrit par Andrew Martin, l'un des fondateurs de la jeune société britannique Control Plane, spécialisée dans la sécurité des applications cloud natives fonctionnant sur K8.</i> <br><br><img src="https://habrastorage.org/webt/em/sv/dw/emsvdwgvf4ym5fydg8ob7jxomcq.jpeg"><br><br>  La sécurité à Kubernetes a parcouru un long chemin depuis l'arrivée du projet, mais des écueils persistent.  Nous proposons une liste de recommandations utiles sur la façon de protéger les clusters et d'augmenter leur stabilité en cas de piratage: nous allons commencer par le plan de contrôle, continuer avec les charges de travail et la sécurité du réseau, et terminer par une évaluation de la sécurité future. <a name="habracut"></a><br><br><h2>  Partie 1: Plan de contrôle </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le plan de contrôle</a> est le cerveau de Kubernetes.  Il a une idée générale de chaque conteneur et pod s'exécutant dans le cluster, peut planifier de nouveaux pods (qui peuvent contenir des conteneurs avec un accès root à leurs nœuds parents) et peut lire tous les secrets stockés dans le cluster.  Il s'agit d'un composant très important qui nécessite une protection constante contre les fuites accidentelles de données et les actions malveillantes: à la fois lors de son accès, lorsque rien ne se produit et lorsque les données sont transmises sur le réseau. <br><br><h3>  1. TLS ubiquitaire </h3><br>  <b>Pour chaque composant qui prend en charge TLS, il doit être activé - pour empêcher le reniflement du trafic, la vérification de l'identité du serveur et (dans le cas de Mutual TLS) la vérification de l'identité du client.</b> <br><br><blockquote>  "Veuillez noter que certains composants et méthodes d'installation peuvent activer les ports locaux pour HTTP, les administrateurs doivent donc se familiariser avec les paramètres de chaque composant pour identifier les chemins possibles pour le trafic non sécurisé." <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Depuis la documentation de Kubernetes</a></i> </blockquote><br>  Le schéma de réseau ci-dessous de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lucas Käldström</a> montre où TLS est idéalement nécessaire: entre chaque composant de l'assistant, et entre Kubelet et le serveur API.  Le classique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kelsey Hightower</a> <a href="">Kubernetes The Hard Way</a> et la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation de sécurité sur etcd</a> offrent des instructions détaillées pour atteindre ces objectifs. <br><br><img src="https://habrastorage.org/webt/tl/z6/9p/tlz69p-_qgydpvdbkb8i0wkwjlm.png"><br><br>  Historiquement, la mise à l'échelle automatique des nœuds Kubernetes n'était pas facile, car chaque nœud nécessitait une clé TLS pour se connecter au maître, et garder les secrets dans les images de base est une mauvaise pratique.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'amorçage Kubelet TLS</a> permet au nouveau Kubelet de créer une demande de signature de certificat afin que les certificats soient générés au démarrage: <br><br><img src="https://habrastorage.org/webt/js/7x/bw/js7xbwddp6cgld-bgcp20r657qy.png"><br><br><h3>  2. Privilèges minimum dans RBAC, désactivation d'ABAC, surveillance des journaux </h3><br>  <b>Le contrôle d'accès basé sur les rôles (RBAC) fournit une gestion de stratégie précise par laquelle les utilisateurs accèdent aux ressources telles que les espaces de noms.</b> <br><br><img src="https://habrastorage.org/webt/if/so/hz/ifsohz4fgeo5alqvpe4pbvimujq.png"><br><br>  Le contrôle d'accès basé sur les attributs (ABAC) dans Kubernetes a été remplacé par RBAC depuis K8s 1.6 et ne doit pas être activé du côté serveur de l'API.  Utilisez plutôt RBAC: <code>--authorization-mode=RBAC</code> (ou cet indicateur pour GKE: --no <code>--no-enable-legacy-authorization</code> ). <br><br>  Il existe de nombreux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bons exemples de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stratégies RBAC</a> pour divers services dans un cluster, ainsi que de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> .  Mais ne vous arrêtez pas là: les paramètres compétents pour les stratégies RBAC peuvent être obtenus en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">audit2rbac à</a> partir des journaux d' <code>audit</code> . <br><br>  Des politiques RBAC incorrectes ou trop permissives constituent un risque pour la sécurité si le foyer est compromis.  Le maintien des règles du RBAC avec des privilèges minimaux, leur audit permanent et leur amélioration devraient faire partie de «l'hygiène technique de la dette» que les équipes appliquent dans le cycle de vie du développement. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La journalisation d'audit</a> (bêta dans Kubernetes 1.10) offre une API de journalisation personnalisée pour les charges de travail (telles que les demandes et les réponses) et au niveau des métadonnées.  Le niveau de journalisation peut être configuré conformément à la politique de sécurité de l'organisation - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GKE</a> applique des valeurs par défaut raisonnables pour ceux qui commencent tout juste à l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utiliser</a> . <br><br>  Pour les demandes de lecture telles que <i>get</i> , <i>list</i> et <i>watch</i> , seul l'objet demandé est stocké dans les journaux d'audit, sans objet de réponse.  Pour les requêtes impliquant des données sensibles comme <i>Secret</i> ou <i>ConfigMap</i> , seules les métadonnées sont exportées.  Pour toutes les autres demandes, les deux objets sont enregistrés dans les journaux d'audit: à la fois la demande et la réponse. <br><br>  N'oubliez pas: le stockage de ces journaux à l'intérieur du cluster est un risque de sécurité en cas de compromis.  Ces journaux, comme tous les autres sensibles à la sécurité, doivent être placés en dehors du cluster afin d'éviter des conséquences négatives en cas de vulnérabilité. <br><br><h3>  3. Utilisez l'authentification tierce pour le serveur API </h3><br>  <b>La centralisation de l'authentification et de l'autorisation pour l'ensemble de l'organisation (c'est-à-dire, l'authentification unique) facilite les processus d'acceptation et de départ de nouveaux employés, garantissant des droits d'accès cohérents.</b> <br><br>  L'intégration de Kubernetes avec des fournisseurs d'authentification tiers (comme Google ou GitHub) offre des garanties d'identité à partir d'une plate-forme distante (avec une protection comme l'authentification à deux facteurs) et élimine la nécessité pour les administrateurs de reconfigurer le serveur API dans Kubernetes pour ajouter / supprimer des utilisateurs. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dex</a> est un fournisseur OpenID Connect Identity (OIDC) et OAuth 2.0 avec des plug-ins.  Pusher est allé encore plus loin en fournissant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des outils personnalisables</a> , auxquels s'ajoutent d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autres</a> aides axées sur d'autres applications. <br><br><h3>  4. Séparez et placez votre cluster, etc. derrière le pare-feu </h3><br>  <b>etcd stocke des informations sur l'état et les secrets de Kubernetes, est un composant essentiel des K8 - il doit être protégé séparément du reste du cluster.</b> <br><br>  L'accès en écriture à etcd sur le serveur API équivaut à attribuer des droits root à l'ensemble du cluster, et même l'accès en lecture peut être facilement utilisé pour augmenter les privilèges. <br><br>  Le planificateur Kubernetes dans etcd recherche les définitions de pod qui n'ont pas de nœud.  Il envoie ensuite tous les pods trouvés au Kubelet disponible pour la planification.  La validation de ces pods est effectuée par le serveur API avant de les écrire dans etcd, de sorte que les attaquants écrivant directement dans etcd peuvent contourner de nombreux mécanismes de sécurité - par exemple, <code>PodSecurityPolicies</code> . <br><br>  etcd doit être configuré avec les <a href="">deux certificats TLS</a> ( <i>client</i> et <i>homologue</i> ) et déployé sur des nœuds dédiés.  Pour réduire le risque de vol et d'utilisation de clés privées des nœuds de travail, vous pouvez également limiter le pare-feu du cluster API Server. <br><br><h3>  5. Rotation des clés de cryptage </h3><br>  <b>La rotation régulière des clés de sécurité et des certificats est la meilleure pratique de sécurité qui vous permet de limiter le "rayon de destruction" lorsque la clé est compromise.</b> <br><br>  Kubernetes effectuera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">automatiquement la rotation de</a> certains certificats (en particulier, les certificats client et serveur Kubelet) en créant de nouveaux CSR après l'expiration des certificats actuels. <br><br>  Cependant, les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">clés symétriques</a> utilisées par le serveur API pour crypter les valeurs etcd ne sont pas tournées automatiquement - cela doit être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fait manuellement</a> .  Cette opération nécessite un accès maître, donc les services gérés (comme GKE et AKS) cachent le problème à l'utilisateur. <br><br><h2>  Partie 2: charges de travail </h2><br>  Avec une sécurité minimale au niveau du plan de contrôle, le cluster peut déjà fonctionner en toute sécurité.  Cependant, comme pour un navire avec une cargaison potentiellement dangereuse, les conteneurs d'un tel navire doivent protéger la cargaison en cas d'accident ou de fuite imprévus.  Il en va de même pour les charges de travail Kubernetes (pods, <i>déploiements</i> , <i>travaux</i> , <i>ensembles</i> , etc.) - elles peuvent être fiables au moment du déploiement, mais si elles sont accessibles de l'extérieur, il y a toujours un risque qu'elles soient exploitées ultérieurement par [les attaquants].  Ce risque peut être atténué en exécutant des charges de travail avec des privilèges minimaux et leur configuration sécurisée. <br><br><h3>  6. Utilisez les fonctionnalités de sécurité Linux et PodSecurityPolicies </h3><br>  <b>Le noyau Linux possède de nombreuses extensions de sécurité se chevauchant partiellement (capacités, SELinux, AppArmor, seccomp-bpf) qui peuvent être configurées pour accorder aux applications des privilèges minimaux.</b> <br><br>  Des utilitaires comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bane</a> vous aideront à générer des profils pour AppArmor, et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docker-slim</a> vous aidera à générer des profils seccomp, mais soyez prudent: pour identifier tous les effets secondaires de l'application de ces politiques, vous avez besoin d'une suite de tests complète qui vérifie l'intégralité du code de l'application. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PodSecurityPolicies</a> régit l'utilisation de ces extensions de sécurité, ainsi que d'autres directives de sécurité Kubernetes.  Ils sont responsables des exigences minimales qui doivent être remplies pour accéder au serveur API, y compris les profils de sécurité, l'indicateur de privilège, le réseau hôte partagé, les processus ou les espaces de noms pour IPC. <br><br>  Ces directives sont importantes car elles aident à empêcher les processus conteneurisés d'échapper à leurs limites isolées.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'exemple PodSecurityPolicy de Tim Allclair est</a> très polyvalent - vous pouvez le prendre comme base et le personnaliser pour votre cas. <br><br><h3>  7. Effectuer une analyse statique de YAML </h3><br>  <b>Si PodSecurityPolicies restreint l'accès au serveur API, une analyse statique peut également être utilisée dans le processus de développement pour modéliser les exigences réglementaires de l'organisation et l'appétit pour le risque.</b> <br><br>  Les informations sensibles ne doivent pas être stockées dans des ressources YAML comme les foyers ( <i>pods</i> , <i>déploiements</i> , <i>ensembles</i> , etc.), et les <i>ConfigMaps</i> et <i>Secrets</i> sensibles doivent être cryptés avec des utilitaires comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vault</a> (avec un opérateur de CoreOS), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">git-crypt</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">secrets scellés</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cloud KMS fournisseur</a> . <br><br>  L'analyse statique de la configuration YAML peut être utilisée comme base de sécurité lors du démarrage.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">kubesec</a> génère des évaluations des risques pour les ressources: <br><br><pre> <code class="plaintext hljs">{ "score": -30, "scoring": { "critical": [{ "selector": "containers[] .securityContext .privileged == true", "reason": "Privileged containers can allow almost completely unrestricted host access" }], "advise": [{ "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege" }, { "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "href": "https://kubernetes.io/docs/tasks/configure-pod-container/security-context/" }] } }</code> </pre> <br>  Et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">kubetest</a> est un cadre pour les tests unitaires des configurations Kubernetes: <br><br><pre> <code class="go hljs">#<span class="hljs-comment"><span class="hljs-comment">// vim: set ft=python: def test_for_team_label(): if spec["kind"] == "Deployment": labels = spec["spec"]["template"]["metadata"]["labels"] assert_contains(labels, "team", "should indicate which team owns the deployment") test_for_team_label()</span></span></code> </pre> <br>  Ces utilitaires implémentent l'approche de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">décalage à gauche</a> (c'est-à-dire qu'ils déplacent la validation et la vérification aux premiers stades du cycle de développement).  Les tests de sécurité au stade du développement donnent aux utilisateurs un retour rapide sur le code et la configuration, qui peuvent ensuite être rejetés par vérification manuelle ou automatisée, et peuvent également faciliter l'introduction de pratiques de sécurité supplémentaires. <br><br><h3>  8. Exécutez les conteneurs non root </h3><br>  <b>Les conteneurs qui s'exécutent en tant que root ont souvent beaucoup plus de droits que ne l'exigent leurs charges de travail, et s'ils sont compromis, ils aident les attaquants à atteindre de grandes capacités.</b> <br><br>  Les conteneurs reposent toujours sur le modèle de sécurité UNIX traditionnel (appelé DAC, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contrôle d'accès discrétionnaire</a> ) - tout est un fichier et des droits sont accordés aux utilisateurs et aux groupes. <br><br>  Les espaces de noms utilisateur ne fonctionnent pas dans Kubernetes.  Cela signifie que la table d'ID utilisateur dans le conteneur est mappée à la table utilisateur hôte et que le démarrage du processus avec des privilèges root à l'intérieur du conteneur le fait s'exécuter avec des privilèges root sur l'hôte.  Bien que des mécanismes soient ajoutés à tout cela pour empêcher la sortie du conteneur, l'exécution en tant que root à l'intérieur du conteneur n'est pas recommandée. <br><br>  De nombreuses images de conteneurs utilisent l'utilisateur root pour exécuter le PID 1: si ce processus est compromis, l'attaquant obtient root dans le conteneur et, avec toute erreur de configuration, l'opération du problème devient beaucoup plus facile. <br><br>  Bitnami a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fait un excellent travail</a> de traduction de leurs images de conteneur aux utilisateurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réguliers (non root)</a> (ce qui est également l'exigence d'OpenShift par défaut), ce qui peut également simplifier votre migration vers des images non root. <br><br>  Ce fragment PodSecurityPolicy empêche les processus racine de s'exécuter dans le conteneur et de remonter à la racine: <br><br><pre> <code class="plaintext hljs"># Required to prevent escalations to root. allowPrivilegeEscalation: false runAsUser: # Require the container to run without root privileges. rule: 'MustRunAsNonRoot'</code> </pre> <br>  Les conteneurs qui n'utilisent pas root ne peuvent pas occuper des ports privilégiés, c'est-à-dire  jusqu'à 1024 (la capacité correspondante dans le noyau Linux - <code>CAP_NET_BIND_SERVICE</code> est responsable), cependant, l'utilisation des <i>services</i> permet de contourner cette limitation.  Voici un exemple pour l'application MyApp, qui occupe le port 8443 dans le conteneur, mais <i>Service le</i> rend disponible sur le port 443, en mandatant les demandes de <code>targetPort</code> : <br><br><pre> <code class="plaintext hljs">kind: Service apiVersion: v1 metadata: name: my-service spec: selector: app: MyApp ports: - protocol: TCP port: 443 targetPort: 8443</code> </pre> <br>  La nécessité d'exécuter des charges de travail sans utiliser root restera jusqu'à ce que l'espace de nom de l'utilisateur ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le temps de fonctionnement</a> pour le lancement de conteneurs sans root soient inclus dans l'exécution du conteneur. <br><br><h3>  9. Utilisez des politiques de réseau </h3><br>  <b>Par défaut, le réseau Kubernetes autorise tout le trafic entre les pods.</b>  <b>Ce paramètre peut être limité par la stratégie réseau - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>NetworkPolicy</i></a> .</b> <br><br><img src="https://habrastorage.org/webt/kd/cv/xu/kdcvxufrkq2dm0jw13vk8hvowae.png"><br><br>  Les services traditionnels sont limités aux pare-feu utilisant des adresses IP statiques et des plages de ports pour chaque service.  Parce que ces adresses IP changent très rarement, elles ont historiquement été utilisées comme une forme d'authentification.  Les conteneurs ont rarement des adresses IP statiques - leur nature implique la possibilité d'une suppression et d'une recréation rapides, pour eux, la découverte de services est utilisée à la place des adresses IP statiques.  Ces fonctionnalités compliquent considérablement la configuration et la vérification des pare-feu. <br><br>  Étant donné que Kubernetes stocke toutes les données sur l'état du système dans etcd, il est possible de configurer un pare-feu dynamique - s'il existe le support nécessaire dans le plugin réseau CNI.  Calico, Cilium, kube-router, Romana et Weave Net - tous ces plugins prennent en charge les politiques réseau. <br><br>  Il est important de noter que les politiques fonctionnent sur le principe de la fermeture en cas de défaillance, c'est-à-dire que l'absence d'un <code>podSelector</code> ici par défaut est égale à toutes les valeurs possibles (caractère générique): <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default-deny spec: podSelector:</code> </pre> <br>  Ce qui suit est un exemple de <i>NetworkPolicy</i> , qui interdit tout de la sortie sauf UDP 53 (DNS), qui empêche également les connexions entrantes à l'application.  <i>NetworkPolicies</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sont des</a> stratégies avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">état</a> , de sorte que l'application recevra toujours des réponses aux connexions sortantes. <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: myapp-deny-external-egress spec: podSelector: matchLabels: app: myapp policyTypes: - Egress egress: - ports: - port: 53 protocol: UDP - to: - namespaceSelector: {}</code> </pre> <br>  Les stratégies de réseau Kubernetes ne peuvent pas être appliquées aux noms DNS.  La raison en est que DNS prend en charge la répétition alternée vers plusieurs adresses IP et les réponses dynamiques en fonction de l'adresse IP accédant, de sorte que les stratégies réseau s'appliquent uniquement aux adresses IP fixes ou <code>podSelector</code> (pour les adresses IP dynamiques Kubernetes). <br><br>  La meilleure pratique consiste à commencer par interdire tout le trafic pour l'espace de noms et à ajouter pas à pas les itinéraires requis par l'application pour réussir les tests d'acceptation.  Le processus peut être difficile, donc ControlPlane a développé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">netassert</a> , un utilitaire pour tester la sécurité du réseau dans les scripts DevSecOps avec nmap hautement parallèle: <br><br><pre> <code class="plaintext hljs">k8s: # used for Kubernetes pods deployment: # only deployments currently supported test-frontend: # pod name, defaults to `default` namespace test-microservice: 80 # `test-microservice` is the DNS name of the target service test-database: -80 # `test-frontend` should not be able to access test-database's port 80 169.254.169.254: -80, -443 # AWS metadata API metadata.google.internal: -80, -443 # GCP metadata API new-namespace:test-microservice: # `new-namespace` is the namespace name test-database.new-namespace: 80 # longer DNS names can be used for other namespaces test-frontend.default: 80 169.254.169.254: -80, -443 # AWS metadata API metadata.google.internal: -80, -443 # GCP metadata API</code> </pre> <br>  Une API avec des métadonnées d'un fournisseur de cloud est une source constante d'escalade potentielle (démontrée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par la</a> récente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prime de bogue de Shopify</a> ), donc des tests spéciaux confirmant que l'API est bloquée sur le réseau de conteneurs aideront à se protéger contre les erreurs de configuration. <br><br><h3>  10. Numérisez des images et exécutez IDS </h3><br>  <b>Les serveurs Web sont un tremplin pour attaquer les réseaux auxquels ils sont connectés.</b>  <b>L'analyse des fichiers installés dans les images vous permet de vérifier qu'il n'existe aucune vulnérabilité connue qu'un attaquant pourrait utiliser pour accéder à distance au conteneur.</b>  <b>Les systèmes de détection d'intrusion (IDS) enregistrent ces événements s'ils se produisent.</b> <br><br>  Kubernetes permet des soumissions au cluster via un ensemble de vérifications de contrôle (dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contrôleur d'admission</a> ), qui s'appliquent non seulement aux pods, mais également à d'autres ressources comme les <i>déploiements</i> .  Dans ceux-ci, chaque sous-marin peut être validé pour l'admission ou son contenu peut être modifié, en plus des webhooks du côté backend sont désormais également pris en charge. <br><br><img src="https://habrastorage.org/webt/0s/-h/fw/0s-hfwbv4xf-izil5ljtxjxdyjm.png"><br><br>  Ces webhooks peuvent être utilisés par des outils d'analyse d'images de conteneur pour vérifier les images avant leur déploiement sur le cluster.  Les images qui échouent à la validation ne recevront pas l'approbation du contrôleur. <br><br>  L'analyse des images de conteneurs à la recherche de vulnérabilités connues permet de réduire le temps pendant lequel un attaquant peut tirer parti d'un CVE ouvert.  Pour empêcher le déploiement d'images présentant des vulnérabilités critiques dans le pipeline de déploiement, vous pouvez utiliser des utilitaires gratuits tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Clair</a> de CoreOS et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Micro Scanner</a> d'Aqua. <br><br>  Des outils tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Grafeas</a> vous permettent de stocker des métadonnées d'image pour des vérifications continues de conformité et de vulnérabilité à l'aide d'une signature de conteneur unique (ou d'un hachage spécial d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">adressage de contenu</a> ).  La numérisation d'une image de conteneur à l'aide de ce hachage équivaut à numériser des images déployées en production et peut être effectuée en continu sans avoir besoin d'accéder aux environnements de production. <br><br>  Des vulnérabilités 0day inconnues existeront toujours, donc Kubernetes devrait déployer un système de détection d'intrusion comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Twistlock</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Aqua</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sysdig Secure</a> .  IDS détecte un comportement inhabituel dans le conteneur et l'arrête ou le tue.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Falco de Sysdig</a> est un moteur de règles Open Source et le point de départ de cet écosystème. <br><br><h2>  Partie 3: L'avenir </h2><br>  La prochaine étape de la sécurité dans «l'évolution du cloud natif» semble être le maillage de service, bien que son adoption ne se produise pas immédiatement: cette migration nécessite de déplacer la complexité des applications vers l'infrastructure de maillage, et les organisations doivent mettre en œuvre cette meilleure pratique. <br><br><img src="https://habrastorage.org/webt/rm/qu/_m/rmqu_mfve6uvnnlaidl_bkjutqm.png"><br><br><h3>  11. Lancez le maillage de service </h3><br>  <b>Le maillage de service est un réseau de connexions chiffrées persistantes établies entre des «proxy connectés» <i>(similaires à «side-car»)</i> , des proxys hautes performances comme Envoy et Linkerd.</b>  <b>Il apporte la gestion, la surveillance et les politiques du trafic, le tout sans modification des microservices.</b> <br><br>  Le transfert de la sécurité et du code réseau des microservices vers un ensemble de bibliothèques partagées et testées au combat était déjà possible avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Linkerd</a> , et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Istio</a> de Google, IBM et Lyft a apporté une alternative à cet espace.  Avec l'ajout de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SPIFFE</a> pour l'identité cryptographique de chaque module et de nombreuses autres fonctionnalités, Istio peut simplifier le déploiement de la sécurité réseau de nouvelle génération. <br><br>  Dans les réseaux de «confiance zéro», il peut ne pas être nécessaire d'avoir un pare-feu traditionnel ou des politiques de réseau Kubernetes, car chaque interaction se produit à l'aide de mTLS (Mutual TLS), qui non seulement garantit la sécurité de l'interaction, mais confirme également l'identité des deux services. . <br><br>  Ce passage des approches réseau traditionnelles aux principes de sécurité du monde de Cloud Native ne sera pas facile pour ceux qui ont une mentalité de sécurité traditionnelle.  Comme introduction à ce nouveau monde, nous recommandons fortement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le livre Zero Trust Networking</a> par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Evan Gilman</a> de SPIFFE. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Istio 0.8 LTS</a> est actuellement disponible et le projet approche rapidement de sa version 1.0.  Le versioning du projet en termes de stabilité est réalisé de manière similaire au modèle Kubernetes: un noyau stable avec des API distinctes pour lesquelles leur statut alpha ou beta est indiqué à l'aide d'espaces de noms.  Attendez-vous à voir Istio se développer dans les prochains mois. <br><br><h2>  Conclusion </h2><br>  Les applications cloud natives disposent d'un ensemble plus détaillé de primitives de sécurité légères qui aident à protéger les charges de travail et l'infrastructure.  La puissance et la flexibilité de ces outils sont à la fois une bénédiction et une malédiction: sans une automatisation suffisante [pour leur utilisation], exposer des applications dangereuses pour aller au-delà du conteneur ou leur modèle d'isolement est devenu encore plus facile. <br><br>  Les utilitaires de protection sont plus accessibles que jamais, cependant, pour réduire le potentiel d'attaque et le risque de configurations incorrectes, vous devez les utiliser avec prudence. <br><br>  Si la sécurité ralentit la vitesse de l’organisation à apporter des changements, ce ne sera jamais une priorité.  L'utilisation des principes de la livraison continue en relation avec la chaîne d'approvisionnement des logiciels permet à l'organisation d'atteindre la conformité réglementaire, un audit continu et une gestion améliorée sans affecter les performances de l'entreprise. <br><br>  L'amélioration rapide et incrémentielle de la sécurité est le moyen le plus simple avec une suite de tests complète.    Continuous Security —          pipeline', ,    ,     . <br><br><h2>  PS du traducteur </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OPA  SPIFFE —     CNCF    </a> »; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vulnerable Docker VM — -  Docker  pentesting</a> »; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  service mesh      [    ]?</a>  "; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conduit —  service mesh  Kubernetes</a> »; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">      Kubernetes</a> »; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Infrastructure avec Kubernetes en tant que service abordable</a> .» </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417905/">https://habr.com/ru/post/fr417905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417895/index.html">Réparation d'imprimantes 3D et de machines-outils: comment fonctionne le service Top 3D Shop à Moscou et Saint-Pétersbourg</a></li>
<li><a href="../fr417897/index.html">PHP Digest n ° 135 (9-23 juillet 2018)</a></li>
<li><a href="../fr417899/index.html">Rechercher des nœuds de variance de contrôle (comment arrêter de faire un travail stupide et le transférer à un autre)</a></li>
<li><a href="../fr417901/index.html">Comment nous avons commencé à faire de longues réunions impressionnantes, et pourquoi ce n'est plus un mal universel</a></li>
<li><a href="../fr417903/index.html">Cas de révision de code 1</a></li>
<li><a href="../fr417909/index.html">Pourquoi avez-vous besoin de Splunk? Analyse d'application</a></li>
<li><a href="../fr417911/index.html">Conception continue en développement: méthodologie et principe</a></li>
<li><a href="../fr417913/index.html">Optimisation du rendu d'une scène du dessin animé Disney "Moana". 3e partie</a></li>
<li><a href="../fr417915/index.html">Comment jouer à un colocataire</a></li>
<li><a href="../fr417917/index.html">ASC'18: Persévérance et entraînement régulier comme moyen d'atteindre l'objectif</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>