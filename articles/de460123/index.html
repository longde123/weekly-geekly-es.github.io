<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🎓 🥡 ↘️ Eine deklarative Datenverarbeitungspipeline über den Akteuren? Warum nicht? 👨🏻‍🍳 🍋 👔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einiger Zeit wurden wir in einer Diskussion über eine der Versionen von SObjectizer gefragt: "Ist es möglich, ein DSL zur Beschreibung einer Daten...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine deklarative Datenverarbeitungspipeline über den Akteuren? Warum nicht?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460123/"><p>  Vor einiger Zeit wurden wir in einer Diskussion über eine der Versionen von SObjectizer gefragt: "Ist es möglich, ein DSL zur Beschreibung einer Datenverarbeitungspipeline zu erstellen?"  Mit anderen Worten, ist es möglich, so etwas zu schreiben: </p><br><p><code>A | B | C | D</code> </p> <br><p>  und erhalten Sie eine funktionierende Pipeline, in der Nachrichten von A nach B und dann nach C und dann nach D geleitet werden. Mit der Kontrolle erhält B genau den Typ, den A zurückgibt.  Und C empfängt genau den Typ, den B zurückgibt.  Und so weiter. </p><br><p>  Es war eine interessante Aufgabe mit einer überraschend einfachen Lösung.  So kann beispielsweise die Erstellung einer Pipeline aussehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pipeline = make_pipeline(env, stage(A) | stage(B) | stage(C) | stage(D));</code> </pre> <br><p>  Oder in einem komplexeren Fall (der unten diskutiert wird): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alarm_detected &amp; v ) { alarm_distribution( <span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span>, v ); } ) ) ) );</code> </pre> <br><p>  In diesem Artikel werden wir über die Implementierung eines solchen Pipeline-DSL sprechen.  Wir werden hauptsächlich Teile im Zusammenhang mit <code>stage()</code> , <code>broadcast()</code> und <code>operator|()</code> -Funktionen mit mehreren Beispielen für die Verwendung von C ++ - Vorlagen diskutieren.  Ich hoffe, es wird auch für Leser interessant sein, die nichts über SObjectizer wissen (wenn Sie noch nie von SObjectizer gehört haben, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> eine Übersicht über dieses Tool). </p><a name="habracut"></a><br><h1 id="a-couple-of-words-about-the-used-demo">  Ein paar Worte zur verwendeten Demo </h1><br><p>  Das in diesem Artikel verwendete Beispiel wurde von meiner alten (und eher vergessenen) Erfahrung im SCADA-Bereich beeinflusst. </p><br><p>  Die Idee der Demo ist der Umgang mit Daten, die von einem Sensor gelesen werden.  Die Daten werden von einem Sensor mit einer gewissen Zeitspanne erfasst, dann müssen diese Daten validiert (falsche Daten sollten ignoriert werden) und in einige tatsächliche Werte umgewandelt werden.  Beispielsweise können die von einem Sensor gelesenen Rohdaten zwei 8-Bit-Ganzzahlwerte sein, und diese Werte sollten in eine Gleitkommazahl umgewandelt werden. </p><br><p>  Dann sollten die gültigen und konvertierten Werte archiviert, irgendwo verteilt (z. B. auf verschiedenen Knoten zur Visualisierung) und auf "Alarme" überprüft werden (wenn Werte außerhalb sicherer Bereiche liegen, sollte dies speziell behandelt werden).  Diese Operationen sind unabhängig und können parallel ausgeführt werden. </p><br><p>  Operationen, die sich auf den erkannten Alarm beziehen, können auch parallel ausgeführt werden: Ein "Alarm" sollte ausgelöst werden (damit der Teil von SCADA auf dem aktuellen Knoten darauf reagieren kann) und die Informationen über den "Alarm" sollten an anderer Stelle verteilt werden (z. B.) : in einer historischen Datenbank gespeichert und / oder auf dem Display des SCADA-Bedieners visualisiert). </p><br><p>  Diese Logik kann in Textform folgendermaßen ausgedrückt werden: </p><br><pre> <code class="plaintext hljs">optional(valid_raw_data) = validate(raw_data); if valid_raw_data is not empty then { converted_value = convert(valid_raw_data); do_async archive(converted_value); do_async distribute(converted_value); do_async { optional(suspicious_value) = check_range(converted_value); if suspicious_value is not empty then { optional(alarm) = detect_alarm(suspicious_value); if alarm is not empty then { do_async initiate_alarm(alarm); do_async distribute_alarm(alam); } } } }</code> </pre> <br><p>  Oder in grafischer Form: </p><br><p><img src="https://habrastorage.org/webt/5z/nm/vv/5znmvvaqnou_qwh808t8vkbrdc8.jpeg"></p><br><p>  Es ist ein ziemlich künstliches Beispiel, aber es hat einige interessante Dinge, die ich zeigen möchte.  Das erste ist das Vorhandensein paralleler Stufen in einer Pipeline (Operation <code>broadcast()</code> existiert nur deswegen).  Das zweite ist das Vorhandensein eines Staates in einigen Stadien.  Zum Beispiel ist alarm_detector eine Stateful-Phase. </p><br><h1 id="pipeline-capabilities">  Pipeline-Funktionen </h1><br><p>  Eine Pipeline wird aus getrennten Stufen aufgebaut.  Jede Stufe ist eine Funktion oder ein Funktor des folgenden Formats: </p><br><pre> <code class="cpp hljs">opt&lt;Out&gt; func(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> In &amp;);</code> </pre> <br><p>  oder </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> In &amp;)</span></span></span></span>;</code> </pre> <br><p>  Stufen, die <code>void</code> können nur als letzte Stufe einer Pipeline verwendet werden. </p><br><p>  Stufen sind zu einer Kette verbunden.  Jede nächste Stufe erhält ein Objekt, das von der vorherigen Stufe zurückgegeben wurde.  Wenn die vorherige Stufe den leeren Wert <code>opt&lt;Out&gt;</code> zurückgibt, wird die nächste Stufe nicht aufgerufen. </p><br><p>  Es gibt eine spezielle <code>broadcast</code> .  Es besteht aus mehreren Pipelines.  Eine <code>broadcast</code> empfängt ein Objekt aus der vorherigen Stufe und sendet es an jede Tochterpipeline. </p><br><p>  Aus Sicht der Pipeline sieht die <code>broadcast</code> Phase wie eine Funktion des folgenden Formats aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> In &amp;)</span></span></span></span>;</code> </pre> <br><p>  Da es keinen Rückgabewert von der <code>broadcast</code> Stufe gibt, kann eine <code>broadcast</code> Stufe nur die letzte Stufe in einer Pipeline sein. </p><br><h2 id="why-does-the-pipeline-stage-return-an-optional-value">  Warum gibt die Pipeline-Stufe einen optionalen Wert zurück? </h2><br><p>  Dies liegt daran, dass einige eingehende Werte gelöscht werden müssen.  Beispielsweise gibt die <code>validate</code> nichts zurück, wenn ein Rohwert falsch ist und es keinen Sinn macht, damit umzugehen. </p><br><p>  Ein weiteres Beispiel: Die Stufe <code>alarm_detector</code> gibt nichts zurück, wenn der aktuelle verdächtige Wert keinen neuen Alarmfall erzeugt. </p><br><h1 id="implementation-details">  Implementierungsdetails </h1><br><h2 id="types-and-functions-related-to-the-application-logic">  Typen und Funktionen im Zusammenhang mit der Anwendungslogik </h2><br><p>  Beginnen wir mit Datentypen und Funktionen, die sich auf die Anwendungslogik beziehen.  In dem diskutierten Beispiel werden die folgenden Datentypen verwendet, um Informationen von einer Stufe zur anderen zu übergeben: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Raw data from a sensor. struct raw_measure { int m_meter_id; uint8_t m_high_bits; uint8_t m_low_bits; }; // Type of input for validation stage with raw data from a sensor. struct raw_value { raw_measure m_data; }; // Type of input for conversion stage with valid raw data from a sensor. struct valid_raw_value { raw_measure m_data; }; // Data from a sensor after conversion to Celsius degrees. struct calculated_measure { int m_meter_id; float m_measure; }; // The type for result of conversion stage with converted data from a sensor. struct sensor_value { calculated_measure m_data; }; // Type with value which could mean a dangerous level of temperature. struct suspicious_value { calculated_measure m_data; }; // Type with information about detected dangerous situation. struct alarm_detected { int m_meter_id; };</span></span></code> </pre> <br><p>  Eine Instanz von <code>raw_value</code> geht in die erste Phase unserer Pipeline.  Dieser <code>raw_value</code> enthält Informationen, die von einem Sensor in Form eines <code>raw_measure</code> Objekts <code>raw_measure</code> .  Dann wird <code>raw_value</code> in <code>valid_raw_value</code> .  Dann <code>valid_raw_value</code> <code>sensor_value</code> mit dem Wert eines tatsächlichen Sensors in Form von <code>calulated_measure</code> in <code>calulated_measure</code> .  Wenn eine Instanz von <code>sensor_value</code> einen verdächtigen Wert enthält, wird eine Instanz von <code>suspicious_value</code> erzeugt.  Und dieser <code>suspicious_value</code> kann später in eine <code>alarm_detected</code> Instanz umgewandelt werden. </p><br><p>  Oder in grafischer Form: </p><br><p><img src="https://habrastorage.org/webt/dp/dx/rz/dpdxrzpp-rvo05zk-8rwdwucszo.jpeg"></p><br><p>  Jetzt können wir einen Blick auf die Implementierung unserer Pipeline-Phasen werfen: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // The first stage of a pipeline. Validation of raw data from a sensor. // // Returns valid_raw_value or nothing if value is invalid. // stage_result_t&lt; valid_raw_value &gt; validation( const raw_value &amp; v ) { if( 0x7 &gt;= v.m_data.m_high_bits ) return make_result&lt; valid_raw_value &gt;( v.m_data ); else return make_empty&lt; valid_raw_value &gt;(); } // // The second stage of a pipeline. Conversion from raw data to a value // in Celsius degrees. // stage_result_t&lt; sensor_value &gt; conversion( const valid_raw_value &amp; v ) { return make_result&lt; sensor_value &gt;( calculated_measure{ v.m_data.m_meter_id, 0.5f * ((static_cast&lt; uint16_t &gt;( v.m_data.m_high_bits ) &lt;&lt; 8) + v.m_data.m_low_bits) } ); } // // Simulation of the data archiving. // void archiving( const sensor_value &amp; v ) { clog &lt;&lt; "archiving (" &lt;&lt; v.m_data.m_meter_id &lt;&lt; "," &lt;&lt; v.m_data.m_measure &lt;&lt; ")" &lt;&lt; endl; } // // Simulation of the data distribution. // void distribution( const sensor_value &amp; v ) { clog &lt;&lt; "distributing (" &lt;&lt; v.m_data.m_meter_id &lt;&lt; "," &lt;&lt; v.m_data.m_measure &lt;&lt; ")" &lt;&lt; endl; } // // The first stage of a child pipeline at third level of the main pipeline. // // Checking for to high value of the temperature. // // Returns suspicious_value message or nothing. // stage_result_t&lt; suspicious_value &gt; range_checking( const sensor_value &amp; v ) { if( v.m_data.m_measure &gt;= 45.0f ) return make_result&lt; suspicious_value &gt;( v.m_data ); else return make_empty&lt; suspicious_value &gt;(); } // // The next stage of a child pipeline. // // Checks for two suspicious_value-es in 25ms time window. // class alarm_detector { using clock = chrono::steady_clock; public : stage_result_t&lt; alarm_detected &gt; operator()( const suspicious_value &amp; v ) { if( m_previous ) if( *m_previous + chrono::milliseconds(25) &gt; clock::now() ) { m_previous = nullopt; return make_result&lt; alarm_detected &gt;( v.m_data.m_meter_id ); } m_previous = clock::now(); return make_empty&lt; alarm_detected &gt;(); } private : optional&lt; clock::time_point &gt; m_previous; }; // // One of last stages of a child pipeline. // Imitates beginning of the alarm processing. // void alarm_initiator( const alarm_detected &amp; v ) { clog &lt;&lt; "=== alarm (" &lt;&lt; v.m_meter_id &lt;&lt; ") ===" &lt;&lt; endl; } // // Another of last stages of a child pipeline. // Imitates distribution of the alarm. // void alarm_distribution( ostream &amp; to, const alarm_detected &amp; v ) { to &lt;&lt; "alarm_distribution (" &lt;&lt; v.m_meter_id &lt;&lt; ")" &lt;&lt; endl; }</span></span></code> </pre> <br><p>  Überspringen <code>stage_result_t</code> <code>make_result</code> <code>make_empty</code> wie <code>stage_result_t</code> , <code>make_result</code> und <code>make_empty</code> , wir werden es im nächsten Abschnitt besprechen. </p><br><p>  Ich hoffe, dass der Code dieser Stufen eher trivial ist.  Der einzige Teil, der einer zusätzlichen Erläuterung bedarf, ist die Implementierung der Stufe <code>alarm_detector</code> . </p><br><p>  In diesem Beispiel wird ein Alarm nur ausgelöst, wenn im Zeitfenster von 25 ms mindestens zwei <code>suspicious_values</code> Werte vorhanden sind.  Wir müssen uns also die Zeit der vorherigen <code>suspicious_value</code> Instanz im Stadium <code>alarm_detector</code> .  <code>alarm_detector</code> liegt daran, dass <code>alarm_detector</code> als Stateful Functor mit einem Funktionsaufrufoperator <code>alarm_detector</code> ist. </p><br><h2 id="stages-return-sobjectizers-type-instead-of-stdoptional">  Stufen geben den Typ von SObjectizer anstelle von std :: optional zurück </h2><br><p>  Ich habe vorhin gesagt, dass die Stufe einen optionalen Wert zurückgeben könnte.  Aber <code>std::optional</code> wird im Code nicht verwendet, der unterschiedliche Typ <code>stage_result_t</code> kann in der Implementierung von Stufen gesehen werden. </p><br><p>  Dies liegt daran, dass einige der spezifischen Funktionen von SObjectizer hier eine Rolle spielen.  Die zurückgegebenen Werte werden als Nachrichten zwischen den Agenten von SObjectizer (auch als Akteure bezeichnet) verteilt.  Jede Nachricht in SObjectizer wird als dynamisch zugewiesenes Objekt gesendet.  Wir haben hier also eine Art "Optimierung": Anstatt <code>std::optional</code> und dann ein neues Nachrichtenobjekt zuzuweisen, weisen wir einfach ein Nachrichtenobjekt zu und geben einen intelligenten Zeiger darauf zurück. </p><br><p>  Tatsächlich ist <code>stage_result_t</code> nur ein typedef für SObjectizers shared_ptr-Analog: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt; M &gt;;</code> </pre> <br><p>  Und <code>make_result</code> und <code>make_empty</code> sind nur <code>make_result</code> <code>make_empty</code> <code>stage_result_t</code> mit oder ohne tatsächlichen Wert: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt; make_result( Args &amp;&amp;... args ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt;::make(forward&lt; Args &gt;(args)...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt; make_empty() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt;(); }</code> </pre> <br><p>  Der Einfachheit halber kann man mit Sicherheit sagen, dass die <code>validation</code> folgendermaßen ausgedrückt werden könnte: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; valid_raw_value &gt; validation( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> raw_value &amp; v ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0x7</span></span> &gt;= v.m_data.m_high_bits ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt; valid_raw_value &gt;( v.m_data ); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; valid_raw_value &gt;{}; }</code> </pre> <br><p>  Aufgrund der Besonderheiten von SObjectizer können wir <code>std::shared_ptr</code> jedoch nicht verwenden und müssen <code>so_5::message_holder_t</code> Typ <code>so_5::message_holder_t</code> befassen.  Und wir verstecken das spezifisch hinter den <code>stage_result_t</code> , <code>make_result</code> und <code>make_empty</code> . </p><br><h2 id="stage_handler_t-and-stage_builder_t-separation">  Stage_handler_t und Stage_builder_t Trennung </h2><br><p>  Ein wichtiger Punkt bei der Pipeline-Implementierung ist die Trennung von <em>Stage-Handler-</em> und <em>Stage-Builder-</em> Konzepten.  Dies geschieht der Einfachheit halber.  Das Vorhandensein dieser Konzepte ermöglichte mir zwei Schritte in der Pipeline-Definition. </p><br><p>  Im ersten Schritt beschreibt ein Benutzer Pipeline-Phasen.  Als Ergebnis erhalte ich eine Instanz von <code>stage_t</code> , die alle Pipeline-Stufen enthält. </p><br><p>  Im zweiten Schritt wird eine Reihe von zugrunde liegenden SObjectizer-Agenten erstellt.  Diese Agenten empfangen Nachrichten mit Ergebnissen der vorherigen Phasen und rufen die tatsächlichen <em>Phasenhandler auf</em> . Anschließend senden sie die Ergebnisse an die nächsten Phasen. </p><br><p>  Um diese Gruppe von Agenten zu erstellen, muss jede Stufe einen <em>Bühnenbauer haben</em> .  <em>Stage Builder</em> kann als Factory betrachtet werden, die den Agenten eines zugrunde liegenden SObjectizers erstellt. </p><br><p>  Wir haben also die folgende Beziehung: Jede Pipeline-Stufe erzeugt zwei Objekte: <em>Stage-Handler</em> mit stufenbezogener Logik und <em>Stage-Builder</em> , der den Agenten eines zugrunde liegenden SObjectizers erstellt, um den <em>Stage-Handler</em> zum richtigen Zeitpunkt aufzurufen: </p><br><p><img src="https://habrastorage.org/webt/gl/tp/nn/gltpnnqhjqslsscxvellndh6n0u.jpeg"></p><br><p>  <em>Der Stage Handler</em> wird folgendermaßen dargestellt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stage_handler_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> traits = <span class="hljs-keyword"><span class="hljs-keyword">handler_traits_t</span></span>&lt; In, Out &gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> func_type = function&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::output(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::input &amp;) &gt;; <span class="hljs-keyword"><span class="hljs-keyword">stage_handler_t</span></span>( func_type handler ) : m_handler( move(handler) ) {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_handler_t</span></span>( Callable handler ) : m_handler( handler ) {} <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::<span class="hljs-function"><span class="hljs-function">output </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> traits::input &amp; a )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_handler( a ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : func_type m_handler; };</code> </pre> <br><p>  Wobei <code>handler_traits_t</code> folgendermaßen definiert werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // We have to deal with two types of stage handlers: // - intermediate handlers which will return some result (eg some new // message); // - terminal handlers which can return nothing (eg void instead of // stage_result_t&lt;M&gt;); // // This template with specialization defines `input` and `output` // aliases for both cases. // template&lt; typename In, typename Out &gt; struct handler_traits_t { using input = In; using output = stage_result_t&lt; Out &gt;; }; template&lt; typename In &gt; struct handler_traits_t&lt; In, void &gt; { using input = In; using output = void; };</span></span></code> </pre> <br><p>  <em>Der Stage Builder</em> wird nur durch <code>std::function</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> = function&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>) &gt;;</code> </pre> <br><h2 id="helper-types-lambda_traits_t-and-callable_traits_t">  Hilfstypen lambda_traits_t und callable_traits_t </h2><br><p>  Da Stufen durch freie Funktionen oder Funktoren dargestellt werden können (z. B. Instanzen der Klasse <code>alarm_detector</code> oder von anonymen Compilern generierte Klassen, die Lambdas darstellen), benötigen wir einige Helfer, um die Argumente und den Rückgabewert der Stufe zu erkennen.  Zu diesem Zweck habe ich den folgenden Code verwendet: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Helper type for `arg_type` and `result_type` alises definition. // template&lt; typename R, typename A &gt; struct callable_traits_typedefs_t { using arg_type = A; using result_type = R; }; // // Helper type for dealing with stateful objects with operator() // (they could be user-defined objects or generated by compiler // like lambdas). // template&lt; typename T &gt; struct lambda_traits_t; template&lt; typename M, typename A, typename T &gt; struct lambda_traits_t&lt; stage_result_t&lt; M &gt;(T::*)(const A &amp;) const &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A, typename T &gt; struct lambda_traits_t&lt; void (T::*)(const A &amp;) const &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {}; template&lt; typename M, typename A, typename T &gt; struct lambda_traits_t&lt; stage_result_t&lt; M &gt;(T::*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A, typename T &gt; struct lambda_traits_t&lt; void (T::*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {}; // // Main type for definition of `arg_type` and `result_type` aliases. // With specialization for various cases. // template&lt; typename T &gt; struct callable_traits_t : public lambda_traits_t&lt; decltype(&amp;T::operator()) &gt; {}; template&lt; typename M, typename A &gt; struct callable_traits_t&lt; stage_result_t&lt; M &gt;(*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A &gt; struct callable_traits_t&lt; void(*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {};</span></span></code> </pre> <br><p>  Ich hoffe, dass dieser Code für Leser mit guten C ++ - Kenntnissen durchaus verständlich ist.  Wenn nicht, können Sie mich gerne in den Kommentaren fragen. Gerne erkläre ich Ihnen die Logik hinter <code>lambda_traits_t</code> und <code>lambda_traits_t</code> im Detail. </p><br><h2 id="stage-broadcast-and-operator-functions">  Stage () -, Broadcast () - und Operator | () -Funktionen </h2><br><p>  Jetzt können wir uns die wichtigsten Funktionen zum Aufbau von Pipelines ansehen.  <code>stage_t</code> die Definition einer Vorlagenklasse <code>stage_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stage_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> m_builder; };</code> </pre> <br><p>  Es ist eine sehr einfache Struktur, die nur <code>stage_bulder_t</code> Instanz <code>stage_bulder_t</code> .  Vorlagenparameter werden in <code>stage_t</code> nicht verwendet. Warum sind sie hier also vorhanden? </p><br><p>  Sie sind für die Überprüfung der Typkompatibilität zwischen Pipeline-Stufen zur Kompilierungszeit erforderlich.  Wir werden das bald sehen. </p><br><p>  Schauen wir uns die einfachste Pipeline-Funktion an, die <code>stage()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::arg_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::result_type &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; stage( Callable handler ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_stage_point_t</span></span>&lt;In, Out&gt; &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ) -&gt;so_direct_mbox(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  Es erhält einen tatsächlichen <em>Stage-Handler</em> als einzelnen Parameter.  Es kann ein Zeiger auf eine Funktion oder eine Lambda-Funktion oder einen Funktor sein.  Die Arten der Eingabe und Ausgabe der Bühne werden aufgrund der "Vorlagenmagie" hinter der Vorlage callable_traits_t automatisch abgeleitet. </p><br><p>  Eine Instanz des <em>Stage Builders</em> wird im Inneren erstellt und diese Instanz wird als Ergebnis der Funktion <code>stage()</code> in einem neuen <code>stage_t</code> Objekt zurückgegeben.  Ein tatsächlicher <em>Stage-Handler</em> wird vom <em>Stage-Builder</em> Lambda erfasst und dann für die Erstellung eines zugrunde liegenden SObjectizer-Agenten verwendet (darüber werden wir im nächsten Abschnitt sprechen). </p><br><p>  Die nächste zu überprüfende Funktion ist der <code>operator|()</code> , der zwei Stufen miteinander verkettet und eine neue Stufe zurückgibt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out2 &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out2 &gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>|( <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out1 &gt; &amp;&amp; prev, <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; Out1, Out2 &gt; &amp;&amp; next ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span>{ [prev, next]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = next.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m) ); } } }; }</code> </pre> <br><p>  Der einfachste Weg, die Logik des <code>operator|()</code> zu erklären, besteht darin, ein Bild zu zeichnen.  Nehmen wir an, wir haben den Ausdruck: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B) | stage(C) | stage(B)</code> </pre> <br><p>  Dieser Ausdruck wird folgendermaßen transformiert: </p><br><p><img src="https://habrastorage.org/webt/jo/rr/aq/jorraqaawl6y7ju3om7zfq3java.jpeg"></p><br><p>  Dort können wir auch sehen, wie die Typprüfung zur Kompilierungszeit funktioniert: Die Definition des <code>operator|()</code> erfordert, dass der Ausgabetyp der ersten Stufe die Eingabe der zweiten Stufe ist.  Ist dies nicht der Fall, wird der Code nicht kompiliert. </p><br><p>  Und jetzt können wir uns die komplexeste Funktion zum Aufbau von Pipelines ansehen, die <code>broadcast()</code> .  Die Funktion selbst ist ziemlich einfach: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Rest &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &gt; broadcast( <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... stages ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)] ( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> &gt; mboxes; mboxes.reserve( broadcasts.size() ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; b : broadcasts ) mboxes.emplace_back( b( coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>{} ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">broadcast_mbox_t</span></span>::make( coop.environment(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mboxes) ); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  Der Hauptunterschied zwischen einer gewöhnlichen Bühne und einer Rundfunkbühne besteht darin, dass die Rundfunkbühne einen Vektor von <em>Nebenbühnenbauern enthalten muss</em> .  Also müssen wir diesen Vektor erstellen und ihn an den <em>Hauptbühnenbauer</em> der Rundfunkbühne übergeben.  Aus diesem Grund können wir einen Aufruf von <code>collect_sink_builders</code> in der Capture-Liste eines Lambdas in der Funktion <code>collect_sink_builders</code> <code>broadcast()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)]</code> </pre> <br><p>  Wenn wir uns <code>collect_sink_builder</code> ansehen, <code>collect_sink_builder</code> wir den folgenden Code: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Serie of helper functions for building description for // `broadcast` stage. // // Those functions are used for collecting // `builders` functions for every child pipeline. // // Please note that this functions checks that each child pipeline has the // same In type. // template&lt; typename In, typename Out, typename... Rest &gt; void move_sink_builder_to( vector&lt; stage_builder_t &gt; &amp; receiver, stage_t&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... rest ) { receiver.emplace_back( move( first.m_builder ) ); if constexpr( 0u != sizeof...(rest) ) move_sink_builder_to&lt;In&gt;( receiver, forward&lt; Rest &gt;(rest)... ); } template&lt; typename In, typename Out, typename... Rest &gt; vector&lt; stage_builder_t &gt; collect_sink_builders( stage_t&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... stages ) { vector&lt; stage_builder_t &gt; receiver; receiver.reserve( 1 + sizeof...(stages) ); move_sink_builder_to&lt;In&gt;( receiver, move(first), std::forward&lt;Rest&gt;(stages)... ); return receiver; }</span></span></code> </pre> <br><p>  Die Typprüfung zur Kompilierungszeit funktioniert auch hier: Ein Aufruf von <code>move_sink_builder_to</code> explizit durch den Typ 'In' parametrisiert.  <code>collect_sink_builders(stage_t&lt;In1, Out1&gt;, stage_t&lt;In2, Out2&gt;, ...)</code> bedeutet, dass ein Aufruf in der Form <code>collect_sink_builders(stage_t&lt;In1, Out1&gt;, stage_t&lt;In2, Out2&gt;, ...)</code> zu einem Kompilierungsfehler führt, da der Compiler einen Aufruf von <code>move_sink_builder_to&lt;In1&gt;(receiver, stage_t&lt;In2, Out2&gt;, ...)</code> . </p><br><p>  Ich kann auch feststellen, dass wir, da die Anzahl der Nebenpipelines für <code>broadcast()</code> zur Kompilierungszeit bekannt ist, <code>std::array</code> anstelle von <code>std::vector</code> und einige Speicherzuordnungen vermeiden können.  Der Einfachheit halber wird hier jedoch <code>std::vector</code> verwendet. </p><br><h2 id="relation-between-stages-and-sobjectizers-agentsmboxes">  Beziehung zwischen Stufen und Agenten / mboxen von SObjectizer </h2><br><p>  Die Idee hinter der Implementierung der Pipeline ist die Erstellung eines separaten Agenten für jede Pipeline-Phase.  Ein Agent empfängt eine eingehende Nachricht, leitet sie an den entsprechenden <em>Stage-Handler weiter</em> , analysiert das Ergebnis und sendet das Ergebnis als eingehende Nachricht an die nächste Stufe, wenn das Ergebnis nicht leer ist.  Dies kann durch das folgende Sequenzdiagramm veranschaulicht werden: </p><br><p><img src="https://habrastorage.org/webt/om/pn/wy/ompnwye792gjgad7zzgphpv4ctu.png"></p><br><p>  Einige SObjectizer-bezogene Dinge müssen zumindest kurz besprochen werden.  Wenn Sie kein Interesse an solchen Details haben, können Sie die folgenden Abschnitte überspringen und direkt zum Abschluss gehen. </p><br><h3 id="coop-is-a-group-of-agents-to-work-together">  Coop ist eine Gruppe von Agenten, die zusammenarbeiten </h3><br><p>  Agenten werden nicht einzeln, sondern in Gruppen mit dem Namen coops in SObjectizer eingeführt.  Ein Coop ist eine Gruppe von Agenten, die zusammenarbeiten sollten, und es macht keinen Sinn, die Arbeit fortzusetzen, wenn einer der Agenten der Gruppe fehlt. </p><br><p>  Die Einführung von Agenten in SObjectizer sieht also so aus, als würde eine Coop-Instanz erstellt, diese Instanz mit den entsprechenden Agenten gefüllt und dann die Coop in SObjectizer registriert. </p><br><p>  Aus diesem Grund ist das erste Argument für einen <em>Bühnenbauer</em> ein Verweis auf einen neuen Coop.  Dieser Coop wird in der Funktion <code>make_pipeline()</code> erstellt ( <code>make_pipeline()</code> unten), dann von <em>Stage Buildern</em> <code>make_pipeline()</code> und dann registriert (erneut in der Funktion <code>make_pipeline()</code> ). </p><br><h3 id="message-boxes">  Meldungsfelder </h3><br><p>  SObjectizer implementiert mehrere Parallelitätsmodelle.  Das Actor Model ist nur einer von ihnen.  Aus diesem Grund kann sich SObjectizer erheblich von anderen Akteur-Frameworks unterscheiden.  Einer der Unterschiede ist das Adressierungsschema für Nachrichten. </p><br><p>  Nachrichten in SObjectizer richten sich nicht an Akteure, sondern an <em>Nachrichtenfelder</em> (mboxes).  Schauspieler müssen Nachrichten von einer mbox abonnieren.  Wenn ein Akteur einen bestimmten Nachrichtentyp von einer mbox abonniert, erhält er Nachrichten dieses Typs: </p><br><p><img src="https://habrastorage.org/webt/o4/bf/ee/o4bfee0lp8hdvks68cas4yjlkgu.png"></p><br><p>  Diese Tatsache ist entscheidend, da Nachrichten von einer Stufe zur anderen gesendet werden müssen.  Dies bedeutet, dass jede Stufe ihre mbox haben sollte und dass mbox für die vorherige Stufe bekannt sein sollte. </p><br><p>  Jeder Schauspieler (auch bekannt als Agent) in SObjectizer hat <em>die direkte mbox</em> .  Diese mbox ist nur dem Eigentümeragenten zugeordnet und kann von keinem anderen Agenten verwendet werden.  Die direkten mboxen von Agenten, die für Stufen erstellt wurden, werden für die Stufeninteraktion verwendet. </p><br><p>  Die spezifische Funktion dieses SObjectizers bestimmt einige Details der Pipeline-Implementierung. </p><br><p>  Das erste ist die Tatsache, dass <em>Stage Builder</em> den folgenden Prototyp hat: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> builder(<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>);</code> </pre> <br><p>  Dies bedeutet, dass der <em>Stage Builder</em> eine mbox der nächsten Stufe empfängt und einen neuen Agenten erstellen sollte, der die Ergebnisse der Stufe an diese mbox sendet.  Eine mbox des neuen Agenten sollte vom <em>Stage Builder zurückgegeben werden</em> .  Diese mbox wird für die Erstellung eines Agenten für die vorherige Stufe verwendet. </p><br><p>  Das zweite ist die Tatsache, dass Agenten für Stufen in Reservereihenfolge erstellt werden.  Es bedeutet, dass wenn wir eine Pipeline haben: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B) | stage(C)</code> </pre> <br><p>  Zuerst wird ein Agent für Stufe C erstellt, dann wird seine mbox für die Erstellung eines Agenten für Stufe B verwendet, und dann wird die mbox des Agenten der Stufe B für die Erstellung eines Agenten für Stufe A verwendet. </p><br><p>  Beachten Sie auch, dass der <code>operator|()</code> keine Agenten erstellt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span>{ [prev, next]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = next.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m) ); } }</code> </pre> <br><p>  Der <code>operator|()</code> erstellt einen Builder, der nur andere Builder aufruft, aber keine zusätzlichen Agenten einführt.  Also für den Fall: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B)</code> </pre> <br><p>  Es werden nur zwei Agenten erstellt (für A-Stufe und B-Stufe), die dann im vom <code>operator|()</code> erstellten <em>Stage Builder</em> miteinander verknüpft werden. </p><br><h3 id="there-is-no-agent-for-broadcast-implementation">  Es gibt keinen Agenten für <code>broadcast()</code> Implementierung von <code>broadcast()</code> </h3><br><p>  Eine naheliegende Möglichkeit, eine Broadcast-Phase zu implementieren, besteht darin, einen speziellen Agenten zu erstellen, der eine eingehende Nachricht empfängt und diese Nachricht dann erneut an eine Liste von Ziel-Mboxes sendet.  Dieser Weg <a href="">wurde bei der ersten Implementierung</a> der beschriebenen Pipeline DSL verwendet. </p><br><p>  Aber unser Begleitprojekt, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">so5extra</a> , hat jetzt eine spezielle Variante von mbox: Broadcasting one.  Diese mbox macht genau das, was hier erforderlich ist: Sie nimmt eine neue Nachricht auf und sendet sie an eine Reihe von Ziel-mboxen. </p><br><p>  Aus diesem Grund muss kein separater Broadcast-Agent erstellt werden. Wir können einfach die Broadcast-Mbox von so5extra verwenden: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // A special mbox for broadcasting of a message to a set of destination // mboxes. // using broadcast_mbox_t = so_5::extra::mboxes::broadcast::fixed_mbox_template_t&lt;&gt;; ... // // Inside the broadcast() function: // stage_builder_t builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)] ( coop_t &amp; coop, mbox_t ) -&gt; mbox_t { vector&lt; mbox_t &gt; mboxes; mboxes.reserve( broadcasts.size() ); for( const auto &amp; b : broadcasts ) mboxes.emplace_back( b( coop, mbox_t{} ) ); // That is the creation of broadcasting mbox instance. return broadcast_mbox_t::make( coop.environment(), std::move(mboxes) ); } };</span></span></code> </pre> <br><h3 id="implementation-of-stage-agent">  Implementierung von Stage-Agent </h3><br><p>  Jetzt können wir uns die Implementierung von Stage Agent ansehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // An agent which will be used as intermediate or terminal pipeline stage. // It will receive input message, call the stage handler and pass // handler result to the next stage (if any). // template&lt; typename In, typename Out &gt; class a_stage_point_t final : public agent_t { public : a_stage_point_t( context_t ctx, stage_handler_t&lt; In, Out &gt; handler, mbox_t next_stage ) : agent_t{ ctx } , m_handler{ move( handler ) } , m_next{ move(next_stage) } {} void so_define_agent() override { if( m_next ) // Because there is the next stage the appropriate // message handler will be used. so_subscribe_self().event( [=]( const In &amp; evt ) { auto r = m_handler( evt ); if( r ) so_5::send( m_next, r ); } ); else // There is no next stage. A very simple message handler // will be used for that case. so_subscribe_self().event( [=]( const In &amp; evt ) { m_handler( evt ); } ); } private : const stage_handler_t&lt; In, Out &gt; m_handler; const mbox_t m_next; }; // // A specialization of a_stage_point_t for the case of terminal stage of // a pipeline. This type will be used for stage handlers with void // return type. // template&lt; typename In &gt; class a_stage_point_t&lt; In, void &gt; final : public agent_t { public : a_stage_point_t( context_t ctx, stage_handler_t&lt; In, void &gt; handler, mbox_t next_stage ) : agent_t{ ctx } , m_handler{ move( handler ) } { if( next_stage ) throw std::runtime_error( "sink point cannot have next stage" ); } void so_define_agent() override { so_subscribe_self().event( [=]( const In &amp; evt ) { m_handler( evt ); } ); } private : const stage_handler_t&lt; In, void &gt; m_handler; };</span></span></code> </pre> <br><p>  Es ist ziemlich trivial, wenn Sie die Grundlagen des SObjectizers verstehen.  Wenn nicht, wird es ziemlich schwierig sein, es in wenigen Worten zu erklären (also zögern Sie nicht, Fragen in den Kommentaren zu stellen). </p><br><p>  Die Hauptimplementierung des Agenten <code>a_stage_point_t</code> erstellt ein Abonnement für eine Nachricht vom Typ In.  Wenn eine Nachricht dieses Typs eintrifft, wird der <em>Stage-Handler</em> aufgerufen.  Wenn der <em>Stage-Handler</em> ein tatsächliches Ergebnis zurückgibt, wird das Ergebnis an die nächste Stufe gesendet (falls diese Stufe vorhanden ist). </p><br><p>  Es gibt auch eine Version von <code>a_stage_point_t</code> für den Fall, dass die entsprechende Stufe die Endstufe ist und es nicht die nächste Stufe geben kann. </p><br><p>  Die Implementierung von <code>a_stage_point_t</code> kann etwas kompliziert aussehen, aber glauben Sie mir, es ist einer der einfachsten Agenten, die ich geschrieben habe. </p><br><h2 id="make_pipeline-function">  Funktion make_pipeline () </h2><br><p>  Es ist Zeit, die letzte Pipeline-Funktion zu diskutieren, die <code>make_pipeline()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> make_pipeline( <span class="hljs-comment"><span class="hljs-comment">// SObjectizer Environment to work in. so_5::environment_t &amp; env, // Definition of a pipeline. stage_t&lt; In, Out &gt; &amp;&amp; sink, // Optional args to be passed to make_coop() function. Args &amp;&amp;... args ) { auto coop = env.make_coop( forward&lt; Args &gt;(args)... ); auto mbox = sink.m_builder( *coop, mbox_t{} ); env.register_coop( move(coop) ); return mbox; }</span></span></code> </pre> <br><p>  Hier gibt es weder Magie noch Überraschungen.  Wir müssen nur einen neuen Coop für die zugrunde liegenden Agenten der Pipeline erstellen, diesen Coop mit Agenten füllen, indem wir einen <em>Stage Builder der</em> obersten Ebene aufrufen, und diesen Coop dann in SObjectizer registrieren.  Das alles. </p><br><p>  Das Ergebnis von <code>make_pipeline()</code> ist die mbox der am weitesten links stehenden (ersten) Stufe der Pipeline.  Diese mbox sollte zum Senden von Nachrichten an die Pipeline verwendet werden. </p><br><h1 id="the-simulation-and-experiments-with-it">  Die Simulation und Experimente damit </h1><br><p>  Jetzt haben wir Datentypen und Funktionen für unsere Anwendungslogik und die Tools zum Verketten dieser Funktionen zu einer Datenverarbeitungspipeline.  Lassen Sie es uns tun und ein Ergebnis sehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Launch SObjectizer in a separate thread. wrapped_env_t sobj; // Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ) ); // Send messages to a pipeline in a loop with 10ms delays. for( uint8_t i = 0; i &lt; static_cast&lt; uint8_t &gt;(250); i += 10 ) { send&lt; raw_value &gt;( pipeline, raw_measure{ 0, 0, i } ); std::this_thread::sleep_for( chrono::milliseconds{10} ); } }</span></span></code> </pre> <br><p>  Wenn wir dieses Beispiel ausführen, sehen wir die folgende Ausgabe: </p><br><pre> <code class="plaintext hljs">archiving (0,0) distributing (0,0) archiving (0,5) distributing (0,5) archiving (0,10) distributing (0,10) archiving (0,15) distributing (0,15) archiving (0,20) distributing (0,20) archiving (0,25) distributing (0,25) archiving (0,30) distributing (0,30) ... archiving (0,105) distributing (0,105) archiving (0,110) distributing (0,110) === alarm (0) === alarm_distribution (0) archiving (0,115) distributing (0,115) archiving (0,120) distributing (0,120) === alarm (0) === alarm_distribution (0)</code> </pre> <br><p>  Es funktioniert. </p><br><p>  Aber es scheint, dass Phasen unserer Pipeline nacheinander ablaufen, nicht wahr? </p><br><p>  Ja, das ist es.  Dies liegt daran, dass alle Pipeline-Agenten an den Dispatcher des Standard-SObjectizers gebunden sind.  Und dieser Dispatcher verwendet nur einen Arbeitsthread, um die Nachrichtenverarbeitung aller Agenten zu bedienen. </p><br><p>  Dies kann jedoch leicht geändert werden.  <code>make_pipeline()</code> einfach ein zusätzliches Argument an den <code>make_pipeline()</code> von <code>make_pipeline()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ), disp::thread_pool::make_dispatcher( sobj.environment() ).binder( disp::thread_pool::bind_params_t{}.fifo( disp::thread_pool::fifo_t::individual ) ) );</span></span></code> </pre> <br><p>  Dadurch wird ein neuer Thread-Pool erstellt und alle Pipeline-Agenten an diesen Pool gebunden.  Jeder Agent wird vom Pool unabhängig von anderen Agenten bedient. </p><br><p>  Wenn wir das modifizierte Beispiel ausführen, können wir so etwas sehen: </p><br><pre> <code class="plaintext hljs">archiving (0,0) distributing (0,0) distributing (0,5) archiving (0,5) archiving (0,10) distributing (0,10) distributing (archiving (0,15) 0,15) archiving (0,20) distributing (0,20) archiving (0,25) distributing (0,25) archiving (0,distributing (030) ,30) ... archiving (0,distributing (0,105) 105) archiving (0,alarm_distribution (0) distributing (0,=== alarm (0) === 110) 110) archiving (distributing (0,0,115) 115) archiving (distributing (=== alarm (0) === 0alarm_distribution (0) 0,120) ,120)</code> </pre> <br><p>  Wir können also sehen, dass verschiedene Phasen der Pipeline parallel arbeiten. </p><br><p>  Aber ist es möglich, weiter zu gehen und Stufen an verschiedene Disponenten zu binden? </p><br><p>  Ja, es ist möglich, aber wir müssen eine weitere Überladung für die Funktion <code>stage()</code> implementieren: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::arg_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::result_type &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; stage( <span class="hljs-keyword"><span class="hljs-keyword">disp_binder_shptr_t</span></span> disp_binder, Callable handler ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [binder = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(disp_binder), h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_stage_point_t</span></span>&lt;In, Out&gt; &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(binder), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ) -&gt;so_direct_mbox(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p> This version of <code>stage()</code> accepts not only a <em>stage handler</em> but also a dispatcher binder. Dispatcher binder is a way to bind an agent to the particular dispatcher. So to assign a stage to a specific working context we can create an appropriate dispatcher and then pass the binder to that dispatcher to <code>stage()</code> function. Let's do that: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// An active_obj dispatcher to be used for some stages. auto ao_disp = disp::active_obj::make_dispatcher( sobj.environment() ); // Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(ao_disp.binder(), archiving), stage(ao_disp.binder(), distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(ao_disp.binder(), alarm_initiator), stage(ao_disp.binder(), []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ), disp::one_thread::make_dispatcher( sobj.environment() ).binder() );</span></span></code> </pre> <br><p> In that case stages <code>archiving</code> , <code>distribution</code> , <code>alarm_initiator</code> and <code>alarm_distribution</code> will work on own worker threads. All other stages will work on the same single worker thread. </p><br><h1 id="the-conclusion"> The conclusion </h1><br><p> This was an interesting experiment and I was surprised how easy SObjectizer could be used in something like reactive programming or data-flow programming. </p><br><p> However, I don't think that pipeline DSL can be practically meaningful. It's too simple and, maybe not flexible enough. But, I hope, it can be a base for more interesting experiments for those why need to deal with different workflows and data-processing pipelines. At least as a base for some ideas in that area. C++ language a rather good here and some (not so complicated) template magic can help to catch various errors at compile-time. </p><br><p> In conclusion, I want to say that we see SObjectizer not as a specialized tool for solving a particular problem, but as a basic set of tools to be used in solutions for different problems. And, more importantly, that basic set can be extended for your needs. Just take a look at <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer</a> , try it, and share your feedback. Maybe you missed something in SObjectizer? Perhaps you don't like something? <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tell us</a> , and we can try to help you. </p><br><p> If you want to help further development of SObjectizer, please share a reference to it or to this article somewhere you want (Reddit, HackerNews, LinkedIn, Facebook, Twitter, ...). The more attention and the more feedback, the more new features will be incorporated into SObjectizer. </p><br><p> And many thanks for reading this ;) </p><br><p>  PS. The source code for that example can be found in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">that repository</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460123/">https://habr.com/ru/post/de460123/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460113/index.html">Ein paar Geschichten aus dem Leben von JSOC CERT oder Unbanal Forensics</a></li>
<li><a href="../de460115/index.html">Zehn Jahre Programmierung in Erlang</a></li>
<li><a href="../de460117/index.html">Sind die größten Kunden in Russland ein großer Jackpot oder Kopfschmerzen? AGIMA Erfahrung</a></li>
<li><a href="../de460119/index.html">Fehler, die die statische Code-Analyse nicht findet, weil sie nicht verwendet wird</a></li>
<li><a href="../de460121/index.html">Fehler, die die statische Code-Analyse nicht findet, weil sie nicht verwendet wird</a></li>
<li><a href="../de460125/index.html">Node.js oder Java: Leistung, Ressourcen, Flusskontrolle, Popularität und persönliche Erfahrung</a></li>
<li><a href="../de460129/index.html">Roboter und Erdbeeren: Wie KI die Feldausbeute erhöht</a></li>
<li><a href="../de460131/index.html">Sophos XG Firewall: Vom klassischen ME zum NGFW mit automatischer Reaktion auf Informationssicherheitsvorfälle</a></li>
<li><a href="../de460133/index.html">Kotlin / Everywhere - Showcase-Praxis: 31. Juli</a></li>
<li><a href="../de460135/index.html">Sicherheitswoche 29: Sicherheitslücke in Bezug auf Zoom, Sicherheit und Drama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>