<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüéì ü•° ‚ÜòÔ∏è Eine deklarative Datenverarbeitungspipeline √ºber den Akteuren? Warum nicht? üë®üèª‚Äçüç≥ üçã üëî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einiger Zeit wurden wir in einer Diskussion √ºber eine der Versionen von SObjectizer gefragt: "Ist es m√∂glich, ein DSL zur Beschreibung einer Daten...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine deklarative Datenverarbeitungspipeline √ºber den Akteuren? Warum nicht?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460123/"><p>  Vor einiger Zeit wurden wir in einer Diskussion √ºber eine der Versionen von SObjectizer gefragt: "Ist es m√∂glich, ein DSL zur Beschreibung einer Datenverarbeitungspipeline zu erstellen?"  Mit anderen Worten, ist es m√∂glich, so etwas zu schreiben: </p><br><p><code>A | B | C | D</code> </p> <br><p>  und erhalten Sie eine funktionierende Pipeline, in der Nachrichten von A nach B und dann nach C und dann nach D geleitet werden. Mit der Kontrolle erh√§lt B genau den Typ, den A zur√ºckgibt.  Und C empf√§ngt genau den Typ, den B zur√ºckgibt.  Und so weiter. </p><br><p>  Es war eine interessante Aufgabe mit einer √ºberraschend einfachen L√∂sung.  So kann beispielsweise die Erstellung einer Pipeline aussehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pipeline = make_pipeline(env, stage(A) | stage(B) | stage(C) | stage(D));</code> </pre> <br><p>  Oder in einem komplexeren Fall (der unten diskutiert wird): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alarm_detected &amp; v ) { alarm_distribution( <span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span>, v ); } ) ) ) );</code> </pre> <br><p>  In diesem Artikel werden wir √ºber die Implementierung eines solchen Pipeline-DSL sprechen.  Wir werden haupts√§chlich Teile im Zusammenhang mit <code>stage()</code> , <code>broadcast()</code> und <code>operator|()</code> -Funktionen mit mehreren Beispielen f√ºr die Verwendung von C ++ - Vorlagen diskutieren.  Ich hoffe, es wird auch f√ºr Leser interessant sein, die nichts √ºber SObjectizer wissen (wenn Sie noch nie von SObjectizer geh√∂rt haben, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> eine √úbersicht √ºber dieses Tool). </p><a name="habracut"></a><br><h1 id="a-couple-of-words-about-the-used-demo">  Ein paar Worte zur verwendeten Demo </h1><br><p>  Das in diesem Artikel verwendete Beispiel wurde von meiner alten (und eher vergessenen) Erfahrung im SCADA-Bereich beeinflusst. </p><br><p>  Die Idee der Demo ist der Umgang mit Daten, die von einem Sensor gelesen werden.  Die Daten werden von einem Sensor mit einer gewissen Zeitspanne erfasst, dann m√ºssen diese Daten validiert (falsche Daten sollten ignoriert werden) und in einige tats√§chliche Werte umgewandelt werden.  Beispielsweise k√∂nnen die von einem Sensor gelesenen Rohdaten zwei 8-Bit-Ganzzahlwerte sein, und diese Werte sollten in eine Gleitkommazahl umgewandelt werden. </p><br><p>  Dann sollten die g√ºltigen und konvertierten Werte archiviert, irgendwo verteilt (z. B. auf verschiedenen Knoten zur Visualisierung) und auf "Alarme" √ºberpr√ºft werden (wenn Werte au√üerhalb sicherer Bereiche liegen, sollte dies speziell behandelt werden).  Diese Operationen sind unabh√§ngig und k√∂nnen parallel ausgef√ºhrt werden. </p><br><p>  Operationen, die sich auf den erkannten Alarm beziehen, k√∂nnen auch parallel ausgef√ºhrt werden: Ein "Alarm" sollte ausgel√∂st werden (damit der Teil von SCADA auf dem aktuellen Knoten darauf reagieren kann) und die Informationen √ºber den "Alarm" sollten an anderer Stelle verteilt werden (z. B.) : in einer historischen Datenbank gespeichert und / oder auf dem Display des SCADA-Bedieners visualisiert). </p><br><p>  Diese Logik kann in Textform folgenderma√üen ausgedr√ºckt werden: </p><br><pre> <code class="plaintext hljs">optional(valid_raw_data) = validate(raw_data); if valid_raw_data is not empty then { converted_value = convert(valid_raw_data); do_async archive(converted_value); do_async distribute(converted_value); do_async { optional(suspicious_value) = check_range(converted_value); if suspicious_value is not empty then { optional(alarm) = detect_alarm(suspicious_value); if alarm is not empty then { do_async initiate_alarm(alarm); do_async distribute_alarm(alam); } } } }</code> </pre> <br><p>  Oder in grafischer Form: </p><br><p><img src="https://habrastorage.org/webt/5z/nm/vv/5znmvvaqnou_qwh808t8vkbrdc8.jpeg"></p><br><p>  Es ist ein ziemlich k√ºnstliches Beispiel, aber es hat einige interessante Dinge, die ich zeigen m√∂chte.  Das erste ist das Vorhandensein paralleler Stufen in einer Pipeline (Operation <code>broadcast()</code> existiert nur deswegen).  Das zweite ist das Vorhandensein eines Staates in einigen Stadien.  Zum Beispiel ist alarm_detector eine Stateful-Phase. </p><br><h1 id="pipeline-capabilities">  Pipeline-Funktionen </h1><br><p>  Eine Pipeline wird aus getrennten Stufen aufgebaut.  Jede Stufe ist eine Funktion oder ein Funktor des folgenden Formats: </p><br><pre> <code class="cpp hljs">opt&lt;Out&gt; func(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> In &amp;);</code> </pre> <br><p>  oder </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> In &amp;)</span></span></span></span>;</code> </pre> <br><p>  Stufen, die <code>void</code> k√∂nnen nur als letzte Stufe einer Pipeline verwendet werden. </p><br><p>  Stufen sind zu einer Kette verbunden.  Jede n√§chste Stufe erh√§lt ein Objekt, das von der vorherigen Stufe zur√ºckgegeben wurde.  Wenn die vorherige Stufe den leeren Wert <code>opt&lt;Out&gt;</code> zur√ºckgibt, wird die n√§chste Stufe nicht aufgerufen. </p><br><p>  Es gibt eine spezielle <code>broadcast</code> .  Es besteht aus mehreren Pipelines.  Eine <code>broadcast</code> empf√§ngt ein Objekt aus der vorherigen Stufe und sendet es an jede Tochterpipeline. </p><br><p>  Aus Sicht der Pipeline sieht die <code>broadcast</code> Phase wie eine Funktion des folgenden Formats aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> In &amp;)</span></span></span></span>;</code> </pre> <br><p>  Da es keinen R√ºckgabewert von der <code>broadcast</code> Stufe gibt, kann eine <code>broadcast</code> Stufe nur die letzte Stufe in einer Pipeline sein. </p><br><h2 id="why-does-the-pipeline-stage-return-an-optional-value">  Warum gibt die Pipeline-Stufe einen optionalen Wert zur√ºck? </h2><br><p>  Dies liegt daran, dass einige eingehende Werte gel√∂scht werden m√ºssen.  Beispielsweise gibt die <code>validate</code> nichts zur√ºck, wenn ein Rohwert falsch ist und es keinen Sinn macht, damit umzugehen. </p><br><p>  Ein weiteres Beispiel: Die Stufe <code>alarm_detector</code> gibt nichts zur√ºck, wenn der aktuelle verd√§chtige Wert keinen neuen Alarmfall erzeugt. </p><br><h1 id="implementation-details">  Implementierungsdetails </h1><br><h2 id="types-and-functions-related-to-the-application-logic">  Typen und Funktionen im Zusammenhang mit der Anwendungslogik </h2><br><p>  Beginnen wir mit Datentypen und Funktionen, die sich auf die Anwendungslogik beziehen.  In dem diskutierten Beispiel werden die folgenden Datentypen verwendet, um Informationen von einer Stufe zur anderen zu √ºbergeben: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Raw data from a sensor. struct raw_measure { int m_meter_id; uint8_t m_high_bits; uint8_t m_low_bits; }; // Type of input for validation stage with raw data from a sensor. struct raw_value { raw_measure m_data; }; // Type of input for conversion stage with valid raw data from a sensor. struct valid_raw_value { raw_measure m_data; }; // Data from a sensor after conversion to Celsius degrees. struct calculated_measure { int m_meter_id; float m_measure; }; // The type for result of conversion stage with converted data from a sensor. struct sensor_value { calculated_measure m_data; }; // Type with value which could mean a dangerous level of temperature. struct suspicious_value { calculated_measure m_data; }; // Type with information about detected dangerous situation. struct alarm_detected { int m_meter_id; };</span></span></code> </pre> <br><p>  Eine Instanz von <code>raw_value</code> geht in die erste Phase unserer Pipeline.  Dieser <code>raw_value</code> enth√§lt Informationen, die von einem Sensor in Form eines <code>raw_measure</code> Objekts <code>raw_measure</code> .  Dann wird <code>raw_value</code> in <code>valid_raw_value</code> .  Dann <code>valid_raw_value</code> <code>sensor_value</code> mit dem Wert eines tats√§chlichen Sensors in Form von <code>calulated_measure</code> in <code>calulated_measure</code> .  Wenn eine Instanz von <code>sensor_value</code> einen verd√§chtigen Wert enth√§lt, wird eine Instanz von <code>suspicious_value</code> erzeugt.  Und dieser <code>suspicious_value</code> kann sp√§ter in eine <code>alarm_detected</code> Instanz umgewandelt werden. </p><br><p>  Oder in grafischer Form: </p><br><p><img src="https://habrastorage.org/webt/dp/dx/rz/dpdxrzpp-rvo05zk-8rwdwucszo.jpeg"></p><br><p>  Jetzt k√∂nnen wir einen Blick auf die Implementierung unserer Pipeline-Phasen werfen: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // The first stage of a pipeline. Validation of raw data from a sensor. // // Returns valid_raw_value or nothing if value is invalid. // stage_result_t&lt; valid_raw_value &gt; validation( const raw_value &amp; v ) { if( 0x7 &gt;= v.m_data.m_high_bits ) return make_result&lt; valid_raw_value &gt;( v.m_data ); else return make_empty&lt; valid_raw_value &gt;(); } // // The second stage of a pipeline. Conversion from raw data to a value // in Celsius degrees. // stage_result_t&lt; sensor_value &gt; conversion( const valid_raw_value &amp; v ) { return make_result&lt; sensor_value &gt;( calculated_measure{ v.m_data.m_meter_id, 0.5f * ((static_cast&lt; uint16_t &gt;( v.m_data.m_high_bits ) &lt;&lt; 8) + v.m_data.m_low_bits) } ); } // // Simulation of the data archiving. // void archiving( const sensor_value &amp; v ) { clog &lt;&lt; "archiving (" &lt;&lt; v.m_data.m_meter_id &lt;&lt; "," &lt;&lt; v.m_data.m_measure &lt;&lt; ")" &lt;&lt; endl; } // // Simulation of the data distribution. // void distribution( const sensor_value &amp; v ) { clog &lt;&lt; "distributing (" &lt;&lt; v.m_data.m_meter_id &lt;&lt; "," &lt;&lt; v.m_data.m_measure &lt;&lt; ")" &lt;&lt; endl; } // // The first stage of a child pipeline at third level of the main pipeline. // // Checking for to high value of the temperature. // // Returns suspicious_value message or nothing. // stage_result_t&lt; suspicious_value &gt; range_checking( const sensor_value &amp; v ) { if( v.m_data.m_measure &gt;= 45.0f ) return make_result&lt; suspicious_value &gt;( v.m_data ); else return make_empty&lt; suspicious_value &gt;(); } // // The next stage of a child pipeline. // // Checks for two suspicious_value-es in 25ms time window. // class alarm_detector { using clock = chrono::steady_clock; public : stage_result_t&lt; alarm_detected &gt; operator()( const suspicious_value &amp; v ) { if( m_previous ) if( *m_previous + chrono::milliseconds(25) &gt; clock::now() ) { m_previous = nullopt; return make_result&lt; alarm_detected &gt;( v.m_data.m_meter_id ); } m_previous = clock::now(); return make_empty&lt; alarm_detected &gt;(); } private : optional&lt; clock::time_point &gt; m_previous; }; // // One of last stages of a child pipeline. // Imitates beginning of the alarm processing. // void alarm_initiator( const alarm_detected &amp; v ) { clog &lt;&lt; "=== alarm (" &lt;&lt; v.m_meter_id &lt;&lt; ") ===" &lt;&lt; endl; } // // Another of last stages of a child pipeline. // Imitates distribution of the alarm. // void alarm_distribution( ostream &amp; to, const alarm_detected &amp; v ) { to &lt;&lt; "alarm_distribution (" &lt;&lt; v.m_meter_id &lt;&lt; ")" &lt;&lt; endl; }</span></span></code> </pre> <br><p>  √úberspringen <code>stage_result_t</code> <code>make_result</code> <code>make_empty</code> wie <code>stage_result_t</code> , <code>make_result</code> und <code>make_empty</code> , wir werden es im n√§chsten Abschnitt besprechen. </p><br><p>  Ich hoffe, dass der Code dieser Stufen eher trivial ist.  Der einzige Teil, der einer zus√§tzlichen Erl√§uterung bedarf, ist die Implementierung der Stufe <code>alarm_detector</code> . </p><br><p>  In diesem Beispiel wird ein Alarm nur ausgel√∂st, wenn im Zeitfenster von 25 ms mindestens zwei <code>suspicious_values</code> Werte vorhanden sind.  Wir m√ºssen uns also die Zeit der vorherigen <code>suspicious_value</code> Instanz im Stadium <code>alarm_detector</code> .  <code>alarm_detector</code> liegt daran, dass <code>alarm_detector</code> als Stateful Functor mit einem Funktionsaufrufoperator <code>alarm_detector</code> ist. </p><br><h2 id="stages-return-sobjectizers-type-instead-of-stdoptional">  Stufen geben den Typ von SObjectizer anstelle von std :: optional zur√ºck </h2><br><p>  Ich habe vorhin gesagt, dass die Stufe einen optionalen Wert zur√ºckgeben k√∂nnte.  Aber <code>std::optional</code> wird im Code nicht verwendet, der unterschiedliche Typ <code>stage_result_t</code> kann in der Implementierung von Stufen gesehen werden. </p><br><p>  Dies liegt daran, dass einige der spezifischen Funktionen von SObjectizer hier eine Rolle spielen.  Die zur√ºckgegebenen Werte werden als Nachrichten zwischen den Agenten von SObjectizer (auch als Akteure bezeichnet) verteilt.  Jede Nachricht in SObjectizer wird als dynamisch zugewiesenes Objekt gesendet.  Wir haben hier also eine Art "Optimierung": Anstatt <code>std::optional</code> und dann ein neues Nachrichtenobjekt zuzuweisen, weisen wir einfach ein Nachrichtenobjekt zu und geben einen intelligenten Zeiger darauf zur√ºck. </p><br><p>  Tats√§chlich ist <code>stage_result_t</code> nur ein typedef f√ºr SObjectizers shared_ptr-Analog: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt; M &gt;;</code> </pre> <br><p>  Und <code>make_result</code> und <code>make_empty</code> sind nur <code>make_result</code> <code>make_empty</code> <code>stage_result_t</code> mit oder ohne tats√§chlichen Wert: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt; make_result( Args &amp;&amp;... args ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt;::make(forward&lt; Args &gt;(args)...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt; make_empty() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt;(); }</code> </pre> <br><p>  Der Einfachheit halber kann man mit Sicherheit sagen, dass die <code>validation</code> folgenderma√üen ausgedr√ºckt werden k√∂nnte: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; valid_raw_value &gt; validation( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> raw_value &amp; v ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0x7</span></span> &gt;= v.m_data.m_high_bits ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt; valid_raw_value &gt;( v.m_data ); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; valid_raw_value &gt;{}; }</code> </pre> <br><p>  Aufgrund der Besonderheiten von SObjectizer k√∂nnen wir <code>std::shared_ptr</code> jedoch nicht verwenden und m√ºssen <code>so_5::message_holder_t</code> Typ <code>so_5::message_holder_t</code> befassen.  Und wir verstecken das spezifisch hinter den <code>stage_result_t</code> , <code>make_result</code> und <code>make_empty</code> . </p><br><h2 id="stage_handler_t-and-stage_builder_t-separation">  Stage_handler_t und Stage_builder_t Trennung </h2><br><p>  Ein wichtiger Punkt bei der Pipeline-Implementierung ist die Trennung von <em>Stage-Handler-</em> und <em>Stage-Builder-</em> Konzepten.  Dies geschieht der Einfachheit halber.  Das Vorhandensein dieser Konzepte erm√∂glichte mir zwei Schritte in der Pipeline-Definition. </p><br><p>  Im ersten Schritt beschreibt ein Benutzer Pipeline-Phasen.  Als Ergebnis erhalte ich eine Instanz von <code>stage_t</code> , die alle Pipeline-Stufen enth√§lt. </p><br><p>  Im zweiten Schritt wird eine Reihe von zugrunde liegenden SObjectizer-Agenten erstellt.  Diese Agenten empfangen Nachrichten mit Ergebnissen der vorherigen Phasen und rufen die tats√§chlichen <em>Phasenhandler auf</em> . Anschlie√üend senden sie die Ergebnisse an die n√§chsten Phasen. </p><br><p>  Um diese Gruppe von Agenten zu erstellen, muss jede Stufe einen <em>B√ºhnenbauer haben</em> .  <em>Stage Builder</em> kann als Factory betrachtet werden, die den Agenten eines zugrunde liegenden SObjectizers erstellt. </p><br><p>  Wir haben also die folgende Beziehung: Jede Pipeline-Stufe erzeugt zwei Objekte: <em>Stage-Handler</em> mit stufenbezogener Logik und <em>Stage-Builder</em> , der den Agenten eines zugrunde liegenden SObjectizers erstellt, um den <em>Stage-Handler</em> zum richtigen Zeitpunkt aufzurufen: </p><br><p><img src="https://habrastorage.org/webt/gl/tp/nn/gltpnnqhjqslsscxvellndh6n0u.jpeg"></p><br><p>  <em>Der Stage Handler</em> wird folgenderma√üen dargestellt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stage_handler_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> traits = <span class="hljs-keyword"><span class="hljs-keyword">handler_traits_t</span></span>&lt; In, Out &gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> func_type = function&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::output(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::input &amp;) &gt;; <span class="hljs-keyword"><span class="hljs-keyword">stage_handler_t</span></span>( func_type handler ) : m_handler( move(handler) ) {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_handler_t</span></span>( Callable handler ) : m_handler( handler ) {} <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::<span class="hljs-function"><span class="hljs-function">output </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> traits::input &amp; a )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_handler( a ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : func_type m_handler; };</code> </pre> <br><p>  Wobei <code>handler_traits_t</code> folgenderma√üen definiert werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // We have to deal with two types of stage handlers: // - intermediate handlers which will return some result (eg some new // message); // - terminal handlers which can return nothing (eg void instead of // stage_result_t&lt;M&gt;); // // This template with specialization defines `input` and `output` // aliases for both cases. // template&lt; typename In, typename Out &gt; struct handler_traits_t { using input = In; using output = stage_result_t&lt; Out &gt;; }; template&lt; typename In &gt; struct handler_traits_t&lt; In, void &gt; { using input = In; using output = void; };</span></span></code> </pre> <br><p>  <em>Der Stage Builder</em> wird nur durch <code>std::function</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> = function&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>) &gt;;</code> </pre> <br><h2 id="helper-types-lambda_traits_t-and-callable_traits_t">  Hilfstypen lambda_traits_t und callable_traits_t </h2><br><p>  Da Stufen durch freie Funktionen oder Funktoren dargestellt werden k√∂nnen (z. B. Instanzen der Klasse <code>alarm_detector</code> oder von anonymen Compilern generierte Klassen, die Lambdas darstellen), ben√∂tigen wir einige Helfer, um die Argumente und den R√ºckgabewert der Stufe zu erkennen.  Zu diesem Zweck habe ich den folgenden Code verwendet: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Helper type for `arg_type` and `result_type` alises definition. // template&lt; typename R, typename A &gt; struct callable_traits_typedefs_t { using arg_type = A; using result_type = R; }; // // Helper type for dealing with stateful objects with operator() // (they could be user-defined objects or generated by compiler // like lambdas). // template&lt; typename T &gt; struct lambda_traits_t; template&lt; typename M, typename A, typename T &gt; struct lambda_traits_t&lt; stage_result_t&lt; M &gt;(T::*)(const A &amp;) const &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A, typename T &gt; struct lambda_traits_t&lt; void (T::*)(const A &amp;) const &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {}; template&lt; typename M, typename A, typename T &gt; struct lambda_traits_t&lt; stage_result_t&lt; M &gt;(T::*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A, typename T &gt; struct lambda_traits_t&lt; void (T::*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {}; // // Main type for definition of `arg_type` and `result_type` aliases. // With specialization for various cases. // template&lt; typename T &gt; struct callable_traits_t : public lambda_traits_t&lt; decltype(&amp;T::operator()) &gt; {}; template&lt; typename M, typename A &gt; struct callable_traits_t&lt; stage_result_t&lt; M &gt;(*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A &gt; struct callable_traits_t&lt; void(*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {};</span></span></code> </pre> <br><p>  Ich hoffe, dass dieser Code f√ºr Leser mit guten C ++ - Kenntnissen durchaus verst√§ndlich ist.  Wenn nicht, k√∂nnen Sie mich gerne in den Kommentaren fragen. Gerne erkl√§re ich Ihnen die Logik hinter <code>lambda_traits_t</code> und <code>lambda_traits_t</code> im Detail. </p><br><h2 id="stage-broadcast-and-operator-functions">  Stage () -, Broadcast () - und Operator | () -Funktionen </h2><br><p>  Jetzt k√∂nnen wir uns die wichtigsten Funktionen zum Aufbau von Pipelines ansehen.  <code>stage_t</code> die Definition einer Vorlagenklasse <code>stage_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stage_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> m_builder; };</code> </pre> <br><p>  Es ist eine sehr einfache Struktur, die nur <code>stage_bulder_t</code> Instanz <code>stage_bulder_t</code> .  Vorlagenparameter werden in <code>stage_t</code> nicht verwendet. Warum sind sie hier also vorhanden? </p><br><p>  Sie sind f√ºr die √úberpr√ºfung der Typkompatibilit√§t zwischen Pipeline-Stufen zur Kompilierungszeit erforderlich.  Wir werden das bald sehen. </p><br><p>  Schauen wir uns die einfachste Pipeline-Funktion an, die <code>stage()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::arg_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::result_type &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; stage( Callable handler ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_stage_point_t</span></span>&lt;In, Out&gt; &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ) -&gt;so_direct_mbox(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  Es erh√§lt einen tats√§chlichen <em>Stage-Handler</em> als einzelnen Parameter.  Es kann ein Zeiger auf eine Funktion oder eine Lambda-Funktion oder einen Funktor sein.  Die Arten der Eingabe und Ausgabe der B√ºhne werden aufgrund der "Vorlagenmagie" hinter der Vorlage callable_traits_t automatisch abgeleitet. </p><br><p>  Eine Instanz des <em>Stage Builders</em> wird im Inneren erstellt und diese Instanz wird als Ergebnis der Funktion <code>stage()</code> in einem neuen <code>stage_t</code> Objekt zur√ºckgegeben.  Ein tats√§chlicher <em>Stage-Handler</em> wird vom <em>Stage-Builder</em> Lambda erfasst und dann f√ºr die Erstellung eines zugrunde liegenden SObjectizer-Agenten verwendet (dar√ºber werden wir im n√§chsten Abschnitt sprechen). </p><br><p>  Die n√§chste zu √ºberpr√ºfende Funktion ist der <code>operator|()</code> , der zwei Stufen miteinander verkettet und eine neue Stufe zur√ºckgibt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out2 &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out2 &gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>|( <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out1 &gt; &amp;&amp; prev, <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; Out1, Out2 &gt; &amp;&amp; next ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span>{ [prev, next]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = next.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m) ); } } }; }</code> </pre> <br><p>  Der einfachste Weg, die Logik des <code>operator|()</code> zu erkl√§ren, besteht darin, ein Bild zu zeichnen.  Nehmen wir an, wir haben den Ausdruck: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B) | stage(C) | stage(B)</code> </pre> <br><p>  Dieser Ausdruck wird folgenderma√üen transformiert: </p><br><p><img src="https://habrastorage.org/webt/jo/rr/aq/jorraqaawl6y7ju3om7zfq3java.jpeg"></p><br><p>  Dort k√∂nnen wir auch sehen, wie die Typpr√ºfung zur Kompilierungszeit funktioniert: Die Definition des <code>operator|()</code> erfordert, dass der Ausgabetyp der ersten Stufe die Eingabe der zweiten Stufe ist.  Ist dies nicht der Fall, wird der Code nicht kompiliert. </p><br><p>  Und jetzt k√∂nnen wir uns die komplexeste Funktion zum Aufbau von Pipelines ansehen, die <code>broadcast()</code> .  Die Funktion selbst ist ziemlich einfach: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Rest &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &gt; broadcast( <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... stages ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)] ( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> &gt; mboxes; mboxes.reserve( broadcasts.size() ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; b : broadcasts ) mboxes.emplace_back( b( coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>{} ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">broadcast_mbox_t</span></span>::make( coop.environment(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mboxes) ); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  Der Hauptunterschied zwischen einer gew√∂hnlichen B√ºhne und einer Rundfunkb√ºhne besteht darin, dass die Rundfunkb√ºhne einen Vektor von <em>Nebenb√ºhnenbauern enthalten muss</em> .  Also m√ºssen wir diesen Vektor erstellen und ihn an den <em>Hauptb√ºhnenbauer</em> der Rundfunkb√ºhne √ºbergeben.  Aus diesem Grund k√∂nnen wir einen Aufruf von <code>collect_sink_builders</code> in der Capture-Liste eines Lambdas in der Funktion <code>collect_sink_builders</code> <code>broadcast()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)]</code> </pre> <br><p>  Wenn wir uns <code>collect_sink_builder</code> ansehen, <code>collect_sink_builder</code> wir den folgenden Code: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Serie of helper functions for building description for // `broadcast` stage. // // Those functions are used for collecting // `builders` functions for every child pipeline. // // Please note that this functions checks that each child pipeline has the // same In type. // template&lt; typename In, typename Out, typename... Rest &gt; void move_sink_builder_to( vector&lt; stage_builder_t &gt; &amp; receiver, stage_t&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... rest ) { receiver.emplace_back( move( first.m_builder ) ); if constexpr( 0u != sizeof...(rest) ) move_sink_builder_to&lt;In&gt;( receiver, forward&lt; Rest &gt;(rest)... ); } template&lt; typename In, typename Out, typename... Rest &gt; vector&lt; stage_builder_t &gt; collect_sink_builders( stage_t&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... stages ) { vector&lt; stage_builder_t &gt; receiver; receiver.reserve( 1 + sizeof...(stages) ); move_sink_builder_to&lt;In&gt;( receiver, move(first), std::forward&lt;Rest&gt;(stages)... ); return receiver; }</span></span></code> </pre> <br><p>  Die Typpr√ºfung zur Kompilierungszeit funktioniert auch hier: Ein Aufruf von <code>move_sink_builder_to</code> explizit durch den Typ 'In' parametrisiert.  <code>collect_sink_builders(stage_t&lt;In1, Out1&gt;, stage_t&lt;In2, Out2&gt;, ...)</code> bedeutet, dass ein Aufruf in der Form <code>collect_sink_builders(stage_t&lt;In1, Out1&gt;, stage_t&lt;In2, Out2&gt;, ...)</code> zu einem Kompilierungsfehler f√ºhrt, da der Compiler einen Aufruf von <code>move_sink_builder_to&lt;In1&gt;(receiver, stage_t&lt;In2, Out2&gt;, ...)</code> . </p><br><p>  Ich kann auch feststellen, dass wir, da die Anzahl der Nebenpipelines f√ºr <code>broadcast()</code> zur Kompilierungszeit bekannt ist, <code>std::array</code> anstelle von <code>std::vector</code> und einige Speicherzuordnungen vermeiden k√∂nnen.  Der Einfachheit halber wird hier jedoch <code>std::vector</code> verwendet. </p><br><h2 id="relation-between-stages-and-sobjectizers-agentsmboxes">  Beziehung zwischen Stufen und Agenten / mboxen von SObjectizer </h2><br><p>  Die Idee hinter der Implementierung der Pipeline ist die Erstellung eines separaten Agenten f√ºr jede Pipeline-Phase.  Ein Agent empf√§ngt eine eingehende Nachricht, leitet sie an den entsprechenden <em>Stage-Handler weiter</em> , analysiert das Ergebnis und sendet das Ergebnis als eingehende Nachricht an die n√§chste Stufe, wenn das Ergebnis nicht leer ist.  Dies kann durch das folgende Sequenzdiagramm veranschaulicht werden: </p><br><p><img src="https://habrastorage.org/webt/om/pn/wy/ompnwye792gjgad7zzgphpv4ctu.png"></p><br><p>  Einige SObjectizer-bezogene Dinge m√ºssen zumindest kurz besprochen werden.  Wenn Sie kein Interesse an solchen Details haben, k√∂nnen Sie die folgenden Abschnitte √ºberspringen und direkt zum Abschluss gehen. </p><br><h3 id="coop-is-a-group-of-agents-to-work-together">  Coop ist eine Gruppe von Agenten, die zusammenarbeiten </h3><br><p>  Agenten werden nicht einzeln, sondern in Gruppen mit dem Namen coops in SObjectizer eingef√ºhrt.  Ein Coop ist eine Gruppe von Agenten, die zusammenarbeiten sollten, und es macht keinen Sinn, die Arbeit fortzusetzen, wenn einer der Agenten der Gruppe fehlt. </p><br><p>  Die Einf√ºhrung von Agenten in SObjectizer sieht also so aus, als w√ºrde eine Coop-Instanz erstellt, diese Instanz mit den entsprechenden Agenten gef√ºllt und dann die Coop in SObjectizer registriert. </p><br><p>  Aus diesem Grund ist das erste Argument f√ºr einen <em>B√ºhnenbauer</em> ein Verweis auf einen neuen Coop.  Dieser Coop wird in der Funktion <code>make_pipeline()</code> erstellt ( <code>make_pipeline()</code> unten), dann von <em>Stage Buildern</em> <code>make_pipeline()</code> und dann registriert (erneut in der Funktion <code>make_pipeline()</code> ). </p><br><h3 id="message-boxes">  Meldungsfelder </h3><br><p>  SObjectizer implementiert mehrere Parallelit√§tsmodelle.  Das Actor Model ist nur einer von ihnen.  Aus diesem Grund kann sich SObjectizer erheblich von anderen Akteur-Frameworks unterscheiden.  Einer der Unterschiede ist das Adressierungsschema f√ºr Nachrichten. </p><br><p>  Nachrichten in SObjectizer richten sich nicht an Akteure, sondern an <em>Nachrichtenfelder</em> (mboxes).  Schauspieler m√ºssen Nachrichten von einer mbox abonnieren.  Wenn ein Akteur einen bestimmten Nachrichtentyp von einer mbox abonniert, erh√§lt er Nachrichten dieses Typs: </p><br><p><img src="https://habrastorage.org/webt/o4/bf/ee/o4bfee0lp8hdvks68cas4yjlkgu.png"></p><br><p>  Diese Tatsache ist entscheidend, da Nachrichten von einer Stufe zur anderen gesendet werden m√ºssen.  Dies bedeutet, dass jede Stufe ihre mbox haben sollte und dass mbox f√ºr die vorherige Stufe bekannt sein sollte. </p><br><p>  Jeder Schauspieler (auch bekannt als Agent) in SObjectizer hat <em>die direkte mbox</em> .  Diese mbox ist nur dem Eigent√ºmeragenten zugeordnet und kann von keinem anderen Agenten verwendet werden.  Die direkten mboxen von Agenten, die f√ºr Stufen erstellt wurden, werden f√ºr die Stufeninteraktion verwendet. </p><br><p>  Die spezifische Funktion dieses SObjectizers bestimmt einige Details der Pipeline-Implementierung. </p><br><p>  Das erste ist die Tatsache, dass <em>Stage Builder</em> den folgenden Prototyp hat: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> builder(<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>);</code> </pre> <br><p>  Dies bedeutet, dass der <em>Stage Builder</em> eine mbox der n√§chsten Stufe empf√§ngt und einen neuen Agenten erstellen sollte, der die Ergebnisse der Stufe an diese mbox sendet.  Eine mbox des neuen Agenten sollte vom <em>Stage Builder zur√ºckgegeben werden</em> .  Diese mbox wird f√ºr die Erstellung eines Agenten f√ºr die vorherige Stufe verwendet. </p><br><p>  Das zweite ist die Tatsache, dass Agenten f√ºr Stufen in Reservereihenfolge erstellt werden.  Es bedeutet, dass wenn wir eine Pipeline haben: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B) | stage(C)</code> </pre> <br><p>  Zuerst wird ein Agent f√ºr Stufe C erstellt, dann wird seine mbox f√ºr die Erstellung eines Agenten f√ºr Stufe B verwendet, und dann wird die mbox des Agenten der Stufe B f√ºr die Erstellung eines Agenten f√ºr Stufe A verwendet. </p><br><p>  Beachten Sie auch, dass der <code>operator|()</code> keine Agenten erstellt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span>{ [prev, next]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = next.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m) ); } }</code> </pre> <br><p>  Der <code>operator|()</code> erstellt einen Builder, der nur andere Builder aufruft, aber keine zus√§tzlichen Agenten einf√ºhrt.  Also f√ºr den Fall: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B)</code> </pre> <br><p>  Es werden nur zwei Agenten erstellt (f√ºr A-Stufe und B-Stufe), die dann im vom <code>operator|()</code> erstellten <em>Stage Builder</em> miteinander verkn√ºpft werden. </p><br><h3 id="there-is-no-agent-for-broadcast-implementation">  Es gibt keinen Agenten f√ºr <code>broadcast()</code> Implementierung von <code>broadcast()</code> </h3><br><p>  Eine naheliegende M√∂glichkeit, eine Broadcast-Phase zu implementieren, besteht darin, einen speziellen Agenten zu erstellen, der eine eingehende Nachricht empf√§ngt und diese Nachricht dann erneut an eine Liste von Ziel-Mboxes sendet.  Dieser Weg <a href="">wurde bei der ersten Implementierung</a> der beschriebenen Pipeline DSL verwendet. </p><br><p>  Aber unser Begleitprojekt, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">so5extra</a> , hat jetzt eine spezielle Variante von mbox: Broadcasting one.  Diese mbox macht genau das, was hier erforderlich ist: Sie nimmt eine neue Nachricht auf und sendet sie an eine Reihe von Ziel-mboxen. </p><br><p>  Aus diesem Grund muss kein separater Broadcast-Agent erstellt werden. Wir k√∂nnen einfach die Broadcast-Mbox von so5extra verwenden: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // A special mbox for broadcasting of a message to a set of destination // mboxes. // using broadcast_mbox_t = so_5::extra::mboxes::broadcast::fixed_mbox_template_t&lt;&gt;; ... // // Inside the broadcast() function: // stage_builder_t builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)] ( coop_t &amp; coop, mbox_t ) -&gt; mbox_t { vector&lt; mbox_t &gt; mboxes; mboxes.reserve( broadcasts.size() ); for( const auto &amp; b : broadcasts ) mboxes.emplace_back( b( coop, mbox_t{} ) ); // That is the creation of broadcasting mbox instance. return broadcast_mbox_t::make( coop.environment(), std::move(mboxes) ); } };</span></span></code> </pre> <br><h3 id="implementation-of-stage-agent">  Implementierung von Stage-Agent </h3><br><p>  Jetzt k√∂nnen wir uns die Implementierung von Stage Agent ansehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // An agent which will be used as intermediate or terminal pipeline stage. // It will receive input message, call the stage handler and pass // handler result to the next stage (if any). // template&lt; typename In, typename Out &gt; class a_stage_point_t final : public agent_t { public : a_stage_point_t( context_t ctx, stage_handler_t&lt; In, Out &gt; handler, mbox_t next_stage ) : agent_t{ ctx } , m_handler{ move( handler ) } , m_next{ move(next_stage) } {} void so_define_agent() override { if( m_next ) // Because there is the next stage the appropriate // message handler will be used. so_subscribe_self().event( [=]( const In &amp; evt ) { auto r = m_handler( evt ); if( r ) so_5::send( m_next, r ); } ); else // There is no next stage. A very simple message handler // will be used for that case. so_subscribe_self().event( [=]( const In &amp; evt ) { m_handler( evt ); } ); } private : const stage_handler_t&lt; In, Out &gt; m_handler; const mbox_t m_next; }; // // A specialization of a_stage_point_t for the case of terminal stage of // a pipeline. This type will be used for stage handlers with void // return type. // template&lt; typename In &gt; class a_stage_point_t&lt; In, void &gt; final : public agent_t { public : a_stage_point_t( context_t ctx, stage_handler_t&lt; In, void &gt; handler, mbox_t next_stage ) : agent_t{ ctx } , m_handler{ move( handler ) } { if( next_stage ) throw std::runtime_error( "sink point cannot have next stage" ); } void so_define_agent() override { so_subscribe_self().event( [=]( const In &amp; evt ) { m_handler( evt ); } ); } private : const stage_handler_t&lt; In, void &gt; m_handler; };</span></span></code> </pre> <br><p>  Es ist ziemlich trivial, wenn Sie die Grundlagen des SObjectizers verstehen.  Wenn nicht, wird es ziemlich schwierig sein, es in wenigen Worten zu erkl√§ren (also z√∂gern Sie nicht, Fragen in den Kommentaren zu stellen). </p><br><p>  Die Hauptimplementierung des Agenten <code>a_stage_point_t</code> erstellt ein Abonnement f√ºr eine Nachricht vom Typ In.  Wenn eine Nachricht dieses Typs eintrifft, wird der <em>Stage-Handler</em> aufgerufen.  Wenn der <em>Stage-Handler</em> ein tats√§chliches Ergebnis zur√ºckgibt, wird das Ergebnis an die n√§chste Stufe gesendet (falls diese Stufe vorhanden ist). </p><br><p>  Es gibt auch eine Version von <code>a_stage_point_t</code> f√ºr den Fall, dass die entsprechende Stufe die Endstufe ist und es nicht die n√§chste Stufe geben kann. </p><br><p>  Die Implementierung von <code>a_stage_point_t</code> kann etwas kompliziert aussehen, aber glauben Sie mir, es ist einer der einfachsten Agenten, die ich geschrieben habe. </p><br><h2 id="make_pipeline-function">  Funktion make_pipeline () </h2><br><p>  Es ist Zeit, die letzte Pipeline-Funktion zu diskutieren, die <code>make_pipeline()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> make_pipeline( <span class="hljs-comment"><span class="hljs-comment">// SObjectizer Environment to work in. so_5::environment_t &amp; env, // Definition of a pipeline. stage_t&lt; In, Out &gt; &amp;&amp; sink, // Optional args to be passed to make_coop() function. Args &amp;&amp;... args ) { auto coop = env.make_coop( forward&lt; Args &gt;(args)... ); auto mbox = sink.m_builder( *coop, mbox_t{} ); env.register_coop( move(coop) ); return mbox; }</span></span></code> </pre> <br><p>  Hier gibt es weder Magie noch √úberraschungen.  Wir m√ºssen nur einen neuen Coop f√ºr die zugrunde liegenden Agenten der Pipeline erstellen, diesen Coop mit Agenten f√ºllen, indem wir einen <em>Stage Builder der</em> obersten Ebene aufrufen, und diesen Coop dann in SObjectizer registrieren.  Das alles. </p><br><p>  Das Ergebnis von <code>make_pipeline()</code> ist die mbox der am weitesten links stehenden (ersten) Stufe der Pipeline.  Diese mbox sollte zum Senden von Nachrichten an die Pipeline verwendet werden. </p><br><h1 id="the-simulation-and-experiments-with-it">  Die Simulation und Experimente damit </h1><br><p>  Jetzt haben wir Datentypen und Funktionen f√ºr unsere Anwendungslogik und die Tools zum Verketten dieser Funktionen zu einer Datenverarbeitungspipeline.  Lassen Sie es uns tun und ein Ergebnis sehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Launch SObjectizer in a separate thread. wrapped_env_t sobj; // Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ) ); // Send messages to a pipeline in a loop with 10ms delays. for( uint8_t i = 0; i &lt; static_cast&lt; uint8_t &gt;(250); i += 10 ) { send&lt; raw_value &gt;( pipeline, raw_measure{ 0, 0, i } ); std::this_thread::sleep_for( chrono::milliseconds{10} ); } }</span></span></code> </pre> <br><p>  Wenn wir dieses Beispiel ausf√ºhren, sehen wir die folgende Ausgabe: </p><br><pre> <code class="plaintext hljs">archiving (0,0) distributing (0,0) archiving (0,5) distributing (0,5) archiving (0,10) distributing (0,10) archiving (0,15) distributing (0,15) archiving (0,20) distributing (0,20) archiving (0,25) distributing (0,25) archiving (0,30) distributing (0,30) ... archiving (0,105) distributing (0,105) archiving (0,110) distributing (0,110) === alarm (0) === alarm_distribution (0) archiving (0,115) distributing (0,115) archiving (0,120) distributing (0,120) === alarm (0) === alarm_distribution (0)</code> </pre> <br><p>  Es funktioniert. </p><br><p>  Aber es scheint, dass Phasen unserer Pipeline nacheinander ablaufen, nicht wahr? </p><br><p>  Ja, das ist es.  Dies liegt daran, dass alle Pipeline-Agenten an den Dispatcher des Standard-SObjectizers gebunden sind.  Und dieser Dispatcher verwendet nur einen Arbeitsthread, um die Nachrichtenverarbeitung aller Agenten zu bedienen. </p><br><p>  Dies kann jedoch leicht ge√§ndert werden.  <code>make_pipeline()</code> einfach ein zus√§tzliches Argument an den <code>make_pipeline()</code> von <code>make_pipeline()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ), disp::thread_pool::make_dispatcher( sobj.environment() ).binder( disp::thread_pool::bind_params_t{}.fifo( disp::thread_pool::fifo_t::individual ) ) );</span></span></code> </pre> <br><p>  Dadurch wird ein neuer Thread-Pool erstellt und alle Pipeline-Agenten an diesen Pool gebunden.  Jeder Agent wird vom Pool unabh√§ngig von anderen Agenten bedient. </p><br><p>  Wenn wir das modifizierte Beispiel ausf√ºhren, k√∂nnen wir so etwas sehen: </p><br><pre> <code class="plaintext hljs">archiving (0,0) distributing (0,0) distributing (0,5) archiving (0,5) archiving (0,10) distributing (0,10) distributing (archiving (0,15) 0,15) archiving (0,20) distributing (0,20) archiving (0,25) distributing (0,25) archiving (0,distributing (030) ,30) ... archiving (0,distributing (0,105) 105) archiving (0,alarm_distribution (0) distributing (0,=== alarm (0) === 110) 110) archiving (distributing (0,0,115) 115) archiving (distributing (=== alarm (0) === 0alarm_distribution (0) 0,120) ,120)</code> </pre> <br><p>  Wir k√∂nnen also sehen, dass verschiedene Phasen der Pipeline parallel arbeiten. </p><br><p>  Aber ist es m√∂glich, weiter zu gehen und Stufen an verschiedene Disponenten zu binden? </p><br><p>  Ja, es ist m√∂glich, aber wir m√ºssen eine weitere √úberladung f√ºr die Funktion <code>stage()</code> implementieren: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::arg_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::result_type &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; stage( <span class="hljs-keyword"><span class="hljs-keyword">disp_binder_shptr_t</span></span> disp_binder, Callable handler ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [binder = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(disp_binder), h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_stage_point_t</span></span>&lt;In, Out&gt; &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(binder), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ) -&gt;so_direct_mbox(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p> This version of <code>stage()</code> accepts not only a <em>stage handler</em> but also a dispatcher binder. Dispatcher binder is a way to bind an agent to the particular dispatcher. So to assign a stage to a specific working context we can create an appropriate dispatcher and then pass the binder to that dispatcher to <code>stage()</code> function. Let's do that: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// An active_obj dispatcher to be used for some stages. auto ao_disp = disp::active_obj::make_dispatcher( sobj.environment() ); // Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(ao_disp.binder(), archiving), stage(ao_disp.binder(), distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(ao_disp.binder(), alarm_initiator), stage(ao_disp.binder(), []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ), disp::one_thread::make_dispatcher( sobj.environment() ).binder() );</span></span></code> </pre> <br><p> In that case stages <code>archiving</code> , <code>distribution</code> , <code>alarm_initiator</code> and <code>alarm_distribution</code> will work on own worker threads. All other stages will work on the same single worker thread. </p><br><h1 id="the-conclusion"> The conclusion </h1><br><p> This was an interesting experiment and I was surprised how easy SObjectizer could be used in something like reactive programming or data-flow programming. </p><br><p> However, I don't think that pipeline DSL can be practically meaningful. It's too simple and, maybe not flexible enough. But, I hope, it can be a base for more interesting experiments for those why need to deal with different workflows and data-processing pipelines. At least as a base for some ideas in that area. C++ language a rather good here and some (not so complicated) template magic can help to catch various errors at compile-time. </p><br><p> In conclusion, I want to say that we see SObjectizer not as a specialized tool for solving a particular problem, but as a basic set of tools to be used in solutions for different problems. And, more importantly, that basic set can be extended for your needs. Just take a look at <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer</a> , try it, and share your feedback. Maybe you missed something in SObjectizer? Perhaps you don't like something? <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tell us</a> , and we can try to help you. </p><br><p> If you want to help further development of SObjectizer, please share a reference to it or to this article somewhere you want (Reddit, HackerNews, LinkedIn, Facebook, Twitter, ...). The more attention and the more feedback, the more new features will be incorporated into SObjectizer. </p><br><p> And many thanks for reading this ;) </p><br><p>  PS. The source code for that example can be found in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">that repository</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460123/">https://habr.com/ru/post/de460123/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460113/index.html">Ein paar Geschichten aus dem Leben von JSOC CERT oder Unbanal Forensics</a></li>
<li><a href="../de460115/index.html">Zehn Jahre Programmierung in Erlang</a></li>
<li><a href="../de460117/index.html">Sind die gr√∂√üten Kunden in Russland ein gro√üer Jackpot oder Kopfschmerzen? AGIMA Erfahrung</a></li>
<li><a href="../de460119/index.html">Fehler, die die statische Code-Analyse nicht findet, weil sie nicht verwendet wird</a></li>
<li><a href="../de460121/index.html">Fehler, die die statische Code-Analyse nicht findet, weil sie nicht verwendet wird</a></li>
<li><a href="../de460125/index.html">Node.js oder Java: Leistung, Ressourcen, Flusskontrolle, Popularit√§t und pers√∂nliche Erfahrung</a></li>
<li><a href="../de460129/index.html">Roboter und Erdbeeren: Wie KI die Feldausbeute erh√∂ht</a></li>
<li><a href="../de460131/index.html">Sophos XG Firewall: Vom klassischen ME zum NGFW mit automatischer Reaktion auf Informationssicherheitsvorf√§lle</a></li>
<li><a href="../de460133/index.html">Kotlin / Everywhere - Showcase-Praxis: 31. Juli</a></li>
<li><a href="../de460135/index.html">Sicherheitswoche 29: Sicherheitsl√ºcke in Bezug auf Zoom, Sicherheit und Drama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>