<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚öïÔ∏è üêô üßü ¬øQu√© pasa si sin Python? Julia para aprendizaje autom√°tico y en general üê¶ ü§≥üèª üè¥‚Äç‚ò†Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Siempre queremos escribir c√≥digo r√°pidamente, pero hay que pagarlo. En lenguajes flexibles de alto nivel, los programas se pueden desarrollar r√°pidame...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øQu√© pasa si sin Python? Julia para aprendizaje autom√°tico y en general</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/476114/">  Siempre queremos escribir c√≥digo r√°pidamente, pero hay que pagarlo.  En lenguajes flexibles de alto nivel, los programas se pueden desarrollar r√°pidamente, pero se ejecutan lentamente despu√©s del lanzamiento.  Por ejemplo, es monstruosamente lento leer algo pesado en Python puro.  Los lenguajes tipo C funcionan mucho m√°s r√°pido, pero es m√°s f√°cil cometer errores en ellos, cuya b√∫squeda reducir√° toda la ganancia de velocidad a la nada. <br><br>  Por lo general, este dilema se resuelve de la siguiente manera: primero escriben el prototipo en algo flexible, por ejemplo, en Python o R, y luego lo reescriben en C / C ++ o Fortran.  Pero este ciclo es demasiado largo, ¬øpuedes prescindir de √©l? <br><br><img src="https://habrastorage.org/webt/c0/hu/mw/c0humwwihszecprm5u7-j1ofego.jpeg"><br><br>  Quiz√°s haya una soluci√≥n.  Julia es un lenguaje de programaci√≥n de alto nivel y flexible pero r√°pido.  Julia tiene despacho m√∫ltiple, un compilador inteligente integrado y herramientas de metaprogramaci√≥n.  <strong>Gleb Ivashkevich</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">phtRaveller</a> ), fundador de datarythmics, que desarrolla sistemas de aprendizaje autom√°tico para la industria y otras industrias, un ex f√≠sico, le contar√° m√°s sobre lo que tiene Julia. <br><br>  Gleb explicar√° por qu√© se necesitan nuevos lenguajes y por qu√© a veces falta Python.  √âl le dir√° lo que es interesante en Julia, sobre sus fortalezas y debilidades, lo comparar√° con otros idiomas y le mostrar√° cu√°les son las perspectivas del aprendizaje autom√°tico y la inform√°tica en general. <br><br>  <em>Descargo de responsabilidad.</em>  <em>No habr√° an√°lisis sint√°ctico.</em>  <em>Habrazhiteli experiment√≥ desarrolladores, por lo que no tiene sentido mostrar c√≥mo escribir un bucle, por ejemplo.</em> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/REVmhiJ1Zi8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  El problema de dos idiomas. </h2><blockquote>  Si escribe c√≥digo r√°pidamente, los programas se ejecutan lentamente.  Si los programas funcionan r√°pido, escr√≠balos durante mucho tiempo. </blockquote> Python cl√°sico cae en la primera categor√≠a.  Si elimina NumPy, considere algo en Python puro lentamente.  Por otro lado, hay lenguajes como C y C ++.  Es dif√≠cil encontrar un equilibrio, por lo que a menudo primero escriben un prototipo en algo flexible y, despu√©s de depurar el algoritmo, lo reescriben en el idioma m√°s r√°pido.  Este es un ejemplo de un <strong>problema claro en dos idiomas</strong> : un ciclo largo cuando tiene que escribir en Python y reescribirlo en C o en Cython, por ejemplo. <br><br>  Los especialistas en aprendizaje autom√°tico y ciencia de datos tienen NumPy, Sklearn, TensorFlow.  Han estado resolviendo sus problemas durante a√±os sin una sola l√≠nea en C, y parece que el problema de los dos lenguajes no les concierne.  Esto no es as√≠, el problema se manifiesta <strong>impl√≠citamente</strong> , porque el c√≥digo en NumPy o en TensorFlow no es realmente Python.  Se utiliza como metalenguaje para lanzar lo que hay dentro.  Dentro hay exactamente C / Fortran (en el caso de NumPy) o C ++ (en el caso de TensorFlow). <br><br>  Esta "caracter√≠stica" es poco visible, por ejemplo, en PyTorch, pero en Numpy es claramente visible.  Por ejemplo, si un ciclo cl√°sico de Python apareci√≥ en los c√°lculos, entonces algo sali√≥ mal.  En el c√≥digo productivo, no se necesitan bucles; debe reescribir todo para que NumPy pueda vectorizarlo y calcularlo r√°pidamente. <br><br>  Al mismo tiempo, a muchos les parece que NumPy es r√°pido y que todo est√° bien.  Veamos qu√© tiene NumPy debajo del cap√≥ para ver esto. <br><br><ul><li>  NumPy est√° tratando de solucionar el problema de flexibilidad de tipo Python, por lo que tiene un <strong>sistema de tipo</strong> bastante <strong>estricto</strong> .  Si la matriz tiene un cierto tipo, entonces no puede haber nada m√°s; si <code>Float64</code> est√° <code>Float64</code> , no se puede hacer nada al respecto. </li><li>  <strong>Despacho.</strong>  Dependiendo de los tipos de matrices y de la operaci√≥n que necesita realizar, NumPy dentro de s√≠ mismo decidir√° a qu√© funci√≥n llamar para hacer los c√°lculos lo m√°s r√°pido posible.  La biblioteca intentar√° sacar Python cl√°sico del ciclo de c√°lculo. </li></ul><br>  Resulta que Numpy no es tan r√°pido como parece.  Por eso hay proyectos como <strong>Cython</strong> o <strong>Numba</strong> .  El primero genera c√≥digo C a partir del "h√≠brido" de Python y C, y el segundo compila el c√≥digo en Python y, por lo general, esto es m√°s r√°pido. <br><blockquote>  Si NumPy fuera realmente tan r√°pido como parece para muchos, entonces la existencia de Cython y Numba no tendr√≠a sentido. </blockquote>  Reescribimos todo en Cython si queremos encontrar r√°pidamente algo grande y complejo.  Uno de los criterios para la calidad de un contenedor en Cython es la presencia o ausencia de llamadas puras de Python en el c√≥digo generado. <br><br>  Un ejemplo simple: agregamos el tipo (bueno) o no agregamos (malo), y obtenemos dos c√≥digos completamente diferentes, aunque adem√°s de los tipos, las opciones iniciales no son diferentes. <br><br><img src="https://habrastorage.org/webt/23/nj/e0/23nje0ddwbpf8c9debfufjvg0h8.png"><br><br>  Cuando generamos el c√≥digo C, en el primer caso obtenemos lo siguiente: <br><br><pre> <code class="cpp hljs">__pyx_t_4 = __pyx_v_i; __pyx_v_result = (__pyx_v_result + (*((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *) ( <span class="hljs-comment"><span class="hljs-comment">/* dim=0 */</span></span> (__pyx_v_a.data + __pyx_t_4 * __pyx_v_a.strides[<span class="hljs-number"><span class="hljs-number">0</span></span>]) ))));</code> </pre> <br>  Y en el segundo <code>result =0.</code>  se convertir√° en esto: <br><br><pre> <code class="cpp hljs">__pyx_t_6 = PyFloat_FromDouble((*((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *) ( <span class="hljs-comment"><span class="hljs-comment">/* dim=0 */</span></span> (__pyx_v_a.data + __pyx_t_4 * __pyx_v_a.strides[<span class="hljs-number"><span class="hljs-number">0</span></span>]) )))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(!__pyx_t_6)) __PYX_ERR(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_6); __pyx_t_7 = PyNumber_InPlaceAdd(__pyx_v_result, __pyx_t_6); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(!__pyx_t_7)) __PYX_ERR(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_7); __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = <span class="hljs-number"><span class="hljs-number">0</span></span>; __Pyx_DECREF_SET(__pyx_v_result, __pyx_t_7); __pyx_t_7 = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Cuando se especifica un tipo, el c√≥digo C se ejecuta a la velocidad del rayo.  Si no se especifica el tipo, vemos Python normal, pero desde el lado C: llamadas est√°ndar de Python, donde por alguna raz√≥n se crean <code>float</code> desde el <code>double</code> , se cuentan los enlaces y muchos otros c√≥digos basura.  Este c√≥digo es lento porque llama a Python para cada operaci√≥n. <br><br><h3>  ¬øEs posible resolver todos los problemas a la vez? </h3><br>  Es curioso que cuando pensamos en algo, tratamos de eliminar Python puro.  Hay dos opciones sobre c√≥mo hacer esto. <br><br><ul><li>  Usando <strong>Cython</strong> u otras herramientas.  Hay muchas maneras en que puede optimizar su c√≥digo de Cython para terminar casi sin llamadas de Python.  Pero esta no es la actividad m√°s agradable: no todo es tan obvio en Cython, y solo se gasta un poco menos de tiempo que si solo escribe todo en C. El m√≥dulo resultante se puede usar en Python, pero a√∫n as√≠ lleva mucho tiempo, se producen errores, el c√≥digo no siempre es obvio y no siempre est√° claro c√≥mo optimizarlo. </li><li>  Usando Numba, que hace una <strong>compilaci√≥n JIT</strong> . </li></ul><br>  Pero tal vez hay una mejor manera, y creo que esta es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Julia</a> . <br><br><h2>  Julia </h2><br>  Los creadores afirman que este es un lenguaje <strong>r√°pido</strong> , de <strong>alto nivel</strong> y <strong>flexible</strong> , que es comparable a Python en t√©rminos de facilidad para escribir c√≥digo.  En mi opini√≥n, Julia es como un <strong>lenguaje de script:</strong> no necesita hacer lo que tiene que hacer en C, donde todo es de muy bajo nivel, incluidas las estructuras de datos.  Al mismo tiempo, puede trabajar en una consola normal, como Python y otros idiomas. <br><br>  Julia usa <strong>la compilaci√≥n Just-In-Time</strong> : este es uno de los elementos que le da velocidad.  Pero el lenguaje es bueno con los c√°lculos, porque fue desarrollado para ellos.  Julia se utiliza para tareas cient√≠ficas y obtener un rendimiento decente. <br><blockquote>  Aunque Julia est√° tratando de parecer un lenguaje de prop√≥sito general, Julia es buena para la inform√°tica y no muy buena para los servicios web.  Usar Julia en lugar de Django, por ejemplo, no es la mejor opci√≥n. </blockquote>  Veamos las caracter√≠sticas del lenguaje como un ejemplo de una funci√≥n primitiva. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; methods(f) <span class="hljs-comment"><span class="hljs-comment"># 1 method for generic function "f": [1] f(x) in Main at mpconf.jl:2</span></span></code> </pre> <br>  Cuatro caracter√≠sticas son notables en este c√≥digo. <br><br><ul><li>  <strong>Pr√°cticamente no hay restricciones para usar Unicode</strong> .  Puede tomar f√≥rmulas de un art√≠culo sobre aprendizaje profundo o modelado num√©rico, reescribir con los mismos caracteres y todo funcionar√°: Unicode est√° cosido en casi todas partes. </li><li>  <strong>No hay signo de multiplicaci√≥n.</strong>  Sin embargo, no siempre es posible prescindir de √©l, por ejemplo, en 2.x (un n√∫mero de coma flotante multiplicado por x) que Julia jurar√°. </li><li>  <strong>Sin <code>return</code></strong>  En general, se recomienda que escriba <code>return</code> para poder ver lo que est√° sucediendo, pero el ejemplo devolver√° <code>Œ±</code> , porque la asignaci√≥n es una expresi√≥n. </li><li>  <strong>No tipos</strong>  Parecer√≠a que si hay velocidad, ¬øen alg√∫n momento deber√≠an aparecer los tipos?  S√≠, aparecer√°n, pero m√°s tarde. </li></ul><br>  Julia tiene tres caracter√≠sticas que dan flexibilidad y velocidad: <strong>despacho m√∫ltiple, metaprogramaci√≥n y paralelismo</strong> .  Hablaremos de los dos primeros, y dejaremos la paralelizaci√≥n para un estudio independiente para usuarios avanzados. <br><br><h3>  Programaci√≥n m√∫ltiple </h3><br>  La llamada a los <code>methods(f)</code> en el ejemplo anterior se ve inesperadamente: ¬øqu√© tipo de m√©todos tiene la funci√≥n?  Estamos acostumbrados al hecho de que tenemos objetos de clase, las clases tienen m√©todos.  Pero en Julia todo se da vuelta al rev√©s: las funciones tienen m√©todos, porque el lenguaje usa el despacho m√∫ltiple. <br><blockquote>  La programaci√≥n m√∫ltiple significa que la variante de una funci√≥n particular que se ejecutar√° est√° determinada por todo el conjunto de tipos de par√°metros de esta funci√≥n. </blockquote>  Describir√© brevemente c√≥mo funciona esto en un ejemplo ya familiar. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x::<span class="hljs-built_in"><span class="hljs-built_in">AbstractFloat</span></span>) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + sin(x) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; methods(f) <span class="hljs-comment"><span class="hljs-comment"># 2 methods for generic function "f": [1] f(x::AbstractFloat) in Main at mpconf.jl:6 [2] f(x) in Main at mpconf.jl:2</span></span></code> </pre> <br>  Las variantes de la misma funci√≥n para diferentes conjuntos de tipos se denominan m√©todos.  Hay dos en el c√≥digo: el primero para todos los n√∫meros de coma flotante y el segundo para todo lo dem√°s.  Cuando llamamos por primera vez a la funci√≥n, Julia decidir√° qu√© m√©todo usar y si debe compilarlo.  Si ya ha sido llamado y compilado, tomar√° el que es. <br><br>  Dado que en Julia todo no es como estamos acostumbrados, aqu√≠ puede agregar funciones a los tipos definidos por el usuario, pero estos no ser√°n m√©todos de tipo en el sentido de OOP.  Simplemente ser√° el campo en el que se escribe la funci√≥n, porque la <strong>funci√≥n es el mismo objeto completo</strong> que todo lo dem√°s. <br><br>  Para saber qu√© se activar√° exactamente, hay macros especiales.  Comienzan con <code>@</code> .  En el ejemplo, la macro <code>@which</code> permite averiguar qu√© m√©todo se llam√≥ para un caso espec√≠fico. <br><br><img src="https://habrastorage.org/webt/nu/ix/ih/nuixiha2x9r2b148gdqyo81fkri.png"><br><br>  En el primer caso, Julia decidi√≥ que dado que 2 es un n√∫mero entero, no encaja en <code>AbstractFloat</code> , y llam√≥ a la primera opci√≥n.  En el segundo caso, decidi√≥ que era <code>Float</code> y ya hab√≠a pedido una versi√≥n especializada.  Aproximadamente esto funcionar√° si agrega otros m√©todos para algunos tipos espec√≠ficos. <br><br><h3>  LLVM y JIT </h3><br>  Julia usa el marco LLVM para compilar.  La biblioteca de compilaci√≥n JIT viene en un paquete de idiomas.  La primera vez que se llama a la funci√≥n, Julia busca si la funci√≥n se ha utilizado con este conjunto de tipos y la compila si es necesario.  El primer lanzamiento llevar√° alg√∫n tiempo, y luego todo funcionar√° r√°pidamente. <br><blockquote>  La funci√≥n se compilar√° en el momento de la primera llamada para este conjunto de par√°metros. </blockquote>  Caracter√≠sticas del compilador <br><br><ul><li>  <strong>El compilador es razonablemente razonable</strong> porque LLVM es un buen producto. </li><li>  Los desarrolladores m√°s avanzados pueden <strong>analizar el proceso de compilaci√≥n</strong> y ver qu√© genera. </li><li>  <strong>La compilaci√≥n de Julia y Numba son similares</strong> .  En Numba, tambi√©n crea un decorador JIT, pero en Numba no puede "entrar" tanto y decidir qu√© optimizar o cambiar. </li></ul><br>  Para ilustrar el trabajo del compilador, dar√© un ejemplo de una funci√≥n simple: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; <span class="hljs-meta"><span class="hljs-meta">@code_llvm</span></span> f(<span class="hljs-number"><span class="hljs-number">2</span></span>) define i64 <span class="hljs-meta"><span class="hljs-meta">@julia_f_35897</span></span>(i64) { top: %<span class="hljs-number"><span class="hljs-number">1</span></span> = mul i64 %<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> %<span class="hljs-number"><span class="hljs-number">2</span></span> = add i64 %<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ret i64 %<span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre><br>  La macro <code>@code_llvm</code> permite ver el resultado de la generaci√≥n.  Este <strong>LLVM IR</strong> es <strong>una representaci√≥n intermedia</strong> , una especie de ensamblador. <br><br>  En el c√≥digo, el argumento de la funci√≥n se multiplica por 3, se agrega 1 al resultado, se devuelve el resultado.  Todo es lo m√°s sencillo posible.  Si define la funci√≥n un poco diferente, por ejemplo, reemplace 3 con 2, entonces todo cambiar√°. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; <span class="hljs-meta"><span class="hljs-meta">@code_llvm</span></span> f(<span class="hljs-number"><span class="hljs-number">2</span></span>) define i64 <span class="hljs-meta"><span class="hljs-meta">@julia_f_35894</span></span>(i64) { top: %<span class="hljs-number"><span class="hljs-number">1</span></span> = shl i64 %<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> %<span class="hljs-number"><span class="hljs-number">2</span></span> = or i64 %<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ret i64 %<span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre> <br>  Parecer√≠a, ¬øcu√°l es la diferencia: 2, 3, 10?  Pero Julia y LLVM ven que cuando llamas a una funci√≥n para un entero, puedes hacerlo un poco m√°s inteligente.  Multiplicar por dos un n√∫mero entero es un desplazamiento a la izquierda por un bit: es m√°s r√°pido que el producto.  Pero, por supuesto, esto solo funciona para enteros, no funcionar√° desplazar <code>Float</code> izquierda por 1 bit y obtener el resultado de multiplicar por 2. <br><br><h3>  Tipos personalizados </h3><br>  Los tipos personalizados en Julia son tan r√°pidos como los tipos integrados.  Se realiza una programaci√≥n m√∫ltiple en ellos, y ser√° tan r√°pido como para los tipos incorporados.  En este sentido, el mecanismo de despacho m√∫ltiple est√° profundamente incrustado en el lenguaje. <br><br>  Es l√≥gico esperar que las variables no tengan tipos, solo los valores las tienen.  Las variables sin tipo son solo un marcador, una etiqueta en alg√∫n contenedor. <br><br>  <strong>El sistema de tipos es jer√°rquico.</strong>  No podemos crear descendientes de tipos concretos; los tipos abstractos solo pueden tenerlos.  Sin embargo, los tipos abstractos no pueden ser instanciados.  Este matiz no ser√° de inter√©s para todos. <br><br>  Como explicaron los autores del lenguaje cuando desarrollaron a Julia, quer√≠an obtener el resultado, y si algo era dif√≠cil de hacer, lo rechazaron.  Tal sistema de tipo jer√°rquico fue m√°s f√°cil de desarrollar.  Este no es un problema catastr√≥fico, pero si no vuelves la cabeza al principio, ser√° un inconveniente. <br><br>  <strong>Los tipos se pueden parametrizar</strong> , que es un poco como C / C ++.  Por ejemplo, podemos tener una estructura dentro de la cual hay campos, pero los tipos de estos campos no est√°n especificados: estos son par√°metros.  Especificamos un tipo espec√≠fico en la instanciaci√≥n. <br><br>  <strong>En la mayor√≠a de los casos, los tipos se pueden omitir</strong> .  Por lo general, son necesarios cuando el tipo ayuda al compilador a adivinar la mejor forma de compilar.  En este caso, es mejor especificar los tipos.  Tambi√©n debe especificar tipos si desea lograr un mejor rendimiento. <br><br>  Veamos qu√© es posible y qu√© no se puede instanciar. <br><br><img src="https://habrastorage.org/webt/0r/xr/bl/0rxrbllszhjk9okl1-3irj1zdns.png"><br><br>  El primer tipo de <code>AbstractPoint</code> no puede ser instanciado.  Este es solo un padre com√∫n para todos que podemos especificar en los m√©todos, por ejemplo.  La segunda l√≠nea dice que <code>PlanarPoint{T}</code> es un descendiente de este punto abstracto.  Debajo de los campos comienzan, aqu√≠ puede ver la parametrizaci√≥n.  Puede poner un <code>float</code> , <code>int</code> u otro tipo aqu√≠. <br><br>  El primer tipo no puede ser instanciado, y para todo lo dem√°s es imposible crear descendientes.  Adem√°s, por defecto son <strong>inmutables</strong> .  Para poder cambiar los campos, esto debe especificarse expl√≠citamente. <br><br>  Cuando todo est√© listo, puede continuar, por ejemplo, calcular la distancia para diferentes tipos de puntos.  En el ejemplo, el primer punto en el plano es <code>PlanarPoint</code> , luego en la esfera y en el cilindro.  Dependiendo de los dos puntos entre los que calculamos la distancia, necesitamos usar diferentes m√©todos.  En general, la funci√≥n se ver√° as√≠: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> describe(p::AbstractPoint) println(<span class="hljs-string"><span class="hljs-string">"Point instance: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$p</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Para <code>Float64</code> , <code>Float32</code> , <code>Float16</code> ser√°: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> distance(pf::PlanarPoint{T}, ps::PlanarPoint{T}) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">AbstractFloat</span></span> sqrt((pf.x-ps.x)^<span class="hljs-number"><span class="hljs-number">2</span></span> + (pf.y-ps.y)^<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Y para los enteros, el m√©todo de c√°lculo de distancia se ver√° as√≠: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> distance(pf::PlanarPoint{T}, ps::PlanarPoint{T}) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span> abs(pf.x-ps.x) + abs(pf.y-ps.y) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Para los puntos de cada tipo, se llamar√°n diferentes m√©todos. <br><br><img src="https://habrastorage.org/webt/ya/8n/_d/ya8n_dvihkdqpsmqfkmdl5wm_ro.png"><br><br>  Si hace trampa y, por ejemplo, aplica <code>distance(f1, i2)</code> , Julia jurar√°: ‚Äú¬°No conozco este m√©todo!  Me preguntaste tales m√©todos y dijiste que ambos son del mismo tipo.  No me dijiste c√≥mo contar esto cuando un par√°metro es <code>float</code> y el otro es <code>int</code> ". <br><br><h3>  Velocidad </h3><br>  Es posible que ya haya estado encantado: ‚ÄúHay una compilaci√≥n JIT: escribir es f√°cil, funcionar√° r√°pidamente.  ¬°Tira a Python y comienza a escribir en Julia! <br><br>  Pero no tan simple.  No todas las caracter√≠sticas de Julia ser√°n r√°pidas.  Depende de dos factores. <br><br><ul><li>  <strong>Del desarrollador</strong> .  No hay idiomas en los que ninguna funci√≥n sea r√°pida.  Un desarrollador inexperto incluso escribir√° c√≥digo en C que funcionar√° mucho m√°s lentamente que el c√≥digo Python de un desarrollador experimentado.  Cualquier idioma tiene sus propios trucos y matices de los que depende el rendimiento.  El compilador, ya sea un est√°tico regular o un JIT, no puede proporcionar todas las opciones imaginables y optimizar todo en absoluto. </li><li>  <strong>De tipo estabilidad</strong> .  En una versi√≥n m√°s r√°pida, se compilar√°n las funciones que son estables por tipo. </li></ul><br><h3>  Estabilidad tipo </h3><br>  ¬øQu√© es la estabilidad de tipo?  Cuando el compilador no puede adivinar de manera suficientemente confiable lo que sucede con los tipos, tiene que generar mucho c√≥digo envoltorio para que todo lo que llegue a la entrada funcione. <br><br>  Un ejemplo simple para entender la estabilidad de tipos. <br><br><img src="https://habrastorage.org/webt/ye/83/jv/ye83jvzws3gkfjvobwf6xvtlpaq.png"><br><br>  Los especialistas en aprendizaje autom√°tico dir√°n que esta es una activaci√≥n de relu normal: si x&gt; 0, devu√©lvelo como est√°, de lo contrario, devuelve cero.  Un problema es el cero despu√©s del entero de signo de interrogaci√≥n.  Esto significa que si llamamos a esta funci√≥n para un n√∫mero de punto flotante, en un caso, se devolver√° un n√∫mero de punto flotante y, en el otro, un n√∫mero entero. <br><br>  El compilador no puede adivinar el tipo de resultado solo por el tipo de argumento de funci√≥n.  √âl tambi√©n necesita saber el significado.  Por lo tanto, genera mucho c√≥digo. <br><br>  Luego, creamos una matriz de 100 por 100 n√∫meros aleatorios de 0 a 1, la cambiamos por 0.5 para distribuir uniformemente los n√∫meros positivos y negativos, y medimos el resultado.  Hay dos puntos interesantes: el punto y la funci√≥n.  El punto despu√©s de <code>rand(100,100)</code> significa "aplicar a cada elemento".  Si tienes alg√∫n tipo de colecci√≥n y funci√≥n escalar, ponle fin, y Julia har√° el resto.  Podemos suponer que esto es tan efectivo como un bucle normal en un lenguaje compilado normal.  No hay necesidad de escribir, todo se har√° por usted. <br><br>  No hay problemas en este momento: el <strong>problema est√° dentro de la funci√≥n misma</strong> .  El tiempo de ejecuci√≥n estimado de tal opci√≥n en una computadora decente para dicha matriz es de microsegundos.  Pero en realidad, milisegundos, que es demasiado para una matriz tan peque√±a. <br><br>  Cambia solo una l√≠nea. <br><br><img src="https://habrastorage.org/webt/bt/3g/4t/bt3g4t3kgng3thzuyb75mi_bmzw.png"><br><br>  La funci√≥n <code>zero(x)</code> ejecuta genera un cero del mismo tipo que el argumento <code>(x)</code> .  Esto significa que no importa cu√°l sea el valor de <code>x</code> , el tipo de resultado siempre ser√° conocido por el tipo de <code>x</code> s√≠. <br><blockquote>  Cuando miramos solo el tipo de argumentos y ya conocemos el tipo de resultado, estas son funciones que son de tipo estable. </blockquote>  Si necesitamos ver el significado de los argumentos, estas no son funciones estables. <br><br>  Cuando el compilador puede optimizar el c√≥digo, la diferencia en el tiempo de ejecuci√≥n se obtiene en dos √≥rdenes de magnitud.  En el segundo ejemplo, solo se asign√≥ exactamente a una nueva matriz, un par m√°s de decenas de bytes y nada m√°s.  Esta opci√≥n es mucho m√°s efectiva que la anterior. <br><br>  Esto es lo principal a tener en cuenta cuando escribimos c√≥digo en Julia.  Si escribe como en Python, funcionar√° como en Python.  Si realiza las mismas operaciones en NumPy, entonces cero con o sin un punto no juega un papel.  Pero en Julia, esto puede socavar en gran medida el rendimiento. <br><br>  Afortunadamente, hay un m√©todo para averiguar si existe un problema.  Esta es la macro <code>@code_warntype</code> , que le permite averiguar si el compilador puede adivinar d√≥nde est√°n los tipos y optimizar si todo est√° bien. <br><br><img src="https://habrastorage.org/webt/bg/jp/xf/bgjpxfne2jxskxqaloz2omljbda.png"><br><br>  En la primera opci√≥n (izquierda), el compilador no est√° seguro del tipo y lo muestra en rojo.  En el segundo caso, siempre habr√° <code>Float64</code> para tal argumento, por lo que puede generar c√≥digo mucho m√°s corto. <br><br>  Esto todav√≠a no es LLVM, pero el c√≥digo de Julia etiquetado, <code>return 0</code> o <code>return 0.0</code> da una diferencia de rendimiento de dos √≥rdenes de magnitud. <br><br><h3>  Metaprogramaci√≥n </h3><blockquote>  La metaprogramaci√≥n es cuando creamos programas en un programa y los ejecutamos sobre la marcha. </blockquote>  Este es un m√©todo poderoso que le permite hacer muchas cosas interesantes diferentes.  Un ejemplo cl√°sico es Django ORM, que crea campos utilizando metaclases. <br><br>  Mucha gente conoce el descargo de responsabilidad de <strong>Tim Peters</strong> , autor de Zen of Python: <i>‚ÄúLas metaclases son una magia m√°s profunda de la que el 99% de los usuarios nunca deber√≠an preocuparse.</i>  <i>Si se pregunta si se necesitan metaclases en Python, no las necesita.</i>  <i>Si los necesita, entonces sabe exactamente por qu√© y c√≥mo usarlos ".</i> <i><br></i> <br>  Con la metaprogramaci√≥n, la situaci√≥n es similar, pero en Julia se cose mucho m√°s profundo, esta es una caracter√≠stica importante de todo el lenguaje.  El c√≥digo de Julia tiene la misma estructura de datos que cualquier otro, puede manipular, combinar, crear expresiones, y todo esto funcionar√°. <br><br><pre> <code class="julia hljs">julia&gt; x = <span class="hljs-number"><span class="hljs-number">4</span></span>; julia&gt; typeof(:(x+<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-built_in"><span class="hljs-built_in">Expr</span></span> julia&gt; expr = :(x+<span class="hljs-number"><span class="hljs-number">1</span></span>) :(x + <span class="hljs-number"><span class="hljs-number">1</span></span>) julia&gt; expr.head :call julia&gt; expr.args <span class="hljs-number"><span class="hljs-number">3</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: :+ :x <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  <strong>Las macros son una de las herramientas de metaprogramaci√≥n en Julia</strong> : les damos algo, miran, agregan la correcta, eliminan lo innecesario y dan el resultado.  En todos los ejemplos anteriores, pasamos la llamada a la funci√≥n, y la macro dentro analiz√≥ la llamada.  Todo esto sucede al nivel de trabajar con el √°rbol de sintaxis. <br><br>  Puede analizar expresiones muy simples: si es, por ejemplo, <code>(x+1)</code> , esta es una llamada a la funci√≥n <code>+</code> (la suma no es un operador, como en muchos otros idiomas, sino una funci√≥n) y dos argumentos: un car√°cter (dos puntos significa que es un car√°cter ), y el segundo es solo una constante. <br><br>  Otro ejemplo macro simple: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">macro</span></span> named(name, expr) println(<span class="hljs-string"><span class="hljs-string">"Starting </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">quote</span></span> $(esc(expr)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; <span class="hljs-meta"><span class="hljs-meta">@named</span></span> <span class="hljs-string"><span class="hljs-string">"some process"</span></span> x=<span class="hljs-number"><span class="hljs-number">5</span></span>; Starting some process julia&gt; x <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br>  Utilizando macros, por ejemplo, se crean indicadores de progreso o filtros para marcos de datos; este es un mecanismo com√∫n en Julia. <br><blockquote>  Las macros no se ejecutan en el momento de la llamada, sino al analizar el c√≥digo. </blockquote>  Esta es la principal caracter√≠stica macro en Julia.  -    ,       .   ,   ,       . <br><br><h3> ,      </h3><br> Julia ‚Äî     .      . <br><br><ul><li> Julia  <strong> </strong> .       . </li><li> <strong> </strong> ,    .    ,   ,  C    . </li><li>  Julia <strong>JIT-  </strong> .   ,  , ,   ,    . </li><li>     ‚Äî <strong> </strong> .      . </li><li> <strong>    </strong>     ( ).       ,         .    ,    ,    . </li><li> Julia  <strong></strong> ‚Äî      . </li></ul><br><h2>  Ecosistema </h2><br>  ,    ,   Julia   .    ,     , data science   ,    ,  ,     Python. ,  Python  Pandas,      ,    ,    ,   Julia      . <br><br>  Julia  ,       Python 2008 .        Python,        ,    Julia.    ,     .    ,    Julia. <br><br><h3>   ( ) Python  Julia </h3><br> <strong> </strong> .    Julia:  , ,    .‚Ä¶ <br><br> <strong></strong> .   . <br><br><ul><li> <strong>DataFrames.jl</strong> . </li><li>   <strong>JuliaDB</strong>     ,       . </li><li>        <strong>Query.jl</strong> .     Pandas ‚Äî    - ,   .. </li></ul><br> <strong>Plotting</strong> .     <strong>Matplotlib</strong> ,         Julia.     :  <strong>VegaLite.jl</strong> ,   <strong>Plots.jl</strong> ,     ,  <strong>Gadfly.jl</strong> . <br><br> <strong> </strong> .    <strong>TensorFlow</strong> ,     Flux.jl.    Flux    , ,     ,   Keras  TensorFlow,   .      . <br><br> <strong>Scikit-learn</strong> .   ,  ,     sklearn,    ,  . <br><br> <strong>XGBoost</strong> .  ,  Julia   . <br><br><h3>     ? </h3><br>     <strong>Jupyter</strong> . IDE ‚Äî  Juno,    Visual Studio,         . <br><br> <strong></strong> .  GPU/TPU  .  CUDAnative.jl    Julia     .    Julia-,    -     ,        .    ,      ,      , , . <br><br> <strong> :</strong>   C, Fortran, Python   . <br><br> <strong> </strong>   ,    . <br><br> <strong>Packaging</strong> :      Julia:      , ,   .. <br><br><h3>   </h3><br>      ,      ,   .  ,   ,    .   ,   <strong>PyTorch</strong>       ,  TensorFlow,     ,        . <br><br>      ,        , ,      .      Julia,   , ,      .   ,   <strong> </strong> ,  <strong>Zygote.jl</strong> .     Flux.jl. <br><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Zygote julia&gt; <span class="hljs-literal"><span class="hljs-literal">œÜ</span></span>(x) = x*sin(x) julia&gt; Zygote.gradient(<span class="hljs-literal"><span class="hljs-literal">œÜ</span></span>, <span class="hljs-literal"><span class="hljs-literal">œÄ</span></span>/<span class="hljs-number"><span class="hljs-number">2.</span></span>) (<span class="hljs-number"><span class="hljs-number">1.0</span></span>,) julia&gt; model = Chain(Dense(<span class="hljs-number"><span class="hljs-number">768</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, relu), Dense(<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>), softmax) julia&gt; loss(x, y) = crossentropy(model(x), y) + sum(norm, params(model)) julia&gt; optimizer = ADAM(<span class="hljs-number"><span class="hljs-number">0.001</span></span>) julia&gt; Flux.train!(loss, params(model), data, optimizer) julia&gt; model = Chain(x -&gt; sqrt(x), x-&gt;x-<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>     <code>œÜ</code>  , , ,       . <br><br>  Zygote   ¬´source-to-source¬ª:         ,    ,   .   <strong>differentiable programming ‚Äî  </strong> ‚Äî       backpropagation     ,    . <br><br>     Julia     : ¬´source-to-source¬ª          ,      . ,     . <br><br><h2>  Julia  ? </h2><br>     ,         ‚Äî  .        . <br><br>   - , , ,       ‚Äî . <br><br>    ,   ,  . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Julia</a> ,   . <br><br><ul><li>     ,  ,    . Julia   ¬´¬ª . </li><li>    ,     API,     ,    . </li></ul><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Moscow Python Conf++</a>    ,  27   ,          Python  Julia.   ,     ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">telegram-</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>  MoscowPython. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/476114/">https://habr.com/ru/post/476114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../476104/index.html">No use MTProxy gratis y otros tipos de proxies gratuitos ...</a></li>
<li><a href="../476106/index.html">"Protocolos de criptosistemas": Diffie - Hellman, El-Gamal, MTI / A (0), STS</a></li>
<li><a href="../476108/index.html">Cerebro mutable</a></li>
<li><a href="../476110/index.html">¬øPor qu√© necesita una marca personal?</a></li>
<li><a href="../476112/index.html">Elixir como objetivo de desarrollo para python async</a></li>
<li><a href="../476118/index.html">Dise√±o de interfaz para el juego, dibuja un anillo Havel de Dark Souls 3</a></li>
<li><a href="../476122/index.html">"Escucha" el cosmos: de la materia oscura al cometa Churyumov - Gerasimenko</a></li>
<li><a href="../476126/index.html">C√≥mo probar el rendimiento del servidor: una selecci√≥n de varios puntos de referencia de c√≥digo abierto</a></li>
<li><a href="../476128/index.html">Ivan Osipov y Yuri Artamonov sobre Kotlin y complementos para IntelliJ IDEA en la reuni√≥n jug.msk.ru</a></li>
<li><a href="../476134/index.html">MONQ - monitoreo y AIOps originarios de Rusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>