<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦀 🙋🏾 🈚️ Pembuatan kode dari OpenAPI v3 (alias Swagger 3) ke TypeScript dan tidak hanya 🙍 🌽 🚱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dua tahun lalu, saya memulai pengembangan  satu lagi  generator kode gratis dari Spesifikasi OpenAPI v3 ke TypeScript ( tersedia di Github ). Awalnya,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pembuatan kode dari OpenAPI v3 (alias Swagger 3) ke TypeScript dan tidak hanya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483628/"><p>  Dua tahun lalu, saya memulai pengembangan <del>  satu lagi </del>  generator kode gratis dari <a href="https://swagger.io/docs/specification/about/">Spesifikasi OpenAPI</a> v3 ke TypeScript ( <a href="https://github.com/koshevy/codegena">tersedia di Github</a> ).  Awalnya, saya mulai membuat generasi efisien tipe data primitif dan kompleks dalam TypeScript, dengan mempertimbangkan berbagai fitur <a href="https://json-schema.org/">Skema JSON</a> , seperti <a href="https://json-schema.org/understanding-json-schema/reference/combining.html">oneOf / anyOf / allOf</a> , dll.  ( <a href="https://github.com/swagger-api/swagger-codegen">Solusi asli</a> Swagger memiliki beberapa masalah dengan ini).  Gagasan lain adalah menggunakan skema dari spesifikasi untuk validasi di bagian depan, belakang dan bagian lain dari sistem. </p><br><p><img src="https://habrastorage.org/webt/hz/cd/u4/hzcdu47rcjbutgqbe6pdb2k46x8.png"></p><a name="habracut"></a><br><p>  Sekarang generator kode relatif siap - ini pada tahap <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B8%25D0%25BD%25D0%25B8%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE_%25D0%25B6%25D0%25B8%25D0%25B7%25D0%25BD%25D0%25B5%25D1%2581%25D0%25BF%25D0%25BE%25D1%2581%25D0%25BE%25D0%25B1%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B4%25D1%2583%25D0%25BA%25D1%2582">MVP</a> .  Ini memiliki banyak hal yang diperlukan dalam hal menghasilkan tipe data, serta perpustakaan eksperimental untuk menghasilkan layanan front-end (sejauh ini untuk Angular).  Pada artikel ini saya ingin menunjukkan perkembangan dan memberi tahu bagaimana mereka dapat membantu jika Anda menggunakan TypeScript dan OpenAPI v3.  Sepanjang jalan, saya ingin berbagi beberapa ide dan pertimbangan yang muncul dalam proses kerja saya.  Nah, jika Anda tertarik, Anda bisa membaca backstory yang saya sembunyikan di spoiler agar tidak menyulitkan pembacaan bagian teknis. </p><br><h2 id="soderzhanie">  Isi </h2><br><ol><li>  <a href="https://habr.com/ru/post/483628/">Latar belakang</a> </li><li>  <a href="https://habr.com/ru/post/483628/">Deskripsi</a> </li><li>  <a href="https://habr.com/ru/post/483628/">Instalasi dan penggunaan</a> </li><li>  <a href="https://habr.com/ru/post/483628/">Berlatih menggunakan generator kode</a> </li><li>  <a href="https://habr.com/ru/post/483628/">Menggunakan tipe data yang dihasilkan dalam aplikasi</a> </li><li>  <a href="https://habr.com/ru/post/483628/">Dekomposisi sirkuit dalam spesifikasi OAS</a> </li><li>  <a href="https://habr.com/ru/post/483628/">Dekomposisi bersarang</a> </li><li>  <a href="https://habr.com/ru/post/483628/">Layanan yang dibuat secara otomatis untuk bekerja dengan REST API</a> <br><ol><li>  <a href="https://habr.com/ru/post/483628/">Mengapa ini dibutuhkan?</a> </li><li>  <a href="https://habr.com/ru/post/483628/">Generasi layanan</a> </li><li>  <a href="https://habr.com/ru/post/483628/">Menggunakan layanan yang dihasilkan</a> </li></ol></li><li>  <a href="https://habr.com/ru/post/483628/">Alih-alih kata penutup</a> </li></ol><br><a name="Foreword"></a><br><h2 id="predystoriya">  Latar belakang </h2><br><div class="spoiler">  <b class="spoiler_title">Perluas untuk membaca (lewati)</b> <div class="spoiler_text"><p>  Semuanya dimulai dua tahun yang lalu - kemudian saya bekerja untuk sebuah perusahaan yang mengembangkan platform Data Mining dan bertanggung jawab untuk frontend (terutama TypeScript + Angular).  Fitur proyek adalah struktur data yang kompleks dengan sejumlah besar parameter (30 atau lebih) dan tidak selalu hubungan bisnis yang jelas di antara mereka.  Perusahaan tumbuh, dan lingkungan perangkat lunak mengalami perubahan yang cukup sering.  Frontend harus berpengetahuan luas dalam nuansa, karena beberapa perhitungan digandakan di depan dan di backend.  Artinya, ini adalah kasus ketika menggunakan OpenAPI lebih dari tepat.  Saya menemukan periode di perusahaan ketika dalam hitungan bulan tim pengembangan memperoleh spesifikasi tunggal, yang menjadi basis pengetahuan umum untuk bagian belakang, depan dan bahkan Core, yang tersembunyi di belakang bagian belakang backend web.  Versi OpenAPI dipilih "untuk pertumbuhan" - maka v3.0 masih cukup muda </p><br><p>  Ini bukan lagi spesifikasi dalam satu atau lebih file YML / JSON statis, dan bukan hasil <a href="https://github.com/zircote/swagger-php">annotator</a> , tetapi seluruh pustaka komponen, metode, template, dan properti, yang diorganisasikan sesuai dengan konsep DDD platform.  Perpustakaan dibagi menjadi direktori dan file, dan seorang kolektor yang diatur secara khusus menghasilkan dokumen OAS untuk setiap bidang studi.  Cara eksperimental dibangun alur kerja, yang dapat digambarkan sebagai Desain-Pertama. </p><br><blockquote>  Ada <a href="https://habr.com/ru/company/yamoney/blog/347390/">artikel bagus</a> di blog perusahaan Yandex.Money, yang membahas tentang Desain Pertama </blockquote><p>  Desain Pertama dan spesifikasi umum membantu mengurangi pengetahuan, tetapi masalah baru menjadi jelas - menjaga relevansi kode.  Spesifikasi tersebut menjelaskan beberapa lusin metode dan lusinan (dan kemudian ratusan) entitas.  Tetapi kode harus ditulis secara manual: tipe data, layanan untuk bekerja dengan REST, dll.  Satu atau dua sprint dengan cerita paralel sangat mengubah gambar;  menambah kompleksitas pada penggabungan beberapa cerita dan faktor manusia.  Rutinitas terancam signifikan, dan solusinya tampak jelas - Anda memerlukan pembuatan kode.  Lagi pula, spesifikasi OAS sudah berisi semua yang diperlukan agar tidak mengetik ulang secara manual.  Tapi itu tidak sesederhana itu. </p><br><p>  Frontend berada di akhir siklus produksi, jadi saya merasakan perubahan yang lebih menyakitkan daripada rekan-rekan dari departemen lain.  Ketika merancang API REST, lingkungan backend memutuskan, dan bahkan setelah persetujuan "Design First", kelembaman tetap;  untuk ujung depan, semuanya tampak kurang jelas.  Bahkan, saya memahami ini sejak awal, dan mulai menyelidiki tanah di muka - ketika pembicaraan tentang spesifikasi "universal" baru saja dimulai.  Tidak ada pembicaraan untuk menulis pembuat kode Anda sendiri;  Saya hanya ingin menemukan sesuatu yang siap. </p><br><p>  Saya kecewa.  Ada dua masalah: OAS versi 3.0, dengan dukungan yang, sepertinya, tidak ada yang terburu-buru, dan kualitas solusi sendiri - pada waktu itu (saya ingat itu dua tahun lalu), saya berhasil menemukan dua solusi yang relatif siap pakai: <a href="https://github.com/swagger-api/swagger-codegen">dari Swagger</a> dan dari Microsoft (sepertinya <a href="https://github.com/Azure/autorest">itu</a> ).  Pada yang pertama, dukungan untuk OAS 3.0 dalam versi beta yang mendalam.  Yang kedua hanya bekerja dengan versi 2.x, tetapi tidak ada perkiraan yang jelas.  Ngomong-ngomong, saya tidak dapat memulai generator kode Microsoft bahkan pada dokumen uji format Swagger 2.0.  Solusi dari Swagger berhasil, tetapi skema yang kurang lebih rumit dengan tautan $ ref berubah menjadi “KESALAHAN!”, Dan dependensi rekursif mengirimnya ke loop tanpa batas.  Ada masalah dengan <a href="">tipe primitif</a> .  Selain itu, saya tidak begitu mengerti bagaimana bekerja dengan layanan yang dibuat secara otomatis - mereka tampaknya dibuat untuk pertunjukan, dan penggunaan mereka yang sebenarnya menciptakan lebih banyak masalah daripada yang mereka selesaikan (menurut saya).  Dan akhirnya, integrasi file JAR ke CI / CD yang berorientasi NPM tidak nyaman: Saya harus mengunduh <a href="https://oss.sonatype.org/content/repositories/snapshots/io/swagger/codegen/v3/swagger-codegen-cli/3.0.15-SNAPSHOT/">snapshot yang diperlukan</a> secara manual, yang sepertinya berbobot 13 megabyte, dan melakukan sesuatu dengan itu.  Secara umum, saya beristirahat dan memutuskan untuk menonton apa yang terjadi selanjutnya. </p><br><p>  Setelah sekitar lima bulan, masalah pembuatan kode muncul kembali.  Saya harus menulis ulang dan memperluas bagian dari aplikasi Web, dan pada saat yang sama saya ingin memperbaiki layanan lama untuk bekerja dengan REST API dan tipe data.  Tetapi penilaian kompleksitas tidak optimis: dari satu minggu ke dua - dan ini hanya untuk layanan REST dan deskripsi tipe.  Saya tidak akan mengatakan bahwa itu sangat membuat saya tertekan, tapi tetap saja.  Di sisi lain, saya tidak pernah menemukan solusi untuk pembuatan kode dan tidak menunggu, dan implementasinya tidak akan memakan waktu lebih sedikit.  Artinya, tidak ada pertanyaan tentang hal itu: manfaatnya diragukan, risikonya besar.  Tidak ada yang akan mendukung gagasan ini, dan saya tidak mengusulkan.  Sementara itu, liburan Mei sudah dekat, dan perusahaan "berhutang" kepada saya beberapa hari karena bekerja di akhir pekan.  Selama dua minggu saya melarikan diri dari semua pengalaman kerja ke Georgia, tempat saya pernah tinggal selama hampir setahun. </p><br><p>  Di sela-sela pesta dan pesta, saya perlu melakukan sesuatu, dan saya memutuskan untuk menulis keputusan saya.  Bekerja di kafe musim panas di dekat Vake Park ternyata sangat produktif, dan saya kembali ke Peter dengan pembuat kode yang sudah jadi untuk tipe data.  Kemudian untuk satu bulan lagi saya “menyelesaikan” layanan di akhir pekan sebelum dia siap bekerja. </p><br><p>  Sejak awal, saya membuat generator kode terbuka, mengerjakannya di waktu luang saya.  Meskipun, pada kenyataannya, ia menulis untuk konsep kerja.  Saya tidak akan mengatakan bahwa revisi / run-in berjalan tanpa masalah;  dan saya tidak akan mengatakan bahwa itu penting.  Tetapi pada titik tertentu saya perhatikan bahwa saya berhenti menggunakan dokumentasi Redoc / Swagger: menavigasi kode lebih nyaman, asalkan kode selalu up-to-date dan dikomentari.  Segera, saya "mencetak" pencapaian saya, tanpa mengembangkannya sama sekali, sampai seorang kolega (sekarang enam bulan lalu saya pergi ke perusahaan lain) menyarankan saya untuk menganggapnya lebih serius (dia juga datang dengan nama itu). </p><br><blockquote>  Saya tidak punya cukup waktu luang, dan beberapa bulan saya harus menyelesaikannya di latar belakang: <a href="https://stackblitz.com/edit/codegena-playground">taman bermain</a> , aplikasi ujian, reorganisasi proyek.  Sekarang saya siap menerima umpan balik. </blockquote></div></div><br><a name="Description"></a><br><h2 id="opisanie">  Deskripsi </h2><br><p> Saat ini, solusi untuk pembuatan kode mencakup tiga pustaka NPM yang terintegrasi dalam ocrey @codegena dan terletak di <a href="https://github.com/koshevy/codegena">repositori mono</a> umum: </p><br><div class="scrollable-table"><table><thead><tr><th>  Perpustakaan </th><th>  Deskripsi </th></tr></thead><tbody><tr><td>  @ codegena / oapi3ts </td><td>  Pustaka dasar adalah konverter dari OAS3 ke deskripsi tipe data (sekarang hanya mendukung TypeScript) </td></tr><tr><td>  @ codegena / ng-api-service </td><td>  Perpanjangan untuk Layanan Angular </td></tr><tr><td>  @ codegena / oapi3ts-cli </td><td>  Shell agar mudah digunakan dalam skrip CLI </td></tr></tbody></table></div><br><a name="SetupAndUsing"></a><br><h3 id="ustanovka-i-ispolzovanie">  Instalasi dan penggunaan </h3><br><p>  Opsi paling praktis adalah menggunakan skrip NodeJS yang dijalankan dari CLI.  Pertama, Anda perlu menginstal dependensi: </p><br><pre> <code class="plaintext hljs">npm i @codegena/oapi3ts, @codegena/ng-api-service, @codegena/oapi3ts-cli</code> </pre> <br><p>  Lalu, buat file js (mis. <code>update-typings.js</code> ) dengan kode: </p><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cliLib = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@codegena/oapi3ts-cli'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cliApp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cliLib.CliApplication; cliApp.createTypings(); <span class="hljs-comment"><span class="hljs-comment">// cliApp.createServices('angular'); // optional</span></span></code> </pre> <br><p>  Dan mulai dengan melewati tiga parameter: </p><br><pre> <code class="plaintext hljs">node ./update-typings.js --srcPath ./specs/todo-app-spec.json --destPath ./src/lib --separatedFiles true</code> </pre> <br><p>  Di <code>destPath</code> akan ada file yang dihasilkan dan, pada kenyataannya, isi <a href="https://github.com/koshevy/codegena/tree/master/libs/todo-app-scheme/src/lib">direktori ini</a> di repositori proyek dibuat dengan cara yang sama.  <a href="">Ini adalah skrip penghasil</a> , dan <a href="">ini adalah bagaimana</a> skrip NPM berjalan.  Namun, jika mau, Anda dapat menggunakannya bahkan di browser, seperti yang dilakukan di <a href="https://codegena-playground.stackblitz.io/">Playground</a> . </p><br><a name="CodegenerationUsingPractice"></a><br><h2 id="praktika-ispolzovanie-kodogeneratora">  Berlatih menggunakan generator kode </h2><br><p>  Selanjutnya, saya ingin berbicara tentang apa yang akan kita dapatkan sebagai hasilnya: apa gagasan tentang bagaimana ini akan membantu kita.  Bantuan visual akan menjadi kode aplikasi demo.  Ini terdiri dari dua bagian: backend (pada kerangka <a href="https://nestjs.com/">NestJS</a> ) dan frontend (pada <a href="https://angular.io/">Angular</a> ).  Jika mau, Anda bahkan dapat <a href="https://github.com/koshevy/codegena/tree/5367749623826d270fb652e32fa394c023751877">menjalankannya secara lokal</a> . </p><br><blockquote>  Bahkan jika Anda tidak terbiasa dengan Angular dan / atau NestJS, ini seharusnya tidak menimbulkan masalah: contoh kode yang akan diberikan harus dipahami oleh sebagian besar pengembang TypeScript. </blockquote><p>  Meskipun aplikasi disederhanakan sebanyak mungkin (misalnya, backend menyimpan data dalam suatu sesi, bukan dalam database), saya mencoba untuk membuat ulang aliran data dan fitur-fitur dari hierarki tipe data yang melekat pada aplikasi sebenarnya.  Sudah sekitar 80-85% siap, tetapi "selesai" bisa ditunda, tetapi untuk saat ini lebih penting untuk berbicara tentang apa yang sudah ada. </p><br><a name="UsingGeneratedDataTypes"></a><br><h2 id="ispolzovanie-generiruemyh-tipov-dannyh-v-prilozheniyah">  Menggunakan tipe data yang dihasilkan dalam aplikasi </h2><br><p>  Misalkan kita memiliki spesifikasi OpenAPI (misalnya, yang <a href="">ini</a> ) yang harus kita kerjakan.  Tidak masalah jika kita membuat sesuatu dari awal, atau kita mendukung, ada hal penting yang kemungkinan besar akan kita mulai dengan - mengetik.  Kami akan mulai menggambarkan tipe data dasar atau membuat perubahan padanya.  Sebagian besar programmer melakukan ini untuk memfasilitasi pengembangan masa depan mereka.  Jadi Anda tidak perlu melihat dokumentasi sekali lagi, perhatikan daftar parameter;  dan Anda dapat yakin bahwa IDE dan / atau kompiler akan melihat kesalahan ketik. </p><br><p>  Spesifikasi kami mungkin atau mungkin tidak termasuk bagian <a href="">components.schems</a> .  Tetapi bagaimanapun, itu akan menggambarkan set parameter, permintaan dan jawaban - dan kita bisa menggunakannya.  Pertimbangkan sebuah contoh: </p><br><pre> <code class="javascript hljs">@Controller(<span class="hljs-string"><span class="hljs-string">'group'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... @Put(':groupId') rewriteGroup( @Param(ParseQueryPipe) { groupId }: RewriteGroupParameters, @Body() body: RewriteGroupRequest, @Session() session ): RewriteGroupResponse&lt;HttpStatus.OK&gt; { return this.appService .setSession(session) .rewriteGroup(groupId, body); } // ... }</span></span></code> </pre> <br><p>  Ini adalah fragmen <a href="">pengontrol</a> untuk kerangka NestJS dengan parameter ( <code>RewriteGroupParameters</code> ), badan permintaan ( <code>RewriteGroupRequest</code> ) dan badan respons ( <code>RewriteGroupResponse&lt;T&gt;</code> ) yang <code>RewriteGroupResponse&lt;T&gt;</code> .  Sudah dalam fragmen kode ini kita bisa melihat manfaat dari mengetik: </p><br><ul><li>  Jika kita mengacaukan nama <code>groupId</code> parameter yang dirusak, menentukan <code>groupId</code> sebagai gantinya, kami segera mendapatkan kesalahan di editor. <br><img src="https://habrastorage.org/webt/1z/2q/0c/1z2q0cstw2lv3vncwmgi8gkxfa0.png"></li><li>  Jika <a href="">metode this.appService.rewriteGroup (groupId, body)</a> telah mengetik parameter, kita dapat mengontrol kebenaran dari parameter <code>body</code> dikirimkan.  Dan jika format data input dari metode controller atau metode layanan berubah, kita akan segera mengetahuinya.  <code>RewriteGroupRequest</code> depan, saya perhatikan bahwa metode input dari metode layanan memiliki tipe data yang berbeda dari <code>RewriteGroupRequest</code> , tetapi dalam kasus kami, mereka akan identik satu sama lain.  Namun, jika tiba-tiba metode layanan diubah, dan mulai menerima <code>ToDoGroup</code> alih-alih <code>ToDoGroupBlank</code> , IDE dan kompiler akan segera menampilkan tempat-tempat perbedaan: <br><img src="https://habrastorage.org/webt/wo/cq/rr/wocqrrks2gtcthaq_wghrhlbbta.png"></li><li>  Dengan cara yang sama, kita dapat mengontrol kepatuhan terhadap hasil yang dikembalikan.  Jika status respons yang sukses tiba-tiba berubah dalam spesifikasi dan menjadi <code>202</code> alih-alih <code>200</code> , kami juga akan mengetahuinya, karena <code>RewriteGroupResponse</code> adalah <a href="">generik dengan tipe yang disebutkan</a> : <br><img src="https://habrastorage.org/webt/pt/io/ss/ptiossjjfhihchrlwdlydrrkft4.png"></li></ul><br><p>  Sekarang mari kita lihat <a href="">contoh dari aplikasi front-end</a> yang bekerja dengan <a href="">metode API lain</a> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initSelectedGroupData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(truth: ComponentTruth)</span></span></span><span class="hljs-function">: Observable&lt;ComponentTruth&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getGroupsService.request(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, { isComplete: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, withItems: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> }).pipe( pickResponseBody&lt;GetGroupsResponse&lt;<span class="hljs-number"><span class="hljs-number">200</span></span>&gt;&gt;(<span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>), switchMap&lt;ToDoGroup[], Observable&lt;ComponentTruth&gt;&gt;( groups =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadItemsOfSelectedGroups({ ...truth, groups }) ) ); }</code> </pre> <br><p>  Mari kita tidak maju sendiri dan mem-parsing operator kustom RxJS <code>pickResponseBody</code> , tetapi mari kita fokus pada penyempurnaan tipe <code>GetGroupsResponse</code> .  Kami menggunakannya dalam rantai operator RxJS, dan operator yang mengikutinya memiliki penyempurnaan input <code>ToDoGroup[]</code> .  Jika kode ini berfungsi, maka tipe data yang ditunjukkan sesuai satu sama lain.  Di sini kami juga dapat mengontrol pencocokan jenis, dan jika format respons di API kami tiba-tiba berubah, ini tidak akan luput dari perhatian kami: </p><br><p><img src="https://habrastorage.org/webt/ci/hr/7c/cihr7csbo5kqn9fqkreoij7kuxk.png"></p><br><p>  Dan tentu saja, parameter panggilan <code>this.getGroupsService.request</code> juga diketik.  Tapi ini adalah topik dari layanan yang dihasilkan. </p><br><blockquote>  Dalam contoh di atas, kita melihat bahwa mengetik permintaan, tanggapan, dan parameter dapat digunakan di berbagai bagian sistem - frontend, backend, dll.  Jika backend dan frontend berada dalam repositori mono yang sama dan memiliki lingkungan yang kompatibel, mereka dapat menggunakan <a href="https://github.com/koshevy/codegena/tree/5367749623826d270fb652e32fa394c023751877/libs/todo-app-scheme">pustaka bersama yang</a> sama dengan kode yang dihasilkan.  Tetapi bahkan jika backend dan frontend didukung oleh tim yang berbeda, dan tidak memiliki kesamaan kecuali spesifikasi OAS publik, masih akan lebih mudah bagi mereka untuk menyinkronkan kode mereka. </blockquote><br><a name="DecompositionInOAS"></a><br><h2 id="dekompoziciya-shem-vnutri-oas-specifikacii">  Dekomposisi sirkuit dalam spesifikasi OAS </h2><br><p>  Mungkin, dalam contoh sebelumnya, Anda memperhatikan <code>ToDoGroup</code> , <code>ToDoGroup</code> , yang <code>RewriteGroupResponse</code> dengan <code>RewriteGroupResponse</code> dan <code>GetGroupsResponse</code> .  Sebenarnya, <code>RewriteGroupResponse</code> hanyalah alias umum untuk <code>ToDoGroup</code> , <code>HttpErrorBadRequest</code> , dll.  Sangat mudah untuk menebak bahwa <a href="">ToDoGroup</a> dan <a href="">HttpErrorBadRequest</a> adalah skema dari <a href="">components.schem</a> spesifikasi yang dirujuk oleh <a href="">titik akhir rewriteGroup</a> (langsung atau melalui <a href="">perantara</a> ): </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"responses"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"200"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Todo group saved"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"content"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"application/json"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"schema"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/ToDoGroup"</span></span> } } } }, <span class="hljs-attr"><span class="hljs-attr">"400"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/responses/errorBadRequest"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"404"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/responses/errorGroupNotFound"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"409"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/responses/errorConflict"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"500"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/responses/errorServer"</span></span> } }</code> </pre><br><p>  Ini adalah dekomposisi struktur data yang biasa, dan prinsipnya sama dengan bahasa pemrograman lain.  Komponen, pada gilirannya, juga dapat didekomposisi: lihat komponen lain (termasuk secara rekursif), gunakan kombinasi dan fitur JSON Schema lainnya.  Tetapi terlepas dari kerumitannya, mereka harus dikonversi dengan benar ke deskripsi tipe data.  Saya ingin menunjukkan bagaimana Anda dapat menggunakan dekomposisi di OpenAPI, dan bagaimana kode yang dihasilkan akan terlihat. </p><br><blockquote>  Komponen dalam spesifikasi OAS yang dirancang dengan baik akan tumpang tindih dengan model DDD dari aplikasi yang menggunakannya.  Tetapi bahkan jika spesifikasinya tidak sempurna, Anda dapat mengandalkannya, membangun model data Anda sendiri.  Ini akan memberi Anda kontrol lebih besar atas korespondensi tipe data Anda dengan tipe data subsistem terintegrasi. </blockquote><p>  Karena aplikasi kita adalah daftar tugas, esensi utama adalah Tugas.  Adalah logis untuk memasukkannya ke dalam komponen di tempat pertama, karena  entitas dan titik akhir lain entah bagaimana akan terhubung dengannya.  Tetapi sebelum itu Anda perlu memahami dua hal: </p><br><ul><li>  Kami menjelaskan tidak hanya abstraksi, tetapi juga aturan validasi, dan semakin akurat dan jelas, semakin baik. </li><li>  Seperti entitas apa pun yang disimpan dalam database, tugas memiliki dua jenis properti: layanan dan yang dimasukkan pengguna. </li></ul><br><p>  Ternyata, tergantung pada skenario penggunaan, kami memiliki dua struktur data: Tugas yang baru saja dibuat pengguna, dan Tugas yang sudah disimpan dalam database.  Dalam kasus kedua, ia memiliki UID unik, tanggal pembuatan, perubahan, dll., Dan data ini harus ditetapkan pada backend.  Saya menggambarkan dua entitas ( <code>ToDoTaskBlank</code> dan <code>ToDoTask</code> ) sedemikian rupa sehingga yang pertama adalah subset dari yang kedua: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"components"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"ToDoTaskBlank"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Base part of data of item in todo's group"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Data about group item needed for creation of it"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"groupUid"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"An unique id of group that item belongs to"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/Uid"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Short brief of task to be done"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"minLength"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"maxLength"</span></span>: <span class="hljs-number"><span class="hljs-number">64</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Detailed description and context of the task. Allowed using of Common Markdown."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: [<span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"null"</span></span>], <span class="hljs-attr"><span class="hljs-attr">"minLength"</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">"maxLength"</span></span>: <span class="hljs-number"><span class="hljs-number">1024</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"isDone"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Status of task: is done or not"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"boolean"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"default"</span></span>: <span class="hljs-string"><span class="hljs-string">"false"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"example"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"position"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Position of a task in group. Allows to track changing of state of a concrete item, including changing od position."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"min"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max"</span></span>: <span class="hljs-number"><span class="hljs-number">4096</span></span>, <span class="hljs-attr"><span class="hljs-attr">"example"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"attachments"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Any material attached to the task: may be screenshots, photos, pdf- or doc- documents on something else"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/AttachmentMeta"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"maxItems"</span></span>: <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-attr"><span class="hljs-attr">"example"</span></span>: [] } }, <span class="hljs-attr"><span class="hljs-attr">"required"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"isDone"</span></span>, <span class="hljs-string"><span class="hljs-string">"title"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"example"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"isDone"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Book soccer field"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"The complainant agreed and recruited more members to play soccer."</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"ToDoTask"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Item in todo's group"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Describe data structure of an item in group of tasks"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"allOf"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/ToDoTaskBlank"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"uid"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"An unique id of task"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/Uid"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"readOnly"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"dateCreated"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Date/time (ISO) when task was created"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"format"</span></span>: <span class="hljs-string"><span class="hljs-string">"date-time"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"readOnly"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"example"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-11-17T11:20:51.555Z"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"dateChanged"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Date/time (ISO) when task was changed last time"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"format"</span></span>: <span class="hljs-string"><span class="hljs-string">"date-time"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"readOnly"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"example"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-11-17T11:20:51.555Z"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"required"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"dateChanged"</span></span>, <span class="hljs-string"><span class="hljs-string">"dateCreated"</span></span>, <span class="hljs-string"><span class="hljs-string">"position"</span></span>, <span class="hljs-string"><span class="hljs-string">"uid"</span></span> ] } ] } }</code> </pre> <br><p>  Pada output, kita mendapatkan dua antarmuka TypeScript, dan yang <a href="">pertama</a> akan diwarisi oleh yang <a href="">kedua</a> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * ## Base part of data of item in todo's group * Data about group item needed for creation of it */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoTaskBlank</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... imagine there are ToDoTaskBlank properties } /** * ## Item in todo's group * Describe data structure of an item in group of tasks */ export interface ToDoTask extends ToDoTaskBlank { /** * ## UID of element * An unique id of task */ readonly uid: string; /** * Date/time (ISO) when task was created */ readonly dateCreated: string; /** * Date/time (ISO) when task was changed last time */ readonly dateChanged: string; // ... imagine there are ToDoTaskBlank properties }</span></span></code> </pre> <br><p>  Sekarang kami memiliki deskripsi dasar entitas Task, dan kami merujuknya <strong>dalam kode aplikasi kami</strong> seperti yang dilakukan dalam <a href="">aplikasi demo</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ToDoTask, ToDoTaskBlank, } from <span class="hljs-string"><span class="hljs-string">'@our-npm-scope/our-generated-lib'</span></span>; export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoTaskTeaser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoTask</span></span></span><span class="hljs-class"> </span></span>{ isInvalid?: <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Means this task just created, has temporary uid * and not saved yet. */</span></span> isJustCreated?: <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Means this task is saving now. */</span></span> isPending?: <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Previous uid of task temporary assigned until * it gets saved and gets new UID from backend. */</span></span> prevTempUid?: string; }</code> </pre> <br><p>  Dalam contoh ini, kami menggambarkan entitas baru, menambah <code>ToDoTask</code> properti-properti yang kami miliki di sisi aplikasi front-end.  Faktanya, kami memperluas model data yang dihasilkan dengan mempertimbangkan kekhasan lokal.  Di sekitar model ini, seperangkat <a href="">alat lokal</a> dan sesuatu seperti DTO primitif secara bertahap tumbuh: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downgradeTeaserToTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> taskTeaser: ToDoTaskTeaser </span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToDoTask</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> task = { ...taskTeaser }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!task.description || !task.description.trim()) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.description; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { task.description = task.description.trim(); } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.isJustCreated; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.isPending; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.prevTempUid; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downgradeTeaserToTaskBlank</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> taskTeaser: ToDoTaskTeaser </span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToDoTaskBlank</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> task = downgradeTeaserToTask(taskTeaser) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> any; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.dateChanged; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.dateCreated; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.uid; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Seseorang lebih suka membuat model data lebih integral dan menggunakan kelas.</b> <div class="spoiler_text"><pre> <code class="java hljs">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoTaskTeaser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoTask</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// … imagine, definitions from ToDoTask are here constructor( task: ToDoTask, public isInvalid?: boolean, public isJustCreated?: boolean, public isPending?: boolean, public prevTempUid?: string ) { Object.assign(this, task); } downgradeTeaserToTask(): ToDoTask { const task = {...this}; if (!task.description || !task.description.trim()) { delete task.description; } else { task.description = task.description.trim(); } delete task.isJustCreated; delete task.isPending; delete task.prevTempUid; return task; } downgradeTeaserToTaskBlank(): ToDoTaskBlank { // … some code } }</span></span></code> </pre> </div></div><br><p>  Tapi ini masalah gaya, kepantasan dan bagaimana arsitektur aplikasi akan berkembang.  Secara umum, terlepas dari pendekatannya, kita dapat mengandalkan model data dasar dan memiliki kontrol lebih besar atas kesesuaian pengetikan.  Jadi, jika karena alasan tertentu, <code>uid</code> dari <code>ToDoTask</code> menjadi angka, kita akan tahu tentang semua bagian dari kode yang perlu diperbarui: </p><br><p><img src="https://habrastorage.org/webt/cc/7g/yz/cc7gyzy0tc4oh5zpomvjy09endw.png"></p><br><a name="NestedDecomposition"></a><br><h2 id="vlozhennaya-dekompoziciya">  Dekomposisi bersarang </h2><br><p>  Jadi sekarang kita memiliki antarmuka <code>ToDoTask</code> dan kita bisa <code>ToDoTask</code> .  Demikian pula, kami akan menjelaskan <a href="">ToDoTaskGroup</a> dan <a href="">ToDoTaskGroupBlank</a> , dan mereka masing-masing berisi properti tipe <code>ToDoTask</code> dan <code>ToDoTaskBlank</code> .  Tapi sekarang kita akan memecah "Kelompok Tugas" menjadi dua, bukan tiga, komponen: untuk kejelasan, kita akan menggambarkan delta di <a href="">ToDoGroupExtendedData</a> .  Jadi saya ingin menunjukkan pendekatan di mana satu komponen dibuat dari dua komponen lainnya: </p><br><pre> <code class="plaintext hljs">"ToDoGroup": { "allOf": [ { "$ref": "#/components/schemas/ToDoGroupBlank" }, { "$ref": "#/components/schemas/ToDoGroupExtendedData" } ] }</code> </pre> <br><p>  Setelah memulai pembuatan kode, kami mendapatkan konstruksi TypeScript yang sedikit berbeda: </p><br><pre> <code class="java hljs">export type ToDoGroup = ToDoGroupBlank &amp; <span class="hljs-comment"><span class="hljs-comment">// Data needed for group creation ToDoGroupExtendedData; // Extended data has to be obtained after first save</span></span></code> </pre> <br><p>  Karena <code>ToDoGroup</code> tidak memiliki "tubuh" sendiri, pembuat kode lebih suka mengubahnya menjadi gabungan antarmuka.  Namun, jika Anda menambahkan bagian ketiga dengan skema Anda sendiri (anonim), hasilnya akan menjadi antarmuka dengan dua leluhur (tetapi lebih baik tidak melakukannya).  Dan mari kita perhatikan bahwa properti <code>items</code> dari antarmuka <code>ToDoGroupBlank</code> diketik sebagai array dari <code>ToDoTaskBlank</code> , dan didefinisikan ulang di <code>ToDoGroupBlank</code> di <code>ToDoTask</code> .  Dengan demikian, pembuat kode dapat mentransfer nuansa dekomposisi yang agak rumit dari Skema JSON ke TypeScipt. </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* tslint:disable */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ToDoTaskBlank } from <span class="hljs-string"><span class="hljs-string">'./to-do-task-blank'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * ## Base part of data of group * Data needed for group creation */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoGroupBlank</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... items?: Array&lt;ToDoTaskBlank&gt;; // ... }</span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* tslint:disable */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ToDoTask } from <span class="hljs-string"><span class="hljs-string">'./to-do-task'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * ## Extended data of group * Extended data has to be obtained after first save */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoGroupExtendedData</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... items: Array&lt;ToDoTask&gt;; }</span></span></code> </pre><br><p>  Baik dan tentu saja, di <code>ToDoTask</code> / <code>ToDoTaskBlank</code> kita juga dapat menggunakan dekomposisi.  Anda mungkin telah memperhatikan bahwa properti <code>attachments</code> dijelaskan sebagai array elemen bertipe <a href="">AttachmentMeta</a> .  Dan komponen ini dijelaskan sebagai berikut: </p><br><pre> <code class="java hljs"><span class="hljs-string"><span class="hljs-string">"AttachmentMeta"</span></span>: { <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Common meta data model of any type of attachment"</span></span>, <span class="hljs-string"><span class="hljs-string">"oneOf"</span></span>: [ {<span class="hljs-string"><span class="hljs-string">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/AttachmentMetaImage"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/AttachmentMetaDocument"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/ExternalResource"</span></span>} ] }</code> </pre> <br><p>  Artinya, komponen ini mengacu pada komponen lain.  Karena tidak memiliki skema sendiri, pembuat kode tidak membuatnya menjadi tipe data terpisah agar tidak menggandakan entitas, tetapi mengubah deskripsi anonim dari tipe yang disebutkan: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Any material attached to the task: may be screenshots, photos, pdf- or doc- * documents on something else */</span></span> attachments?: Array&lt; | AttachmentMetaImage <span class="hljs-comment"><span class="hljs-comment">// Meta data of image attached to task | AttachmentMetaDocument // Meta data of document attached to task | string // Link to any external resource &gt;;</span></span></code> </pre> <br><p>  Pada saat yang sama, untuk komponen <code>AttachmentMetaDocument</code> dan <code>AttachmentMetaDocument</code> , antarmuka non-anonim dijelaskan yang diimpor dalam file yang menggunakannya: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { AttachmentMetaDocument } from <span class="hljs-string"><span class="hljs-string">'./attachment-meta-document'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { AttachmentMetaImage } from <span class="hljs-string"><span class="hljs-string">'./attachment-meta-image'</span></span>;</code> </pre> <br><p>  Tetapi bahkan di <a href="">AttachmentMetaImage,</a> kita dapat menemukan tautan ke antarmuka <a href="">ImageOptions yang</a> dirender lain, yang digunakan dua kali, termasuk di dalam antarmuka anonim (hasil konversi dari properti <a href="">tambahan</a> ): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* tslint:disable */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ImageOptions } from <span class="hljs-string"><span class="hljs-string">'./image-options'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Meta data of image attached to task */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttachmentMetaImage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... /** * Possible thumbnails of uploaded image */ thumbs?: { [key: string]: { /** * Link to any external resource */ url?: string; imageOptions?: ImageOptions; }; }; // ... imageOptions: ImageOptions; }</span></span></code> </pre> <br><p>  Dengan demikian, berdasarkan pada <code>ToDoGroup</code> atau <code>ToDoGroup</code> , kami benar-benar mengintegrasikan beberapa entitas ke dalam kode dan rangkaian koneksi bisnis mereka, yang memberi kami kontrol lebih besar atas perubahan dalam sistem berlebih yang melampaui kode kami.  Tentu saja, ini tidak masuk akal dalam semua kasus.  Tetapi jika Anda menggunakan OpenAPI, maka Anda mungkin memiliki satu bonus kecil lagi, di samping dokumentasi yang sebenarnya. </p><br><a name="ServiceGeneration"></a><br><h2 id="avtogeneraciya-servisov-dlya-raboty-s-rest-api">  Layanan yang dibuat secara otomatis untuk bekerja dengan REST API </h2><br><a name="WhyItNeccessary"></a><br><h3 id="zachem-eto-nuzhno">  Mengapa ini dibutuhkan? </h3><br><p>  Jika kami mengambil aplikasi front-end statistik rata-rata yang berfungsi dengan REST API yang kurang lebih kompleks, maka sebagian besar kodenya adalah layanan (atau hanya fungsi) untuk mengakses API.  Mereka akan mencakup: </p><br><ul><li>  Pemetaan URL dan Parameter </li><li>  Validasi parameter, permintaan, dan respons </li><li>  Ekstraksi Data dan Penanganan Darurat </li></ul><br><p>  Tidak menyenangkan bahwa dalam banyak hal ini tipikal dan tidak mengandung logika unik.  Mari kita anggap beberapa contoh - sebagai garis besar umum, pekerjaan dengan API dapat dibangun: </p><br><div class="spoiler">  <b class="spoiler_title">Contoh skematis yang disederhanakan untuk bekerja dengan REST API</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lodash'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable, fromFetch, throwError } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { switchMap } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Definitions const URLS = { 'getTasksOfGroup': `${env.REST_API_BASE_URL}/tasks/\${groupId}`, // ... other urls ... }; const URL_TEMPLATES = _.mapValues(urls, url =&gt; _.template(url)); interface GetTaskConditions { isDone?: true | false; offset?: number; limit?: number; } interface ErrorReponse { error: boolean; message?: string; } // Helpers // I taken this snippet from StackOverflow only for example function encodeData(data) { return Object.keys(data).map(function(key) { return [key, data[key]].map(encodeURIComponent).join("="); }).join("&amp;"); } // REST API functions // our REST API working function example function getTasksFromServer(groupUid: string, conditions: GetTaskConditions = {}): Observable&lt;Response&gt; { if (!groupUid) { return throwError(new Error('You should specify "groupUid"!')); } if (!_.isString(groupUid)) { return throwError(new Error('`groupUid` should be string!')); } if (_.isBoolean(conditions.isDone)) { // ... applying of conditions.isDone } else if (conditions.isDone !== undefined) { return throwError(new Error('`isDone` should be "true", "false" or should\'t be set!'!)); } if (offset) { // ... check of `offset` and applying or error throwing } if (limit) { // ... check of `limit` and applying or error throwing } const url = [ URL_TEMPLATES['getTasksOfGroup']({groupUid}), ...(conditions ? [encodeData(conditions)] : []) ]; return fromFetch(url); } // Using of REST API working functions function getRemainedTasks(groupUid: number): Observable&lt;ToDoTask[] | ErrorReponse&gt; { return getTasksFromServer(groupUid, {isDone: false}).pipe( switchMap(response =&gt; { if (response.ok) { // OK return data return response.json(); } else { // Server is returning a status requiring the client to try something else. return of({ error: true, message: `Error ${response.status}` }); } }), catchError(err =&gt; { // Network or other error, handle appropriately console.error(err); return of({ error: true, message: err.message }) }) ); }</span></span></code> </pre> </div></div><br><p>  Anda dapat menggunakan abstraksi tingkat tinggi untuk bekerja dengan REST - tergantung pada tumpukan yang digunakan, dapat berupa: <a href="https://github.com/axios/axios">Axios</a> , <a href="http">Angular HttpClient</a> , atau solusi serupa lainnya.  Tetapi kemungkinan besar, pada dasarnya kode Anda akan bertepatan dengan contoh ini.  Hampir pasti, itu akan mencakup: </p><br><ul><li>  Layanan atau fungsi untuk mengakses titik akhir spesifik (fungsi <code>getTasksFromServer</code> dalam contoh kami) </li><li>  Potongan kode yang memproses hasilnya (fungsi <code>getRemainedTasks</code> ) </li></ul><br><p>  Dalam aplikasi dari dunia nyata, kode ini akan lebih rumit: spesifikasi aplikasi demo <a href="">menjelaskan 5-6 opsi jawaban</a> .  Seringkali, REST API dirancang sedemikian rupa sehingga setiap status respons dari server harus ditangani sesuai.  Tetapi bahkan memeriksa data input cenderung menjadi lebih sulit selama pengembangan aplikasi: semakin banyak waktu yang dibutuhkan untuk mendukung dan memproses ulasan kesalahan, semakin Anda ingin tahu tentang kemacetan dalam sirkulasi data dalam aplikasi. </p><br><blockquote>  Kesalahan dapat terjadi pada setiap titik dok dari bagian perangkat lunak, pendeteksian yang tidak tepat waktu (serta pencarian masalah yang sulit didiagnosis) bisa sangat mahal untuk bisnis.  Karena itu, akan ada pemeriksaan klarifikasi tambahan.  Sebagai basis kode tumbuh, dan jumlah kasus tertutup, demikian juga kompleksitas membuat perubahan.  Tetapi bisnis adalah perubahan yang konstan, dan tidak ada jalan keluarnya.  Karena itu, kita harus peduli tentang bagaimana kita akan membuat perubahan sebelumnya. </blockquote><p>  Kembali ke topik OpenAPI, kami mencatat bahwa dalam spesifikasi OAS mungkin ada informasi yang cukup untuk: </p><br><ul><li>    -      </li><li>       </li><li>   URL      </li><li>         </li></ul><br><p>         — <strong></strong> .    ,     ,     /  — 5, 10  200,            .  ,      ,   : , , , RxJS- <a href="">pickResponseBody</a> ,            ,     - ;  <a href="">tapResponse</a> ,    side-effect (tap)   HTTP-.     ,     -   .    ,       ,    . </p><br><blockquote> ,     —   -,      .      ,       ,  ,   ""  /     API     "-"  "" .    -   ,        "" (    ),     . </blockquote><p>   ,          REST API   Angular.         ,      ,        /.      . ,      ,    .  ,      , ..      . </p><br><a name="HowToGenerateServices"></a><br><h3 id="generaciya-servisov">   </h3><br><p>   " <a href="https://habr.com/ru/post/483628/">  </a> "      .   Angular-,       <code>update-typings.js</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cliLib = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@codegena/oapi3ts-cli'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cliApp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cliLib.CliApplication; cliApp.createTypings(); cliApp.createServices(<span class="hljs-string"><span class="hljs-string">'angular'</span></span>);</code> </pre> <br><p>             ,   Angular-    API   .    , -   - ,     <a href="https://github.com/koshevy/codegena/tree/master/libs/todo-app-scheme/src/lib/services"> </a> .     ,    <a href="">RewriteGroupService</a> .    <a href="">ApiService</a> ,        ,   ,   -: </p><br><div class="spoiler"> <b class="spoiler_title">-  </b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Typings for this API method import { RewriteGroupParameters, RewriteGroupResponse, RewriteGroupRequest } from '../typings'; // Schemas import { schema as domainSchema } from './schema.b4c655ec1635af1be28bd6'; /** * Service for angular based on ApiAgent solution. * Provides assured request to API method with implicit * validation and common errors handling scheme. */ @Injectable() export class RewriteGroupService extends ApiService&lt; RewriteGroupResponse, RewriteGroupRequest, RewriteGroupParameters &gt; { protected get method(): 'PUT' { return 'PUT'; } /** * Path template, example: `/some/path/{id}`. */ protected get pathTemplate(): string { return '/group/{groupId}'; } /** * Parameters in a query. */ protected get queryParams(): string[] { return ['forceSave']; } // ... }</span></span></code> </pre> </div></div><br><p> , <a href="">   JSON Schema</a>  ,   .    <a href=""> </a> ,        ,       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { schema as domainSchema } from <span class="hljs-string"><span class="hljs-string">'./schema.b4c655ec1635af1be28bd6'</span></span>;</code> </pre> <br><blockquote> ,     <code>schema.b4c655ec1635af1be28bd6.ts</code>       ,  <a href="">  </a>  ,  . </blockquote><br><a name="UsingOfGeneratedServices"></a><br><h3 id="ispolzovanie-generiruemyh-servisov">    </h3><br><p>       ,   Angular-. </p><br><div class="spoiler"> <b class="spoiler_title">    Angular-</b> <div class="spoiler_text"><p>      <code>ApiModule</code>       : </p><br><pre> <code class="plaintext hljs">import { ApiModule, API_ERROR_HANDLER } from '@codegena/ng-api-service'; import { CreateGroupItemService, GetGroupsService, GetGroupItemsService, UpdateFewItemsService } from '@codegena/todo-app-scheme'; @NgModule({ imports: [ ApiModule, // ... ], providers: [ RewriteGroupService, { provide: API_ERROR_HANDLER, useClass: ApiErrorHandlerService }, // ... ], // ... }) export class TodoAppModule { }</code> </pre> </div></div><br><p>    ,     [])( <a href="https://angular.io/guide/dependency-injection">https://angular.io/guide/dependency-injection</a> ): </p><br><pre> <code class="plaintext hljs">@Injectable() export class TodoTasksStore { constructor( protected createGroupItemService: CreateGroupItemService, protected getGroupsService: GetGroupsService, protected getGroupItemsService: GetGroupItemsService, protected updateFewItemsService: UpdateFewItemsService ) {} }</code> </pre> <br><p>         —  ,       <a href="">request</a> ,        : </p><br><pre> <code class="plaintext hljs">return this.getGroupsService.request(null, { isComplete: null, withItems: false }).pipe( pickResponseBody&lt;GetGroupsResponse&lt;200&gt;&gt;(200, null, true), switchMap&lt;ToDoGroup[], Observable&lt;ComponentTruth&gt;&gt;( groups =&gt; this.loadItemsOfSelectedGroups({ ...truth, groups }) ) );</code> </pre> <br><p>  <code>request</code>   <code>Observable&lt;HttpResponse&lt;R&gt; | HttpEvent&lt;R&gt;&gt;</code> ,   ,        . ,     ,      . ,  ,      ,     .     RxJS- <code>pickResponseBody</code> . </p><br><p>  ,    ,    ,   .         API,    .        .   ,     : </p><br><p><img src="https://habrastorage.org/webt/3y/xe/dy/3yxedy51z7su99butzrk2dvunnq.png"></p><br><p>      .   JSON Schema     .       ,   ""      - .   ,      <a href="https://sentry.io/welcome/">Sentry</a>  <a href="https://www.elastic.co/products/kibana">Kibana</a> ,   .       .  ,      ,      . </p><br><blockquote>  ,             .  ,      :) </blockquote><br><a name="AfterWord"></a><br><h2 id="vmesto-poslesloviya">  Alih-alih kata penutup </h2><br><p>   ,       .       -,   "    "    —   .  ,  ,   ,   . </p><br><p>     —    ,  - /    (   ).      ,  —   . </p><br><p>   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483628/">https://habr.com/ru/post/id483628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483612/index.html">Pengemudi Tesla didenda karena menyikat giginya saat mengemudi dengan autopilot</a></li>
<li><a href="../id483614/index.html">Metode memerangi pencurian di klub robotika</a></li>
<li><a href="../id483616/index.html">Proyek Lacmus: Bagaimana Visi Komputer Membantu Menyelamatkan Orang yang Hilang</a></li>
<li><a href="../id483624/index.html">Persaingan dari Yandex.Taxi: analisis trek backend kejuaraan pemrograman</a></li>
<li><a href="../id483626/index.html">Cara menggambarkan pekerjaan 100 gitlab dalam 100 baris di Jsonnet</a></li>
<li><a href="../id483630/index.html">The Ember Times - Edisi 130</a></li>
<li><a href="../id483634/index.html">Min dan Max lebar / properti tinggi di CSS</a></li>
<li><a href="../id483646/index.html">Retas Kotak - Panduan Bitlab. Lemahnya kebingungan JS, GIT dan membalikkan aplikasi Windows</a></li>
<li><a href="../id483648/index.html">Lepas Pantai untuk IT-bisnis di Georgia: peretasan dan perangkap kehidupan</a></li>
<li><a href="../id483650/index.html">Kosmodrom lebih dekat ke khatulistiwa - Wenchang Tropical Cosmodrome</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>