<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🏫 🏧 🕋 Bersihkan arsitektur cepat sebagai alternatif untuk VIPER 🗡️ 🍾 🎸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Saat ini, ada banyak artikel tentang VIPER - arsitektur bersih, berbagai variasi yang pada satu waktu menjadi populer untuk proyek iOS. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bersihkan arsitektur cepat sebagai alternatif untuk VIPER</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415725/"><h3>  Pendahuluan </h3><br>  Saat ini, ada banyak artikel tentang VIPER - arsitektur bersih, berbagai variasi yang pada satu waktu menjadi populer untuk proyek iOS.  Jika Anda tidak terbiasa dengan Viper, Anda dapat membacanya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> atau di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Saya ingin berbicara tentang alternatif VIPER - Clean Swift.  Clean Swift pada pandangan pertama tampak seperti VIPER, namun, perbedaannya menjadi terlihat setelah mempelajari prinsip interaksi antar modul.  Dalam VIPER, interaksi didasarkan pada Presenter, itu mentransfer permintaan pengguna ke Interactor untuk memproses dan memformat data yang diterima darinya kembali untuk ditampilkan pada View Controller: <br><br><img src="https://habrastorage.org/webt/au/kr/v_/aukrv_2zvl2ikjare8odlwup--k.png" alt="gambar"><br><a name="habracut"></a><br>  Di Clean Swift, modul utama, seperti di VIPER, adalah View Controller, Interactor, Presenter. <br><br><img src="https://habrastorage.org/webt/ll/ud/y0/lludy0ydjgy6domer_ayleohrp4.png" alt="gambar"><br><br>  Interaksi di antara mereka terjadi dalam siklus.  Transfer data didasarkan pada protokol (sekali lagi, mirip dengan VIPER), yang memungkinkan untuk perubahan di masa depan di salah satu komponen sistem untuk hanya menggantinya dengan yang lain.  Proses interaksi secara umum terlihat seperti ini: pengguna mengklik tombol, View Controller membuat objek dengan deskripsi dan mengirimkannya ke Interactor.  Interactor, pada gilirannya, mengimplementasikan skenario spesifik sesuai dengan logika bisnis, menciptakan objek hasil dan meneruskannya ke Presenter.  Presenter membentuk objek dengan data yang diformat untuk ditampilkan kepada pengguna dan mengirimkannya ke View Controller.  Mari kita lihat lebih dekat setiap modul Clean Swift secara lebih rinci. <br><br><h3>  Lihat (Lihat Pengontrol) </h3><br>  View Controller, seperti pada VIPER, melakukan semua konfigurasi VIew, baik itu pengaturan warna, UILabel atau Layout font.  Oleh karena itu, setiap UIViewController dalam arsitektur ini mengimplementasikan protokol input untuk menampilkan data atau menanggapi tindakan pengguna. <br><br><h3>  Interactractor </h3><br>  Interactor berisi semua logika bisnis.  Ini menerima tindakan pengguna dari controller, dengan parameter (misalnya, teks yang berubah dari bidang input, menekan tombol) yang didefinisikan dalam protokol Input.  Setelah mengerjakan logika, Interactor, jika perlu, harus mentransfer data untuk persiapannya ke Presenter sebelum menampilkannya di ViewController.  Namun, Interactor hanya menerima permintaan dari View sebagai input, tidak seperti VIPER, di mana permintaan ini melalui Presenter. <br><br><h3>  Presenter </h3><br>  Presenter memproses data untuk ditampilkan kepada pengguna.  Hasilnya dalam kasus ini adalah protokol Input ViewController's, di sini Anda dapat, misalnya, mengubah format teks, menerjemahkan nilai warna dari enum ke rgb, dll. <br><br><h3>  Pekerja </h3><br>  Agar tidak mempersulit Interactor dan tidak menggandakan detail logika bisnis, Anda dapat menggunakan elemen Pekerja tambahan.  Dalam modul sederhana, itu tidak selalu diperlukan, tetapi dalam modul yang cukup dimuat memungkinkan Anda untuk menghapus beberapa tugas dari Interactor.  Sebagai contoh, logika interaksi dengan database dapat dibuat pada pekerja, terutama jika query database yang sama dapat digunakan dalam modul yang berbeda. <br><br><h3>  Router </h3><br>  Router bertanggung jawab untuk mentransfer data ke modul lain dan transisi di antara mereka.  Dia memiliki tautan ke pengontrol, karena di iOS, sayangnya, pengontrol, antara lain, secara historis bertanggung jawab atas transisi.  Menggunakan segue dapat menyederhanakan inisialisasi transisi dengan memanggil metode Router dari Bersiap untuk segue, karena Router tahu cara mentransfer data, dan akan melakukannya tanpa kode loop tambahan dari Interactor / Presenter.  Data ditransfer menggunakan protokol data warehouse dari setiap modul yang diimplementasikan dalam Interactor.  Protokol-protokol ini juga membatasi kemampuan untuk mengakses data modul internal dari Router. <br><br><h3>  Model </h3><br>  Model adalah deskripsi struktur data untuk mentransfer data antar modul.  Setiap implementasi fungsi logika bisnis memiliki deskripsi modelnya sendiri. <br><br><ul><li>  Permintaan - untuk mengirim permintaan dari controller ke interaktor. </li><li>  Respons - respons interaksor untuk mengirimkan ke presenter dengan data. </li><li>  ViewModel - untuk transfer data dalam bentuk yang siap ditampilkan di controller. </li></ul><br><h3>  Contoh implementasi </h3><br>  Mari kita lihat lebih dekat arsitektur ini menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> sederhana.  Mereka akan dilayani oleh aplikasi ContactsBook secara sederhana, tetapi cukup memadai untuk memahami esensi dari bentuk arsitektur.  Aplikasi ini mencakup daftar kontak, serta menambah dan mengedit kontak. <br><br>  Contoh protokol input: <br><br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListDisplayLogic</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(viewModel: ContactList.ShowContacts.ViewModel)</span></span></span></span> }</code> </pre> <br>  Setiap pengontrol berisi referensi ke objek yang mengimplementasikan protokol input Interactor <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interactor: <span class="hljs-type"><span class="hljs-type">ContactListBusinessLogic?</span></span></code> </pre> <br>  juga ke objek Router, yang harus menerapkan logika transfer data dan pengalihan modul: <br><br><pre> <code class="hljs objectivec">var router: (<span class="hljs-built_in"><span class="hljs-built_in">NSObjectProtocol</span></span> &amp; ContactListRoutingLogic &amp; ContactListDataPassing)?</code> </pre> <br>  Anda dapat menerapkan konfigurasi modul dalam metode pribadi yang terpisah: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewController = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> interactor = <span class="hljs-type"><span class="hljs-type">ContactListInteractor</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> presenter = <span class="hljs-type"><span class="hljs-type">ContactListPresenter</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> router = <span class="hljs-type"><span class="hljs-type">ContactListRouter</span></span>() viewController.interactor = interactor viewController.router = router interactor.presenter = presenter presenter.viewController = viewController router.viewController = viewController router.dataStore = interactor }</code> </pre> <br>  atau buat singleton Configurator untuk menghapus kode ini dari controller (bagi mereka yang percaya bahwa controller tidak boleh terlibat dalam konfigurasi) dan tidak menggoda diri mereka sendiri dengan akses ke bagian-bagian modul di controller.  Tidak ada kelas konfigurator dalam pandangan Paman Bob dan dalam VIPER klasik.  Menggunakan konfigurator untuk modul add contact terlihat seperti ini: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">awakeFromNib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.awakeFromNib() <span class="hljs-type"><span class="hljs-type">AddContactConfigurator</span></span>.sharedInstance.configure(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) }</code> </pre> <br>  Kode konfigurator berisi satu-satunya metode konfigurasi yang benar-benar identik dengan metode pengaturan di controller: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddContactConfigurator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sharedInstance = <span class="hljs-type"><span class="hljs-type">AddContactConfigurator</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> control: AddContactViewController)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewController = control <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> interactor = <span class="hljs-type"><span class="hljs-type">AddContactInteractor</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> presenter = <span class="hljs-type"><span class="hljs-type">AddContactPresenter</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> router = <span class="hljs-type"><span class="hljs-type">AddContactRouter</span></span>() viewController.interactor = interactor viewController.router = router interactor.presenter = presenter presenter.viewController = viewController router.viewController = viewController router.dataStore = interactor } }</code> </pre> <br>  Poin lain yang sangat penting dalam implementasi controller adalah kode dalam standar mempersiapkan metode segue: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> scene = segue.identifier { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> selector = <span class="hljs-type"><span class="hljs-type">NSSelectorFromString</span></span>(<span class="hljs-string"><span class="hljs-string">"routeTo\(scene)WithSegue:"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> router = router, router.responds(to: selector) { router.perform(selector, with: segue) } } }</code> </pre> <br>  Pembaca yang penuh perhatian kemungkinan besar memperhatikan bahwa Router juga diperlukan untuk mengimplementasikan NSObjectProtocol.  Ini dilakukan agar kita dapat menggunakan metode standar protokol ini untuk perutean saat menggunakan segues.  Untuk mendukung pengalihan sederhana ini, penamaan pengidentifikasi segue harus cocok dengan akhir nama metode Router.  Misalnya, untuk melihat kontak, ada segue, yang terkait dengan pilihan sel dengan kontak.  Pengenalnya adalah "ViewContact", berikut adalah metode yang sesuai di Router: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">routeToViewContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(segue: UIStoryboardSegue?)</span></span></span></span></code> </pre> <br>  Permintaan untuk menampilkan data ke Interactor juga terlihat sangat sederhana: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> func fetchContacts() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> = ContactList.ShowContacts.<span class="hljs-built_in"><span class="hljs-built_in">Request</span></span>() interactor?.showContacts(<span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>) }</code> </pre> <br>  Mari kita beralih ke Interactor.  Interactor mengimplementasikan protokol ContactListDataStore, yang bertanggung jawab untuk menyimpan / mengakses data.  Dalam kasus kami, ini hanya sebuah array kontak, yang hanya dibatasi oleh metode pengambil, untuk menunjukkan kepada router bahwa tidak dapat diubahnya dari modul lain.  Protokol yang menerapkan logika bisnis untuk daftar kami adalah sebagai berikut: <br><br><pre> <code class="hljs vbscript">func showContacts(<span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: ContactList.ShowContacts.<span class="hljs-built_in"><span class="hljs-built_in">Request</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contacts = worker.getContacts() self.contacts = contacts <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">response</span></span> = ContactList.ShowContacts.<span class="hljs-built_in"><span class="hljs-built_in">Response</span></span>(contacts: contacts) presenter?.presentContacts(<span class="hljs-built_in"><span class="hljs-built_in">response</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">response</span></span>) }</code> </pre> <br>  Ini menerima data kontak dari ContactListWorker.  Dalam hal ini, Pekerja bertanggung jawab atas bagaimana data diunduh.  Ia dapat beralih ke layanan pihak ketiga yang memutuskan, misalnya, untuk mengambil data dari cache atau mengunduh dari jaringan.  Setelah menerima data, Interactor mengirimkan Respons ke Presenter untuk mempersiapkan tampilan, karena Interactor ini berisi tautan ke Presenter: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presenter: <span class="hljs-type"><span class="hljs-type">ContactListPresentationLogic?</span></span></code> </pre> <br>  Presenter mengimplementasikan hanya satu protokol - ContactListPresentationLogic, dalam kasus kami, itu hanya secara paksa mengubah kasus nama depan dan belakang kontak, membentuk model presentasi DisplayedContact dari model data dan meneruskannya ke Controller untuk ditampilkan: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">presentContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response: ContactList.ShowContacts.Response)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mapped = response.contacts.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { <span class="hljs-type"><span class="hljs-type">ContactList</span></span> .<span class="hljs-type"><span class="hljs-type">ShowContacts</span></span> .<span class="hljs-type"><span class="hljs-type">ViewModel</span></span> .<span class="hljs-type"><span class="hljs-type">DisplayedContact</span></span>(firstName: $<span class="hljs-number"><span class="hljs-number">0</span></span>.firstName.uppercaseFirst, lastName: $<span class="hljs-number"><span class="hljs-number">0</span></span>.lastName.uppercaseFirst) } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewModel = <span class="hljs-type"><span class="hljs-type">ContactList</span></span>.<span class="hljs-type"><span class="hljs-type">ShowContacts</span></span>.<span class="hljs-type"><span class="hljs-type">ViewModel</span></span>(displayedContacts: mapped) viewController?.displayContacts(viewModel: viewModel) }</code> </pre> <br>  Setelah itu, siklus berakhir dan pengontrol menampilkan data, menerapkan metode protokol ContactListDisplayLogic: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(viewModel: ContactList.ShowContacts.ViewModel)</span></span></span></span> { displayedContacts = viewModel.displayedContacts tableView.reloadData() }</code> </pre> <br>  Ini adalah bagaimana model untuk menampilkan kontak terlihat seperti: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShowContacts</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contacts: [<span class="hljs-type"><span class="hljs-type">Contact</span></span>] } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DisplayedContact</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstName: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastName: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fullName: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstName + <span class="hljs-string"><span class="hljs-string">" "</span></span> + lastName } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> displayedContacts: [<span class="hljs-type"><span class="hljs-type">DisplayedContact</span></span>] } }</code> </pre> <br>  Dalam hal ini, permintaan tidak mengandung data, karena ini hanya daftar kontak umum, namun, jika, misalnya, layar daftar berisi filter, tipe filter dapat dimasukkan dalam permintaan ini.  Model respons Intrecator berisi daftar kontak yang diinginkan, ViewModel juga berisi berbagai data yang siap untuk ditampilkan - DisplayedContact. <br><br><h3>  Mengapa Bersihkan Swift </h3><br>  Pertimbangkan pro dan kontra dari arsitektur ini.  Pertama, Bersihkan Swift memiliki templat kode yang mempermudah pembuatan modul.  Template ini dapat ditulis untuk banyak arsitektur, tetapi ketika mereka berada di luar kotak - setidaknya menghemat beberapa jam dari waktu Anda. <br><br>  Kedua, arsitektur ini, seperti VIPER, telah diuji dengan baik, contoh-contoh tes tersedia di proyek.  Karena modul tempat interaksi terjadi mudah untuk diganti dengan rintisan, menentukan fungsionalitas setiap modul menggunakan protokol memungkinkan Anda untuk mengimplementasikannya tanpa sakit kepala.  Jika kita secara bersamaan membuat logika bisnis dan tes yang sesuai (Interactor, Interactor tests), ini cocok dengan prinsip TDD.  Karena fakta bahwa output dan input dari setiap kasus logika didefinisikan oleh protokol, cukup hanya menulis tes pertama yang menentukan perilakunya, dan kemudian langsung menerapkan metode logika. <br><br>  Ketiga, Clean Swift (tidak seperti VIPER) mengimplementasikan aliran searah pemrosesan data dan pengambilan keputusan.  Hanya satu siklus yang selalu dijalankan - View - Interactor - Presenter - View, yang juga menyederhanakan refactoring, karena seringkali diperlukan untuk mengubah lebih sedikit entitas.  Karena itu, proyek-proyek dengan logika yang sering berubah atau ditambah lebih mudah untuk refactor menggunakan metodologi Clean Swift.  Menggunakan Clean Swift, Anda memisahkan entitas dengan dua cara: <br><br><ol><li>  Mengisolasi komponen dengan mendeklarasikan protokol Input dan Output </li><li>  Mengisolasi fitur dengan menggunakan struktur dan merangkum data dalam permintaan / tanggapan / model UI yang terpisah.  Setiap fitur memiliki logikanya sendiri dan dikendalikan dalam kerangka satu proses, tanpa berpotongan dalam satu modul dengan fitur lainnya. </li></ol><br>  Clean Swift tidak boleh digunakan dalam proyek kecil tanpa perspektif jangka panjang, dalam proyek prototipe.  Misalnya, terlalu mahal untuk mengimplementasikan aplikasi untuk jadwal konferensi pengembang menggunakan arsitektur ini.  Proyek jangka panjang, proyek dengan banyak logika bisnis, sebaliknya, sangat cocok dengan kerangka arsitektur ini.  Sangat mudah untuk menggunakan Clean Swift ketika proyek diimplementasikan untuk dua platform - Mac OS dan iOS, atau direncanakan untuk port di masa depan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415725/">https://habr.com/ru/post/id415725/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415713/index.html">Pemrograman PHP Berorientasi Aspek</a></li>
<li><a href="../id415715/index.html">Kisah keruntuhan dan penyelamatan mukjizat cetakan dalam KOMPAS-3D</a></li>
<li><a href="../id415717/index.html">Bisakah saya membuat senjata ringan untuk layar LCD? Kickstarter sudah mengumpulkan uang</a></li>
<li><a href="../id415721/index.html">Mengapa prosesor unggulan membutuhkan memori teratas? Menguji Kit HyperX Fury DDR4-3466</a></li>
<li><a href="../id415723/index.html">Dari desainer ke departemen QA, atau apakah ada kehidupan setelah pabrik</a></li>
<li><a href="../id415727/index.html">Tenggelam dalam dinamika basis klien: analisis kohort dan analisis aliran</a></li>
<li><a href="../id415729/index.html">Beberapa statistik - pengembang Ubuntu pertama kali menerbitkan telemetri desktop</a></li>
<li><a href="../id415731/index.html">Tinjau Xiaomi Redmi Note 5 - phablet anggaran menengah dengan klaim keaslian</a></li>
<li><a href="../id415733/index.html">Informasi: Roskomsvoboda dan sejarahnya</a></li>
<li><a href="../id415735/index.html">Perangkat keras menyandikan aliran video pada kamera Logitech C920 dan mengirimkannya ke ROS melalui wifi dengan penundaan kurang dari 0,2 detik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>