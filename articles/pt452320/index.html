<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÆ üì™ üÜì MVCC-6. Limpeza üôÜüèΩ ü§≤ üññüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Come√ßamos com problemas relacionados ao isolamento , fizemos uma digress√£o sobre a organiza√ß√£o de dados em um n√≠vel baixo e conversamos detalhadamente...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-6. Limpeza</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452320/">  Come√ßamos com problemas relacionados ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">isolamento</a> , fizemos uma digress√£o sobre a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">organiza√ß√£o de dados em um n√≠vel baixo</a> e conversamos detalhadamente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sobre as vers√µes de linha</a> e como os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instant√¢neos</a> s√£o obtidos a partir das vers√µes. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Na √∫ltima vez em</a> que conversamos sobre atualiza√ß√µes HOT e limpeza na p√°gina, hoje veremos o conhecido vulgar de limpeza comum a <em>v√°cuo</em> .  Sim, j√° foi escrito tanto sobre ela que √© improv√°vel que eu diga algo novo, mas a integridade da imagem exige sacrif√≠cio.  Seja paciente. <br><br><h1>  Limpeza normal (v√°cuo) </h1><br><h2>  O que a limpeza faz </h2><br>  A limpeza dentro da p√°gina √© r√°pida, mas libera apenas uma fra√ß√£o do espa√ßo.  Ele funciona na mesma p√°gina tabular e n√£o afeta os √≠ndices. <br><br>  A principal limpeza "normal" √© realizada pelo comando VACUUM e a chamaremos de limpeza simples (e falaremos sobre limpeza autom√°tica separadamente). <br><br>  Portanto, a limpeza processa a tabela completamente.  Ele limpa n√£o apenas vers√µes desnecess√°rias de strings, mas tamb√©m refer√™ncias a eles de todos os √≠ndices. <br><br>  O processamento ocorre em paralelo com outras atividades no sistema.  Nesse caso, a tabela e os √≠ndices podem ser usados ‚Äã‚Äãda maneira usual, tanto para leitura quanto para altera√ß√£o (no entanto, a execu√ß√£o simult√¢nea de comandos como CREATE INDEX, ALTER TABLE e alguns outros ser√° imposs√≠vel). <br><br>  Somente as p√°ginas nas quais ocorreu alguma atividade s√£o exibidas na tabela.  Para isso, √© usado um mapa de visibilidade (lembro que as p√°ginas que cont√™m apenas vers√µes bastante antigas de linhas que s√£o garantidas como vis√≠veis em todos os instant√¢neos de dados est√£o marcadas nele).  Somente p√°ginas que n√£o est√£o marcadas no mapa s√£o processadas, enquanto o pr√≥prio mapa √© atualizado. <br><br>  No processo, o mapa de espa√ßo livre √© atualizado para refletir o espa√ßo livre que aparece nas p√°ginas. <br><a name="habracut"></a><br>  Como de costume, crie uma tabela: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> vac_s <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> vac(s); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre> <br>  Usando o par√¢metro <em>autovacuum_enabled,</em> desativamos a limpeza autom√°tica.  Falaremos sobre isso na pr√≥xima vez, mas por enquanto - para experimentos - √© importante gerenciarmos a limpeza manualmente. <br><br>  Existem tr√™s vers√µes da linha na tabela agora e cada uma est√° vinculada a partir de um √≠ndice: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | normal | 4000 (c) | 4001 (c) | | | (0,2) (0,2) | normal | 4001 (c) | 4002 | | | (0,3) (0,3) | normal | 4002 | 0 (a) | | | (0,3) (3 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,1) 2 | (0,2) 3 | (0,3) (3 rows)</code> </pre><br>  Ap√≥s a limpeza, as vers√µes "mortas" desaparecem e existe apenas uma, relevante.  E o √≠ndice tamb√©m tem um link restante: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4002 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br>  Observe que os dois primeiros ponteiros receberam o status sem uso e n√£o morto, como seria com a limpeza dentro da p√°gina. <br><br><h2>  E novamente sobre o horizonte de transa√ß√µes </h2><br>  Como o PostgreSQL determina quais vers√µes de linha podem ser consideradas "inoperantes"?  J√° consideramos o conceito de horizonte de transa√ß√£o quando falamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sobre</a> instant√¢neos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dados</a> , mas esse √© um t√≥pico t√£o importante que n√£o √© pecado repeti-lo. <br><br>  Vamos come√ßar a experi√™ncia anterior novamente. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Mas antes de atualizar a linha novamente, deixe outra transa√ß√£o come√ßar (mas n√£o terminar).  Em nosso exemplo, ele funcionar√° no n√≠vel Read Committed, mas dever√° obter um n√∫mero de transa√ß√£o real (n√£o virtual).  Por exemplo, ele pode alterar ou at√© mesmo bloquear algumas linhas em qualquer tabela, n√£o necessariamente em vac: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>;</code> </pre><pre> <code class="plaintext hljs">| s | ----- | FOO | BAR | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre><br>  Existem tr√™s linhas na tabela e tr√™s links no √≠ndice.  O que acontece ap√≥s a limpeza? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | normal | 4005 (c) | 4007 (c) | | | (0,3) (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,3) (2 rows)</code> </pre><br>  Existem duas vers√µes da linha restantes na tabela: a limpeza decidiu que a vers√£o (0.2) ainda n√£o podia ser exclu√≠da.  O motivo, √© claro, est√° no horizonte de transa√ß√£o do banco de dados, que em nosso exemplo √© determinado por uma transa√ß√£o incompleta: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| backend_xmin | -------------- | 4006 | (1 row)</code> </pre><br>  Voc√™ pode solicitar a limpeza para falar sobre o que acontece: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: index "vac_s" now contains 2 row versions in 2 pages DETAIL: 0 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 0 removable, 2 nonremovable row versions in 1 out of 1 pages DETAIL: 1 dead row versions cannot be removed yet, oldest xmin: 4006 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Observe: <br><br><ul><li>  2 vers√µes de linha n√£o remov√≠veis - foram encontradas 2 vers√µes na tabela que n√£o podem ser exclu√≠das, </li><li>  1 vers√£o de linha morta ainda n√£o pode ser removida - incluindo 1 "morta", </li><li>  xmin mais antigo mostra o horizonte atual. </li></ul><br>  Repetimos a conclus√£o mais uma vez: a presen√ßa de transa√ß√µes de longa dura√ß√£o no banco de dados (n√£o conclu√≠das ou muito demoradas) pode levar √† expans√£o de tabelas (inchadas), independentemente da frequ√™ncia com que a limpeza √© realizada.  Portanto, no PostgreSQL, as cargas de trabalho OLTP e OLAP s√£o pouco combinadas em um banco de dados: os relat√≥rios que s√£o executados por horas n√£o permitem que as tabelas atualizadas com frequ√™ncia sejam limpas a tempo.  Uma solu√ß√£o poss√≠vel seria criar uma r√©plica separada de "relat√≥rio". <br><br>  Ap√≥s a conclus√£o de uma transa√ß√£o aberta, o horizonte muda e a situa√ß√£o √© corrigida: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: scanned index "vac_s" to remove 1 row versions DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: "vac": removed 1 row versions in 1 pages DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: index "vac_s" now contains 1 row versions in 2 pages DETAIL: 1 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 1 removable, 1 nonremovable row versions in 1 out of 1 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4008 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Agora a p√°gina possui apenas a vers√£o atual mais recente da linha: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><br>  Tamb√©m h√° apenas uma entrada no √≠ndice: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br><h2>  O que est√° acontecendo por dentro </h2><br>  A limpeza deve processar a tabela e os √≠ndices ao mesmo tempo e faz√™-lo de maneira a n√£o bloquear a opera√ß√£o de outros processos.  Como ela faz isso? <br><br>  Tudo come√ßa com <strong>uma varredura de tabela</strong> (levando em considera√ß√£o o mapa de visibilidade, como j√° observado).  Nas p√°ginas lidas, vers√µes desnecess√°rias de strings s√£o determinadas e seus identificadores (tid) s√£o gravados em uma matriz especial.  A matriz est√° localizada na mem√≥ria local do processo de limpeza;  um fragmento do tamanho <em>maintenance_work_mem</em> √© alocado para ele.  O valor padr√£o para este par√¢metro √© 64 MB.  Observe que essa mem√≥ria √© alocada imediatamente na √≠ntegra e n√£o conforme necess√°rio.  Verdadeiro, se a tabela for pequena, o fragmento ser√° alocado menos. <br><br>  A seguir, uma das duas coisas: chegaremos ao final da tabela ou a mem√≥ria alocada para a matriz terminar√°.  Nos dois casos, <strong>a fase de limpeza do √≠ndice √©</strong> iniciada.  Para fazer isso, <em>cada um</em> dos √≠ndices criados na tabela √© <em>completamente verificado</em> na busca de registros que fazem refer√™ncia a vers√µes armazenadas de linhas.  Os registros encontrados s√£o limpos das p√°ginas de √≠ndice. <br><br>  Nesse ponto, temos a seguinte imagem: nos √≠ndices, n√£o h√° mais links para vers√µes desnecess√°rias de linhas, mas elas ainda existem na tabela.  Isso n√£o contradiz nada: ao executar uma consulta, n√£o chegamos a vers√µes mortas de linhas (com acesso ao √≠ndice) ou as marcamos ao verificar a visibilidade (ao verificar uma tabela). <br><br>  Depois disso, <strong>a fase de limpeza da mesa</strong> come√ßa.  A tabela √© digitalizada novamente para ler as p√°ginas necess√°rias, limpar as vers√µes armazenadas das linhas e liberar os ponteiros.  Podemos fazer isso porque n√£o h√° mais links de √≠ndices. <br><br>  Se a tabela n√£o foi lida completamente na primeira passagem, a matriz √© limpa e tudo √© repetido do local em que paramos. <br><br>  Desta forma: <br><br><ul><li>  a tabela √© sempre digitalizada duas vezes; </li><li>  se tantas vers√µes de linha forem exclu√≠das durante a limpeza que todas elas n√£o caber√£o na mem√≥ria <em>maintenance_work_mem</em> , todos os √≠ndices ser√£o varridos completamente quantas vezes forem necess√°rias. </li></ul><br>  Em tabelas grandes, isso pode levar uma quantidade consider√°vel de tempo e criar uma carga significativa no sistema.  Obviamente, as solicita√ß√µes n√£o ser√£o bloqueadas, mas a E / S "extra" tamb√©m √© desagrad√°vel. <br><br>  Para acelerar o processo, faz sentido solicitar a limpeza com mais frequ√™ncia (para que um n√∫mero n√£o muito grande de vers√µes de linha seja limpo a cada vez) ou alocar mais mem√≥ria. <br><br>  Observo entre par√™nteses que, a partir da vers√£o 11, o PostgreSQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pode pular as verifica√ß√µes de √≠ndice,</a> se isso n√£o for absolutamente necess√°rio.  Isso deve facilitar a vida dos propriet√°rios de tabelas grandes nas quais as linhas s√£o adicionadas apenas (mas n√£o alteradas). <br><br><h2>  Monitoramento </h2><br>  Como entender que a limpeza n√£o lida com o trabalho de uma s√≥ vez? <br><br>  J√° vimos o primeiro m√©todo: voc√™ pode chamar o comando VACUUM com VERBOSE.  Em seguida, as informa√ß√µes sobre as fases do trabalho ser√£o exibidas no console. <br><br>  Em segundo lugar, a partir da vers√£o 9.6, existe uma vis√£o pg_stat_progress_vacuum, que tamb√©m cont√©m todas as informa√ß√µes necess√°rias. <br><br>  (Existe uma terceira maneira - exibir informa√ß√µes no log de mensagens, mas isso funciona apenas para a limpeza autom√°tica, que ser√° discutida na pr√≥xima vez.) <br><br>  Inseriremos mais linhas na tabela para que o processo de limpeza leve um tempo not√°vel e atualizaremos todas elas para que haja algo a ver com a limpeza. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Reduza o tamanho da mem√≥ria alocada para a matriz identificadora: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> maintenance_work_mem = <span class="hljs-string"><span class="hljs-string">'1MB'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Come√ßamos a limpar e, enquanto funciona, voltaremos √† visualiza√ß√£o pg_stat_progress_vacuum v√°rias vezes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 2908 | heap_blks_vacuumed | 0 | index_vacuum_count | 0 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 5816 | heap_blks_vacuumed | 2907 | index_vacuum_count | 1 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br>  Aqui vemos em particular: <br><br><ul><li>  nome da fase atual (fase) - falamos sobre tr√™s fases principais, mas em geral existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mais</a> ; </li><li>  n√∫mero total de p√°ginas da tabela (heap_blks_total); </li><li>  o n√∫mero de p√°ginas rastreadas (heap_blks_scanned); </li><li>  o n√∫mero de p√°ginas j√° limpas (heap_blks_vacuumed); </li><li>  o n√∫mero de passes por √≠ndice (index_vacuum_count). </li></ul><br>  O progresso geral √© determinado pela propor√ß√£o de heap_blks_vacuumed e heap_blks_total, mas lembre-se de que esse valor n√£o muda suavemente, mas "de maneira inst√°vel" devido √†s verifica√ß√µes de √≠ndice.  No entanto, a principal aten√ß√£o deve ser dada ao n√∫mero de ciclos de limpeza - um valor maior que 1 significa que a mem√≥ria alocada n√£o foi suficiente para concluir a limpeza de uma s√≥ vez. <br><br>  A sa√≠da do comando VACUUM VERBOSE, conclu√≠da neste momento, mostrar√° o quadro geral: <br><br><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac"</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.50 s, system: 0.07 s, elapsed: 1.36 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.02 s, system: 0.02 s, elapsed: 0.13 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.26 s, system: 0.07 s, elapsed: 0.81 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.10 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 151040 row versions DETAIL: CPU: user: 0.13 s, system: 0.04 s, elapsed: 0.47 s INFO: "vac": removed 151040 row versions in 2518 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.08 s</code> </pre><pre> <code class="plaintext hljs">INFO: index "vac_s" now contains 500000 row versions in 17821 pages DETAIL: 500000 index row versions were removed. 8778 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 500000 removable, 500000 nonremovable row versions in 16667 out of 16667 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4011 There were 0 unused item pointers. 0 pages are entirely empty. CPU: user: 1.10 s, system: 0.37 s, elapsed: 3.71 s. VACUUM</code> </pre><br>  Aqui voc√™ pode ver que, no total, houve tr√™s passagens pelos √≠ndices, cada uma das quais limpou 174.480 ponteiros para vers√µes mortas de strings.  De onde vem esse n√∫mero?  Um link (tid) ocupa 6 bytes e 1024 * 1024/6 = 174762 √© o n√∫mero que vemos em pg_stat_progress_vacuum.max_dead_tuples.  Na verdade, ele pode ser usado um pouco menos: √© garantido que, ao ler a pr√≥xima p√°gina, todos os indicadores para as vers√µes "inativas" caber√£o exatamente na mem√≥ria. <br><br><h2>  An√°lise </h2><br>  A an√°lise ou, em outras palavras, a coleta de informa√ß√µes estat√≠sticas para o planejador de consultas, n√£o est√° formalmente conectada √† limpeza.  No entanto, podemos realizar a an√°lise n√£o apenas com a equipe ANALYZE, mas tamb√©m combinar a limpeza com a an√°lise: AN√ÅLISE DE V√ÅCUO.  Nesse caso, a limpeza √© realizada primeiro e depois a an√°lise - n√£o ocorre economia. <br><br>  Por√©m, como veremos mais adiante, a limpeza autom√°tica e a an√°lise autom√°tica s√£o realizadas em um processo e gerenciadas de maneira semelhante. <br><br><h1>  Limpeza completa (v√°cuo cheio) </h1><br>  Como vimos, a limpeza convencional libera mais espa√ßo do que a limpeza intra-p√°gina, mas nem sempre resolve o problema completamente. <br><br>  Se, por algum motivo, uma tabela ou √≠ndice tiver aumentado significativamente de tamanho, a limpeza regular liberar√° espa√ßo nas p√°ginas existentes: eles ter√£o orif√≠cios que ser√£o usados ‚Äã‚Äãpara inserir novas vers√µes de linhas.  Mas o n√∫mero de p√°ginas n√£o ser√° alterado e, portanto, do ponto de vista do sistema operacional, os arquivos ocupar√£o exatamente a mesma quantidade de espa√ßo que ocupavam antes da limpeza.  E isso √© ruim porque: <br><br><ul><li>  a varredura completa de uma tabela (ou √≠ndice) fica mais lenta; </li><li>  pode ser necess√°rio um cache de buffer maior (porque as p√°ginas s√£o armazenadas e a densidade de informa√ß√µes √∫teis diminui); </li><li>  um n√≠vel "extra" pode aparecer na √°rvore de √≠ndices, o que tornar√° mais lento o acesso ao √≠ndice; </li><li>  arquivos ocupam espa√ßo em disco extra e backups. </li></ul><br>  (A √∫nica exce√ß√£o s√£o as p√°ginas completamente limpas no final do arquivo - essas p√°ginas "cortam" o arquivo e retornam ao sistema operacional.) <br><br>  Se o compartilhamento de informa√ß√µes √∫teis nos arquivos estiver abaixo de um limite razo√°vel, o administrador poder√° executar uma limpeza completa da tabela.  Ao mesmo tempo, a tabela e todos os seus √≠ndices s√£o completamente reconstru√≠dos do zero e os dados s√£o compactados da maneira mais compacta poss√≠vel (√© claro, levando em considera√ß√£o o par√¢metro fator de preenchimento).  Ao reconstruir, o PostgreSQL reconstr√≥i sequencialmente a tabela primeiro e depois cada um de seus √≠ndices.  Novos arquivos s√£o criados para cada objeto e, no final da reconstru√ß√£o, os arquivos antigos s√£o exclu√≠dos.  Observe que, no processo de trabalho no disco, ser√° necess√°rio espa√ßo adicional. <br><br>  Para ilustrar, insira v√°rias linhas na tabela novamente: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>);</code> </pre><br>  Como avaliar a densidade da informa√ß√£o?  Para fazer isso, √© conveniente usar a extens√£o especial: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgstattuple; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- table_len | 68272128 tuple_count | 500000 tuple_len | 64500000 tuple_percent | 94.47 dead_tuple_count | 0 dead_tuple_len | 0 dead_tuple_percent | 0 free_space | 38776 free_percent | 0.06</code> </pre><br>  A fun√ß√£o l√™ a tabela inteira e mostra estat√≠sticas sobre quanto espa√ßo quais dados est√£o ocupados nos arquivos.  A principal informa√ß√£o em que estamos interessados ‚Äã‚Äãagora √© o campo tuple_percent: a porcentagem ocupada por dados √∫teis.  √â inferior a 100 devido √† sobrecarga inevit√°vel de informa√ß√µes de servi√ßo dentro da p√°gina, mas mesmo assim √© bastante alta. <br><br>  Para o √≠ndice, outras informa√ß√µes s√£o exibidas, mas o campo avg_leaf_density tem o mesmo significado: a porcentagem de informa√ß√µes √∫teis (nas p√°ginas de folha). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- version | 3 tree_level | 3 index_size | 72802304 root_block_no | 2722 internal_pages | 241 leaf_pages | 8645 empty_pages | 0 deleted_pages | 0 avg_leaf_density | 83.77 leaf_fragmentation | 64.25</code> </pre><br>  E aqui est√° o tamanho da tabela e do √≠ndice: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Agora exclua 90% de todas as linhas.  Selecionamos as linhas para exclus√£o aleatoriamente, para que em todas as p√°ginas com alta probabilidade pelo menos uma linha permane√ßa: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> random() &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 450189</code> </pre><br>  Qual o tamanho dos objetos ap√≥s a limpeza normal? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Vimos que o tamanho n√£o mudou: a limpeza regular n√£o pode reduzir o tamanho dos arquivos de forma alguma.  Embora a densidade da informa√ß√£o tenha obviamente diminu√≠do cerca de 10 vezes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 9.41 | 9.73 (1 row)</code> </pre><br>  Agora verifique o que acontece ap√≥s uma limpeza completa.  Aqui est√£o os arquivos usados ‚Äã‚Äãpela tabela e √≠ndices agora: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57392 | base/41493/57393 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FULL</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57404 | base/41493/57407 (1 row)</code> </pre><br>  Agora os arquivos s√£o substitu√≠dos por novos.  O tamanho da tabela e do √≠ndice diminuiu significativamente e a densidade de informa√ß√µes aumentou: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 6648 kB | 6480 kB (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 94.39 | 91.08 (1 row)</code> </pre><br>  Observe que a densidade de informa√ß√µes no √≠ndice aumentou ainda em compara√ß√£o com o original.  Recriar um √≠ndice (√°rvore B) a partir dos dados dispon√≠veis √© mais rent√°vel do que inserir dados em um √≠ndice existente, linha por linha. <br><br>  As fun√ß√µes de extens√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pgstattuple</a> que usamos leram a tabela inteira.  Se a tabela for grande, isso √© inconveniente e, portanto, existe uma fun√ß√£o pgstattuple_approx, que pula as p√°ginas marcadas no mapa de visibilidade e mostra n√∫meros aproximados. <br><br>  Uma maneira ainda mais r√°pida, mas ainda menos precisa, √© estimar a propor√ß√£o do volume de dados para o tamanho do arquivo no diret√≥rio do sistema.  Op√ß√µes para essas consultas podem ser encontradas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no wiki</a> . <br><br>  Uma limpeza completa n√£o requer uso regular, pois bloqueia completamente todo o trabalho com a tabela (incluindo a consulta) por toda a dura√ß√£o do trabalho.  √â claro que em um sistema usado ativamente isso pode ser inaceit√°vel.  Bloqueios ser√£o considerados separadamente, mas por enquanto nos restringiremos a mencionar a extens√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pg_repack</a> , que bloqueia a tabela apenas por um curto per√≠odo de tempo no final do trabalho. <br><br><h2>  Equipes semelhantes </h2><br>  Existem v√°rios comandos que tamb√©m reconstroem completamente tabelas e √≠ndices, e isso √© semelhante a uma limpeza completa.  Todos eles bloqueiam completamente o trabalho com a tabela, todos excluem os arquivos de dados antigos e criam novos. <br><br>  O comando CLUSTER √© semelhante em tudo ao VACUUM FULL, mas adicionalmente organiza fisicamente a vers√£o das strings de acordo com um dos √≠ndices dispon√≠veis.  Isso fornece ao agendador a capacidade de usar o acesso ao √≠ndice com mais efici√™ncia em alguns casos.  No entanto, deve-se entender que o armazenamento em cluster n√£o √© suportado: com altera√ß√µes subseq√ºentes na tabela, a ordem f√≠sica das vers√µes de linha ser√° violada. <br><br>  O comando REINDEX reconstr√≥i um √∫nico √≠ndice em uma tabela.  De fato, VACUUM FULL e CLUSTER usam esse comando para recriar √≠ndices. <br><br>  O comando TRUNCATE funciona logicamente da mesma forma que DELETE - exclui todas as linhas da tabela.  Mas DELETE, como j√° discutido, marca apenas a vers√£o das linhas como exclu√≠da, o que requer limpeza adicional.  TRUNCATE apenas cria um novo arquivo limpo.  Como regra, isso funciona mais r√°pido, mas lembre-se de que TRUNCATE bloquear√° completamente o trabalho com a tabela durante todo o tempo at√© o final da transa√ß√£o. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para ser continuado</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt452320/">https://habr.com/ru/post/pt452320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt452310/index.html">Configurando canais de vendas em rede para gadgets DO-RA</a></li>
<li><a href="../pt452312/index.html">As telecomunica√ß√µes brit√¢nicas pagar√£o aos assinantes uma compensa√ß√£o pelas desconex√µes</a></li>
<li><a href="../pt452314/index.html">O design de n√≠veis e jogabilidade roguelike no exemplo de Cogmind</a></li>
<li><a href="../pt452316/index.html">A miss√£o Chang'e-4 - os resultados do quinto dia lunar: problemas com o ve√≠culo espacial Yutu-2 e uma nova descoberta cient√≠fica</a></li>
<li><a href="../pt452318/index.html">Usando o Firebase como armazenamento de imagens para um aplicativo Android</a></li>
<li><a href="../pt452322/index.html">Do epicentro do Google Cloud Next '19: notas de campo do CEO</a></li>
<li><a href="../pt452328/index.html">Matryoshka C Sistema de linguagem de programa de camada</a></li>
<li><a href="../pt452330/index.html">Como conduzir o planejamento trimestral sem papel distribu√≠do e n√£o estragar tudo?</a></li>
<li><a href="../pt452332/index.html">√â dif√≠cil ser um mantenedor de projeto de c√≥digo aberto</a></li>
<li><a href="../pt452334/index.html">Como se disfar√ßar na Internet: compare servidor e proxies residentes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>