<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏘️ 🤦🏼 🙋🏽 ECS库的本机实现 💆🏼 👨🏿‍🔧 👸🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本周，我开始研究Vagabond引擎，并开始实现实体组件系统模板。 

 在本文中，我想谈一谈我的实现，该实现可在GitHub上免费获得。 但是，我不仅要对代码进行注释，还要解释其结构是如何设计的。 因此，我将从编写的第一个实现开始，分析其优缺点，然后说明如何改进它。 最后，我将列出也可以改进的方面...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ECS库的本机实现</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459288/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c9/fc6/23e/4c9fc623e0787518bde7823317b0e6af.png" alt="图片"></div><br> 本周，我开始研究Vagabond引擎，并开始实现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实体组件系统</a>模板。 <br><br> 在本文中，我想谈一谈我的实现，该实现可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上</a>免费获得。 但是，我不仅要对代码进行注释，还要解释其结构是如何设计的。 因此，我将从编写的第一个实现开始，分析其优缺点，然后说明如何改进它。 最后，我将列出也可以改进的方面。 <br><br><h1> 引言 </h1><br><h2> 动机 </h2><br> 我不会谈论ECS优于面向对象方法的好处，因为在我之前的很多人都做得很好。 斯科特·比拉斯（Scott Bilas）是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://web.archive.org/web/20101011021902/">2002年GDC</a>上第一个谈论ECS的人。 该主题的其他引人注目的介绍包括Mike West的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Evolve Your Hierarchy</a>和Robert Nistrom令人惊叹的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Game Programming Patterns</a>书中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Components</a>章节。 <br><br> 简而言之，我将说ECS的任务是为游戏实体创建一种面向数据的方法，并方便地将数据与逻辑分离。 实体由包含数据的组件组成。 包含逻辑的系统将处理这些组件。 <br><br> 如果您要详细介绍，ECS中将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">composition（组合）</a> ，而不是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">继承</a> 。 此外，这种面向数据的方法可以更好地利用缓存，这意味着它可以实现出色的性能。 <br><a name="habracut"></a><br><h2> 例子 </h2><br> 在深入研究代码之前，我想向您展示我们将要设计的内容。 <br><br> 分配组件非常简单： <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Position</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Component&lt;Position&gt; { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Velocity</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Component&lt;Velocity&gt; { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; };</code> </pre> <br> 如您所见，我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CRTP</a>模板。 <br><br> 然后，出于技术原因（我将在后面解释），我们需要确定组件数和系统数： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ComponentCount = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> SystemCount = <span class="hljs-number"><span class="hljs-number">8</span></span>;</code> </pre> <br> 接下来，您可以指定一个系统，该系统将接收同时具有两个组件的所有实体并更新其位置： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PhysicsSystem</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> System&lt;ComponentCount, SystemCount&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: PhysicsSystem(EntityManager&lt;ComponentCount, SystemCount&gt;&amp; entityManager) : mEntityManager(entityManager) { setRequirements&lt;Position, Velocity&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; entity : getManagedEntities()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [position, velocity] = mEntityManager.getComponents&lt;Position, Velocity&gt;(entity); position.x += velocity.x * dt; position.y += velocity.y * dt; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: EntityManager&lt;ComponentCount, SystemCount&gt;&amp; mEntityManager; };</code> </pre> <br> 系统仅使用<code>setRequirements</code>方法来<code>setRequirements</code>其<code>setRequirements</code>组件。 然后，在<code>update</code>方法中，它可以调用<code>getManagedEntities</code>来迭代遍历所有满足要求的实体。 <br><br> 最后，让我们创建一个实体管理器，注册组件，创建一个系统和几个实体，然后使用该系统更新它们的位置： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> manager = EntityManager&lt;ComponentCount, SystemCount&gt;(); manager.registerComponent&lt;Position&gt;(); manager.registerComponent&lt;Velocity&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> system = manager.createSystem&lt;PhysicsSystem&gt;(manager); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> entity = manager.createEntity(); manager.addComponent&lt;Position&gt;(entity); manager.addComponent&lt;Velocity&gt;(entity); } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> dt = <span class="hljs-number"><span class="hljs-number">1.0f</span></span> / <span class="hljs-number"><span class="hljs-number">60.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) system-&gt;update(dt);</code> </pre> <br><h3> 基准测试 </h3><br> 我不会假装创建最好的ECS库。 我只是想自己写。 另外，我只做了一个星期。 <br><br> 但是，这不是制造完全无效的原因。 因此，让我们安装基准测试： <br><br><ul><li> 第一个将创建实体；第二个将创建实体。 </li><li> 第二个将使用该系统迭代遍历实体； </li><li> 后者将创建并销毁实体； </li></ul><br> 所有这些基准测试的参数是实体数，每个实体的组件数，最大组件数和最大系统数。 通过这种方式，我们可以看到我们的实现扩展的程度。 特别是，我将显示三种不同配置文件的结果： <br><br><ul><li> 配置文件A：32个组件和16个系统； </li><li>  AA配置文件：128个组件和32个系统； </li><li>  AAA配置文件：512个组件和64个系统。 </li></ul><br> 尽管这些基准将使我们对执行质量有所了解，但它们非常简单。 例如，在这些基准测试中，我们仅使用同类实体，并且它们的组成很小。 <br><br><h1> 实作 </h1><br><h2> 精华液 </h2><br> 在我的实现中，实体只是一个ID： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Entity = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>;</code> </pre> <br> 此外，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Entity.h中，</a>我们还将定义一个别名<code>Index</code> ，稍后<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将派</a>上用场： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> InvalidIndex = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;Index&gt;::max();</code> </pre> <br> 我决定使用<code>uint32_t</code>代替64位类型或<code>std::size_t</code>来节省空间并改善缓存优化。 我们不会损失那么多：某人拥有数十亿个实体的可能性不大。 <br><br><h2> 组成部分 </h2><br> 现在让我们定义组件的基类： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(Type); };</code> </pre> <br> 模板类非常简单，它只存储类型ID，我们稍后将使用该ID根据组件的类型为数据结构建立索引。 <br><br> 第一个模板参数是组件的类型。 第二个是转换为<code>std::size_t</code>的值，它将用作组件类型id。 <br><br> 例如，我们可以如下定义<code>Position</code>组件： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Positon</span></span></span><span class="hljs-class"> :</span></span> Component&lt;Position, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; };</code> </pre> <br> 但是，枚举可能更方便： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentType</span></span></span><span class="hljs-class"> {</span></span> Position }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Positon</span></span></span><span class="hljs-class"> :</span></span> Component&lt;Position, ComponentType::Position&gt; { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; };</code> </pre> <br> 在介绍性示例中，只有一个模板参数：我们不需要手动指定类型ID。 稍后我们将看到如何改善结构并自动生成类型标识符。 <br><br><h2> 实体容器 </h2><br>  <code>EntityContainer</code>类将负责管理实体和每个实体的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>std::bitset</code></a> 。 这组位将指示实体拥有的组件。 <br><br> 因为我们将使用实体来索引容器，尤其是<code>std::vector</code> ，所以我们需要id尽可能小并占用更少的内存。 因此，我们将重用被破坏实体的ID。 为此，免费ID将存储在名为<code>mFreeEntities</code>的容器中。 <br><br> 这是<code>EntityContainer</code> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ComponentCount, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SystemCount&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EntityContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; getEntityToBitset(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&amp; getBitset(Entity entity) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt; mEntityToBitset; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt; mFreeEntities; };</code> </pre> <br> 让我们看看这些方法是如何实现的。 <br><br>  <code>getEntityToBitset</code>和<code>getBitset</code>是通常的小吸气剂： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; getEntityToBitset() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mEntityToBitset; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&amp; getBitset(Entity entity) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mEntityToBitset[entity]; }</code> </pre> <br>  <code>create</code>方法更有趣： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> entity = Entity(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mFreeEntities.empty()) { entity = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Entity&gt;(mEntityToBitset.size()); mEntityToBitset.emplace_back(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { entity = mFreeEntities.back(); mFreeEntities.pop_back(); mEntityToBitset[entity].reset(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entity; }</code> </pre> <br> 如果有自由实体，他将重用它。 否则，该方法将创建一个新实体。 <br><br>  <code>remove</code>方法只是在<code>mFreeEntities</code>添加要删除的实体： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ mFreeEntities.push_back(entity); }</code> </pre> <br> 最后一种方法是<code>reserve</code> 。 它的任务是为各种容器保留内存。 如我们所知，分配内存是一项昂贵的操作，因此，如果我们大约知道游戏中未来实体的数量，那么预留内存将加快工作： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ mFreeEntities.resize(size); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::iota(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin(mFreeEntities), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(mFreeEntities), <span class="hljs-number"><span class="hljs-number">0</span></span>); mEntityToBitset.resize(size); }</code> </pre> <br> 除了简单的内存备份外，它还会填充<code>mFreeEntities</code> 。 <br><br><h2> 组件容器 </h2><br>  <code>ComponentContainer</code>类将负责存储指定类型的所有组件。 <br><br> 在我的体系结构中，给定类型的所有组件都存储在一起。 也就是说，每种类型的组件都有一个大数组，称为<code>mComponents</code> 。 <br><br> 另外，为了能够在恒定时间内添加，接收或从实体中删除组件，我们需要一种从实体移动到组件以及从组件移动到实体的方法。 为此，我们还需要两个名为<code>mComponentToEntity</code>和<code>mEntityToComponent</code>数据结构。 <br><br> 这是<code>ComponentContainer</code>声明： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ComponentCount, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SystemCount&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentContainer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BaseComponentContainer { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ComponentContainer(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; entityToBitset); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, Args&amp;&amp;... args)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryRemove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; component)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; mComponents; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt; mComponentToEntity; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;Entity, Index&gt; mEntityToComponent; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; mEntityToBitset; };</code> </pre> <br> 您可以看到它继承自<code>BaseComponentContainer</code> ，其设置如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseComponentContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~BaseComponentContainer() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryRemove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br> 该基类的唯一目的是能够在容器中存储<code>ComponentContainer</code>所有实例。 <br><br> 现在让我们看一下方法的定义。 <br><br> 首先，考虑构造函数：它获得对包含实体位集合的容器的引用。 此类将使用它来检查实体中组件的存在，并在添加或删除组件时更新实体的位集： <br><br><pre> <code class="cpp hljs">ComponentContainer(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; entityToBitset) : mEntityToBitset(entityToBitset) { }</code> </pre> <br>  <code>get</code>方法很简单，我们只使用<code>mEntityToComponent</code>在<code>mEntityToComponent</code>中查找实体组件的<code>mComponents</code> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mComponents[mEntityToComponent[entity]]; }</code> </pre> <br>  <code>add</code>方法使用其参数在<code>mComponents</code>的末尾插入新组件，然后准备从实体到组件以及从组件到实体的链接。 最后，它将与组件匹配的<code>entity</code>位集中的位设置为<code>true</code> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Index&gt;(mComponents.size()); mComponents.emplace_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); mComponentToEntity.emplace_back(entity); mEntityToComponent[entity] = index; mEntityToBitset[entity][T::type] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  <code>remove</code>方法将相应的位组件设置为<code>false</code> ，然后将最后一个<code>mComponents</code>组件移动到我们要删除的组件的索引处。 它更新到我们刚刚移动的组件的链接，并删除我们要销毁的组件之一： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ mEntityToBitset[entity][T::type] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> index = mEntityToComponent[entity]; <span class="hljs-comment"><span class="hljs-comment">// Update mComponents mComponents[index] = std::move(mComponents.back()); mComponents.pop_back(); // Update mEntityToComponent mEntityToComponent[mComponentToEntity.back()] = index; mEntityToComponent.erase(entity); // Update mComponentToEntity mComponentToEntity[index] = mComponentToEntity.back(); mComponentToEntity.pop_back(); }</span></span></code> </pre> <br> 我们可以通过在要破坏的索引处移动最后一个组件来执行恒定时间的移动。 实际上，我们只需要删除最后一个组件，就可以在恒定时间<code>std::vector</code>中完成此操作。 <br><br>  <code>tryRemove</code>方法在尝试删除实体之前先检查它是否具有组件： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryRemove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mEntityToBitset[entity][T::type]) { remove(entity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  <code>getOwner</code>方法返回拥有组件的实体，为此，它使用指针算法和<code>mComponentToEntity</code> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; component)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> begin = mComponents.data(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(&amp;component - begin); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mComponentToEntity[index]; }</code> </pre> <br> 最后一个方法是<code>reserve</code> ，其目的与<code>EntityContainer</code>的类似方法相同： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> override </span></span>{ mComponents.reserve(size); mComponentToEntity.reserve(size); mEntityToComponent.reserve(size); }</code> </pre> <br><h2> 系统 </h2><br> 现在让我们看一下<code>System</code>类。 <br><br> 每个系统都有一组<code>mRequirements</code>位， <code>mRequirements</code>位描述了所需的组件。 此外，它存储一组满足这些要求的<code>mManagedEntities</code>实体。 我重复一遍，为了能够在恒定时间内实施所有操作，我们需要一种从实体移到<code>mManagedEntities</code>索引的<code>mManagedEntities</code> 。 为此，我们将使用名为<code>mEntityToManagedEntity</code> <code>std::unordered_map</code> 。 <br><br> 这是<code>System</code>声明的样子： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ComponentCount, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SystemCount&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">System</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~System() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRequirements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt;&amp; getManagedEntities() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onManagedEntityAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([[maybe_unused]] Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onManagedEntityRemoved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([[maybe_unused]] Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> EntityManager&lt;ComponentCount, SystemCount&gt;; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt; mRequirements; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mType; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt; mManagedEntities; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;Entity, Index&gt; mEntityToManagedEntity; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEntityUpdated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">bitset</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;ComponentCount&gt;&amp; components)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEntityRemoved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; };</code> </pre> <br>  <code>setRequirements</code>使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">卷积表达式</a>来设置位值： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRequirements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ (mRequirements.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(Ts::type), ...); }</code> </pre> <br>  <code>getManagedEntities</code>是一个getter，生成的类将使用该getter来访问正在处理的实体： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt;&amp; getManagedEntities() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mManagedEntities; }</code> </pre> <br> 它返回一个常量引用，以使生成的类不会尝试修改<code>mManagedEntities</code> 。 <br><br>  <code>onManagedEntityAdded</code>和<code>onManagedEntityRemoved</code>为空。 它们将在以后重新定义。 将实体添加到<code>mManagedEntities</code>或将其删除时，将调用这些方法。 <br><br> 以下方法将是私有的，并且只能从声明为友好类的<code>EntityManager</code>访问。 <br><br> 实体管理器将调用<code>setUp</code>为系统分配ID。 然后可以使用它来索引数组： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type)</span></span></span><span class="hljs-function"> </span></span>{ mType = type; }</code> </pre> <br> 当实体发生变化时，即<code>onEntityUpdated</code>被调用 添加或删除组件时。 系统检查是否满足要求以及是否已处理实体。 如果满足要求并且尚未处理，则系统将其添加。 但是，如果实体不满足要求并且已经被处理，则系统将其删除。 在所有其他情况下，系统不执行任何操作： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEntityUpdated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">bitset</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;ComponentCount&gt;&amp; components)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> satisfied = (mRequirements &amp; components) == mRequirements; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> managed = mEntityToManagedEntity.find(entity) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(mEntityToManagedEntity); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (satisfied &amp;&amp; !managed) addEntity(entity); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!satisfied &amp;&amp; managed) removeEntity(entity); }</code> </pre> <br> 删除实体时，实体管理器将调用<code>onEntityRemoved</code> 。 如果该实体已由系统处理，则将其删除： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEntityRemoved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mEntityToManagedEntity.find(entity) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(mEntityToManagedEntity)) removeEntity(entity); }</code> </pre> <br>  <code>addEntity</code>和<code>removeEntity</code>只是辅助方法。 <br><br>  <code>addEntity</code>通过<code>mManagedEntities</code>索引将链接设置为从添加的实体<code>mManagedEntities</code> ，添加实体并调用<code>onManagedEntityAdded</code> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ mEntityToManagedEntity[entity] = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Index&gt;(mManagedEntities.size()); mManagedEntities.emplace_back(entity); onManagedEntityAdded(entity); }</code> </pre> <br>  <code>onManagedEntityRemoved</code>首先调用<code>onManagedEntityRemoved</code> 。 然后，它将最后处理的实体移到要删除的实体的索引处。 它更新对已移动实体的引用。 最后，它从<code>mManagedEntities</code>和<code>mEntityToManagedEntity</code>删除要删除的实体： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ onManagedEntityRemoved(entity); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> index = mEntityToManagedEntity[entity]; mEntityToManagedEntity[mManagedEntities.back()] = index; mEntityToManagedEntity.erase(entity); mManagedEntities[index] = mManagedEntities.back(); mManagedEntities.pop_back(); }</code> </pre> <br><h2> 实体管理器 </h2><br> 所有重要的逻辑都在其他类别中。 实体经理只是将所有内容捆绑在一起。 <br><br> 让我们看一下他的广告： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ComponentCount, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SystemCount&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EntityManager</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createSystem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args&amp;&amp; ...args)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasComponents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Ts&amp;...&gt; getComponents(Entity entity); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ts&amp;...&gt; getComponents(Entity entity) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, Args&amp;&amp;... args)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; component)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;BaseComponentContainer&gt;, ComponentCount&gt; mComponentContainers; EntityContainer&lt;ComponentCount, SystemCount&gt; mEntities; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;System&lt;ComponentCount, SystemCount&gt;&gt;&gt; mSystems; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkComponentType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkComponentTypes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponentContainer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponentContainer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre> <br>  <code>EntityManager</code>类具有三个成员变量： <code>mComponentContainers</code> （用于存储<code>std::unique_ptr</code> <code>BaseComponentContainer</code> <code>std::unique_ptr</code> ， <code>mEntities</code> （仅是<code>EntityContainer</code>的实例）和<code>mSystems</code> （用于存储指向<code>System</code> <code>unique_ptr</code>指针）。 <br><br> 一个类有很多方法，但实际上它们都很简单。 <br><br> 首先让我们看一下<code>getComponentContainer</code> ，它返回一个指向处理<code>T</code>类型组件的组件容器的指针： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponentContainer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;ComponentContainer&lt;T, ComponentCount, SystemCount&gt;*&gt;(mComponentContainers[T::type].get()); }</code> </pre> <br> 另一个辅助函数是<code>checkComponentType</code> ，它仅检查组件类型ID是否低于最大组件数： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkComponentType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(T::type &lt; ComponentCount); }</code> </pre> <br>  <code>checkComponentTypes</code>使用卷积表达式执行几种类型的检查： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkComponentTypes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ (checkComponentType&lt;Ts&gt;(), ...); }</code> </pre> <br>  <code>registerComponent</code>创建指定类型的组件的新容器： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); mComponentContainers[T::type] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;ComponentContainer&lt;T, ComponentCount, SystemCount&gt;&gt;( mEntities.getEntityToBitset()); }</code> </pre> <br>  <code>createSystem</code>创建指定类型的新系统并设置其类型： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createSystem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args&amp;&amp; ...args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> type = mSystems.size(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; system = mSystems.emplace_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;T&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...)); system-&gt;setUp(type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(system.get()); }</code> </pre> <br>  <code>reserve</code>方法调用<code>ComponentContainer</code>和<code>EntityContainer</code>的<code>reserve</code>方法： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); i &lt; ComponentCount; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mComponentContainers[i]) mComponentContainers[i]-&gt;reserve(size); } mEntities.reserve(size); }</code> </pre> <br>  <code>createEntity</code>方法返回<code>EntityManager</code>管理器的<code>create</code>方法的结果： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mEntities.create(); }</code> </pre> <br>  <code>hasComponent</code>使用一组实体位来快速验证该实体是否具有指定类型的组件： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mEntities.getBitset(entity)[T::type]; }</code> </pre> <br>  <code>hasComponents</code>使用卷积表达式创建一组表示所需组件的位，然后将其与实体的一组位一起使用以检查该实体是否具有所有必需的组件： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasComponents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ checkComponentTypes&lt;Ts...&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> requirements = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;(); (requirements.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(Ts::type), ...); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (requirements &amp; mEntities.getBitset(entity)) == requirements; }</code> </pre> <br>  <code>getComponent</code>将请求重定向到所需的组件容器： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getComponentContainer&lt;T&gt;()-&gt;get(entity); }</code> </pre> <br>  <code>getComponents</code>返回到请求的组件的链接的元组。 为此，它使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>std::tie</code></a>和一个卷积表达式： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Ts&amp;...&gt; getComponents(Entity entity) { checkComponentTypes&lt;Ts...&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie(getComponentContainer&lt;Ts&gt;()-&gt;get(entity)...); }</code> </pre> <br>  <code>addComponent</code>和<code>removeComponent</code>将请求重定向到所需的组件容器，然后调用<code>onEntityUpdated</code>系统<code>onEntityUpdated</code> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); getComponentContainer&lt;T&gt;()-&gt;add(entity, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); <span class="hljs-comment"><span class="hljs-comment">// Send message to systems const auto&amp; bitset = mEntities.getBitset(entity); for (auto&amp; system : mSystems) system-&gt;onEntityUpdated(entity, bitset); } template&lt;typename T&gt; void removeComponent(Entity entity) { checkComponentType&lt;T&gt;(); getComponentContainer&lt;T&gt;()-&gt;remove(entity); // Send message to systems const auto&amp; bitset = mEntities.getBitset(entity); for (auto&amp; system : mSystems) system-&gt;onEntityUpdated(entity, bitset); }</span></span></code> </pre> <br> 最后， <code>getOwner</code>将请求重定向到所需的容器组件： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; component)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getComponentContainer&lt;T&gt;()-&gt;getOwner(component); }</code> </pre> <br> 那是我的第一个实现。 它仅包含357行代码。 所有代码都可以在此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">线程中</a>找到。 <br><br><h1> 分析和基准 </h1><br><h2> 基准测试 </h2><br> 现在是对我的第一个ECS实施进行基准测试的时候了！ <br><br> 结果如下： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c9/fc6/23e/4c9fc623e0787518bde7823317b0e6af.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/323/9a9/bb03239a90cccf5f95ab47ecf94e3a4d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/679/e54/f0e/679e54f0e32260a9f62621838b51a15e.png"></div><br> 模板可伸缩！ 当增加实体数量并更改配置文件（A，AA和AAA）时，每秒处理的数量大约相同。 <br><br> 此外，随着实体中组件数量的增加，它可以很好地扩展。 当我们遍历具有三个组成部分的实体时，它们发生的速度比遍历具有一个组成部分的实体慢三倍。 这是可以预期的，因为我们需要获得三个组成部分。 <br><br><h2> 缓存未命中 </h2><br> 为了检查缓存未命中的数量，我运行了<a href="">从此处</a>获取的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cachegrind</a>示例。 <br><br> 这是10,000个实体的结果： <br><br> <code>==1652== D refs: 277,577,353 (254,775,159 rd + 22,802,194 wr) <br> ==1652== D1 misses: 20,814,368 ( 20,759,914 rd + 54,454 wr) <br> ==1652== LLd misses: 43,483 ( 7,847 rd + 35,636 wr) <br> ==1652== D1 miss rate: 7.5% ( 8.1% + 0.2% ) <br> ==1652== LLd miss rate: 0.0% ( 0.0% + 0.2% )</code> <br> <br> 这是100,000个实体的结果： <br><br> <code>==1738== D refs: 2,762,879,670 (2,539,368,564 rd + 223,511,106 wr) <br> ==1738== D1 misses: 207,415,181 ( 206,902,072 rd + 513,109 wr) <br> ==1738== LLd misses: 207,274,328 ( 206,789,289 rd + 485,039 wr) <br> ==1738== D1 miss rate: 7.5% ( 8.1% + 0.2% ) <br> ==1738== LLd miss rate: 7.5% ( 8.1% + 0.2% )</code> <br> <br> 结果很好。 为何在100,000个实体中有如此多的LLd未命中，这有点奇怪。 <br><br><h2> 剖析 </h2><br> 为了了解当前实现的哪些部分需要更长的时间，我使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gprof</a>对示例进行了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分析</a> 。 <br><br> 结果如下： <br><br> <code>Flat profile: <br> <br> Each sample counts as 0.01 seconds. <br> % cumulative self self total <br> time seconds seconds calls ms/call ms/call name <br> 57.45 1.16 1.16 200300000 0.00 0.00 std::__detail::_Map_base&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt;, true&gt;::operator[](unsigned int const&amp;) <br> 19.31 1.55 0.39 main <br> 16.34 1.88 0.33 200500000 0.00 0.00 std::_Hashtable&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt; &gt;::_M_find_before_node(unsigned long, unsigned int const&amp;, unsigned long) const <br> 3.96 1.96 0.08 300000 0.00 0.00 std::_Hashtable&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt; &gt;::_M_insert_unique_node(unsigned long, unsigned long, std::__detail::_Hash_node&lt;std::pair&lt;unsigned int const, unsigned int&gt;, false&gt;*) <br> 2.48 2.01 0.05 300000 0.00 0.00 unsigned int&amp; std::vector&lt;unsigned int, std::allocator&lt;unsigned int&gt; &gt;::emplace_back&lt;unsigned int&amp;&gt;(unsigned int&amp;) <br> 0.50 2.02 0.01 3 3.33 3.33 std::_Hashtable&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt; &gt;::~_Hashtable() <br> 0.00 2.02 0.00 200000 0.00 0.00 std::_Hashtable&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt; &gt;::find(unsigned int const&amp;)</code> <br> <br> 结果可能有些失真，因为我使用<code>-O1</code>标志进行了编译， <code>-O1</code> gprof <code>-O1</code>有意义的内容。 看来，当提高优化级别时，编译器开始积极嵌入所有内容，而gprof几乎什么也没说。 <br><br> 根据gprof的说法，此实现中的明显瓶颈是<code>std::unordered_map</code> 。 如果我们想对其进行优化，那么就值得尝试摆脱它们。 <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 与之比较 </font></font><code>std::map</code> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我开始好奇中之间的性能差异</font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，所以我改变了代码全部</font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上</font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">了</font></a><font style="vertical-align: inherit;">该实现，</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下面是基准测试结果：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/611/50b/3da/61150b3da1ec1cf850a0ed5b761f03a1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/136/3be/951/1363be95163a3dfb2ab968c1591c7c60.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d08/b4b/7f1/d08b4b7f1b5b35531bdc32a614ccbb81.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以看到，这次随着实体数量的增加，实现无法很好地扩展。</font><font style="vertical-align: inherit;">即使有1000个实体，其迭代速度也是版本c的两倍</font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h1> 结论 </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们已经创建了一个简单但已经实用的实体-组件-系统模板库。</font><font style="vertical-align: inherit;">将来，我们将以此为基础进行改进和优化。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在下一节中，我们将展示如何通过替代来提高生产力</font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上</font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此外，我们将展示如何自动将ID类型分配给组件。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用std :: vector替换std :: unordered_map </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正如我们所看到的，它们</font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是我们实施的瓶颈。</font><font style="vertical-align: inherit;">因此，而不是</font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用</font></font><code>mEntityToComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到</font></font><code>ComponentContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>mEntityToManagedEntity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到</font></font><code>System</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">载体</font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 变化 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改将非常简单，您可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看它们</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">唯一的精妙之处在于一个事实，即</font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><code>mEntityToComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>mEntityToManagedEntity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已经足够长，以指数的任何实体。</font><font style="vertical-align: inherit;">为此，我决定将它们存储</font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在中</font></font><code>EntityContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在其中我们知道实体的最大ID。</font><font style="vertical-align: inherit;">然后，我通过</font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实体管理器中的引用或指针</font><font style="vertical-align: inherit;">将向量传递到</font><font style="vertical-align: inherit;">组件容器。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">修改后的代码可以在此</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线程中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到</font><font style="vertical-align: inherit;">。</font></font><br><br><h2> 结果 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 让我们检查一下该版本比上一个版本如何更好地工作： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38a/1df/4bd/38a1df4bd3c8110d3873588854ffc314.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/897/2ae/0f58972ae408b9726899597fbd774be1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22b/3f5/fcd/22b3f5fcd21c8285cc779f46ca3896a4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如您所见，使用大量组件和系统进行创建和删除变得有点</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">慢。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，迭代速度快了十倍！</font><font style="vertical-align: inherit;">而且扩展性非常好。</font><font style="vertical-align: inherit;">这种速度大大超过了创建和删除的速度。</font><font style="vertical-align: inherit;">这是合乎逻辑的：实体的迭代将发生多次，但仅创建和删除一次。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在让我们看看这是否减少了高速缓存未命中的次数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是具有10,000个实体的cachegrind的输出：</font><font style="vertical-align: inherit;">这是100,000个实体的输出：</font><font style="vertical-align: inherit;">我们看到此版本创建的链接减少了大约三倍，高速缓存未命中次数减少了四倍。</font></font><br><br> <code>==1374== D refs: 94,563,949 (72,082,880 rd + 22,481,069 wr) <br> ==1374== D1 misses: 4,813,780 ( 4,417,702 rd + 396,078 wr) <br> ==1374== LLd misses: 378,905 ( 9,626 rd + 369,279 wr) <br> ==1374== D1 miss rate: 5.1% ( 6.1% + 1.8% ) <br> ==1374== LLd miss rate: 0.4% ( 0.0% + 1.6% )</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>==1307== D refs: 938,405,796 (715,424,940 rd + 222,980,856 wr) <br> ==1307== D1 misses: 51,034,738 ( 44,045,090 rd + 6,989,648 wr) <br> ==1307== LLd misses: 5,866,508 ( 1,997,948 rd + 3,868,560 wr) <br> ==1307== D1 miss rate: 5.4% ( 6.2% + 3.1% ) <br> ==1307== LLd miss rate: 0.6% ( 0.3% + 1.7% )</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 自动类型 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我要讨论的最后一个改进是自动生成组件类型标识符。 </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 变化 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到用于实现ID类型自动生成的所有更改</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，为了能够为每种类型的组件分配一个唯一的ID，您需要使用CRTP和带有静态计数器的函数：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> type; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> generateComponentType() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> counter = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Component&lt;T&gt;::type = generateComponentType();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可能会注意到类型ID现在是在运行时生成的，以前在编译时就已知道。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改后的代码可以在此</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线程中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到</font><font style="vertical-align: inherit;">。</font></font><br><br><h2> 结果 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为了测试此版本的性能，我进行了基准测试： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bd/112/0da/7bd1120da37daac5e3ef48446776b6e7.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/234/f2f/937/234f2f9377a0f3ad8ea231f91e335ddf.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/101/4f2/ade/1014f2adebd6156bc48c9b6fe5670b43.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于创建和删除，结果大致相同。</font><font style="vertical-align: inherit;">但是，您可以看到迭代速度变慢了一点，大约10％。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以通过编译器在编译时知道类型标识符这一事实来解释这种速度下降，这意味着它可以更好地优化代码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手动分配ID类型有点不方便，并且可能导致错误。</font><font style="vertical-align: inherit;">因此，即使我们稍微降低了性能，它仍然是ECS库可用性的改进。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 进一步改进的想法 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在结束本文之前，我想与您分享其他改进的想法。</font><font style="vertical-align: inherit;">到目前为止，我还没有实现它们，但也许将来会实现。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 组件和系统的动态数量 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事先以模板参数的形式指示组件和系统的最大数量是不方便的。</font><font style="vertical-align: inherit;">我认为这将有可能取代</font></font><code>std::array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><code>EntityManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对</font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有强大的性能下降。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，它</font></font><code>std::bitset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要在编译时知道位数。</font><font style="vertical-align: inherit;">虽然我想纠正通过更换这个问题</font></font><code>std::vector&lt;bitset&lt;ComponentCount&gt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><code>EntityContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上</font></font><code>std::vector&lt;char&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并释放出足够的字节数来表示所有实体的位集合。</font><font style="vertical-align: inherit;">然后，我们实现一个轻量级类</font></font><code>BitsetView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该类</font><font style="vertical-align: inherit;">在输入处接收一对指向该位集合的开始和结束的指针，然后</font></font><code>std::bitset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此存储范围内</font><font style="vertical-align: inherit;">执行所有必要的操作</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个想法：不再使用位集，而是检查</font></font><code>mEntityToComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实体是否具有组件。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 简化的组件迭代 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 目前，如果系统要迭代处理其处理的实体的组件，则需要这样做： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; entity : getManagedEntities()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [position, velocity] = mEntityManager.getComponents&lt;Position, Velocity&gt;(entity); ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果我们可以做这样的事情，那将是更漂亮，更简单的： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [position, velocity] : mEntityManager.getComponents&lt;Position, Velocity&gt;(mManagedEntities)) { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">借助</font></font><code>std::view::transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 20 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的ranges库</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">将更容易实现这一点</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不幸的是，它还不存在。</font><font style="vertical-align: inherit;">我可以使用</font><font style="vertical-align: inherit;">Eric Nibler的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">范围库</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是我不想添加依赖项。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案可能是实现一个类</font></font><code>EntityRangeView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该类</font><font style="vertical-align: inherit;">将接收需要接收的组件类型作为模板参数，并使用</font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实体</font><font style="vertical-align: inherit;">引用作为构造函数参数</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后，我们将不得不才意识到</font></font><code>begin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>end</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和迭代器类型，以实现所需的行为。</font><font style="vertical-align: inherit;">这不是很困难，但是会花费一些时间。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 活动管理优化 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在当前的实现中，当从实体中添加或删除组件时，我们称</font></font><code>onEntityUpdated</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有系统。</font><font style="vertical-align: inherit;">这有点效率低下，因为许多系统对刚刚更改的组件类型不感兴趣。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了最大程度地减少破坏，我们可以存储指向对数据结构中指定类型的组件感兴趣的系统的指针，例如</font></font><code>std::array&lt;std::vector&lt;System&lt;ComponentCount, SystemCount&gt;&gt;, ComponentCount&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后，在添加或删除组件时，我们只需调用</font></font><code>onEntityUpdated</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对该组件感兴趣</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">系统</font><font style="vertical-align: inherit;">方法即可</font><font style="vertical-align: inherit;">。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 由实体管理器而非系统管理的实体子集 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我的最后一个想法将导致图书馆结构的更广泛的变化。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代替管理其实体集的系统，实体管理器可以做到这一点。这种方案的优势在于，如果两个系统对一组组件感兴趣，我们不会复制满足这些要求的实体子集。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统可以简单地向实体经理声明其要求。然后，实体管理器将存储实体的所有不同子集。最后，系统将使用类似的语法查询实体：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; entity : mEntityManager.getEntitiesWith&lt;Position, Velocity&gt;()) { ... }</code> </pre> <br><h1> 结论 </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，这是关于我的实体组件系统实现的文章的结尾。</font><font style="vertical-align: inherit;">如果我进行其他改进，将来可能会写新文章。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本文中描述的实现非常简单：它由少于500行代码组成，并且具有良好的性能。</font><font style="vertical-align: inherit;">所有交易均在固定时间内（摊销）实现。</font><font style="vertical-align: inherit;">此外，在实践中，它最佳地使用了缓存并非常快速地接收和迭代实体。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我希望这篇文章对您很有意思甚至有用。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 补充阅读 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 以下是一些有用的资源，可用于更深入地研究实体组件系统模式： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">米歇尔该隐，笔者</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，写了一个非常有趣的一系列关于所谓的实体组件系统文章</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的ECS回往复</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实体系统Wiki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含非常有用的信息和链接。</font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN459288/">https://habr.com/ru/post/zh-CN459288/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN459274/index.html">Astra Linux特别版（Smolensk）中的屏幕锁定漏洞</a></li>
<li><a href="../zh-CN459276/index.html">史诗般的抗故障能力2或为何不应该使用FireFox插件来参与隐私保护</a></li>
<li><a href="../zh-CN459280/index.html">为什么开发人员喜欢构建本机应用程序？</a></li>
<li><a href="../zh-CN459284/index.html">产品策略和功能优先级简介</a></li>
<li><a href="../zh-CN459286/index.html">半金属碲化钨-纳米技术日的瑞士刀</a></li>
<li><a href="../zh-CN459292/index.html">移动应用测试自动化：工具比较</a></li>
<li><a href="../zh-CN459294/index.html">更重要的是：了解编程语言或能够解决业务问题？</a></li>
<li><a href="../zh-CN459296/index.html">JavaScript价格2019</a></li>
<li><a href="../zh-CN459298/index.html">Angular：2019年状态</a></li>
<li><a href="../zh-CN459300/index.html">Quasar 1.0：Vue开发人员的新实用工具，不仅限于他们</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>