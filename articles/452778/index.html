<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíü üôéüèæ üéª C√≥mo acelerar la descarga de LZ4 en ClickHouse üßôüèæ üå°Ô∏è üë®üèæ‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Al ejecutar consultas en ClickHouse, puede observar que en el generador de perfiles, en uno de los primeros lugares, la funci√≥n LZ_decompress_fast a m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo acelerar la descarga de LZ4 en ClickHouse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/452778/"> Al ejecutar consultas en ClickHouse, puede observar que en el generador de perfiles, en uno de los primeros lugares, la funci√≥n LZ_decompress_fast a menudo es visible.  ¬øPor qu√© est√° pasando esto?  Esta pregunta se convirti√≥ en la raz√≥n de todo el estudio sobre la elecci√≥n del mejor algoritmo de descompresi√≥n.  Aqu√≠ publico todo el estudio, y la versi√≥n corta se puede encontrar en mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe</a> sobre HighLoad ++ Siberia. <br><br>  Los datos de ClickHouse se almacenan en forma comprimida.  Y durante la ejecuci√≥n de las solicitudes, ClickHouse intenta hacer casi nada: utilizar un m√≠nimo de recursos de la CPU.  Sucede que todos los c√°lculos que podr√≠an llevar un tiempo ya est√°n bien optimizados, y la solicitud est√° bien escrita por el usuario.  Luego queda realizar el lanzamiento. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/057/302/aba/057302aba5041790af404c2c781c4dd3.png"><br><br>  La pregunta es: ¬øpor qu√© la descarga de LZ4 puede ser un cuello de botella?  Parece que LZ4 es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algoritmo muy liviano</a> : la tasa de compresi√≥n, dependiendo de los datos, generalmente var√≠a de 1 a 3 GB / s por n√∫cleo de procesador.  Esto es significativamente m√°s que la velocidad del subsistema de disco.  Adem√°s, utilizamos todos los n√∫cleos disponibles, y la expansi√≥n se escala linealmente en todos los n√∫cleos f√≠sicos. <br><a name="habracut"></a><br>  Pero hay dos puntos a tener en cuenta.  En primer lugar, los datos comprimidos se leen del disco y la tasa de compresi√≥n se da en la cantidad de datos sin comprimir.  Si la relaci√≥n de compresi√≥n es lo suficientemente grande, entonces no es necesario leer casi nada de los discos.  Pero al mismo tiempo, se generan muchos datos comprimidos y, por supuesto, esto afecta el consumo de la CPU: la cantidad de trabajo de compresi√≥n de datos en el caso de LZ4 es casi proporcional al volumen de los datos comprimidos. <br><br>  En segundo lugar, es posible que no sea necesario leer los datos de los discos si los datos est√°n en la cach√©.  Para hacer esto, puede confiar en la memoria cach√© de la p√°gina o usar su propia memoria cach√©.  En una base de datos de columnas, el uso de la memoria cach√© es m√°s eficiente debido al hecho de que no todas las columnas caen en √©l, sino solo las que se usan con frecuencia.  Es por eso que LZ4, en t√©rminos de carga de CPU, a menudo es un cuello de botella. <br><br>  De ah√≠ dos preguntas m√°s.  Si la compresi√≥n de datos "se ralentiza", ¬øtal vez no deber√≠an comprimirse en absoluto?  Pero en la pr√°ctica, esta suposici√≥n no tiene sentido.  Recientemente en ClickHouse fue posible configurar solo dos opciones de compresi√≥n de datos: LZ4 y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Zstandard</a> .  El valor predeterminado es LZ4.  Al cambiar a Zstandard, puede hacer que la compresi√≥n sea m√°s fuerte y m√°s lenta.  Pero hasta hace poco era imposible desactivar por completo la compresi√≥n: LZ4 se considera un m√≠nimo razonable, que siempre se puede usar.  Es por eso que realmente amo el LZ4.  :) <br><br>  Pero recientemente, un extra√±o misterioso apareci√≥ en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chat de chat de</a> habla inglesa ClickHouse, quien dijo que tiene un subsistema de disco muy r√°pido (NVMe SSD) y que todo depende de la compresi√≥n; ser√≠a bueno poder apagarlo.  Respond√≠ que no existe tal posibilidad, pero es f√°cil de agregar.  Unos d√≠as m√°s tarde, recibimos una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solicitud de grupo</a> , que implementa el m√©todo de compresi√≥n <code>none</code> .  Pregunt√© por los resultados: cu√°nto ayud√≥ esto, qu√© tan r√°pido las solicitudes.  La persona dijo que esta nueva caracter√≠stica result√≥ in√∫til en la pr√°ctica, ya que los datos sin compresi√≥n comenzaron a ocupar demasiado espacio. <br><br>  La segunda pregunta que surge es: si hay un cach√©, ¬øpor qu√© no almacenar los datos ya sin comprimir en √©l?  Esto est√° permitido: en muchos casos ser√° posible deshacerse de la necesidad de descompresi√≥n.  Y en ClickHouse hay una cach√© de este tipo: una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cach√© de bloques expandidos</a> .  Pero es una pena gastar mucha RAM en √©l debido a su baja eficiencia.  Se justifica solo en solicitudes peque√±as y consecutivas que utilizan casi los mismos datos. <br><br>  Consideraci√≥n general: los datos deben comprimirse, preferiblemente siempre.  Siempre gr√°belos en un disco comprimido.  Transmita por la red tambi√©n con compresi√≥n.  En mi opini√≥n, la compresi√≥n predeterminada debe considerarse justificada incluso cuando se transfiere a una red de 10 gigabits sin suscribirse en exceso dentro del centro de datos, y la transferencia de datos sin compresi√≥n entre centros de datos es generalmente inaceptable. <br><br><h3>  ¬øPor qu√© LZ4? </h3><br>  ¬øPor qu√© se usa LZ4?  ¬øEs posible elegir algo a√∫n m√°s f√°cil?  En principio, es posible, y es correcto y √∫til.  Pero primero veamos a qu√© clase de algoritmos pertenece LZ4. <br><br>  En primer lugar, no depende del tipo de datos.  Por ejemplo, si sabe de antemano que tendr√° una serie de enteros, puede usar una de las muchas variantes del algoritmo VarInt: ser√° m√°s eficiente en la CPU.  En segundo lugar, LZ4 no depende demasiado de los supuestos requeridos en el modelo de datos.  Suponga que tiene una serie temporal ordenada de lecturas de sensores: una matriz con n√∫meros de tipo flotante.  Luego puede calcular los deltas y luego comprimir a√∫n m√°s, y esto ser√° m√°s eficiente en t√©rminos de relaci√≥n de compresi√≥n. <br><br>  Es decir, LZ4 se puede usar sin problemas para cualquier conjunto de bytes, para cualquier archivo.  Por supuesto, √©l tiene su propia especializaci√≥n (m√°s sobre eso a continuaci√≥n), y en algunos casos su uso no tiene sentido.  Pero si lo llama un algoritmo de prop√≥sito general, este ser√° un peque√±o error.  Y tenga en cuenta que, gracias al dispositivo interno, LZ4 implementa autom√°ticamente el algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RLE</a> como un caso especial. <br><br>  Otra pregunta: ¬øes LZ4 el algoritmo m√°s √≥ptimo de esta clase para la combinaci√≥n de velocidad y fuerza de compresi√≥n?  Dichos algoritmos se denominan pareto fronterizo; esto significa que no hay otro algoritmo que sea estrictamente mejor en un indicador y no peor en otros (e incluso en una amplia variedad de conjuntos de datos).  Hay algoritmos que son m√°s r√°pidos, pero dan una relaci√≥n de compresi√≥n m√°s baja, y hay aquellos que comprimen m√°s, pero al mismo tiempo comprimen o descomprimen m√°s lentamente. <br><br>  De hecho, el LZ4 no es una frontera pareto.  Hay opciones que son un poco mejores.  Por ejemplo, esto es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LZTURBO</a> de un cierto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">powturbo</a> .  No hay dudas sobre la fiabilidad de los resultados gracias a la comunidad en encode.ru (el foro m√°s grande y aproximadamente el √∫nico para la compresi√≥n de datos).  Pero el desarrollador no distribuye el c√≥digo fuente o los archivos binarios, sino que solo los entrega a un c√≠rculo limitado de personas para que los prueben o paguen mucho dinero (como nadie ha pagado hasta ahora).  Tambi√©n vale la pena prestar atenci√≥n a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lizard</a> (anteriormente LZ5) y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Density</a> .  Pueden funcionar un poco mejor que LZ4 al elegir alg√∫n nivel de compresi√≥n.  Tambi√©n preste atenci√≥n a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LZSSE</a> , algo extremadamente interesante.  Sin embargo, es mejor mirarlo despu√©s de leer este art√≠culo. <br><br><h3>  ¬øC√≥mo funciona LZ4? </h3><br>  Veamos c√≥mo funciona LZ4 en general.  Esta es una de las implementaciones del algoritmo LZ77: L y Z indican los nombres de los autores (Lempel y Ziv), y 77 - en 1977, cuando se public√≥ el algoritmo.  Tiene muchas otras implementaciones: QuickLZ, FastLZ, BriefLZ, LZF, LZO, as√≠ como gzip y zip cuando se usan bajos niveles de compresi√≥n. <br><br>  Un bloque de datos comprimido usando LZ4 contiene una secuencia de registros (comandos, instrucciones) de dos tipos: <br><br><ol><li>  Literal: "tome los siguientes N bytes tal como est√°n y c√≥pielos en el resultado". </li><li>  Coincidencia (coincidencia): "tomar N bytes que ya fueron descomprimidos por el desplazamiento de la posici√≥n actual". </li></ol><br>  Un ejemplo  Antes de la compresi√≥n: <br> <code>Hello world Hello</code> <br> <br>  Despu√©s de la compresi√≥n: <br> <code>literals 12 "Hello world " match 5 12</code> <br> <br>  Si tomamos un bloque comprimido y lo atravesamos con el cursor, ejecutando estos comandos, obtendremos los datos iniciales sin comprimir como resultado. <br><br>  Analizamos aproximadamente c√≥mo se descomprimen los datos.  El punto tambi√©n est√° claro: para realizar la compresi√≥n, el algoritmo codifica secuencias de bytes repetidas utilizando coincidencias. <br><br>  Claro y algunas propiedades.  Este algoritmo est√° orientado a bytes: no disecciona bytes individuales, sino que solo los copia en su totalidad.  Aqu√≠ radica la diferencia, por ejemplo, de la codificaci√≥n de entrop√≠a.  Por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">zstd</a> es una composici√≥n de LZ77 y codificaci√≥n de entrop√≠a. <br><br>  Tenga en cuenta que el tama√±o del bloque comprimido no se elige demasiado grande para no gastar mucha RAM durante la descarga;  para no ralentizar el acceso aleatorio en un archivo comprimido (que consta de muchos bloques comprimidos);  y a veces para que el bloque quepa en alg√∫n cach√© de la CPU.  Por ejemplo, puede elegir 64 KB, por lo que las memorias intermedias para datos comprimidos y sin comprimir se ajustar√°n en la cach√© L2 y quedar√° la mitad. <br><br>  Si necesitamos comprimir un archivo m√°s grande, simplemente concatenaremos los bloques comprimidos.  Al mismo tiempo, al lado de cada bloque comprimido, es conveniente colocar datos adicionales: tama√±os, suma de verificaci√≥n. <br><br>  El desplazamiento m√°ximo para el partido es limitado, en LZ4 - 64 kilobytes.  Este valor se llama ventana deslizante.  De hecho, esto significa que a medida que el cursor avanza, las coincidencias pueden estar en una ventana de 64 kilobytes de tama√±o con respecto al cursor, que se mueve con el cursor. <br><br>  Ahora veamos c√≥mo comprimir datos, en otras palabras, c√≥mo encontrar secuencias coincidentes en un archivo.  Por supuesto, puedes usar el sufijo trie (genial si has o√≠do hablar de √©l).  Hay opciones en las que se garantiza que la secuencia de coincidencia m√°s larga se encuentre entre los bytes anteriores en el proceso de compresi√≥n.  Esto se llama an√°lisis √≥ptimo y proporciona una relaci√≥n de compresi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">casi</a> mejor para un formato de bloque comprimido fijo.  Pero hay opciones m√°s efectivas, cuando encontramos una buena coincidencia en los datos, pero no necesariamente la m√°s larga.  La forma m√°s eficiente de encontrarlo es usar una tabla hash. <br><br>  Para hacer esto, atravesamos el bloque de datos de origen con el cursor y tomamos algunos bytes despu√©s del cursor.  Por ejemplo, 4 bytes.  Hash y coloque en la tabla hash el desplazamiento desde el comienzo del bloque, donde se reunieron estos 4 bytes.  El valor 4 se llama min-match: con la ayuda de dicha tabla hash podemos encontrar coincidencias de al menos 4 bytes. <br><br>  Si miramos la tabla hash, y ya hay un registro all√≠, y si el desplazamiento no excede la ventana deslizante, entonces verificamos cu√°ntos bytes m√°s coinciden despu√©s de estos cuatro bytes.  Quiz√°s haya mucho m√°s que coincida.  Tambi√©n es posible que se haya producido una colisi√≥n en la tabla hash y que nada coincida.  Esto es normal: simplemente puede reemplazar el valor en la tabla hash por uno nuevo.  Las colisiones en la tabla hash simplemente resultar√°n en una relaci√≥n de compresi√≥n m√°s baja ya que hay menos coincidencias.  Por cierto, este tipo de tabla hash (de tama√±o fijo y sin resoluci√≥n de colisi√≥n) se denomina tabla de cach√©, tabla de cach√©.  Esto tambi√©n es l√≥gico: en caso de colisi√≥n, la tabla de cach√© simplemente olvida el registro anterior. <br><blockquote>  La tarea para el lector atento.  Deje que los datos sean una matriz de n√∫meros como UInt32 en formato little endian, que es parte de una secuencia de n√∫meros naturales: 0, 1, 2 ... Explique por qu√© al usar LZ4 estos datos no est√°n comprimidos (la cantidad de datos comprimidos no es menor que la cantidad de datos sin comprimir). </blockquote><h3>  C√≥mo acelerar las cosas </h3><br>  Entonces, quiero acelerar la descarga de LZ4.  Veamos c√≥mo es el ciclo de descarga.  Aqu√≠ est√° el bucle en pseudoc√≥digo: <br><br><pre>  mientras que (...)
 {
     leer (input_pos, literal_length, match_length);<font></font>
<font></font>
     copia (output_pos, input_pos, literal_length);
     output_pos + = literal_length;<font></font>
<font></font>
     leer (input_pos, match_offset);<font></font>
<font></font>
     copy (output_pos, output_pos - match_offset,
         match_length);
     output_pos + = match_length;
 } </pre><br>  El formato LZ4 est√° dise√±ado para que los literales y las coincidencias se alternen en un archivo comprimido.  Y obviamente, el literal siempre viene primero (porque desde el principio el partido no tiene a d√≥nde ir).  Por lo tanto, sus longitudes est√°n codificadas juntas. <br><br>  De hecho, todo es un poco m√°s complicado.  Se lee un byte del archivo y se toman dos mordiscos, en los que se codifican los n√∫meros del 0 al 15. Si el n√∫mero correspondiente no es igual a 15, se considera la longitud del literal y la coincidencia, respectivamente.  Y si es 15, entonces la longitud es m√°s larga y est√° codificada en los siguientes bytes.  Luego se lee el siguiente byte y su valor se agrega a la longitud.  Adem√°s, si es igual a 255, entonces continuamos: leemos el siguiente byte de la misma manera. <br><br>  Tenga en cuenta que la relaci√≥n de compresi√≥n m√°xima para el formato LZ4 no alcanza 255. Y la segunda observaci√≥n (in√∫til): si sus datos son muy redundantes, el uso de LZ4 aumentar√° el doble de la relaci√≥n de compresi√≥n. <br><br>  Cuando leemos la longitud del literal (y luego tambi√©n la duraci√≥n de la coincidencia y el desplazamiento de la coincidencia), para destrabar es suficiente simplemente copiar dos piezas de memoria. <br><br><h3>  C√≥mo copiar un trozo de memoria </h3><br>  Parece que puede usar la funci√≥n <code>memcpy</code> , que est√° dise√±ada para copiar fragmentos de memoria.  Pero esto no es √≥ptimo y sigue siendo incorrecto. <br><br>  ¬øPor qu√© el uso de la funci√≥n memcpy es sub√≥ptimo?  Porque ella: <br><br><ol><li>  generalmente ubicado en la biblioteca libc (y la biblioteca libc generalmente se vincula din√°micamente, y la llamada a memcpy se realizar√° indirectamente, a trav√©s de PLT), </li><li>  no est√° en l√≠nea con el argumento de tama√±o desconocido en tiempo de compilaci√≥n, </li><li>  hace un gran esfuerzo para procesar correctamente las "colas" de un fragmento de memoria que no son m√∫ltiples del tama√±o de una palabra o registro de m√°quina. </li></ol><br>  El √∫ltimo punto es el m√°s importante.  Supongamos que le pedimos a la funci√≥n memcpy que copie exactamente 5 bytes.  Ser√≠a muy bueno copiar 8 bytes a la vez, utilizando dos instrucciones movq para esto. <br><br> <code>Hello world <font color="#0fc000">Hello</font> <font color="#ff0000">wo</font> ... <br> ^^^^^ <font color="#ff0000">^^^</font> - src <br> ^^^^^ <font color="#ff0000">^^^</font> - dst</code> <br> <br>  Pero luego copiaremos tres bytes adicionales, es decir, escribiremos en el extranjero el b√∫fer transferido.  La funci√≥n <code>memcpy</code> no tiene derecho a hacer esto; de hecho, debido a que sobrescribiremos algunos datos en nuestro programa, habr√° un "paso" de la memoria.  Y si escribimos en una direcci√≥n no alineada, entonces estos bytes adicionales pueden ubicarse en una p√°gina de memoria virtual no asignada o en una p√°gina sin acceso de escritura.  Entonces obtenemos segfault (eso es bueno). <br><br>  Pero en nuestro caso, casi siempre podemos escribir bytes adicionales.  Podemos leer bytes adicionales en el b√∫fer de entrada siempre que los bytes adicionales se encuentren en √©l por completo.  En las mismas condiciones, podemos escribir bytes adicionales en el b√∫fer de salida, porque en la pr√≥xima iteraci√≥n los sobrescribiremos de todos modos. <br><br>  Esta optimizaci√≥n ya est√° en la implementaci√≥n original de LZ4: <br><br><pre>  copia anulada en l√≠nea8 (UInt8 * dst, const UInt8 * src)
 {
     memcpy (dst, src, 8);  /// En realidad, memcpy no se llama aqu√≠.
 }<font></font>
<font></font>
 inline void wildCopy8 (UInt8 * dst, const UInt8 * src, UInt8 * dst_end)
 {
     hacer
     {
         copy8 (dst, src);
         dst + = 8;
         src + = 8;
     } while (dst &lt;dst_end);
 } </pre><br>  Para aprovechar esta optimizaci√≥n, solo necesita verificar que estamos lo suficientemente lejos del borde del b√∫fer.  Esto deber√≠a ser gratuito, porque ya verificamos que se superen los l√≠mites del b√∫fer.  Y el procesamiento de los √∫ltimos bytes, la "cola" de los datos, se puede hacer despu√©s del bucle principal. <br><br>  Sin embargo, todav√≠a hay algunas sutilezas.  Hay dos copias en el ciclo: literal y coincidente.  Pero cuando se usa la funci√≥n LZ4_decompress_fast (en lugar de LZ4_decompress_safe), la verificaci√≥n se realiza una vez, cuando necesitamos copiar el literal.  Al copiar una coincidencia, la verificaci√≥n no se realiza, pero en la <a href="">especificaci√≥n del formato LZ4</a> hay condiciones que permiten evitarla: <br><br><blockquote>  Los √∫ltimos 5 bytes son siempre literales. <br>  La √∫ltima coincidencia debe comenzar al menos 12 bytes antes del final del bloque. <br>  En consecuencia, un bloque con menos de 13 bytes no se puede comprimir. </blockquote><br>  Los datos de entrada especialmente seleccionados pueden causar una unidad de memoria.  Si utiliza la funci√≥n LZ4_decompress_fast, necesita protecci√≥n contra datos incorrectos.  Los datos comprimidos deben ser al menos una suma de verificaci√≥n.  Y si necesita protecci√≥n contra un atacante, use la funci√≥n LZ4_decompress_safe.  Otras opciones: tomar una funci√≥n hash criptogr√°fica como suma de verificaci√≥n, pero casi seguramente matar√° todo el rendimiento;  o bien asignar m√°s memoria para buffers;  asignar memoria para buffers con una llamada separada a mmap y crear una p√°gina de protecci√≥n. <br><br>  Cuando veo un c√≥digo que copia datos de 8 bytes, inmediatamente pregunto: ¬øpor qu√© exactamente 8 bytes?  Puede copiar 16 bytes utilizando registros SSE: <br><br><pre>  copia vac√≠a en l√≠nea 16 (UInt8 * dst, const UInt8 * src)
 {
 #if __SSE2__
     _mm_storeu_si128 (reinterpret_cast &lt;__ m128i *&gt; (dst),
         _mm_loadu_si128 (reinterpret_cast &lt;const __m128i *&gt; (src)));
 #else
     memcpy (dst, src, 16);
 #endif
 }<font></font>
<font></font>
 inline void wildCopy16 (UInt8 * dst, const UInt8 * src, UInt8 * dst_end)
 {
     hacer
     {
         copy16 (dst, src);
         dst + = 16;
         src + = 16;
     } while (dst &lt;dst_end);
 } </pre><br>  Copiar 32 bytes para AVX y 64 bytes para AVX-512 funciona de manera similar.  Adem√°s, puede ampliar el ciclo varias veces.  Si alguna vez has visto c√≥mo <code>memcpy</code> implementa <code>memcpy</code> , este es exactamente el enfoque.  (Por cierto, el compilador en este caso no expandir√° ni vectorizar√° el ciclo: esto requerir√° la inserci√≥n de controles engorrosos). <br><br>  ¬øPor qu√© esto no se hace en la implementaci√≥n original de LZ4?  En primer lugar, no es obvio si esto es mejor o peor.  El resultado depende de los tama√±os de los fragmentos que deben copiarse.  De repente, todos son cortos y el trabajo extra ser√° in√∫til.  Y en segundo lugar, destruye esas condiciones en el formato LZ4 que le permiten evitar un brunch innecesario en el bucle interno. <br><br>  Sin embargo, tendremos en cuenta esta opci√≥n por ahora. <br><br><h3>  Copia dif√≠cil </h3><br>  Volviendo a la pregunta: ¬øsiempre es posible copiar datos de esta manera?  Supongamos que necesitamos copiar una coincidencia, es decir, copiar un trozo de memoria del b√∫fer de salida que est√° en alg√∫n desplazamiento detr√°s del cursor a la posici√≥n de este cursor. <br><br>  Imagine un caso simple: debe copiar 5 bytes en el desplazamiento 12: <br><br> <code><font color="#0fc000">Hello</font> world ........... <br> ^^^^^ - src <br> ^^^^^ - dst <br> <br> Hello world <font color="#0fc000">Hello</font> <font color="#a8a8a8">wo</font> ... <br> ^^^^^ - src <br> ^^^^^ - dst</code> <br> <br>  Pero hay un caso m√°s complicado: cuando necesitamos copiar una pieza de memoria cuya longitud es mayor que el desplazamiento.  Es decir, indica parcialmente datos que a√∫n no se han escrito en el b√∫fer de salida. <br><br>  Copie 10 bytes en el desplazamiento 3: <br><br> <code><font color="#0fc000">abc</font> ............. <br> ^^^^^^^^^^ - src <br> ^^^^^^^^^^ - dst <br> <br> abc <font color="#0fc000">abcabcabca</font> ... <br> ^^^^^^^^^^ - src <br> ^^^^^^^^^^ - dst</code> <br> <br>  En el proceso de compresi√≥n, tenemos todos los datos, y tal coincidencia bien se puede encontrar.  La funci√≥n <code>memcpy</code> no es adecuada para copiarla: no admite el caso cuando los rangos de fragmentos de memoria se cruzan.  Por cierto, la funci√≥n <code>memmove</code> tampoco es adecuada, porque el fragmento de memoria de donde obtener los datos a√∫n no est√° completamente inicializado.  Debe copiar como si estuvi√©ramos copiando por byte. <br><br><pre>  op [0] = partido [0];
 op [1] = partido [1];
 op [2] = partido [2];
 op [3] = partido [3];
 ... </pre><br><br>  As√≠ es como funciona: <br><br> <code><font color="#0fc000">a</font> bc <font color="#0fc000">a</font> ............ <br> ^ - src <br> ^ - dst <br> <br> a <font color="#0fc000">b</font> ca <font color="#0fc000">b</font> ........... <br> ^ - src <br> ^ - dst <br> <br> ab <font color="#0fc000">c</font> ab <font color="#0fc000">c</font> .......... <br> ^ - src <br> ^ - dst <br> <br> abc <font color="#0fc000">a</font> bc <font color="#0fc000">a</font> ......... <br> ^ - src <br> ^ - dst <br> <br> abca <font color="#0fc000">b</font> ca <font color="#0fc000">b</font> ........ <br> ^ - src <br> ^ - dst</code> <br> <br>  Es decir, debemos crear una secuencia repetitiva.  En la implementaci√≥n original de LZ4, se escribi√≥ un c√≥digo sorprendentemente incomprensible para esto: <br><br><pre>  const unsigned dec32table [] = {0, 1, 2, 1, 4, 4, 4, 4};
 const int dec64table [] = {0, 0, 0, -1, 0, 1, 2, 3};<font></font>
<font></font>
 const int dec64 = dec64table [offset];
 op [0] = partido [0];
 op [1] = partido [1];
 op [2] = partido [2];
 op [3] = partido [3];
 match + = dec32table [offset];
 memcpy (op + 4, partido, 4);
 partido - = dec64; </pre><br>  Copiamos los primeros 4 bytes byte por bit, cambiamos por alg√∫n n√∫mero m√°gico, copiamos los siguientes 4 bytes en su conjunto, desplazamos el puntero para que coincida con otro n√∫mero m√°gico.  El autor del c√≥digo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jan Collet</a> ), por alguna raz√≥n rid√≠cula, olvid√≥ dejar un comentario sobre lo que esto significa.  Adem√°s, los nombres de las variables son confusos.  Ambos se llaman dec ... table, pero agregamos uno de ellos y restamos el otro.  Adem√°s, otro no est√° firmado y el otro es int.  Sin embargo, vale la pena rendir homenaje: recientemente, el autor mejor√≥ este lugar en el c√≥digo. <br><br>  As√≠ es como funciona realmente.  Copie los primeros 4 bytes byte: <br><br> <code>abc <font color="#0fc000">abca</font> ......... <br> ^^^^ - src <br> ^^^^ - dst</code> <br> <br>  Ahora puede copiar 4 bytes a la vez: <br><br> <code>abcabca <font color="#0fc000">bcab</font> ..... <br> ^^^^ - src <br> ^^^^ - dst</code> <br> <br>    ,  8  : <br><br> <code>abcabcabcab <font color="#0fc000">cabcabca</font> ..... <br> ^^^^^^^^ - src <br> ^^^^^^^^ - dst</code> <br> <br>     ,      ‚Äî   .   : <br><br><pre> inline void copyOverlap8(UInt8 * op, const UInt8 *&amp; match, const size_t offset)<font></font>
{<font></font>
    /// 4 % n.<font></font>
    /// Or if 4 % n is zero, we use n.<font></font>
    /// It gives equivalent result, but is better CPU friendly for unknown reason.<font></font>
    static constexpr int shift1[] = { 0, 1, 2, 1, 4, 4, 4, 4 };<font></font>
<font></font>
    /// 8 % n - 4 % n<font></font>
    static constexpr int shift2[] = { 0, 0, 0, 1, 0, -1, -2, -3 };<font></font>
<font></font>
    op[0] = match[0];<font></font>
    op[1] = match[1];<font></font>
    op[2] = match[2];<font></font>
    op[3] = match[3];<font></font>
<font></font>
    match += shift1[offset];<font></font>
    memcpy(op + 4, match, 4);<font></font>
    match += shift2[offset];<font></font>
} </pre><br> ,  ,   . ,     ,     ‚Äî   16 . <br><br>    ¬´ ¬ª    ,     ( <code>offset &lt; 16</code>   ,  <code>offset &lt; 8</code> ).  ()     16-   : <br><br><pre> inline void copyOverlap16(UInt8 * op, const UInt8 *&amp; match, const size_t offset)<font></font>
{<font></font>
    /// 4 % n.<font></font>
    static constexpr int shift1[]<font></font>
        = { 0, 1, 2, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };<font></font>
<font></font>
    /// 8 % n - 4 % n<font></font>
    static constexpr int shift2[]<font></font>
        = { 0, 0, 0, 1, 0, -1, -2, -3, -4, 4, 4, 4, 4, 4, 4, 4 };<font></font>
<font></font>
    /// 16 % n - 8 % n<font></font>
    static constexpr int shift3[]<font></font>
        = { 0, 0, 0, -1, 0, -2, 2, 1, 8, -1, -2, -3, -4, -5, -6, -7 };<font></font>
<font></font>
    op[0] = match[0];<font></font>
    op[1] = match[1];<font></font>
    op[2] = match[2];<font></font>
    op[3] = match[3];<font></font>
<font></font>
    match += shift1[offset];<font></font>
    memcpy(op + 4, match, 4);<font></font>
    match += shift2[offset];<font></font>
    memcpy(op + 8, match, 8);<font></font>
    match += shift3[offset];<font></font>
} </pre><br>       ?  ,        SIMD-,       16 ,         ( 1  15). ,   ,      . <br><br>    ‚Äî   <code>pshufb</code> (  packed shuffle bytes)    SSSE3 (  S).    16- .      .   ‚Äî ¬´¬ª:       0  15 ‚Äî    ,       . ,      127 ‚Äî     . <br><br>  : <br><br><pre> xmm0: abc.............<font></font>
xmm1: 0120120120120120<font></font>
<font></font>
pshufb %xmm1, %xmm0<font></font>
<font></font>
xmm0: abcabcabcabcabca </pre><br>           ‚Äî      !      : <br><br><pre> inline void copyOverlap16Shuffle(UInt8 * op, const UInt8 *&amp; match, const size_t offset)<font></font>
{<font></font>
#ifdef __SSSE3__<font></font>
<font></font>
    static constexpr UInt8 __attribute__((__aligned__(16))) masks[] =<font></font>
    {<font></font>
        0, 1, 2, 1, 4, 1, 4, 2, 8, 7, 6, 5, 4, 3, 2, 1, /* offset = 0, not used as mask, but for shift amount instead */<font></font>
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* offset = 1 */<font></font>
        0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,<font></font>
        0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0,<font></font>
        0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3,<font></font>
        0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0,<font></font>
        0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3,<font></font>
        0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3, 4, 5, 6,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0, 1, 2,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0, 1,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0,<font></font>
     };<font></font>
<font></font>
    _mm_storeu_si128(reinterpret_cast&lt;__m128i *&gt;(op),<font></font>
        _mm_shuffle_epi8(<font></font>
            _mm_loadu_si128(reinterpret_cast&lt;const __m128i *&gt;(match)),<font></font>
            _mm_load_si128(reinterpret_cast&lt;const __m128i *&gt;(masks) + offset)));<font></font>
<font></font>
    match += masks[offset];<font></font>
<font></font>
#else<font></font>
    copyOverlap16(op, match, offset);<font></font>
#endif<font></font>
} </pre><br>  <code>_mm_shuffle_epi8</code> ‚Äî  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">intrinsic</a> ,    <code>pshufb</code> . <br><br>          ,    ?  SSSE3 ‚Äî    ,   2006 .  AVX2  ,      32 ,      16- .     packed shuffle bytes,  vector permute bytes ‚Äî  ,    .  AVX-512 VBMI    ,    64 ,        .      ARM NEON ‚Äî   vtbl (vector table lookup),     8 . <br><br>  ,    <code>pshufb</code>  64- MMX-,   8 .         . ,        ,   16  (  ). <br><br>   Highload++ Siberia         ,    8          (  ) ‚Äî       ! <br><br><h3>    if </h3><br> ,    ,   16 .         ? <br><br>  ,       .      ,           ,  ,         .    ,     . <br><br> ,    . , ,    ,      65 536 .        65 536    .           , ,  65 551 .  ,  ,       96   128  ‚Äî     .     ,           ¬´¬ª      mmap    (     madvice).      - page faults.         ,    . <br><br><h3>   ? </h3><br> ,    ,     : <br><br><ol><li>   16   8. </li><li>  shuffle-   <code>offset &lt; 16</code> . </li><li>    if. </li></ol><br>              . <br><br>  Ejemplo 1: <br> Xeon E2650v2,  .,  AppVersion. <br> reference: 1.67 GB/sec. <br> 16 bytes, shuffle: 2.94 GB/sec ( 76% ). <br><br>  Ejemplo 2 <br> Xeon E2650v2,  .,  ShowsSumPosition. <br> reference: 2.30 GB/sec. <br> 16 bytes, shuffle: 1.91 GB/sec ( 20% ). <br><br>   ,         .     ,    .   - ,   .   ,      .     ‚Äî       16 .  :    ,     ,   . <br><br>   ,     C++      :  8-  16-  ;     shuffle-. <br><br><pre> template &lt;size_t copy_amount, bool use_shuffle&gt;<font></font>
void NO_INLINE decompressImpl(<font></font>
     const char * const source,<font></font>
     char * const dest,<font></font>
     size_t dest_size) </pre><br>        ,         shuffle  .     ,   : <br><br><pre> sudo echo 'performance' | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor<font></font>
kill -STOP $(pidof firefox) $(pidof chromium) </pre><br>        ¬´¬ª  (c  Xeon E5645),           ,    . ,         ,    .    ,    shuffle-,   ,      16- . <br><br>         : <br><br><pre> sudo kill -STOP $(pidof python) $(pidof perl) $(pgrep -u skynet) $(pidof cqudp-client) </pre><br>    .    thermal throttling  power capping. <br><br><h3>     </h3><br> ,      ,        .         ,         ,    .       .       , ,     .   : ClickHouse      ,       ,         .       ,             (       ‚Äî  ?).      . <br><br>      ,    ,      .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬´ ¬ª</a> .   ,      ,           ,    . <br><br>      ,   .        .       -        .             ‚Äî   ClickHouse      64 . ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>   .) <br><br>  ,     ¬´ ¬ª, ,    .      ,     ,   ,   -   .           .            ,          ,    .      . <br><br>         ,          ,       .    ¬´¬ª     ,    .     ,        .    Thompson Sampling. <br><br> ,   ,    .  ‚Äî      :  ,  .          .     ,     .       ,           C++.     ‚Äî ,     -   ,   ;     . <br><br>     ?      ,       .    . -,      ,         . -,  ,   ,   ¬´¬ª . <br><br> ,  ,           Thompson Sampling ‚Äî   (   ,        ).   ,         ,         - ,     ,      .           ,     . <br><br>   ,   ¬´¬ª .   ,     ,        ¬´¬ª,     .      ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> .    ,     ,       . <br><br>       ,   ,    ,    ,   ¬´¬ª: <br><br><pre> /// For better convergence, we don't use proper estimate of stddev.<font></font>
/// We want to eventually separate between two algorithms even in case<font></font>
/// when there is no statistical significant difference between them.<font></font>
double sigma() const<font></font>
{<font></font>
    return mean() / sqrt(adjustedCount());<font></font>
}<font></font>
<font></font>
double sample(pcg64 &amp; rng) const<font></font>
{<font></font>
     ...<font></font>
    return std::normal_distribution&lt;&gt;(mean(), sigma())(rng);<font></font>
} </pre><br>    ,       ‚Äî    memory latencies. <br><br>   ,         ,       ‚Äî    LZ4    . <br><br>  ,    : <br> ‚Äî reference (baseline):  LZ4   ; <br> ‚Äî variant 0:   8 ,   shuffle; <br> ‚Äî variant 1:   8 ,  shuffle; <br> ‚Äî variant 2:   16 ,   shuffle; <br> ‚Äî variant 3:   16 ,  shuffle; <br> ‚Äî ¬´¬ª ,            . <br><br><h3>    CPU </h3><br>       CPU,    ,  .  ,   CPU   ? <br><br>         ClickHouse   ,  256    100    ( 256  ).  ,  CPU  ,      .      CPU: <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5-2650 v2 @ 2.60GHz <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5-2660 v4 @ 2.00GHz <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5-2660 0 @ 2.20GHz <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5645 @ 2.40GHz <br> ‚Äî Intel Xeon E312xx (Sandy Bridge) <br> ‚Äî AMD Opteron(TM) Processor 6274 <br> ‚Äî AMD Opteron(tm) Processor 6380 <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5-2683 v4 @ 2.10GHz <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5530 @ 2.40GHz <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5440 @ 2.83GHz <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5-2667 v2 @ 3.30GHz <br><br>    ‚Äî ,   R&amp;D: <br> ‚Äî AMD EPYC 7351 16-Core Processor ‚Äî    AMD. <br> ‚Äî Cavium ThunderX2 ‚Äî     x86,  AArch64.    SIMD-   .    224   56  . <br><br>  13 ,        256   6  (reference, 0, 1, 2, 3, adaptive),    10 ,   .  199 680 ,    . <br><br> ,    CPU  .         :      LZ4    (   ‚Äî  ).  ,  Cavium   .       ClickHouse,   ¬´¬ª Xeon E5-2650 v2         ,      ,   ClickHouse    x86. <br><br><pre> ‚îå‚îÄcpu‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄref‚îÄ‚î¨‚îÄadapt‚îÄ‚î¨‚îÄ‚îÄmax‚îÄ‚î¨‚îÄbest‚îÄ‚î¨‚îÄadapt_boost‚îÄ‚î¨‚îÄmax_boost‚îÄ‚î¨‚îÄadapt_over_max‚îÄ‚îê<font></font>
‚îÇ E5-2667 v2 @ 3.30GHz ‚îÇ 2.81 ‚îÇ 3.19 ‚îÇ 3.15 ‚îÇ 3 ‚îÇ 1.14 ‚îÇ 1.12 ‚îÇ 1.01 ‚îÇ<font></font>
‚îÇ E5-2650 v2 @ 2.60GHz ‚îÇ 2.5 ‚îÇ 2.84 ‚îÇ 2.81 ‚îÇ 3 ‚îÇ 1.14 ‚îÇ 1.12 ‚îÇ 1.01 ‚îÇ<font></font>
‚îÇ E5-2683 v4 @ 2.10GHz ‚îÇ 2.26 ‚îÇ 2.63 ‚îÇ 2.59 ‚îÇ 3 ‚îÇ 1.16 ‚îÇ 1.15 ‚îÇ 1.02 ‚îÇ<font></font>
‚îÇ E5-2660 v4 @ 2.00GHz ‚îÇ 2.15 ‚îÇ 2.49 ‚îÇ 2.46 ‚îÇ 3 ‚îÇ 1.16 ‚îÇ 1.14 ‚îÇ 1.01 ‚îÇ<font></font>
‚îÇ AMD EPYC 7351 ‚îÇ 2.03 ‚îÇ 2.44 ‚îÇ 2.35 ‚îÇ 3 ‚îÇ 1.20 ‚îÇ 1.16 ‚îÇ 1.04 ‚îÇ<font></font>
‚îÇ E5-2660 0 @ 2.20GHz ‚îÇ 2.13 ‚îÇ 2.39 ‚îÇ 2.37 ‚îÇ 3 ‚îÇ 1.12 ‚îÇ 1.11 ‚îÇ 1.01 ‚îÇ<font></font>
‚îÇ E312xx (Sandy Bridge) ‚îÇ 1.97 ‚îÇ 2.2 ‚îÇ 2.18 ‚îÇ 3 ‚îÇ 1.12 ‚îÇ 1.11 ‚îÇ 1.01 ‚îÇ<font></font>
‚îÇ E5530 @ 2.40GHz ‚îÇ 1.65 ‚îÇ 1.93 ‚îÇ 1.94 ‚îÇ 3 ‚îÇ 1.17 ‚îÇ 1.18 ‚îÇ 0.99 ‚îÇ<font></font>
‚îÇ E5645 @ 2.40GHz ‚îÇ 1.65 ‚îÇ 1.92 ‚îÇ 1.94 ‚îÇ 3 ‚îÇ 1.16 ‚îÇ 1.18 ‚îÇ 0.99 ‚îÇ<font></font>
‚îÇ AMD Opteron 6380 ‚îÇ 1.47 ‚îÇ 1.58 ‚îÇ 1.56 ‚îÇ 1 ‚îÇ 1.07 ‚îÇ 1.06 ‚îÇ 1.01 ‚îÇ<font></font>
‚îÇ AMD Opteron 6274 ‚îÇ 1.15 ‚îÇ 1.35 ‚îÇ 1.35 ‚îÇ 1 ‚îÇ 1.17 ‚îÇ 1.17 ‚îÇ 1 ‚îÇ<font></font>
‚îÇ E5440 @ 2.83GHz ‚îÇ 1.35 ‚îÇ 1.33 ‚îÇ 1.42 ‚îÇ 1 ‚îÇ 0.99 ‚îÇ 1.05 ‚îÇ 0.94 ‚îÇ<font></font>
‚îÇ Cavium ThunderX2 ‚îÇ 0.84 ‚îÇ 0.87 ‚îÇ 0.87 ‚îÇ 0 ‚îÇ 1.04 ‚îÇ 1.04 ‚îÇ 1 ‚îÇ<font></font>
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò </pre><br> ref, adapt, max ‚Äî       (,            ). best ‚Äî      ,  0  3. adapt_boost ‚Äî        baseline. max_boost ‚Äî          baseline. adapt_over_max ‚Äî         . <br><br>  ,    x86      12‚Äì20%.   ARM    4%,   ,         .  ,        ¬´¬ª              Intel. <br><br><h3>  Conclusiones </h3><br>       . ,   LZ4     12‚Äì20%,            .           .      ,         . <br><br>    ,     ,    ¬´¬ª ,    ZStandard level 1  LZ4:      IO    . <br><br>           ‚Äî ,      .          ,       . <br><br>    :         . LZ4    ,   Lizard, Density  LZSSE  ,    . ,    LZ4      LZSSE  ClickHouse. <br><br>       LZ4 :         .          :      ,   .             . ,   inc-  dec-   <a href=""></a> .  ,           12‚Äì15%     32 ,    16,   .       32  ‚Äî     ,     <a href=""> </a> . <br><br>       ,  ,          page cache  userspace (   mmap,    O_DIRECT  userspace page cache ‚Äî     ),      - (  CityHash128  CRC32-C,    HighwayHash, FARSH  XXH3).         ,       . <br><br>   ,     master,            .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>  HighLoad++ Siberia,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452778/">https://habr.com/ru/post/452778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452766/index.html">Tecnolog√≠a de transmisi√≥n progresiva, o c√≥mo ver video 4k a trav√©s de la red, sin frisos</a></li>
<li><a href="../452768/index.html">C√≥mo dise√±ar un producto si decide ingresar al mercado extranjero</a></li>
<li><a href="../452772/index.html">5 t√©cnicas avanzadas de prueba de Go</a></li>
<li><a href="../452774/index.html">Dell XPS 13 9380: port√°til confiable y muy compacto para negocios serios</a></li>
<li><a href="../452776/index.html">N.M.D. (No es mi negocio)</a></li>
<li><a href="../452780/index.html">Mobius 2019 Piter: transmisi√≥n en vivo gratis y todo lo dem√°s</a></li>
<li><a href="../452788/index.html">La lucha por la calidad en aplicaciones web, depresi√≥n, dragones y Westeros</a></li>
<li><a href="../452790/index.html">OpenCV 4.0 y 4.1: ¬øqu√© hay de nuevo?</a></li>
<li><a href="../452792/index.html">Revisi√≥n de SSD de estado s√≥lido para usuarios corporativos Kingston DC500R</a></li>
<li><a href="../452794/index.html">Sobre la localizaci√≥n de productos. Primera parte: ¬øpor d√≥nde empezar?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>