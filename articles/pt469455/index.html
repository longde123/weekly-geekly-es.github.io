<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌩️ 👩‍🔬 🧒🏿 Migrando do Nginx para o Envoy Proxy 👩🏿‍🔬 🙏🏼 🐊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! Trago a sua atenção a tradução do post: Migração do Nginx para o Envoy Proxy . 


 O Envoy é um servidor proxy distribuído de alto desempenh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Migrando do Nginx para o Envoy Proxy</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469455/"><p>  Olá Habr!  Trago a sua atenção a tradução do post: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Migração do Nginx para o Envoy Proxy</a> . </p><br><p>  O Envoy é um servidor proxy distribuído de alto desempenho (escrito em C ++) projetado para serviços e aplicativos individuais; também é um barramento de comunicação e um "plano de dados universal" projetado para grandes arquiteturas de "service mesh" de microsserviço.  Quando ele foi criado, as soluções para problemas surgidos durante o desenvolvimento de servidores como NGINX, HAProxy, balanceadores de carga de hardware e balanceadores de nuvem foram levadas em consideração.  O Enviado trabalha com todos os aplicativos e abstrai a rede, fornecendo funções comuns, independentemente da plataforma.  Quando todo o tráfego do escritório na infraestrutura passa pela grade do Envoy, fica fácil visualizar as áreas problemáticas com observabilidade consistente, ajustando o desempenho geral e adicionando funções básicas em um local específico. </p><br><h2 id="vozmozhnosti">  As possibilidades </h2><br><ul><li> Arquitetura fora de processo: o enviado é um servidor autônomo de alto desempenho que consome uma pequena quantidade de RAM.  Funciona em conjunto com qualquer linguagem ou estrutura de aplicativo. </li><li>  Suporte para http / 2 e grpc: o enviado possui suporte de primeira classe para http / 2 e grpc para conexões de entrada e saída.  Este é um proxy transparente de http / 1.1 para http / 2. </li><li>  Balanceamento de carga aprimorado: o enviado suporta recursos avançados de balanceamento de carga, incluindo novas tentativas automáticas, circuito aberto, limite de velocidade global, solicitações de sombreamento, balanceamento de carga na zona local, etc. </li><li>  API de gerenciamento de configuração: o enviado fornece uma API robusta para gerenciar dinamicamente sua configuração. </li><li>  Observabilidade: observabilidade profunda do tráfego L7, suporte interno para rastreamento distribuído e observabilidade do mongodb, dynamodb e muitas outras aplicações. </li></ul><a name="habracut"></a><br><h2 id="shag-1---primer-konfiga-nginx">  Etapa 1 - Exemplo de configuração do NGINX </h2><br><p>  Este script usa um arquivo <em>nginx.conf</em> especialmente criado, com base em um exemplo completo do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Wiki</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NGINX</a> .  Você pode visualizar a configuração no editor abrindo <em>nginx.conf</em> </p><br><p>  Configuração nginx de origem </p><br><pre><code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">user</span></span> www www; <span class="hljs-attribute"><span class="hljs-attribute">pid</span></span> /var/run/nginx.pid; <span class="hljs-attribute"><span class="hljs-attribute">worker_processes</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-section"><span class="hljs-section">events</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">worker_connections</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span>; } <span class="hljs-section"><span class="hljs-section">http</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gzip</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">gzip_min_length</span></span> <span class="hljs-number"><span class="hljs-number">1100</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">gzip_buffers</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">8k</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">gzip_types</span></span> text/plain; <span class="hljs-attribute"><span class="hljs-attribute">log_format</span></span> main <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$remote_addr</span></span></span><span class="hljs-string"> - </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$remote_user</span></span></span><span class="hljs-string"> [</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time_local</span></span></span><span class="hljs-string">] '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$request</span></span></span><span class="hljs-string">" </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$status</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$bytes_sent</span></span></span><span class="hljs-string"> '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_referer</span></span></span><span class="hljs-string">" "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_user_agent</span></span></span><span class="hljs-string">" '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$gzip_ratio</span></span></span><span class="hljs-string">"'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">log_format</span></span> download <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$remote_addr</span></span></span><span class="hljs-string"> - </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$remote_user</span></span></span><span class="hljs-string"> [</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time_local</span></span></span><span class="hljs-string">] '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$request</span></span></span><span class="hljs-string">" </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$status</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$bytes_sent</span></span></span><span class="hljs-string"> '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_referer</span></span></span><span class="hljs-string">" "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_user_agent</span></span></span><span class="hljs-string">" '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_range</span></span></span><span class="hljs-string">" "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$sent_http_content_range</span></span></span><span class="hljs-string">"'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> targetCluster { 172.18.0.3:80; 172.18.0.4:80; } <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">8080</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> one.example.com www.one.example.com; <span class="hljs-attribute"><span class="hljs-attribute">access_log</span></span> /var/log/nginx.access_log main; <span class="hljs-attribute"><span class="hljs-attribute">error_log</span></span> /var/log/nginx.error_log <span class="hljs-literal"><span class="hljs-literal">info</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://targetCluster/; <span class="hljs-attribute"><span class="hljs-attribute">proxy_redirect</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Real-IP <span class="hljs-variable"><span class="hljs-variable">$remote_addr</span></span>; } } }</code> </pre> <br><p>  As configurações do NGINX geralmente têm três elementos principais: </p><br><ol><li>  Configurando o servidor NGINX, a estrutura de log e a funcionalidade Gzip.  Isso é determinado globalmente em todos os casos. </li><li>  Configurando o NGINX para aceitar solicitações para o host <em>one.example.com</em> na porta 8080. </li><li>  Definindo o local de destino, como lidar com o tráfego para diferentes partes do URL. </li></ol><br><p>  Nem toda a configuração será aplicada ao Envoy Proxy, e você não precisa definir algumas configurações.  O Envoy Proxy possui <strong>quatro tipos principais</strong> que suportam a infraestrutura subjacente oferecida pelo NGINX.  O núcleo é: </p><br><ul><li>  <strong>Ouvintes:</strong> Eles determinam como o Envoy Proxy aceita solicitações de entrada.  Atualmente, o Envoy Proxy suporta apenas ouvintes baseados em TCP.  Depois que a conexão é estabelecida, ela é transferida para um conjunto de filtros para processamento. </li><li>  <strong>Filtros:</strong> fazem parte de uma arquitetura em pipeline que pode processar dados de entrada e saída.  Essa funcionalidade inclui filtros, como o Gzip, que comprime os dados antes de enviá-los ao cliente. </li><li>  <strong>Roteadores:</strong> eles redirecionam o tráfego para o destino desejado, definido como um cluster. </li><li>  <strong>Clusters:</strong> Eles definem o terminal para o tráfego e as definições de configuração. </li></ul><br><p>  Usaremos esses quatro componentes para criar a configuração do Proxy Envoy para corresponder à configuração específica do NGINX.  O objetivo do Enviado é trabalhar com a API e a configuração dinâmica.  Nesse caso, a configuração básica usará parâmetros estáticos e codificados no NGINX. </p><br><h2 id="shag-2---konfiguraciya-nginx">  Etapa 2 - Configurar o NGINX </h2><br><p>  A primeira parte do <em>nginx.conf</em> define alguns dos componentes internos do NGINX que precisam ser configurados. </p><br><h4 id="worker-connections-rabochie-soedineniya">  Conexões do trabalhador </h4><br><p>  A configuração abaixo determina o número de processos e conexões de trabalho.  Isso indica como o NGINX será dimensionado para atender à demanda. </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">worker_processes</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-section"><span class="hljs-section">events</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">worker_connections</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span>; }</code> </pre> <br><p>  O Envoy Proxy gerencia fluxos de trabalho e conexões de maneira diferente. </p><br><p>  O enviado cria um fluxo de trabalho para cada thread de hardware no sistema.  Cada encadeamento de trabalhador executa um loop de eventos sem bloqueio, responsável por </p><br><ol><li>  Ouvindo cada ouvinte </li><li>  Aceitar novas conexões </li><li>  Criando um conjunto de filtros para uma conexão </li><li>  Manipulando todas as operações de E / S durante a vida útil de uma conexão. </li></ol><br><p>  Todo o processamento de conexão adicional é totalmente processado no fluxo de trabalho, incluindo qualquer comportamento de encaminhamento. </p><br><p>  Para cada fluxo de trabalho no Envoy, há uma conexão no pool.  Portanto, os conjuntos de conexões HTTP / 2 estabelecem apenas uma conexão para cada host externo por vez; se houver quatro threads de trabalho, haverá quatro conexões HTTP / 2 para cada host externo em um estado estável.  Ao armazenar tudo em um fluxo de trabalho, quase todo o código pode ser gravado sem o bloqueio, como se fosse de thread único.  Se mais de fluxos de trabalho necessários forem alocados, isso poderá levar ao uso não racional da memória, à criação de um grande número de conexões inativas e a uma diminuição no número de conexões retornadas ao pool. </p><br><p>  Para mais informações, visite o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">blog Envoy Proxy</a> . </p><br><h4 id="konfiguraciya-http">  Configuração HTTP </h4><br><p>  O seguinte bloco de configuração do NGINX define configurações HTTP, como: </p><br><ul><li>  Quais tipos MIME são suportados </li><li>  Tempos limite padrão </li><li>  Configuração Gzip </li></ul><br><p>  Você pode configurar esses aspectos usando filtros no Envoy Proxy, que discutiremos mais adiante. </p><br><h2 id="shag-3---konfiguraciya-server">  Etapa 3 - Configuração do servidor </h2><br><p>  No bloco de configuração HTTP, a configuração do NGINX instrui você a ouvir na porta 8080 e responder a solicitações de entrada para os domínios <em>one.example.com</em> e <em>www.one.example.com</em> . </p><br><pre> <code class="nginx hljs"> <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">8080</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> one.example.com www.one.example.com;</code> </pre> <br><p>  Dentro do Enviado, os Ouvintes controlam. </p><br><h4 id="slushateli-envoy">  Ouvintes enviados </h4><br><p>  O aspecto mais importante da introdução ao Envoy Proxy é identificar ouvintes.  Você precisa criar um arquivo de configuração que descreva como deseja executar uma instância do Envoy. </p><br><p>  O trecho abaixo criará um novo ouvinte e o associará à porta 8080. A configuração informa ao Proxy Envoy a quais portas ele deve estar vinculado para solicitações de entrada. </p><br><p>  O Envoy Proxy usa a notação YAML para sua configuração.  Para se familiarizar com essa notação, consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> aqui. </p><br><pre> <code class="plaintext hljs">Copy to Editorstatic_resources: listeners: - name: listener_0 address: socket_address: { address: 0.0.0.0, port_value: 8080 }</code> </pre> <br><p>  Não há necessidade de definir <em>server_name</em> , pois os filtros Envoy Proxy podem lidar com isso. </p><br><h2 id="shag-4---konfiguraciya-mestopolozheniya">  Etapa 4 - Configuração da Localização </h2><br><p>  Quando uma solicitação chega ao NGINX, o bloco de localização determina como processar e para onde direcionar o tráfego.  No fragmento a seguir, todo o tráfego para o site é transmitido para um cluster upstream (nota do tradutor: upstream geralmente é um servidor de aplicativos) chamado <em>targetCluster</em> .  O cluster upstream define os nós que devem processar a solicitação.  Discutiremos isso na próxima etapa. </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://targetCluster/; <span class="hljs-attribute"><span class="hljs-attribute">proxy_redirect</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Real-IP <span class="hljs-variable"><span class="hljs-variable">$remote_addr</span></span>; }</code> </pre> <br><p>  Na Envoy, a Filters faz isso. </p><br><h4 id="envoy-filters">  Filtros enviados </h4><br><p>  Para uma configuração estática, os filtros determinam como lidar com solicitações recebidas.  Nesse caso, definimos filtros que correspondem a <em>server_names</em> na etapa anterior.  Quando chegam solicitações que correspondem a domínios e rotas específicos, o tráfego é roteado para o cluster.  Isso é equivalente à configuração upstream do NGINX. </p><br><pre> <code class="plaintext hljs">Copy to Editor filter_chains: - filters: - name: envoy.http_connection_manager config: codec_type: auto stat_prefix: ingress_http route_config: name: local_route virtual_hosts: - name: backend domains: - "one.example.com" - "www.one.example.com" routes: - match: prefix: "/" route: cluster: targetCluster http_filters: - name: envoy.router</code> </pre> <br><p>  O nome <em>envoy.http_connection_manager</em> é um filtro <em>interno</em> no Envoy Proxy.  Outros filtros incluem <em>Redis</em> , <em>Mongo</em> , <em>TCP</em> .  Você pode encontrar a lista completa na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> . </p><br><p>  Para obter mais informações sobre outras políticas de balanceamento de carga, visite a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Enviado</a> . </p><br><h2 id="step-5---proxy-and-upstream-configuration">  Etapa 5 - Proxy e configuração upstream </h2><br><p>  No NGINX, a configuração upstream define o conjunto de servidores de destino que manipularão o tráfego.  Nesse caso, dois clusters foram atribuídos. </p><br><pre> <code class="nginx hljs"> <span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> targetCluster { 172.18.0.3:80; 172.18.0.4:80; }</code> </pre> <br><p>  No Envoy, ele é gerenciado por cluster. </p><br><h4 id="envoy-clusters">  Clusters enviados </h4><br><p>  O equivalente a montante é definido como clusters.  Nesse caso, os hosts que atenderão ao tráfego foram identificados.  Um método para acessar hosts, como tempos limite, é definido como uma configuração de cluster.  Isso permite que você controle com mais precisão a granularidade de aspectos como latência e balanceamento de carga. </p><br><pre> <code class="plaintext hljs">Copy to Editor clusters: - name: targetCluster connect_timeout: 0.25s type: STRICT_DNS dns_lookup_family: V4_ONLY lb_policy: ROUND_ROBIN hosts: [ { socket_address: { address: 172.18.0.3, port_value: 80 }}, { socket_address: { address: 172.18.0.4, port_value: 80 }} ]</code> </pre> <br><p>  Ao usar a <em>descoberta de</em> serviço <em>STRICT_DNS, o</em> Envoy resolverá contínua e assincronamente os destinos DNS especificados.  Cada endereço IP retornado como resultado do DNS será considerado um host explícito no cluster upstream.  Isso significa que, se a solicitação retornar dois endereços IP, o Envoy assumirá que existem dois hosts no cluster e ambos deverão ter balanceamento de carga.  Se o host for removido do resultado, o Envoy assumirá que ele não existe mais e selecionará o tráfego de qualquer pool de conexões existente. </p><br><p>  Para obter mais informações, consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação do Proxy Envoy</a> . </p><br><h2 id="shag-6---dostup-k-zhurnalu-i-oshibki">  Etapa 6 - Log de acesso e erros </h2><br><p>  A configuração final é registro.  Em vez de transferir logs de erro para o disco, o Envoy Proxy usa uma abordagem baseada na nuvem.  Todos os logs do aplicativo são exibidos em <em>stdout</em> e <em>stderr</em> . </p><br><p>  Quando os usuários fazem uma solicitação, os logs de acesso são opcionais e são desativados por padrão.  Para habilitar logs de acesso para solicitações HTTP, ative a configuração <em>access_log</em> para o HTTP Connection Manager.  O caminho pode ser um dispositivo, como <em>stdout</em> , ou um arquivo em disco, dependendo dos seus requisitos. </p><br><p>  A configuração a seguir redirecionará todos os logs de acesso para o <em>stdout</em> (nota do tradutor - o stdout é necessário para usar o enviado dentro da janela de encaixe. Se você usar sem a janela de encaixe, substitua / dev / stdout pelo caminho para o arquivo de log normal).  Copie o trecho para a seção de configuração do gerenciador de conexões: </p><br><pre> <code class="plaintext hljs">Copy to Clipboardaccess_log: - name: envoy.file_access_log config: path: "/dev/stdout"</code> </pre> <br><p>  Os resultados devem ficar assim: </p><br><pre> <code class="plaintext hljs"> - name: envoy.http_connection_manager config: codec_type: auto stat_prefix: ingress_http access_log: - name: envoy.file_access_log config: path: "/dev/stdout" route_config:</code> </pre> <br><p>  Por padrão, o Envoy possui uma sequência de formatos que inclui os detalhes da solicitação HTTP: </p><br><pre> <code class="plaintext hljs">[%START_TIME%] "%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %PROTOCOL%" %RESPONSE_CODE% %RESPONSE_FLAGS% %BYTES_RECEIVED% %BYTES_SENT% %DURATION% %RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)% "%REQ(X-FORWARDED-FOR)%" "%REQ(USER-AGENT)%" "%REQ(X-REQUEST-ID)%" "%REQ(:AUTHORITY)%" "%UPSTREAM_HOST%"\n</code> </pre> <br><p>  O resultado dessa sequência de formato: </p><br><pre> <code class="bash hljs">[2018-11-23T04:51:00.281Z] <span class="hljs-string"><span class="hljs-string">"GET / HTTP/1.1"</span></span> 200 - 0 58 4 1 <span class="hljs-string"><span class="hljs-string">"-"</span></span> <span class="hljs-string"><span class="hljs-string">"curl/7.47.0"</span></span> <span class="hljs-string"><span class="hljs-string">"f21ebd42-6770-4aa5-88d4-e56118165a7d"</span></span> <span class="hljs-string"><span class="hljs-string">"one.example.com"</span></span> <span class="hljs-string"><span class="hljs-string">"172.18.0.4:80"</span></span></code> </pre> <br><p>  O conteúdo da saída pode ser personalizado, definindo o campo de formato.  Por exemplo: </p><br><pre> <code class="plaintext hljs">access_log: - name: envoy.file_access_log config: path: "/dev/stdout" format: "[%START_TIME%] "%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %PROTOCOL%" %RESPONSE_CODE% %RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)% "%REQ(X-REQUEST-ID)%" "%REQ(:AUTHORITY)%" "%UPSTREAM_HOST%"\n"</code> </pre> <br><p>  A cadeia de log também pode ser <em>impressa</em> no formato JSON, configurando o campo <em>json_format</em> .  Por exemplo: </p><br><pre> <code class="plaintext hljs">access_log: - name: envoy.file_access_log config: path: "/dev/stdout" json_format: {"protocol": "%PROTOCOL%", "duration": "%DURATION%", "request_method": "%REQ(:METHOD)%"}</code> </pre> <br><p>  Para mais informações sobre técnicas de registro de enviado, visite </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.envoyproxy.io/docs/envoy/latest/configuration/access_log#config-access-log-format-dictionaries</a> </p><br><p>  O registro não é a única maneira de ter uma idéia de trabalhar com o Envoy Proxy.  Possui recursos avançados integrados para rastreamento e métricas.  Você pode descobrir mais na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação de rastreamento</a> ou através do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Script de rastreamento interativo</a> . </p><br><h2 id="shag-7---zapusk">  Etapa 7 - Iniciar </h2><br><p>  Agora você transferiu a configuração do NGINX para o Envoy Proxy.  A etapa final é executar uma instância do Envoy Proxy para testá-lo. </p><br><h4 id="zapusk-ot-polzovatelya">  Executar do usuário </h4><br><p>  Na parte superior da configuração do NGINX, o <em>usuário</em> da linha <em>www www;</em>  indica que o NGINX foi iniciado como um usuário com baixos privilégios para aprimorar a segurança. </p><br><p>  O Envoy Proxy adota uma abordagem baseada em nuvem para gerenciar quem é o proprietário do processo.  Quando executamos o Envoy Proxy através do contêiner, podemos especificar um usuário com um baixo nível de privilégio. </p><br><h4 id="zapusk-envoy-proxy">  Iniciar o Proxy Envoy </h4><br><p>  O comando abaixo iniciará o Envoy Proxy através do contêiner do Docker no host.  Este comando fornece ao Envoy a capacidade de escutar solicitações de entrada pela porta 80. No entanto, conforme indicado na configuração do ouvinte, o Proxy Envoy escuta o tráfego de entrada pela porta 8080. Isso permite que o processo seja executado como um usuário com privilégios baixos. </p><br><pre> <code class="bash hljs">docker run --name proxy1 -p 80:8080 --user 1000:1000 -v /root/envoy.yaml:/etc/envoy/envoy.yaml envoyproxy/envoy</code> </pre> <br><h4 id="testirovanie">  Teste </h4><br><p>  Com os proxies em execução, agora os testes podem ser feitos e processados.  O comando cURL a seguir emite uma solicitação com o cabeçalho do host definido na configuração do proxy. </p><br><pre> <code class="bash hljs">curl -H <span class="hljs-string"><span class="hljs-string">"Host: one.example.com"</span></span> localhost -i</code> </pre> <br><p>  Uma solicitação HTTP resultará no erro <em>503</em> .  Isso se deve ao fato de as conexões upstream não funcionarem e não estarem disponíveis.  Portanto, o Envoy Proxy não possui destinos de destino disponíveis para a solicitação.  O comando a seguir iniciará uma série de serviços HTTP que correspondem à configuração definida para o Envoy. </p><br><pre> <code class="bash hljs">docker run -d katacoda/docker-http-server; docker run -d katacoda/docker-http-server;</code> </pre> <br><p>  Com os serviços disponíveis, o Envoy pode proxy com êxito o tráfego para o seu destino. </p><br><pre> <code class="bash hljs">curl -H <span class="hljs-string"><span class="hljs-string">"Host: one.example.com"</span></span> localhost -i</code> </pre> <br><p>  Você deverá ver uma resposta indicando qual contêiner do Docker processou a solicitação.  Nos logs do Proxy Envoy, você também deve ver a sequência de acesso exibida. </p><br><h4 id="dopolnitelnye-zagolovki-otveta-http-http-response">  Cabeçalhos de resposta HTTP adicionais </h4><br><p>  Você verá cabeçalhos HTTP adicionais nos cabeçalhos de resposta da solicitação real.  O cabeçalho exibe o tempo que o host upstream passou processando a solicitação.  É expresso em milissegundos.  Isso é útil se o cliente deseja determinar o tempo de serviço comparado à latência da rede. </p><br><pre> <code class="plaintext hljs">x-envoy-upstream-service-time: 0 server: envoy</code> </pre> <br><h2 id="itogovyy-konfig">  Configuração final </h2><br><pre> <code class="plaintext hljs">static_resources: listeners: - name: listener_0 address: socket_address: { address: 0.0.0.0, port_value: 8080 } filter_chains: - filters: - name: envoy.http_connection_manager config: codec_type: auto stat_prefix: ingress_http route_config: name: local_route virtual_hosts: - name: backend domains: - "one.example.com" - "www.one.example.com" routes: - match: prefix: "/" route: cluster: targetCluster http_filters: - name: envoy.router clusters: - name: targetCluster connect_timeout: 0.25s type: STRICT_DNS dns_lookup_family: V4_ONLY lb_policy: ROUND_ROBIN hosts: [ { socket_address: { address: 172.18.0.3, port_value: 80 }}, { socket_address: { address: 172.18.0.4, port_value: 80 }} ] admin: access_log_path: /tmp/admin_access.log address: socket_address: { address: 0.0.0.0, port_value: 9090 }</code> </pre> <br><h2 id="dopolnitelnaya-informaciya-ot-perevodchika">  Informações adicionais do tradutor </h2><br><p>  As instruções de instalação do Envoy Proxy podem ser encontradas em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.getenvoy.io/</a> </p><br><p>  Por padrão, no rpm, não há nenhuma configuração do serviço systemd. </p><br><p>  Adicione o serviço systemd config /etc/systemd/system/envoy.service: </p><br><pre> <code class="bash hljs">[Unit] Description=Envoy Proxy Documentation=https://www.envoyproxy.io/ After=network-online.target Requires=envoy-auth-server.service Wants=nginx.service [Service] User=root Restart=on-failure ExecStart=/usr/bin/envoy --config-path /etc/envoy/config.yaml [Install] WantedBy=multi-user.target</code> </pre> <br><p>  Você precisa criar o diretório / etc / envoy / e colocar o config.yaml config lá. </p><br><p>  Por procurador enviado, há um bate-papo por telegrama: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://t.me/envoyproxy_ru</a> </p><br><p>  O Proxy Envoy não suporta distribuição de conteúdo estático.  Então, quem pode votar no recurso: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/envoyproxy/envoy/issues/378</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt469455/">https://habr.com/ru/post/pt469455/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt469445/index.html">Visão geral do AngularConnect 2019. Parte 2</a></li>
<li><a href="../pt469447/index.html">O caminho da inteligência artificial, de uma ideia fantástica para a indústria científica</a></li>
<li><a href="../pt469449/index.html">Certificados EV SSL: Existe vida após a morte?</a></li>
<li><a href="../pt469451/index.html">Filosofia do zero</a></li>
<li><a href="../pt469453/index.html">Gerenciamento de uma equipe distribuída no modo multiprojeto (revisão e reportagem em vídeo)</a></li>
<li><a href="../pt469457/index.html">Onde Extravaganza leva</a></li>
<li><a href="../pt469459/index.html">Conectando dispositivos IoT na cidade inteligente</a></li>
<li><a href="../pt469461/index.html">“Para as Estrelas”: Anti-Cósmico “Apocalipse Hoje”</a></li>
<li><a href="../pt469463/index.html">Tendências e previsões no processamento de idiomas naturais</a></li>
<li><a href="../pt469465/index.html">Inicialização em C ++ moderno</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>