<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏾 👃🏾 🐨 零停机时间部署和数据库 👃 🏛️ ✌🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文详细说明了如何解决与部署过程中数据库兼容性相关的问题。 如果您在没有任何准备的情况下尝试执行部署，我们将告诉您产品上的应用程序会发生什么。 然后，我们将经历应用程序生命周期的各个阶段，这些阶段对于实现零停机时间（ 大约Transl .：进一步-零停机时间 ）是必不可少的。 我们操作的结果将是以向...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>零停机时间部署和数据库</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nixys/blog/481932/"><p><img src="https://habrastorage.org/webt/hr/vy/qq/hrvyqqi2mmitehw9vx_xklbofj8.png" alt="图片"></p><br><p> 本文详细说明了如何解决与部署过程中数据库兼容性相关的问题。 如果您在没有任何准备的情况下尝试执行部署，我们将告诉您产品上的应用程序会发生什么。 然后，我们将经历应用程序生命周期的各个阶段，这些阶段对于实现零停机时间（ <em>大约Transl .：进一步-零停机时间</em> ）是必不可少的。 我们操作的结果将是以向后兼容的方式应用向后不兼容的数据库更改。 </p><a name="habracut"></a><br><p> 如果您想了解本文中的代码示例，可以在<a href="https://github.com/spring-cloud-samples/zero-downtime-deployment">GitHub上</a>找到它们。 </p><br><h2 id="vvedenie"> 引言 </h2><br><h3 id="zero-downtime-deployment"> 零停机时间部署 </h3><br><p> 什么是<strong>零停机</strong>神秘<strong>部署</strong> ？ 您可以在部署应用程序时这样说，以便您可以成功引入新版本的应用程序进行生产，而用户不会注意到其不可访问性。 从用户和公司的角度来看，这是最佳的部署方案，因为这样您就可以引入新功能并消除错误而不会中断。 </p><br><p> 如何实现呢？ 有几种方法，这是其中一种： </p><br><ul><li> 扩展服务的版本1 </li><li> 迁移数据库 </li><li> 与版本1并行部署服务的版本2 </li><li> 一旦看到版本号2正常运行，请删除版本号1 </li><li> 完成了！ </li></ul><br><p> 容易吧？ 不幸的是，这并不是那么简单，我们将在后面详细讨论。 现在，让我们看看另一个相当普遍的部署过程-蓝绿色部署。 </p><br><p> 您听说过<a href="https://martinfowler.com/bliki/BlueGreenDeployment.html">蓝绿色部署</a>吗？ 使用Cloud Foundry，这非常容易做到。 只需看一下<a href="https://spring.io/blog/2014/04/04/project-sagan-zero-downtime-deployments">本文</a> ，我们将对其进行更详细的描述。 简要总结一下，我们回顾了如何进行蓝绿色部署： </p><br><ul><li>  <em>确保操作两个生产代码副本（“蓝色”和“绿色”）；</em> </li><li>  <em>将所有流量定向到蓝色环境，即</em>  <em>以便将生产URL指向此处；</em> </li><li>  <em>在绿色环境中部署和测试所有应用程序更改</em> </li><li>  <em>将网址从蓝色环境切换到绿色环境</em> </li></ul><br><p> 蓝绿色部署是一种使您可以轻松引入新功能而不必担心生产会中断的方法。 这是由于这样的事实，即使发生了某些事情，您也可以通过简单地“单击开关”轻松回滚到以前的环境。 </p><br><p> 阅读完以上所有内容后，您可以提出以下问题：蓝绿色部署与零停机时间有什么关系？ </p><br><p> 嗯，它们有很多共同点，因为支持同一环境的两个副本需要付出双重努力来维护它们。 这就是为什么<a href="https://martinfowler.com/bliki/BlueGreenDeployment.html">马丁·福勒</a> （ <a href="https://martinfowler.com/bliki/BlueGreenDeployment.html">Martin Fowler</a> ）认为某些团队坚持采用这种方法的原因： </p><br><p> <em>另一个选择是使用相同的数据库，为Web和域层创建蓝绿色开关。</em>  <em>在这种方法中，数据库通常是个问题，尤其是当您需要更改其架构以支持该软件的新版本时。</em> </p><br><p> 在这里，我们讨论本文的主要问题。  <strong>数据库</strong> 。 让我们再来看一下这句话。 </p><br><p>  <em>迁移数据库。</em> </p><br><p> 现在您必须问自己一个问题-如果更改数据库向后不兼容怎么办？ 我的应用程序的第一个版本不会中断吗？ 实际上，这正是将要发生的事情... </p><br><p> 因此，尽管零停机时间/蓝绿色部署带来了巨大的好处，但公司仍倾向于为其应用遵循以下更安全的部署过程： </p><br><ul><li> 使用新版本的应用程序准备软件包 </li><li> 关闭正在运行的应用程序 </li><li> 运行脚本进行数据库迁移 </li><li> 部署并启动新版本的应用程序 </li></ul><br><p> 在本文中，我们将详细描述如何使用数据库和代码来利用零停机时间部署。 </p><br><h3 id="problemy-s-bazoy-dannyh"> 数据库问题 </h3><br><p> 如果您有一个无状态应用程序，该应用程序未在数据库中存储任何数据，则可以立即获得零停机时间部署。 不幸的是，大多数软件都需要将数据存储在某个地方。 这就是为什么在更改电路之前应该三思而后行的原因。 在深入研究如何更改方案的细节，以便可以在不停机的情况下进行部署之前，让我们首先关注版本控制方案。 </p><br><h3 id="shema-upravleniya-versiyami"> 版本控制方案 </h3><br><p>在本文中，我们将使用<a href="https://flywaydb.org/">Flyway</a>作为版本控制工具（ <em>大约Transl。：我们正在谈论数据库迁移</em> ）。 自然，我们还将编写一个具有内置Flyway支持的Spring Boot应用程序，并在设置应用程序上下文时迁移电路。 使用Flyway时，可以将迁移脚本存储在项目文件夹中（默认情况下，在<code>classpath:db/migration</code> ）。 在这里，您可以看到此类迁移文件的示例。 </p><br><pre> <code class="plaintext hljs">└── db └── migration ├── V1__init.sql ├── V2__Add_surname.sql ├── V3__Final_migration.sql └── V4__Remove_lastname.sql</code> </pre> <br><p> 在此示例中，我们看到了4种迁移方案，如果它们没有更早执行，则将在应用程序启动时一个接一个地执行。 让我们以其中一个文件（ <code>V1__init.sql</code> ）为例。 </p><br><pre> <code class="plaintext hljs">CREATE TABLE PERSON ( id BIGINT GENERATED BY DEFAULT AS IDENTITY, first_name varchar(255) not null, last_name varchar(255) not null ); insert into PERSON (first_name, last_name) values ('Dave', 'Syer');</code> </pre> <br><p> 一切都完美地说明了一切：您可以使用SQL来确定应如何修改数据库。 有关Spring Boot和Flyway的更多信息，请查看<a href="https://docs.spring.io/spring-boot/docs/1.3.5.RELEASE/reference/html/howto-database-initialization.html">Spring Boot Docs</a> 。 </p><br><p> 将版本控制与Spring Boot结合使用可为您带来2大好处： </p><br><ul><li> 您将数据库更改与代码更改分开 </li><li> 数据库迁移与应用程序的推出同时发生，即 您的部署过程得以简化 </li></ul><br><h2 id="reshenie-problem-s-bazoy-dannyh"> 解决数据库问题 </h2><br><p> 在本文的下一部分中，我们将重点考虑两种数据库更改方法。 </p><br><ul><li> 向后不兼容 </li><li> 向后兼容 </li></ul><br><p> 前者将被视为警告，如果没有进行初步准备，则不应执行零停机时间部署。第二者提供了有关如何在不停机的情况下执行部署并同时保持向后兼容性的解决方案。 </p><br><p> 我们将进行的项目将是一个简单的Spring Boot Flyway应用程序，其中数据库中存在一个具有<code>first_name</code>和<code>last_name</code>的<code>Person</code> （ <em>大约per .: <code>Person</code>是一个表，而<code>irst_name</code>和<code>last_name</code>是其中的字段</em> ）。 我们想将<code>last_name</code>重命名为<code>surname</code> 。 </p><br><h3 id="dopuscheniya"> 假设条件 </h3><br><p> 在深入研究细节之前，我们需要概述一些关于应用程序的假设。 我们要实现的主要结果将是一个相当简单的过程。 </p><br><blockquote>  <strong>注意事项</strong> 商业专业提示。 简化流程可以为您节省大量支持费用（在公司工作的人越多，您可以节省的钱就更多）！ </blockquote><br><h3 id="ne-nado-delat-otkat-bazy-dannyh"> 无需回滚数据库 </h3><br><p> 这简化了部署过程（几乎不可能进行数据库的某些回滚，例如回滚删除）。 我们只喜欢回滚应用程序。 这样，即使您具有不同的数据库（例如SQL和NoSQL），您的部署管道也将看起来相同。 </p><br><p>  <strong>必须始终可以将应用程序回滚一个版本（不再）</strong> </p><br><p> 仅在必要时才进行回滚。 如果当前版本中存在一个不容易修复的错误，我们应该能够返回最新的工作版本。 我们假定此最新的工作版本为先前的版本。 维持多个发行版的代码和数据库兼容性非常困难且成本很高。 </p><br><blockquote>  <strong>注意事项</strong> 为了提高可读性，在本文的框架内，我们将更改应用程序的主要版本。 </blockquote><br><h3 id="shag-1-ishodnoe-sostoyanie"> 步骤1：初始状态 </h3><br><p> 应用版本： <code>1.0.0</code> <br> 数据库版本： <code>v1</code> </p><br><h3 id="kommentariy"> 评注 </h3><br><p> 这将是应用程序的初始状态。 </p><br><h3 id="izmeneniya-bd"> 数据库更改 </h3><br><p> 该数据库包含<code>last_name.</code> </p><br><pre> <code class="plaintext hljs">CREATE TABLE PERSON ( id BIGINT GENERATED BY DEFAULT AS IDENTITY, first_name varchar(255) not null, last_name varchar(255) not null ); insert into PERSON (first_name, last_name) values ('Dave', 'Syer');</code> </pre> <br><h3 id="izmeneniya-koda"> 代码变更 </h3><br><p> 该应用程序将Person数据保存到<code>last_name</code> ： </p><br><pre> <code class="plaintext hljs">/* * Copyright 2012-2016 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package sample.flyway; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; @Entity public class Person { @Id @GeneratedValue private Long id; private String firstName; private String lastName; public String getFirstName() { return this.firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return this.lastName; } public void setLastName(String lastname) { this.lastName = lastname; } @Override public String toString() { return "Person [firstName=" + this.firstName + ", lastName=" + this.lastName + "]"; } }</code> </pre> <br><h3 id="obratno-nesovmestimoe-pereimenovanie-stolbca"> 不兼容的列重命名 </h3><br><p> 让我们看一下如何更改列名的示例： </p><br><blockquote>  <strong>注意事项</strong> 以下示例将有意中断。 为了说明数据库兼容性问题，我们展示了这一点。 </blockquote><p> 应用程序版本： <code>2.0.0.BAD</code> </p><br><p> 数据库版本： <code>v2bad</code> </p><br><h3 id="kommentariy-1"> 评注 </h3><br><p> 当前的更改不允许我们同时运行两个实例（旧实例和新实例）。 因此，将很难实现零停机时间部署（考虑到假设，这实际上是不可能的）。 </p><br><h3 id="ab-testirovanie">  A / B测试 </h3><br><p> 当前的情况是，我们有一个在prod中部署的应用程序版本<code>1.0.0,</code>和一个数据库<code>v1</code> 。 我们必须部署应用程序的第二个实例<code>2.0.0.BAD</code>版本，并将数据库升级到<code>v2bad</code> 。 </p><br><p> 步骤： </p><br><ol><li> 部署了应用程序版本<code>2.0.0.BAD</code>的新实例，该实例将数据库更新为<code>v2bad</code> </li><li>  <code>v2bad</code>数据库中的<code>last_name</code>列不再存在-更改为<code>surname</code> </li><li> 数据库和应用程序更新成功，并且某些实例在<code>1.0.0</code>工作，其他实例在<code>2.0.0.BAD</code> 。 所有与<code>v2bad</code>相关的 </li><li> 版本<code>1.0.0</code>所有实例将开始引发错误，因为它们将尝试将数据插入到<code>last_name</code>列中，该列不再 </li><li> 版本<code>2.0.0.BAD</code>所有实例<code>2.0.0.BAD</code>正常使用 </li></ol><br><p> 如您所见，如果我们对数据库和应用程序进行向后不兼容的更改，则无法进行A / B测试。 </p><br><h3 id="otkat-prilozheniya"> 回滚应用 </h3><br><p> 假设在尝试执行A / B部署（ <em>大约Transl。:：作者可能是在这里指的是A / B测试</em> ）之后，我们决定需要将应用程序回滚到<code>1.0.0.</code>版<code>1.0.0.</code> 假设我们不想回滚数据库。 </p><br><p> 步骤： </p><br><ol><li> 我们停止了应用程序实例版本<code>2.0.0.BAD</code> </li><li> 数据库仍然是<code>v2bad</code> </li><li> 由于<code>1.0.0</code>版不了解什么是<code>surname</code> ，我们将看到错误 </li><li> 地狱挣脱了我们不能再回来 </li></ol><br><p> 如您所见，如果我们对数据库和应用程序进行向后不兼容的更改，则无法回滚到以前的版本。 </p><br><h3 id="logi-ispolneniya-skripta"> 脚本执行日志 </h3><br><pre> <code class="plaintext hljs">Backward incompatible scenario: 01) Run 1.0.0 02) Wait for the app (1.0.0) to boot 03) Generate a person by calling POST localhost:9991/person to version 1.0.0 04) Run 2.0.0.BAD 05) Wait for the app (2.0.0.BAD) to boot 06) Generate a person by calling POST localhost:9991/person to version 1.0.0 &lt;-- this should fail 07) Generate a person by calling POST localhost:9992/person to version 2.0.0.BAD &lt;-- this should pass Starting app in version 1.0.0 Generate a person in version 1.0.0 Sending a post to 127.0.0.1:9991/person. This is the response: {"firstName":"b73f639f-e176-4463-bf26-1135aace2f57","lastName":"b73f639f-e176-4463-bf26-1135aace2f57"} Starting app in version 2.0.0.BAD Generate a person in version 1.0.0 Sending a post to 127.0.0.1:9991/person. This is the response: curl: (22) The requested URL returned error: 500 Internal Server Error Generate a person in version 2.0.0.BAD Sending a post to 127.0.0.1:9995/person. This is the response: {"firstName":"e156be2e-06b6-4730-9c43-6e14cfcda125","surname":"e156be2e-06b6-4730-9c43-6e14cfcda125"}</code> </pre> <br><h3 id="izmeneniya-bd-1"> 数据库更改 </h3><br><p> 将<code>last_name</code>重命名为<code>surname</code>迁移脚本 </p><br><p> 源Flyway脚本： </p><br><pre> <code class="plaintext hljs">CREATE TABLE PERSON ( id BIGINT GENERATED BY DEFAULT AS IDENTITY, first_name varchar(255) not null, last_name varchar(255) not null ); insert into PERSON (first_name, last_name) values ('Dave', 'Syer');</code> </pre> <br><p> 重命名<code>last_name</code>的脚本。 </p><br><pre> <code class="plaintext hljs">-- This change is backward incompatible - you can't do A/B testing ALTER TABLE PERSON CHANGE last_name surname VARCHAR;</code> </pre> <br><h3 id="izmeneniya-koda-1"> 代码变更 </h3><br><p> 我们将<code>lastName</code>字段名称更改为<code>surname</code> 。 </p><br><h3 id="pereimenovanie-stolbca-obratno-sovmestimym-sposobom"> 以向后兼容的方式重命名列 </h3><br><p> 这是我们可能遇到的最常见的情况。 我们需要进行向后不兼容的更改。 我们已经证明，对于没有停机的部署，我们不应该只是在没有其他操作的情况下应用数据库迁移。 在本文的这一部分中，我们将对应用程序进行3个部署以及数据库迁移，以实现所需的结果并同时保持向后兼容性。 </p><br><blockquote>  <strong>注意事项</strong> 回想一下，我们有一个数据库版本<code>v1</code> 。 它包含列<code>first_name</code>和<code>last_name</code> 。 我们必须将<code>last_name</code>更改为<code>surname</code> 。 我们还有一个版本<code>1.0.0,</code>的应用程序，尚未使用<code>surname</code> 。 </blockquote><br><h3 id="shag-2-dobavlyaem-surname"> 步骤2：添加姓 </h3><br><p> 应用版本： <code>2.0.0</code> <br> 数据库版本： <code>v2</code> </p><br><h3 id="kommentariy-2"> 评注 </h3><br><p> 通过添加新列并复制其内容，我们创建了向后兼容的数据库更改。 同时，如果我们回滚JAR或拥有可用的旧JAR，则它在运行时不会中断。 </p><br><h3 id="vykatyvaem-novuyu-versiyu"> 我们推出新版本 </h3><br><p> 步骤： </p><br><ol><li> 迁移数据库以创建新的<code>surname</code>列。 现在您的数据库版本<code>v2</code> </li><li> 将数据从<code>last_name</code>复制到<code>surname</code> 。  <strong>请注意</strong> ，如果您有大量此类数据，则应考虑批量迁移！ </li><li> 编写同时使用<strong>新</strong>列和<strong>旧</strong>列的代码。 现在您的应用程序版本为<code>2.0.0</code> </li><li> 如果该值不为<code>null</code> ，则从<code>surname</code>列中读取该值；如果未指定<code>surname</code> ，则从l <code>ast_name</code> 。 您可以从代码中删除<code>getLastName()</code> ，因为当您将应用程序从<code>3.0.0</code>回滚到<code>2.0.0</code>时，它将返回<code>null</code> 。 </li></ol><br><p> 如果您使用的是Spring Boot Flyway，则将在启动应用程序<code>2.0.0</code>版时执行这两个步骤。 如果手动运行数据库版本控制工具，则必须为此执行两项不同的操作（首先手动更新数据库版本，然后部署新的应用程序）。 </p><br><blockquote>  <strong>这很重要。</strong> 请记住，新创建的列<strong>一定</strong> <strong>不能</strong>为<strong>NOT NULL</strong> 。 如果回滚，旧应用程序将不知道新列，并且在<code>Insert.</code>过程中将不会安装新列<code>Insert.</code> 但是，如果添加此限制，并且数据库将是<code>v2</code> ，则需要设置新列的值。 这将导致违反限制。 <br><br>  <strong>这很重要。</strong> 您应该删除<code>getLastName()</code>方法，因为版本<code>3.0.0</code>在代码<code>getLastName()</code>没有<code>last_name</code>列的概念。 这意味着将在此处设置null。 您可以保留该方法并添加<code>null</code>检查，但是更好的解决方案是确保在<code>getSurname()</code>逻辑中选择了正确的非零值。 </blockquote><br><h3 id="ab-testirovanie-1">  A / B测试 </h3><br><p> 当前的情况是我们在prod上部署了应用程序版本<code>1.0.0</code> ，在<code>v1</code>部署了数据库。 我们需要部署应用程序版本<code>2.0.0</code>的第二个实例，该实例会将数据库升级到<code>v2</code> 。 </p><br><p> 步骤： </p><br><ol><li> 部署了应用程序版本<code>2.0.0</code>的新实例，该实例将数据库更新为<code>v2</code> </li><li> 同时，一些请求由版本<code>1.0.0</code>的实例处理 </li><li> 更新成功，并且您拥有应用程序版本<code>1.0.0</code>和其余版本<code>2.0.0.</code>多个工作实例<code>2.0.0.</code> 每个人都在<code>v2</code>与数据库通信 </li><li>  <code>1.0.0</code>版不使用数据库中的姓列，但<code>2.0.0</code>版使用。 它们不会互相干扰，并且应该没有错误。 </li><li>  <code>2.0.0</code>版将数据存储在旧列和新列中，这提供了向后兼容性 </li></ol><br><blockquote>  <strong>这很重要。</strong> 如果您有任何查询根据旧/新列中的值对项目进行计数，则应记住，现在您有重复的值（很可能它们仍在迁移）。 例如，如果您要计算姓氏（无论列名如何）以字母<code>A</code>开头<code>A</code> ，则在数据迁移（ <code>old</code> → <code>new</code>列）完成之前，如果在新列上执行查询，则数据可能不一致。 </blockquote><br><h3 id="otkat-prilozheniya-1"> 回滚应用 </h3><br><p> 现在，我们有一个应用程序版本<code>2.0.0</code>和一个<code>v2</code>的数据库。 </p><br><p> 步骤： </p><br><ol><li> 将您的应用程序回滚到<code>1.0.0</code>版本。 </li><li>  <code>1.0.0</code>版不使用数据库中的<code>surname</code>列，因此回滚必须成功 </li></ol><br><h3 id="izmeneniya-db"> 数据库更改 </h3><br><p> 该数据库包含一个名为<code>last_name</code>的列。 </p><br><p> 源Flyway脚本： </p><br><pre> <code class="plaintext hljs">CREATE TABLE PERSON ( id BIGINT GENERATED BY DEFAULT AS IDENTITY, first_name varchar(255) not null, last_name varchar(255) not null ); insert into PERSON (first_name, last_name) values ('Dave', 'Syer');</code> </pre> <br><p> 用于添加<code>surname</code>的脚本。 </p><br><blockquote>  <strong>注意事项</strong> 请记住，您不能将任何NOT NULL约束添加到添加的列。 如果回滚JAR，则旧版本对添加的列一无所知，并将自动将其设置为NULL。 如果有这样的限制，旧的应用程序将被破坏。 </blockquote><br><pre> <code class="plaintext hljs">-- NOTE: This field can't have the NOT NULL constraint cause if you rollback, the old version won't know about this field -- and will always set it to NULL ALTER TABLE PERSON ADD surname varchar(255); -- WE'RE ASSUMING THAT IT'S A FAST MIGRATION - OTHERWISE WE WOULD HAVE TO MIGRATE IN BATCHES UPDATE PERSON SET PERSON.surname = PERSON.last_name</code> </pre> <br><h3 id="izmeneniya-koda-2"> 代码变更 </h3><br><p> 我们将数据存储在<code>last_name</code>和<code>surname</code> 。 同时，我们从<code>last_name</code>读取内容，因为此列最相关。 在部署过程中，某些请求可能已由尚未更新的应用程序实例处理。 </p><br><pre> <code class="plaintext hljs">/* * Copyright 2012-2016 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package sample.flyway; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; @Entity public class Person { @Id @GeneratedValue private Long id; private String firstName; private String lastName; private String surname; public String getFirstName() { return this.firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } /** * Reading from the new column if it's set. If not the from the old one. * * When migrating from version 1.0.0 -&gt; 2.0.0 this can lead to a possibility that some data in * the surname column is not up to date (during the migration process lastName could have been updated). * In this case one can run yet another migration script after all applications have been deployed in the * new version to ensure that the surname field is updated. * * However it makes sense since when looking at the migration from 2.0.0 -&gt; 3.0.0. In 3.0.0 we no longer * have a notion of lastName at all - so we don't update that column. If we rollback from 3.0.0 -&gt; 2.0.0 if we * would be reading from lastName, then we would have very old data (since not a single datum was inserted * to lastName in version 3.0.0). */ public String getSurname() { return this.surname != null ? this.surname : this.lastName; } /** * Storing both FIRST_NAME and SURNAME entries */ public void setSurname(String surname) { this.lastName = surname; this.surname = surname; } @Override public String toString() { return "Person [firstName=" + this.firstName + ", lastName=" + this.lastName + ", surname=" + this.surname + "]"; } }</code> </pre> <br><h3 id="shag-3-udalenie-last_name-iz-koda"> 步骤3：从代码中删除last_name </h3><br><p> 应用版本： <code>3.0.0</code> </p><br><p> 数据库版本： <code>v3</code> </p><br><h3 id="kommentariy-3"> 评注 </h3><br><p>  <em>注意事项</em>  <em>trans .：显然，作者错误地复制了原始文章中第2步中的该块的文本，在此步骤中，应对应用程序代码进行更改，以删除使用<code>last_name</code>列的功能。</em> </p><br><p> 通过添加新列并复制其内容，我们创建了向后兼容的数据库更改。 另外，如果我们回滚JAR或有可用的旧JAR，则它在运行时不会中断。 </p><br><h3 id="otkat-prilozheniya-2"> 回滚应用 </h3><br><p> 我们目前有<code>3.0.0</code>版的应用程序和<code>v3</code>数据库。 版本<code>3.0.0</code>不会将数据保存在<code>last_name</code> 。 这意味着<code>surname</code>将存储最新信息。 </p><br><p> 步骤： </p><br><ol><li> 将您的应用程序回滚到<code>2.0.0</code>版本。 </li><li>  <code>2.0.0</code>版同时使用<code>last_name</code>和<code>surname</code> 。 </li><li> 如果版本<code>2.0.0</code>不为null，则它将使用<code>surname</code> ，否则为<code>last_name</code> </li></ol><br><h3 id="izmeneniya-bd-2"> 数据库更改 </h3><br><p> 数据库中没有结构上的更改。 执行以下脚本，该脚本执行旧数据的最终迁移： </p><br><pre> <code class="plaintext hljs">-- WE'RE ASSUMING THAT IT'S A FAST MIGRATION - OTHERWISE WE WOULD HAVE TO MIGRATE IN BATCHES -- ALSO WE'RE NOT CHECKING IF WE'RE NOT OVERRIDING EXISTING ENTRIES. WE WOULD HAVE TO COMPARE -- ENTRY VERSIONS TO ENSURE THAT IF THERE IS ALREADY AN ENTRY WITH A HIGHER VERSION NUMBER -- WE WILL NOT OVERRIDE IT. UPDATE PERSON SET PERSON.surname = PERSON.last_name; -- DROPPING THE NOT NULL CONSTRAINT; OTHERWISE YOU WILL TRY TO INSERT NULL VALUE OF THE LAST_NAME -- WITH A NOT_NULL CONSTRAINT. ALTER TABLE PERSON MODIFY COLUMN last_name varchar(255) NULL DEFAULT NULL;</code> </pre> <br><h3 id="izmeneniya-koda-3"> 代码变更 </h3><br><p>  <em>注意事项</em>  <em>trans .：作者在第2步中也错误地复制了此块的描述。根据文章故事的逻辑，此步骤中的代码更改应旨在从中删除与<code>last_name</code>列一起使用的元素。</em> </p><br><p> 我们将数据存储在<code>last_name</code>和<code>surname.</code> 另外，我们从列<code>last_name</code>读取内容，因为它最相关。 在部署过程中，某些请求可能由尚未更新的实例处理。 </p><br><pre> <code class="plaintext hljs">/* * Copyright 2012-2016 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package sample.flyway; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; @Entity public class Person { @Id @GeneratedValue private Long id; private String firstName; private String surname; public String getFirstName() { return this.firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getSurname() { return this.surname; } public void setSurname(String lastname) { this.surname = lastname; } @Override public String toString() { return "Person [firstName=" + this.firstName + ", surname=" + this.surname + "]"; } }</code> </pre> <br><h3 id="shag-4-udalenie-last_name-iz-bd"> 步骤4：从数据库中删除last_name </h3><br><p> 应用版本： <code>4.0.0</code> </p><br><p> 数据库版本： <code>v4</code> </p><br><h3 id="kommentariy-4"> 评注 </h3><br><p> 由于版本<code>3.0.0</code>代码未使用<code>last_name</code>列，因此，如果在从数据库中删除该列后回滚到<code>3.0.0</code> ，则在执行过程中不会发生任何不良情况。 </p><br><h3 id="logi-ispolneniya-skripta-1"> 脚本执行日志 </h3><br><pre> <code class="plaintext hljs">We will do it in the following way: 01) Run 1.0.0 02) Wait for the app (1.0.0) to boot 03) Generate a person by calling POST localhost:9991/person to version 1.0.0 04) Run 2.0.0 05) Wait for the app (2.0.0) to boot 06) Generate a person by calling POST localhost:9991/person to version 1.0.0 07) Generate a person by calling POST localhost:9992/person to version 2.0.0 08) Kill app (1.0.0) 09) Run 3.0.0 10) Wait for the app (3.0.0) to boot 11) Generate a person by calling POST localhost:9992/person to version 2.0.0 12) Generate a person by calling POST localhost:9993/person to version 3.0.0 13) Kill app (3.0.0) 14) Run 4.0.0 15) Wait for the app (4.0.0) to boot 16) Generate a person by calling POST localhost:9993/person to version 3.0.0 17) Generate a person by calling POST localhost:9994/person to version 4.0.0 Starting app in version 1.0.0 Generate a person in version 1.0.0 Sending a post to 127.0.0.1:9991/person. This is the response: {"firstName":"52b6e125-4a5c-429b-a47a-ef18bbc639d2","lastName":"52b6e125-4a5c-429b-a47a-ef18bbc639d2"} Starting app in version 2.0.0 Generate a person in version 1.0.0 Sending a post to 127.0.0.1:9991/person. This is the response: {"firstName":"e41ee756-4fa7-4737-b832-e28827a00deb","lastName":"e41ee756-4fa7-4737-b832-e28827a00deb"} Generate a person in version 2.0.0 Sending a post to 127.0.0.1:9992/person. This is the response: {"firstName":"0c1240f5-649a-4bc5-8aa9-cff855f3927f","lastName":"0c1240f5-649a-4bc5-8aa9-cff855f3927f","surname":"0c1240f5-649a-4bc5-8aa9-cff855f3927f"} Killing app 1.0.0 Starting app in version 3.0.0 Generate a person in version 2.0.0 Sending a post to 127.0.0.1:9992/person. This is the response: {"firstName":"74d84a9e-5f44-43b8-907c-148c6d26a71b","lastName":"74d84a9e-5f44-43b8-907c-148c6d26a71b","surname":"74d84a9e-5f44-43b8-907c-148c6d26a71b"} Generate a person in version 3.0.0 Sending a post to 127.0.0.1:9993/person. This is the response: {"firstName":"c6564dbe-9ab5-40ae-9077-8ae6668d5862","surname":"c6564dbe-9ab5-40ae-9077-8ae6668d5862"} Killing app 2.0.0 Starting app in version 4.0.0 Generate a person in version 3.0.0 Sending a post to 127.0.0.1:9993/person. This is the response: {"firstName":"cbe942fc-832e-45e9-a838-0fae25c10a51","surname":"cbe942fc-832e-45e9-a838-0fae25c10a51"} Generate a person in version 4.0.0 Sending a post to 127.0.0.1:9994/person. This is the response: {"firstName":"ff6857ce-9c41-413a-863e-358e2719bf88","surname":"ff6857ce-9c41-413a-863e-358e2719bf88"}</code> </pre> <br><h3 id="izmeneniya-db-1"> 数据库更改 </h3><br><p> 对于<code>v3</code>我们只需删除<code>last_name</code>列并添加缺少的约束。 </p><br><pre> <code class="plaintext hljs">-- REMOVE THE COLUMN ALTER TABLE PERSON DROP last_name; -- ADD CONSTRAINTS UPDATE PERSON SET surname='' WHERE surname IS NULL; ALTER TABLE PERSON ALTER COLUMN surname VARCHAR NOT NULL;</code> </pre> <br><h3 id="izmeneniya-koda-4"> 代码变更 </h3><br><p> 代码没有变化。 </p><br><h3 id="vyvod"> 结论 </h3><br><p> 我们通过执行几个向后兼容的部署成功地应用了向后不兼容的列名更改。 以下是所采取步骤的摘要： </p><br><ol><li> 具有<code>v1</code>数据库架构的应用程序部署版本<code>1.0.0</code> （列名称= <code>last_name</code> ） </li><li> 部署应用程序版本<code>2.0.0,</code>该版本将数据保存在<code>last_name</code>和<code>surname</code> 。 应用程序从<code>last_name</code>读取。 该数据库的版本为<code>v2</code> ，其中包含<code>last_name</code>和<code>surname. surname</code>的列<code>surname. surname</code>  <code>surname. surname</code>是l <code>ast_name</code>的副本。 (:       not null) </li><li>    <code>3.0.0</code> ,      <code>surname</code>    surname.   ,     <code>last_name</code>  <code>surname</code> .   <strong>NOT NULL</strong>   <code>last_name</code> .     <code>v3</code> </li><li>    <code>4.0.0</code> —      .    <code>v4</code> ,   <code>last_name</code> .         . </li></ol><br><p>   ,        ,      / . </p><br><h3 id="kod"> 代号 </h3><br><p>  ,    ,   <a href="https://github.com/spring-cloud-samples/zero-downtime-deployment">Github</a> .   . </p><br><h3 id="proekty">  </h3><br><p>   ,     . </p><br><pre> <code class="plaintext hljs">├── boot-flyway-v1 - 1.0.0 version of the app with v1 of the schema ├── boot-flyway-v2 - 2.0.0 version of the app with v2 of the schema (backward-compatible - app can be rolled back) ├── boot-flyway-v2-bad - 2.0.0.BAD version of the app with v2bad of the schema (backward-incompatible - app cannot be rolled back) ├── boot-flyway-v3 - 3.0.0 version of the app with v3 of the schema (app can be rolled back) └── boot-flyway-v4 - 4.0.0 version of the app with v4 of the schema (app can be rolled back)</code> </pre> <br><h3 id="skripty">  </h3><br><p>    ,    ,         . </p><br><p>   <strong>    </strong> , : </p><br><pre> <code class="plaintext hljs">./scripts/scenario_backward_compatible.sh</code> </pre> <br><p>    <strong>    </strong> , : </p><br><pre> <code class="plaintext hljs">./scripts/scenario_backward_incompatible.sh</code> </pre> <br><h3 id="spring-boot-sample-flyway"> Spring Boot Sample Flyway </h3><br><p>     <code>Spring Boot Sample Flyway.</code> </p><br><p>     <code>http://localhost:8080/flyway</code> ,   . </p><br><p>        H2 (  <code>http://localhost:8080/h2-console</code> ),        (URL jdbc   — <code>jdbc:h2:mem:testdb</code> ). </p><br><h2 id="dopolnitelno"> 选配 </h2><br><ul><li> <a href="https://databaserefactoring.com/">Database Refactoring patterns</a> </li><li> <a href="https://martinfowler.com/bliki/ContinuousDelivery.html">Continuous Delivery</a> </li></ul><br><h2 id="takzhe-chitayte-drugie-stati-v-nashem-bloge"> 另请阅读我们博客上的其他文章： </h2><br><ul><li>  <a href="https://habr.com/ru/company/nixys/blog/480072/">Kubernetes：为什么设置系统资源管理如此重要？</a> </li><li>  <a href="https://habr.com/ru/company/nixys/blog/481992/">Tekton管道-Kubernetes原生管道</a> </li><li>  <a href="https://habr.com/ru/company/nixys/blog/473578/">为Nginx构建动态模块</a> </li><li>  <a href="https://habr.com/ru/company/nixys/blog/473014/">Hashicorp Consul的Kubernetes授权简介</a> </li><li>  <a href="https://habr.com/ru/company/nixys/blog/468779/">从未经授权的ClickHouse迁移到具有授权的ClickHouse的结果是什么？</a> </li><li>  <a href="https://habr.com/ru/company/nixys/blog/470568/">使用Nginx Web Server进行Spring应用程序的蓝绿色部署</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN481932/">https://habr.com/ru/post/zh-CN481932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN481916/index.html">记得2019年的发展年是什么？</a></li>
<li><a href="../zh-CN481922/index.html">新年IMaskjs 6-React Native，管道，ESM</a></li>
<li><a href="../zh-CN481924/index.html">Apache Spark，惰性评估和多页SQL查询</a></li>
<li><a href="../zh-CN481926/index.html">满足适用于AWS的新Veeam Backup解决方案</a></li>
<li><a href="../zh-CN481930/index.html">发展文化：如何评估绩效和效率</a></li>
<li><a href="../zh-CN481934/index.html">分析：特斯拉股价为何上涨</a></li>
<li><a href="../zh-CN481936/index.html">A / B测试的优缺点：大公司的经验</a></li>
<li><a href="../zh-CN481940/index.html">在命令行中快速有效地工作</a></li>
<li><a href="../zh-CN481942/index.html">回到未来：2010年展示了哪些现代游戏</a></li>
<li><a href="../zh-CN481944/index.html">是什么决定了网站在搜索页面上的位置？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>