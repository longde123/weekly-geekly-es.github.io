<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äç‚öïÔ∏è ü§¥ üöø Resolvemos las tareas de Yandex.Interview en un estilo funcional üé¶ üíÇüèº üòÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace unos meses, apareci√≥ un art√≠culo en el blog de Yandex que discut√≠a el paso de la secci√≥n algor√≠tmica de la entrevista. Entre otras cosas, en este...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Resolvemos las tareas de Yandex.Interview en un estilo funcional</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470790/"><p>  Hace unos meses, apareci√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un art√≠culo</a> en el blog de Yandex que discut√≠a el paso de la secci√≥n algor√≠tmica de la entrevista.  Entre otras cosas, en este art√≠culo, se proporcion√≥ un enlace a un concurso especial que conten√≠a tareas similares a las ofrecidas por Yandex a sus candidatos. </p><br><p>  Al registrarme en el sistema, me llam√≥ la atenci√≥n de inmediato la capacidad de resolver problemas en Haskell.  El hecho es que, aunque soy aficionado a la programaci√≥n en este lenguaje, no he avanzado m√°s all√° de la implementaci√≥n de tareas de varios cursos de plataformas educativas en l√≠nea.  Habiendo decidido que su soluci√≥n puede ser un desaf√≠o interesante y aumentar√° mi nivel como desarrollador, proced√≠ a resolverlos. </p><br><p>  A qui√©n le importa lo que finalmente surgi√≥, bienvenido a cat. </p><a name="habracut"></a><br><h2 id="a-kamni-i-ukrasheniya">  A. Piedras y joyas. </h2><br><blockquote> Se dan dos l√≠neas de caracteres latinos en min√∫scula: cadena J y cadena S. Los caracteres incluidos en la cadena J son "joyas" y se incluyen en la cadena S son "piedras".  Es necesario determinar cu√°ntos caracteres de S son simult√°neamente "joyas".  En pocas palabras, debe verificar cu√°ntos caracteres de S hay en J. </blockquote><p>  La primera tarea es un calentamiento, lo resolveremos "en la frente".  Definimos la funci√≥n <em>jewelleryCount :: String -&gt; String -&gt; Int</em> , que, utilizando la convoluci√≥n de la lista pasada por el segundo argumento, resume todos los casos del elemento que se procesa en la primera lista.  Para estos fines, definimos la funci√≥n <em>elemInt en</em> funci√≥n de la funci√≥n <em>elem</em> , que, a diferencia de la √∫ltima, no devolver√° True o False, sino el n√∫mero 0 o 1. En la funci√≥n principal, solo necesita leer dos l√≠neas, pasarlas a la funci√≥n correspondiente e imprimir el resultado.  El veredicto del sistema de prueba est√° bien, pasamos a la segunda tarea. </p><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">jeweleryCount</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> jeweleryCount j = foldr ((+).(elemInt j)) <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> elemInt sx = fromEnum $ elem xs main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> j &lt;- getLine s &lt;- getLine print $ jeweleryCount js</code> </pre> <br><p>  <em>El c√≥digo fuente para resolver esta y otras tareas tambi√©n est√° disponible en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">repositorio de github.</a></em> </p><br><h2 id="b-posledovatelno-iduschie-edinicy">  B. Unidades consecutivas </h2><br><blockquote>  Se requiere encontrar la secuencia m√°s larga de unidades en el vector binario e imprimir su longitud. </blockquote><p>  Para resolver este problema, implementamos una funci√≥n recursiva que recorrer√° la lista transferida y calcular√° la longitud de la secuencia requerida.  Con los argumentos de la funci√≥n, adem√°s de la lista en s√≠, pasaremos la longitud m√°xima actual y el n√∫mero de unidades consecutivas en la llamada actual.  Primero, definimos la base de recursi√≥n en la lista vac√≠a, y luego el paso de recursi√≥n en s√≠. </p><br><p>  Para leer los datos de entrada, definimos la funci√≥n <em>getUserInputs :: IO [Char]</em> , en la que primero leemos el n√∫mero n - el tama√±o de la lista, y luego usando el combinador <em>replicateM</em> obtenemos una funci√≥n que llamar√° a la funci√≥n <em>&lt;&lt;get&gt; getLine</em> n veces y fusionar√° los resultados en una lista . </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad (<span class="hljs-title"><span class="hljs-title">replicateM</span></span>) onesCount :: [Char] -&gt; Int onesCount xs = onesCount' xs 0 0 where onesCount' "" max curr | max &gt; curr = max | otherwise = curr onesCount' (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) max curr | x == '1' = onesCount' xs max $ curr + 1 | curr &gt; max = onesCount' xs curr 0 | otherwise = onesCount' xs max 0 getUserInputs :: IO [Char] getUserInputs = do n &lt;- read &lt;$&gt; getLine :: IO Int replicateM n $ head &lt;$&gt; getLine main :: IO () main = do xs &lt;- getUserInputs print $ onesCount xs</code> </pre><br><p>  Enviamos la decisi√≥n, el veredicto est√° bien.  Seguimos adelante. </p><br><h2 id="c-udalenie-dublikatov">  C. Eliminaci√≥n duplicada </h2><br><blockquote>  Se proporciona una matriz de enteros de 32 bits ordenados en orden no decreciente.  Es necesario eliminar todas las repeticiones. </blockquote><p>  Comencemos con una implementaci√≥n simple.  Definimos una funci√≥n inicial que lee un n√∫mero, lo imprime y lo devuelve envuelto en la m√≥nada IO.  Tambi√©n definimos la funci√≥n <em>deleteDoubles :: Int -&gt; Int -&gt; IO ()</em> , que lee un n√∫mero y lo imprime solo si no es igual al segundo argumento (pasaremos el n√∫mero le√≠do en el paso anterior all√≠).  Despu√©s de eso, la funci√≥n se llama recursivamente y, por lo tanto, pasa al siguiente n√∫mero en la secuencia de entrada.  La base de recursi√≥n es el n√∫mero de n√∫meros a leer, le pasaremos el primer argumento. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad initial :: IO Int initial = do a &lt;- read &lt;$&gt; getLine print a return a deleteDoubles :: Int -&gt; Int -&gt; IO() deleteDoubles 0 _ = return () deleteDoubles ta = do b &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">a</span></span> == <span class="hljs-title"><span class="hljs-title">b</span></span>) $ print b deleteDoubles (<span class="hljs-title"><span class="hljs-title">t</span></span>-1) b main :: IO () main = do t &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">t</span></span> &lt; 1) $ initial &gt;&gt;= deleteDoubles (<span class="hljs-title"><span class="hljs-title">t</span></span>-1)</code> </pre> <br><p>  Enviamos la soluci√≥n, pasa todas las pruebas y parece que podemos pasar a la siguiente tarea, pero en mi opini√≥n, la llamada recursiva de la funci√≥n que funciona en la m√≥nada IO es m√°s confusa que concisa.  Intentemos mejorarlo. </p><br><p>  Tenga en cuenta que, en t√©rminos generales, primero puede leer la lista completa de n√∫meros (usaremos el combinador replicateM que ya est√° familiarizado con la segunda tarea), luego pasarlo a una funci√≥n pura que filtre todas las repeticiones y finalmente imprima el resultado. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad deleteDoubles' _ [] = [] deleteDoubles' prev (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) | prev /= x = x:(<span class="hljs-title"><span class="hljs-title">deleteDoubles'</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) | otherwise = deleteDoubles' x xs deleteDoubles (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) = x:deleteDoubles' x xs getUserInputs :: Int -&gt; IO [Int] getUserInputs t = replicateM t $ read &lt;$&gt; getLine main :: IO () main = do t &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">t</span></span> &lt; 1) $ (<span class="hljs-title"><span class="hljs-title">deleteDoubles</span></span> &lt;$&gt; <span class="hljs-title"><span class="hljs-title">getUserInputs</span></span> <span class="hljs-title"><span class="hljs-title">t</span></span>) &gt;&gt;= mapM_ print</code> </pre> <br><p>  Estoy enviando una soluci√≥n, y la primera decepci√≥n es que el programa no pasa la prueba 193 debido a que excede el l√≠mite de memoria utilizada.  El error principal es leer la lista completa en la memoria como un todo.  Intentaremos evitar esto e implementaremos un cierto h√≠brido de la primera y segunda versi√≥n. </p><br><p>  Tenga en cuenta que la tarea de eliminar duplicados recuerda un poco a una convoluci√≥n asociativa izquierda: en cada paso calculamos una funci√≥n que, dependiendo del elemento actual le√≠do y parte de su resultado, en el paso anterior decide imprimir, y luego pasa al siguiente par de valores. </p><br><p>  Una funci√≥n que imprime o no imprime el resultado dependiendo de sus argumentos, despu√©s de lo cual devuelve su segundo argumento, envuelto en la m√≥nada IO, es bastante simple, llam√©moslo paso: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">step</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> step fst snd = unless (fst == snd) (print snd) &gt;&gt; return snd</code> </pre> <br><p>  Descubrimos si imprimir o no, dependiendo de los valores pasados, pero ¬øc√≥mo organizar la lectura?  Para hacer esto, utilizamos la funci√≥n de convoluci√≥n mon√°dica <em>foldM :: (Plegable t, M√≥nada m) =&gt; (b -&gt; a -&gt; mb) -&gt; b -&gt; ta -&gt; mb</em> , que es aplicable a la lista de funciones de lectura. <br>  Por tipo de funci√≥n foldM, observamos que en cada paso el ‚Äúdesempaquetado‚Äù del resultado de la aplicaci√≥n previa de la funci√≥n ocurre bajo el cap√≥ de foldM.  Por lo tanto, en cada paso solo necesitamos comenzar un c√°lculo mon√°dico del elemento de la lista actual (de hecho, leer el siguiente n√∫mero) usando el operador de <em>enlace</em> ( <em>&gt;&gt; =</em> ) y pasarlo junto con el n√∫mero anterior al paso.  Como resultado, obtenemos el siguiente programa </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">step</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> step fst snd = unless (fst == snd) (print snd) &gt;&gt; return snd initial :: <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> initial = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a &lt;- read &lt;$&gt; getLine print a return a getUserInputs t = replicate t $ read &lt;$&gt; getLine main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> t &lt;- read &lt;$&gt; getLine unless (t &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> init &lt;- initial foldM_ ((=&lt;&lt;) . step) init $ getUserInputs (t<span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br><h2 id="d-generaciya-skobochnyh-posledovatelnostey">  D. Generaci√≥n de secuencias de par√©ntesis. </h2><br><blockquote>  Dado un n√∫mero entero n.  Es necesario derivar todas las secuencias de par√©ntesis correctas de longitud 2 n, ordenadas lexicogr√°ficamente (ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">https://ru.wikipedia.org/wiki/Lexographic_order</a> ). <br>  Solo se usan par√©ntesis en la tarea. <br>  Es recomendable obtener una soluci√≥n que funcione en un tiempo proporcional al n√∫mero total de secuencias de par√©ntesis correctas en la respuesta, y al mismo tiempo utiliza una capacidad de memoria proporcional a n. </blockquote><p>  Esta tarea, como muchas otras, en la que es necesario derivar secuencias que satisfagan ciertas condiciones (por ejemplo, la tarea de intercambiar monedas, organizar ocho reinas y otras, se puede leer con m√°s detalle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">aqu√≠</a> ), se resuelve sucintamente utilizando la m√≥nada de la lista.  En resumen, este enfoque se basa en el enlace mon√°dico para listas, cuyo significado es unir el conjunto de operaciones realizadas en cada elemento de la lista. </p><br><p>  Defina la funci√≥n recursiva <em>generate ':: Int -&gt; Int -&gt; [[Char]]</em> , que toma el n√∫mero de corchetes que se colocar√°n como segundo argumento, y el n√∫mero de corchetes de apertura no cerrados ya establecidos.  Para el paso de recursi√≥n, necesitamos dos funciones auxiliares: <em>posible</em> : devuelve una lista de corchetes que se pueden colocar en el siguiente paso y <em>paso</em> : realiza una llamada recursiva a la funci√≥n de generaci√≥n con los par√°metros necesarios. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad(<span class="hljs-title"><span class="hljs-title">mapM_</span></span>) generate :: Int -&gt; [String] generate = generate' 0 where generate' _ 0 = [[]] generate' an = [x:xs | x &lt;- possible, xs &lt;- step x] where step '(' = <span class="hljs-title"><span class="hljs-title">generate'</span></span> (<span class="hljs-title"><span class="hljs-title">a</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) step ')' = generate' (<span class="hljs-title"><span class="hljs-title">a</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) possible | n == a = ")" | a == 0 = "(" | <span class="hljs-title"><span class="hljs-title">otherwise</span></span> = "()" main :: IO () main = do n &lt;- read &lt;$&gt; getLine let result = generate $ n * 2 mapM_ putStrLn result</code> </pre><br><p>  Enviamos la soluci√≥n y entendemos que no tomamos en cuenta la restricci√≥n que se impuso a la cantidad de memoria utilizada por el programa; la soluci√≥n no pasa la 14a prueba debido a que se excede el l√≠mite de memoria utilizada. </p><br><p>  Modificamos la funci√≥n de generaci√≥n para que, en lugar de construir la lista completa de secuencias de par√©ntesis correctas, las muestre inmediatamente en la pantalla.  Para hacer esto, tendremos que agregar el tercer argumento a la funci√≥n: un fragmento de la secuencia construida para el paso actual.  Observo que en esta implementaci√≥n construiremos la secuencia en el orden inverso, esto nos permitir√° usar el constructor de lista ( <em>:) en</em> lugar del operador de concatenaci√≥n m√°s costoso ( <em>++</em> ). </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad(<span class="hljs-title"><span class="hljs-title">mapM_</span></span>) generate :: Int -&gt; IO() generate = generate' "" 0 where generate' xs _ 0 = putStrLn $ reverse xs generate' xs an | n == a = step ')' | a == 0 = step '(' | <span class="hljs-title"><span class="hljs-title">otherwise</span></span> = <span class="hljs-title"><span class="hljs-title">step</span></span> '(' &gt;&gt; <span class="hljs-title"><span class="hljs-title">step</span></span> ')' where step '(' = <span class="hljs-title"><span class="hljs-title">generate'</span></span> ('(':<span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-title"><span class="hljs-title">a</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) step ')' = generate' (')':xs) (<span class="hljs-title"><span class="hljs-title">a</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) main :: IO () main = do n &lt;- read &lt;$&gt; getLine generate $ n * 2</code> </pre><br><h2 id="e-anagrammy">  E. Anagramas </h2><br><blockquote>  Se dan dos l√≠neas, que consisten en letras latinas min√∫sculas.  Es necesario determinar si estas l√≠neas son anagramas, es decir, difieren solo en la secuencia de caracteres. </blockquote><p>  Para resolver este problema, contaremos cu√°ntas veces aparece una letra en cada fila y compararemos los resultados.  Inmediatamente entendemos que las listas est√°ndar no son adecuadas para nosotros, y es necesario usar una estructura de datos que nos permita acceder efectivamente al elemento por su √≠ndice.  Existen varios tipos de datos que satisfar√≠an nuestras condiciones, pero usaremos la matriz de <em>datos</em> inmutable est√°ndar <em>Data.Array</em> (todav√≠a hay al menos varias matrices mutables, as√≠ como <em>Data.Vector</em> ). </p><br><p>  Para construir las matrices necesarias, utilizamos la funci√≥n <em>hist :: (Ix a, Num b) =&gt; (a, a) -&gt; [a] -&gt; Array ab</em> , que, de acuerdo con la lista de elementos transferidos y el rango al que deben pertenecer estos elementos, forma una matriz, que almacena el n√∫mero de repeticiones de elementos de la lista.  Esta funci√≥n, aunque no se incluye en el m√≥dulo Data.Array, a menudo se da como un ejemplo del uso de otra funci√≥n, ya de biblioteca, acumulaci√≥nArray.  Solo podemos copiar su implementaci√≥n y escribir main: el beneficio de la comparaci√≥n de igualdad para <em>Array Char Int</em> ya <em>est√°</em> definido.  Le llamo la atenci√≥n sobre una caracter√≠stica agradable: como √≠ndice podemos usar no solo enteros, sino tambi√©n cualquier representante de la clase <em>Ix</em> .  En nuestro caso, Char juega un papel natural en este papel. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Array hist :: (<span class="hljs-type"><span class="hljs-type">Ix</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>, <span class="hljs-type"><span class="hljs-type">Num</span></span> <span class="hljs-title"><span class="hljs-title">b</span></span>) =&gt; (<span class="hljs-title"><span class="hljs-title">a</span></span>,<span class="hljs-title"><span class="hljs-title">a</span></span>) -&gt; [a] -&gt; Array ab hist bnds is = accumArray (+) 0 bnds [(<span class="hljs-title"><span class="hljs-title">i</span></span>, 1) | i&lt;-is, inRange bnds i] main = do arr1 &lt;- hist ('<span class="hljs-title"><span class="hljs-title">a'</span></span>,'<span class="hljs-title"><span class="hljs-title">z'</span></span>) &lt;$&gt; getLine arr2 &lt;- hist ('<span class="hljs-title"><span class="hljs-title">a'</span></span>,'<span class="hljs-title"><span class="hljs-title">z'</span></span>) &lt;$&gt; getLine if (<span class="hljs-title"><span class="hljs-title">arr1</span></span> == <span class="hljs-title"><span class="hljs-title">arr2</span></span>) then print 1 else print 0</code> </pre><br><h2 id="f-sliyanie-k-sortirovannyh-spiskov">  F. Fusionar k listas ordenadas </h2><br><blockquote>  Se proporcionan matrices de enteros no negativos ordenados en orden no decreciente, cada uno de los cuales no supera los 100. Se requiere construir el resultado de su fusi√≥n: una matriz ordenada en orden no decreciente que contiene todos los elementos de las matrices k originales. <br>  La longitud de cada matriz no excede 10 ‚ãÖ k. <br>  Intente hacer que la soluci√≥n funcione durante el tiempo k ‚ãÖ log (k) ‚ãÖ n, si suponemos que las matrices de entrada son de longitud n. </blockquote><p>  La fusi√≥n de dos listas ordenadas es una tarea de lista cl√°sica y est√° cubierta en muchos cursos sobre programaci√≥n de Haskell.  Por ejemplo, se puede resolver de la siguiente manera. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">merge</span></span> :: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] merge [] ys = ys merge xs [] = xs merge (x:xs) (y:ys) | x &lt; y = x:merge xs (y:ys) | otherwise = y:merge (x:xs) ys</code> </pre><br><p>  Bueno, podemos fusionar dos listas.  ¬øY qu√© debemos hacer con la lista de listas?  ¬°Convol√∫celo con esta funci√≥n!  Por lo tanto, combinaremos todas las listas en una, y solo tendremos que imprimirla. </p><br><div class="spoiler">  <b class="spoiler_title">Soluci√≥n</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad merge :: [Int] -&gt; [Int] -&gt; [Int] merge [] ys = ys merge xs [] = xs merge (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-title"><span class="hljs-title">y</span></span>:<span class="hljs-title"><span class="hljs-title">ys</span></span>) | x &lt; y = x:merge xs (<span class="hljs-title"><span class="hljs-title">y</span></span>:<span class="hljs-title"><span class="hljs-title">ys</span></span>) | otherwise = y:merge (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) ys mergeLists :: [[Int]] -&gt; [Int] mergeLists = foldl merge [] getUserInputs :: Int -&gt; IO [[Int]] getUserInputs t = replicateM t $ do n &lt;- getLine return $ tail $ read &lt;$&gt; words n main :: IO () main = do k &lt;- read &lt;$&gt; getLine lists &lt;- getUserInputs k let res = mergeLists lists mapM_ (<span class="hljs-title"><span class="hljs-title">putStrLn</span></span> . <span class="hljs-title"><span class="hljs-title">show</span></span>) res</code> </pre> </div></div><br><p>  Sin embargo, esta soluci√≥n tiene dos problemas serios: la complejidad computacional es mayor que la requerida: <em>O (k ^ 2 ‚ãÖ n) en</em> lugar de <em>O (k ‚ãÖ log (k) ‚ãÖ n)</em> , adem√°s de que usa mucha memoria adicional.  Como resultado, esta soluci√≥n falla la prueba n√∫mero 17 debido a que excede el l√≠mite de memoria utilizada: 17.27Mb en lugar de los 10Mb permitidos. </p><br><p>  Si bien no prestaremos atenci√≥n al hecho de que los n√∫meros suministrados a la entrada pertenecen a un rango limitado de valores, y continuamos buscando soluciones para un caso m√°s general. </p><br><p>  El siguiente paso es tratar de implementar el enfoque que se propuso en el art√≠culo original con el an√°lisis de estas tareas.  Perm√≠tame recordarle que se basa en el uso de una estructura de datos que proporciona una forma eficiente de extraer el elemento m√≠nimo.  Como tal estructura, seleccione <em>Data.Set</em> .  Inicializamos Set con la lista de primeros elementos, luego en cada paso extraeremos e imprimiremos el elemento m√≠nimo, y luego agregaremos el siguiente elemento de la lista correspondiente.  Adem√°s, necesitaremos una estructura <em>Data.Sequence</em> para almacenar las listas.  Se eligi√≥ por razones que en cada paso es necesario tener acceso r√°pido a la lista por su √≠ndice (que la lista no puede proporcionar) y cambiar el elemento de este elemento sin la necesidad de copiar toda la estructura (que en general no puede proporcionar <em>datos</em> inmutables <em>). Array</em> ). </p><br><p>  Por lo tanto, tenemos el siguiente programa: </p><br><div class="spoiler">  <b class="spoiler_title">Soluci√≥n</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Sequence <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Seq <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Set <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Set <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Foldable mergeLists :: Set.Set (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; Seq.Seq [Int] -&gt; IO () mergeLists set seq | Set.null set = return () | otherwise = do let ((<span class="hljs-title"><span class="hljs-title">val</span></span>, <span class="hljs-title"><span class="hljs-title">idx</span></span>), set') = Set.deleteFindMin set print val if null (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">index</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span>) then mergeLists set' seq else mergeLists (<span class="hljs-type"><span class="hljs-type">Set</span></span>.<span class="hljs-title"><span class="hljs-title">insert</span></span> (<span class="hljs-title"><span class="hljs-title">head</span></span> (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">index</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span>), idx) set') (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">adjust</span></span> <span class="hljs-title"><span class="hljs-title">tail</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span>) getUserInputs :: Int -&gt; IO [[Int]] getUserInputs t = replicateM t $ do n &lt;- getLine return $ tail $ read &lt;$&gt; words n main :: IO () main = do t &lt;- read &lt;$&gt; getLine lists &lt;- getUserInputs t let init_seq = Seq.fromList (<span class="hljs-title"><span class="hljs-title">filter</span></span> (<span class="hljs-title"><span class="hljs-title">not</span></span> . <span class="hljs-title"><span class="hljs-title">null</span></span>) lists) let init_heap = Set.fromList (<span class="hljs-title"><span class="hljs-title">zipWith</span></span> (,) (<span class="hljs-title"><span class="hljs-title">toList</span></span> (<span class="hljs-title"><span class="hljs-title">fmap</span></span> <span class="hljs-title"><span class="hljs-title">head</span></span> <span class="hljs-title"><span class="hljs-title">init_seq</span></span>)) [0..]) mergeLists init_heap $ tail &lt;$&gt; init_seq</code> </pre></div></div><br><p>  Enviamos la soluci√≥n y descubrimos que a pesar de que el programa comenz√≥ a consumir mucha menos memoria (10.26Mb en lugar de 17.27Mb en la 17a prueba), a√∫n no alcanz√≥ el l√≠mite.  La raz√≥n de esto radica en el hecho de que con esta decisi√≥n, de una forma u otra, tenemos que leer todos los datos de entrada en la memoria.  Intentemos evitar esto con la ayuda de la tercera soluci√≥n a este problema: ordenar por conteo. </p><br><p>  Ya hemos realizado el recuento de la cantidad de caracteres entrantes al resolver el problema del anagrama anterior.  Adem√°s, como para resolverlo, usaremos <em>Data.Array</em> .  Primero, implementamos la funci√≥n <em>addToArray :: Array Int Int -&gt; [Int] -&gt; Array Int Int</em> , que forma una matriz basada en la existente al aumentar los valores en los √≠ndices que corresponden a los valores de la lista. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">addToArray</span></span> :: <span class="hljs-type"><span class="hljs-type">Array</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Array</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> addToArray acc elems = accum (+) acc [(i, <span class="hljs-number"><span class="hljs-number">1</span></span>) | i&lt;-elems]</code> </pre><br><p>  Luego, usaremos el enfoque que conocemos en el problema de eliminar repeticiones: usar la convoluci√≥n mon√°dica, aplicando secuencialmente la funci√≥n <em>addToArray</em> a <em>k</em> matrices de origen.  Y ... obtenemos el mismo resultado de 10.26Mb en la 17a prueba.  Y luego es hora de recordar que <em>foldl</em> (cuyo an√°logo es <em>foldM</em> ) de acuerdo con el orden de reducci√≥n aceptado expandir√° primero toda la cadena de expresiones anidadas y solo luego proceder√° a su c√°lculo activo.  Como saben, para combatir este hecho, el m√≥dulo <em>Data.List</em> implementa la funci√≥n <em>foldl '</em> , que usa la funci√≥n <em>seq :: a -&gt; b -&gt; b</em> , que primero lanza el primer argumento a la forma normal de la cabeza d√©bil, es decir, la reduce a la parte externa. el valor de la funci√≥n o constructor, y luego devuelve el segundo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">https://www.ibm.com/developerworks/ru/library/l-haskell4/index.html</a> ).  No tenemos m√°s remedio que implementar la funci√≥n <em>foldM 'de forma independiente</em> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldM'</span></span> :: (<span class="hljs-type"><span class="hljs-type">Monad</span></span> m) =&gt; (a -&gt; b -&gt; ma) -&gt; a -&gt; [b] -&gt; ma foldM' _ z [] = return z foldM' fz (x:xs) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> z' &lt;- fzx z' `seq` foldM' fz' xs</code> </pre> <br><p>  Como resultado, ¬°la cantidad de memoria usada en la 17¬™ prueba casi se redujo a la mitad y ascendi√≥ a 5.64Mb!  Aunque las pruebas 17 y 18 se aprobaron con √©xito, esta implementaci√≥n no pas√≥ la prueba 19 por la misma raz√≥n por la que se excedi√≥ el l√≠mite de memoria: 10.25Mb. </p><br><p>  Bien, sigan adelante: todav√≠a no hemos probado Data.Array.Unboxed.  Este tipo de matrices es notable porque, a diferencia del est√°ndar, puede almacenar los valores en s√≠ mismos, en lugar de indicadores para ellos ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">https://wiki.haskell.org/Arrays#Unboxed_arrays</a> ).  Debido a esto, tales matrices ocupan menos espacio en la memoria y son m√°s eficientes.  Para usarlos, solo necesitamos cambiar los tipos de importaci√≥n y funci√≥n, ya que <em>Data.Array</em> y <em>Data.Array.Unboxed</em> implementan una interfaz de matrices <em>IArray</em> inmutables. </p><br><p>  Estamos enviando una soluci√≥n: el consumo de memoria ha disminuido 4.5 veces a 2.26 MB, pero no ha pasado el l√≠mite de tiempo, el tiempo de ejecuci√≥n fue de 1.09 segundos.  ¬øCon qu√© podr√≠a estar conectado esto?  A juzgar por el hecho de que el tiempo de ejecuci√≥n de las pruebas restantes sigue siendo el mismo, creo que la raz√≥n no es que la matriz sin caja result√≥ ser m√°s lenta que la caja, sino en particular el sistema de prueba.  Parece que la tarea se interrumpe tan pronto como se viola una de las restricciones.  Sin embargo, en casos muy raros, esta implementaci√≥n todav√≠a pasa la prueba 19 con un resultado de 0,98 segundos, pero falla la prueba n√∫mero 20 tambi√©n debido a que excede el l√≠mite de tiempo. </p><br><p>  Despu√©s de eso, intent√© usar el an√°logo inseguro de la funci√≥n acumular, que en teor√≠a deber√≠a ser m√°s r√°pido, varios m√©todos de almacenamiento en b√∫fer ( <em>hSetBuffering :: Handle -&gt; BufferMode -&gt; IO ()</em> function), matrices <em>IOArray</em> mutables, pero ninguno de estos m√©todos arroj√≥ ning√∫n resultado . </p><br><p>  No me inclino a creer que los l√≠mites para Haskell est√©n demasiado ajustados, y espero que todav√≠a haya una soluci√≥n que pase todas las pruebas.  En el repositorio del proyecto, publiqu√© varias versiones diferentes del c√≥digo para resolver este problema (con Array e IOArray), quiz√°s este sea el punto de partida para una soluci√≥n que pasar√° todas las pruebas. </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>  Incluso a pesar de que solo cinco de las seis tareas me sucumbieron, complet√© mi tarea principal: practicar la programaci√≥n funcional.  Las restricciones severas sobre los recursos consumidos por el programa jugaron un papel importante, lo que nos oblig√≥ a buscar cada vez m√°s enfoques nuevos para resolver problemas.  Espero que su descripci√≥n sea √∫til para aquellos que reci√©n comienzan su viaje en la programaci√≥n funcional. </p><br><p>  ¬øFue conveniente el enfoque funcional para resolver tales problemas?  Sinceramente, tengo una doble impresi√≥n.  Por un lado, las soluciones a la mayor√≠a de los problemas resultaron ser muy concisas, y las herramientas expresivas del propio Haskell, as√≠ como su rica biblioteca est√°ndar, jugaron un papel importante en esto.  Por otro lado, uno no puede dejar de admitir que, en la mayor√≠a de los casos, la gesti√≥n de los recursos consumidos puede ser un cierto problema, que no permitir√° resolver el problema en las restricciones dadas. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/470790/">https://habr.com/ru/post/470790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../470778/index.html">Revisi√≥n de la unidad Seagate ST2000DM008: r√°pido "dos" sin sobreprecio</a></li>
<li><a href="../470780/index.html">La barra est√° tomada: lo nuevo de Seagate para almacenamiento</a></li>
<li><a href="../470782/index.html">Datos en la frontera: c√≥mo construir una nueva arquitectura de TI</a></li>
<li><a href="../470784/index.html">El dise√±o de color de los misteriosos mundos de Dead Cells.</a></li>
<li><a href="../470786/index.html">Preparaci√≥n para la certificaci√≥n profesional de primavera. Seguridad de primavera</a></li>
<li><a href="../470792/index.html">Entrevista con uno de los creadores de Untitled Goose Game</a></li>
<li><a href="../470794/index.html">Laravel: explica los conceptos b√°sicos. Primera parte: teor√≠a</a></li>
<li><a href="../470800/index.html">P - anticipaci√≥n, as√≠ como el programa preliminar DUMP Kazan. Vea los informes que han pasado la selecci√≥n de picadora de carne</a></li>
<li><a href="../470802/index.html">Copia de seguridad, Parte 6: Comparaci√≥n de herramientas de copia de seguridad</a></li>
<li><a href="../470804/index.html">Premio Alice: 5 ideas del ganador</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>