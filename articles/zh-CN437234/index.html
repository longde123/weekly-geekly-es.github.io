<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📅 🖐️ 🏸 我们以STM32F030f4p6为例开始研究微控制器 👨‍🔧 🤦🏼 🍙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="0.阅读文章之前 
 本文的目标如下： 



1. 展示如何专门使用此板； 
2. 显示仅依靠文档和逻辑即可编写闪烁的LED程序的方法； 
3. 以对微控制器不熟悉的人可以理解的语言展示材料。 
 就使用其他文件而言，该代码将变得非常简单-我们将不包括单个文件，除了构建空的但有效的固件所需的文件之...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们以STM32F030f4p6为例开始研究微控制器</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437234/"><img src="https://habrastorage.org/webt/ex/dh/0-/exdh0-6tdd7sj-4usxbip9chsz0.jpeg"><br><br><h1>  0.阅读文章之前 </h1><br> 本文的目标如下： <br><br><ol><li> 展示如何专门使用此板； </li><li> 显示仅依靠文档和逻辑即可编写闪烁的LED程序的方法； </li><li> 以对微控制器不熟悉的人可以理解的语言展示材料。 </li></ol><br> 就使用其他文件而言，该代码将变得非常简单-我们将不包括单个文件，除了构建空的但有效的固件所需的文件之外。 即 基于固件代码，虽然可以，但是没有任何用处。 <br><a name="habracut"></a><br> 我们将需要以下文档： <br><br><ol><li> 数据表STM32F030x4（我使用2017年1月的文档DocID024849 Rev 3）; </li><li>  RM0360参考手册STM32F030x4 / x6 / x8 / xC（我使用2017年4月的文档DocID025023 Rev 4）; </li><li> 电路板。 </li></ol><br> 您可以从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">云中</a>下载这些文档。 <br> 本文中的计时器将<i>不</i>被考虑，并且<i>不会</i>被包含在代码中。 <br>  <i>未</i>使用ST-LINK编程器。 为了与开发板一起使用，使用了USB-COM适配器（基于PL2303HX的RS232），该适配器可模拟COM端口。 <br><br><div class="spoiler">  <b class="spoiler_title">照片适配器</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/wp/em/u8/wpemu8n1juvbuipavxu-mzfa2eq.jpeg"></div></div><br> 一切都收集在通过Windows X主机上的VirtualBox版本5.2.22r126460运行的Windows XP Professional 2002 SP3虚拟机上。 <br><br><h1>  1.安装USB-COM适配器的驱动程序 </h1><br>  Windows没有帮助，请从官方网站<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Prolific</a> （在Google中请求“ prolific driver”的第一个链接）下载驱动程序USB到UART / Serial / Printer <b>PL2303 Windows Driver</b> （您需要一个<i>Standard Driver</i> ）。 或者，您可以从我的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">云</a>下载。 <br><br> 安装驱动程序，重新启动并查看新的COM端口。 <br><br><div class="spoiler">  <b class="spoiler_title">屏幕快照，其中包含安装程序的名称和新的COM端口</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/tq/tt/dh/tqttdhvov6eiov75df-pqcycz0s.png"></div></div><br> 端口设置为标准配置。 您可以自行决定更改COM端口号。 以我的经验，我一生只看过一个程序，只能看到前4个COM端口，如果我没记错的话，那是Windows下的某种蓝牙终端。 <br><br><div class="spoiler">  <b class="spoiler_title">COM端口设置</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ak/ad/ep/akadepan2w3tldshsr6sys69jo4.png"><br></div></div><br><h1>  2.在板上装满固件 </h1><br><h2>  2.0下载实用程序，可用于开发板 </h2><br> 我们从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">STM</a>网站下载了<b>FLASHER-STM32</b>实用程序（在说明中称为STM32 Flash loader演示程序（UM0462）），您必须注册该程序，但这并不可怕-最终，我们将zip压缩文件与安装程序一起删除； 下一步-&gt;下一步-&gt;下一步...，所有内容均已安装。 为了方便起见，我在工作文件夹中创建此应用程序的快捷方式。 <br><br><div class="spoiler">  <b class="spoiler_title">这是实用程序（网站的屏幕快照）</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/oa/4a/xz/oa4axzxm4eljcbpzubyspqghcbe.png"><br></div></div><br> 默认情况下，实用程序<i>C</i>的路径为<i>：Program Files \ STMicroelectronics \ Software \ Flash Loader Demo \ STMFlashLoader Demo.exe</i> 。 <br><br><h2>  2.1引导细微差别 </h2><br> 板上有一个BOOT跳线。 <br><br><ul><li> 当跳线<b>闭合时</b> ，微控制器将从其存储器（即，由程序员编写的程序）中加载指令。 </li><li> 当跳线<b>打开时</b> ，微控制器将在RX和TX线上接收信息，即 它将从COM端口（在我的情况下是从适配器）刷新。 </li></ul><br><h2>  2.2配置实用程序 </h2><br><img src="https://habrastorage.org/webt/pu/oc/h3/puoch3mqjkqfryjvcnxfg9zeycq.png"><br><br> 运行此应用程序，它实际上是最简单的（包含最少的设置）。 在第一个窗口中，选择： <br><br><ol><li> 接口（我有COM-3）； </li><li> 计算机和微控制器通信的速度（IMHO，9600正常值）； </li><li> 数据位数（出于某种原因，此窗口对我不可用，但到目前为止这并不重要）； </li><li> 奇偶校验（我没有奇偶校验，即无）； </li><li> 回声（我有关闭）; </li><li> 等待时间（我有10秒）。 </li></ol><br> 单击下一步，如果一切正常，那么我们将看到绿灯，并且“目标是可读的”。 如果看到红灯，则表明计算机无法连接。 <br><br><div class="spoiler">  <b class="spoiler_title">如果成功检测到微控制器，则目标是可读的</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/gd/9y/hw/gd9yhwnpu15asiupizayeozvsfo.png"><br></div></div><br> 总是有帮助的步骤顺序： <br><br><ol><li> 首先，您需要检查板上的BOOT跳线是否已关闭。 </li><li> 其次，在任何情况下，都应关闭微控制器的电源，最好关闭从适配器到电路板的TX和RX线（您不能断开接地）。 </li><li> 第三，在程序中，按返回到末尾，即 返回首页，甚至将其关闭然后重新启动（通常来说，它有时会冻结）。 重要的是，始终先从首页开始，然后再通过此程序与主板进行每次连接。 </li><li> 第四，从适配器到电路板的导线接好，然后尝试再次在程序中连接（请确保从首页开始！）。 </li></ol><br> 如果其他所有方法均失败，则可以尝试关闭所有功能，重新启动计算机，然后尝试重新连接至主板。 <br><br> 因为 我在虚拟机上工作，我必须多次重新连接USB-COM适配器，以便虚拟机可以检测到它，并且主机没有时间安装损坏的驱动程序。 <br><br> 我在撰写本文时发现的另一种选择是按下板上的按钮，而不是不断拉动电线。 但是，无论如何都必须关闭并打开BOOT跳线。 该选项起作用的原因是该按钮位于外部<abbr title="外部代表">NRST</abbr>复位的底部。 <br><br> 在下一个窗口中，选择目标设备Target。 顺便说一句，有时在这里您通常可以看到（也许是一个错误）左侧的设备，例如，代替STM32而不是STM8-在发生某种故障的地方，上面已经描述了处理程序。 因此，在此步骤中，您不必急于单击“下一步”，但是请始终注意在Target中选择了所需设备的事实。 <br><br><div class="spoiler">  <b class="spoiler_title">目标设备选择</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/zz/p8/83/zzp88341ayrb95ymtn1bf3-elvq.png"><br></div></div><br> 如何确定我们拥有的设备？  -我们看一下芯片并重写所有写在芯片上的东西。 我们打开芯片上的<i>数据表</i> ，“ <i>订购信息</i> ”部分描述了哪个字母负责什么。 以我为例： <br><br><img src="https://habrastorage.org/webt/pa/kn/ga/pakngat6l5tahlk-y75nledccuy.png"><img src="https://habrastorage.org/webt/f0/fb/jk/f0fbjkrbe8a-g5uqbjdovxzr_fc.png"><br><br><div class="spoiler">  <b class="spoiler_title">我在Target中选择我的芯片（16K），然后继续。</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/qs/u4/v2/qsu4v2uhtvft1sj1uhp2bnount4.png"><br></div></div><br> 芯片提供4种动作选择： <br><br><ol><li> 擦除内存（整个或选择一个特定区域）； </li><li> 将固件写入设备； </li><li> 从设备读取固件； </li><li> 启用/禁用写或读保护。 </li></ol><br><h2>  2.3从板上读取固件 </h2><br> 当我第一次连接开发板时，我决定保留原始固件，这是一种备份-我们现在就做。 有必要指出该固件的保存位置以及要保存的内存页面，还建议使用<i>hex</i> ， <i>bin</i>或<i>s19</i>文件格式进行<i>选择</i> 。 <br><br><div class="spoiler">  <b class="spoiler_title">选择要读取的存储页面</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/b_/vs/yq/b_vsyqyslqo1sib02nymmymvy_m.png"><br></div></div><br> 如果您只是将固件上载到板上或从板上读取固件，则这些文件格式之间没有区别。 以下是进度页，有时该进程会长时间冻结99％（不一定是99），但应该在几秒钟后成功完成-实际上，在此之后，开发板没有给出与加载的固件相对应的行为。 简而言之，您需要重新连接所有内容并重新填充固件，对此没有什么要求。 <br><br> 固件文件已保存，以后可以上传到板上。 <br><br> 但是，如果安装了读取保护，则无法读取固件。 <br><br><div class="spoiler">  <b class="spoiler_title">进度窗口</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/nb/ta/rs/nbtarsmjtb1-ylmcxaesykldlv0.png"><br></div></div><br><h2>  2.4刷板 </h2><br> 现在填写固件文件，其源代码如下。 展望未来，我会说我们将上传<i>bin</i>和<i>hex</i>文件，因为 开发环境将发布它们。  <i>s19</i>和<i>hex</i>文件的其他设置相同。 与它们不同的是，在<i>bin</i>文件中，您可以选择将从中记录固件的地址，默认情况下在实用程序中为800万（适用于我们）。 <br><br><div class="spoiler">  <b class="spoiler_title">准备录音</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1k/u8/cf/1ku8cfxnzt_bjob1szyix3u2xpw.png"><br></div></div><br> 在录制之前，您可以通过选择以下三个选项之一来清除微控制器的闪存： <br><br><ul><li> 擦除必要的页面（清除存储器的必要部分）； </li><li> 无擦除（未经纯化）； </li><li> 全局擦除（完全清除）。 </li></ul><br> 实际上，清除是将零写入内存的过程。 <br><br> 仍然有可选的字节，但是到目前为止您无法触摸它们。 单击“下一步”，等待该过程完成，然后完成。 <br><br> 如果要记录我的固件，可以在云中找到它，即<i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">blink.bin</a></i>文件。 使用此固件时，PA4脚上的内置LED闪烁应闪烁。 <br><br><h1>  3.代码编写 </h1><br><h2>  3.0安装CooCox CoIDE开发环境 </h2><br> 您可以先从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SoftPedia.com</a>网站下载IDE，然后再从STM网站和IDE网站本身下载IDE，但是由于IDE不再提供支持，因此已成为不可能。 没有关键的不再支持IDE了，不，因为 对于编写代码，主要是编译器。 我下载了两个版本，但我使用的是1.7.8版本。 <br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>很好地描述了环境的首次启动，Next-&gt; Next-&gt; Next ...，没有什么复杂的。 我只补充说，最好先创建一个项目，然后再进行其他所有操作。 <br><br> 但是，如果丢失了“存储库”选项卡，则可以在菜单“ <i>视图”-&gt;“存储库”中</i>找到它。 <br> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>下载适用于环境的工具（编译器），也可以向Google询问“用于手臂的gnu工具”； 我下载了一个在结尾处带有sha1.exe的选项。 <br><br><h2>  3.1源框架 </h2><br> 因此，已经创建了项目，选择了芯片，现在我们将向项目添加最少的资源集，否则将无法使用它。 <br><br><div class="spoiler">  <b class="spoiler_title">这就是项目刚创建时的外观，即</b>  <b class="spoiler_title">只有主main.c文件，仅此而已</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/db/rf/qh/dbrfqhef0pg7j3perjtzm3b3okc.png"><br></div></div><br>  <b>选择CMSIS BOOT</b> ，环境将自动<b>选择M0 Cmsis Core</b> ，因为 依赖关系需要这个。 <br><br><div class="spoiler">  <b class="spoiler_title">现在我们得到最少的来源</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fk/u8/qt/fku8qtl8uhcttxq_xswbovf-10c.png"><br></div></div><br> 组装项目（“生成”图标或F7键）。 由于我不知道的原因，未收集十六进制文件（控制台中有警告）； 我几次重新安装了IDE和编译器，重新创建了项目，但是由于某种原因在虚拟机上出现了这样的结果。 在另一台计算机（不是虚拟的，而是真实的）上，所有内容都是一对一的，并且输出是十六进制的。 幸运的是，这里有垃圾桶。 <br><br><div class="spoiler">  <b class="spoiler_title">该项目已成功组装</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ap/zn/ct/apznctscxqdbgullp11rzqxtyj4.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">我建议您注意文件大小，可以在控制台的输出末尾看到它，也可以通过标准方式看到它（在这里，您可以看到十六进制为空）。</b>  <b class="spoiler_title">同时，此屏幕快照显示固件文件位于项目文件夹中，然后是Debug / bin /</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ho/ue/wd/houewdyn-cyjvmn-js5sbah-yru.png"><br></div></div><br> 尽管代码没有执行任何操作，但我将其上传到板上以确保可以上传（例如，实用程序不会拒绝它）。 我建议读者这样做。 如果不起作用，请再试一次，然后写评论。 <br><br><h2>  3.2手指算法 </h2><br> 首先，我们从人的角度勾勒出一种算法，微控制器将如何使LED闪烁。 为此，需要进行一些推理。 <br><br> 每种设备都由于存储的能量而工作，例如，某些发动机可以使用不同类型的燃料运行，但是为此，需要将发动机调整为我们将要供给的燃料类型。 同样，微控制器需要针对能源进行调整（调整）-这将是算法的<i>第一步</i> 。 <br> 我们进一步推理。 台式计算机具有监视器，扬声器，键盘，鼠标...，您可以看到某些设备向我们提供了信息，而在其他设备的帮助下，我们向计算机提供了信息，但是它们都连接到所有设备通用的盒子（系统单元）上。 您可以猜测微控制器可以接收并提供信息，这意味着其支路可以接收信号或发出信号-这将是算法的<i>下一个步骤</i> 。 <br><br> 接下来，微控制器必须打开LED，等待一会儿，关闭LED，等待一会儿，然后将其打开，然后再关闭... <br><br> 结果，该算法将如下所示 <br><br><img src="https://habrastorage.org/webt/h1/m4/oo/h1m4oou5txdafrybbwobj69vahm.png" height="361" width="192"><br><br> 该流程图的目的是清楚地显示算法的作用。 首先，该方案是为您自己编写的，因此每个人都可以随意（自己）编写/绘制该方案。 我认为，该方案应旨在尽可能简单，易读和直观，以具有较高的抽象水平。 <br><br> 按照此算法，我们将编写代码。 <br><br><h2>  3.3处理文档 </h2><br> 建议您使用打开文件<i>stm32f0xx.h</i> （位于我们项目的<i>cmsis_boot</i>文件夹中）和打开文档阅读本文的这一部分。 <br><br><h3>  3.3.1选择时钟源 </h3><br> 首先，您需要为微控制器供电。 微控制器从适配器接收5伏电压（用万用表测量），但是出现的问题是“微控制器以什么频率工作”，因为已知电子设备以不同的频率工作。 首先，打开<i>数据表</i> ，在目录中，您可以看到两个有意义的部分： <i>电源管理</i> ， <i>时钟和启动</i> 。 首先是关于电压和低功耗模式。 第二部分隐藏了我们目前感兴趣的内容。 在第一句话中已经说过“内部RC 8 MHz振荡器被选为复位时的默认CPU时钟”，这意味着<i>默认情况下，复位MC后，内部8 MHz RC链</i>被选<i>为主时钟源</i> 。 <br> 接下来是一些难以理解的时钟树方案，我们稍后再考虑。 <br><a name="Clock_tree"></a><br><br><div class="spoiler">  <b class="spoiler_title">时钟树</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/sg/nl/ul/sgnlul1krp_mdiqntf5it8a0eni.png"></div></div><br> 严格来说，您可以依靠短语“在重置MK之后默认情况下...”并斜着阅读本文的这一部分。 <br><br> 现在，您需要分散电路板的注意力，并寻找内部LED。 我知道电路中的二极管由<i>D1</i> ， <i>D2</i> ...表示，即  <i>D ==二极管</i> ，在我的电路板上靠近电阻<i>R7的</i>是二极管<i>D1</i> 。 <br><br><div class="spoiler">  <b class="spoiler_title">板照片</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ma/ze/ke/mazekeve26x9-imexuqb2k1knb8.png" width="462" height="330"><br></div></div><br> 也许，在仔细检查电路板之后，您可以找到二极管挂在哪条腿上，但我将转向电路板。 不幸的是，电路板的元件在其位置上与电路中的元件并不完全匹配。 但是我很高兴在互联网上找到了这样的方案（否则我很长时间都找不到了）。 <br><br><img src="https://habrastorage.org/webt/id/gz/tw/idgztwbtwraskhguvq-9alkrp18.png"><br><br> 在该图中，我们看到二极管的阴极通过跳线<i>J2</i>接地，而阳极通过电阻器连接到<i>PA4</i>引脚。  <i>PA4</i>表示端口<i>A</i>的第四个输出，这意味着要点亮和关闭LED，必须向<i>PA4</i>的输出端提供电压。 <br><br> 接下来，您需要确定如何向该输出施加电压。 对我而言，这根本不是直观的，并且很长一段时间以来，我一直在仔细阅读文档，直到在数据表最开始的“ <i>描述”</i>部分遇到了<b>框图</b> 。 在其中我看到了珍贵的轨道<i>PA [15：0] &lt;=&gt; GPIO端口A &lt;=&gt; AHB解码器&lt;=&gt;总线矩阵&lt;=&gt; Cortex-M0</i> ，即 端口<i>A</i>是通用I / O端口，并连接到<abbr title="先进的高性能总线"><i>AHB</i></abbr>总线。 <br><br><div class="spoiler">  <b class="spoiler_title">方块图</b> <div class="spoiler_text">  （图片可点击） <br> <a href=""><img src="https://habrastorage.org/webt/_e/hf/d0/_ehfd0kdf5v87xxud5yj4abp3xu.png"></a> <br></div></div><br> 我注意到在电子产品中，通常将微控制器的输出分成端口，通常该端口有16个输出。 该图显示端口<i>A</i> ， <i>B</i>和<i>C</i>只有16个，但是端口<i>D</i>和<i>F</i>却较少（少于16个引脚，更多-否）。 <br><br> 让我们回到“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">时钟树”</a>方案，找到<i>AHB</i>签名的输出。 我们将弄清楚该输出的工作频率。  <i>HCLK</i>信号到<i>AHB</i> ，离开<i>HPRE</i>分频器。 该分频器从开关<abbr title="系统时钟切换"><i>SW</i></abbr>接收<abbr title="系统定位"><i>SYSCLK</i></abbr>信号。 通过<i>编程设置</i> <i>SW</i>输入中的哪个信号将用作<i>SYSCLK</i> ，然后在代码中进行设置。 提供选择： <br><br><ol><li>  <i><abbr title="内部高速">HSI-</abbr></i>来自内部高频发生器的信号，它是由一个8 MHz石英谐振器产生的，在使用该板之前我已将其焊接； </li><li>  <i><abbr title="锁相环ClocK">PLLCLK-</abbr></i>来自倍频器<i>PLLMUL的</i>信号； </li><li>  <i><abbr title="外部高速">HSE-</abbr></i>来自外部高频发生器的信号。 </li></ol><br> 任何选项都适合我们的任务，我建议选择其中最简单，最实惠的<i>HSI</i> 。 <br><br> 我们将进入<i>参考手册</i>并打开第<i>7</i>节“ <i>复位和时钟控制（RCC）”</i> ，特别是<i>7.2.6系统时钟选择</i> ，在这里我们再次遇到数据表中类似的措辞：“系统复位后，选择<i>HSI</i>振荡器作为系统时钟”-即 我们甚至不需要做任何事情，MK将从<i>HSI</i>开始。 <br><br> 为了确保MK确实可以从此源工作，我将在程序中明确编写此代码。 滚动到负责复位和时钟的<i>寄存器</i> （第<i>7.4</i>节<i>RCC寄存器</i> ）。 文档中描述的第一个寄存器是<b>时钟控制寄存器（RCC_CR）</b> ； 下面是对位的描述，这些位负责什么。 <br><br><div class="spoiler">  <b class="spoiler_title">时钟控制寄存器</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/qq/i4/ll/qqi4llshdqrtgidy2_x-hxx9yhe.png"><br></div></div><br> 我们对<i>HSION</i>零位感兴趣，该位负责打开谐振器（ <i>0-</i>关闭， <i>1-</i>开启）。 <br><br> 因此，有必要向<i>RCC_CR</i>寄存器写入1。  （零位为1，或2 <sup>0</sup> = 1）。 <br><br> 现在，我们在<i>stm32f0xx.h</i>文件中找到<b>RCC</b>的定义（ <i>#define RCC</i> ）。 <br><br><div class="spoiler">  <b class="spoiler_title">RCC-&gt; RC</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/vn/ej/0x/vnej0xmqlqnrgeprbgyjo9cpjt8.png"><br></div></div><br> 如您所见，这是位于<i>RCC_BASE</i>的结构； 地址<i>0x40021000</i> ，如果您全部展开<i>define</i> ，则可以在《 <i>参考手册》</i>中的<i>2.2.2</i>节“ <i>内存映射和寄存器边界地址”</i>以及在数据表的“第<i>5章内存映射</i> （ <i>AHB</i>区域）”中看到相同的地址。 <br><br> 要在<i>RCC</i>块<i>CR</i>寄存器中写入一个启用<i>HSI</i>的单元，需要一行代码 <br><br><pre><code class="plaintext hljs">RCC-&gt;CR |= 0x1;</code> </pre> <br><h3>  3.3.2设置腿 </h3><br> 向微控制器的脚发送信号以点亮LED并停止信号，以使LED熄灭是简单的操作，因此适用于<i><abbr title="通用输入/输出">GPIO</abbr></i>功能（通用输入输出端口）。 <br><br> 默认情况下，MK支脚未连接，即 输出是不确定的。 必须连接端口，该端口的脚将为LED供电。 之前，我们确定<i>GPIO</i>端口已连接到<i>AHB</i>总线-您需要调整该总线。 继续翻阅第<i>7.4</i>节<i>RCC寄存器</i> （复位和控制控制寄存器），我们发现第<i>7.4.6</i>节<i>AHB外设时钟使能寄存器</i> （ <b>RCC_AHBENR</b>和<i>AHB</i>总线<i>时钟使能寄存器</i> ）。 早些时候，我确定我的LED已连接到<i>PA4</i>引脚-因此，我需要将一个单元写入寄存器的第17位，以便固定端口<i>A。</i> <br><br><div class="spoiler">  <b class="spoiler_title">AHB外设时钟使能寄存器</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/u7/s5/vs/u7s5vsoduvggexg9chpopozlzdw.png"><br></div></div><br> 因此，代码应为 <br><br><pre> <code class="plaintext hljs">RCC-&gt;AHBENR |= (1 &lt;&lt; 17);</code> </pre> <br> 或者，这是同一回事 <br><br><pre> <code class="plaintext hljs">RCC-&gt;AHBENR |= 0x20000;</code> </pre> <br> 使用<i>#define</i>文件<i>stm32f0xx.h</i>写入 <br><br><pre> <code class="plaintext hljs">RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">RCC-&gt; AHBENR</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/19/ex/ke/19exkey4g-yyfkz4pmvrrgilnlk.png"><br></div></div><br> 我们已经为端口<i>A</i>供电，现在我们需要通知MK <i>PA4</i>将在<i>出口</i>工作-我们将阅读第<i>8</i>节<i>通用I / O（GPIO）</i> ； 本节的引言已经说到“每个通用I / O端口都有四个32位配置寄存器（ <b>GPIOx_MODER</b> ， <b>GPIOx_OTYPER</b> ， <b>GPIOx_OSPEEDR</b>和<b>GPIOx_PUPDR</b> ），两个32位数据寄存器（ <b>GPIOx_IDR</b>和<b>GPIOx_ODR</b> ）...”- <i>每个GPIO端口中有4个调整寄存器和2个数据寄存器</i> -这就是我们所需要的（配置端口<i>A</i>或<i>PA4</i>输出，并定期向其发送<i>0</i>和<i>1</i> ）。 为了更好地理解所发生的情况（理论），您可以阅读本节，但我向下滚动至<i>8.4</i>节<i>GPIO寄存器</i>并根据说明配置端口。 <br><br><ol><li> 端口<b>模式</b> -退出。 根据文档，有必要在相应寄存器（ <i>GPIOA_MODER</i> ）的相应区域（ <i>MODER4</i> ）中写入<i>01</i> ，即 第9位和第<i>8</i>位：第9位应为零，以第8位为单位： <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;MODER |= (1 &lt;&lt; 8); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;MODER |= 0x100; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;MODER |= GPIO_MODER_MODER4_0;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">GPIO端口模式寄存器</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/tv/xf/vt/tvxfvtoiw91rguuz-rtmgcrk8fo.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">GPIOA-&gt;模块</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/co/df/x5/codfx50xu4hopklififyeecpiqu.png"><br></div></div><br></li><li> 输出<b>类型</b> 。 老实说，我仍然没有完全弄清楚这种情况的电路（我会理解，再次阅读论坛等），但是研究有关MK输出配置的其他资源以及逻辑和直觉，建议应该<b>有所作为-pull</b> ，之后应上<i>拉</i> 。 无论如何，代码都已编写，一切正常，没有任何内容耗尽。 如果选择<b>漏极开路</b>类型并将此输出与另一个设备短路，则存在烧伤的真正风险，例如 这是一个开放的出口，不受任何保护。 另外，我们在二极管的前面有一个限流电阻-它肯定不会在这里燃烧。 <br><br> 根据文档，有必要在第四位写零； 该文档还指出，重置后将为零。 <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;OTYPER &amp;= ~(1 &lt;&lt; 4); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OTYPER &amp;= ~0x10; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OTYPER &amp;= ~GPIO_OTYPER_OT_4;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">GPIO端口输出类型寄存器</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ii/3k/ch/ii3kcht4jvsbnd7yybouiilgmhk.png"><br></div></div><br></li><li> 输出<b>速度</b> 。 在我们的情况下，这并不重要，但是为了保真，我将在此处写入零。 <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;OSPEEDR &amp;= ~(1 &lt;&lt; 8); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OSPEEDR &amp;= ~0x100; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OSPEEDR &amp;= ~GPIO_OSPEEDER_OSPEEDR4_0;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">GPIO端口输出速度寄存器</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/47/xg/fr/47xgfrtfqdl5ai0eztsrqej1i1k.png"><br></div></div><br></li><li>  <b>电梯</b> 。 因为 输出将为LED供电，您需要将其上拉至电源，即  <b>上拉</b> <br><br> 必须拧紧端口<i>A</i>的第4针; 该文档说，为此，有必要分别在<i>9</i>和<i>8</i>位中写入0和1。 <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;PUPDR |= (1 &lt;&lt; 8); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;PUPDR |= 0x100; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;PUPDR |= GPIO_PUPDR_PUPDR4_0;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">GPIO端口上拉/下拉寄存器</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/pg/pa/zk/pgpazkwfltwme4jy0wwrhp9imqi.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">GPIOA-&gt; PUPDR</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bo/ee/na/boeenaff6fxjiemjuiky9ukhb6w.png"><br></div></div><br></li></ol><br><h3>  3.3.3 LED开/关和延迟 </h3><br> 前面我们读到每个端口都有寄存器，包括<i><abbr title="输入数据寄存器">IDR</abbr></i>和<i><abbr title="输出数据寄存器">ODR</abbr></i>数据寄存器-分别是输入和输出数据寄存器。  MK分支上的逻辑零和一-这是数据吗？  -是的，数据。 数据可以来自微控制器外部（作为<i>输入</i> ），然后退出微控制器并进入另一个设备（作为<i>输出</i> ）。  MK支路上的单元是存在高电压电平，即 如果将一个带到输出，则将有电压，并且此LED可以为我们的LED供电。 单元向微控制器支路的输出不同于将单元写入<i>ODR</i>输出寄存器。 <br><br><div class="spoiler">  <b class="spoiler_title">GPIO端口输出数据寄存器</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/or/vw/el/orvwel6seyhwvx6pbxdcow6ufpm.png"><br></div></div><br> 根据文档，我们看到每个端口（ <i>A</i> ， <i>B</i> ， <i>C</i> ， <i>D</i> ， <i>F</i> ）都有一个32位寄存器。 端口的引脚数不能超过16个，则仅使用寄存器的前16位。 每一位对应一个端口号（引脚）。 要将一个单元输出到<i>PA4</i>支路，需要将一个单元写入第4位，以输出零-将一个零写入第4位，即 从输出端去除电压。 <br><br><img src="https://habrastorage.org/webt/pr/0n/pr/pr0npr4jplwjahmcflj_nlksq5i.png" width="400" height="156"><br><br><div class="spoiler">  <b class="spoiler_title">GPIOA-&gt; ODR</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/hs/yy/v4/hsyyv4z5u2kf6fkqqe5wk9t6ti4.png"><br></div></div><br> 开启LED的代码如下所示 <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR |= (1 &lt;&lt; 4); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR |= 0x10; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR |= GPIO_ODR_4;</code> </pre> <br> 代码关闭LED <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR &amp;= ~(1 &lt;&lt; 4); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR &amp;= ~0x10; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR &amp;= ~GPIO_ODR_4;</code> </pre> <br> 但是，如果您在打开电源线之后写了关闭LED的线，则LED不会闪烁（如果您对发生的事情感兴趣-您可以尝试;什么都不会燃烧，这已经在上面进行了讨论）-那么您需要进行延迟。 计时器用于延迟，但是计时器值得一提（由于复杂性），因此我们将延迟使用拐杖：我们将驱动空闲周期。 有一点： <b>如果启用</b>了<b>编译</b> <b>器优化</b> ，则<b>编译器将减少</b>我们的空闲周期，并且不会有延迟。 确保未启用优化。 为此，让我们进入项目配置（右键单击项目树中的项目名称），然后检查“ <i>编译</i> ”选项卡中的“ <i>编译控制字符串”</i>行：它必须具有<i>-O0</i>参数（“约零”表示禁用优化）。 如果您按照我的指示收集了所有内容，那么很可能还会有<i>-O0</i> ，因为 默认情况下，我在这里什么都没碰。 参数<i>-O1 -O2 -O3</i>表示启用相应级别的优化。 <br><br><div class="spoiler">  <b class="spoiler_title">编译器优化检查</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/vc/ps/pu/vcpspuz5xfupw1pa5n-e5at9_nm.png"><br></div></div><br> 空闲周期可以这样写： <br><br><pre> <code class="plaintext hljs">int t = 4000000; while(t &gt; 0) t--;</code> </pre><br> 我没有这样设置<i>t</i>的值，我这样推断：如果微控制器以8MHz运行，那么它将在一秒钟内执行大约8,000,000条指令，如果您夸大其词，那么半秒的延迟将需要运行4,000,000次。 <br> 空闲周期将需要在打开LED之后，关闭LED之后运行，并且所有这些共同循环。 <br><br><h3>  3.4编写代码并运行 </h3><br> 让我们将之前编写的所有代码行放在一起。 您还需要包括<i>stm32f0xx.h</i>头文件，如下所示 我们依靠它并从中获取结构，地址和值的定义。 结果应为： <br><br><pre> <code class="plaintext hljs">#include "stm32f0xx.h" int main(void) { int t; //  '' RCC-&gt;CR |= 0x1; //   HSI RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; //   A GPIOA-&gt;MODER |= GPIO_MODER_MODER4_0; // PA4   GPIOA-&gt;OTYPER &amp;= ~GPIO_OTYPER_OT_4; //  push-pull  PA4 GPIOA-&gt;OSPEEDR &amp;= ~GPIO_OSPEEDER_OSPEEDR4_0; //    PA4 GPIOA-&gt;PUPDR |= GPIO_PUPDR_PUPDR4_0; //  pull-up  PA4 while(1) { GPIOA-&gt;ODR |= GPIO_ODR_4; //    PA4 t = 4000000; while(t &gt; 0) t--; //  GPIOA-&gt;ODR &amp;= ~GPIO_ODR_4; //    PA4 t = 4000000; while(t &gt; 0) t--; //  } }</code> </pre><br> 单击重建，然后通过实用程序在板上填写代码。 <br><br><img src="https://habrastorage.org/webt/fo/rr/1d/forr1d6ruw6sohn7eyomgs4yb_g.png"><br><br> 为了使开发板能够启动新固件，请不要忘记关闭BOOT跳线并进行复位（RESET）。 <br><br><h1>  4.结论 </h1><br> 代码已编写，一切正常。 部队消耗得无法估量。 我很高兴基于文档，事实证明编写了工作代码，主要是因为STM拥有高质量的文档。 <br><br> 计划是写一篇关于如何在没有IDE的情况下通过控制台<i>真正</i>手工组装所有东西的文章，理想情况下，这一切都可以在Linux下完成。 现在，我正在研究PWM和ADC（也在该板上）-我也会在它们上写一篇文章。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN437234/">https://habr.com/ru/post/zh-CN437234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN437224/index.html">将Dust模板转换为JSX</a></li>
<li><a href="../zh-CN437226/index.html">开尔文点影</a></li>
<li><a href="../zh-CN437228/index.html">比特币作为一种货币，将导致经济危机</a></li>
<li><a href="../zh-CN437230/index.html">如此不同的在线广告。 三轴vs. 人工智能，广告技术和户外</a></li>
<li><a href="../zh-CN437232/index.html">Psto好</a></li>
<li><a href="../zh-CN437236/index.html">ESET：新的Zebrocy组件分析</a></li>
<li><a href="../zh-CN437238/index.html">Orange Pi 3发布-Linux上完整的30美元迷你电脑</a></li>
<li><a href="../zh-CN437240/index.html">如何将Zimbra Collaboration Suite与Active Directory集成</a></li>
<li><a href="../zh-CN437242/index.html">产品经理的精通。 功能要求</a></li>
<li><a href="../zh-CN437244/index.html">Google教用户识别网络钓鱼电子邮件</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>