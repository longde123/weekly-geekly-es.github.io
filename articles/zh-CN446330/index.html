<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔦 😲 ⛺️ 自动机器反对意大利面条代码 😊 🤦🏼 ➖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="“我喜欢意大利面条的西部菜，我讨厌意大利面条的代码” 

 “意大利面条式代码”是描述软件的理想表达，从认知和美学的角度来看，这都是一团混乱的蒸汽。 在本文中，我将讨论销毁意大利面条代码的三点计划： 



- 我们讨论为什么意大利面条代码不那么美味。 
- 介绍一下代码实际执行的功能。 
- 我们...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>自动机器反对意大利面条代码</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446330/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/049/15b/078/04915b0789f8de5be2bc6950b3265a8a.png"></div><br>  <i>“我喜欢意大利面条的西部菜，我讨厌意大利面条的代码”</i> <br><br>  “意大利面条式代码”是描述软件的理想表达，从认知和美学的角度来看，这都是一团混乱的蒸汽。 在本文中，我将讨论销毁意大利面条代码的三点计划： <br><br><ul><li> 我们讨论为什么意大利面条代码不那么美味。 </li><li> 介绍一下代码实际执行的功能。 </li><li> 我们正在讨论<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow noopener">帧机器符号（FMN）</a> ，它可以帮助开发人员解开一团糊状。 </li></ul><br> 我们都知道阅读别人的代码有多困难。 这可能是由于任务本身很困难，或者由于代码的结构过于“创造性”。 通常这两个问题并存。 <br><br> 挑战是艰巨的任务，通常只有革命性的发现才能简化挑战。 但是，碰巧软件结构本身增加了不必要的复杂性，这个问题<em>值得</em>解决。 <br><br> 意粉代码的丑陋在于其复杂的条件逻辑。 而且，如果没有许多棘手的if-then-else构造，虽然生活很难想象，但本文将为您提供更好的解决方案。 <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6cc/af0/c3c/6ccaf0c3c57a472e1eb5b80a238a86c5.png"></div><br> 为了说明意大利细面条的代码情况，我们需要先将其打开： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf9/eac/43c/cf9eac43c588d9fecbbfc9bf15753ee1.jpg"></div><br>  <i>脆皮意大利面</i> <br><br> 在此： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fc/683/f12/7fc683f12aa20bcf4abcf5a774c7a039.jpg"></div><br>  <i>Al dente！</i> <br><br> 让我们开始做饭。 <br><br><h3> 内隐状态 </h3><br> 要制作面食，我们肯定需要水做饭。 但是，即使是涉及意大利面条代码的看似简单的元素也可能造成混乱。 <br><br> 这是一个简单的示例： <br><br><pre><code class="cpp hljs">(temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>)</code> </pre> <br> 此检查实际上是做什么的？ 显然，它将数字线分为两部分，但是这些部分<em>是</em>什么<em>意思</em>呢？ 我认为您可以做出合理的假设，但问题是代码实际上并未<em>明确</em>传达这<em>一点</em> 。 <br><br> 如果我真的确认她检查水是否为固体<i>[大约。</i>  <i>车道：根据华氏度表，水冻结在+32度处]</i> ，从逻辑上讲，返回假是什么意思？ <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SOLID water } else { // not SOLID water. is (LIQUID | GAS) }</span></span></code> </pre> <br> 尽管检查将数字分为两组，但实际上存在三种逻辑状态-固体，液体和气体（固体，液体和气体）！ <br><br> 也就是说，此数字行： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fad/b04/343/fadb04343c512bbf297dbf17a250d742.png"></div><br> 按条件拆分如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/e83/2cc/56ae832ccebc547053d46dec39993ec3.png"></div><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a55/dcf/20d/a55dcf20d2de1f679a233913c045546f.png"></div><br><pre> <code class="cpp hljs">}</code> </pre> <br> 注意发生了什么，因为这对于理解意大利面条代码的性质非常重要。 布尔检查将数字空间分为两部分，但并未将系统归类为（SOLID，LIQUID，GAS）的真实逻辑结构。 取而代之的是，检查将空间分为（SOLID，其他所有内容）。 <br><br> 这是类似的检查： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &gt; <span class="hljs-number"><span class="hljs-number">212</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// GAS water } else { // not GAS water. is (SOLID | LIQUID) }</span></span></code> </pre> <br> 从视觉上看，它将如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &gt; <span class="hljs-number"><span class="hljs-number">212</span></span>) {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/127/810/51d127810231b42191868d0972e3865f.png"></div><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42a/187/bd4/42a187bd4559e2dfa9e6acffcd24c8b2.png"></div><br><pre> <code class="cpp hljs">}</code> </pre> <br> 注意： <br><br><ol><li> 完整的可能状态集未在任何地方宣布 </li><li> 条件构造中无处声明可验证的逻辑状态或状态组 </li><li> 一些状态通过条件逻辑和分支的结构间接分组 </li></ol><br> 这样的代码是易碎的，但是很常见，并且不大到导致其支持问题。 因此，让情况变得更糟。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/852/bd5/7a1/852bd57a151d005a34ddd883aea5d1ab.png"></div><br>  <i>反正我从来都不喜欢你的代码</i> <br><br> 上面显示的代码暗含物质的三种状态-固体，液体，气体。 但是，根据科学数据，实际上存在<strong><em>四个</em></strong>可观察到的状态，其中包含了等离子体（PLASMA）（实际上，还有许多其他状态，但这对我们来说已经足够了）。 尽管没有人准备用等离子体制备糊剂，但是如果此代码在Github上发布，然后由研究高能物理的一些研究生分叉，那么我们也必须保持这种状态。 <br><br> 但是，添加等离子后，上面显示的代码将天真地执行以下操作： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SOLID water } else { // not SOLID water. is (LIQUID | GAS) + (PLASMA?) // how did PLASMA get in here?? } if (temp &gt; 212) { // GAS water + (PLASMA) // again with the PLASMA!! } else { // not GAS water. is (SOLID | LIQUID) }</span></span></code> </pre> <br> 当旧代码添加到许多等离子体状态时，很可能会在else分支中中断。 不幸的是，代码结构中没有任何内容可以帮助报告新状态的存在或影响更改。 此外，任何错误都可能不那么明显，也就是说，找到它们将是最困难的。 对意大利面条中的昆虫说不。 <br><br> 简而言之，问题是这样的：布尔检查用于<em>间接</em>确定状态。 逻辑状态通常没有声明，并且在代码中不可见。 如上所述，当系统添加新的逻辑状态时，现有代码可能会中断。 为避免这种情况， <strong>开发人员应重新检查每个条件检查并分支，</strong>以确保代码路径对其<em>所有</em>逻辑状态仍然有效！ 这是大代码片段变得越来越复杂时降级的主要原因。 <br><br> 尽管没有方法可以完全摆脱条件数据检查，但是将其最小化的任何技术都会降低代码的复杂性。 <br><br> 现在，让我们看一下一个类的典型的面向对象的实现，该类创建一个<em>非常</em>简单的水量模型。 该课程将管理水的状态变化。 在研究了该问题的经典解决方案的问题之后，我们将讨论一个称为<strong>Frame</strong>的新符号，并说明它如何应对我们发现的困难。 <br><br><h3> 首先把水烧开... </h3><br> 科学为物质在温度变化时可能发生的所有可能的转变命名。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/638/016/dc5/638016dc5b2a19ecd2b677cc40e2ee26.png"></div><br> 我们的课程非常简单（并非特别有用）。 它回答了在状态之间进行转换并改变温度直到变得适合于所需目标状态的挑战： <br><br>  （注意：我编写了此伪代码。仅在自担风险的情况下在您的工作中使用它。） <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaterSample</span></span></span><span class="hljs-class"> {</span></span> temp:<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Water</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(temp:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.temp = temp } <span class="hljs-comment"><span class="hljs-comment">// gas -&gt; solid func depose() { // If not in GAS state, throw an error if (temp &lt; WATER_GAS_TEMP) throw new IllegalStateError() // do depose while (temp &gt; WATER_SOLID_TEMP) decreaseTemp(1) } // gas -&gt; liquid func condense() { // If not in GAS state, throw an error if (temp &lt; WATER_GAS_TEMP) throw new IllegalStateError() // do condense while (temp &gt; WATER_GAS_TEMP) decreaseTemp(1) } // liquid -&gt; gas func vaporize() { // If not in LIQUID state, throw an error if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError() // do vaporize while (temp &lt; WATER_GAS_TEMP) increaseTemp(1) } // liquid -&gt; solid func freeze() { // If not in LIQUID state, throw an error if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError() // do freeze while (temp &gt; WATER_SOLID_TEMP) decreaseTemp(1) } // solid -&gt; liquid func melt() { // If not in SOLID state, throw an error if (temp &gt; WATER_SOLID_TEMP) throw new IllegalStateError() // do melt while (temp &lt; WATER_SOLID_TEMP) increaseTemp(1) } // solid -&gt; gas func sublimate() { // If not in SOLID state, throw an error if (temp &gt; WATER_SOLID_TEMP) throw new IllegalStateError() // do sublimate while (temp &lt; WATER_GAS_TEMP) increaseTemp(1) } func getState():string { if (temp &lt; WATER_SOLID_TEMP) return "SOLID" if (temp &gt; WATER_GAS_TEMP) return "GAS" return "LIQUID" } }</span></span></code> </pre> <br> 与第一个示例相比，此代码具有某些改进。 首先，将硬编码的“魔术”数字（32、212）替换为状态温度边界的常量（WATER_SOLID_TEMP，WATER_GAS_TEMP）。 这种变化开始使状态更加明确，尽管是间接的。 <br><br> 此代码中还会出现“防御性编程”检查，如果该方法处于不合适的操作状态，则会限制该方法的调用。 例如，如果水不是液体，它就不会冻结-这违反了自然法。 但是添加看门狗条件会使对代码目的的理解变得复杂。 例如： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// liquid -&gt; solid if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError()</span></span></code> </pre> <br> 此条件检查执行以下操作： <br><br><ol><li> 检查<code>temp</code>低于GAS极限温度 </li><li> 检查<code>temp</code>超过SOLID极限温度 </li><li> 如果这些检查之一不正确，则返回错误 </li></ol><br> 这种逻辑令人困惑。 首先，液态是由什么物质决定的-固体或气体。 <br><br><pre> <code class="cpp hljs">(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-comment"><span class="hljs-comment">// is liquid?</span></span></code> </pre> <br> 其次，代码检查水是否为液态，以查明是否需要返回错误。 <br><br><pre> <code class="cpp hljs">!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-comment"><span class="hljs-comment">// Seriously?</span></span></code> </pre> <br> 第一次了解状态的双重否定并不容易。 这是一个简化，可以稍微降低表达式的复杂度： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isLiquidWater = (temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLiquidWater) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateError()</code> </pre> <br> 此代码更易于理解，因为<strong>isLiquidWater</strong>状态是<em>显式的</em> 。 <br><br> 现在，我们正在探索将<strong>显式状态</strong>作为解决问题的最佳方法的技术。 通过这种方法，系统的逻辑状态成为软件的物理结构，从而改善了代码并简化了对代码的理解。 <br><br><h3> 相框机符号 </h3><br>  <strong>帧机器符号（FMN）</strong>是一种领域特定语言（DSL），它定义了一种分类，方法论和简单的方法来定义和实现各种类型的<em>机器</em> 。 为简单起见，我将框架自动机简称为“机器”，因为这种表示法可以定义任何不同类型（状态机，商店自动机和自动机的最高级发展—图灵机）的理论标准。 要了解不同类型的机器及其应用，我建议研究<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow noopener">Wikipedia</a>上的页面。 <br><br> 尽管自动机理论可能很有趣（一个非常可疑的说法），但在本文中，我们将重点关注这些强大概念在构建系统和编写代码方面的实际应用。 <br><br> 为了解决此问题，Frame引入了一种在三个集成级别上起作用的标准化表示法： <br><br><ol><li> 用于通过优雅简洁的语法定义帧控制器的文本DSL </li><li> 一组参考编码模式，用于以Frame称为“控制器”的机器形式实现面向对象的类 </li><li> 视觉表示法，其中FMN用于表示难以用图形表示的复杂操作- <strong>帧直观表示法（FVN）</strong> </li></ol><br> 在本文中，我将考虑前两点：FMN和参考模式，在以后的文章中，我将不再讨论FVN。 <br><br> 框架是一种具有以下几个重要方面的符号： <br><br><ol><li>  FMN具有与自动机概念相关的第一类对象，而这些对象在面向对象的语言中不可用。 </li><li>  FMN规范在伪代码中定义了标准实现模式，这些模式演示了如何实现FMN表示法。 </li><li>  FMN很快将能够以任何面向对象的语言进行编译（正在进行中） </li></ol><br> 注意：参考实现用于演示FMN表示法的绝对等价以及以任何面向对象的语言实现它的简单方法。 您可以选择任何方法。 <br><br> 现在，我将向您介绍Frame- <strong>Frame Events</strong>和<strong>Frame Controllers中</strong>两个最重要的第一级对象。 <br><br><h3> 框架事件 </h3><br>  FrameEvents是FMN表示法简单性的组成部分。  FrameEvent被实现为至少具有以下成员变量的结构或类： <br><br><ul><li> 讯息编号 </li><li> 字典或参数列表 </li><li> 返回对象 </li></ul><br> 这是FrameEvent类的伪代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FrameEvent</span></span></span><span class="hljs-class"> {</span></span> var _msg:String var _params:Object var _return:<span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FrameEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg:String, params:Object = null)</span></span></span><span class="hljs-function"> </span></span>{ _msg = msg _params = params } }</code> </pre> <br> 框架符号使用<strong>@</strong>符号，它标识FrameEvent对象。 每个必需的FrameEvent属性都有一个特殊的令牌可以访问它： <br><br><pre> <code class="cpp hljs">@|message| :  -    _msg @[param1] :  []      @^ :              _return</code> </pre> <br> 通常，我们不必指定FrameEvent可以使用的功能。 由于大多数上下文一次只能使用一个FrameEvent，因此可以简化表示法，使其仅使用属性选择器。 因此，我们可以简化访问： <br><br><pre> <code class="cpp hljs">|buttonClick| <span class="hljs-comment"><span class="hljs-comment">// Select for a "buttonClick" event _msg [firstName] = "Mark" // Set firstName _params property to "Mark" ^ = "YES" // Set the _return object to "YES"</span></span></code> </pre> <br> 这种表示法一开始可能看起来很奇怪，但是很快我们将看到事件的这种简单语法如何极大地简化了对FMN代码的理解。 <br><br><h3> 框架控制器 </h3><br> 框架控制器是一个面向对象的类，以定义良好的方式排序以实现框架机器。 控制器类型由<strong>＃</strong>前缀标识： <br><br><pre> <code class="cpp hljs">#MyController</code> </pre> <br> 这等效于以下面向对象的伪代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span>}</code> </pre> <br> 显然，该类不是特别有用。 为了使他可以做某事，控制器至少需要一种状态来响应事件。 <br><br> 控制器的结构使其包含各种类型的块，这些块由围绕块类型名称的短划线标识： <br><br><pre> <code class="cpp hljs">#MyController&lt;br&gt; -block <span class="hljs-number"><span class="hljs-number">1</span></span>- -block <span class="hljs-number"><span class="hljs-number">2</span></span>- -block <span class="hljs-number"><span class="hljs-number">3</span></span>-</code> </pre> <br> 一个控制器每个块最多只能有一个实例，并且块类型只能包含某些类型的子组件。 在本文中，我们仅检查<strong>-machine-</strong>块，该块只能包含状态。 状态由<strong>$</strong>前缀标记标识。 <br><br> 在这里，我们看到包含仅具有一种状态的机器的控制器的FMN： <br><br><pre> <code class="cpp hljs">#MyController <span class="hljs-comment"><span class="hljs-comment">// controller declaration -machine- // machine block $S1 // state declaration</span></span></code> </pre> <br> 这是上面的FMN代码的实现： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// -machine- var _state(e:FrameEvent) = S1 // initialize state variable // to $S1 func S1(e:FrameEvent) { // state $S1 does nothing } }</span></span></code> </pre> <br> 机器块的实现包括以下元素： <br><br><ol><li>  <strong>_state</strong>变量，指的是当前状态的函数。 通过控制器中的第一个状态功能对其进行初始化。 </li><li> 一种或多种状态方法 </li></ol><br> 框架状态方法定义为具有以下签名的函数： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e:FrameEvent)</span></span></span></span>;</code> </pre> <br> 在定义了机器模块实现的这些基础之后，我们可以看到FrameEvent对象与机器的交互程度。 <br><br><h3> 接口单元 </h3><br> 框架事件的交互控制机器的运行是框架表示法的简单性和强大功能的本质。 但是，我们尚未回答这个问题，FrameEvents来自哪里-它们如何进入控制器进行控制？ 一种选择：外部客户端本身可以创建和初始化FrameEvent，然后直接调用_state成员变量指向的方法： <br><br><pre> <code class="cpp hljs">myController._state(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>))</code> </pre> <br> 更好的选择是创建一个通用接口，该接口包装对_state成员变量的直接调用： <br><br><pre> <code class="cpp hljs">myController.sendEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>))</code> </pre> <br> 但是，与创建面向对象软件的通常方法相对应的最简便的方法是，创建代表客户端将事件发送到内部计算机的通用方法： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ FrameEvent e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>) _state(e) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e._return } }</code> </pre> <br>  Frame定义了<strong>接口块</strong>的语法， <strong>该接口块</strong>包含将调用转换为FrameEvents的公共接口的方法。 <br><br><pre> <code class="cpp hljs">#MyController -interface- buttonClick ...</code> </pre> <br>  <code>interface</code>模块还具有许多其他功能，但是本示例向我们提供了有关其工作原理的总体思路。 我将在本系列的以下文章中进一步说明。 <br><br> 现在，让我们继续研究Frame自动机的操作。 <br><br><h3> 事件处理程序 </h3><br> 尽管我们已经展示了如何定义汽车，但是我们还没有一个<em>可以做</em>任何事情的记号。 要处理事件，我们需要1）能够选择需要处理的事件，以及2）将其附加到正在执行的行为上。 <br><br> 这是一个简单的框架控制器，提供了处理事件的基础结构： <br><br><pre> <code class="cpp hljs">#MyController <span class="hljs-comment"><span class="hljs-comment">// controller declaration -machine- // machine block $S1 // state declaration |e1| ^ // e1 event handler and return</span></span></code> </pre> <br> 如上所述，要访问<code>_msg</code>事件的<code>_msg</code>属性，FMN表示法使用垂直线中的括号： <br><br><pre> <code class="cpp hljs">|messageName|</code> </pre> <br>  FMN还使用表示返回语句的指数令牌。 上面显示的控制器将实现如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #MyController // -machine- var _state(e:FrameEvent) = S1 func S1(e:FrameEvent) { // $S1 if (e._msg == "e1") { // |e1| return // ^ } } }</span></span></code> </pre> <br> 在这里，我们看到FMN标记与一种易于理解和编码的实现模式对应的清晰程度。 <br><br> 在设置了事件，控制器，机器，状态和事件处理程序的这些基本方面之后，我们可以在它们的帮助下着手解决实际问题。 <br><br><h3> 单焦点机 </h3><br> 在上面，我们看了一个非常无用的无状态控制器。 <br><br><pre> <code class="cpp hljs">#MyController</code> </pre> <br> 在公用事业的食物链中，迈向更高一步的是具有单一状态的一类，尽管这不是没有用的，但它简直无聊。 但至少他至少在<em>做某事</em> 。 <br><br> 首先，让我们看看如何实现只有一个（隐含）状态的类： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mono</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OFF"</span></span> } }</code> </pre> <br> 这里没有声明甚至没有隐含任何状态，但是我们假设如果代码执行了某些操作，则系统处于“工作”状态。 <br><br> 我们还将介绍一个重要的想法：接口调用将被视为类似于将事件发送给对象。 因此，以上代码可被视为传输|状态|的方法。  Mono类，始终处于$ Working状态。 <br><br> 可以使用事件绑定表将这种情况可视化： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/81e/7e0/e1b81e7e0916b8354c4092abcc79ab40.png"></div><br> 现在让我们看一下FMN，它展示了相同的功能并匹配了相同的绑定表： <br><br><pre> <code class="cpp hljs">#Mono -machine- $Working |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>)</code> </pre> <br> 这是实现的样子： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mono</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Mono // -machine- var _state(e:FrameEvent) = Working // initialize start state func Working(e:FrameEvent) { // $Working if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } }</span></span></code> </pre> <br> 您可能会注意到，我们还为<strong>return语句</strong>引入了新的表示法，这意味着对表达式进行求值并将结果返回给接口： <br><br><pre> <code class="cpp hljs">^(return_expr)</code> </pre> <br> 该运算符等效 <br><br><pre> <code class="cpp hljs">@^ = return_expr</code> </pre> <br> 或者只是 <br><br><pre> <code class="cpp hljs">^ = return_expr</code> </pre> <br> 所有这些运算符在功能上都是等效的，您可以使用它们中的任何一个，但是<code>^(return_expr)</code>看起来最具表现力。 <br><br><h3> 打开炉子 </h3><br> 到目前为止，我们已经看到状态为0的控制器和状态为1的控制器。 它们还不是很有用，但是我们已经处于有趣的边缘。 <br><br> 要煮意大利面，首先需要打开火炉。 以下是带有单个布尔变量的简单Switch类： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch</span></span></span><span class="hljs-class"> {</span></span> boolean _isOn; <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_isOn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"ON"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OFF"</span></span>; } } }</code> </pre> <br> 尽管乍看之下并不明显，但是上面显示的代码实现了下表的事件绑定： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ef/5f8/ad7/2ef5f8ad7634c21066e847faf89c8228.png"></div><br> 为了进行比较，以下是针对相同行为的FMN： <br><br><pre> <code class="cpp hljs">#Switch1 -machine- $Off |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br> 现在，我们了解框架符号与代码目的的精确匹配-根据控制器所在的状态将事件（方法调用）附加到行为。 另外，实现结构还对应于绑定表： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch1 // -machine- var _state(e:FrameEvent) = Off func Off(e:FrameEvent) { // $Off if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } func On(e:FrameEvent) { // $On if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br> 该表使您可以快速了解控制器在各种状态下的用途。 帧标记结构和实现模式都具有相似的优点。 <br><br> 但是，我们的交换机存在明显的功能问题。 它被初始化为状态$ Off，但是不能切换到状态$ On！ 为此，我们需要输入<strong>状态更改</strong>运算符。 <br><br><h3> 变更状态 </h3><br>  <strong>状态更改语句</strong>如下： <br><br><pre> <code class="cpp hljs">-&gt;&gt; $NewState</code> </pre> <br> 现在我们可以使用此运算符在$ Off和$ On之间切换： <br><br><pre> <code class="cpp hljs">#Switch2 -machine- $Off |toggle| -&gt;&gt; $On ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |toggle| -&gt;&gt; $Off ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br> 这是对应的事件绑定表： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b02/08f/688/b0208f68897eb1412f386392e8779247.png"></div><br> 新事件|切换| 现在会触发一个更改，只需在两个状态之间循环即可。 如何执行状态更改操作？ <br><br> 没有地方比这容易。 这是Switch2的实现： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch2 // -machine- var _state(e:FrameEvent) = Off func Off(e:FrameEvent) { if (e._msg == "toggle") { // |toggle| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } func On(e:FrameEvent) { if (e._msg == "toggle") { // |toggle| _state = Off // -&gt;&gt; $Off return // ^("OFF") } if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br> 您还可以在Switch2中进行最后的改进，以便它不仅允许您在状态之间进行切换，而且可以显式设置状态： <br><br><pre> <code class="cpp hljs">#Switch3 -machine- $Off |turnOn| -&gt;&gt; $On ^ |toggle| -&gt;&gt; $On ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |turnOff| -&gt;&gt; $Off ^ |toggle| -&gt;&gt; $Off ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br> 与| toggle |事件不同，如果| turnOn | 当Switch3处于打开状态或| TurnOff |处于关闭状态时发送消息，该消息将被忽略并且没有任何反应。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这种小的改进使客户端能够明确指示开关应处于的状态： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch3 // -machine- var _state(e:FrameEvent) = Off /********************************** $Off |turnOn| -&gt;&gt; $On ^ |toggle| -&gt;&gt; $On ^ |status| ^("OFF") ***********************************/ func Off(e:FrameEvent) { if (e._msg == "turnOn") { // |turnOn| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "toggle") { // |toggle| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } /********************************** $On |turnOff| -&gt;&gt; $Off ^ |toggle| -&gt;&gt; $Off ^ |status| ^("ON") ***********************************/ func On(e:FrameEvent) { if (e._msg == "turnOff") { // |turnOff| _state = Off // -&gt;&gt; $Off return // ^ } if (e._msg == "toggle") { // |toggle| _state = Off // -&gt;&gt; $Off return // ^ } if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们交换机发展的最后一步表明，了解FMN控制器的用途是多么容易。</font><font style="vertical-align: inherit;">相关代码演示了使用框架机制实现起来很容易。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建了Switch机器之后，我们可以打开火炉并开始烹饪！</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 声音状态 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自动机的一个关键（尽管微妙）方面是机器的当前状态是某种情况（例如，开机）或某种数据或环境分析的结果。</font><font style="vertical-align: inherit;">当机器已切换到所需状态时，即表示已隐含。</font><font style="vertical-align: inherit;">没有汽车的知识，情况就不会改变。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，这种假设并不总是正确的。</font><font style="vertical-align: inherit;">在某些情况下，需要对数据进行验证（或“感应”）以确定当前的逻辑状态：</font></font><br><br><ol><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始还原状态</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -当计算机从恒定状态还原时</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外部状态</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -定义在创建，恢复或操作机器时环境中存在的“实际情况”</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不稳定的内部状态</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -由运行中的机器管理的内部数据的一部分可以在机器的控制范围之外更改时</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在所有这些情况下，都必须对“数据”，“环境”或“两者”进行“探测”，以便确定情况并相应地设置计算机的状态。</font><font style="vertical-align: inherit;">理想情况下，可以在定义正确逻辑状态的单个函数中实现此布尔逻辑。</font><font style="vertical-align: inherit;">为了支持此模式，帧符号具有一种特殊类型的功能，该功能可探测Universe并确定当前时间的情况。</font><font style="vertical-align: inherit;">此类函数由</font><font style="vertical-align: inherit;">返回</font><strong><font style="vertical-align: inherit;">状态</font></strong><font style="vertical-align: inherit;">的</font><strong><font style="vertical-align: inherit;">链接</font></strong><font style="vertical-align: inherit;">的方法名称前</font><font style="vertical-align: inherit;">的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前缀表示</font><font style="vertical-align: inherit;">：</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs">$probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在我们的情况下，可以按以下方式实现这种方法： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probeForState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:FrameState </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Solid <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">212</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Liquid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Gas }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如我们所见，该方法仅返回对与正确逻辑状态相对应的状态函数的引用。</font><font style="vertical-align: inherit;">然后可以使用此感应功能进入正确的状态：</font></font><br><br><pre> <code class="cpp hljs">-&gt;&gt; $probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 实现机制如下所示： </font></font><br><br><pre> <code class="cpp hljs">_state = probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态感测方法是用于以给定方式管理状态的帧符号的示例。</font><font style="vertical-align: inherit;">接下来，我们还将学习管理FrameEvent的重要符号。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 行为继承和调度程序 </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行为继承和调度程序</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一种强大的编程范例，也是本文中有关框架表示法的最后一个主题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">框架使用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行为的</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">继承</font><font style="vertical-align: inherit;">，而不是数据或其他属性的继承。</font><font style="vertical-align: inherit;">对于此状态，如果初始状态不处理事件（或者，如我们将在下一篇文章中看到的那样，只想将其传递），则将FrameEvents发送到其他状态。</font><font style="vertical-align: inherit;">这一系列事件可以达到任何期望的深度。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，可以使用称为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法链接</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的技术来实现机器</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">用于将事件从一种状态发送到另一种状态的FMN标记是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调度程序</font></font></strong> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=&gt;</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="cpp hljs">$S1 =&gt; $S2</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 此FMN语句可以按以下方式实现： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">S1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e:FrameEvent)</span></span></span><span class="hljs-function"> </span></span>{ S2(e) <span class="hljs-comment"><span class="hljs-comment">// $S1 =&gt; $S2 }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们看到链接状态方法是多么容易。</font><font style="vertical-align: inherit;">让我们将此技术应用于一个相当困难的情况：</font></font><br><br><pre> <code class="cpp hljs">#Movement -machine- $Walking =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">3</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Running =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">6</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Crawling =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">.5</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) $AtAttention =&gt; $Motionless |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $LyingDown =&gt; $Motionless |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) $Moving |isMoving| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Motionless |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">0</span></span>) |isMoving| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在上面的代码中，我们看到有两个基本状态-$ Moving和$ Motionless-其他五个状态从它们继承了重要的功能。</font><font style="vertical-align: inherit;">事件绑定清楚地向我们展示了绑定的外观：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/117/95d/97c/11795d97c6a96d32824dc9ac2ddf62dc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 多亏了我们学到的技术，实现非常简单： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Movement</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Movement // -machine- /********************************** $Walking =&gt; $Moving |getSpeed| ^(3) |isStanding| ^(true) ***********************************/ func Walking(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 3 return } if (e._msg == "isStanding") { e._return = true return } Moving(e) // $Walking =&gt; $Moving } /********************************** $Running =&gt; $Moving |getSpeed| ^(6) |isStanding| ^(true) ***********************************/ func Running(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 6 return } if (e._msg == "isStanding") { e._return = true return } Moving(e) // $Running =&gt; $Moving } /********************************** $Crawling =&gt; $Moving |getSpeed| ^(.5) |isStanding| ^(false) ***********************************/ func Crawling(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = .5 return } if (e._msg == "isStanding") { e._return = false return } Moving(e) // $Crawling =&gt; $Moving } /********************************** $AtAttention =&gt; $Motionless |isStanding| ^(true) ***********************************/ func AtAttention(e:FrameEvent) { if (e._msg == "isStanding") { e._return = true return } Motionless(e) // $AtAttention =&gt; $Motionless } /********************************** $LyingDown =&gt; $Motionless |isStanding| ^(false) ***********************************/ func LyingDown(e:FrameEvent) { if (e._msg == "isStanding") { e._return = false return } Motionless(e) // $AtAttention =&gt; $Motionless } /********************************** $Moving |isMoving| ^(true) ***********************************/ func Moving(e:FrameEvent) { if (e._msg == "isMoving") { e._return = true return } } /********************************** $Motionless |getSpeed| ^(0) |isMoving| ^(false) ***********************************/ func Motionless(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 0 return } if (e._msg == "isMoving") { e._return = false return } } }</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 水机 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们有了有关FMN的知识基础，使我们能够了解如何使用状态以及更智能的方式重新实现WaterSample类。</font><font style="vertical-align: inherit;">我们还将使其对我们的研究生物理学家有用，并为其添加新的$等离子状态：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afb/d16/64d/afbd1664dacfde5e4857c45e35ee33ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 完整的FMN实施如下所示： </font></font><br><br><pre> <code class="cpp hljs">#WaterSample -machine- $Begin |create| <span class="hljs-comment"><span class="hljs-comment">// set temp to the event param value setTemp(@[temp]) // probe for temp state and change to it -&gt;&gt; $probeForState() ^ $Solid =&gt; $Default |melt| doMelt() -&gt;&gt; $Liquid ^ |sublimate| doSublimate() -&gt;&gt; $Gas ^ |getState| ^("SOLID") $Liquid =&gt; $Default |freeze| doFreeze() -&gt;&gt; $Solid ^ |vaporize| doVaporize() -&gt;&gt; $Gas ^ |getState| ^("LIQUID") $Gas =&gt; $Default |condense| doCondense() -&gt;&gt; $Liquid ^ |depose| doDepose() -&gt;&gt; $Solid ^ |ionize| doIonize() -&gt;&gt; $Plasma ^ |getState| ^("GAS") $Plasma =&gt; $Default |recombine| doRecombine() -&gt;&gt; $Gas ^ |getState| ^("PLASMA") $Default |melt| throw new InvalidStateError() |sublimate| throw new InvalidStateError() |freeze| throw new InvalidStateError() |vaporize| throw new InvalidStateError() |condense| throw InvalidStateError() |depose| throw InvalidStateError() |ionize| throw InvalidStateError() |recombine| throw InvalidStateError() |getState| throw InvalidStateError()</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如您所见，我们的初始状态为$ Begin，它会响应消息| create |。并保留价值</font></font><code>temp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。传感功能首先检查初始值</font></font><code>temp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以确定逻辑状态，然后执行机器到该状态的转换。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有物理状态（$固态，$液体，$气体，$等离子）都从$默认状态继承保护行为。对于当前状态无效的所有事件都将传递到$ Default状态，这将引发InvalidStateError错误。这显示了如何使用行为继承来实现简单的防御性编程。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在执行：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaterSample</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// -machine- var _state(e:FrameEvent) = Begin /********************************** $Begin |create| // set temp to the event param value setTemp(@[temp]) // probe for temp state and change to it -&gt;&gt; $probeForState() ^ ***********************************/ func Begin(e:FrameEvent) { if (e._msg == "create") { setTemp(e["temp"]) _state = probeForState() return } } /********************************** $Solid =&gt; $Default |melt| doMelt() -&gt;&gt; $Liquid ^ |sublimate| doSublimate() -&gt;&gt; $Gas ^ |sublimate| ^("SOLID") ***********************************/ func Solid(e:FrameEvent) { if (e._msg == "melt") { doMelt() _state = Liquid return } if (e._msg == "sublimate") { doSublimate() _state = Gas return } if (e._msg == "getState") { e._return = "SOLID" return } Default(e) } /********************************** $Liquid =&gt; $Default |freeze| doFreeze() -&gt;&gt; $Solid ^ |vaporize| doVaporize() -&gt;&gt; $Gas ^ |getState| ^("LIQUID") ***********************************/ func Liquid(e:FrameEvent) { if (e._msg == "freeze") { doFreeze() _state = Solid return } if (e._msg == "vaporize") { doVaporize() _state = Gas return } if (e._msg == "getState") { e._return = "LIQUID" return } Default(e) } /********************************** $Gas =&gt; $Default |condense| doCondense() -&gt;&gt; $Liquid ^ |depose| doDepose() -&gt;&gt; $Solid ^ |ionize| doIonize() -&gt;&gt; $Plasma ^ |getState| ^("GAS") ***********************************/ func Gas(e:FrameEvent) { if (e._msg == "condense") { doCondense() _state = Liquid return } if (e._msg == "depose") { doDepose() _state = Solid return } if (e._msg == "ionize") { doIonize() _state = Plasma return } if (e._msg == "getState") { e._return = "GAS" return } Default(e) } /********************************** $Plasma =&gt; $Default |recombine| doRecombine() -&gt;&gt; $Gas ^ |getState| ^("PLASMA") ***********************************/ func Plasma(e:FrameEvent) { if (e._msg == "recombine") { doRecombine() _state = Gas return } if (e._msg == "getState") { e._return = "PLASMA" return } Default(e) } /********************************** $Default |melt| throw new InvalidStateError() |sublimate| throw new InvalidStateError() |freeze| throw new InvalidStateError() |vaporize| throw new InvalidStateError() |condense| throw InvalidStateError() |depose| throw InvalidStateError() |ionize| throw InvalidStateError() |recombine| throw InvalidStateError() |getState| throw InvalidStateError() ***********************************/ func Default(e:FrameEvent) { if (e._msg == "melt") { throw new InvalidStateError() } if (e._msg == "sublimate") { throw new InvalidStateError() } if (e._msg == "freeze") { throw new InvalidStateError() } if (e._msg == "vaporize") { throw new InvalidStateError() } if (e._msg == "condense") { throw new InvalidStateError() } if (e._msg == "depose") { throw new InvalidStateError() } if (e._msg == "ionize") { throw new InvalidStateError() } if (e._msg == "recombine") { throw new InvalidStateError() } if (e._msg == "getState") { throw new InvalidStateError() } } }</span></span></code> </pre> <br><h3> 结论 </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自动机是计算机科学的基本概念，仅在软件和硬件开发的专门领域中使用时间已久。 Frame的主要任务是创建一种描述自动机的符号，并设置简单的模式来编写代码或为实现它们而使用的“机制”。我希望Frame表示法将改变程序员看待计算机的方式，从而提供一种简单的方法将它们付诸实践，以执行日常编程任务，当然，也可以将它们从代码中省去。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/411/041/f9d/411041f9dac0d4b6b9901a9528939495.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">终结者吃面食（Suzuki san摄）</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在未来的文章中，基于我们所学的概念，我们将为FMN表示法创造更大的功能和表现力。</font><font style="vertical-align: inherit;">随着时间的流逝，我将把讨论扩展到视觉建模的研究，其中包括FMN，并解决现代软件建模方法中行为不确定的问题。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446330/">https://habr.com/ru/post/zh-CN446330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN446320/index.html">3D扫描仪如何允许放弃桥梁的全面控制组件</a></li>
<li><a href="../zh-CN446322/index.html">Java中的密码学。 Keytool实用程序</a></li>
<li><a href="../zh-CN446324/index.html">使用Yandex.Navigator在DataGrip中导航</a></li>
<li><a href="../zh-CN446326/index.html">解决交通问题</a></li>
<li><a href="../zh-CN446328/index.html">为什么我们需要短信接收服务，以及它们与什么一起吃</a></li>
<li><a href="../zh-CN446332/index.html">IBM System i（又名AS / 400）-我们如何进行绿屏应用程序自动测试</a></li>
<li><a href="../zh-CN446334/index.html">关于IT事业的思考和针对初学者的提示</a></li>
<li><a href="../zh-CN446336/index.html">如何禁止标准密码并使所有人讨厌你</a></li>
<li><a href="../zh-CN446338/index.html">SVG 3D：创建，旋转和动画</a></li>
<li><a href="../zh-CN446340/index.html">操作系统：三个简单的部分。 第1部分：简介（翻译）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>