<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ú≥Ô∏è ‚úçüèª ü§î ¬øQu√© son las pruebas de componentes y c√≥mo es ser un SDET? üê§ üôèüèº ü§ê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anotaci√≥n 


 El art√≠culo habla sobre la forma poco convencional pero √∫til de las pruebas, y tambi√©n resume los resultados de siete a√±os de trabajo en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øQu√© son las pruebas de componentes y c√≥mo es ser un SDET?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414563/"><h1 id="annotaciya">  Anotaci√≥n </h1><br><p>  El art√≠culo habla sobre la forma poco convencional pero √∫til de las pruebas, y tambi√©n resume los resultados de siete a√±os de trabajo en el desarrollo de pruebas. </p><br><h1 id="zachem-nuzhny-komponentnye-testy">  ¬øPor qu√© necesita pruebas de componentes? </h1><br><p>  Despu√©s de todo, hay, por ejemplo, pruebas unitarias que prueban en detalle los despojos de los componentes.  Verifican a fondo que el componente funciona de acuerdo con la intenci√≥n del desarrollador.  Pero a menudo esto es una comprobaci√≥n de botones, y no c√≥mo se sienta el traje en su conjunto.  Y no siempre el comportamiento concebido por el programador coincide con lo que el cliente quer√≠a. </p><br><p>  Y hay, por ejemplo, pruebas de aceptaci√≥n.  Y eliminan todas estas deficiencias.  Pero, desafortunadamente, est√°n introduciendo nuevos.  Son lentos, a menudo inestables y generalmente mansos.  Sin embargo, solo indican un problema, pero no lo localizan. </p><br><p>  Obviamente, surge la necesidad de pruebas intermedias, que ser√°n la media de oro entre las pruebas unitarias y de aceptaci√≥n.  Este t√©rmino medio puede ser pruebas de componentes. </p><a name="habracut"></a><br><h1 id="chto-takoe-komponentnye-testy">  ¬øQu√© son las pruebas de componentes? </h1><br><p>  Estas son pruebas para la API del componente p√∫blico.  En consecuencia, est√°n escritos en el mismo idioma que el componente.  Objetivo de prueba: </p><br><ul><li>  verificar el cumplimiento de los componentes con sus contratos </li><li>  verificar cumplimiento <br>  Esto √∫ltimo es especialmente importante ya que  las pruebas unitarias generalmente se escriben en funci√≥n de las expectativas del desarrollador, pero aqu√≠ debe verificar las expectativas de los clientes. </li></ul><br><p>  Obviamente, las pruebas de componentes tienen sentido cuando tiene componentes dedicados con una interfaz extensa.  Por ejemplo, una biblioteca din√°mica o un objeto COM.  Entonces las pruebas de componentes dar√°n el m√°ximo efecto. </p><br><h1 id="plyusy-k-testov">  Ventajas de las pruebas k: </h1><br><ul><li>  <strong>Dar estabilidad al desarrollo.</strong>  Obviamente, una verificaci√≥n exhaustiva de las interfaces p√∫blicas le permite mantener el componente en una forma m√°s o menos eficiente. </li><li>  <strong>Localiza con precisi√≥n los problemas.</strong>  Incluso si la prueba del componente en s√≠ es bastante general, siempre se puede depurar en profundidad, llegando r√°pidamente al c√≥digo de batalla.  En este caso, el entorno de prueba ser√° m√≠nimo y se configurar√° autom√°ticamente. </li><li>  <strong>Acelere el desarrollo con un n√∫mero cr√≠tico de desarrolladores.</strong>  Los programadores son conocidos por ser como caballos.  Si un caballo tira de un carro con una capacidad de 1 litro.  s., luego se tiran ocho caballos con una capacidad de solo unos 4 litros.  s  Y la adici√≥n de otro desarrollador al equipo (especialmente al final del proyecto) a menudo no solo no acelera, sino que tambi√©n lo ralentiza.  Si bien la adici√≥n de un desarrollador de pruebas de componentes siempre es una ventaja, ya que act√∫a de manera relativamente independiente del equipo: realiza pruebas (esencialmente externas), acelera la compilaci√≥n de la compilaci√≥n, optimiza los archivos de ensamblaje, etc. </li><li>  <strong>Aclarar (y luego verificar) los requisitos del cliente.</strong>  Como el desarrollador de las pruebas de componentes no est√° vinculado a la implementaci√≥n, se ve menos afectado por el efecto "S√© c√≥mo hacerlo yo mismo".  En el caso de un requisito ambiguo, el desarrollador ordinario se inclina a hacer lo que sea conveniente (m√°s interesante, m√°s r√°pido, m√°s f√°cil).  Mientras que el desarrollador ct en este caso se inclina a especificar qu√© es exactamente lo que espera el cliente. </li><li>  <strong>Relativamente estable y relativamente r√°pido</strong> (en comparaci√≥n con las pruebas manuales y las pruebas automatizadas a trav√©s de la interfaz de usuario). </li></ul><br><h1 id="minusy-k-testov">  Contras de las pruebas K: </h1><br><ul><li>  <strong>Tiempo de desarrollo y apoyo.</strong>  Obviamente, la versi√≥n alfa del producto, si se pasa parte del tiempo escribiendo pruebas de componentes, aparecer√° m√°s tarde.  ¬øHabr√° una ganancia en general?  ¬øHabr√° un lanzamiento antes?  Esta es una buena pregunta  Mi opini√≥n: cuando se desarrolle con pruebas de componentes, la versi√≥n se lanzar√° aproximadamente al mismo tiempo.  Pero, con menos rumores y m√°s predecible en t√©rminos de tiempo.  El tiempo de desarrollo aumentar√° naturalmente, se reducir√° el tiempo de correcci√≥n de errores y la estabilizaci√≥n.  Dado que la segunda parte es mucho menos predecible, su reducci√≥n tendr√° un efecto beneficioso en la cantidad de procesamiento y molestias.  Sin embargo, esta es solo mi experiencia, y la realidad puede ser diferente.  Es posible que el tiempo asignado para las pruebas de componentes se invierta ineptamente para duplicar las pruebas unitarias existentes. </li><li>  <strong>Menos intercambiabilidad.</strong>  La separaci√≥n de roles aumenta la eficiencia, pero reduce la intercambiabilidad.  Los desarrolladores rara vez quieren profundizar en las pruebas de componentes, que pueden tener (o simular) un entorno bastante complejo.  Los desarrolladores de pruebas de componentes est√°n lejos de conocer el c√≥digo de batalla tan bien que puede editarse f√°cilmente. </li><li>  <strong>Duplicaci√≥n molesta.</strong>  Con buenas pruebas unitarias, las pruebas de componentes a menudo resultan ser en su mayor√≠a redundantes.  Esto es molesto y cuestiona su necesidad.  La coordinaci√≥n de los planes unitarios y las pruebas de componentes ayudan, pero por lo general la duplicaci√≥n no se elimina por completo. </li><li>  <strong>La necesidad de seguir el flujo de trabajo correcto.</strong>  Una vez recibidos los requisitos, la tarea debe ponerse simult√°neamente en el desarrollador y desarrollador de las pruebas.  Luego terminan de trabajar aproximadamente al mismo tiempo.  El componente se ejecuta a trav√©s de pruebas, los errores se detectan y corrigen r√°pidamente y se utiliza un producto m√°s o menos terminado para salir.  En este caso, los beneficios de las pruebas de componentes se maximizan.  Pero a menudo sucede que los plazos son profanos desde hace mucho tiempo, todos se abandonan para escribir solo c√≥digo y el componente se env√≠a a pruebas manuales sin pruebas.  Y solo entonces invitan al desarrollador de las pruebas: dicen que no es bueno que el c√≥digo sin las pruebas haya sido lanzado, deber√≠amos agregarlos.  En este caso, los probadores manuales encuentran la mayor√≠a de los errores, los desarrolladores realizan correcciones a ciegas (o prueban los cambios a mano) y las pruebas posteriores a los hechos solo encuentran un peque√±o n√∫mero de errores (lo que afecta negativamente la moral de su escritor).  Tal uso de pruebas de componentes es in√∫til en el mejor de los casos, y es dif√≠cil asegurarlo. </li><li>  <strong>Hay pocas personas adecuadas.</strong>  El desarrollador de pruebas de componentes deber√≠a, por un lado, poder escribir c√≥digo en el lenguaje del componente (y esto, por ejemplo, C ++).  Adem√°s, si el entorno para iniciar el componente es extenso, el c√≥digo puede ser bastante complicado.  Y, por otro lado, ser capaz de probar meticulosamente el trabajo de otra persona.  No hay muchas personas as√≠, y generalmente van inmediatamente a los desarrolladores.  Pero todav√≠a hay esas personas, y la siguiente parte sobre ellas. </li></ul><br><h1 id="rezyume-1">  Resumen 1 </h1><br><p>  Las pruebas de componentes son buenas, pero solo si tiene todas las condiciones para ellas: una API p√∫blica amplia, el flujo de trabajo correcto y las personas adecuadas en el equipo. </p><br><h1 id="kakovo-byt-sdetom">  ¬øC√≥mo es ser un SDET? </h1><br><p>  Obviamente, SDET - Ingeniero de desarrollo de software en prueba es un candidato ideal para escribir pruebas de componentes.  √âl sabe c√≥mo escribir c√≥digo y sabe c√≥mo pensar en las pruebas.  Tambi√©n proporciona una segunda opini√≥n, que tambi√©n mejora la calidad de las pruebas y el c√≥digo.  Todo esto suena interesante y tentador, tal vez ya quieras ser uno.  Aqu√≠ te contar√© brevemente c√≥mo el trabajo de SDET difiere del trabajo de un desarrollador puro. </p><br><h1 id="plyusy-raboty-sdetom">  Ventajas de trabajar con SDET: </h1><br><ul><li>  <strong>Nuevo c√≥digo</strong>  Casi siempre, SDET escribe pruebas desde cero.  Y a menudo, un entorno se escribe desde cero.  Es muy agradable y ofrece un gran margen para la creatividad. </li><li>  <strong>Baja dependencia del c√≥digo heredado.</strong>  No importa cu√°n terrible fue el c√≥digo de batalla, las pruebas se pueden hacer de manera competente y hermosa.  Por supuesto, un c√≥digo mal dise√±ado genera pruebas feas, pero a√∫n as√≠ se puede hacer un orden de magnitud mejor que el c√≥digo en s√≠. </li><li>  <strong>Refactorizaci√≥n m√°s frecuente.</strong>  Los cambios en las pruebas son mucho menos peligrosos, por lo tanto, se acuerdan con m√°s frecuencia.  Esta es una buena oportunidad para trabajar en errores y practicar la escritura de c√≥digo limpio a trav√©s de la refactorizaci√≥n. </li><li>  <strong>El desarrollo del pensamiento cr√≠tico.</strong>  Las pruebas autom√°ticas son una b√∫squeda interesante de c√≥mo descifrar el c√≥digo de otra persona.  Adem√°s, la b√∫squeda no es est√∫pida, no se asoma y se mete, sino con la ayuda de la l√≥gica, la combinatoria y la capacidad de ver vulnerabilidades.  Adem√°s, una vez creado, un cheque continuar√° funcionando para usted constantemente. </li><li>  <strong>Desarrollando la capacidad de probar c√≥digo.</strong>  En el entrenamiento de combate cuerpo a cuerpo, a menudo dan palabras introductorias: "ahora solo trabajamos con nuestros pies; ahora solo trabajamos con nuestras cabezas".  El uso de un solo mecanismo (en nuestro caso, pruebas autom√°ticas) le permite perfeccionarlo para dominarlo. </li><li>  <strong>Menos cantidad de rumores.</strong>  Los SDET se extraen mucho menos durante el fin de semana.  No tienen que ir a trabajar urgentemente para corregir errores cr√≠ticos.  Bueno, tienen muchas menos posibilidades de cometer un error grave. </li></ul><br><h1 id="minusy-raboty-sdetom">  Contras de trabajar con SDET: </h1><br><ul><li>  <strong>Baja complejidad de codificaci√≥n.</strong>  El c√≥digo de prueba suele ser a√∫n m√°s simple que el c√≥digo de batalla.  Condiciones previas, invocar el c√≥digo de batalla, condiciones posteriores, etc. para cada prueba.  El c√≥digo para crear el entorno es m√°s complicado, pero a√∫n no llega al combate.  Selecci√≥n de algoritmos √≥ptimos, dise√±o de estructuras de datos complejas, construcci√≥n de jerarqu√≠as de clases, generalmente todo esto lo pasa el desarrollador de la prueba. </li><li>  <strong>La experiencia est√° ganando m√°s lentamente</strong> .  La variedad y complejidad de situaciones en las que cae el desarrollador de la prueba es mucho menor.  Falla en la l√≠nea de ensamblaje, pruebas rojas, a veces vuelcos: este es el conjunto principal con el que generalmente tiene que trabajar.  El desarrollador tiene muchos m√°s problemas floridos: comienza con variaciones de enlace y ensamblaje, contin√∫a con fallas en un cliente en particular y volcados dise√±ados, y termina con la b√∫squeda de errores en el compilador y en las bibliotecas de terceros.  Y no solo ... </li><li>  <strong>Una gran diferencia en el estilo de prueba con los desarrolladores.</strong>  Por lo general, las SDET prefieren pruebas expresivas compactas que le permiten crear un entorno complejo en solo unas pocas l√≠neas, y las comprobaciones at√≥micas en el estilo son iguales / no iguales (es decir, el requisito se cumple o no).  A veces se trata de su DSL.  Simplemente, los desarrolladores prefieren las pruebas con un ajuste fino del entorno y numerosas pruebas de varios aspectos del comportamiento del programa, lo que conduce a pruebas bastante m√∫ltiples.  A veces se trata de copiar y pegar (que incluso los mejores desarrolladores no consideran pecado en este caso).  Aqu√≠ puede discutir durante mucho tiempo la mejor manera o incluso escribir un art√≠culo separado, pero el hecho es que cuando un desarrollador intenta modificar las pruebas SDET (o viceversa), esto a menudo conduce a discusiones largas e ineficaces. </li><li>  <strong>A continuaci√≥n se muestra el "grado".</strong>  Quiz√°s debido a un c√≥digo m√°s simple y menos responsabilidad, pero en √∫ltima instancia no es importante.  Por lo general, es as√≠. </li><li>  <strong>M√°s dif√≠cil moverse a una nueva posici√≥n.</strong>  SDET bien puede tener la pregunta en la frente: ha estado escribiendo pruebas durante tanto tiempo, es decir, de hecho, simplemente llam√≥ funciones y compar√≥ los resultados: ¬øpuede escribir c√≥digo real?  ¬øConoces todas las trampas del idioma?  ¬øResolviste problemas complejos?  ¬øTuviste que desmontar errores ornamentales o vertederos?  ¬øHay alguna experiencia con multihilo?  ¬øTienes, despu√©s de todo, ambiciones? </li></ul><br><h1 id="rezyume-2">  Resumen 2 </h1><br><p>  Como persona que trabaj√≥ como desarrollador durante muchos a√±os, luego asisti√≥ a SDET durante varios a√±os y luego volvi√≥ al desarrollo nuevamente, puedo decir lo siguiente. </p><br><p>  Recomiendo gastar un SDET durante al menos un a√±o o dos.  Esta es una experiencia muy gratificante para cualquier desarrollador.  Pero quedarse all√≠, en mi opini√≥n, no vale la pena. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414563/">https://habr.com/ru/post/es414563/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414549/index.html">3.000 ojos para inteligencia artificial. ¬øCu√°l es el sistema de monitoreo de estructuras del Centro Lakhta?</a></li>
<li><a href="../es414551/index.html">Instrucciones de admisi√≥n de doctorado en EE. UU.</a></li>
<li><a href="../es414555/index.html">C√≥mo transferimos 36 millones de clientes a un servicio de soporte t√©cnico digital</a></li>
<li><a href="../es414557/index.html">Hackear medidores inteligentes en PHDays 8: an√°lisis del concurso MeterH3cker</a></li>
<li><a href="../es414561/index.html">Escuela de videojuegos francesa: otro mundo</a></li>
<li><a href="../es414565/index.html">L√°mpara para muebles, cocina o ba√±o.</a></li>
<li><a href="../es414567/index.html">Anuncio de RamblerFront & # 5</a></li>
<li><a href="../es414569/index.html">Los arrecifes de coral guardan secretos del pasado y el futuro de los oc√©anos.</a></li>
<li><a href="../es414571/index.html">La inesperada relatividad del GPS integrado en el cerebro.</a></li>
<li><a href="../es414573/index.html">IP DoorBell - Timbre interactivo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>