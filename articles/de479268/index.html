<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙 🤚🏽 👩🏽 Event Listener und Web Worker 👃🏻 📕 🧛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe kürzlich die Web Workers API herausgefunden . Es ist bedauerlich, dass ich mir vorher nicht die Zeit für dieses gut unterstützte Tool genomme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Event Listener und Web Worker</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/479268/">  Ich habe kürzlich <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">die Web Workers API herausgefunden</a> .  Es ist bedauerlich, dass ich mir vorher nicht die Zeit für dieses gut unterstützte Tool genommen habe.  Moderne Webanwendungen stellen hohe Anforderungen an die Funktionen des JavaScript-Hauptthreads.  Dies wirkt sich auf die Produktivität von Projekten und deren Fähigkeit aus, eine komfortable Benutzererfahrung zu gewährleisten.  Web Worker sind genau das, was heutzutage Entwicklern helfen kann, schnelle und bequeme Webprojekte zu erstellen. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/479268/"><img src="https://habrastorage.org/webt/lz/ri/gh/lzrighg_057gfhx-kt26m-rr9eg.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">In dem Moment habe ich alles verstanden</font> </h2><br>  Web Worker haben viele positive Eigenschaften.  Aber ich habe ihre Nützlichkeit wirklich erkannt, als ich auf eine Situation stieß, in der eine bestimmte Anwendung mehrere DOM-Ereignis-Listener verwendet.  B. Ereignisse beim Senden von Formularen, Ändern der Fenstergröße, Klicken auf Schaltflächen.  Alle diese Listener müssen im Hauptthread arbeiten.  Wenn der Hauptthread mit bestimmten Vorgängen überlastet ist, die lange dauern, hat dies eine negative Auswirkung auf die Reaktionsrate der Ereignis-Listener auf Benutzereinflüsse.  Die Anwendung "verlangsamt sich", Ereignisse warten auf die Freigabe des Hauptthreads. <br><br>  Ich muss zugeben, der Grund, warum ich mich so für Event-Listener interessierte, war, dass ich anfangs falsch verstanden habe, welche Aufgaben Web-Worker lösen sollen.  Zuerst dachte ich, sie könnten dazu beitragen, die Geschwindigkeit der Codeausführung zu verbessern.  Ich dachte, dass eine Anwendung in einem bestimmten Zeitraum viel mehr kann, wenn einige Fragmente ihres Codes parallel in separaten Threads ausgeführt werden.  Während der Ausführung von Webprojektcode ist es jedoch durchaus üblich, dass Sie auf ein Ereignis warten müssen, bevor Sie etwas tun.  Angenommen, das DOM muss erst aktualisiert werden, nachdem einige Berechnungen abgeschlossen sind.  Da ich das wusste, glaubte ich naiv, dass es keinen Sinn macht, die Ausführung von Code auf einen separaten Thread zu übertragen, wenn ich auf jeden Fall warten muss. <br><br>  Hier ist ein Beispiel für Code, den Sie hier abrufen können: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> calculateResultsButton = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'calculateResultsButton'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> openMenuButton = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'#openMenuButton'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resultBox = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'resultBox'</span></span>); calculateResultsButton.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, (e) =&gt; {     <span class="hljs-comment"><span class="hljs-comment">// "    -, ,   ,     //   DOM   ?"     const result = performLongRunningCalculation();     resultBox.innerText = result; }); openMenuButton.addEventListener('click', (e) =&gt; {     //      . });</span></span></code> </pre> <br>  Hier aktualisiere ich den Text im Feld, nachdem einige Berechnungen abgeschlossen sind, vermutlich langwierig.  Es scheint sinnlos zu sein, diesen Code in einem separaten Thread auszuführen, da das DOM nicht aktualisiert wird, bevor dieser Code vollständig ist.  Aus diesem Grund entscheide ich mich natürlich, dass dieser Code synchron ausgeführt werden muss.  Als ich jedoch einen solchen Code sah, verstand ich zunächst nicht, dass andere Ereignis-Listener nicht gestartet werden, solange der Haupt-Thread blockiert ist.  Dies bedeutet, dass auf der Seite "Bremsen" angezeigt werden. <br><br><h2>  <font color="#3AC1EF">So "verlangsamen" Sie die Seite</font> </h2><br>  <a href="https://codepen.io/alexmacarthur/pen/XWWKyGe">Hier ist ein</a> CodePen-Projekt, das das oben Genannte demonstriert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bd/b78/158/3bdb781580ff39915b6b6ec1ea701c4c.png"></div><br>  <i><font color="#999999">Ein Projekt, das eine Situation zeigt, in der Seiten langsam sind</font></i> <br><br>  Durch Drücken der <code>Freeze</code> die Synchronaufgabe von der Anwendung gelöst.  All dies dauert 3 Sekunden (es simuliert die Leistung von langwierigen Berechnungen).  Wenn Sie gleichzeitig auf die Schaltfläche <code>Increment</code> klicken, wird der Wert im Feld Klickanzahl erst nach Ablauf von 3 Sekunden aktualisiert.  Ein neuer Wert, der der Anzahl der Klicks auf <code>Increment</code> wird erst nach <code>Increment</code> drei Sekunden in dieses Feld geschrieben.  Der Hauptstrom ist während einer Pause blockiert.  Infolgedessen funktioniert alles im Anwendungsfenster nicht mehr.  Die Anwendungsschnittstelle ist eingefroren.  Ereignisse, die während des „Einfrierens“ auftreten, warten auf die Gelegenheit, die Ressourcen des Hauptstroms zu nutzen. <br><br>  Wenn Sie auf <code>Freeze</code> klicken und versuchen, <code>resize me!</code> zu <code>resize me!</code>  Auch hier ändert sich die Größe des Feldes nicht, bis drei Sekunden vergangen sind.  Danach ändert sich jedoch die Größe des Feldes, es ist jedoch nicht erforderlich, über eine „Glätte“ der Benutzeroberfläche zu sprechen. <br><br><h2>  <font color="#3AC1EF">Ereignis-Listener sind ein viel größeres Phänomen, als es auf den ersten Blick erscheinen mag</font> </h2><br>  Jeder Benutzer möchte nicht mit einer Site arbeiten, die sich wie im vorherigen Beispiel verhält.  Hier kommen aber nur wenige Event-Listener zum Einsatz.  In der realen Welt sprechen wir von völlig anderen Maßstäben.  Ich habe mich für die <code>getEventListeners</code> Methode in Chrome entschieden und mithilfe des folgenden Skripts die Anzahl der Ereignis-Listener ermittelt, die an die DOM-Elemente verschiedener Seiten angehängt sind.  Dieses Skript kann direkt in der Entwicklertool-Konsole ausgeführt werden.  Da ist er: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>  .from([<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>, ...document.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'*'</span></span>)])  .reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">accumulator, node</span></span></span><span class="hljs-function">) =&gt;</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> listeners = getEventListeners(node);    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> listeners) {      accumulator = accumulator + listeners[property].length    }    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> accumulator;  }, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Ich habe dieses Skript auf verschiedenen Seiten ausgeführt und herausgefunden, wie viele Ereignis-Listener auf diesen Seiten verwendet wurden.  Die Ergebnisse meines Experiments sind in der folgenden Tabelle gezeigt. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>App</b> <br></td><td>  <b>Anzahl der Ereignislistener</b> <br></td></tr><tr><td>  Dropbox <br></td><td>  602 <br></td></tr><tr><td>  Google-Nachrichten <br></td><td>  581 <br></td></tr><tr><td>  Reddit <br></td><td>  692 <br></td></tr><tr><td>  YouTube <br></td><td>  6054 (!!!) <br></td></tr></tbody></table></div><br>  Sie können nicht auf bestimmte Nummern achten.  Die Hauptsache hier ist, dass wir über eine sehr große Anzahl von Event-Zuhörern sprechen.  Infolgedessen reagieren alle diese Listener nicht mehr auf Benutzereinflüsse, wenn mindestens ein längerer Vorgang in der Anwendung fehlschlägt.  Dies gibt Entwicklern viele Möglichkeiten, die Benutzer ihrer Anwendungen zu verärgern. <br><br><h2>  <font color="#3AC1EF">Beseitigen Sie mit Web-Workern die „Bremsen“</font> </h2><br>  In Anbetracht all der obigen Umstände schreiben wir das vorherige Beispiel neu.  <a href="https://codepen.io/alexmacarthur/pen/qBEORdO">Hier ist</a> seine neue Version.  Es sieht genauso aus wie das alte, ist aber anders angeordnet.  Nun wurde nämlich die Operation, die zum Blockieren des Hauptthreads verwendet wurde, in einen eigenen Thread verschoben.  Wenn Sie mit diesem Beispiel dasselbe tun wie mit dem vorherigen, können Sie schwerwiegende positive Unterschiede feststellen.  Wenn Sie nach dem Klicken auf die Schaltfläche " <code>Freeze</code> auf " <code>Increment</code> klicken, wird das Feld "Klickanzahl" aktualisiert (nach Abschluss des Webworkers wird in jedem Fall die Zahl 1 zum Wert " <code>Click Count</code> hinzugefügt).  Das gleiche gilt für die <code>resize me!</code>  .  In einem separaten Thread ausgeführter Code blockiert keine Ereignis-Listener.  Dies ermöglicht, dass alle Elemente der Seite auch während der Ausführung einer Operation funktionsfähig bleiben, bei der die Seite zuvor einfach "eingefroren" wurde. <br><br>  Hier ist der JS-Code für dieses Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> button1 = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button1'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> button2 = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button2'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'count'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workerScript = <span class="hljs-string"><span class="hljs-string">`  function pause(ms) {    let time = new Date();    while ((new Date()) - time &lt;= ms) {}               }  self.onmessage = function(e) {    pause(e.data);    self.postMessage('Process complete!');  } `</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> blob = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Blob([  workerScript, ], {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"text/javascipt"</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> worker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.URL.createObjectURL(blob)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bumpCount = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {  count.innerText = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(count.innerText) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } worker.onmessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e.data);  bumpCount(); } button1.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  worker.postMessage(<span class="hljs-number"><span class="hljs-number">3000</span></span>); }); button2.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  bumpCount(); });</code> </pre> <br>  Wenn Sie sich ein wenig mit diesem Code befassen, werden Sie feststellen, dass die Web Workers-API zwar übersichtlicher und komfortabler sein könnte, die Arbeit jedoch nicht besonders beängstigend ist.  Dieser Code sieht wahrscheinlich beängstigend aus, da es sich um eine einfache, schnell geschriebene Demo handelt.  Um die Benutzerfreundlichkeit der API zu verbessern und die Arbeit mit Web-Workern zu vereinfachen, können Sie einige zusätzliche Tools verwenden.  Zum Beispiel erschien mir Folgendes interessant: <br><br><ul><li>  <a href="https://github.com/developit/workerize">Workerize</a> - Ermöglicht das Ausführen von Modulen in Web <a href="https://github.com/developit/workerize">Workern</a> . </li><li>  <a href="https://github.com/developit/greenlet">Greenlet</a> - <a href="https://github.com/developit/greenlet">Ermöglicht</a> die Ausführung beliebiger asynchroner Codeteile in Web <a href="https://github.com/developit/greenlet">Workern</a> . </li><li>  <a href="https://github.com/GoogleChromeLabs/comlink">Comlink</a> - bietet eine praktische Abstraktionsebene über die Web Workers-API. </li></ul><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Wenn es sich bei Ihrer Webanwendung um ein typisches modernes Projekt handelt, ist es sehr wahrscheinlich, dass es viele Ereignis-Listener gibt.  Es ist auch möglich, dass es im Haupt-Thread viele Berechnungen ausführt, die durchaus in anderen Threads durchgeführt werden können.  Infolgedessen können Sie sowohl Ihren Benutzern als auch den Zuhörern von Veranstaltungen einen guten Service bieten und Web-Mitarbeitern „schwere“ Berechnungen anvertrauen. <br><br>  Es ist erwähnenswert, dass eine übermäßige Begeisterung für Web-Worker und das Entfernen von allem, was nicht direkt mit der Benutzeroberfläche für Web-Worker zusammenhängt, wahrscheinlich nicht die beste Idee ist.  Eine solche Bearbeitung eines Antrags kann viel Zeit und Mühe erfordern, der Projektcode wird komplizierter und die Vorteile einer solchen Konvertierung sind sehr gering.  Stattdessen könnte es sich lohnen, zunächst nach einem wirklich „schweren“ Code zu suchen und ihn den Web-Mitarbeitern zur Verfügung zu stellen.  Mit der Zeit wird die Idee, Web-Worker zu verwenden, vertrauter und Sie werden wahrscheinlich bereits in der Phase des Interface-Designs davon geleitet. <br><br>  Wie auch immer, ich empfehle Ihnen, die Web Workers-API zu verstehen.  Diese Technologie wird von zahlreichen Browsern unterstützt, und die Leistungsanforderungen an moderne Webanwendungen steigen.  Daher haben wir keinen Grund, das Studium von Tools wie Webworkern abzulehnen. <br><br>  <b>Sehr geehrte Leser!</b>  Verwenden Sie in Ihren Projekten Web-Worker? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub"><img src="https://habrastorage.org/getpro/habr/post_images/2fc/5b4/735/2fc5b473506e5be00e2b4274bb5e5da8.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479268/">https://habr.com/ru/post/de479268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479256/index.html">Nach dem Astrotracker an zwei Abenden - Meine Erfahrung</a></li>
<li><a href="../de479258/index.html">IGF 2019. Fällt das Internet auseinander?</a></li>
<li><a href="../de479262/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 392 (2. - 8. Dezember 2019)</a></li>
<li><a href="../de479264/index.html">Die Farbe des Mondes und der Sonne aus dem All in Bezug auf RGB und Farbtemperatur</a></li>
<li><a href="../de479266/index.html">Analyse der CPU-Auslastung einzelner JavaScript-Komponenten</a></li>
<li><a href="../de479270/index.html">Was können Sie 2020 von Node.js erwarten?</a></li>
<li><a href="../de479272/index.html">[Lesezeichen] 9 Tools zur Steigerung der Produktivität von Webentwicklern</a></li>
<li><a href="../de479274/index.html">10 wichtige Python-Tricks</a></li>
<li><a href="../de479276/index.html">Drei Pandas-Methoden, die Sie vielleicht nicht kennen</a></li>
<li><a href="../de479278/index.html">Einhundert bis fünfhundert Ziffern der Zahl pi auf dem Knie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>