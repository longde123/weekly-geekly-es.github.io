<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèª ‚úåüèª ü§¨ ValueTask <TResult>: ¬øpor qu√©, por qu√© y c√≥mo? ü§üüèº üõ¢Ô∏è ü§öüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prefacio a la traducci√≥n 


 A diferencia de los art√≠culos cient√≠ficos, los art√≠culos de este tipo son dif√≠ciles de traducir "cerca del texto", y se d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ValueTask <TResult>: ¬øpor qu√©, por qu√© y c√≥mo?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/465259/"><h3 id="predislovie-k-perevodu">  <em>Prefacio a la traducci√≥n</em> </h3><br><p>  <em>A diferencia de los art√≠culos cient√≠ficos, los art√≠culos de este tipo son dif√≠ciles de traducir "cerca del texto", y se debe hacer una adaptaci√≥n bastante fuerte.</em>  <em>Por esta raz√≥n, pido disculpas por algunas libertades, por mi parte, al tratar con el texto del art√≠culo original.</em>  <em>Me gu√≠o por un solo objetivo: hacer que la traducci√≥n sea comprensible, incluso si en algunos lugares se desv√≠a fuertemente del art√≠culo original.</em>  <em>Agradecer√≠a las cr√≠ticas constructivas y las correcciones / adiciones a la traducci√≥n.</em> </p><br><h2 id="vvedenie">  Introduccion </h2><br><p> El <code>System.Threading.Tasks</code> nombres <code>System.Threading.Tasks</code> y la clase <code>Task</code> se introdujeron por primera vez en .NET Framework 4. Desde entonces, este tipo y su clase derivada <code>Task&lt;TResult&gt;</code> , han entrado firmemente en la pr√°ctica de la programaci√≥n en .NET y se han convertido en aspectos clave del modelo asincr√≥nico. implementado en C # 5, con su <code>async/await</code> .  En este art√≠culo, hablar√© sobre los nuevos tipos de <code>ValueTask/ValueTask&lt;TResult&gt;</code> que se introdujeron para mejorar el rendimiento del c√≥digo as√≠ncrono, en los casos en que la sobrecarga de memoria juega un papel clave. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/f4/7b/3c/f47b3cblzfyn77xgh1odpwfgy5i.jpeg"></a> </p><a name="habracut"></a><br><h2 id="task">  Tarea </h2><br><p>  <code>Task</code> tiene varios prop√≥sitos, pero el principal es "promesa": un objeto que representa la capacidad de esperar la finalizaci√≥n de una operaci√≥n.  Inicia la operaci√≥n y obtiene <code>Task</code> .  Esta <code>Task</code> se completar√° cuando se complete la operaci√≥n en s√≠.  En este caso, hay tres opciones: </p><br><ol><li>  La operaci√≥n se completa sincr√≥nicamente en el subproceso iniciador.  <em>Por ejemplo, al acceder a algunos datos que ya est√°n en el b√∫fer</em> . </li><li>  La operaci√≥n se realiza de forma asincr√≥nica, pero logra completarse <em>cuando el</em> iniciador recibe la <code>Task</code> .  <em>Por ejemplo, cuando se realiza un acceso r√°pido a datos que a√∫n no se han almacenado</em> </li><li>  La operaci√≥n se realiza de forma as√≠ncrona y finaliza <em>despu√©s de que el</em> iniciador recibe la <code>Task</code> <em>Un ejemplo es la recepci√≥n de datos a trav√©s de una red</em> . </li></ol><br><p>  Para obtener el resultado de una llamada asincr√≥nica, el cliente puede bloquear el hilo de llamada mientras espera la finalizaci√≥n, lo que a menudo contradice la idea de asincron√≠a, o proporcionar un m√©todo de devoluci√≥n de llamada que se ejecutar√° al finalizar la operaci√≥n asincr√≥nica.  El modelo de devoluci√≥n de llamada en .NET 4 se present√≥ expl√≠citamente, utilizando el m√©todo <code>ContinueWith</code> de un objeto de la clase <code>Task</code> , que recibi√≥ un delegado al que se llam√≥ al finalizar la operaci√≥n asincr√≥nica. </p><br><pre> <code class="plaintext hljs">SomeOperationAsync().ContinueWith(task =&gt; { try { TResult result = task.Result; UseResult(result); } catch (Exception e) { HandleException(e); } });</code> </pre> <br><p>  Con .NET Frmaework 4.5 y C # 5, se simplific√≥ la obtenci√≥n del resultado de una operaci√≥n asincr√≥nica al introducir las palabras clave <code>async/await</code> y el mecanismo detr√°s de ellas.  Este mecanismo, el c√≥digo generado, puede optimizar todos los casos mencionados anteriormente, manejando correctamente la finalizaci√≥n a pesar de la ruta en la que se alcanz√≥. </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  La clase <code>Task</code> es bastante flexible y tiene varias ventajas.  Por ejemplo, puede "esperar" un objeto de esta clase varias veces, puede esperar el resultado de forma competitiva, por cualquier n√∫mero de consumidores.  Las instancias de una clase se pueden almacenar en un diccionario para cualquier n√∫mero de llamadas posteriores, con el objetivo de "esperar" en el futuro.  Los escenarios descritos le permiten considerar los objetos de <code>Task</code> como una especie de cach√© de resultados obtenidos de forma asincr√≥nica.  Adem√°s, <code>Task</code> proporciona la capacidad de bloquear el hilo de espera hasta que se complete la operaci√≥n si el script lo requiere.  Tambi√©n est√° el llamado.  combinadores para diversas estrategias para esperar la finalizaci√≥n de conjuntos de tareas, por ejemplo, "Tarea.CuandoAny" - esperando asincr√≥nicamente la finalizaci√≥n de la primera de muchas tareas. </p><br><p>  Pero, sin embargo, el caso de uso m√°s com√∫n es simplemente comenzar una operaci√≥n asincr√≥nica y luego esperar el resultado de su ejecuci√≥n.  Un caso tan simple, bastante com√∫n, no requiere la flexibilidad anterior: </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  Esto es muy similar a c√≥mo escribimos c√≥digo s√≠ncrono (por ejemplo, <code>TResult result = SomeOperation();</code> ).  Esta opci√≥n se traduce naturalmente en <code>async/await</code> . </p><br><p>  Adem√°s, a pesar de todos sus m√©ritos, el tipo de <code>Task</code> tiene un defecto potencial.  <code>Task</code> es una clase, lo que significa que cada operaci√≥n que crea una instancia de una tarea asigna un objeto en el mont√≥n.  Cuantos m√°s objetos creamos, m√°s trabajo se requiere del GC, y m√°s recursos se gastan en el trabajo del recolector de basura, recursos que podr√≠an usarse para otros fines.  Esto se convierte en un problema claro para el c√≥digo, en el que, por un lado, las instancias de <code>Task</code> se crean a menudo, y por otro lado, lo que ha aumentado los requisitos de rendimiento y rendimiento. </p><br><p>  El tiempo de ejecuci√≥n y las bibliotecas principales, en muchas situaciones, logran mitigar este efecto.  Por ejemplo, si escribe un m√©todo como el siguiente: </p><br><pre> <code class="plaintext hljs">public async Task WriteAsync(byte value) { if (_bufferedCount == _buffer.Length) { await FlushAsync(); } _buffer[_bufferedCount++] = value; }</code> </pre> <br><p>  y, la mayor√≠a de las veces, habr√° suficiente espacio en el b√∫fer, la operaci√≥n finalizar√° sincr√≥nicamente.  Si es as√≠, la tarea devuelta no tiene nada de especial, no hay valor de retorno y la operaci√≥n ya se ha completado.  En otras palabras, estamos tratando con <code>Task</code> , el equivalente de una operaci√≥n de <code>void</code> s√≠ncrono.  En tales situaciones, el tiempo de ejecuci√≥n simplemente almacena en cach√© el objeto <code>Task</code> y lo usa cada vez como resultado de cualquier <code>async Task</code> , un m√©todo que finaliza sincr√≥nicamente ( <code>Task.ComletedTask</code> ).  Otro ejemplo, digamos que escribes: </p><br><pre> <code class="plaintext hljs">public async Task&lt;bool&gt; MoveNextAsync() { if (_bufferedCount == 0) { await FillBuffer(); } return _bufferedCount &gt; 0; }</code> </pre> <br><p>  Suponga, de la misma manera, que en la mayor√≠a de los casos, hay algunos datos en el b√∫fer.  El m√©todo verifica <code>_bufferedCount</code> , ve que la variable es mayor que cero y devuelve <code>true</code> .  Solo si en el momento de la verificaci√≥n no se almacenaron los datos, se requiere una operaci√≥n asincr√≥nica.  Sea como fuere, solo hay dos posibles resultados l√≥gicos ( <code>true</code> y <code>false</code> ), y solo dos posibles estados de retorno a trav√©s de la <code>Task&lt;bool&gt;</code> .  Basado en la finalizaci√≥n sincr√≥nica o asincr√≥nica, pero antes de salir del m√©todo, el tiempo de ejecuci√≥n almacena en cach√© dos instancias de la <code>Task&lt;bool&gt;</code> (una para <code>true</code> y otra para <code>false</code> ), y devuelve la deseada, evitando asignaciones adicionales.  La √∫nica opci√≥n cuando tiene que crear un nuevo objeto <code>Task&lt;bool&gt;</code> es un caso de ejecuci√≥n asincr√≥nica, que finaliza despu√©s del "retorno".  En este caso, el m√©todo tiene que crear un nuevo objeto <code>Task&lt;bool&gt;</code> , porque  en el momento de la salida del m√©todo, el resultado de la operaci√≥n a√∫n no se conoce.  El objeto devuelto debe ser √∫nico, porque  finalmente almacenar√° el resultado de la operaci√≥n asincr√≥nica. </p><br><p>  Hay otros ejemplos de almacenamiento en cach√© similar del tiempo de ejecuci√≥n.  Pero tal estrategia no es aplicable en todas partes.  Por ejemplo, el m√©todo: </p><br><pre> <code class="plaintext hljs">public async Task&lt;int&gt; ReadNextByteAsync() { if (_bufferedCount == 0) { await FillBuffer(); } if (_bufferedCount == 0) { return -1; } _bufferedCount--; return _buffer[_position++]; }</code> </pre> <br><p>  Tambi√©n a menudo termina sincr√≥nicamente.  Pero, a diferencia del ejemplo anterior, este m√©todo devuelve un resultado entero que tiene aproximadamente cuatro mil millones de valores posibles.  Para almacenar en cach√© la <code>Task&lt;int&gt;</code> , en esta situaci√≥n, se necesitar√≠an cientos de gigabytes de memoria.  El entorno aqu√≠ tambi√©n admite un cach√© peque√±o para la <code>Task&lt;int&gt;</code> , para varios valores peque√±os.  Entonces, por ejemplo, si la operaci√≥n se completa sincr√≥nicamente (los datos est√°n presentes en el b√∫fer), con un resultado de 4, se usar√° el cach√©.  Pero si el resultado, aunque sincr√≥nico, la finalizaci√≥n es 42, se crear√° un nuevo objeto <code>Task&lt;int&gt;</code> , similar a llamar a <code>Task.FromResult(42)</code> . </p><br><p>  Muchas implementaciones de bibliotecas intentan mitigar estas situaciones mediante el soporte de sus propios cach√©s.  Un ejemplo es la sobrecarga de <code>MemoryStream.ReadAsync</code> .  Esta operaci√≥n, introducida en .NET Framework 4.5, siempre finaliza sincr√≥nicamente porque  Es solo una lectura de memoria.  <code>ReadAsync</code> devuelve una <code>Task&lt;int&gt;</code> donde el resultado entero representa el n√∫mero de bytes le√≠dos.  Muy a menudo, en el c√≥digo, ocurre una situaci√≥n cuando <code>ReadAsync</code> usa en un bucle.  Adem√°s, si hay los siguientes s√≠ntomas: </p><br><ul><li>  El n√∫mero de bytes solicitados no cambia para la mayor√≠a de las iteraciones del bucle; </li><li>  En la mayor√≠a de las iteraciones, <code>ReadAsync</code> puede leer el n√∫mero de bytes solicitado. </li></ul><br><p>  Es decir, para llamadas repetidas, <code>ReadAsync</code> ejecuta sincr√≥nicamente y devuelve un objeto <code>Task&lt;int&gt;</code> , con el mismo resultado de iteraci√≥n a iteraci√≥n.  Es l√≥gico que <code>MemoryStream</code> cach√© la √∫ltima tarea completada con √©xito, y para todas las llamadas posteriores, si el nuevo resultado coincide con el anterior, devuelve una instancia del cach√©.  Si el resultado no coincide, <code>Task.FromResult</code> usa para crear una nueva instancia, que, a su vez, tambi√©n se almacena en cach√© antes de regresar. </p><br><p>  Pero, sin embargo, hay muchos casos en que una operaci√≥n se ve obligada a crear nuevos objetos de <code>Task&lt;TResult&gt;</code> , incluso cuando se completa sincr√≥nicamente. </p><br><h2 id="valuetasktresult-i-sinhronnoe-zavershenie">  ValueTask &lt;TResult&gt; y finalizaci√≥n sincr√≥nica </h2><br><p>  Todo esto, en √∫ltima instancia, sirvi√≥ como motivaci√≥n para introducir un nuevo tipo de <code>ValueTask&lt;TResult&gt;</code> en .NET Core 2.0.  Adem√°s, a trav√©s del sistema nuget-package <code>System.Threading.Tasks.Extensions</code> , este tipo estuvo disponible en otras versiones de .NET. </p><br><p>  <code>ValueTask&lt;TResult&gt;</code> se introdujo en .NET Core 2.0 como una estructura capaz de <code>TResult</code> o <code>Task&lt;TResult&gt;</code> .  Esto significa que los objetos de este tipo se pueden devolver desde el m√©todo <code>async</code> .  La primera ventaja de la introducci√≥n de este tipo es inmediatamente visible: si el m√©todo se complet√≥ con √©xito y sincr√≥nicamente, no hay necesidad de crear nada en el mont√≥n, solo lo suficiente para crear una instancia de <code>ValueTask&lt;TResult&gt;</code> con el valor del resultado.  Solo si el m√©todo sale de forma asincr√≥nica, necesitamos crear una <code>Task&lt;TResult&gt;</code> .  En este caso, <code>ValueTask&lt;TResult&gt;</code> usa como envoltorio sobre la <code>Task&lt;TResult&gt;</code> .  La decisi√≥n de hacer que <code>ValueTask&lt;TResult&gt;</code> pueda agregar la <code>Task&lt;TResult&gt;</code> se tom√≥ para la optimizaci√≥n: en caso de √©xito y en caso de falla, el m√©todo asincr√≥nico crea la <code>Task&lt;TResult&gt;</code> , desde el punto de vista de la optimizaci√≥n de la memoria, es mejor agregar el objeto <code>Task&lt;TResult&gt;</code> que mantener campos adicionales en <code>ValueTask&lt;TResult&gt;</code> para varios casos de finalizaci√≥n (por ejemplo, para almacenar una excepci√≥n). </p><br><p>  Dado lo anterior, ya no es necesario el almacenamiento en cach√© de m√©todos como el <code>MemoryStream.ReadAsync</code> anterior, sino que se puede implementar de la siguiente manera: </p><br><pre> <code class="plaintext hljs">public override ValueTask&lt;int&gt; ReadAsync(byte[] buffer, int offset, int count) { try { int bytesRead = Read(buffer, offset, count); return new ValueTask&lt;int&gt;(bytesRead); } catch (Exception e) { return new ValueTask&lt;int&gt;(Task.FromException&lt;int&gt;(e)); } }</code> </pre> <br><h2 id="valuetasklttresultgt-i-asinhronnoe-zavershenie">  ValueTask &lt;TResult&gt; y terminaci√≥n asincr√≥nica </h2><br><p>  Tener la capacidad de escribir m√©todos asincr√≥nicos que no requieren asignaciones de memoria adicionales para el resultado, con finalizaci√≥n sincr√≥nica, es realmente una gran ventaja.  Como se indic√≥ anteriormente, este era el objetivo principal para introducir el nuevo tipo <code>ValueTask&lt;TResult&gt;</code> en .NET Core 2.0.  Todos los m√©todos nuevos que se espera utilizar en las "carreteras <code>ValueTask&lt;TResult&gt;</code> " ahora usan <code>ValueTask&lt;TResult&gt;</code> lugar de <code>Task&lt;TResult&gt;</code> como el tipo de retorno.  Por ejemplo, una nueva sobrecarga del m√©todo <code>ReadAsync</code> para <code>Stream</code> , en .NET Core 2.1 (que toma <code>Memory&lt;byte&gt;</code> lugar de <code>byte[]</code> como par√°metro), devuelve una instancia de <code>ValueTask&lt;int&gt;</code> .  Esto permiti√≥ reducir significativamente el n√∫mero de asignaciones cuando se trabaja con flujos (muy a menudo el m√©todo <code>ReadAsync</code> finaliza sincr√≥nicamente, como en el ejemplo con <code>MemoryStream</code> ). </p><br><p>  Sin embargo, al desarrollar servicios con gran ancho de banda, en los que la terminaci√≥n asincr√≥nica no es infrecuente, debemos hacer todo lo posible para evitar asignaciones adicionales. </p><br><p>  Como se mencion√≥ anteriormente, en el modelo <code>async/await</code> , cualquier operaci√≥n que se complete de forma as√≠ncrona debe devolver un objeto √∫nico para esperar a que se complete.  √önico porque  servir√° como un canal para realizar devoluciones de llamada.  Sin embargo, tenga en cuenta que esta construcci√≥n no dice nada acerca de si el objeto de espera devuelto puede <em>reutilizarse</em> despu√©s de la finalizaci√≥n de la operaci√≥n asincr√≥nica.  Si se puede reutilizar un objeto, la API puede mantener un grupo para este tipo de objetos.  Pero, en este caso, este grupo no puede admitir el acceso concurrente: un objeto del grupo pasar√° del estado "completado" al estado "no completado" y viceversa. </p><br><p>  Para admitir la capacidad de trabajar con dichos grupos, la <code>IValueTaskSource&lt;TResult&gt;</code> se agreg√≥ a .NET Core 2.1, y la <code>ValueTask&lt;TResult&gt;</code> se expandi√≥: ahora los objetos de este tipo pueden envolver no solo objetos del tipo <code>TResult</code> o <code>Task&lt;TResult&gt;</code> , sino tambi√©n instancias de <code>IValueTaskSource&lt;TResult&gt;</code> .  La nueva interfaz proporciona una funcionalidad b√°sica que permite que los <code>ValueTask&lt;TResult&gt;</code> trabajen con <code>IValueTaskSource&lt;TResult&gt;</code> de la misma manera que con la <code>Task&lt;TResult&gt;</code> : </p><br><pre> <code class="plaintext hljs">public interface IValueTaskSource&lt;out TResult&gt; { ValueTaskSourceStatus GetStatus(short token); void OnCompleted( Action&lt;object&gt; continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags); TResult GetResult(short token); }</code> </pre> <br><p>  <code>GetStatus</code> destinado para su uso en la <code>ValueTask&lt;TResult&gt;.IsCompleted/IsCompletedSuccessfully</code> : le permite saber si la operaci√≥n se complet√≥ o no (con √©xito o no).  <code>OnCompleted</code> usa en <code>ValueTask&lt;TResult&gt;</code> para activar una devoluci√≥n de llamada.  <code>GetResult</code> usa para obtener el resultado o para lanzar una excepci√≥n. </p><br><p>  Es poco probable que la mayor√≠a de los desarrolladores necesiten tratar con la <code>IValueTaskSource&lt;TResult&gt;</code> , porque  Los m√©todos asincr√≥nicos, cuando se devuelven, lo ocultan detr√°s de la <code>ValueTask&lt;TResult&gt;</code> .  La interfaz en s√≠ est√° destinada principalmente a aquellos que desarrollan API de alto rendimiento y busca evitar el trabajo innecesario con un grupo. </p><br><p>  En .NET Core 2.1, hay varios ejemplos de este tipo de API.  La m√°s famosa de ellas es la nueva sobrecarga de los m√©todos <code>Socket.ReceiveAsync</code> y <code>Socket.SendAsync</code> .  Por ejemplo: </p><br><pre> <code class="plaintext hljs">public ValueTask&lt;int&gt; ReceiveAsync( Memory&lt;byte&gt; buffer, SocketFlags socketFlags, CancellationToken cancellationToken = default);</code> </pre> <br><p>  Los objetos de tipo <code>ValueTask&lt;int&gt;</code> se utilizan como valor de retorno. <br>  Si el m√©todo sale sincr√≥nicamente, devuelve una <code>ValueTask&lt;int&gt;</code> con el valor correspondiente: </p><br><pre> <code class="plaintext hljs">int result = ‚Ä¶; return new ValueTask&lt;int&gt;(result);</code> </pre> <br><p>  Si la operaci√≥n se completa de forma as√≠ncrona, se utiliza un objeto en cach√© que implementa la <code>IValueTaskSource&lt;TResult&gt;</code> : </p><br><pre> <code class="plaintext hljs">IValueTaskSource&lt;int&gt; vts = ‚Ä¶; return new ValueTask&lt;int&gt;(vts);</code> </pre> <br><p>  La implementaci√≥n de <code>Socket</code> admite un objeto en cach√© para recibir y otro para enviar datos, siempre que cada uno de ellos se use sin competencia (no, por ejemplo, env√≠o de datos competitivos).  Esta estrategia reduce la cantidad de memoria adicional asignada, incluso en el caso de ejecuci√≥n asincr√≥nica. <br>  La optimizaci√≥n descrita de <code>Socket</code> en .NET Core 2.1 tuvo un impacto positivo en el rendimiento de <code>NetworkStream</code> .  Su sobrecarga es el m√©todo <code>ReadAsync</code> de la clase <code>Stream</code> : </p><br><pre> <code class="plaintext hljs">public virtual ValueTask&lt;int&gt; ReadAsync( Memory&lt;byte&gt; buffer, CancellationToken cancellationToken);</code> </pre> <br><p>  simplemente delega el trabajo al m√©todo <code>Socket.ReceiveAsync</code> .  Aumentar la eficiencia del m√©todo de socket, en t√©rminos de trabajar con memoria, aumenta la eficiencia del m√©todo <code>NetworkStream</code> . </p><br><h2 id="non-generic-valuetask">  ValueTask no gen√©rico </h2><br><p>  Anteriormente, not√© varias veces que el objetivo original de <code>ValueTask&lt;T&gt;</code> , en .NET Core 2.0, era optimizar los casos de finalizaci√≥n sincr√≥nica de m√©todos con un resultado "no vac√≠o".  Esto significa que no hab√≠a necesidad de una <code>ValueTask</code> no <code>ValueTask</code> : en casos de finalizaci√≥n sincr√≥nica, los m√©todos usan un singleton a trav√©s de la propiedad <code>Task.CompletedTask</code> , y el tiempo de ejecuci√≥n para los m√©todos de <code>async Task</code> tambi√©n se recibe impl√≠citamente. </p><br><p>  Pero, con el advenimiento de la capacidad de evitar asignaciones innecesarias y con una ejecuci√≥n asincr√≥nica, la necesidad de un <code>ValueTask</code> no tipado volvi√≥ a ser relevante.  Por esta raz√≥n, en .NET Core 2.1, introdujimos <code>ValueTask</code> y <code>IValueTaskSource</code> no <code>IValueTaskSource</code> .  Son an√°logos de los tipos gen√©ricos correspondientes, y se usan de la misma manera, pero para m√©todos con un retorno vac√≠o ( <code>void</code> ). </p><br><h2 id="realizaciya-ivaluetasksource--ivaluetasksourcelttgt">  Implemente IValueTaskSource / IValueTaskSource &lt;T&gt; </h2><br><p>  La mayor√≠a de los desarrolladores no necesitar√°n implementar estas interfaces.  Y su implementaci√≥n no es una tarea f√°cil.  Si decide que necesita implementarlos usted mismo, entonces, dentro de .NET Core 2.1, hay varias implementaciones que pueden servir como ejemplos: </p><br><ul><li>  <a href="">AwaitableSocketAsyncEventArgs</a> </li><li>  <a href="">AsyncOperation &lt;TResult&gt;</a> </li><li>  <a href="">DefaultPipeReader</a> </li></ul><br><p>  Para simplificar estas tareas (implementaciones de <code>IValueTaskSource / IValueTaskSource&lt;T&gt;</code> ), planeamos presentar el tipo <code>ManualResetValueTaskSourceCore&lt;TResult&gt;</code> en .NET Core 3.0.  Esta estructura encapsular√° toda la l√≥gica necesaria.  La <code>ManualResetValueTaskSourceCore&lt;TResult&gt;</code> puede usarse en otro objeto que implemente <code>IValueTaskSource&lt;TResult&gt;</code> y / o <code>IValueTaskSource</code> , y delegarle la mayor parte del trabajo.  Puede obtener m√°s informaci√≥n sobre esto en ttps: //github.com/dotnet/corefx/issues/32664. </p><br><h2 id="pravilnaya-model-ispolzovaniya-valuetasks">  El modelo correcto para usar ValueTasks </h2><br><p>  Incluso un examen superficial <code>ValueTask</code> que <code>ValueTask</code> y <code>ValueTask&lt;TResult&gt;</code> m√°s limitados que <code>Task</code> y <code>Task&lt;TResult&gt;</code> .  Y esto es normal, incluso deseable, porque su objetivo principal es esperar la finalizaci√≥n de la ejecuci√≥n asincr√≥nica. </p><br><p>  En particular, surgen limitaciones significativas debido al hecho de que <code>ValueTask</code> y <code>ValueTask&lt;TResult&gt;</code> pueden agregar objetos reutilizables.  En general, las siguientes operaciones * <em>NUNCA deben realizarse cuando se utiliza</em> <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> * <em>(</em> d√©jeme reformular a trav√©s de "Nunca" *): </p><br><ul><li>  <strong>Nunca use el mismo objeto <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> repetidamente</strong> </li></ul><br><p>  <em>Motivaci√≥n: las</em> instancias de <code>Task</code> y <code>Task&lt;TResult&gt;</code> nunca pasan del estado "completado" al estado "incompleto", podemos usarlas para esperar el resultado tantas veces como queramos; una vez finalizado, siempre obtendremos el mismo resultado.  Por el contrario, desde <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> , pueden actuar como envoltorios sobre objetos reutilizados, lo que significa que su estado puede cambiar, porque  el estado de los objetos reutilizados cambia por definici√≥n, para pasar de "completado" a "incompleto" y viceversa. </p><br><ul><li>  <strong>Nunca <code>ValueTask</code> / <code>ValueTask&amp;lt;TResult&amp;gt;</code></strong>  <strong>en modo competitivo</strong> </li></ul><br><p>  <em>Motivaci√≥n: un</em> objeto envuelto espera funcionar con una sola devoluci√≥n de llamada, de un solo consumidor a la vez, y tratar de competir anticipadamente puede conducir f√°cilmente a condiciones de carrera y sutiles errores de programaci√≥n.  Expectativas competitivas, esta es una de las opciones descritas anteriormente con <strong>m√∫ltiples expectativas</strong> .  Tenga en cuenta que <code>Task</code> / <code>Task&lt;TResult&gt;</code> permite cualquier cantidad de expectativas competitivas. </p><br><ul><li>  <strong>Nunca use <code>.GetAwaiter().GetResult()</code> hasta que se complete la operaci√≥n</strong> . </li></ul><br><p>  <em>Motivaci√≥n: las</em> implementaciones de <code>IValueTaskSource</code> / <code>IValueTaskSource&lt;TResult&gt;</code> no deber√≠an admitir el bloqueo hasta que se complete la operaci√≥n.  El bloqueo, de hecho, conduce a una condici√≥n de carrera, es poco probable que este sea el comportamiento esperado por parte del consumidor.  Mientras <code>Task</code> / <code>Task&lt;TResult&gt;</code> permite hacer esto, bloqueando el hilo de llamada hasta que se complete la operaci√≥n. </p><br><p>  Pero, ¬øqu√© sucede si, sin embargo, necesita realizar una de las operaciones descritas anteriormente y el m√©todo llamado devuelve instancias de <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> ?  Para tales casos, <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> proporciona el m√©todo <code>.AsTask()</code> .  Al llamar a este m√©todo, obtendr√° una instancia de <code>Task</code> / <code>Task&lt;TResult&gt;</code> , y ya puede realizar la operaci√≥n necesaria con √©l.  <em>No se permite</em> reutilizar el objeto original despu√©s de llamar a <code>.AsTask()</code> . </p><br><p> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una regla corta dice</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando trabaje con una instancia de </font></font><code>ValueTask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/, </font></font><code>ValueTask&lt;TResult&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe esperar ( </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) directamente (o, si es necesario </font></font><code>.ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), o llamarlo </font></font><code>.AsTask()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y nunca usar el objeto original </font></font><code>ValueTask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font><font style="vertical-align: inherit;">nuevamente </font></font><code>ValueTask&lt;TResult&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></em> </p><br><pre> <code class="plaintext hljs">// Given this ValueTask&lt;int&gt;-returning method‚Ä¶ public ValueTask&lt;int&gt; SomeValueTaskReturningMethodAsync(); ‚Ä¶ // GOOD int result = await SomeValueTaskReturningMethodAsync(); // GOOD int result = await SomeValueTaskReturningMethodAsync().ConfigureAwait(false); // GOOD Task&lt;int&gt; t = SomeValueTaskReturningMethodAsync().AsTask(); // WARNING ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); ... // storing the instance into a local makes it much more likely it'll be misused, // but it could still be ok // BAD: awaits multiple times ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = await vt; int result2 = await vt; // BAD: awaits concurrently (and, by definition then, multiple times) ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); Task.Run(async () =&gt; await vt); Task.Run(async () =&gt; await vt); // BAD: uses GetAwaiter().GetResult() when it's not known to be done ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = vt.GetAwaiter().GetResult();</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hay otro patr√≥n de uso "avanzado" adicional que algunos programadores pueden decidir aplicar (espero que solo despu√©s de mediciones cuidadosas, con justificaci√≥n de los beneficios de su uso). </font></font></p><br><p>   <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>  ,       .  ,  <code>IsCompleted</code>  <code>true</code> ,    (   ,  ),    ‚Äî <code>false</code> ,  <code>IsCompletedSuccessfully</code>  <code>true</code>     .   " " ,   , ,    ,    ,    .            <code>await</code> / <code>.AsTask()</code>     <code>.Result</code> .  ,   <code>SocketsHttpHandler</code>  .NET Core 2.1,     <code>.ReadAsync</code> ,   <code>ValueTask&lt;int&gt;</code> .    ,       , ,  .      ,         ..   .  Porque    ,     , ,  ,    : </p><br><pre> <code class="plaintext hljs">int bytesRead; { ValueTask&lt;int&gt; readTask = _connection.ReadAsync(buffer); if (readTask.IsCompletedSuccessfully) { bytesRead = readTask.Result; } else { using (_connection.RegisterCancellation()) { bytesRead = await readTask; } } }</code> </pre> <br><p>    , .. <code>ValueTask&lt;int&gt;</code> ,     <code>.Result</code> ,    <code>await</code> ,     . </p><br><h2 id="dolzhny-li-vse-novye-asinhronnye-api-vozvraschat-valuetask--valuetasklttresultgt">      API  ValueTask / ValueTask&lt;TResult&gt;? </h2><br><p>  ,  .      <code>Task</code> / <code>ValueTask&lt;TResult&gt;</code> . </p><br><p>    ,   <code>Task</code> / <code>Task&lt;TResult&gt;</code>     .   ,       ""  / ,    <code>Task</code> / <code>Task&lt;TResult&gt;</code> . ,  ,      <code>ValueTask&lt;TResult&gt;</code>  <code>Task&lt;TResult&gt;</code> : ,   ,  <code>await</code>     <code>Task&lt;TResult&gt;</code>   <code>ValueTask&lt;TResult&gt;</code> .  ,       (,  API  <code>Task</code>  <code>Task&lt;bool&gt;</code> ), ,    ,   <code>Task</code> ( <code>Task&lt;bool&gt;</code> ).  , <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>    .  ,    async-,              <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> ,       . </p><br><p>     , <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>   , : </p><br><ol><li>  ,    API    , </li><li>  API        ,  </li><li>   ,      ,         ,    . </li></ol><br><p>  ,     <code>abstract</code> / <code>virtual</code>  ,    ,           /  ? </p><br><h2 id="chto-dalshe">  Que sigue </h2><br><p>    .NET,     API,  <code>Task</code> / <code>Task&lt;TResult&gt;</code> . ,  ,     API c <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> ,     .         <code>IAsyncEnumerator&lt;T&gt;</code> ,      .NET Core 3.0.  <code>IEnumerator&lt;T&gt;</code>   <code>MoveNext</code> ,    .   ‚Äî <code>IAsyncEnumerator&lt;T&gt;</code>   <code>MoveNextAsync</code> .      ,        <code>Task&lt;bool&gt;</code> ,        ,    .  ,       ,       ,      (        ),   ,   ,         <code>await foreach</code> -,  ,      <code>MoveNextAsync</code> ,  <code>ValueTask&lt;bool&gt;</code> .         , ,   ,     " " ,         . ,  C#      ,           . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465259/">https://habr.com/ru/post/465259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465247/index.html">Angular Comprender @Input, @Output y EventEmitter</a></li>
<li><a href="../465249/index.html">Conferencia de Richard Stallman en el Polit√©cnico de Mosc√∫. Agosto 2019</a></li>
<li><a href="../465251/index.html">El verano casi ha terminado. Casi no se filtraron datos</a></li>
<li><a href="../465255/index.html">Implementaci√≥n de la agrupaci√≥n de conexiones WCF para .Net Core usando HttpClientFactory</a></li>
<li><a href="../465257/index.html">‚Äú¬°Cuidado, FAS!‚Äù: Trucos de McDonald's, shawarma divino, falso Clooney y algo de magia callejera</a></li>
<li><a href="../465261/index.html">El poder m√°gico de las macros, o c√≥mo hacer la vida m√°s f√°cil para un programador ensamblador AVR</a></li>
<li><a href="../465263/index.html">Bloquea en PostgreSQL: 3. Bloquea otros objetos</a></li>
<li><a href="../465267/index.html">TypeScript Magia de expresi√≥n</a></li>
<li><a href="../465269/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. D√≠a 26. DNS y DHCP</a></li>
<li><a href="../465271/index.html">Los hackers roban y lavan dinero mediante la entrega de alimentos y los servicios de reserva de hotel.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>