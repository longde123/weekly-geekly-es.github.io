<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍💼 ☁️ 💅 OpenStreetMap Part Medium: Versteckte Datenvisualisierung 🙆🏼 👩🏽‍🏭 🏜️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir alle sind es gewohnt, die klassischen Basissubstrate im Internet zu betrachten, um die Siedlungen, Straßen und ihre Namen, Häuser mit ihrer Nummer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenStreetMap Part Medium: Versteckte Datenvisualisierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441296/"><p>  Wir alle sind es gewohnt, die klassischen Basissubstrate im Internet zu betrachten, um die Siedlungen, Straßen und ihre Namen, Häuser mit ihrer Nummer zu sehen.  Aber auch diese Eigenschaftsobjekte haben mehr als nur einen Namen oder eine Nummer.  Für Gebäude ist dies eine Reihe von Stockwerken, für Straßen gibt es eine Reihe von Fahrspuren und für Städte eine Reihe von Einwohnern.  Dies ist jedoch nur die Spitze des Eisbergs - OpenStreetMap ist so reich an einer Vielzahl von Geodaten, dass Sie einige davon einfach nie gesehen haben.  Und ohne spezielle Renderings werden Sie nie sehen, es sei denn, Sie möchten die Daten dieser Zeile mit seltsamen Tags bearbeiten.  Heute erstellen wir ein hochspezialisiertes Rendering für die Darstellung von Waldvierteln. </p><br><p><img src="https://habrastorage.org/webt/ae/7r/_m/ae7r_mo4w4x-v8amg0uqh15vjii.png" alt="Waldviertel"></p><a name="habracut"></a><br><p>  Schritt 1. Umfragen. <br>  Sie können natürlich mit Ihrem Finger am Himmel erraten, wie sie bezeichnet werden könnten, aber es ist sicherer, zu Wiki-Osm zu gehen.  Und dort finden wir folgendes: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">border = wood_compartment</a> </p><br><p> Daher werden <code>boundary=forest_compartment</code> durch Polygone mit dem Tag <code>boundary=forest_compartment</code> .  Es gibt zwar eine Klarstellung, dass es ursprünglich als <code>boundary=forestry_compartment</code> , aber es war weniger gebildet.  Und da die Anzahl der Verwendungen mit der alten Bezeichnung erheblich ist (laut taginfo etwa viertausendmal), werden wir sie nicht rabattieren. </p><br><p>  Schritt 2. Daten. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nehmen Sie die</a> Daten von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geofabrik</a> .  Laden Sie eine Datei für ganz Russland herunter - <code>russia-latest.osm.pbf</code> .  Mit <code>osmconvert</code> wir die Daten im o5m-Format für die anschließende Filterung. </p><br><pre> <code class="plaintext hljs">osmconvert russia-latest.osm.pbf -o=russia-latest.o5m</code> </pre> <br><p>  Jetzt filtern wir nur die Daten, die wir mit <code>osmfilter</code> benötigen </p><br><pre> <code class="plaintext hljs">osmfilter russia-latest.o5m --keep="boundary=forest_compartment =forestry_compartment" -o=forest_compartment-local.o5m</code> </pre> <br><p>  Schritt 3. Vektorkacheln. <br>  Eine kleine kurze Theorie.  Der alte Ansatz besteht darin, einige Daten aus einer großen Datenbank anzufordern, ein Bild von ihnen zu erhalten und sie zu speichern, um sie dem Kunden in Zukunft zur Verfügung zu stellen.  Fordern Sie in der neuen Datenbank aus einer großen Datenbank einige kleine Daten an und speichern Sie sie für die spätere Übertragung an den Client.  Und lassen Sie den Kunden sie in ein Bild verwandeln.  Profitieren Sie sozusagen vom Gesicht - wir haben die Last, das Bild zu rendern, auf die Schultern des Kunden übertragen.  Von den Minuspunkten: Auf der Kaffeemaschine können Sie die Karte möglicherweise nicht sehen. Sie benötigen WebGL-Unterstützung. </p><br><p>  Deshalb schlug Mapbox ein Format für Vektorkacheln und einen Container für diese in Form einer SQLite-Datenbank vor.  Daher ist es jetzt keine Streuung von Dateien in Ordnern, sondern eine ordentlich einsame Datei.  Eine Vektorkachel enthält logische Ebenen (Häuser, Straßen usw.), die aus Geometrie und Attributen bestehen. </p><br><p>  Hier bereiten wir sie auf unsere Waldviertel vor.  Ich werde das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TileMaker-</a> Tool verwenden.  Es empfängt OSM-Daten im PDF-Format als Eingabe, daher müssen wir nach dem Filtern wieder in dieses Format konvertieren. </p><br><pre> <code class="plaintext hljs">osmconvert forest_compartment-local.o5m -o=forest_compartment-local.pbf</code> </pre> <br><p>  Jetzt müssen wir TileMaker erklären, welche Ebenen und mit welchen Attributen wir gemäß der <a href="">Dokumentation</a> benötigen. </p><br><p>  Schritt 4. Ebenen? <br>  Und welche Schichten brauchen wir?  Und es kommt darauf an, was wir zeigen.  Das heißt,  Zunächst müssen wir uns den visuellen Teil irgendwie vorstellen.  Und wie kann dies aus den verfügbaren Daten erreicht werden?  Aus den OSM-Daten haben wir ein Raster aus Polygonen und ihren Attributen.  Die Attribute haben den Namen der Forstwirtschaft und die Viertelnummer. </p><br><p><img src="https://habrastorage.org/webt/ii/mb/6v/iimb6vqew9cch0kpobg2ko4qej8.png" alt="OSM-Rohdaten"></p><br><p>  Am einfachsten ist es, das Quartal anzuzeigen und mit Ihrer Nummer zu unterschreiben.  Das heißt,  Wir brauchen eine Polygonebene. In der Mitte des Polygons wird eine Inschrift mit ihrer Nummer angezeigt. <br>  Und dann erscheint das erste Merkmal von Vektorkacheln.  Wenn ein großes Quellpolygon in verschiedene Kacheln fällt, fallen nur seine Teile in die Kacheln.  Und beim Rendern stellt sich heraus, dass es sich jeweils um zwei verschiedene Polygone handelt. Für sie befinden sich zwei Signaturen in der Mitte ihrer Hälften. </p><br><p><img src="https://habrastorage.org/webt/qp/av/s-/qpavs-uusqadrvzpisc2ukozii4.png"></p><br><p>  Daher wird für Vektorkacheln eine separate Ebene mit Inschriften erstellt, wenn noch alle erforderlichen Informationen zur Geometrie vorliegen. </p><br><p>  Fazit: Wir benötigen zwei Ebenen, Polygon zum Füllen und Punkt zum Signieren.  Erstellen Sie die Datei <code>config.json</code> . </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"layers"</span></span>: { }, <span class="hljs-attr"><span class="hljs-attr">"settings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"minzoom"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"maxzoom"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"basezoom"</span></span>: <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-attr"><span class="hljs-attr">"include_ids"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"freeExec"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Forest Compartment RUS"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ODbL 1.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Forest compartment from OpenStreetMap"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"compress"</span></span>: <span class="hljs-string"><span class="hljs-string">"gzip"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"metadata"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"attribution"</span></span>: <span class="hljs-string"><span class="hljs-string">"&lt;a href=\"http://www.openstreetmap.org/copyright/\" target=\"_blank\"&gt;&amp;copy;  OpenStreetMap&lt;/a&gt;"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"json"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"vector_layers"</span></span>: [ ] } } } }</code> </pre> <br><p>  Geben Sie im Abschnitt Ebenen an, was wir benötigen </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"layers"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"forest_compartment"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"minzoom"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"maxzoom"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"forest_compartment_label"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"minzoom"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"maxzoom"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span> } },</code> </pre> <br><p>  Die Namen der Ebenen werden angezeigt und in welchem ​​Maßstab werden sie angezeigt. </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"json"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"vector_layers"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"forest_compartment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Compartment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: {}}, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"forest_compartment_label"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Compartment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: {<span class="hljs-attr"><span class="hljs-attr">"ref"</span></span>:<span class="hljs-string"><span class="hljs-string">"String"</span></span>}} ] }</code> </pre> <br><p>  In den Metadaten teilen wir dem zukünftigen Visualizer mit, welche Attribute bei uns verfügbar sind.  Für die Tag-Ebene haben wir die Viertelnummer in <code>ref</code> </p><br><p>  Schritt 5. Datenverarbeitung. <br>  Zu diesem Zweck wird ein Skript in der Sprache <code>lua</code> verwendet, das entscheidet, welche Objekte aus den OSM-Daten wir benötigen, in welcher Ebene sie gesendet werden sollen und mit welchen Attributen. </p><br><p>  Beginnen wir mit der Dateivorlage process.lua. </p><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">-- Nodes will only be processed if one of these keys is present node_keys = { } -- Initialize Lua logic function init_function() end -- Finalize Lua logic() function exit_function() end -- Assign nodes to a layer, and set attributes, based on OSM tags function node_function(node) end -- Similarly for ways function way_function(way) end</span></span></code> </pre> <br><p>  Was wir hier haben: </p><br><p>  node_keys - Es gibt viele Punkte in den OSM-Daten. Wenn wir jeweils dieses Skript aufrufen, dauert die Verarbeitung sehr lange.  Dies ist ein Filter, der uns sagt, an welchen wichtigen Punkten wir interessiert sind. </p><br><p>  Funktion node_function (node) - Die Funktion wird an jedem Punkt aufgerufen, der für uns aus dem vorherigen Absatz interessant ist.  Hier müssen wir entscheiden, was wir damit machen wollen. </p><br><p>  function way_function (way) - eine Funktion, die in jeder Zeile und in Beziehungen zu den Multipolygon- und Grenztypen aufgerufen wird, weil  Sie werden als Flächenobjekte betrachtet. </p><br><p>  Wir beginnen Code zu schreiben.  Zunächst geben wir an, welche Punkte wir benötigen: </p><br><pre> <code class="lua hljs">node_keys = { <span class="hljs-string"><span class="hljs-string">"boundary"</span></span> }</code> </pre> <br><p>  Jetzt schreiben wir die Funktion, um sie zu verarbeiten: </p><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">node_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> boundary = node:Find(<span class="hljs-string"><span class="hljs-string">"boundary"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> boundary == <span class="hljs-string"><span class="hljs-string">"forestry_compartment"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> boundary == <span class="hljs-string"><span class="hljs-string">"forest_compartment"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> ref = node:Find(<span class="hljs-string"><span class="hljs-string">"ref"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ref ~= <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> node:Layer(<span class="hljs-string"><span class="hljs-string">"forest_compartment_label"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) node:Attribute(<span class="hljs-string"><span class="hljs-string">"ref"</span></span>, ref) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Was hier passiert: Wir lesen den Wert des <code>boundary</code> durch den <code>node:Find("")</code> .  Wenn dies <code>forest_compartment</code> , lesen Sie die Viertelnummer aus dem <code>ref</code> Tag.  Wenn es nicht leer ist, wird dieses Objekt über <code>Layer("_", ___)</code> zu unserer Ebene mit Beschriftungen <code>Layer("_", ___)</code> .  Im Attribut der <code>ref</code> Ebene speichern wir die Viertelnummer. <br>  Fast so einfach für quadratische Blöcke: </p><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">way_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(way)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> boundary = way:Find(<span class="hljs-string"><span class="hljs-string">"boundary"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> way:IsClosed() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ( boundary == <span class="hljs-string"><span class="hljs-string">"forestry_compartment"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> boundary == <span class="hljs-string"><span class="hljs-string">"forest_compartment"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> way:Layer(<span class="hljs-string"><span class="hljs-string">"forest_compartment"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) way:AttributeNumeric(<span class="hljs-string"><span class="hljs-string">"nomerge"</span></span>, way:Id()) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> ref = way:Find(<span class="hljs-string"><span class="hljs-string">"ref"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ref ~= <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> way:LayerAsCentroid(<span class="hljs-string"><span class="hljs-string">"forest_compartment_label"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) way:Attribute(<span class="hljs-string"><span class="hljs-string">"ref"</span></span>, ref) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Hier prüfen wir zusätzlich, ob die Leitung geschlossen ist, weil  Es kommt vor, dass Tags einfach auf Segmenten vorhanden sind.  Es ist erwähnenswert, dass die <code>forest_compartment</code> Fläche ist (daher das zweite Argument für die Funktion <code>Layer("", true))</code> , und wir nehmen den Platz für die Signatur als Zentrum der <code>LayerAsCentroid</code> . </p><br><p>  Es lohnt sich auch, auf das Attribut zu achten, das wir hinzufügen, obwohl wir es in der Konfiguration nicht angegeben <code>nomerge</code> .  Es ist erforderlich, um eine andere Funktion zu deaktivieren, diesmal bereits den TileMaker-Konverter (obwohl der Parameter zum Deaktivieren in der neuen Version angezeigt wurde). </p><br><p>  Die Besonderheit ist, dass zur Optimierung, wenn sich viele Objekte mit denselben Attributen in einer Ebene befinden, der Konverter für sie die Geometrien zu einer kombiniert.  Zum Beispiel haben wir eine Straße, die aus drei separaten Segmenten besteht, die als Ergebnis dreimal zum Rendern gesendet werden.  Dies ist länger im Vergleich zu der Tatsache, dass wir ein Objekt an das Rendering senden würden, jedoch mit einer etwas komplexeren Geometrie (die alle vereint). </p><br><p>  In unserem Fall würden alle benachbarten Viertel zu einem großen Polygon zusammengefasst, aber das brauchen wir nicht.  Daher fügen wir die Objektnummer so hinzu, dass sie unterschiedlich und nicht kombiniert sind. </p><br><p>  Jetzt ist es Zeit, mit dem Erstellen von Vektorkacheln zu beginnen. </p><br><pre> <code class="plaintext hljs">tilemaker forest_compartment-local.pbf --output forest_compartment-local.mbtiles</code> </pre> <br><p>  Daher sollten wir die Datei <code>forest_compartment-local.mbtiles</code> </p><br><p>  Schritt 6. Erstellen Sie einen Stil. <br>  Wir erstellen ein Konto auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mapbox.com</a> .  Erstellen Sie in Mapbox Studio im Abschnitt Tileset ein neues Tileet, indem Sie unsere zuvor erstellte Datei in das Download-Fenster ziehen.  Innerhalb einer Minute sollte es verarbeitet und der Liste hinzugefügt werden. </p><br><p>  Jetzt gehen wir zum Abschnitt Stile und erstellen einen neuen basierend auf dem fertigen Licht, damit wir die Hauptelemente der Karte sehen können, wie Straßen, Siedlungen usw.  Wir fahren nach Cheboksary, weil dort Waldblöcke gesehen wurden. </p><br><p>  Wir gehen zu Level 11 der Skala (wir haben nur Kacheln für ihn erstellt) und klicken auf die Schaltfläche Ebene hinzufügen.  Auf der Registerkarte Datenquelle finden wir unsere <code>forest_compartment-local-XXXXX</code> wählen wir die Polygonebene aus.  Es sollte rechts grün hervorgehoben sein. </p><br><p><img src="https://habrastorage.org/webt/dq/ka/-h/dqka-h_wx2qcqz-xbncxutb1exo.png" alt="Schicht hinzufügen"></p><br><p>  Stellen Sie als Nächstes auf der Registerkarte Stil die Füllfarbe auf Grün und den Strich auf Braun ein. </p><br><p><img src="https://habrastorage.org/webt/zb/h_/zp/zbh_zpmk7tmktabdpbfvxoekbeu.png" alt="Farbanpassung"></p><br><p>  Nun bleibt die Signatur hinzuzufügen.  Fügen Sie eine neue Ebene hinzu. Nur dieses Mal wählen wir <code>forest_compartment_label</code> in den Daten aus und wählen das <code>forest_compartment_label</code> Die Zahlen sollten rechts <code>forest_compartment_label</code> . </p><br><p><img src="https://habrastorage.org/webt/er/gh/_x/ergh_x_oj7bjv0redgs9bf9ylta.png" alt="Etikettenebene hinzufügen."></p><br><p>  Geben Sie auf der Registerkarte Stil an, dass unser <code>ref</code> Attribut angezeigt werden soll. </p><br><p><img src="https://habrastorage.org/webt/zl/7r/nq/zl7rnqapwxl7qqtzyminooid1z4.png" alt="Attribut für Signatur"></p><br><p>  So ist es, klicken Sie auf die rechte Seite des Veröffentlichungsbildschirms und wir können den Link freigeben, damit andere unsere Kreation sehen können.  ABER die Anzeige von Karten ist nicht kostenlos, wie auch anderswo, daher werde ich Ihnen meinen Link nicht geben, um nicht in den Habreffekt zu geraten. </p><br><p>  PS: Vielleicht werde ich Ihnen in einem zusätzlichen Artikel erzählen, wie ich den Ort der Signatur mit dem Namen der Forstwirtschaft auf einer Gruppe von darin enthaltenen Blöcken erreicht habe. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441296/">https://habr.com/ru/post/de441296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441286/index.html">Yandex Neural Network ist Co-Autor eines Stücks für Bratsche und Orchester</a></li>
<li><a href="../de441288/index.html">6 Punkte Conversion-Wachstum oder effektive Techniken für die Arbeit mit dem Preis auf der Website</a></li>
<li><a href="../de441290/index.html">The Witcher 3: Wild Hunt: Wie Lokalisierer Namen übersetzten</a></li>
<li><a href="../de441292/index.html">Fintech Digest: Zentralbankroboter gegen Finanzpyramiden, Banken überprüfen die Daten von Abonnenten von Mobilfunkbetreibern</a></li>
<li><a href="../de441294/index.html">Smart Lock: Warum Faultier ein Treiber für den IoT-Fortschritt ist</a></li>
<li><a href="../de441298/index.html">Cisco Live EMEA 2019: Wechsel eines alten IT-Fahrrads zu BMW in den Wolken</a></li>
<li><a href="../de441300/index.html">Anachronismen, Crunches, schlechte Organisationsstruktur: Drei Schmerzen der Teamführung in einem Unternehmen</a></li>
<li><a href="../de441302/index.html">AMA mit Habr (Direktverbindung mit TM, Version 6.0)</a></li>
<li><a href="../de441306/index.html">Wie man in einem Tag ein Angebot für einen QS-Ingenieur in Moskau bekommt (und es ist teuer, hier zu leben)</a></li>
<li><a href="../de441310/index.html">Erfahrung im Aufbau einer Infrastruktur auf Microservice-Architektur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>