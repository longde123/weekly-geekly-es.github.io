<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📜 👊🏼 👍🏼 OpenVPN dengan otentikasi dan otorisasi tingkat lanjut 😲 📹 🕒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini membahas konfigurasi OpenVPN dengan fitur tambahan: 



- Sertifikat token untuk otentikasi utama (Rutoken sebagai contoh) 
- Backend LDAP...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenVPN dengan otentikasi dan otorisasi tingkat lanjut</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433250/">  Artikel ini membahas konfigurasi OpenVPN dengan fitur tambahan: <br><br><ul><li>  Sertifikat token untuk otentikasi utama (Rutoken sebagai contoh) </li><li>  Backend LDAP untuk otentikasi sekunder (menggunakan ActiveDirectory sebagai contoh) </li><li>  memfilter sumber daya internal yang tersedia untuk pengguna (melalui iptables) </li></ul><br>  Ini juga menjelaskan cara mengkonfigurasi klien untuk Linux, Windows dan MacOS. <br><a name="habracut"></a><br><h3>  Pengaturan server </h3><br><h4>  Instal OpenVPN </h4><br>  Ambil script <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nyr / openvpn-install</a> , jalankan dari root. <br><br><pre><code class="plaintext hljs">git clone https://github.com/Nyr/openvpn-install.git cd openvpn-install</code> </pre> <br>  Proses startup akan mengajukan beberapa pertanyaan. <br><br><ul><li>  protokol udp </li><li>  port 1194 </li><li>  Server DNS - Lokal </li><li>  alamat ip-gateway eksternal di Internet di mana server vpn akan tersedia </li></ul><br>  Ada juga versi skrip asli yang ditingkatkan keamanannya - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/Angristan/OpenVPN-install</a> .  Ini memiliki lebih banyak pengaturan enkripsi dengan penjelasan mengapa. <br><br><h4>  Manajemen pengguna </h4><br>  <b>Menambahkan</b> <br>  Jika token tidak digunakan, pengguna ditambahkan melalui skrip yang sama.  Script pada dasarnya menghasilkan konfigurasi ovpn khusus dan menyisipkan sertifikat yang ditandatangani oleh sertifikat root di sana. <br><br>  Jika token digunakan (lihat bagian token di bawah), maka sertifikat tersebut ditulis secara manual berdasarkan permintaan untuk sertifikat yang dihasilkan pada token.  Konfigurasi pengguna harus dilakukan secara manual dari templat yang ada (dari yang sama dari mana skrip konfigurasi dibuat).  Templatnya ada di sini <code>/etc/openvpn/client-common.txt</code> .  Itu tidak termasuk dalam paket openvpn dan dihasilkan oleh skrip selama proses konfigurasi. <br><br>  <b>Hapus</b> <br>  Menghapus pengguna dilakukan melalui skrip instalasi yang sama.  Sertifikat ditambahkan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CRL</a> , CRL baru didorong ke server vpn.  Server menganggap semua sertifikat yang ada di CRL tidak valid dan menolak untuk menerima. <br><br>  Cara mencabut sertifikat secara manual: <br><br><pre> <code class="plaintext hljs">cd /etc/openvpn/easyrsa #   ./easyrsa revoke $CLIENT #   crl ./easyrsa gen-crl #   crl rm -rf /etc/openvpn/crl.pem #    cp /etc/openvpn/easy-rsa/pki/crl.pem /etc/openvpn/crl.pem # openvpn    crl,       nobody chown nobody:nobody /etc/openvpn/crl.pem</code> </pre><br><h4>  Memfilter Host yang Tersedia untuk Klien </h4><br>  Klien harus dibatasi oleh host yang dapat mereka akses di jaringan ketika mereka terhubung ke openvpn. <br><br>  <b>Secara manual</b> <br><br>  Idenya adalah untuk menangkap paket bahkan pada antarmuka <code>tun0</code> , di mana mereka berasal dari klien dan menyaringnya sebelum mereka masuk ke NAT.  Setelah NAT, tidak akan ada alasan untuk memfilter mereka - mereka semua akan memiliki alamat ip server openvpn di jaringan internal.  Sebelum masuk ke NAT, paket untuk setiap pengguna memiliki alamat ip unik mereka sendiri (untuk korespondensi alamat-ip dan pengguna, lihat file <code>/etc/openvpn/ipp.txt</code> ). <br><br>  Paket yang melewati sistem (tidak datang langsung dari itu dan tidak masuk, yaitu, sebenarnya, dialihkan oleh sistem) diproses oleh tabel FORWARD.  Tabel di iptables diproses dari atas ke bawah, jika tidak ada aturan dalam tabel yang mengarah pada keputusan tentang nasib paket, maka aturan default dipicu. <br><br>  Mempersiapkan tabel FORWARD: <br><br><pre> <code class="plaintext hljs">#   iptables -F FORWARD #     FORWARD -    iptables -P FORWARD DROP #     iptables -I FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT</code> </pre><br>  Contoh aturan untuk klien tertentu.  Karena aturan default untuk tabel ini adalah DROP, aturan ini hanya memperbolehkan pasangan host + port di mana Anda bisa.  Izinkan akses ke port di host + ping host itu sendiri: <br><br><pre> <code class="plaintext hljs">iptables -I FORWARD -s 10.8.0.3 -i tun0 -d 10.0.2.3 -p tcp --dport 443 -j ACCEPT iptables -I FORWARD -s 10.8.0.3 -i tun0 -d 10.0.2.3 -p icmp --icmp-type echo-request -j ACCEPT</code> </pre><br>  Pada contoh di atas, host 10.8.0.3 diizinkan mengakses port 443 dari host 10.0.2.3. <br><br>  Cara menutup akses: <br><br><pre> <code class="plaintext hljs">#         iptables -L FORWARD --line-numbers #     iptables -D FORWARD { }</code> </pre><br>  Maka Anda perlu menemukan semua aturan untuk klien tertentu dan menghapusnya. <br><br>  Selama debugging, nyaman untuk melihat aturan apa yang berfungsi.  Setiap aturan memiliki penghitung paket yang diproses. <br><br><pre> <code class="plaintext hljs">#  ,      watch iptables -nvL FORWARD #     iptables -Z FORWARD</code> </pre><br>  <b>Secara otomatis</b> <br><br>  Server openvpn memiliki kemampuan untuk mengeksekusi skrip untuk tindakan tertentu.  Khususnya, saat menghubungkan dan memutuskan klien.  Skrip dapat ditulis pada apa saja jika hanya itu yang dapat dieksekusi.  Di dalam skrip, variabel lingkungan meneruskan segala macam parameter ke koneksi saat ini.  Kami tertarik pada variabel: <br><br><ul><li>  <code>common_name</code> (nama pemilik sertifikat; apa yang mendorong ke bidang nama umum saat membuat sertifikat) </li><li>  <code>ifconfig_pool_remote_ip</code> (alamat ip klien pada tun0) </li><li>  <code>script_type</code> (peristiwa mana yang terjadi - sambungkan atau putuskan). </li></ul><br>  Anda membutuhkan hak akses root untuk mengelola iptables.  Openvpn setelah menghubungkan hak reset ke siapa pun dan menjalankan skrip darinya.  Sangat buruk untuk tidak mengizinkan siapa pun untuk melakukan sesuatu dari bawah sudo, dan lebih baik tidak menggunakan tanda bintang dalam aturan, tapi entah bagaimana Anda perlu mengizinkan pengguna untuk mengontrol iptables. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># /etc/sudoers.d/50_openvpn # #    nobody ALL = NOPASSWD: /sbin/iptables -A FORWARD* #     nobody ALL = NOPASSWD: /sbin/iptables -L FORWARD* #    nobody ALL = NOPASSWD: /sbin/iptables -D FORWARD*</span></span></code> </pre><br>  Di konfigurasi server, Anda perlu menambahkan izin untuk mengeksekusi file pihak ketiga dan mengaktifkan dua kait yang bertanggung jawab untuk menghubungkan dan memutuskan sambungan pengguna. <br><br><pre> <code class="bash hljs">script-security 2 client-connect /etc/openvpn/bin/hosts.rb client-disconnect /etc/openvpn/bin/hosts.rb</code> </pre><br>  Script itu sendiri, yang membaca konfigurasi dan menerapkan aturan untuk iptables.  Skrip bekerja dengan prinsip yang sama seperti yang dijelaskan di bagian sebelumnya. <br><br><div class="spoiler">  <b class="spoiler_title">/openvpn/bin/hosts.rb</b> <div class="spoiler_text"><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/ruby # -*- coding: utf-8 -*- require 'pp' def log(string) puts 'hosts.rb: ' + string end def parse_config_file(name) config_path = "hosts/#{name}" unless File.exist?(config_path) puts "There is no specific configuration for #{name}." p name exit 0 end config_source = IO.read(config_path).split("\n") config = config_source.inject([]) do |result,line| ip, port, protocol = line.split(/\s+/) result &lt;&lt; { ip: ip, port: port, protocol: protocol || 'tcp' } end end def get_config(name) user_config = parse_config_file(name) if user_config everybody_config = parse_config_file('everybody') end everybody_config + user_config end def apply_rule(rule) command = "sudo iptables #{rule}" log(command) system(command) end def remove_rule(number) command = "sudo iptables -D FORWARD #{number}" log(command) system(command) end def allow_target(source_ip, options) #         . apply_rule("-A FORWARD -s #{source_ip} -i tun0 -d #{options[:ip]} -p #{options[:protocol]} --dport #{options[:port]} -j ACCEPT") #       apply_rule("-A FORWARD -s #{source_ip} -i tun0 -d #{options[:ip]} -p icmp --icmp-type echo-request -j ACCEPT") end def clear_targets(source_ip) #      FORWARD,  source_ip. rules_exist = true while rules_exist table = `sudo iptables -L FORWARD --line-number`.split("\n") the_line = table.find do |line| fields = line.split(/\s+/) ip = fields[4] ip == source_ip end if the_line number = the_line.split(/\s+/)[0] remove_rule(number) else rules_exist = false end end end ################################################################################ script_type = ENV['script_type'] log(script_type) name = ENV['common_name'] source_ip = ENV['ifconfig_pool_remote_ip'] case script_type when 'client-connect' config = get_config(name) config.each{|target| allow_target(source_ip, target)} when 'client-disconnect' clear_targets(source_ip) else puts "Unknown script type #{script_type}." end</span></span></code> </pre></div></div><br>  Aturan disimpan dalam file yang sesuai dengan nama umum sertifikat di folder <code>/etc/openvpn/hosts</code> .  Mereka menentukan dengan tepat alamat IP mana yang tersedia untuk klien tertentu.  Separator - jumlah ruang yang berubah-ubah.  Alamat IP, port, dan protokol (tcp atau udp) ditulis melalui pemisah. <br><br><pre> <code class="bash hljs">10.0.0.24 53 udp 10.0.0.25 53 udp 10.0.2.3 443 tcp</code> </pre><br>  Sebagai hasilnya, struktur berikut ini akan <code>/etc/openvpn</code> di folder <code>/etc/openvpn</code> <br><br>  ├── bin <br>  │ └── hosts.rb <br>  ├── tuan rumah <br>  │ ├── pengguna1 <br>  │ ├── pengguna2 <br>  │ └── semuanya <br>  ├── server.conf <br>  └── ... <br><br>  <code>User1</code> dan <code>user2</code> adalah file dalam format di atas.  Mereka menggambarkan host mana yang pengguna dengan nama umum terkait memiliki akses. <br><br>  Ada file <code>everybody</code> lain tambahan, ini berisi aturan yang berlaku untuk semua klien, asalkan ada file konfigurasi terpisah untuk klien ini.  Yaitu, jika pengguna memiliki daftar host di mana ia dapat pergi, maka daftar ini dan host yang terdaftar di <code>everybody</code> diterapkan.  Jika tidak, maka <code>everybody</code> tidak berlaku.  Misalnya, server DNS nyaman ditempatkan di file ini. <br><br>  <b>Penebangan</b> <br><br>  Skrip instalasi hanya menyertakan logging koneksi saat ini (parameter <code>status)</code> .  Agar log reguler muncul, Anda perlu menambahkan baris ke konfigurasi server ( <code>/etc/openvpn/server.conf</code> ): <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">log</span></span>-append /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/openvpn.log</code> </pre> <br><br>  <b>LDAP</b> <br><br>  Ada plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">openvpn-auth-ldap</a> yang memungkinkan Anda untuk mengautentikasi pengguna lagi melalui LDAP. <br><br>  Paket pengiriman: <br><br><pre> <code class="plaintext hljs">sudo yum install openvpn-auth-ldap</code> </pre> <br>  Tambahkan ke server.conf: <br><br><pre> <code class="plaintext hljs">plugin /usr/lib64/openvpn/plugin/lib/openvpn-auth-ldap.so "/etc/openvpn/ldap.conf"</code> </pre> <br>  Buat config untuk ldap di <code>/etc/openvpn/ldap.conf</code> : <br><pre> <code class="plaintext hljs">&lt;LDAP&gt; URL ldaps://{LDAP_DOMAIN_HERE} Timeout 15 TLSEnable no FollowReferrals yes BindDN "BIND_DN_HERE" Password "BIND_PASSWORD_HERE" &lt;/LDAP&gt; &lt;Authorization&gt; BaseDN "{BASE_DN_HERE}" SearchFilter "(&amp;(sAMAccountName=%u)(objectClass=organizationalPerson)(objectCategory=person)(!(userAccountControl:1.2.840.113556.1.4.803:=2)))" RequireGroup false &lt;/Authorization&gt;</code> </pre><br>  Tambahkan baris ke konfigurasi ovpn khusus: <br><br><pre> <code class="plaintext hljs">auth-user-pass</code> </pre> <br>  Dengan demikian, pengguna pertama-tama akan diminta nama pengguna dan kata sandi dari domain, kemudian PIN dari token.  Jika salah satu dari langkah-langkah ini gagal, koneksi tidak akan dibuat. <br><br>  Deskripsi opsi untuk ldap.conf <a href="">ada di repositori plugin</a> .  Ini mendukung otentikasi berdasarkan keanggotaan grup, tetapi saya belum mengujinya. <br><br><h4>  Kecepatan </h4><br>  Peningkatan kecepatan terbesar memberikan masuknya mode udp.  Ini disarankan di semua manual.  Intinya adalah tidak masuk akal untuk memulai koneksi klien tcp di saluran tcp.  Satu tcp di klien sudah cukup untuk membuat pengiriman paket yang benar.  Jika paket hilang di saluran udp, koneksi tcp klien akan mengontrol penyesuaian pengiriman. <br><br>  Kecepatan akan meningkat setidaknya karena tidak perlu menunggu konfirmasi pengiriman setiap paket di saluran.  Ada masalah kedua dengan tcp - satu paket klien tcp kemungkinan besar tidak masuk ke dalam satu paket saluran vpn.  MTU adalah sama, tetapi header perlu ditambahkan ke paket klien.  Akibatnya, Anda harus mengirim dua paket dalam saluran vpn per paket pengguna. <br><br>  TCP masuk akal untuk digunakan ketika tidak mungkin dengan cara lain.  Misalnya, ketika vpn bekerja melalui saluran ssh. <br><br><h4>  Contoh konfigurasi server lengkap </h4><br><div class="spoiler">  <b class="spoiler_title">contoh-server.conf</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">port 1194 proto tcp dev tun sndbuf 0 rcvbuf 0 ca ca.crt cert server.crt key server.key dh dh.pem tls-auth ta.key 0 topology subnet server 10.8.0.0 255.255.255.0 ifconfig-pool-persist ipp.txt push "redirect-gateway def1 bypass-dhcp" push "dhcp-option DNS 10.0.0.25" push "dhcp-option DNS 10.0.0.24" keepalive 10 120 cipher AES-256-CBC comp-lzo user nobody group nobody persist-key persist-tun status openvpn-status.log verb 3 crl-verify crl.pem log-append /var/log/openvpn.log script-security 2 client-connect /etc/openvpn/bin/hosts.rb client-disconnect /etc/openvpn/bin/hosts.rb</code> </pre><br></div></div><br><h3>  Pengaturan token </h3><br><h4>  Perpustakaan PKCS # 11 </h4><br>  Untuk bekerja dengan token, Anda memerlukan perpustakaan khusus.  Pustaka diperlukan untuk membuat pasangan kunci, dan untuk koneksi yang sebenarnya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unduh untuk semua platform melalui tautan</a> . <br><br>  Di mana pun librtpkcs11ecp.so ditemukan nanti - ini adalah perpustakaan yang perlu diunduh dan diletakkan di suatu tempat di tempat yang nyaman. <br><br><h4>  Membuat sertifikat di token </h4><br>  Buat pasangan kunci pada token.  Parameter id di sini adalah nomor seri slot pada token tempat pasangan kunci cocok. <br><br><pre> <code class="plaintext hljs">pkcs11-tool --module /usr/lib64/librtpkcs11ecp.so --keypairgen --key-type rsa:2048 -l --id 01</code> </pre><br>  Buat permintaan sertifikat untuk kunci publik.  Dalam proses membuat permintaan sertifikat, masa berlaku sertifikat dan nama umum ditetapkan, yang digunakan untuk memfilter alamat ip yang tersedia dalam jaringan.  Nama umum harus cocok dengan login di ActiveDirectory sehingga tidak ada kebingungan. <br><br><pre> <code class="plaintext hljs">openssl openssl&gt; engine -t dynamic -pre SO_PATH:/usr/lib64/openssl/engines/pkcs11.so -pre ID:pkcs11 -pre LIST_ADD:1 -pre LOAD -pre MODULE_PATH:/usr/lib64/librtpkcs11ecp.so openssl&gt; req -engine pkcs11 -new -key slot_0-id_01 -keyform engine -out /home/john/good.req</code> </pre><br>  Permintaan yang diterima harus dipindahkan ke <code>/etc/openvpn/easy-rsa/pki/reqs/</code> .  Ekstensi file harus <code>req</code> . <br>  Mengonversi permintaan ke sertifikat: <br><br><pre> <code class="plaintext hljs">cd /etc/openvpn/easy-rsa/ ./easyrsa sign-req client good</code> </pre><br>  Setelah itu, sertifikat dengan nama yang sama tetapi dengan ekstensi <code>crt</code> akan muncul di folder <code>/etc/openvpn/easy-rsa/pki/issued/</code> . <br><br>  Sebelum merekam, sertifikat harus dikonversi ke DER: <br><br><pre> <code class="plaintext hljs">openssl x509 -in /home/user/user-cert.pem -out /home/user/user-cert.crt -outform DER</code> </pre><br>  Menulis sertifikat untuk token: <br><br><pre> <code class="plaintext hljs">pkcs11-tool --module /usr/lib/librtpkcs11ecp.so -l -y cert -w /home/user/user-cert.crt --id 45 --label TEST</code> </pre> <br>  Ini ditulis berdasarkan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Menggunakan Rutoken EDS dengan OpenSSL (RSA)"</a> . <br><br><h4>  Menggunakan Token untuk Otentikasi </h4><br>  Temukan id sertifikat yang akan disajikan ke server: <br><br><pre> <code class="plaintext hljs">$ openvpn --show-pkcs11-ids /usr/lib64/librtpkcs11ecp.so The following objects are available for use. Each object shown below may be used as parameter to --pkcs11-id option please remember to use single quote mark. Certificate DN: /CN=User1 Serial: 490B82C4000000000075 Serialized id: aaaa/bbb/41545F5349474E415455524581D2A1A1B23C4AA4CB17FAF7A4600</code> </pre><br>  Kami tertarik pada serialized id di sini. <br><br>  Opsi yang harus dimasukkan dalam konfigurasi ovpn agar token mengambil: <br><br><pre> <code class="plaintext hljs">pkcs11-providers /usr/lib64/librtpkcs11ecp.so pkcs11-id 'aaaa/bbb/41545F5349474E415455524581D2A1A1B23C4AA4CB17FAF7A4600'</code> </pre> <br>  Opsi <code>pkcs11-id</code> <b>harus dilampirkan dalam tanda kutip tunggal.</b> <br><br>  Manual ini masuk akal di semua platform.  Anda perlu menentukan jalur ke perpustakaan dan id sertifikat pada token.  Perpustakaan dapat disebut sedikit berbeda, menjadi <code>.dll</code> , bukan <code>.so</code> , tetapi artinya sama. <br><br>  Dalam hal ini, Anda perlu menghapus bagian <code>cert</code> dan <code>key</code> dari file ovpn, karena sertifikat dan kunci pribadi akan diambil dari token. <br><br>  Konfigurasi klien sepenuhnya (untuk windows) terlihat seperti ini: <br><br><div class="spoiler">  <b class="spoiler_title">client.ovpn</b> <div class="spoiler_text"> <code>client <br> dev tun <br> proto tcp <br> sndbuf 0 <br> rcvbuf 0 <br> remote 78.47.37.247 22222 <br> resolv-retry infinite <br> nobind <br> persist-key <br> persist-tun <br> remote-cert-tls server <br> cipher AES-256-CBC <br> comp-lzo <br> setenv opt block-outside-dns <br> key-direction 1 <br> verb 3 <br> <br> pkcs11-providers "c://Windows//System32//rtPKCS11ECP.dll" <br> pkcs11-id 'Aktiv\x20Co\x2E/Rutoken\x20ECP/342b871d/Rutoken/01' <br> <br> -----BEGIN CERTIFICATE----- <br> {CERT_HERE} <br> -----END CERTIFICATE----- <br> <br> <br> &lt;tls-auth&gt; <br> # <br> # 2048 bit OpenVPN static key <br> # <br> -----BEGIN OpenVPN Static key V1----- <br> {KEY_HERE} <br> -----END OpenVPN Static key V1----- <br> &lt;/tls-auth&gt;</code> <br> </div></div><br>  Ditulis berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Bagaimana cara menambahkan otentikasi dua faktor ke konfigurasi OpenVPN menggunakan kartu pintar sisi klien</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a> <br><br><h3>  Pengaturan pelanggan </h3><br><h4>  Linux </h4><br>  Openvpn memiliki bug yang mencegah pengguna memasukkan kode PIN dari token jika paket dibangun dengan dukungan systemd.  Karena systemd telah ada di mana-mana akhir-akhir ini, semua paket yang sudah tersedia di repositori dikompilasi dengan dukungannya.  Klien di Linux perlu mengumpulkan paket sendiri.  Berikut adalah contoh konfigurasi yang berfungsi untuk saya di Arch Linux: <br><br><pre> <code class="plaintext hljs">./configure \ --prefix=/usr \ --sbindir=/usr/bin \ --enable-iproute2 \ --enable-pkcs11 \ --enable-plugins \ --enable-x509-alt-username</code> </pre><br>  Anda dapat memverifikasi bahwa openvpn dibangun dengan atau tanpa systemd menggunakan perintah berikut: <br><br><pre> <code class="plaintext hljs">openvpn --version | grep --color enable_systemd</code> </pre><br><h4>  Mas os </h4><br>  Di bawah Mac OS, hanya ada satu klien gratis - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tunnelblink</a> . <br><br>  Dia tidak tahu bagaimana memasukkan kode pin dari token dari gui.  Bug tersebut dijelaskan misalnya di sini - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://groups.google.com/forum/#!topic/tunnelblick-discuss/f_Rp_2nV-x8</a> Dicacah dengan meluncurkan openvpn dari konsol.  Ini tidak mengherankan, mengingat bahwa klien resmi untuk windows juga tidak mengetahui hal ini. <br><br>  Juga di bawah Mac OS (tidak seperti windows) skrip tambahan diperlukan untuk mengkonfigurasi jaringan.  Jika Anda hanya menjalankan openvpn dari konsol, maka DNS tidak akan berfungsi (mungkin sesuatu yang lain, hanya DNS yang akan muncul). <br><br>  TunnelBlick memiliki skrip konfigurasi jaringan ini, mereka hanya perlu dipanggil saat membuat dan memutuskan koneksi.  Apa yang perlu Anda tambahkan ke konfigurasi ovpn: <br><br><pre> <code class="bash hljs">script-security 2 up <span class="hljs-string"><span class="hljs-string">"/Applications/Tunnelblick.app/Contents/Resources/client.up.tunnelblick.sh -9 -d -f -m -w -ptADGNWradsgnw"</span></span> down <span class="hljs-string"><span class="hljs-string">"/Applications/Tunnelblick.app/Contents/Resources/client.down.tunnelblick.sh -9 -d -f -m -w -ptADGNWradsgnw"</span></span></code> </pre> <br>  Contoh skrip untuk meluncurkan koneksi openvpn, yang dapat diletakkan di desktop dan disodok dengan mouse: <br><br><pre> <code class="plaintext hljs">#!/bin/bash tunnelblick=/Applications/Tunnelblick.app/Contents/Resources/openvpn/openvpn-2.4.2-openssl-1.0.2k sudo $tunnelblick/openvpn --config $tunnelblick/user.ovpn</code> </pre><br><h4>  Windows </h4><br>  Di bawah windows, semuanya tampak berfungsi.  Klien resmi tidak tahu bagaimana memasukkan kode pin dari token, ia berhasil membuka openvpn dengan tangan dari konsol. <br><br>  Yang paling penting adalah melakukan semuanya dari bawah administrator.  Jalankan penginstal klien sebagai administrator.  Luncurkan terminal di mana openvpn memulai juga dengan hak admin, jika tidak, ia tidak akan dapat mengontrol antarmuka jaringan. <br><br>  Di bawah Windows, jalur ke perpustakaan untuk bekerja dengan token harus direkam melalui garis miring ganda.  Ini berlaku untuk konfigurasi ovpn dan <code>--show-pkcs11-ids</code> pada baris perintah. <br><br><pre> <code class="bash hljs">pkcs11-providers <span class="hljs-string"><span class="hljs-string">"c://Windows//System32//rtPKCS11ECP.dll"</span></span> pkcs11-id <span class="hljs-string"><span class="hljs-string">'Aktiv\x20Co\x2E/Rutoken\x20ECP/342b871d/Rutoken/01'</span></span></code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433250/">https://habr.com/ru/post/id433250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433234/index.html">Dibutuhkan pengasuh yang sempurna; pastikan untuk menjalani AI scan untuk menilai rasa hormat dan sopan santun</a></li>
<li><a href="../id433236/index.html">Kepala Google percaya bahwa ketakutan akan AI “sepenuhnya dibenarkan”</a></li>
<li><a href="../id433242/index.html">Topeng beracun</a></li>
<li><a href="../id433246/index.html">Kerangka kerja: analisis sistem DLT</a></li>
<li><a href="../id433248/index.html">Parsing Memory Forensics dengan OtterCTF dan Memperkenalkan Kerangka Volatilitas</a></li>
<li><a href="../id433252/index.html">Manekin pada helikopter hibrida turbojet-listrik</a></li>
<li><a href="../id433254/index.html">Kami hanya melawan kematian, dan Anda? Atau perusahaan yang mengembangkan obat luar biasa</a></li>
<li><a href="../id433256/index.html">Pengembangan UI dengan Flutter</a></li>
<li><a href="../id433258/index.html">Anda dapat membeli komponen elektronik di Eropa bahkan saat liburan. Pengalaman berbelanja di Mouser di Bulgaria</a></li>
<li><a href="../id433260/index.html">Bacaan akhir pekan: bahan tentang bekerja dengan PD, ulasan tentang zat besi di pusat data dan "dapur" dari penyedia IaaS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>