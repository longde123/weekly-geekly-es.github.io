<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💜 🥢 👩🏿‍💻 Wir schreiben unter FPGA ohne HDL. Vergleich von Entwicklungswerkzeugen auf hoher Ebene 👨🏿‍🤝‍👨🏼 🎦 🧜🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In jüngster Zeit haben FPGA-Hersteller und Drittunternehmen aktiv Entwicklungsmethoden für FPGAs entwickelt, die sich von herkömmlichen Ansätzen unter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben unter FPGA ohne HDL. Vergleich von Entwicklungswerkzeugen auf hoher Ebene</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455668/">  In jüngster Zeit haben FPGA-Hersteller und Drittunternehmen aktiv Entwicklungsmethoden für FPGAs entwickelt, die sich von herkömmlichen Ansätzen unter Verwendung von Entwicklungswerkzeugen auf hoher Ebene unterscheiden. <br><br>  Als FPGA-Entwickler verwende ich die Hardwarebeschreibungssprache ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HDL</a> ) von Verilog als Hauptwerkzeug, aber die wachsende Beliebtheit neuer Methoden hat mein großes Interesse geweckt. Deshalb habe ich mich in diesem Artikel entschlossen, herauszufinden, was passiert. <br><br>  Dieser Artikel ist keine Anleitung oder Gebrauchsanweisung. Dies ist mein Rückblick und meine Schlussfolgerungen darüber, was verschiedene Entwicklungswerkzeuge auf hoher Ebene einem FPGA-Entwickler oder Programmierer bieten können, der in die Welt des FPGA eintauchen möchte.  Um die meiner Meinung nach interessantesten Entwicklungswerkzeuge zu vergleichen, habe ich mehrere Tests geschrieben und die Ergebnisse analysiert.  Unter dem Schnitt - was kam daraus. <br><a name="habracut"></a><br><h2>  Warum benötigen Sie hochwertige Entwicklungswerkzeuge für FPGA? </h2><br><ul><li>  Beschleunigen Sie die Projektentwicklung <br>  - aufgrund der Wiederverwendung von Code, der bereits in Hochsprachen geschrieben wurde; <br>  - durch die Nutzung aller Vorteile von Hochsprachen beim Schreiben von Code von Grund auf neu; <br>  - durch Reduzierung der Kompilierungszeit und der Codeüberprüfung. <br></li><li>  Möglichkeit, universellen Code zu erstellen, der für jede FPGA-Familie geeignet ist. </li><li>  Reduzieren Sie beispielsweise den Entwicklungsschwellenwert für FPGAs, indem Sie die Konzepte der „Taktfrequenz“ und anderer Entitäten auf niedriger Ebene vermeiden.  Möglichkeit, Code für FPGA an einen Entwickler zu schreiben, der mit HDL nicht vertraut ist. </li></ul><br><h2>  Woher kommen die hochrangigen Entwicklungswerkzeuge? </h2><br>  Jetzt sind viele von der Idee einer hochrangigen Entwicklung angezogen.  Sowohl Enthusiasten wie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quokka</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Python-Codegenerator</a> als auch Unternehmen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mathworks</a> und die FPGA-Hersteller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Xilinx</a> sind daran beteiligt. <br><br>  Jeder nutzt seine Methoden und Werkzeuge, um sein Ziel zu erreichen.  Enthusiasten im Kampf um eine perfekte und schöne Welt verwenden ihre bevorzugten Entwicklungssprachen wie Python oder C #.  Unternehmen, die versuchen, den Kunden zufrieden zu stellen, bieten ihre eigenen an oder passen vorhandene Tools an.  Mathworks bietet ein eigenes HDL-Codierertool zum Generieren von HDL-Code aus M-Skripten und Simulink-Modellen an, während Intel und Xilinx Compiler für gängiges C / C ++ anbieten. <br><br>  Derzeit haben Unternehmen mit erheblichen finanziellen und personellen Ressourcen größere Erfolge erzielt, während Enthusiasten etwas zurückbleiben.  Dieser Artikel befasst sich mit dem Produkt HDL-Codierer von Mathworks und HLS Compiler von Intel. <br><br><div class="spoiler">  <b class="spoiler_title">Was ist mit Xilinx?</b> <div class="spoiler_text">  In diesem Artikel werde ich HIL von Xilinx aufgrund der unterschiedlichen Architekturen und CAD-Systeme von Intel und Xilinx nicht berücksichtigen, was einen eindeutigen Vergleich der Ergebnisse unmöglich macht.  Ich möchte jedoch darauf hinweisen, dass Xilinx HLS wie Intel HLS einen C / C ++ - Compiler bereitstellt und konzeptionell ähnlich ist. <br></div></div><br>  Beginnen wir mit dem Vergleich des HDL-Codierers von Mathworks und Intel HLS Compiler, nachdem mehrere Probleme mit unterschiedlichen Ansätzen gelöst wurden. <br><br><h2>  Vergleich von Entwicklungswerkzeugen auf hoher Ebene </h2><br><h3>  Testen Sie einen.  "Zwei Multiplikatoren und ein Addierer" </h3><br>  Die Lösung dieses Problems hat keinen praktischen Wert, eignet sich aber gut als erster Test.  Die Funktion verwendet 4 Parameter, multipliziert den ersten mit dem zweiten, den dritten mit dem vierten und addiert die Ergebnisse der Multiplikation.  Nichts kompliziertes, aber mal sehen, wie unsere Probanden damit umgehen. <br><br><h4>  HDL-Codierer von Mathworks </h4><br>  Um dieses Problem zu lösen, sieht das M-Skript wie folgt aus: <br><br><pre><code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[out]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TwoMultAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a,b,c,d)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a*b)</span></span></span><span class="hljs-function">+</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c*d)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Mal sehen, was Mathworks uns bietet, um Code in HDL zu konvertieren. <br><br>  Ich werde die Arbeit mit HDL-Codierern nicht im Detail betrachten, sondern mich nur auf die Einstellungen konzentrieren, die ich in Zukunft ändern werde, um unterschiedliche Ergebnisse in FPGA zu erzielen, und deren Änderungen von einem MATLAB-Programmierer berücksichtigt werden müssen, der seinen Code in FPGA ausführen muss. <br><br>  Als erstes müssen Sie also den Typ und den Bereich der Eingabewerte festlegen.  Es gibt kein bekanntes char, int, float, double im FPGA.  Die Bittiefe der Zahl kann beliebig sein. Es ist logisch, sie basierend auf dem Bereich der Eingabewerte auszuwählen, die Sie verwenden möchten. <br><br><img src="https://habrastorage.org/webt/yi/vt/rm/yivtrmsrseix9d6-r5ktf7q4i98.png" alt="Bild"><br>  <i>Abbildung 1</i> <br><br>  MATLAB überprüft die Variablentypen und ihre Werte und wählt die richtigen Bitgrößen für Busse und Register aus, was sehr praktisch ist.  Wenn es keine Probleme mit der Bittiefe und der Eingabe gibt, können Sie mit den folgenden Punkten fortfahren. <br><br> <a href=""><img src="https://habrastorage.org/webt/hy/bw/zv/hybwzvt-w0xzsta5gkf-0oapcrq.png" alt="Bild"></a> <br>  <i>Abbildung 2</i> <br><br>  In der HDL-Codegenerierung gibt es mehrere Registerkarten, auf denen Sie die Sprache auswählen können, in die konvertiert werden soll (Verilog oder VHDL).  Codestil  Namen von Signalen.  Die meiner Meinung nach interessanteste Registerkarte ist die Optimierung, und ich werde damit experimentieren. Lassen Sie uns jedoch vorerst alle Standardeinstellungen belassen und sehen, was mit dem HDL-Codierer "out of the box" passiert. <br><br>  Drücken Sie die Run-Taste und erhalten Sie den folgenden Code: <br><br><pre> <code class="plaintext hljs">`timescale 1 ns / 1 ns module TwoMultAdd_fixpt (a, b, c, d, out); input [7:0] a; // ufix8 input [7:0] b; // ufix8 input [7:0] c; // ufix8 input [7:0] d; // ufix8 output [16:0] out; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp; // ufix16 wire [16:0] TwoMultAdd_fixpt_2; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp_1; // ufix16 wire [16:0] TwoMultAdd_fixpt_3; // ufix17 //HDL code generation from MATLAB function: TwoMultAdd_fixpt //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% // % // Generated by MATLAB 9.2 and Fixed-Point Designer 5.4 % // % //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% assign TwoMultAdd_fixpt_mul_temp = a * b; assign TwoMultAdd_fixpt_2 = {1'b0, TwoMultAdd_fixpt_mul_temp}; assign TwoMultAdd_fixpt_mul_temp_1 = c * d; assign TwoMultAdd_fixpt_3 = {1'b0, TwoMultAdd_fixpt_mul_temp_1}; assign out = TwoMultAdd_fixpt_2 + TwoMultAdd_fixpt_3; endmodule // TwoMultAdd_fixpt</code> </pre><br>  Der Code sieht gut aus.  MATLAB versteht, dass das Schreiben des gesamten Ausdrucks in einer einzelnen Zeile in Verilog eine schlechte Praxis ist.  Erstellt separate <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Drähte</a> für den Multiplikator und den Addierer. Es gibt nichts zu beanstanden. <br><br>  Es ist alarmierend, dass die Beschreibung der Register fehlt.  Dies geschah, weil wir den HDL-Codierer nicht danach gefragt haben und alle Felder in den Einstellungen auf ihren Standardwerten belassen haben. <br><br>  Hier ist, was Quartus aus einem solchen Code synthetisiert. <br><br><img src="https://habrastorage.org/webt/zf/af/ja/zfafjaezynolikraaha86gadp-e.png"><br>  <i>Abbildung 3</i> <br><br>  Keine Probleme, alles war wie geplant. <br><br>  In FPGA implementieren wir synchrone Schaltungen, und trotzdem würde ich gerne die Register sehen.  Der HDL-Codierer bietet einen Mechanismus zum Platzieren von Registern, aber wo sie platziert werden sollen, liegt beim Entwickler.  Wir können die Register am Eingang der Multiplikatoren, am Ausgang der Multiplikatoren vor dem Addierer oder am Ausgang des Addierers platzieren. <br><br>  Um die Beispiele zusammenzufassen, habe ich mich für die FPGA Cyclone V-Familie entschieden, bei der spezielle DSP-Blöcke mit integrierten Addierern und Multiplikatoren zur Implementierung von arithmetischen Operationen verwendet werden.  Der DSP-Block sieht folgendermaßen aus: <br><br> <a href=""><img src="https://habrastorage.org/webt/zf/5s/bt/zf5sbts5ke1t_pw3dsmrc4uhtrc.png"></a> <br>  <i>Abbildung 4</i> <br><br>  Der DSP-Block hat Eingangs- und Ausgangsregister.  Es ist nicht erforderlich, die Ergebnisse der Multiplikation vor dem Hinzufügen im Register abzufangen. Dies verstößt nur gegen die Architektur (in bestimmten Fällen ist diese Option möglich und wird sogar benötigt).  Es ist Sache des Entwicklers, anhand der Latenzanforderungen und der erforderlichen maximalen Frequenz zu entscheiden, wie mit dem Eingangs- und Ausgangsregister umgegangen werden soll.  Ich habe mich entschieden, nur das Ausgangsregister zu verwenden.  Damit dieses Register in dem vom HDL-Codierer generierten Code beschrieben werden kann, müssen Sie auf der Registerkarte Optionen im HDL-Codierer das Kontrollkästchen Registerausgabe aktivieren und die Konvertierung neu starten. <br><br>  Es stellt sich folgender Code heraus: <br><br><pre> <code class="plaintext hljs">`timescale 1 ns / 1 ns module TwoMultAdd_fixpt (clk, reset, clke_ena_i, a, b, c, d, clke_ena_o, out); input clk; input reset; input clke_ena_i; input [7:0] a; // ufix8 input [7:0] b; // ufix8 input [7:0] c; // ufix8 input [7:0] d; // ufix8 output clke_ena_o; output [16:0] out; // ufix17 wire enb; wire [16:0] out_1; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp; // ufix16 wire [16:0] TwoMultAdd_fixpt_2; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp_1; // ufix16 wire [16:0] TwoMultAdd_fixpt_3; // ufix17 reg [16:0] out_2; // ufix17 //HDL code generation from MATLAB function: TwoMultAdd_fixpt //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% // % // Generated by MATLAB 9.2 and Fixed-Point Designer 5.4 % // % //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% assign TwoMultAdd_fixpt_mul_temp = a * b; assign TwoMultAdd_fixpt_2 = {1'b0, TwoMultAdd_fixpt_mul_temp}; assign TwoMultAdd_fixpt_mul_temp_1 = c * d; assign TwoMultAdd_fixpt_3 = {1'b0, TwoMultAdd_fixpt_mul_temp_1}; assign out_1 = TwoMultAdd_fixpt_2 + TwoMultAdd_fixpt_3; assign enb = clke_ena_i; always @(posedge clk or posedge reset) begin : out_reg_process if (reset == 1'b1) begin out_2 &lt;= 17'b00000000000000000; end else begin if (enb) begin out_2 &lt;= out_1; end end end assign clke_ena_o = clke_ena_i; assign out = out_2; endmodule // TwoMultAdd_fixpt</code> </pre><br>  Wie Sie sehen können, weist der Code grundlegende Unterschiede zur vorherigen Version auf.  Es erschien ein Always-Block, der eine Beschreibung des Registers darstellt (genau das, was wir wollten).  Für den Always-Block-Betrieb erschienen auch die Eingänge des Clk-Moduls (Taktfrequenz) und des Reset (Reset).  Es ist ersichtlich, dass der Ausgang des Addierers in dem in immer beschriebenen Trigger zwischengespeichert ist.  Es gibt auch ein paar Ena-Erlaubnis-Signale, aber sie sind für uns nicht sehr interessant. <br><br>  Schauen wir uns das Diagramm an, das Quartus jetzt synthetisiert. <br><br><img src="https://habrastorage.org/webt/ro/we/px/rowepxxw-fun6ey4x2tpw4cfjyg.png"><br>  <i>Abbildung 5</i> <br><br>  Auch hier sind die Ergebnisse gut und werden erwartet. <br><br>  Die folgende Tabelle zeigt die Tabelle der verwendeten Ressourcen - wir berücksichtigen dies. <br><br><img src="https://habrastorage.org/webt/_z/wy/lk/_zwylksweoc_mhrps-rqhwankbe.png"><br>  <i>Abbildung 6</i> <br><br>  Für diese erste Quest erhält Mathworks eine Gutschrift.  Alles ist nicht kompliziert, vorhersehbar und mit dem gewünschten Ergebnis. <br><br>  Ich habe ein einfaches Beispiel ausführlich beschrieben, ein Diagramm eines DSP-Blocks bereitgestellt und die Möglichkeiten beschrieben, die Registerverwendungseinstellungen in HDL-Codierern außer den „Standardeinstellungen“ zu verwenden.  Dies geschieht aus einem bestimmten Grund.  An dieser Stelle möchte ich betonen, dass auch in einem so einfachen Beispiel bei Verwendung eines HDL-Codierers Kenntnisse der FPGA-Architektur und der Grundlagen digitaler Schaltkreise erforderlich sind und die Einstellungen bewusst geändert werden müssen. <br><br><h4>  Intel HLS Compiler </h4><br>  Versuchen wir, Code mit der gleichen Funktionalität zu kompilieren, die in C ++ geschrieben wurde, und sehen, was schließlich mit dem HLS-Compiler in FPGA synthetisiert wird. <br><br>  Also C ++ Code <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">component </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TwoMultAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a*b)+(c*d); }</code> </pre><br>  Ich habe Datentypen ausgewählt, um ein Überlaufen von Variablen zu vermeiden. <br><br>  Es gibt fortschrittliche Methoden zum Festlegen von Bittiefen. Unser Ziel ist es jedoch, die Fähigkeit zu testen, Funktionen, die im C / C ++ - Stil unter FPGA geschrieben wurden, ohne Änderungen zusammenzustellen. <br><br>  Da der HLS-Compiler ein natives Tool von Intel ist, sammeln wir den Code mit einem speziellen Compiler und überprüfen das Ergebnis sofort in Quartus. <br><br>  Schauen wir uns die Schaltung an, die Quartus synthetisiert. <br><br><img src="https://habrastorage.org/webt/ra/wy/bg/rawybgvk1yirtlaxi5yfmqjk6mi.png"><br>  <i>Abbildung 7</i> <br><br>  Der Compiler hat Register an der Ein- und Ausgabe erstellt, aber die Essenz ist im Wrapper-Modul verborgen.  Wir beginnen mit der Bereitstellung des Wrappers und ... sehen immer mehr verschachtelte Module. <br><br>  Die Struktur des Projekts sieht so aus. <br><br> <a href=""><img src="https://habrastorage.org/webt/x6/3x/pi/x63xpin-73wlqtuear-rhyhcpcy.png"></a> <br>  <i>Abbildung 8</i> <br><br>  Ein offensichtlicher Hinweis von Intel lautet: "Nehmen Sie es nicht in die Hand!".  Aber wir werden versuchen, vor allem die Funktionalität ist nicht kompliziert. <br><br>  In den Eingeweiden des Projektbaums | quartus_compile | TwoMultAdd: TwoMultAdd_inst | TwoMultAdd_internal: twomultadd_internal_inst | TwoMultAdd_fu <br>  nction_wrapper: TwoMultAdd_internal | TwoMultAdd_function: theTwoMultAdd_function | bb_TwoMultAdd_B1_start: <br>  thebb_TwoMultAdd_B1_start | bb_TwoMultAdd_B1_start_stall_region: thebb_TwoMultAdd_B1_start_stall_region | i <br>  _sfc_c1_wt_entry_twomultadd_c1_enter_twomultadd: thei_sfc_c1_wt_entry_twomultadd_c1_enter_twomultad <br>  d_aunroll_x | i_sfc_logic_c1_wt_entry_twomultadd_c1_enter_twomultadd13: thei_sfc_logic_c1_wt_entry_twom <br>  ultadd_c1_enter_twomultadd13_aunroll_x | Mult1 ist das Modul, nach dem Sie suchen. <br><br>  Wir können uns das Diagramm des gewünschten Moduls ansehen, das von Quartus synthetisiert wurde. <br><br> <a href=""><img src="https://habrastorage.org/webt/4m/e8/_c/4me8_cxojdb6zyvo0mkvc-i7a60.png"></a> <br>  <i>Abbildung 9</i> <br><br>  Welche Schlussfolgerungen können aus diesem Schema gezogen werden? <br><br>  Es ist offensichtlich, dass etwas passiert ist, das wir bei der Arbeit in MATLAB zu vermeiden versucht haben: Der Fall am Ausgang des Multiplikators wurde synthetisiert - das ist nicht sehr gut.  Aus dem DSP-Blockdiagramm (Abbildung 4) ist ersichtlich, dass sich an seinem Ausgang nur ein Register befindet, was bedeutet, dass jede Multiplikation in einem separaten Block durchgeführt werden muss. <br><br>  Die Tabelle der verwendeten Ressourcen zeigt, wozu dies führt. <br><br><img src="https://habrastorage.org/webt/es/eu/tj/eseutjlsyur_gibiank94suhhca.png"><br>  <i>Abbildung 10</i> <br><br>  Vergleichen Sie die Ergebnisse mit der HDL-Codierertabelle (Abbildung 6). <br><br>  Wenn Sie eine größere Anzahl von Registern verwenden, die Sie ertragen können, ist es sehr unangenehm, wertvolle DSP-Blöcke für solch einfache Funktionen auszugeben. <br><br>  Intel HLS bietet jedoch ein großes Plus im Vergleich zu HDL-Codierern.  Mit den Standardeinstellungen entwickelte der HLS-Compiler ein synchrones Design in FPGA, obwohl er mehr Ressourcen verbrauchte.  Eine solche Architektur ist möglich, es ist klar, dass Intel HLS so konfiguriert ist, dass maximale Leistung erzielt wird und keine Ressourcen gespart werden. <br><br>  Mal sehen, wie sich unsere Themen bei komplexeren Projekten verhalten. <br><br><h3>  Der zweite Test.  "Elementweise Multiplikation von Matrizen mit Summation des Ergebnisses" </h3><br>  Diese Funktion ist in der Bildverarbeitung weit verbreitet: der sogenannte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Matrixfilter“</a> .  Wir verkaufen es mit hochwertigen Werkzeugen. <br><br><h4>  HDL-Codierer von Mathwork </h4><br>  Die Arbeit beginnt sofort mit einer Einschränkung.  Der HDL-Codierer kann keine 2D-Matrixfunktionen als Eingänge akzeptieren.  Angesichts der Tatsache, dass MATLAB ein Werkzeug für die Arbeit mit Matrizen ist, ist dies ein schwerer Schlag für den gesamten geerbten Code, der zu einem ernsthaften Problem werden kann.  Wenn der Code von Grund auf neu geschrieben wurde, ist dies eine unangenehme Funktion, die berücksichtigt werden muss.  Sie müssen also alle Matrizen in einem Vektor bereitstellen und die Funktionen unter Berücksichtigung der Eingabevektoren implementieren. <br><br>  Der Code für die Funktion in MATLAB lautet wie folgt <br><br><pre> <code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[out]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mhls_conv2_manually</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target,kernel)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(kernel)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-function">.*</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mult)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  Der generierte HDL-Code erwies sich als sehr aufgebläht und enthält Hunderte von Zeilen, daher werde ich ihn hier nicht angeben.  Mal sehen, welches Schema Quartus aus diesem Code synthetisiert. <br><br> <a href=""><img src="https://habrastorage.org/webt/6d/3z/cd/6d3zcdcx0yzcqp-ht6fhz_mtx2i.png"></a> <br>  <i>Abbildung 11</i> <br><br>  Dieses Schema sieht nicht erfolgreich aus.  Formal funktioniert es, aber ich gehe davon aus, dass es mit einer sehr niedrigen Frequenz funktioniert und in realer Hardware kaum verwendet werden kann.  Jede Annahme muss jedoch überprüft werden.  Dazu platzieren wir die Register am Eingang und Ausgang dieser Schaltung und bewerten mit Hilfe des Timing Analyzer die reale Situation.  Um die Analyse durchzuführen, müssen Sie die gewünschte Betriebsfrequenz des Stromkreises angeben, damit Quartus weiß, worauf bei der Verkabelung zu achten ist, und im Fehlerfall Berichte über Verstöße liefert. <br><br>  Wir stellen die Frequenz auf 100 MHz ein. Mal sehen, was Quartus aus der vorgeschlagenen Schaltung herausdrücken kann. <br><br><img src="https://habrastorage.org/webt/r7/zv/xy/r7zvxygef12ws12mmyfwgxc0plk.png"><br>  <i>Abbildung 12</i> <br><br>  Es ist zu sehen, dass es sich ein wenig herausstellte: 33 MHz sehen leichtfertig aus.  Die Verzögerung in der Kette von Multiplikatoren und Addierern beträgt etwa 30 ns.  Um diesen „Engpass“ zu beseitigen, müssen Sie den Förderer verwenden: Register nach arithmetischen Operationen einfügen, wodurch der kritische Pfad verringert wird. <br><br>  Der HDL-Codierer bietet uns diese Möglichkeit.  Auf der Registerkarte Optionen können Sie Pipeline-Variablen festlegen.  Da der betreffende Code im MATLAB-Stil geschrieben ist, gibt es keine Möglichkeit zu Pipeline-Variablen (außer Multi- und Summ-Variablen), die nicht zu uns passen.  Es ist notwendig, die Register in die in unserem HDL-Code verborgenen Zwischenkreise einzufügen. <br><br>  Darüber hinaus könnte sich die Situation bei der Optimierung verschlechtern.  Zum Beispiel hindert uns nichts daran, Code zu schreiben <br><br><pre> <code class="matlab hljs">out = (sum(target.*kernel))/len;</code> </pre> <br>  es ist für MATLAB völlig ausreichend, beraubt uns jedoch völlig der Möglichkeit, HDL zu optimieren. <br><br>  Der nächste Ausweg besteht darin, den Code von Hand zu bearbeiten.  Dies ist ein sehr wichtiger Punkt, da wir uns weigern, das M-Skript zu erben und neu zu schreiben, und NICHT im MATLAB-Stil. <br><br>  Der neue Code lautet wie folgt <br><br><pre> <code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[out]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mhls_conv2_manually</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target,kernel)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(kernel)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-function">.*</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_1</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([1,(len/2)</span></span></span><span class="hljs-function">]); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_2</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([1,(len/4)</span></span></span><span class="hljs-function">]); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_3</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([1,(len/8)</span></span></span><span class="hljs-function">]); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">=0:1:</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len/2)</span></span></span><span class="hljs-function">-1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i+1)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mult(i*2+1)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i*2+2)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">=0:1:</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len/4)</span></span></span><span class="hljs-function">-1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i+1)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(summ_1(i*2+1)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i*2+2)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">=0:1:</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len/8)</span></span></span><span class="hljs-function">-1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i+1)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(summ_2(i*2+1)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i*2+2)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_3</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  In Quartus sammeln wir den vom HDL-Codierer generierten Code.  Es ist ersichtlich, dass die Anzahl der Schichten mit Grundelementen abgenommen hat und das Schema viel besser aussieht. <br><br> <a href=""><img src="https://habrastorage.org/webt/nd/7j/sr/nd7jsrm1hiursvzgredphpuvr7k.png"></a> <br>  <i>Abbildung 12</i> <br><br>  Bei korrekter Anordnung der Grundelemente wächst die Frequenz fast dreimal auf 88 MHz. <br><br><img src="https://habrastorage.org/webt/3z/4s/o3/3z4so3o-whcbn8jct8y-wtfsja4.png"><br>  <i>Abbildung 13</i> <br><br>  Jetzt der letzte Schliff: Geben Sie in den Optimierungseinstellungen summ_1, summ_2 und summ_3 als Elemente der Pipeline an.  Wir sammeln den resultierenden Code in Quartus.  Das Schema ändert sich wie folgt: <br><br> <a href=""><img src="https://habrastorage.org/webt/cu/kr/ua/cukruasropyfoifoib6er-fhck4.png"></a> <br>  <i>Abbildung 14</i> <br><br>  Die maximale Frequenz steigt wieder an und liegt nun bei ca. 195 MHz. <br><br><img src="https://habrastorage.org/webt/tl/gg/dd/tlggddvndao-cm0bavadgbuxx30.png"><br>  <i>Abbildung 15</i> <br><br>  Wie viele Ressourcen auf dem Chip benötigen ein solches Design?  Abbildung 16 zeigt die Tabelle der verwendeten Ressourcen für den beschriebenen Fall. <br><br><img src="https://habrastorage.org/webt/vl/ju/io/vljuioe1zmgnc-zr-nxvyv0lawu.png"><br>  <i>Abbildung 16</i> <br><br>  Welche Schlussfolgerungen können nach Betrachtung dieses Beispiels gezogen werden? <br><br>  Der Hauptnachteil des HDL-Codierers besteht darin, dass MATLAB-Code wahrscheinlich nicht in seiner reinen Form verwendet wird. <br>  Es gibt keine Unterstützung für Matrizen als Funktionseingaben, das Layout des Codes im MATLAB-Stil ist mittelmäßig. <br><br>  Die Hauptgefahr ist das Fehlen von Registern im Code, der ohne zusätzliche Einstellungen generiert wird.  Ohne diese Register ist die Verwendung eines solchen Codes in modernen Realitäten und Entwicklungen unerwünscht, selbst wenn formal funktionierender HDL-Code ohne Syntaxfehler empfangen wurde. <br><br>  Es ist ratsam, sofort Code zu schreiben, der für die Konvertierung in HDL geschärft wurde.  In diesem Fall können Sie in Bezug auf Geschwindigkeit und Ressourcenintensität durchaus akzeptable Ergebnisse erzielen. <br><br>  Wenn Sie ein MATLAB-Entwickler sind, klicken Sie nicht schnell auf die Schaltfläche Ausführen und kompilieren Sie Ihren Code unter FPGA. Denken Sie daran, dass Ihr Code zu einer realen Schaltung synthetisiert wird.  =) <br><br><h4>  Intel HLS Compiler </h4><br>  Für die gleiche Funktionalität habe ich den folgenden C / C ++ - Code geschrieben <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">component </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">conv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *kernel)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mult_res[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> summl; summl = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; i++) { mult_res[i] = data[i] * kernel[i]; summl = summl+mult_res[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summl/<span class="hljs-number"><span class="hljs-number">16</span></span>; }</code> </pre><br>  Das erste, was auffällt, ist die Menge der verwendeten Ressourcen. <br><br><img src="https://habrastorage.org/webt/yg/t1/zq/ygt1zq3p67hkkly29pneur9x6bu.png"><br>  <i>Abbildung 17</i> <br><br>  Aus der Tabelle ist ersichtlich, dass nur 1 DSP-Block verwendet wurde, sodass ein Fehler aufgetreten ist und Multiplikationen nicht parallel durchgeführt werden.  Die Anzahl der verwendeten Register ist ebenfalls überraschend, und es ist sogar Speicher erforderlich, aber wir werden dies dem Gewissen des HLS-Compilers überlassen. <br><br>  Es ist erwähnenswert, dass der HLS-Compiler ein Suboptimum entwickelt hat, das eine große Menge zusätzlicher Ressourcen verwendet, aber dennoch eine Arbeitsschaltung, die laut Quartus-Berichten mit einer akzeptablen Frequenz arbeitet, und ein Fehler wie der HDL-Codierer nicht. <br><br><img src="https://habrastorage.org/webt/y-/wg/fa/y-wgfaigf6zgbaljoez__xzxuqm.png"><br>  <i>Abbildung 18</i> <br><br>  Versuchen wir, die Situation zu verbessern.  Was wird dafür benötigt?  Richtig, schließen Sie die Augen vor der Vererbung und kriechen Sie in den Code, aber bisher ist es nicht viel. <br><br>  HLS verfügt über spezielle Anweisungen zur Optimierung des Codes für FPGA.  Wir fügen die Unroll-Direktive ein, die unsere Schleife parallel erweitern soll: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> unroll for (int i = 0; i &lt; 16; i++) { mult_res[i] = data[i] * kernel[i]; }</span></span></code> </pre><br><br>  Mal sehen, wie Quartus darauf reagiert hat <br><br><img src="https://habrastorage.org/webt/fi/7j/nk/fi7jnkhaoeals29m0pfk38shv70.png"><br>  <i>Abbildung 19</i> <br><br>  Achten Sie zunächst auf die Anzahl der DSP-Blöcke - es gibt 16 davon, was bedeutet, dass Multiplikationen parallel durchgeführt werden. <br><br>  Hurra!  abrollen funktioniert!  Es ist jedoch bereits schwer zu ertragen, wie stark die Nutzung anderer Ressourcen zugenommen hat.  Die Schaltung ist völlig unlesbar geworden. <br><br> <a href=""><img src="https://habrastorage.org/webt/vj/gs/tu/vjgstugdk5a661jnk281gys8-qo.png"></a> <br>  <i>Abbildung 20</i> <br><br>  Ich glaube, das lag an der Tatsache, dass niemand den Compiler darauf hinwies, dass Berechnungen in Festkommazahlen für uns gut geeignet sind, und er hat ehrlich gesagt alle Gleitkomma-Mathematik in Logik und Registern implementiert.  Wir müssen dem Compiler erklären, was davon verlangt wird, und dafür tauchen wir wieder in den Code ein. <br><br>  Zur Verwendung von Festkomma werden Vorlagenklassen implementiert. <br><br><img src="https://habrastorage.org/webt/0a/a8/dj/0aa8djn0cwvyf8tplhtay6lymdg.png"><br>  <i>Abbildung 21</i> <br><br>  In unseren eigenen Worten können wir Variablen verwenden, deren Bittiefe manuell auf ein Bit eingestellt wird.  Für diejenigen, die in HDL schreiben, kann man sich nicht daran gewöhnen, aber C / C ++ - Programmierer werden wahrscheinlich ihre Köpfe umklammern.  Bittiefen, wie in MATLAB, wird in diesem Fall niemand sagen, und der Entwickler selbst muss die Anzahl der Bits zählen. <br><br>  Mal sehen, wie es in der Praxis aussieht. <br><br>  Wir bearbeiten den Code wie folgt: <br><br><pre> <code class="cpp hljs">component ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; conv(ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; *data, ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; *kernel) { ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt;mult_res[<span class="hljs-number"><span class="hljs-number">16</span></span>]; ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt;summl; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> unroll for (int i = 0; i &lt; 16; i++) { mult_res[i] = data[i] * kernel[i]; } for (int i = 0; i &lt; 16; i++) { summl = summl+mult_res[i]; } return summl/16; }</span></span></code> </pre><br>  Und anstelle der gruseligen Nudeln aus Abbildung 20 erhalten wir diese Schönheit: <br><br> <a href=""><img src="https://habrastorage.org/webt/kg/v0/ot/kgv0ot9el2l5a3u4wawqsbw4hli.png"></a> <br>  <i>Abbildung 22</i> <br><br>  Leider passiert mit den verwendeten Ressourcen weiterhin etwas Seltsames. <br><br><img src="https://habrastorage.org/webt/my/dk/bk/mydkbkemq-dzzzhk53gky-zix00.png"><br>  <i>Abbildung 23</i> <br><br>  Eine detaillierte Überprüfung der Berichte zeigt jedoch, dass das Modul, das uns direkt interessiert, mehr als angemessen aussieht: <br><br> <a href=""><img src="https://habrastorage.org/webt/tn/t0/da/tnt0daffouamtkyozxnrnu_zoku.png"></a> <br>  <i>Abbildung 24</i> <br><br>  Der enorme Verbrauch an Registern und Blockspeicher ist mit einer großen Anzahl von Peripheriemodulen verbunden.  Ich verstehe die tiefe Bedeutung ihrer Existenz immer noch nicht vollständig, und dies muss geklärt werden, aber das Problem ist gelöst.  Im Extremfall können Sie ein für uns interessantes Modul sorgfältig aus der allgemeinen Struktur des Projekts herausschneiden, um uns vor peripheren Modulen zu schützen, die Ressourcen verschlingen. <br><br><h3>  Der dritte Test.  "Übergang von RGB zu HSV" </h3><br>  Als ich anfing, diesen Artikel zu schreiben, hatte ich nicht erwartet, dass er so umfangreich sein würde.  Aber ich kann den dritten und den letzten im Rahmen dieses Artikels, ein Beispiel, nicht ablehnen. <br><br>  Erstens ist dies ein echtes Beispiel aus meiner Praxis, und aus diesem Grund begann ich, mich mit hochrangigen Entwicklungswerkzeugen zu befassen. <br><br>  Zweitens könnten wir anhand der ersten beiden Beispiele davon ausgehen, dass die Werkzeuge auf hoher Ebene die Aufgabe umso schlechter bewältigen, je komplexer das Design ist. <br><br>  Ich möchte zeigen, dass dieses Urteil falsch ist. Je komplexer die Aufgabe ist, desto mehr manifestieren sich die Vorteile von Entwicklungswerkzeugen auf hoher Ebene. <br><br>  Letztes Jahr, als ich an einem der Projekte arbeitete, mochte ich die bei Aliexpress gekaufte Kamera nicht, nämlich, dass die Farben nicht gesättigt genug waren.  Eine der beliebtesten Möglichkeiten, die Farbsättigung zu variieren, besteht darin, vom RGB-Farbraum zum HSV-Raum zu wechseln, wobei einer der Parameter die Sättigung ist.  Ich erinnere mich, wie ich die Übergangsformel geöffnet und tief durchgeatmet habe ... Die Implementierung solcher Berechnungen in FPGA ist nichts Außergewöhnliches, aber es wird natürlich einige Zeit dauern, Code zu schreiben.  Die Formel für den Wechsel von RGB zu HSV lautet also wie folgt: <br><br><img src="https://habrastorage.org/webt/z_/6u/_t/z_6u_tufgvs_wkbknmisu_gtn1e.png"><br>  <i>Abbildung 25</i> <br><br>  Die Implementierung eines solchen Algorithmus in FPGA wird nicht Tage, sondern Stunden dauern, und all dies muss aufgrund der Besonderheiten von HDL sehr sorgfältig durchgeführt werden, und die Implementierung in C ++ oder MATLAB wird, glaube ich, Minuten dauern. <br><br>  In C ++ können Sie Code direkt in die Stirn schreiben und trotzdem ein funktionierendes Ergebnis erhalten. <br>  Ich habe die folgende Option in C ++ geschrieben <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">color_space</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> rh; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> gs; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> bv; }; <span class="hljs-function"><span class="hljs-function">component color_space </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rgb2hsv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(color_space rgb_0)</span></span></span><span class="hljs-function"> </span></span>{ color_space hsv; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h,s,v,r,g,b; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> max_col, min_col; r = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(rgb_0.rh)/<span class="hljs-number"><span class="hljs-number">255</span></span>; g = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(rgb_0.gs)/<span class="hljs-number"><span class="hljs-number">255</span></span>; b = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(rgb_0.bv)/<span class="hljs-number"><span class="hljs-number">255</span></span>; max_col = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(r,g),b); min_col = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(r,g),b); <span class="hljs-comment"><span class="hljs-comment">// H if (max_col == min_col) h = 0; else if (max_col==r &amp;&amp; g&gt;=b) h = 60*((gb)/(max_col-min_col)); else if (max_col==r &amp;&amp; g&lt;b) h = 60*((gb)/(max_col-min_col))+360; else if (max_col==g) h = 60*((br)/(max_col-min_col))+120; else if (max_col==b) h = 60*((rg)/(max_col-min_col))+240; // S if (max_col == 0) s = 0; else { s = (1-(min_col/max_col))*100; } // V v = max_col*100; hsv.rh = static_cast&lt;char&gt;(h); hsv.gs = static_cast&lt;char&gt;(s); hsv.bv = static_cast&lt;char&gt;(v); return hsv; }</span></span></code> </pre><br>  Und Quartus hat das Ergebnis erfolgreich implementiert, wie aus der Tabelle der verwendeten Ressourcen hervorgeht. <br><br><img src="https://habrastorage.org/webt/us/bs/qx/usbsqx6dg4ncv_kkefii6ul8msq.png"><br>  <i>Abbildung 26</i> <br><br>  Die Frequenz ist sehr gut. <br><br><img src="https://habrastorage.org/webt/t-/tk/hd/t-tkhdxq-d1yr7uo28m5_k7sfaa.png"><br>  <i>Abbildung 27</i> <br><br>  Mit dem HDL-Codierer sind die Dinge etwas komplizierter. <br><br>  Um den Artikel nicht aufzublasen, werde ich kein M-Skript für diese Aufgabe bereitstellen, es sollte keine Schwierigkeiten verursachen.  Ein in die Stirn geschriebenes M-Skript kann kaum erfolgreich verwendet werden. Wenn Sie jedoch den Code bearbeiten und die Stellen für das Pipelining korrekt angeben, erhalten Sie ein Arbeitsergebnis.  Dies dauert natürlich einige zehn Minuten, aber nicht Stunden. <br><br>  C++          ,       . <br><br>  ,    ,   ,    ,     —   ,         FPGA      ,     HDL. <br><br><h2>  Fazit </h2><br>     . <br><br> ,     ,    ,      . <br><br>    ,   ,   .     ,    ,      HDL,  . <br><br>   ,    FPGA        FPGA       .           . <br><br>    ,    —          FPGA. <br><br>  HLS compiler     : ,     ,  ,      “best practices”  ..  MATLAB,    ,     GUI , , ,      ,    ,     . <br><br>     ?   —  Intel HLS compiler.         . HDL coder          .   ,  HDL coder   ,    ,       .   HLS,   ,  ,   FPGA     ,         . <br><br>   Xilinx ,       —              FPGA.        ,  , Verilog/VHDL   ,    .          (    ),       . <br><br>          ?  ,      ,      ,      HDL   . <br><br>      ,              ,        ,      ,    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455668/">https://habr.com/ru/post/de455668/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455650/index.html">Wie wir ein neuronales Netzwerk trainiert haben, um Schrauben zu klassifizieren</a></li>
<li><a href="../de455652/index.html">Deep Learning gegen gesunden Menschenverstand: Entwicklung eines Chat-Bots</a></li>
<li><a href="../de455658/index.html">Legendärer Intel Core i7-2600K: Testen von Sandy Bridge im Jahr 2019 (Teil 3)</a></li>
<li><a href="../de455662/index.html">Großes mechanisches Display mit Nockenmechanismus als Decoder</a></li>
<li><a href="../de455666/index.html">Aufbau von Outbound Sales in einem IT-Service-Unternehmen</a></li>
<li><a href="../de455670/index.html">Wie 3D-Drucker Knochen, Blutgefäße und Organe drucken</a></li>
<li><a href="../de455676/index.html">Ist die Blase des maschinellen Lernens geplatzt oder hat eine neue Morgendämmerung begonnen?</a></li>
<li><a href="../de455678/index.html">Auf dem Weg von Sergej Pawlowitsch Korolev. Modernes russisches bemanntes Projekt. Teil 1. "Föderation"</a></li>
<li><a href="../de455682/index.html">Wie viel geben Sie für die Infrastruktur aus? Und wie kann man das sparen?</a></li>
<li><a href="../de455684/index.html">Warum haben wir einen Hackathon für Tester durchgeführt?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>