<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíú ü•¢ üë©üèø‚Äçüíª Wir schreiben unter FPGA ohne HDL. Vergleich von Entwicklungswerkzeugen auf hoher Ebene üë®üèø‚Äçü§ù‚Äçüë®üèº üé¶ üßúüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In j√ºngster Zeit haben FPGA-Hersteller und Drittunternehmen aktiv Entwicklungsmethoden f√ºr FPGAs entwickelt, die sich von herk√∂mmlichen Ans√§tzen unter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben unter FPGA ohne HDL. Vergleich von Entwicklungswerkzeugen auf hoher Ebene</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455668/">  In j√ºngster Zeit haben FPGA-Hersteller und Drittunternehmen aktiv Entwicklungsmethoden f√ºr FPGAs entwickelt, die sich von herk√∂mmlichen Ans√§tzen unter Verwendung von Entwicklungswerkzeugen auf hoher Ebene unterscheiden. <br><br>  Als FPGA-Entwickler verwende ich die Hardwarebeschreibungssprache ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HDL</a> ) von Verilog als Hauptwerkzeug, aber die wachsende Beliebtheit neuer Methoden hat mein gro√ües Interesse geweckt. Deshalb habe ich mich in diesem Artikel entschlossen, herauszufinden, was passiert. <br><br>  Dieser Artikel ist keine Anleitung oder Gebrauchsanweisung. Dies ist mein R√ºckblick und meine Schlussfolgerungen dar√ºber, was verschiedene Entwicklungswerkzeuge auf hoher Ebene einem FPGA-Entwickler oder Programmierer bieten k√∂nnen, der in die Welt des FPGA eintauchen m√∂chte.  Um die meiner Meinung nach interessantesten Entwicklungswerkzeuge zu vergleichen, habe ich mehrere Tests geschrieben und die Ergebnisse analysiert.  Unter dem Schnitt - was kam daraus. <br><a name="habracut"></a><br><h2>  Warum ben√∂tigen Sie hochwertige Entwicklungswerkzeuge f√ºr FPGA? </h2><br><ul><li>  Beschleunigen Sie die Projektentwicklung <br>  - aufgrund der Wiederverwendung von Code, der bereits in Hochsprachen geschrieben wurde; <br>  - durch die Nutzung aller Vorteile von Hochsprachen beim Schreiben von Code von Grund auf neu; <br>  - durch Reduzierung der Kompilierungszeit und der Code√ºberpr√ºfung. <br></li><li>  M√∂glichkeit, universellen Code zu erstellen, der f√ºr jede FPGA-Familie geeignet ist. </li><li>  Reduzieren Sie beispielsweise den Entwicklungsschwellenwert f√ºr FPGAs, indem Sie die Konzepte der ‚ÄûTaktfrequenz‚Äú und anderer Entit√§ten auf niedriger Ebene vermeiden.  M√∂glichkeit, Code f√ºr FPGA an einen Entwickler zu schreiben, der mit HDL nicht vertraut ist. </li></ul><br><h2>  Woher kommen die hochrangigen Entwicklungswerkzeuge? </h2><br>  Jetzt sind viele von der Idee einer hochrangigen Entwicklung angezogen.  Sowohl Enthusiasten wie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quokka</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Python-Codegenerator</a> als auch Unternehmen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mathworks</a> und die FPGA-Hersteller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Xilinx</a> sind daran beteiligt. <br><br>  Jeder nutzt seine Methoden und Werkzeuge, um sein Ziel zu erreichen.  Enthusiasten im Kampf um eine perfekte und sch√∂ne Welt verwenden ihre bevorzugten Entwicklungssprachen wie Python oder C #.  Unternehmen, die versuchen, den Kunden zufrieden zu stellen, bieten ihre eigenen an oder passen vorhandene Tools an.  Mathworks bietet ein eigenes HDL-Codierertool zum Generieren von HDL-Code aus M-Skripten und Simulink-Modellen an, w√§hrend Intel und Xilinx Compiler f√ºr g√§ngiges C / C ++ anbieten. <br><br>  Derzeit haben Unternehmen mit erheblichen finanziellen und personellen Ressourcen gr√∂√üere Erfolge erzielt, w√§hrend Enthusiasten etwas zur√ºckbleiben.  Dieser Artikel befasst sich mit dem Produkt HDL-Codierer von Mathworks und HLS Compiler von Intel. <br><br><div class="spoiler">  <b class="spoiler_title">Was ist mit Xilinx?</b> <div class="spoiler_text">  In diesem Artikel werde ich HIL von Xilinx aufgrund der unterschiedlichen Architekturen und CAD-Systeme von Intel und Xilinx nicht ber√ºcksichtigen, was einen eindeutigen Vergleich der Ergebnisse unm√∂glich macht.  Ich m√∂chte jedoch darauf hinweisen, dass Xilinx HLS wie Intel HLS einen C / C ++ - Compiler bereitstellt und konzeptionell √§hnlich ist. <br></div></div><br>  Beginnen wir mit dem Vergleich des HDL-Codierers von Mathworks und Intel HLS Compiler, nachdem mehrere Probleme mit unterschiedlichen Ans√§tzen gel√∂st wurden. <br><br><h2>  Vergleich von Entwicklungswerkzeugen auf hoher Ebene </h2><br><h3>  Testen Sie einen.  "Zwei Multiplikatoren und ein Addierer" </h3><br>  Die L√∂sung dieses Problems hat keinen praktischen Wert, eignet sich aber gut als erster Test.  Die Funktion verwendet 4 Parameter, multipliziert den ersten mit dem zweiten, den dritten mit dem vierten und addiert die Ergebnisse der Multiplikation.  Nichts kompliziertes, aber mal sehen, wie unsere Probanden damit umgehen. <br><br><h4>  HDL-Codierer von Mathworks </h4><br>  Um dieses Problem zu l√∂sen, sieht das M-Skript wie folgt aus: <br><br><pre><code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[out]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TwoMultAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a,b,c,d)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a*b)</span></span></span><span class="hljs-function">+</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c*d)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Mal sehen, was Mathworks uns bietet, um Code in HDL zu konvertieren. <br><br>  Ich werde die Arbeit mit HDL-Codierern nicht im Detail betrachten, sondern mich nur auf die Einstellungen konzentrieren, die ich in Zukunft √§ndern werde, um unterschiedliche Ergebnisse in FPGA zu erzielen, und deren √Ñnderungen von einem MATLAB-Programmierer ber√ºcksichtigt werden m√ºssen, der seinen Code in FPGA ausf√ºhren muss. <br><br>  Als erstes m√ºssen Sie also den Typ und den Bereich der Eingabewerte festlegen.  Es gibt kein bekanntes char, int, float, double im FPGA.  Die Bittiefe der Zahl kann beliebig sein. Es ist logisch, sie basierend auf dem Bereich der Eingabewerte auszuw√§hlen, die Sie verwenden m√∂chten. <br><br><img src="https://habrastorage.org/webt/yi/vt/rm/yivtrmsrseix9d6-r5ktf7q4i98.png" alt="Bild"><br>  <i>Abbildung 1</i> <br><br>  MATLAB √ºberpr√ºft die Variablentypen und ihre Werte und w√§hlt die richtigen Bitgr√∂√üen f√ºr Busse und Register aus, was sehr praktisch ist.  Wenn es keine Probleme mit der Bittiefe und der Eingabe gibt, k√∂nnen Sie mit den folgenden Punkten fortfahren. <br><br> <a href=""><img src="https://habrastorage.org/webt/hy/bw/zv/hybwzvt-w0xzsta5gkf-0oapcrq.png" alt="Bild"></a> <br>  <i>Abbildung 2</i> <br><br>  In der HDL-Codegenerierung gibt es mehrere Registerkarten, auf denen Sie die Sprache ausw√§hlen k√∂nnen, in die konvertiert werden soll (Verilog oder VHDL).  Codestil  Namen von Signalen.  Die meiner Meinung nach interessanteste Registerkarte ist die Optimierung, und ich werde damit experimentieren. Lassen Sie uns jedoch vorerst alle Standardeinstellungen belassen und sehen, was mit dem HDL-Codierer "out of the box" passiert. <br><br>  Dr√ºcken Sie die Run-Taste und erhalten Sie den folgenden Code: <br><br><pre> <code class="plaintext hljs">`timescale 1 ns / 1 ns module TwoMultAdd_fixpt (a, b, c, d, out); input [7:0] a; // ufix8 input [7:0] b; // ufix8 input [7:0] c; // ufix8 input [7:0] d; // ufix8 output [16:0] out; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp; // ufix16 wire [16:0] TwoMultAdd_fixpt_2; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp_1; // ufix16 wire [16:0] TwoMultAdd_fixpt_3; // ufix17 //HDL code generation from MATLAB function: TwoMultAdd_fixpt //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% // % // Generated by MATLAB 9.2 and Fixed-Point Designer 5.4 % // % //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% assign TwoMultAdd_fixpt_mul_temp = a * b; assign TwoMultAdd_fixpt_2 = {1'b0, TwoMultAdd_fixpt_mul_temp}; assign TwoMultAdd_fixpt_mul_temp_1 = c * d; assign TwoMultAdd_fixpt_3 = {1'b0, TwoMultAdd_fixpt_mul_temp_1}; assign out = TwoMultAdd_fixpt_2 + TwoMultAdd_fixpt_3; endmodule // TwoMultAdd_fixpt</code> </pre><br>  Der Code sieht gut aus.  MATLAB versteht, dass das Schreiben des gesamten Ausdrucks in einer einzelnen Zeile in Verilog eine schlechte Praxis ist.  Erstellt separate <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dr√§hte</a> f√ºr den Multiplikator und den Addierer. Es gibt nichts zu beanstanden. <br><br>  Es ist alarmierend, dass die Beschreibung der Register fehlt.  Dies geschah, weil wir den HDL-Codierer nicht danach gefragt haben und alle Felder in den Einstellungen auf ihren Standardwerten belassen haben. <br><br>  Hier ist, was Quartus aus einem solchen Code synthetisiert. <br><br><img src="https://habrastorage.org/webt/zf/af/ja/zfafjaezynolikraaha86gadp-e.png"><br>  <i>Abbildung 3</i> <br><br>  Keine Probleme, alles war wie geplant. <br><br>  In FPGA implementieren wir synchrone Schaltungen, und trotzdem w√ºrde ich gerne die Register sehen.  Der HDL-Codierer bietet einen Mechanismus zum Platzieren von Registern, aber wo sie platziert werden sollen, liegt beim Entwickler.  Wir k√∂nnen die Register am Eingang der Multiplikatoren, am Ausgang der Multiplikatoren vor dem Addierer oder am Ausgang des Addierers platzieren. <br><br>  Um die Beispiele zusammenzufassen, habe ich mich f√ºr die FPGA Cyclone V-Familie entschieden, bei der spezielle DSP-Bl√∂cke mit integrierten Addierern und Multiplikatoren zur Implementierung von arithmetischen Operationen verwendet werden.  Der DSP-Block sieht folgenderma√üen aus: <br><br> <a href=""><img src="https://habrastorage.org/webt/zf/5s/bt/zf5sbts5ke1t_pw3dsmrc4uhtrc.png"></a> <br>  <i>Abbildung 4</i> <br><br>  Der DSP-Block hat Eingangs- und Ausgangsregister.  Es ist nicht erforderlich, die Ergebnisse der Multiplikation vor dem Hinzuf√ºgen im Register abzufangen. Dies verst√∂√üt nur gegen die Architektur (in bestimmten F√§llen ist diese Option m√∂glich und wird sogar ben√∂tigt).  Es ist Sache des Entwicklers, anhand der Latenzanforderungen und der erforderlichen maximalen Frequenz zu entscheiden, wie mit dem Eingangs- und Ausgangsregister umgegangen werden soll.  Ich habe mich entschieden, nur das Ausgangsregister zu verwenden.  Damit dieses Register in dem vom HDL-Codierer generierten Code beschrieben werden kann, m√ºssen Sie auf der Registerkarte Optionen im HDL-Codierer das Kontrollk√§stchen Registerausgabe aktivieren und die Konvertierung neu starten. <br><br>  Es stellt sich folgender Code heraus: <br><br><pre> <code class="plaintext hljs">`timescale 1 ns / 1 ns module TwoMultAdd_fixpt (clk, reset, clke_ena_i, a, b, c, d, clke_ena_o, out); input clk; input reset; input clke_ena_i; input [7:0] a; // ufix8 input [7:0] b; // ufix8 input [7:0] c; // ufix8 input [7:0] d; // ufix8 output clke_ena_o; output [16:0] out; // ufix17 wire enb; wire [16:0] out_1; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp; // ufix16 wire [16:0] TwoMultAdd_fixpt_2; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp_1; // ufix16 wire [16:0] TwoMultAdd_fixpt_3; // ufix17 reg [16:0] out_2; // ufix17 //HDL code generation from MATLAB function: TwoMultAdd_fixpt //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% // % // Generated by MATLAB 9.2 and Fixed-Point Designer 5.4 % // % //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% assign TwoMultAdd_fixpt_mul_temp = a * b; assign TwoMultAdd_fixpt_2 = {1'b0, TwoMultAdd_fixpt_mul_temp}; assign TwoMultAdd_fixpt_mul_temp_1 = c * d; assign TwoMultAdd_fixpt_3 = {1'b0, TwoMultAdd_fixpt_mul_temp_1}; assign out_1 = TwoMultAdd_fixpt_2 + TwoMultAdd_fixpt_3; assign enb = clke_ena_i; always @(posedge clk or posedge reset) begin : out_reg_process if (reset == 1'b1) begin out_2 &lt;= 17'b00000000000000000; end else begin if (enb) begin out_2 &lt;= out_1; end end end assign clke_ena_o = clke_ena_i; assign out = out_2; endmodule // TwoMultAdd_fixpt</code> </pre><br>  Wie Sie sehen k√∂nnen, weist der Code grundlegende Unterschiede zur vorherigen Version auf.  Es erschien ein Always-Block, der eine Beschreibung des Registers darstellt (genau das, was wir wollten).  F√ºr den Always-Block-Betrieb erschienen auch die Eing√§nge des Clk-Moduls (Taktfrequenz) und des Reset (Reset).  Es ist ersichtlich, dass der Ausgang des Addierers in dem in immer beschriebenen Trigger zwischengespeichert ist.  Es gibt auch ein paar Ena-Erlaubnis-Signale, aber sie sind f√ºr uns nicht sehr interessant. <br><br>  Schauen wir uns das Diagramm an, das Quartus jetzt synthetisiert. <br><br><img src="https://habrastorage.org/webt/ro/we/px/rowepxxw-fun6ey4x2tpw4cfjyg.png"><br>  <i>Abbildung 5</i> <br><br>  Auch hier sind die Ergebnisse gut und werden erwartet. <br><br>  Die folgende Tabelle zeigt die Tabelle der verwendeten Ressourcen - wir ber√ºcksichtigen dies. <br><br><img src="https://habrastorage.org/webt/_z/wy/lk/_zwylksweoc_mhrps-rqhwankbe.png"><br>  <i>Abbildung 6</i> <br><br>  F√ºr diese erste Quest erh√§lt Mathworks eine Gutschrift.  Alles ist nicht kompliziert, vorhersehbar und mit dem gew√ºnschten Ergebnis. <br><br>  Ich habe ein einfaches Beispiel ausf√ºhrlich beschrieben, ein Diagramm eines DSP-Blocks bereitgestellt und die M√∂glichkeiten beschrieben, die Registerverwendungseinstellungen in HDL-Codierern au√üer den ‚ÄûStandardeinstellungen‚Äú zu verwenden.  Dies geschieht aus einem bestimmten Grund.  An dieser Stelle m√∂chte ich betonen, dass auch in einem so einfachen Beispiel bei Verwendung eines HDL-Codierers Kenntnisse der FPGA-Architektur und der Grundlagen digitaler Schaltkreise erforderlich sind und die Einstellungen bewusst ge√§ndert werden m√ºssen. <br><br><h4>  Intel HLS Compiler </h4><br>  Versuchen wir, Code mit der gleichen Funktionalit√§t zu kompilieren, die in C ++ geschrieben wurde, und sehen, was schlie√ülich mit dem HLS-Compiler in FPGA synthetisiert wird. <br><br>  Also C ++ Code <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">component </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TwoMultAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a*b)+(c*d); }</code> </pre><br>  Ich habe Datentypen ausgew√§hlt, um ein √úberlaufen von Variablen zu vermeiden. <br><br>  Es gibt fortschrittliche Methoden zum Festlegen von Bittiefen. Unser Ziel ist es jedoch, die F√§higkeit zu testen, Funktionen, die im C / C ++ - Stil unter FPGA geschrieben wurden, ohne √Ñnderungen zusammenzustellen. <br><br>  Da der HLS-Compiler ein natives Tool von Intel ist, sammeln wir den Code mit einem speziellen Compiler und √ºberpr√ºfen das Ergebnis sofort in Quartus. <br><br>  Schauen wir uns die Schaltung an, die Quartus synthetisiert. <br><br><img src="https://habrastorage.org/webt/ra/wy/bg/rawybgvk1yirtlaxi5yfmqjk6mi.png"><br>  <i>Abbildung 7</i> <br><br>  Der Compiler hat Register an der Ein- und Ausgabe erstellt, aber die Essenz ist im Wrapper-Modul verborgen.  Wir beginnen mit der Bereitstellung des Wrappers und ... sehen immer mehr verschachtelte Module. <br><br>  Die Struktur des Projekts sieht so aus. <br><br> <a href=""><img src="https://habrastorage.org/webt/x6/3x/pi/x63xpin-73wlqtuear-rhyhcpcy.png"></a> <br>  <i>Abbildung 8</i> <br><br>  Ein offensichtlicher Hinweis von Intel lautet: "Nehmen Sie es nicht in die Hand!".  Aber wir werden versuchen, vor allem die Funktionalit√§t ist nicht kompliziert. <br><br>  In den Eingeweiden des Projektbaums | quartus_compile | TwoMultAdd: TwoMultAdd_inst | TwoMultAdd_internal: twomultadd_internal_inst | TwoMultAdd_fu <br>  nction_wrapper: TwoMultAdd_internal | TwoMultAdd_function: theTwoMultAdd_function | bb_TwoMultAdd_B1_start: <br>  thebb_TwoMultAdd_B1_start | bb_TwoMultAdd_B1_start_stall_region: thebb_TwoMultAdd_B1_start_stall_region | i <br>  _sfc_c1_wt_entry_twomultadd_c1_enter_twomultadd: thei_sfc_c1_wt_entry_twomultadd_c1_enter_twomultad <br>  d_aunroll_x | i_sfc_logic_c1_wt_entry_twomultadd_c1_enter_twomultadd13: thei_sfc_logic_c1_wt_entry_twom <br>  ultadd_c1_enter_twomultadd13_aunroll_x | Mult1 ist das Modul, nach dem Sie suchen. <br><br>  Wir k√∂nnen uns das Diagramm des gew√ºnschten Moduls ansehen, das von Quartus synthetisiert wurde. <br><br> <a href=""><img src="https://habrastorage.org/webt/4m/e8/_c/4me8_cxojdb6zyvo0mkvc-i7a60.png"></a> <br>  <i>Abbildung 9</i> <br><br>  Welche Schlussfolgerungen k√∂nnen aus diesem Schema gezogen werden? <br><br>  Es ist offensichtlich, dass etwas passiert ist, das wir bei der Arbeit in MATLAB zu vermeiden versucht haben: Der Fall am Ausgang des Multiplikators wurde synthetisiert - das ist nicht sehr gut.  Aus dem DSP-Blockdiagramm (Abbildung 4) ist ersichtlich, dass sich an seinem Ausgang nur ein Register befindet, was bedeutet, dass jede Multiplikation in einem separaten Block durchgef√ºhrt werden muss. <br><br>  Die Tabelle der verwendeten Ressourcen zeigt, wozu dies f√ºhrt. <br><br><img src="https://habrastorage.org/webt/es/eu/tj/eseutjlsyur_gibiank94suhhca.png"><br>  <i>Abbildung 10</i> <br><br>  Vergleichen Sie die Ergebnisse mit der HDL-Codierertabelle (Abbildung 6). <br><br>  Wenn Sie eine gr√∂√üere Anzahl von Registern verwenden, die Sie ertragen k√∂nnen, ist es sehr unangenehm, wertvolle DSP-Bl√∂cke f√ºr solch einfache Funktionen auszugeben. <br><br>  Intel HLS bietet jedoch ein gro√ües Plus im Vergleich zu HDL-Codierern.  Mit den Standardeinstellungen entwickelte der HLS-Compiler ein synchrones Design in FPGA, obwohl er mehr Ressourcen verbrauchte.  Eine solche Architektur ist m√∂glich, es ist klar, dass Intel HLS so konfiguriert ist, dass maximale Leistung erzielt wird und keine Ressourcen gespart werden. <br><br>  Mal sehen, wie sich unsere Themen bei komplexeren Projekten verhalten. <br><br><h3>  Der zweite Test.  "Elementweise Multiplikation von Matrizen mit Summation des Ergebnisses" </h3><br>  Diese Funktion ist in der Bildverarbeitung weit verbreitet: der sogenannte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûMatrixfilter‚Äú</a> .  Wir verkaufen es mit hochwertigen Werkzeugen. <br><br><h4>  HDL-Codierer von Mathwork </h4><br>  Die Arbeit beginnt sofort mit einer Einschr√§nkung.  Der HDL-Codierer kann keine 2D-Matrixfunktionen als Eing√§nge akzeptieren.  Angesichts der Tatsache, dass MATLAB ein Werkzeug f√ºr die Arbeit mit Matrizen ist, ist dies ein schwerer Schlag f√ºr den gesamten geerbten Code, der zu einem ernsthaften Problem werden kann.  Wenn der Code von Grund auf neu geschrieben wurde, ist dies eine unangenehme Funktion, die ber√ºcksichtigt werden muss.  Sie m√ºssen also alle Matrizen in einem Vektor bereitstellen und die Funktionen unter Ber√ºcksichtigung der Eingabevektoren implementieren. <br><br>  Der Code f√ºr die Funktion in MATLAB lautet wie folgt <br><br><pre> <code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[out]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mhls_conv2_manually</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target,kernel)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(kernel)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-function">.*</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mult)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  Der generierte HDL-Code erwies sich als sehr aufgebl√§ht und enth√§lt Hunderte von Zeilen, daher werde ich ihn hier nicht angeben.  Mal sehen, welches Schema Quartus aus diesem Code synthetisiert. <br><br> <a href=""><img src="https://habrastorage.org/webt/6d/3z/cd/6d3zcdcx0yzcqp-ht6fhz_mtx2i.png"></a> <br>  <i>Abbildung 11</i> <br><br>  Dieses Schema sieht nicht erfolgreich aus.  Formal funktioniert es, aber ich gehe davon aus, dass es mit einer sehr niedrigen Frequenz funktioniert und in realer Hardware kaum verwendet werden kann.  Jede Annahme muss jedoch √ºberpr√ºft werden.  Dazu platzieren wir die Register am Eingang und Ausgang dieser Schaltung und bewerten mit Hilfe des Timing Analyzer die reale Situation.  Um die Analyse durchzuf√ºhren, m√ºssen Sie die gew√ºnschte Betriebsfrequenz des Stromkreises angeben, damit Quartus wei√ü, worauf bei der Verkabelung zu achten ist, und im Fehlerfall Berichte √ºber Verst√∂√üe liefert. <br><br>  Wir stellen die Frequenz auf 100 MHz ein. Mal sehen, was Quartus aus der vorgeschlagenen Schaltung herausdr√ºcken kann. <br><br><img src="https://habrastorage.org/webt/r7/zv/xy/r7zvxygef12ws12mmyfwgxc0plk.png"><br>  <i>Abbildung 12</i> <br><br>  Es ist zu sehen, dass es sich ein wenig herausstellte: 33 MHz sehen leichtfertig aus.  Die Verz√∂gerung in der Kette von Multiplikatoren und Addierern betr√§gt etwa 30 ns.  Um diesen ‚ÄûEngpass‚Äú zu beseitigen, m√ºssen Sie den F√∂rderer verwenden: Register nach arithmetischen Operationen einf√ºgen, wodurch der kritische Pfad verringert wird. <br><br>  Der HDL-Codierer bietet uns diese M√∂glichkeit.  Auf der Registerkarte Optionen k√∂nnen Sie Pipeline-Variablen festlegen.  Da der betreffende Code im MATLAB-Stil geschrieben ist, gibt es keine M√∂glichkeit zu Pipeline-Variablen (au√üer Multi- und Summ-Variablen), die nicht zu uns passen.  Es ist notwendig, die Register in die in unserem HDL-Code verborgenen Zwischenkreise einzuf√ºgen. <br><br>  Dar√ºber hinaus k√∂nnte sich die Situation bei der Optimierung verschlechtern.  Zum Beispiel hindert uns nichts daran, Code zu schreiben <br><br><pre> <code class="matlab hljs">out = (sum(target.*kernel))/len;</code> </pre> <br>  es ist f√ºr MATLAB v√∂llig ausreichend, beraubt uns jedoch v√∂llig der M√∂glichkeit, HDL zu optimieren. <br><br>  Der n√§chste Ausweg besteht darin, den Code von Hand zu bearbeiten.  Dies ist ein sehr wichtiger Punkt, da wir uns weigern, das M-Skript zu erben und neu zu schreiben, und NICHT im MATLAB-Stil. <br><br>  Der neue Code lautet wie folgt <br><br><pre> <code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[out]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mhls_conv2_manually</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target,kernel)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(kernel)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-function">.*</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_1</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([1,(len/2)</span></span></span><span class="hljs-function">]); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_2</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([1,(len/4)</span></span></span><span class="hljs-function">]); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_3</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([1,(len/8)</span></span></span><span class="hljs-function">]); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">=0:1:</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len/2)</span></span></span><span class="hljs-function">-1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i+1)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mult(i*2+1)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i*2+2)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">=0:1:</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len/4)</span></span></span><span class="hljs-function">-1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i+1)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(summ_1(i*2+1)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i*2+2)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">=0:1:</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len/8)</span></span></span><span class="hljs-function">-1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i+1)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(summ_2(i*2+1)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i*2+2)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_3</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  In Quartus sammeln wir den vom HDL-Codierer generierten Code.  Es ist ersichtlich, dass die Anzahl der Schichten mit Grundelementen abgenommen hat und das Schema viel besser aussieht. <br><br> <a href=""><img src="https://habrastorage.org/webt/nd/7j/sr/nd7jsrm1hiursvzgredphpuvr7k.png"></a> <br>  <i>Abbildung 12</i> <br><br>  Bei korrekter Anordnung der Grundelemente w√§chst die Frequenz fast dreimal auf 88 MHz. <br><br><img src="https://habrastorage.org/webt/3z/4s/o3/3z4so3o-whcbn8jct8y-wtfsja4.png"><br>  <i>Abbildung 13</i> <br><br>  Jetzt der letzte Schliff: Geben Sie in den Optimierungseinstellungen summ_1, summ_2 und summ_3 als Elemente der Pipeline an.  Wir sammeln den resultierenden Code in Quartus.  Das Schema √§ndert sich wie folgt: <br><br> <a href=""><img src="https://habrastorage.org/webt/cu/kr/ua/cukruasropyfoifoib6er-fhck4.png"></a> <br>  <i>Abbildung 14</i> <br><br>  Die maximale Frequenz steigt wieder an und liegt nun bei ca. 195 MHz. <br><br><img src="https://habrastorage.org/webt/tl/gg/dd/tlggddvndao-cm0bavadgbuxx30.png"><br>  <i>Abbildung 15</i> <br><br>  Wie viele Ressourcen auf dem Chip ben√∂tigen ein solches Design?  Abbildung 16 zeigt die Tabelle der verwendeten Ressourcen f√ºr den beschriebenen Fall. <br><br><img src="https://habrastorage.org/webt/vl/ju/io/vljuioe1zmgnc-zr-nxvyv0lawu.png"><br>  <i>Abbildung 16</i> <br><br>  Welche Schlussfolgerungen k√∂nnen nach Betrachtung dieses Beispiels gezogen werden? <br><br>  Der Hauptnachteil des HDL-Codierers besteht darin, dass MATLAB-Code wahrscheinlich nicht in seiner reinen Form verwendet wird. <br>  Es gibt keine Unterst√ºtzung f√ºr Matrizen als Funktionseingaben, das Layout des Codes im MATLAB-Stil ist mittelm√§√üig. <br><br>  Die Hauptgefahr ist das Fehlen von Registern im Code, der ohne zus√§tzliche Einstellungen generiert wird.  Ohne diese Register ist die Verwendung eines solchen Codes in modernen Realit√§ten und Entwicklungen unerw√ºnscht, selbst wenn formal funktionierender HDL-Code ohne Syntaxfehler empfangen wurde. <br><br>  Es ist ratsam, sofort Code zu schreiben, der f√ºr die Konvertierung in HDL gesch√§rft wurde.  In diesem Fall k√∂nnen Sie in Bezug auf Geschwindigkeit und Ressourcenintensit√§t durchaus akzeptable Ergebnisse erzielen. <br><br>  Wenn Sie ein MATLAB-Entwickler sind, klicken Sie nicht schnell auf die Schaltfl√§che Ausf√ºhren und kompilieren Sie Ihren Code unter FPGA. Denken Sie daran, dass Ihr Code zu einer realen Schaltung synthetisiert wird.  =) <br><br><h4>  Intel HLS Compiler </h4><br>  F√ºr die gleiche Funktionalit√§t habe ich den folgenden C / C ++ - Code geschrieben <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">component </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">conv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *kernel)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mult_res[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> summl; summl = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; i++) { mult_res[i] = data[i] * kernel[i]; summl = summl+mult_res[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summl/<span class="hljs-number"><span class="hljs-number">16</span></span>; }</code> </pre><br>  Das erste, was auff√§llt, ist die Menge der verwendeten Ressourcen. <br><br><img src="https://habrastorage.org/webt/yg/t1/zq/ygt1zq3p67hkkly29pneur9x6bu.png"><br>  <i>Abbildung 17</i> <br><br>  Aus der Tabelle ist ersichtlich, dass nur 1 DSP-Block verwendet wurde, sodass ein Fehler aufgetreten ist und Multiplikationen nicht parallel durchgef√ºhrt werden.  Die Anzahl der verwendeten Register ist ebenfalls √ºberraschend, und es ist sogar Speicher erforderlich, aber wir werden dies dem Gewissen des HLS-Compilers √ºberlassen. <br><br>  Es ist erw√§hnenswert, dass der HLS-Compiler ein Suboptimum entwickelt hat, das eine gro√üe Menge zus√§tzlicher Ressourcen verwendet, aber dennoch eine Arbeitsschaltung, die laut Quartus-Berichten mit einer akzeptablen Frequenz arbeitet, und ein Fehler wie der HDL-Codierer nicht. <br><br><img src="https://habrastorage.org/webt/y-/wg/fa/y-wgfaigf6zgbaljoez__xzxuqm.png"><br>  <i>Abbildung 18</i> <br><br>  Versuchen wir, die Situation zu verbessern.  Was wird daf√ºr ben√∂tigt?  Richtig, schlie√üen Sie die Augen vor der Vererbung und kriechen Sie in den Code, aber bisher ist es nicht viel. <br><br>  HLS verf√ºgt √ºber spezielle Anweisungen zur Optimierung des Codes f√ºr FPGA.  Wir f√ºgen die Unroll-Direktive ein, die unsere Schleife parallel erweitern soll: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> unroll for (int i = 0; i &lt; 16; i++) { mult_res[i] = data[i] * kernel[i]; }</span></span></code> </pre><br><br>  Mal sehen, wie Quartus darauf reagiert hat <br><br><img src="https://habrastorage.org/webt/fi/7j/nk/fi7jnkhaoeals29m0pfk38shv70.png"><br>  <i>Abbildung 19</i> <br><br>  Achten Sie zun√§chst auf die Anzahl der DSP-Bl√∂cke - es gibt 16 davon, was bedeutet, dass Multiplikationen parallel durchgef√ºhrt werden. <br><br>  Hurra!  abrollen funktioniert!  Es ist jedoch bereits schwer zu ertragen, wie stark die Nutzung anderer Ressourcen zugenommen hat.  Die Schaltung ist v√∂llig unlesbar geworden. <br><br> <a href=""><img src="https://habrastorage.org/webt/vj/gs/tu/vjgstugdk5a661jnk281gys8-qo.png"></a> <br>  <i>Abbildung 20</i> <br><br>  Ich glaube, das lag an der Tatsache, dass niemand den Compiler darauf hinwies, dass Berechnungen in Festkommazahlen f√ºr uns gut geeignet sind, und er hat ehrlich gesagt alle Gleitkomma-Mathematik in Logik und Registern implementiert.  Wir m√ºssen dem Compiler erkl√§ren, was davon verlangt wird, und daf√ºr tauchen wir wieder in den Code ein. <br><br>  Zur Verwendung von Festkomma werden Vorlagenklassen implementiert. <br><br><img src="https://habrastorage.org/webt/0a/a8/dj/0aa8djn0cwvyf8tplhtay6lymdg.png"><br>  <i>Abbildung 21</i> <br><br>  In unseren eigenen Worten k√∂nnen wir Variablen verwenden, deren Bittiefe manuell auf ein Bit eingestellt wird.  F√ºr diejenigen, die in HDL schreiben, kann man sich nicht daran gew√∂hnen, aber C / C ++ - Programmierer werden wahrscheinlich ihre K√∂pfe umklammern.  Bittiefen, wie in MATLAB, wird in diesem Fall niemand sagen, und der Entwickler selbst muss die Anzahl der Bits z√§hlen. <br><br>  Mal sehen, wie es in der Praxis aussieht. <br><br>  Wir bearbeiten den Code wie folgt: <br><br><pre> <code class="cpp hljs">component ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; conv(ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; *data, ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; *kernel) { ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt;mult_res[<span class="hljs-number"><span class="hljs-number">16</span></span>]; ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt;summl; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> unroll for (int i = 0; i &lt; 16; i++) { mult_res[i] = data[i] * kernel[i]; } for (int i = 0; i &lt; 16; i++) { summl = summl+mult_res[i]; } return summl/16; }</span></span></code> </pre><br>  Und anstelle der gruseligen Nudeln aus Abbildung 20 erhalten wir diese Sch√∂nheit: <br><br> <a href=""><img src="https://habrastorage.org/webt/kg/v0/ot/kgv0ot9el2l5a3u4wawqsbw4hli.png"></a> <br>  <i>Abbildung 22</i> <br><br>  Leider passiert mit den verwendeten Ressourcen weiterhin etwas Seltsames. <br><br><img src="https://habrastorage.org/webt/my/dk/bk/mydkbkemq-dzzzhk53gky-zix00.png"><br>  <i>Abbildung 23</i> <br><br>  Eine detaillierte √úberpr√ºfung der Berichte zeigt jedoch, dass das Modul, das uns direkt interessiert, mehr als angemessen aussieht: <br><br> <a href=""><img src="https://habrastorage.org/webt/tn/t0/da/tnt0daffouamtkyozxnrnu_zoku.png"></a> <br>  <i>Abbildung 24</i> <br><br>  Der enorme Verbrauch an Registern und Blockspeicher ist mit einer gro√üen Anzahl von Peripheriemodulen verbunden.  Ich verstehe die tiefe Bedeutung ihrer Existenz immer noch nicht vollst√§ndig, und dies muss gekl√§rt werden, aber das Problem ist gel√∂st.  Im Extremfall k√∂nnen Sie ein f√ºr uns interessantes Modul sorgf√§ltig aus der allgemeinen Struktur des Projekts herausschneiden, um uns vor peripheren Modulen zu sch√ºtzen, die Ressourcen verschlingen. <br><br><h3>  Der dritte Test.  "√úbergang von RGB zu HSV" </h3><br>  Als ich anfing, diesen Artikel zu schreiben, hatte ich nicht erwartet, dass er so umfangreich sein w√ºrde.  Aber ich kann den dritten und den letzten im Rahmen dieses Artikels, ein Beispiel, nicht ablehnen. <br><br>  Erstens ist dies ein echtes Beispiel aus meiner Praxis, und aus diesem Grund begann ich, mich mit hochrangigen Entwicklungswerkzeugen zu befassen. <br><br>  Zweitens k√∂nnten wir anhand der ersten beiden Beispiele davon ausgehen, dass die Werkzeuge auf hoher Ebene die Aufgabe umso schlechter bew√§ltigen, je komplexer das Design ist. <br><br>  Ich m√∂chte zeigen, dass dieses Urteil falsch ist. Je komplexer die Aufgabe ist, desto mehr manifestieren sich die Vorteile von Entwicklungswerkzeugen auf hoher Ebene. <br><br>  Letztes Jahr, als ich an einem der Projekte arbeitete, mochte ich die bei Aliexpress gekaufte Kamera nicht, n√§mlich, dass die Farben nicht ges√§ttigt genug waren.  Eine der beliebtesten M√∂glichkeiten, die Farbs√§ttigung zu variieren, besteht darin, vom RGB-Farbraum zum HSV-Raum zu wechseln, wobei einer der Parameter die S√§ttigung ist.  Ich erinnere mich, wie ich die √úbergangsformel ge√∂ffnet und tief durchgeatmet habe ... Die Implementierung solcher Berechnungen in FPGA ist nichts Au√üergew√∂hnliches, aber es wird nat√ºrlich einige Zeit dauern, Code zu schreiben.  Die Formel f√ºr den Wechsel von RGB zu HSV lautet also wie folgt: <br><br><img src="https://habrastorage.org/webt/z_/6u/_t/z_6u_tufgvs_wkbknmisu_gtn1e.png"><br>  <i>Abbildung 25</i> <br><br>  Die Implementierung eines solchen Algorithmus in FPGA wird nicht Tage, sondern Stunden dauern, und all dies muss aufgrund der Besonderheiten von HDL sehr sorgf√§ltig durchgef√ºhrt werden, und die Implementierung in C ++ oder MATLAB wird, glaube ich, Minuten dauern. <br><br>  In C ++ k√∂nnen Sie Code direkt in die Stirn schreiben und trotzdem ein funktionierendes Ergebnis erhalten. <br>  Ich habe die folgende Option in C ++ geschrieben <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">color_space</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> rh; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> gs; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> bv; }; <span class="hljs-function"><span class="hljs-function">component color_space </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rgb2hsv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(color_space rgb_0)</span></span></span><span class="hljs-function"> </span></span>{ color_space hsv; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h,s,v,r,g,b; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> max_col, min_col; r = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(rgb_0.rh)/<span class="hljs-number"><span class="hljs-number">255</span></span>; g = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(rgb_0.gs)/<span class="hljs-number"><span class="hljs-number">255</span></span>; b = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(rgb_0.bv)/<span class="hljs-number"><span class="hljs-number">255</span></span>; max_col = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(r,g),b); min_col = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(r,g),b); <span class="hljs-comment"><span class="hljs-comment">// H if (max_col == min_col) h = 0; else if (max_col==r &amp;&amp; g&gt;=b) h = 60*((gb)/(max_col-min_col)); else if (max_col==r &amp;&amp; g&lt;b) h = 60*((gb)/(max_col-min_col))+360; else if (max_col==g) h = 60*((br)/(max_col-min_col))+120; else if (max_col==b) h = 60*((rg)/(max_col-min_col))+240; // S if (max_col == 0) s = 0; else { s = (1-(min_col/max_col))*100; } // V v = max_col*100; hsv.rh = static_cast&lt;char&gt;(h); hsv.gs = static_cast&lt;char&gt;(s); hsv.bv = static_cast&lt;char&gt;(v); return hsv; }</span></span></code> </pre><br>  Und Quartus hat das Ergebnis erfolgreich implementiert, wie aus der Tabelle der verwendeten Ressourcen hervorgeht. <br><br><img src="https://habrastorage.org/webt/us/bs/qx/usbsqx6dg4ncv_kkefii6ul8msq.png"><br>  <i>Abbildung 26</i> <br><br>  Die Frequenz ist sehr gut. <br><br><img src="https://habrastorage.org/webt/t-/tk/hd/t-tkhdxq-d1yr7uo28m5_k7sfaa.png"><br>  <i>Abbildung 27</i> <br><br>  Mit dem HDL-Codierer sind die Dinge etwas komplizierter. <br><br>  Um den Artikel nicht aufzublasen, werde ich kein M-Skript f√ºr diese Aufgabe bereitstellen, es sollte keine Schwierigkeiten verursachen.  Ein in die Stirn geschriebenes M-Skript kann kaum erfolgreich verwendet werden. Wenn Sie jedoch den Code bearbeiten und die Stellen f√ºr das Pipelining korrekt angeben, erhalten Sie ein Arbeitsergebnis.  Dies dauert nat√ºrlich einige zehn Minuten, aber nicht Stunden. <br><br>  C++          ,       . <br><br>  ,    ,   ,    ,     ‚Äî   ,         FPGA      ,     HDL. <br><br><h2>  Fazit </h2><br>     . <br><br> ,     ,    ,      . <br><br>    ,   ,   .     ,    ,      HDL,  . <br><br>   ,    FPGA        FPGA       .           . <br><br>    ,    ‚Äî          FPGA. <br><br>  HLS compiler     : ,     ,  ,      ‚Äúbest practices‚Äù  ..  MATLAB,    ,     GUI , , ,      ,    ,     . <br><br>     ?   ‚Äî  Intel HLS compiler.         . HDL coder          .   ,  HDL coder   ,    ,       .   HLS,   ,  ,   FPGA     ,         . <br><br>   Xilinx ,       ‚Äî              FPGA.        ,  , Verilog/VHDL   ,    .          (    ),       . <br><br>          ?  ,      ,      ,      HDL   . <br><br>      ,              ,        ,      ,    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455668/">https://habr.com/ru/post/de455668/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455650/index.html">Wie wir ein neuronales Netzwerk trainiert haben, um Schrauben zu klassifizieren</a></li>
<li><a href="../de455652/index.html">Deep Learning gegen gesunden Menschenverstand: Entwicklung eines Chat-Bots</a></li>
<li><a href="../de455658/index.html">Legend√§rer Intel Core i7-2600K: Testen von Sandy Bridge im Jahr 2019 (Teil 3)</a></li>
<li><a href="../de455662/index.html">Gro√ües mechanisches Display mit Nockenmechanismus als Decoder</a></li>
<li><a href="../de455666/index.html">Aufbau von Outbound Sales in einem IT-Service-Unternehmen</a></li>
<li><a href="../de455670/index.html">Wie 3D-Drucker Knochen, Blutgef√§√üe und Organe drucken</a></li>
<li><a href="../de455676/index.html">Ist die Blase des maschinellen Lernens geplatzt oder hat eine neue Morgend√§mmerung begonnen?</a></li>
<li><a href="../de455678/index.html">Auf dem Weg von Sergej Pawlowitsch Korolev. Modernes russisches bemanntes Projekt. Teil 1. "F√∂deration"</a></li>
<li><a href="../de455682/index.html">Wie viel geben Sie f√ºr die Infrastruktur aus? Und wie kann man das sparen?</a></li>
<li><a href="../de455684/index.html">Warum haben wir einen Hackathon f√ºr Tester durchgef√ºhrt?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>