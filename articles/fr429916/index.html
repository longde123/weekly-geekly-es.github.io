<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😔 🐭 👨🏻‍🎤 Comment construire et construire 🙆🏼 🐚 🚝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Contexte 


 Ayant rencontré à de nombreux endroits dans le développement Javascript des situations où il était nécessaire de valider des valeurs, il ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment construire et construire</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429916/"><h2 id="predystoriya">  Contexte </h2><br><p>  Ayant rencontré à de nombreux endroits dans le développement Javascript des situations où il était nécessaire de valider des valeurs, il est devenu clair qu'il était nécessaire de résoudre ce problème.  À cet effet, la tâche suivante a été définie: <br>  Développer une bibliothèque qui permettra: </p><br><ul><li>  valider <strong>les types de données</strong> ; </li><li>  définir <strong>des valeurs par défaut</strong> au lieu de champs ou d'éléments non valides; </li><li>  <strong>supprimer des parties non valides d'un</strong> objet ou d'un tableau; </li><li>  Recevoir <strong>un message d'erreur</strong> </li></ul><br><p>  Dont la base sera: </p><br><ul><li>  Facile à apprendre </li><li>  Lisibilité du code reçu. </li><li>  Facilité de modification du code </li></ul><br><p>  Pour atteindre ces objectifs, une bibliothèque de validation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="quatuor">quatuor</a> a été développée. </p><a name="habracut"></a><br><h2 id="osnovnye-kirpichi-validacii">  Briques de validation de base </h2><br><p>  Au cœur de la plupart des systèmes conçus pour être applicables à un large éventail de tâches se trouvent les <strong>éléments</strong> les plus simples: actions, données et algorithmes.  Ainsi que les méthodes de leur <strong>composition</strong> - afin d'assembler quelque chose à partir des éléments les plus simples les plus complexes pour résoudre des problèmes plus complexes. </p><br><h3 id="validator">  Validateur </h3><br><p>  La bibliothèque du quatuor est basée sur le concept d'un <strong>validateur</strong> .  Les validateurs de cette bibliothèque sont des fonctions du formulaire suivant </p><br><pre><code class="plaintext hljs">function validator( value: any, { key: string|int, parent: any }, { key: string|int, parent: any }, ... ): boolean</code> </pre> <br><p>  Il y a plusieurs choses dans cette définition qui devraient être décrites plus en détail: </p><br><p>  <strong><code>function(...): boolean</code></strong> - dit que le validateur - calcule le résultat de la validation, et le résultat de la validation est une valeur booléenne - <strong>vrai</strong> ou <strong>faux</strong> , respectivement <strong>valide</strong> ou <strong>non valide</strong> </p><br><p>  <strong><code>value: any</code></strong> - indique que le validateur - calcule le résultat de la validation d'une <strong>valeur</strong> , qui peut être n'importe quelle valeur javascript.  Le validateur attribue la <strong>valeur validée</strong> à valide ou non valide. </p><br><p>  <strong><code>{ key: string|int, parent: any }, ...</code></strong> - indique que la valeur validée peut être dans des contextes différents selon le niveau d'imbrication de la valeur.  Montrons-le avec des exemples </p><br><p>  Exemple de valeur <strong>sans aucun contexte</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">//         . //         : const isValueValid = validator(4)</span></span></code> </pre> <br><p>  Exemple de valeur <b>dans un contexte de tableau</b> </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  0 1 2 3 4 const arr = [1, 2, 3, value, 5] //       (k): 3 //      : [1, 2, 3, value, 5] //    value -      const isValueValid = validator(4, { key: 3, parent: [1,2,3,4,5] })</span></span></code> </pre> <br><p>  Exemple de valeur <b>dans le contexte d'un objet</b> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> } <span class="hljs-comment"><span class="hljs-comment">//        'c' //       : { a: 1, b: 2, c: 4, d: 8 } //    value -   //   : const isValueValid = validator(4, { key: 'c', parent: { a: 1, b: 2, c: 4, d: 8 } })</span></span></code> </pre> <br><p>  Étant donné que les structures d'un objet peuvent avoir une imbrication plus importante, il est logique de parler de <b>divers contextes</b> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrOfObj = [{ <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> }, <span class="hljs-comment"><span class="hljs-comment">// ... ] //   c     'c' //    : { a: 1, b: 2, c: 4, d: 8 } //        arrOfObj, //       0. //    value -      const isValueValid = validator( 4, { key: 'c', parent: { a: 1, b: 2, c: 4, d: 8 } } { key: 0, parent: [{ a: 1, b: 2, c: 4, d: 8 }] } )</span></span></code> </pre> <br><p>  Et ainsi de suite. </p><br><div class="spoiler">  <b class="spoiler_title">À propos de la similitude avec les méthodes de tableau</b> <div class="spoiler_text"><p>  Cette définition d'un validateur devrait vous rappeler la définition des fonctions qui sont passées en argument aux méthodes de tableau, telles que: <strong>carte, filtre, certains, tous</strong> , etc. </p><br><ul><li>  Le premier argument de ces fonctions est <strong>un élément de tableau.</strong> </li><li>  Le deuxième argument est l' <strong>indice de l'élément.</strong> </li><li>  Le troisième argument est <strong>le tableau lui-même.</strong> </li></ul><br><p>  Le validateur dans ce cas est une fonction plus généralisée - il prend non seulement l'index de l'élément dans le tableau et le tableau, mais aussi l'index du tableau - dans son parent et son parent, et ainsi de suite. </p></div></div><br><h3 id="chto-nam-stoit-dom-postroit">  Que devons-nous construire une maison? </h3><br><p>  Les briques décrites ci-dessus ne se distinguent pas des autres <em>"solutions de pierre"</em> qui reposent sur la <em>"plage" de la</em> béquille javascript.  Par conséquent, construisons à partir d'eux quelque chose de plus cohérent et intéressant.  Pour cela, nous avons une <strong>composition</strong> . </p><br><h3 id="kak-postroit-neboskryob-validacii-obektov">  Comment construire un gratte-ciel de validation d'objet? </h3><br><p>  D'accord, il serait pratique de valider les objets de telle manière que la description de la validation corresponde à la description de l'objet.  Pour cela, nous utiliserons la <strong>composition d'objet des validateurs</strong> .  Cela ressemble à ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    quartet const quartet = require('quartet') //    (v -  validator) const v = quartet() //      , //     const objectSchema = { a: a =&gt; typeof a ==='string', //   'string' b: b =&gt; typeof b === 'number', //   'number' // ... } const compositeObjValidator = v(objectSchema) const obj = { a: 'some text', b: 2 } const isObjValid = compositeObjValidator(obj) console.log(isObjValid) // =&gt; true</span></span></code> </pre> <br><p>  Comme vous pouvez le voir, à partir de différentes briques de validateur définies pour des champs spécifiques, nous pouvons assembler un validateur d'objet - un "petit bâtiment", qui est encore assez encombré - mais mieux que sans lui.  Pour cela, nous utilisons le compositeur de validateurs <code>v</code> .  <strong>A chaque fois, rencontrant le littéral objet <code>v</code> à la place du validateur, il le considérera comme une composition objet, le transformant en valideur objet dans ses domaines.</strong> </p><br><p>  Parfois, nous <strong>ne pouvons pas décrire tous les domaines</strong> .  Par exemple, lorsqu'un objet est un dictionnaire de données: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quartet = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'quartet'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> v = quartet() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isStringValidator = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> name === <span class="hljs-string"><span class="hljs-string">'string'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keyValueValidator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, { key }</span></span></span><span class="hljs-function">) =&gt;</span></span> value.length === <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; key.length === <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dictionarySchema= { <span class="hljs-attr"><span class="hljs-attr">dictionaryName</span></span>: isStringValidator, ...v.rest(keyValueValidator) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compositeObjValidator = v(dictionarySchema) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">dictionaryName</span></span>: <span class="hljs-string"><span class="hljs-string">'next letter'</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-string"><span class="hljs-string">'d'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isObjValid = compositeObjValidator(obj) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(isObjValid) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true const obj2 = { dictionaryName: 'next letter', b: 'a', a: 'invalid value', notValidKey: 'a' } const isObj2Valid = compositeObjValidator(obj2) console.log(isObj2Valid) // =&gt; false</span></span></code> </pre> <br><h3 id="kak-pereispolzovat-stroitelnye-resheniya">  Comment réutiliser les solutions de construction? </h3><br><p>  Comme nous l'avons vu ci-dessus, il est nécessaire de réutiliser des validateurs simples.  Dans ces exemples, nous avons déjà dû utiliser le "validateur de type de chaîne" deux fois déjà. </p><br><p>  Afin de raccourcir l'enregistrement et d'augmenter sa lisibilité, la bibliothèque de quatuors utilise des synonymes de chaînes de validateurs.  <strong>Chaque fois qu'un compositeur de validateur rencontre une chaîne à l'endroit où le validateur doit être, il recherche le validateur dans le dictionnaire et l'utilise</strong> . </p><br><p>  Par défaut, les valideurs les plus courants sont déjà définis dans la bibliothèque. </p><br><p>  Considérez les exemples suivants: </p><br><pre> <code class="javascript hljs">v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>)(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true v('number')('1') // =&gt; false v('string')('1') // =&gt; true v('string')(null) // =&gt; false v('null')(null) // =&gt; true v('object')(null) // =&gt; true v('object!')(null) // =&gt; false // ...</span></span></code> </pre> <br><p>  et bien d'autres décrits dans la <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="documentation">documentation</a></strong> . </p><br><h3 id="kazhdoy-arke---svoy-vid-kirpichey">  Chaque arc a son propre type de briques? </h3><br><p>  Le compositeur de validateur (fonction <code>v</code> ) est également une fabrique de validateurs.  En ce sens qu'il contient de nombreuses méthodes utiles qui renvoient </p><br><ul><li>  validateurs de fonction </li><li>  valeurs que le compositeur percevra comme des schémas de création de validateurs </li></ul><br><p>  Par exemple, regardons la validation du tableau: le plus souvent, elle consiste à vérifier le type du tableau et à vérifier tous ses éléments.  Nous utiliserons pour cela la méthode <code>v.arrayOf(elementValidator)</code> .  Par exemple, prenez un tableau de points avec des noms. </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [ {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'B'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'C'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'D'</span></span>}, ]</code> </pre> <br><p>  Puisqu'un tableau de points est un tableau d'objets, il est judicieux d'utiliser la composition d'objets pour valider les éléments du tableau. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> namedPointSchema = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-comment"><span class="hljs-comment">// number -       y: 'number', name: 'string' // string -       }</span></span></code> </pre> <br><p>  Maintenant, en utilisant la méthode d'usine <code>v.arrayOf</code> , créez un validateur pour l'ensemble du tableau. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isArrayValid = v.arrayOf({ <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span> })</code> </pre> <br><p>  Voyons comment fonctionne ce validateur: </p><br><pre> <code class="javascript hljs">isArrayValid(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; false isArrayValid(null) // =&gt; false isArrayValid([]) // =&gt; true isArrayValid([1, 2, 3]) // =&gt; false isArrayValid([ {x: 1, y: 1, name: 'A'}, {x: 2, y: 1, name: 'B'}, {x: -1, y: 2, name: 'C'}, {x: 1, y: 3, name: 'D'}, ]) // =&gt; true</span></span></code> </pre> <br><p>  Ceci n'est qu'une des méthodes d'usine, chacune étant décrite dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="documentation">documentation.</a> </p><br><p>  Comme vous l'avez vu ci-dessus, <code>v.rest</code> également une méthode d'usine qui renvoie une composition d'objet qui vérifie tous les champs non spécifiés dans la composition d'objet.  Cela signifie qu'il peut être intégré dans une autre composition d'objet à l'aide de l' <code>spread-operator</code> . </p><br><p>  Citons comme exemple l'utilisation de plusieurs d'entre elles: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    quartet const quartet = require('quartet') //    (v -  validator) const v = quartet() //   ,    const max = { name: 'Maxim', sex: 'male', age: 34, status: 'grandpa', friends: [ { name: 'Dima', friendDuration: '1 year'}, { name: 'Semen', friendDuration: '3 months'} ], workExperience: 2 } //  ,   "" , // ""  , ""   -  const nameSchema = v.and( 'not-empty', 'string', //   name =&gt; name[0].toUpperCase() === name[0] // - ) const maxSchema = { name: nameSchema, //       sex: v.enum('male', 'female'), //  -   . //       "" age: v.and('non-negative', 'safe-integer'), status: v.enum('grandpa', 'non-grandpa'), friends: v.arrayOf({ name: nameSchema, //      friendDuration: v.regex(/^[1-9]\d? (years?|months?)$/) }), workExperience: v.and('non-negative', 'safe-integer') } console.log(v(maxSchema)(max)) // =&gt; true</span></span></code> </pre> <br><h3 id="byt-ili-ne-byt">  Être ou ne pas être? </h3><br><p>  Il arrive souvent que des données valides prennent diverses formes, par exemple: </p><br><ul><li>  <code>id</code> peut être un nombre ou une chaîne. </li><li>  L'objet <code>point</code> peut contenir ou non certaines coordonnées, selon la dimension. </li><li>  Et bien d'autres cas. </li></ul><br><p>  Pour organiser la validation des variantes, un type de composition distinct est fourni - la composition des variantes.  Il est représenté par un tableau de validateurs d'options possibles.  Un objet est considéré comme valide quand au moins l'un des validateurs signale sa validité. </p><br><p>  Prenons un exemple de validation d'identifiant: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isValidId = v([ v.and(<span class="hljs-string"><span class="hljs-string">'not-empty'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>), <span class="hljs-comment"><span class="hljs-comment">//       v.and('positive', 'safe-integer') //    ]) isValidId('') // =&gt; false isValidId('asdba32bas321ab321adb321abds546ba98s7') // =&gt; true isValidId(0) // =&gt; false isValidId(1) // =&gt; true isValidId(1123124) // =&gt; true</span></span></code> </pre> <br><p>  Exemple de validation de point: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isPointValid = v([ { <span class="hljs-comment"><span class="hljs-comment">//    -    x  dimension: v.enum(1), x: 'number', // v.rest    false // ,    -  ...v.rest(() =&gt; false) }, //   -    { dimension: v.enum(2), x: 'number', y: 'number', ...v.rest(() =&gt; false) }, //   - x, y  z { dimension: v.enum(3), x: 'number', y: 'number', z: 'number', ...v.rest(() =&gt; false) }, ]) // ,    ,      ,     -  -    isPointValid(1) // =&gt; false isPointValid(null) // =&gt; false isPointValid({ dimension: 1, x: 2 }) // =&gt; true isPointValid({ dimension: 1, x: 2, y: 3 //   }) // =&gt; false isPointValid({ dimension: 2, x: 2, y: 3 }) // =&gt; true isPointValid({ dimension: 3, x: 2, y: 3, z: 4 }) // =&gt; true // ...</span></span></code> </pre> <br><p>  Ainsi, <strong>chaque fois qu'un compositeur voit un tableau, il le considérera comme une composition des éléments de validation de ce tableau de telle manière que lorsque l'un d'entre eux considère la valeur comme valide, le calcul de validation s'arrêtera et la valeur sera reconnue comme valide.</strong> </p><br><p>  Comme on le voit, le compositeur considère non seulement la fonction validateur comme un validateur, mais aussi tout ce qui peut conduire à une fonction validateur. </p><br><table><thead><tr><th>  Type de validateur </th><th>  Exemple </th><th>  Tel que perçu par le compositeur </th></tr></thead><tbody><tr><td>  fonction de validation </td><td> <code>x =&gt; typeof x === 'bigint'</code> </td> <td>  vient d'appeler sur les valeurs nécessaires </td></tr><tr><td>  composition d'objet </td><td> <code>{ a: 'number' }</code> </td> <td>  crée une fonction de validation pour un objet en fonction des validateurs de champ spécifiés </td></tr><tr><td>  Composition des variantes </td><td> <code>['number', 'string']</code> </td> <td>  Crée une fonction de validation pour valider une valeur avec au moins une des options </td></tr><tr><td>  Résultats des appels de méthode d'usine </td><td> <code>v.enum('male', 'female')</code> </td> <td>  La plupart des méthodes d'usine renvoient des fonctions de validation (à l'exception de <code>v.rest</code> , qui retourne la composition des objets), elles sont donc traitées comme des fonctions de validation normales </td></tr></tbody></table><br><p>  Toutes ces options de validateur sont valides et peuvent être utilisées n'importe où dans le schéma où le validateur doit être. </p><br><p>  Par conséquent, le schéma de travail est toujours le suivant: <code>v(schema)</code> renvoie une fonction de validation.  Ensuite, cette fonction de validation est appelée sur des valeurs spécifiques: <br> <code>v(schema)(value[, ...parents])</code> </p> <br><h2 id="u-vas-avarii-na-stroyke-byli">  Avez-vous eu des accidents sur le chantier? </h2><br><p>  <em>- Pas encore, pas un</em> <br>  <em>- Ils le feront!</em> </p><br><p>  Il arrive que les données soient invalides et nous devons être en mesure de déterminer la cause de l'invalide. </p><br><p>  Pour cela, la bibliothèque de quatuors fournit un mécanisme d' <em>explication</em> .  Elle consiste en ce que dans le cas où le validateur, qu'il soit interne ou externe, détecte la validité des données vérifiées, il doit envoyer une <em>note explicative</em> . </p><br><p>  À ces fins, le deuxième argument du compositeur de validateurs <code>v</code> .  Il ajoute l'effet secondaire de l'envoi d'une <em>note explicative</em> au tableau <code>v.explanation</code> en cas de données non valides. </p><br><p>  Par exemple, laissez-nous valider un tableau et souhaitons connaître le nombre de tous les éléments invalides et leur valeur: </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   -     //   const getExplanation = (value, { key: index }) =&gt; ({ invalidValue: value, index }) // ,       . //         v.explanation //    const arrValidator = v.arrayOf( v( 'number', //   getExplanation //   "",   "" ) ) // ,     ""  //     ,     //         //   ,       const explainableArrValidator = v(arrValidator, 'this array is not valid') const arr = [1, 2, 3, 4, '5', '6', 7, '8'] explainableArrValidator(arr) // =&gt; false v.explanation // [ // { invalidValue: '5', index: 4 }, // { invalidValue: '6', index: 5 }, // { invalidValue: '8', index: 7 }, // 'this array is not valid' // ]</span></span></code> </pre> <br><p>  Comme vous pouvez le voir, le choix de l'explication dépend de la tâche.  Parfois, ce n'est même pas nécessaire. </p><br><p>  Parfois, nous devons faire quelque chose avec des champs invalides.  Dans de tels cas, il est logique d'utiliser le nom du champ non valide comme <em>explication</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> objSchema = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>), <span class="hljs-attr"><span class="hljs-attr">b</span></span>: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>), <span class="hljs-attr"><span class="hljs-attr">c</span></span>: v(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isObjValid = v(objSchema) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> invalidObj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> } isObjValid(invalidObj) <span class="hljs-comment"><span class="hljs-comment">// =&gt; false v.explanation // ['b', 'c'] //     console.error(`${v.explanation.join(', ')} is not valid`) // =&gt; b, c is not valid //       (. ) invalidObj = v.omitInvalidProps(objSchema)(invalidObj) console.log(invalidObj) // =&gt; { a: 1 }</span></span></code> </pre> <br><p>  Ayant ce mécanisme d'explication, vous pouvez implémenter tout comportement associé aux résultats de la validation. </p><br><p>  Une explication peut être n'importe quoi: </p><br><ul><li>  un objet contenant les informations nécessaires; </li><li>  fonction qui corrige l'erreur.  ( <code>getExplanation =&gt; function(invalid): valid</code> ); </li><li>  nom du champ non valide ou index de l'élément non valide; </li><li>  code d'erreur </li><li>  et tout cela suffit à votre imagination. </li></ul><br><h2 id="chto-delat-kogda-delo-ne-stroitsya">  Que faire quand les choses ne se construisent pas? </h2><br><p>  La correction des erreurs de validation n'est pas une tâche rare.  À ces fins, la bibliothèque utilise des validateurs avec un effet secondaire qui se souvient du lieu de l'erreur et de la façon de la corriger. </p><br><ul><li>  <code>v.default(validator, value)</code> - retourne un validateur qui se souvient d'une valeur invalide, et au moment d'appeler <code>v.fix</code> - définit la valeur par défaut </li><li>  <code>v.filter(validator)</code> - retourne un validateur qui se souvient d'une valeur invalide, et au moment d'appeler <code>v.fix</code> - supprime cette valeur du parent </li><li>  <code>v.addFix(validator, fixFunc)</code> - renvoie un validateur qui se souvient d'une valeur non valide, et au moment d'appeler <code>v.fix</code> - appelle fixFunc avec des paramètres (valeur, {clé, parent}, ...).  <code>fixFunc</code> - doit muter l'un des partenaires - pour changer la valeur </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toPositive = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">negativeValue, { key, parent }</span></span></span><span class="hljs-function">) =&gt;</span></span> { parent[key] = -negativeValue } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> objSchema = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-attr"><span class="hljs-attr">b</span></span>: v.filter(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-attr"><span class="hljs-attr">c</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'array'</span></span>, []), <span class="hljs-attr"><span class="hljs-attr">d</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, invalidValue =&gt; <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(invalidValue)), <span class="hljs-comment"><span class="hljs-comment">//    pos: v.and( v.default('number', 0), //     -  0 v.addFix('non-negative', toPositive) //     -   ) } const invalidObj = { a: 1, b: 2, c: 3, d: '4', pos: -3 } v.resetExplanation() //   v() v(objSchema)(invalidObj) // =&gt; false // v.hasFixes() =&gt; true const validObj = v.fix(invalidObj) console.log(validObj) // =&gt; { a: 1, b: '', c: [], d: 4 }</span></span></code> </pre> <br><h3 id="po-hozyaystvu-eschyo-prigoditsya">  Les tâches sont toujours utiles </h3><br><p>  Il existe également des méthodes utilitaires pour les actions de validation dans cette bibliothèque: </p><br><table><thead><tr><th>  La méthode </th><th>  Résultat </th></tr></thead><tbody><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="`v.throwError`"><code>v.throwError</code></a> </td> <td>  S'il n'est pas valide, lance une TypeError avec le message donné. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="`v.omitInvalidItems`"><code>v.omitInvalidItems</code></a> </td> <td>  Renvoie un nouveau tableau (ou objet dictionnaire) sans éléments (champs) non valides. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="`v.omitInvalidProps`"><code>v.omitInvalidProps</code></a> </td> <td>  Renvoie un nouvel objet sans champs non valides, selon le validateur d'objet spécifié. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="`v.validOr`"><code>v.validOr</code></a> </td> <td>  Renvoie la valeur si elle est valide, sinon elle la remplace par la valeur par défaut spécifiée. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>v.example</code></a> </td> <td>  Vérifie si les valeurs données correspondent au schéma.  S'ils ne correspondent pas, une erreur est générée.  Sert de documentation et de test de circuit </td></tr></tbody></table><br><h2 id="rezultaty">  Résultats </h2><br><p>  Les tâches ont été résolues de la manière suivante: </p><br><table><thead><tr><th>  Défi </th><th>  Solution </th></tr></thead><tbody><tr><td>  Validation du type de données </td><td>  Validateurs nommés par défaut. </td></tr><tr><td>  Valeurs par défaut </td><td> <code>v.default</code> </td> </tr><tr><td>  Suppression de pièces invalides </td><td>  <code>v.filter</code> , <code>v.omitInvalidItems</code> et <code>v.omitInvalidProps</code> . </td></tr><tr><td>  Facile à apprendre </td><td>  Validateurs simples, façons simples de les composer en validateurs complexes. </td></tr><tr><td>  Lisibilité du code </td><td>  L'un des objectifs de la bibliothèque était de comparer les schémas de validation eux-mêmes </td></tr><tr><td>  objets validés. </td></tr><tr><td>  Facilité de modification </td><td>  Après avoir maîtrisé les éléments des compositions et utilisé vos propres fonctions de validation - changer le code est assez simple. </td></tr><tr><td>  Message d'erreur </td><td>  Explication sous forme de message d'erreur.  Ou calcul du code d'erreur basé sur des explications. </td></tr></tbody></table><br><h2 id="posleslovie">  Postface </h2><br><p>  Cette solution a été conçue pour créer rapidement et facilement des fonctions de validation avec la possibilité d'intégrer des fonctions de validation personnalisées.  Par conséquent, s'il y en a, toutes les corrections, critiques, options d'amélioration de la part de ceux qui ont lu cet article sont les bienvenues.  Merci de votre attention. <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr429916/">https://habr.com/ru/post/fr429916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr429904/index.html">Histoires drôles et tristes sur le développement de jeux informatiques</a></li>
<li><a href="../fr429908/index.html">Comment utiliser les coroutines dans les aliments et dormir paisiblement la nuit</a></li>
<li><a href="../fr429910/index.html">AppsConf Rises</a></li>
<li><a href="../fr429912/index.html">Développement de bibliothèque: de l'API à la version publique</a></li>
<li><a href="../fr429914/index.html">OpenSceneGraph: graphique de scène et pointeurs intelligents</a></li>
<li><a href="../fr429918/index.html">Monde virtuel Intel. Partie 2: SMP</a></li>
<li><a href="../fr429920/index.html">Tragicomedy in NaN Acts: comment nous avons créé un jeu sur JS et l'avons sorti sur Steam</a></li>
<li><a href="../fr429922/index.html">Comment transformer un projet simple en une construction à long terme ou supprimer tout ce qui n'est pas nécessaire</a></li>
<li><a href="../fr429928/index.html">Tout ce que vous devez savoir sur le stress et les émotions fortes</a></li>
<li><a href="../fr429930/index.html">Splunk Dépannage facile des applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>