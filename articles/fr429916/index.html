<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòî üê≠ üë®üèª‚Äçüé§ Comment construire et construire üôÜüèº üêö üöù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Contexte 


 Ayant rencontr√© √† de nombreux endroits dans le d√©veloppement Javascript des situations o√π il √©tait n√©cessaire de valider des valeurs, il ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment construire et construire</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429916/"><h2 id="predystoriya">  Contexte </h2><br><p>  Ayant rencontr√© √† de nombreux endroits dans le d√©veloppement Javascript des situations o√π il √©tait n√©cessaire de valider des valeurs, il est devenu clair qu'il √©tait n√©cessaire de r√©soudre ce probl√®me.  √Ä cet effet, la t√¢che suivante a √©t√© d√©finie: <br>  D√©velopper une biblioth√®que qui permettra: </p><br><ul><li>  valider <strong>les types de donn√©es</strong> ; </li><li>  d√©finir <strong>des valeurs par d√©faut</strong> au lieu de champs ou d'√©l√©ments non valides; </li><li>  <strong>supprimer des parties non valides d'un</strong> objet ou d'un tableau; </li><li>  Recevoir <strong>un message d'erreur</strong> </li></ul><br><p>  Dont la base sera: </p><br><ul><li>  Facile √† apprendre </li><li>  Lisibilit√© du code re√ßu. </li><li>  Facilit√© de modification du code </li></ul><br><p>  Pour atteindre ces objectifs, une biblioth√®que de validation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="quatuor">quatuor</a> a √©t√© d√©velopp√©e. </p><a name="habracut"></a><br><h2 id="osnovnye-kirpichi-validacii">  Briques de validation de base </h2><br><p>  Au c≈ìur de la plupart des syst√®mes con√ßus pour √™tre applicables √† un large √©ventail de t√¢ches se trouvent les <strong>√©l√©ments</strong> les plus simples: actions, donn√©es et algorithmes.  Ainsi que les m√©thodes de leur <strong>composition</strong> - afin d'assembler quelque chose √† partir des √©l√©ments les plus simples les plus complexes pour r√©soudre des probl√®mes plus complexes. </p><br><h3 id="validator">  Validateur </h3><br><p>  La biblioth√®que du quatuor est bas√©e sur le concept d'un <strong>validateur</strong> .  Les validateurs de cette biblioth√®que sont des fonctions du formulaire suivant </p><br><pre><code class="plaintext hljs">function validator( value: any, { key: string|int, parent: any }, { key: string|int, parent: any }, ... ): boolean</code> </pre> <br><p>  Il y a plusieurs choses dans cette d√©finition qui devraient √™tre d√©crites plus en d√©tail: </p><br><p>  <strong><code>function(...): boolean</code></strong> - dit que le validateur - calcule le r√©sultat de la validation, et le r√©sultat de la validation est une valeur bool√©enne - <strong>vrai</strong> ou <strong>faux</strong> , respectivement <strong>valide</strong> ou <strong>non valide</strong> </p><br><p>  <strong><code>value: any</code></strong> - indique que le validateur - calcule le r√©sultat de la validation d'une <strong>valeur</strong> , qui peut √™tre n'importe quelle valeur javascript.  Le validateur attribue la <strong>valeur valid√©e</strong> √† valide ou non valide. </p><br><p>  <strong><code>{ key: string|int, parent: any }, ...</code></strong> - indique que la valeur valid√©e peut √™tre dans des contextes diff√©rents selon le niveau d'imbrication de la valeur.  Montrons-le avec des exemples </p><br><p>  Exemple de valeur <strong>sans aucun contexte</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">//         . //         : const isValueValid = validator(4)</span></span></code> </pre> <br><p>  Exemple de valeur <b>dans un contexte de tableau</b> </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  0 1 2 3 4 const arr = [1, 2, 3, value, 5] //       (k): 3 //      : [1, 2, 3, value, 5] //    value -      const isValueValid = validator(4, { key: 3, parent: [1,2,3,4,5] })</span></span></code> </pre> <br><p>  Exemple de valeur <b>dans le contexte d'un objet</b> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> } <span class="hljs-comment"><span class="hljs-comment">//        'c' //       : { a: 1, b: 2, c: 4, d: 8 } //    value -   //   : const isValueValid = validator(4, { key: 'c', parent: { a: 1, b: 2, c: 4, d: 8 } })</span></span></code> </pre> <br><p>  √âtant donn√© que les structures d'un objet peuvent avoir une imbrication plus importante, il est logique de parler de <b>divers contextes</b> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrOfObj = [{ <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> }, <span class="hljs-comment"><span class="hljs-comment">// ... ] //   c     'c' //    : { a: 1, b: 2, c: 4, d: 8 } //        arrOfObj, //       0. //    value -      const isValueValid = validator( 4, { key: 'c', parent: { a: 1, b: 2, c: 4, d: 8 } } { key: 0, parent: [{ a: 1, b: 2, c: 4, d: 8 }] } )</span></span></code> </pre> <br><p>  Et ainsi de suite. </p><br><div class="spoiler">  <b class="spoiler_title">√Ä propos de la similitude avec les m√©thodes de tableau</b> <div class="spoiler_text"><p>  Cette d√©finition d'un validateur devrait vous rappeler la d√©finition des fonctions qui sont pass√©es en argument aux m√©thodes de tableau, telles que: <strong>carte, filtre, certains, tous</strong> , etc. </p><br><ul><li>  Le premier argument de ces fonctions est <strong>un √©l√©ment de tableau.</strong> </li><li>  Le deuxi√®me argument est l' <strong>indice de l'√©l√©ment.</strong> </li><li>  Le troisi√®me argument est <strong>le tableau lui-m√™me.</strong> </li></ul><br><p>  Le validateur dans ce cas est une fonction plus g√©n√©ralis√©e - il prend non seulement l'index de l'√©l√©ment dans le tableau et le tableau, mais aussi l'index du tableau - dans son parent et son parent, et ainsi de suite. </p></div></div><br><h3 id="chto-nam-stoit-dom-postroit">  Que devons-nous construire une maison? </h3><br><p>  Les briques d√©crites ci-dessus ne se distinguent pas des autres <em>"solutions de pierre"</em> qui reposent sur la <em>"plage" de la</em> b√©quille javascript.  Par cons√©quent, construisons √† partir d'eux quelque chose de plus coh√©rent et int√©ressant.  Pour cela, nous avons une <strong>composition</strong> . </p><br><h3 id="kak-postroit-neboskryob-validacii-obektov">  Comment construire un gratte-ciel de validation d'objet? </h3><br><p>  D'accord, il serait pratique de valider les objets de telle mani√®re que la description de la validation corresponde √† la description de l'objet.  Pour cela, nous utiliserons la <strong>composition d'objet des validateurs</strong> .  Cela ressemble √† ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    quartet const quartet = require('quartet') //    (v -  validator) const v = quartet() //      , //     const objectSchema = { a: a =&gt; typeof a ==='string', //   'string' b: b =&gt; typeof b === 'number', //   'number' // ... } const compositeObjValidator = v(objectSchema) const obj = { a: 'some text', b: 2 } const isObjValid = compositeObjValidator(obj) console.log(isObjValid) // =&gt; true</span></span></code> </pre> <br><p>  Comme vous pouvez le voir, √† partir de diff√©rentes briques de validateur d√©finies pour des champs sp√©cifiques, nous pouvons assembler un validateur d'objet - un "petit b√¢timent", qui est encore assez encombr√© - mais mieux que sans lui.  Pour cela, nous utilisons le compositeur de validateurs <code>v</code> .  <strong>A chaque fois, rencontrant le litt√©ral objet <code>v</code> √† la place du validateur, il le consid√©rera comme une composition objet, le transformant en valideur objet dans ses domaines.</strong> </p><br><p>  Parfois, nous <strong>ne pouvons pas d√©crire tous les domaines</strong> .  Par exemple, lorsqu'un objet est un dictionnaire de donn√©es: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quartet = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'quartet'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> v = quartet() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isStringValidator = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> name === <span class="hljs-string"><span class="hljs-string">'string'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keyValueValidator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, { key }</span></span></span><span class="hljs-function">) =&gt;</span></span> value.length === <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; key.length === <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dictionarySchema= { <span class="hljs-attr"><span class="hljs-attr">dictionaryName</span></span>: isStringValidator, ...v.rest(keyValueValidator) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compositeObjValidator = v(dictionarySchema) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">dictionaryName</span></span>: <span class="hljs-string"><span class="hljs-string">'next letter'</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-string"><span class="hljs-string">'d'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isObjValid = compositeObjValidator(obj) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(isObjValid) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true const obj2 = { dictionaryName: 'next letter', b: 'a', a: 'invalid value', notValidKey: 'a' } const isObj2Valid = compositeObjValidator(obj2) console.log(isObj2Valid) // =&gt; false</span></span></code> </pre> <br><h3 id="kak-pereispolzovat-stroitelnye-resheniya">  Comment r√©utiliser les solutions de construction? </h3><br><p>  Comme nous l'avons vu ci-dessus, il est n√©cessaire de r√©utiliser des validateurs simples.  Dans ces exemples, nous avons d√©j√† d√ª utiliser le "validateur de type de cha√Æne" deux fois d√©j√†. </p><br><p>  Afin de raccourcir l'enregistrement et d'augmenter sa lisibilit√©, la biblioth√®que de quatuors utilise des synonymes de cha√Ænes de validateurs.  <strong>Chaque fois qu'un compositeur de validateur rencontre une cha√Æne √† l'endroit o√π le validateur doit √™tre, il recherche le validateur dans le dictionnaire et l'utilise</strong> . </p><br><p>  Par d√©faut, les valideurs les plus courants sont d√©j√† d√©finis dans la biblioth√®que. </p><br><p>  Consid√©rez les exemples suivants: </p><br><pre> <code class="javascript hljs">v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>)(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true v('number')('1') // =&gt; false v('string')('1') // =&gt; true v('string')(null) // =&gt; false v('null')(null) // =&gt; true v('object')(null) // =&gt; true v('object!')(null) // =&gt; false // ...</span></span></code> </pre> <br><p>  et bien d'autres d√©crits dans la <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="documentation">documentation</a></strong> . </p><br><h3 id="kazhdoy-arke---svoy-vid-kirpichey">  Chaque arc a son propre type de briques? </h3><br><p>  Le compositeur de validateur (fonction <code>v</code> ) est √©galement une fabrique de validateurs.  En ce sens qu'il contient de nombreuses m√©thodes utiles qui renvoient </p><br><ul><li>  validateurs de fonction </li><li>  valeurs que le compositeur percevra comme des sch√©mas de cr√©ation de validateurs </li></ul><br><p>  Par exemple, regardons la validation du tableau: le plus souvent, elle consiste √† v√©rifier le type du tableau et √† v√©rifier tous ses √©l√©ments.  Nous utiliserons pour cela la m√©thode <code>v.arrayOf(elementValidator)</code> .  Par exemple, prenez un tableau de points avec des noms. </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [ {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'B'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'C'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'D'</span></span>}, ]</code> </pre> <br><p>  Puisqu'un tableau de points est un tableau d'objets, il est judicieux d'utiliser la composition d'objets pour valider les √©l√©ments du tableau. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> namedPointSchema = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-comment"><span class="hljs-comment">// number -       y: 'number', name: 'string' // string -       }</span></span></code> </pre> <br><p>  Maintenant, en utilisant la m√©thode d'usine <code>v.arrayOf</code> , cr√©ez un validateur pour l'ensemble du tableau. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isArrayValid = v.arrayOf({ <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span> })</code> </pre> <br><p>  Voyons comment fonctionne ce validateur: </p><br><pre> <code class="javascript hljs">isArrayValid(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; false isArrayValid(null) // =&gt; false isArrayValid([]) // =&gt; true isArrayValid([1, 2, 3]) // =&gt; false isArrayValid([ {x: 1, y: 1, name: 'A'}, {x: 2, y: 1, name: 'B'}, {x: -1, y: 2, name: 'C'}, {x: 1, y: 3, name: 'D'}, ]) // =&gt; true</span></span></code> </pre> <br><p>  Ceci n'est qu'une des m√©thodes d'usine, chacune √©tant d√©crite dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="documentation">documentation.</a> </p><br><p>  Comme vous l'avez vu ci-dessus, <code>v.rest</code> √©galement une m√©thode d'usine qui renvoie une composition d'objet qui v√©rifie tous les champs non sp√©cifi√©s dans la composition d'objet.  Cela signifie qu'il peut √™tre int√©gr√© dans une autre composition d'objet √† l'aide de l' <code>spread-operator</code> . </p><br><p>  Citons comme exemple l'utilisation de plusieurs d'entre elles: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    quartet const quartet = require('quartet') //    (v -  validator) const v = quartet() //   ,    const max = { name: 'Maxim', sex: 'male', age: 34, status: 'grandpa', friends: [ { name: 'Dima', friendDuration: '1 year'}, { name: 'Semen', friendDuration: '3 months'} ], workExperience: 2 } //  ,   "" , // ""  , ""   -  const nameSchema = v.and( 'not-empty', 'string', //   name =&gt; name[0].toUpperCase() === name[0] // - ) const maxSchema = { name: nameSchema, //       sex: v.enum('male', 'female'), //  -   . //       "" age: v.and('non-negative', 'safe-integer'), status: v.enum('grandpa', 'non-grandpa'), friends: v.arrayOf({ name: nameSchema, //      friendDuration: v.regex(/^[1-9]\d? (years?|months?)$/) }), workExperience: v.and('non-negative', 'safe-integer') } console.log(v(maxSchema)(max)) // =&gt; true</span></span></code> </pre> <br><h3 id="byt-ili-ne-byt">  √ätre ou ne pas √™tre? </h3><br><p>  Il arrive souvent que des donn√©es valides prennent diverses formes, par exemple: </p><br><ul><li>  <code>id</code> peut √™tre un nombre ou une cha√Æne. </li><li>  L'objet <code>point</code> peut contenir ou non certaines coordonn√©es, selon la dimension. </li><li>  Et bien d'autres cas. </li></ul><br><p>  Pour organiser la validation des variantes, un type de composition distinct est fourni - la composition des variantes.  Il est repr√©sent√© par un tableau de validateurs d'options possibles.  Un objet est consid√©r√© comme valide quand au moins l'un des validateurs signale sa validit√©. </p><br><p>  Prenons un exemple de validation d'identifiant: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isValidId = v([ v.and(<span class="hljs-string"><span class="hljs-string">'not-empty'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>), <span class="hljs-comment"><span class="hljs-comment">//       v.and('positive', 'safe-integer') //    ]) isValidId('') // =&gt; false isValidId('asdba32bas321ab321adb321abds546ba98s7') // =&gt; true isValidId(0) // =&gt; false isValidId(1) // =&gt; true isValidId(1123124) // =&gt; true</span></span></code> </pre> <br><p>  Exemple de validation de point: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isPointValid = v([ { <span class="hljs-comment"><span class="hljs-comment">//    -    x  dimension: v.enum(1), x: 'number', // v.rest    false // ,    -  ...v.rest(() =&gt; false) }, //   -    { dimension: v.enum(2), x: 'number', y: 'number', ...v.rest(() =&gt; false) }, //   - x, y  z { dimension: v.enum(3), x: 'number', y: 'number', z: 'number', ...v.rest(() =&gt; false) }, ]) // ,    ,      ,     -  -    isPointValid(1) // =&gt; false isPointValid(null) // =&gt; false isPointValid({ dimension: 1, x: 2 }) // =&gt; true isPointValid({ dimension: 1, x: 2, y: 3 //   }) // =&gt; false isPointValid({ dimension: 2, x: 2, y: 3 }) // =&gt; true isPointValid({ dimension: 3, x: 2, y: 3, z: 4 }) // =&gt; true // ...</span></span></code> </pre> <br><p>  Ainsi, <strong>chaque fois qu'un compositeur voit un tableau, il le consid√©rera comme une composition des √©l√©ments de validation de ce tableau de telle mani√®re que lorsque l'un d'entre eux consid√®re la valeur comme valide, le calcul de validation s'arr√™tera et la valeur sera reconnue comme valide.</strong> </p><br><p>  Comme on le voit, le compositeur consid√®re non seulement la fonction validateur comme un validateur, mais aussi tout ce qui peut conduire √† une fonction validateur. </p><br><table><thead><tr><th>  Type de validateur </th><th>  Exemple </th><th>  Tel que per√ßu par le compositeur </th></tr></thead><tbody><tr><td>  fonction de validation </td><td> <code>x =&gt; typeof x === 'bigint'</code> </td> <td>  vient d'appeler sur les valeurs n√©cessaires </td></tr><tr><td>  composition d'objet </td><td> <code>{ a: 'number' }</code> </td> <td>  cr√©e une fonction de validation pour un objet en fonction des validateurs de champ sp√©cifi√©s </td></tr><tr><td>  Composition des variantes </td><td> <code>['number', 'string']</code> </td> <td>  Cr√©e une fonction de validation pour valider une valeur avec au moins une des options </td></tr><tr><td>  R√©sultats des appels de m√©thode d'usine </td><td> <code>v.enum('male', 'female')</code> </td> <td>  La plupart des m√©thodes d'usine renvoient des fonctions de validation (√† l'exception de <code>v.rest</code> , qui retourne la composition des objets), elles sont donc trait√©es comme des fonctions de validation normales </td></tr></tbody></table><br><p>  Toutes ces options de validateur sont valides et peuvent √™tre utilis√©es n'importe o√π dans le sch√©ma o√π le validateur doit √™tre. </p><br><p>  Par cons√©quent, le sch√©ma de travail est toujours le suivant: <code>v(schema)</code> renvoie une fonction de validation.  Ensuite, cette fonction de validation est appel√©e sur des valeurs sp√©cifiques: <br> <code>v(schema)(value[, ...parents])</code> </p> <br><h2 id="u-vas-avarii-na-stroyke-byli">  Avez-vous eu des accidents sur le chantier? </h2><br><p>  <em>- Pas encore, pas un</em> <br>  <em>- Ils le feront!</em> </p><br><p>  Il arrive que les donn√©es soient invalides et nous devons √™tre en mesure de d√©terminer la cause de l'invalide. </p><br><p>  Pour cela, la biblioth√®que de quatuors fournit un m√©canisme d' <em>explication</em> .  Elle consiste en ce que dans le cas o√π le validateur, qu'il soit interne ou externe, d√©tecte la validit√© des donn√©es v√©rifi√©es, il doit envoyer une <em>note explicative</em> . </p><br><p>  √Ä ces fins, le deuxi√®me argument du compositeur de validateurs <code>v</code> .  Il ajoute l'effet secondaire de l'envoi d'une <em>note explicative</em> au tableau <code>v.explanation</code> en cas de donn√©es non valides. </p><br><p>  Par exemple, laissez-nous valider un tableau et souhaitons conna√Ætre le nombre de tous les √©l√©ments invalides et leur valeur: </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   -     //   const getExplanation = (value, { key: index }) =&gt; ({ invalidValue: value, index }) // ,       . //         v.explanation //    const arrValidator = v.arrayOf( v( 'number', //   getExplanation //   "",   "" ) ) // ,     ""  //     ,     //         //   ,       const explainableArrValidator = v(arrValidator, 'this array is not valid') const arr = [1, 2, 3, 4, '5', '6', 7, '8'] explainableArrValidator(arr) // =&gt; false v.explanation // [ // { invalidValue: '5', index: 4 }, // { invalidValue: '6', index: 5 }, // { invalidValue: '8', index: 7 }, // 'this array is not valid' // ]</span></span></code> </pre> <br><p>  Comme vous pouvez le voir, le choix de l'explication d√©pend de la t√¢che.  Parfois, ce n'est m√™me pas n√©cessaire. </p><br><p>  Parfois, nous devons faire quelque chose avec des champs invalides.  Dans de tels cas, il est logique d'utiliser le nom du champ non valide comme <em>explication</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> objSchema = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>), <span class="hljs-attr"><span class="hljs-attr">b</span></span>: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>), <span class="hljs-attr"><span class="hljs-attr">c</span></span>: v(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isObjValid = v(objSchema) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> invalidObj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> } isObjValid(invalidObj) <span class="hljs-comment"><span class="hljs-comment">// =&gt; false v.explanation // ['b', 'c'] //     console.error(`${v.explanation.join(', ')} is not valid`) // =&gt; b, c is not valid //       (. ) invalidObj = v.omitInvalidProps(objSchema)(invalidObj) console.log(invalidObj) // =&gt; { a: 1 }</span></span></code> </pre> <br><p>  Ayant ce m√©canisme d'explication, vous pouvez impl√©menter tout comportement associ√© aux r√©sultats de la validation. </p><br><p>  Une explication peut √™tre n'importe quoi: </p><br><ul><li>  un objet contenant les informations n√©cessaires; </li><li>  fonction qui corrige l'erreur.  ( <code>getExplanation =&gt; function(invalid): valid</code> ); </li><li>  nom du champ non valide ou index de l'√©l√©ment non valide; </li><li>  code d'erreur </li><li>  et tout cela suffit √† votre imagination. </li></ul><br><h2 id="chto-delat-kogda-delo-ne-stroitsya">  Que faire quand les choses ne se construisent pas? </h2><br><p>  La correction des erreurs de validation n'est pas une t√¢che rare.  √Ä ces fins, la biblioth√®que utilise des validateurs avec un effet secondaire qui se souvient du lieu de l'erreur et de la fa√ßon de la corriger. </p><br><ul><li>  <code>v.default(validator, value)</code> - retourne un validateur qui se souvient d'une valeur invalide, et au moment d'appeler <code>v.fix</code> - d√©finit la valeur par d√©faut </li><li>  <code>v.filter(validator)</code> - retourne un validateur qui se souvient d'une valeur invalide, et au moment d'appeler <code>v.fix</code> - supprime cette valeur du parent </li><li>  <code>v.addFix(validator, fixFunc)</code> - renvoie un validateur qui se souvient d'une valeur non valide, et au moment d'appeler <code>v.fix</code> - appelle fixFunc avec des param√®tres (valeur, {cl√©, parent}, ...).  <code>fixFunc</code> - doit muter l'un des partenaires - pour changer la valeur </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toPositive = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">negativeValue, { key, parent }</span></span></span><span class="hljs-function">) =&gt;</span></span> { parent[key] = -negativeValue } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> objSchema = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-attr"><span class="hljs-attr">b</span></span>: v.filter(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-attr"><span class="hljs-attr">c</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'array'</span></span>, []), <span class="hljs-attr"><span class="hljs-attr">d</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, invalidValue =&gt; <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(invalidValue)), <span class="hljs-comment"><span class="hljs-comment">//    pos: v.and( v.default('number', 0), //     -  0 v.addFix('non-negative', toPositive) //     -   ) } const invalidObj = { a: 1, b: 2, c: 3, d: '4', pos: -3 } v.resetExplanation() //   v() v(objSchema)(invalidObj) // =&gt; false // v.hasFixes() =&gt; true const validObj = v.fix(invalidObj) console.log(validObj) // =&gt; { a: 1, b: '', c: [], d: 4 }</span></span></code> </pre> <br><h3 id="po-hozyaystvu-eschyo-prigoditsya">  Les t√¢ches sont toujours utiles </h3><br><p>  Il existe √©galement des m√©thodes utilitaires pour les actions de validation dans cette biblioth√®que: </p><br><table><thead><tr><th>  La m√©thode </th><th>  R√©sultat </th></tr></thead><tbody><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="`v.throwError`"><code>v.throwError</code></a> </td> <td>  S'il n'est pas valide, lance une TypeError avec le message donn√©. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="`v.omitInvalidItems`"><code>v.omitInvalidItems</code></a> </td> <td>  Renvoie un nouveau tableau (ou objet dictionnaire) sans √©l√©ments (champs) non valides. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="`v.omitInvalidProps`"><code>v.omitInvalidProps</code></a> </td> <td>  Renvoie un nouvel objet sans champs non valides, selon le validateur d'objet sp√©cifi√©. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="`v.validOr`"><code>v.validOr</code></a> </td> <td>  Renvoie la valeur si elle est valide, sinon elle la remplace par la valeur par d√©faut sp√©cifi√©e. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>v.example</code></a> </td> <td>  V√©rifie si les valeurs donn√©es correspondent au sch√©ma.  S'ils ne correspondent pas, une erreur est g√©n√©r√©e.  Sert de documentation et de test de circuit </td></tr></tbody></table><br><h2 id="rezultaty">  R√©sultats </h2><br><p>  Les t√¢ches ont √©t√© r√©solues de la mani√®re suivante: </p><br><table><thead><tr><th>  D√©fi </th><th>  Solution </th></tr></thead><tbody><tr><td>  Validation du type de donn√©es </td><td>  Validateurs nomm√©s par d√©faut. </td></tr><tr><td>  Valeurs par d√©faut </td><td> <code>v.default</code> </td> </tr><tr><td>  Suppression de pi√®ces invalides </td><td>  <code>v.filter</code> , <code>v.omitInvalidItems</code> et <code>v.omitInvalidProps</code> . </td></tr><tr><td>  Facile √† apprendre </td><td>  Validateurs simples, fa√ßons simples de les composer en validateurs complexes. </td></tr><tr><td>  Lisibilit√© du code </td><td>  L'un des objectifs de la biblioth√®que √©tait de comparer les sch√©mas de validation eux-m√™mes </td></tr><tr><td>  objets valid√©s. </td></tr><tr><td>  Facilit√© de modification </td><td>  Apr√®s avoir ma√Ætris√© les √©l√©ments des compositions et utilis√© vos propres fonctions de validation - changer le code est assez simple. </td></tr><tr><td>  Message d'erreur </td><td>  Explication sous forme de message d'erreur.  Ou calcul du code d'erreur bas√© sur des explications. </td></tr></tbody></table><br><h2 id="posleslovie">  Postface </h2><br><p>  Cette solution a √©t√© con√ßue pour cr√©er rapidement et facilement des fonctions de validation avec la possibilit√© d'int√©grer des fonctions de validation personnalis√©es.  Par cons√©quent, s'il y en a, toutes les corrections, critiques, options d'am√©lioration de la part de ceux qui ont lu cet article sont les bienvenues.  Merci de votre attention. <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr429916/">https://habr.com/ru/post/fr429916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr429904/index.html">Histoires dr√¥les et tristes sur le d√©veloppement de jeux informatiques</a></li>
<li><a href="../fr429908/index.html">Comment utiliser les coroutines dans les aliments et dormir paisiblement la nuit</a></li>
<li><a href="../fr429910/index.html">AppsConf Rises</a></li>
<li><a href="../fr429912/index.html">D√©veloppement de biblioth√®que: de l'API √† la version publique</a></li>
<li><a href="../fr429914/index.html">OpenSceneGraph: graphique de sc√®ne et pointeurs intelligents</a></li>
<li><a href="../fr429918/index.html">Monde virtuel Intel. Partie 2: SMP</a></li>
<li><a href="../fr429920/index.html">Tragicomedy in NaN Acts: comment nous avons cr√©√© un jeu sur JS et l'avons sorti sur Steam</a></li>
<li><a href="../fr429922/index.html">Comment transformer un projet simple en une construction √† long terme ou supprimer tout ce qui n'est pas n√©cessaire</a></li>
<li><a href="../fr429928/index.html">Tout ce que vous devez savoir sur le stress et les √©motions fortes</a></li>
<li><a href="../fr429930/index.html">Splunk D√©pannage facile des applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>