<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèí ü¶ë üê∂ Beschleunigen der C / C ++ - Datei-E / A ohne wirkliche Belastung üïß üíØ üé•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vorwort 
 Es gibt ein so einfaches und sehr n√ºtzliches Dienstprogramm auf der Welt - BDelta , und es kam vor, dass es lange Zeit in unserem Produktion...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beschleunigen der C / C ++ - Datei-E / A ohne wirkliche Belastung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444036/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/1j/gs/ok/1jgsokcb4ocacisc7uvo-h40d8o.jpeg" alt="Bild"></div><br><h4>  Vorwort </h4><br>  Es gibt ein so einfaches und sehr n√ºtzliches Dienstprogramm auf der Welt - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BDelta</a> , und es kam vor, dass es lange Zeit in unserem Produktionsprozess Wurzeln schlug (obwohl seine Version nicht installiert werden konnte, aber es war sicherlich nicht die letzte verf√ºgbare).  Wir verwenden es f√ºr den beabsichtigten Zweck - die Konstruktion von bin√§ren Patches.  Wenn Sie sich ansehen, was sich im Repository befindet, wird es ein wenig traurig: Tats√§chlich wurde es vor langer Zeit aufgegeben und vieles war dort sehr veraltet (nachdem mein ehemaliger Kollege dort mehrere Korrekturen vorgenommen hatte, aber es war vor langer Zeit).  Im Allgemeinen habe ich mich entschlossen, dieses Gesch√§ft wiederzubeleben: Ich gabelte, warf heraus, was ich nicht verwenden wollte, √ºberholte das Projekt auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cmake</a> , inline die "hei√üen" Mikrofunktionen, entfernte gro√üe Arrays vom Stapel (und Arrays variabler L√§nge, von denen ich offen "bombardierte"). , fuhr noch einmal den Profiler - und fand heraus, dass etwa 40% der Zeit f√ºr das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schreiben aufgewendet wird</a> ... <br><a name="habracut"></a><br><h4>  Also, was ist los mit fwrite? </h4><br>  In diesem Code wird fwrite (in meinem speziellen Testfall: Erstellen eines Patches zwischen knapp 300 MB gro√üen Dateien, die Eingabedaten befinden sich vollst√§ndig im Speicher) millionenfach mit einem kleinen Puffer aufgerufen.  Offensichtlich wird sich diese Sache verlangsamen, und deshalb m√∂chte ich diese Schande irgendwie beeinflussen.  Es besteht kein Wunsch, irgendeine Art von Datenquellen zu implementieren, asynchrone Eingabe-Ausgabe, ich wollte eine einfachere L√∂sung finden.  Das erste, was mir in den Sinn kam, war, den Puffer zu vergr√∂√üern <br><br><pre><code class="cpp hljs">setvbuf(file, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, _IOFBF, <span class="hljs-number"><span class="hljs-number">64</span></span>* <span class="hljs-number"><span class="hljs-number">1024</span></span>)</code> </pre> <br>  Aber ich habe keine signifikante Verbesserung des Ergebnisses erzielt (jetzt macht fwrite ungef√§hr 37% der Zeit aus) - es bedeutet, dass die Angelegenheit immer noch nicht in der h√§ufigen Datenaufzeichnung auf der Festplatte liegt.  Wenn Sie ‚Äûunter der Haube‚Äú schreiben, k√∂nnen Sie sehen, dass die Struktur der Sperr- / Entsperrdatei im Inneren wie folgt abl√§uft (Pseudocode, alle Analysen wurden unter Visual Studio 2017 durchgef√ºhrt): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> fwrite (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *buffer, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> count, FILE *stream) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> retval = <span class="hljs-number"><span class="hljs-number">0</span></span>; _lock_str(stream); <span class="hljs-comment"><span class="hljs-comment">/* lock stream */</span></span> __try { retval = _fwrite_nolock(buffer, size, count, stream); } __finally { _unlock_str(stream); <span class="hljs-comment"><span class="hljs-comment">/* unlock stream */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; }</code> </pre><br>  Laut dem Profiler macht _fwrite_nolock nur 6% der Zeit aus, der Rest ist Overhead.  In meinem speziellen Fall ist die Thread-Sicherheit ein offensichtlicher √úberschuss. Ich werde sie opfern, indem ich den fwrite-Aufruf durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">_fwrite_nolock ersetze</a> - selbst bei Argumenten, bei denen ich nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">klug sein muss</a> .  Insgesamt: Diese einfache Manipulation reduzierte zeitweise die Kosten f√ºr die Aufzeichnung des Ergebnisses, die in der Originalversion fast die H√§lfte der Zeitkosten betrugen.  √úbrigens gibt es in der POSIX-Welt eine √§hnliche Funktion - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fwrite_unlocked</a> .  Im Allgemeinen gilt das Gleiche f√ºr Fread.  So k√∂nnen Sie mit Hilfe des Paares #define eine plattform√ºbergreifende L√∂sung ohne unn√∂tige Sperren erhalten, wenn diese nicht erforderlich sind (und dies passiert h√§ufig). <br><br><h4>  fwrite, _fwrite_nolock, setvbuf </h4><br>  Lassen Sie uns vom urspr√ºnglichen Projekt abstrahieren und einen bestimmten Fall testen: Aufzeichnen einer gro√üen Datei (512 MB) in extrem kleinen Portionen - 1 Byte.  Testsystem: AMD Ryzen 7 1700, 16 GB RAM, Festplatte 3,5 "7200 U / min 64 MB Cache, Windows 10 1809, das Binar wurde 32-Bit erstellt, Optimierungen sind enthalten, die Bibliothek ist statisch verkn√ºpft. <br><br>  Probe f√ºr das Experiment: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;cstdio&gt; #include &lt;inttypes.h&gt; #include &lt;memory&gt; #ifdef _MSC_VER #define fwrite_unlocked _fwrite_nolock #endif using namespace std::chrono; int main() { std::unique_ptr&lt;FILE, int(*)(FILE*)&gt; file(fopen("test.bin", "wb"), fclose); if (!file) return 1; constexpr size_t TEST_BUFFER_SIZE = 256 * 1024; if (setvbuf(file.get(), nullptr, _IOFBF, TEST_BUFFER_SIZE) != 0) return 2; auto start = steady_clock::now(); const uint8_t b = 77; constexpr size_t TEST_FILE_SIZE = 512 * 1024 * 1024; for (size_t i = 0; i &lt; TEST_FILE_SIZE; ++i) fwrite_unlocked(&amp;b, sizeof(b), 1, file.get()); auto end = steady_clock::now(); auto interval = duration_cast&lt;microseconds&gt;(end - start); printf("Time: %lld\n", interval.count()); return 0; }</span></span></span></span></code> </pre><br>  Die Variablen sind TEST_BUFFER_SIZE. In einigen F√§llen ersetzen wir fwrite_unlocked durch fwrite.  Beginnen wir mit dem Fall von fwrite, ohne die Puffergr√∂√üe explizit festzulegen (setvbuf und den zugeh√∂rigen Code auskommentieren): Zeit 27048906 Œºs, Schreibgeschwindigkeit - 18,93 Mb / s.  Stellen Sie nun die Puffergr√∂√üe auf 64 Kb ein: Zeit - 25037111 Œºs, Geschwindigkeit - 20,44 Mb / s.  Jetzt testen wir den Betrieb von _fwrite_nolock, ohne setvbuf aufzurufen: 7262221 ms, die Geschwindigkeit betr√§gt 70,5 Mb / s! <br><br>  Als n√§chstes experimentieren Sie mit der Gr√∂√üe des Puffers (setvbuf): <br><br><img src="https://habrastorage.org/webt/xv/qv/jd/xvqvjd0rl4owz3zjb319bh0fq9u.png"><br><br>  Die Daten wurden durch Mittelung von 5 Experimenten erhalten, ich war zu faul, um die Fehler zu ber√ºcksichtigen.  F√ºr mich sind 93 MB / s beim Schreiben von 1 Byte auf eine normale Festplatte ein sehr gutes Ergebnis. W√§hlen Sie einfach die optimale Puffergr√∂√üe (in meinem Fall 256 KB - genau richtig) und ersetzen Sie fwrite durch _fwrite_nolock / fwrite_unlocked (in wenn keine Gewindesicherheit erforderlich ist, nat√ºrlich). <br>  √Ñhnliches gilt f√ºr Fread unter √§hnlichen Bedingungen.  Nun wollen wir sehen, wie die Dinge unter Linux sind. Die Testkonfiguration ist wie folgt: AMD Ryzen 7 1700X, 16 GB RAM, Festplatte 3,5 "7200 U / min 64 MB Cache, OpenSUSE 15 OS, GCC 8.3.1, wir werden x86-64 Binar, Dateisystem auf testen ext4-Testabschnitt Das Ergebnis von fwrite ohne explizite Einstellung der Puffergr√∂√üe in diesem Test ist 67,6 Mb / s. Wenn der Puffer auf 256 Kb eingestellt wird, erh√∂ht sich die Geschwindigkeit auf 69,7 Mb / s. Jetzt werden wir √§hnliche Messungen f√ºr fwrite_unlocked durchf√ºhren - die Ergebnisse sind 93,5 bzw. 94,6 Mb / s. Das Variieren der Puffergr√∂√üe von 1 KB auf 8 MB f√ºhrte mich zu folgenden Schlussfolgerungen: Durch Erh√∂hen des Puffers wird die Schreibgeschwindigkeit erh√∂ht.  In meinem Fall betrug der Unterschied jedoch nur 3 Mbit / s. Ich bemerkte √ºberhaupt keinen Geschwindigkeitsunterschied zwischen dem 64-Kbit- und dem 8-Mbit-Puffer. Aus den auf diesem Linux-Computer empfangenen Daten k√∂nnen wir die folgenden Schlussfolgerungen ziehen: <br><br><ul><li>  fwrite_unlocked ist schneller als fwrite, aber der Unterschied in der Schreibgeschwindigkeit ist nicht so gro√ü wie unter Windows </li><li>  Die Puffergr√∂√üe unter Linux hat keinen so gro√üen Einfluss auf die Schreibgeschwindigkeit √ºber fwrite / fwrite_unlocked wie unter Windows </li></ul><br><br>  Insgesamt ist die vorgeschlagene Methode sowohl unter Windows als auch unter Linux wirksam (wenn auch in viel geringerem Umfang). <br><br><h4>  Nachwort </h4><br>  Der Zweck dieses Artikels war es, in vielen F√§llen eine einfache und effektive Technik zu beschreiben (ich bin fr√ºher nicht auf die Funktionen _fwrite_nolock / fwrite_unlocked gesto√üen, sie sind nicht sehr beliebt - aber vergebens).  Ich gebe nicht vor, neu im Material zu sein, aber ich hoffe, dass der Artikel f√ºr die Community n√ºtzlich sein wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444036/">https://habr.com/ru/post/de444036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444026/index.html">MODX Digest # 1.1 (25. Februar - 11. M√§rz 2019)</a></li>
<li><a href="../de444028/index.html">Einf√ºhrung in Microsoft Game Stack</a></li>
<li><a href="../de444030/index.html">Der chinesische Online-H√§ndler Gearbest hat eine Datenbank mit Millionen pers√∂nlicher Kundendaten ge√∂ffnet</a></li>
<li><a href="../de444032/index.html">Warum ein 3D-Drucker kein Drucker ist</a></li>
<li><a href="../de444034/index.html">7 Tods√ºnden eines Managers</a></li>
<li><a href="../de444038/index.html">Erfahrung mit der Verwendung von "Koordinatoren" in einem echten "iOS" -Projekt</a></li>
<li><a href="../de444040/index.html">Autozentrisches Ranking. Yandex-Bericht √ºber die Suche nach relevanten Zielgruppen f√ºr Zen-Autoren</a></li>
<li><a href="../de444044/index.html">Europa wird Eisen aus Rechenzentren recyceln</a></li>
<li><a href="../de444048/index.html">Tipps und Tricks zur digitalen Forensik: Erkennen von √Ñnderungen durch Gruppenrichtlinien, die von Eindringlingen verursacht werden</a></li>
<li><a href="../de444050/index.html">Diskussion: Wird die DNA-Speicherung massiv?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>