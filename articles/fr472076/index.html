<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👘 🎊 👨🏿‍🚀 Le livre "Java pour tous" 🛌🏿 📞 🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, habrozhiteli! Ce livre est destiné aux débutants. 


 Depuis de nombreuses années, le langage Java est l'un des plus populaires et recherchés. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le livre "Java pour tous"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/472076/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/xs/no/fg/xsnofg4jvnjubrnjcows5mbxc3m.jpeg" align="left" alt="image"></a>  Salut, habrozhiteli!  Ce livre est destiné aux débutants. </p><br><p>  Depuis de nombreuses années, le langage Java est l'un des plus populaires et recherchés.  C'est beau, efficace et, surtout, très productif.  Mais, malheureusement, pas le plus simple.  C'est pourquoi la demande de programmeurs Java est constamment élevée.  Le langage Java est un diamant qui ornera le bagage de connaissances de tout programmeur.  Et apprendre Java, comme je l'espère, les lecteurs de ce livre devront s'assurer qu'il est non seulement utile, mais aussi intéressant.  La base du livre est des cours magistraux, à différents moments, que j'ai lus pour les maîtres de la Faculté de physique de l'Université nationale de Kiev nommés d'après  Tarasa Shevchenko, licenciée en génie médical à l'Université technique nationale d'Ukraine «Kiev Polytechnic Institute» et étudiants de divers cours de programmation.  Le matériel du livre et le mode de présentation sont adaptés pour tous ceux qui veulent apprendre Java non seulement dans les établissements d'enseignement, mais aussi de manière indépendante.  Par conséquent, le livre peut être utilisé comme tutoriel. </p><a name="habracut"></a><br><h2 id="massivy">  Tableaux </h2><br><p>  Un tableau signifie un ensemble du même type de valeurs (variables), auquel on peut accéder par un nom commun.  Ce chapitre est consacré aux tableaux. </p><br><p>  Les variables appartenant à un tableau sont appelées éléments de ce tableau.  Pour identifier de manière unique un élément d'un tableau, vous devez connaître le nom du tableau et la position (placement) de l'élément dans le tableau.  La position des éléments dans le tableau est déterminée à l'aide d'indices entiers.  Le nombre d'indices nécessaires pour identifier un élément d'un tableau est appelé la dimension du tableau.  Un tableau unidimensionnel est un tableau dans lequel les éléments sont identifiés à l'aide d'un seul index. </p><br><h2 id="odnomernye-massivy">  Tableaux unidimensionnels </h2><br><p>  Il est commode d'imaginer un tableau unidimensionnel sous la forme d'une chaîne ordonnée ou d'une séquence de variables (du même type).  Pour déclarer un tableau unidimensionnel, vous devez spécifier le type auquel appartiennent les éléments du tableau, le nom du tableau et également le nombre d'éléments inclus dans le tableau.  La syntaxe pour déclarer un tableau unidimensionnel est: </p><br><pre><code class="java hljs">[] =<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [];</code> </pre> <br><p>  Tout d'abord, le type des éléments du tableau est indiqué, et après l'identifiant de type est suivi de crochets vides.  Ensuite, le nom du tableau, l'opérateur d'affectation, l'instruction (opérateur) new, encore une fois le type des éléments du tableau et entre crochets la taille du tableau (le nombre d'éléments dans le tableau).  Par exemple, la commande int nums = new int [20] déclare un tableau nums entier de 20 éléments. </p><br><p>  À proprement parler, la commande de déclaration de tableau présentée ici est une symbiose de deux commandes: la commande int [] nums, la déclaration de la variable nums du type tableau entier (variable de tableau) et la nouvelle instruction int [20], qui, en fait, crée le tableau.  Cette instruction se voit attribuer la valeur de la variable nums et, à la suite de la référence du tableau, elle est écrite dans la variable nums.  En d'autres termes, le processus de création d'un tableau peut être effectué avec deux commandes: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] nums; nums=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">20</span></span>];</code> </pre> <br><p>  De plus, ces commandes peuvent être publiées dans le code du programme - c'est-à-dire que nous pouvons déclarer une variable de tableau et seulement ensuite, à un autre endroit du code, créer un tableau (et écrire un lien vers ce tableau dans la variable de tableau). </p><br><blockquote>  DÉTAILS Auparavant, nous nous occupions principalement des types de base ou primitifs (tels que int, char ou double).  Une variable du type de base stocke la valeur.  Techniquement, cela ressemble à ceci: un espace est alloué pour une variable en mémoire, et la valeur de la variable est écrite à cet endroit.  Mais il existe une autre façon de travailler avec des données dans laquelle une variable fait référence à des données.  C'est ce qui arrive aux objets et les tableaux sont donc implémentés.  Il y a en fait un tableau, mais nous n'y avons pas accès directement, mais avec l'aide d'un intermédiaire, qui est une variable de tableau.  La valeur de la variable tableau n'est pas le tableau, mais l'adresse du tableau.  Par conséquent, la création d'une variable de tableau ne signifie pas la création d'un tableau.  Un tableau est créé séparément.  Nous décrirons cette situation comme une situation dans laquelle une variable de tableau fait référence à un tableau.  Chaque fois que nous devons accéder au tableau, nous accéderons à la variable de tableau qui fait référence au tableau donné. <br>  Bien qu'à première vue un tel schéma puisse sembler redondant, il présente néanmoins ses avantages.  Et nous verrons cela. </blockquote><p>  Dans les cas où il n'y a pas de malentendu, nous identifierons la variable tableau avec le tableau. </p><br><p>  Lors de la déclaration d'une variable de tableau, il est autorisé d'indiquer des crochets soit après l'identificateur de type, soit après le nom du tableau.  Par exemple, au lieu de la commande int [] nums, vous pouvez utiliser la commande int nums []. </p><br><p>  Un élément d'un tableau unidimensionnel est accessible via le nom du tableau avec l'index de l'élément indiqué entre crochets.  L'indexation des éléments du tableau commence à zéro.  Ainsi, la référence au premier élément du tableau nums ressemblera à nums [0].  S'il y a 20 éléments dans le tableau, le dernier élément du tableau a un index de 19, c'est-à-dire que l'instruction pour accéder à l'élément ressemble à nums [19]. </p><br><p>  La longueur du tableau peut être trouvée en utilisant la propriété length: le nom du tableau est indiqué et, à travers le point, la propriété length.  Par exemple, pour connaître la longueur du tableau nums, vous pouvez utiliser l'instruction nums.length.  Ensuite, la référence au dernier élément du tableau peut être écrite comme nums [nums.length-1]. </p><br><blockquote>  AVIS Java utilise une vérification automatique pour voir s'il sort du tableau.  Par conséquent, si le code fait référence à un élément de tableau inexistant, une erreur se produit. </blockquote><p>  Lors de la déclaration d'un tableau, de la mémoire lui est allouée.  En Java, les éléments du tableau sont automatiquement initialisés avec des valeurs nulles - les cellules sélectionnées sont mises à zéro et les valeurs de ces cellules mises à zéro sont interprétées en fonction du type de tableau.  Mais vous ne devez pas vous fier à une telle initialisation automatique.  Il est sage d'initialiser explicitement les éléments du tableau.  Pour ce faire, utilisez l'opérateur de boucle ou spécifiez une liste de valeurs d'élément lors de la déclaration d'un tableau. </p><br><p>  Pour initialiser le tableau avec une liste de valeurs lors de la déclaration d'une variable de tableau, après avoir indiqué (via l'opérateur d'affectation) une liste de valeurs entre accolades.  Par exemple: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] data={<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>};</code> </pre> <br><p>  Ici, les données variables sont déclarées pour un tableau d'entiers, un tableau est créé et un lien vers celui-ci est écrit dans cette variable.  La taille du tableau et les valeurs des éléments sont déterminées automatiquement en fonction du nombre d'éléments dans la liste de valeurs.  Dans ce cas, un tableau entier de quatre éléments est créé avec les valeurs des éléments 3, 8, 1 et 7. Le même résultat peut être obtenu en utilisant, par exemple, les commandes suivantes: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] data; data=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[]{<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>};</code> </pre> <br><p>  La première commande de données int [] déclare une variable de tableau.  L'instruction new int [] {3,8,1,7} crée un tableau de quatre entiers, et une référence à ce tableau est affectée aux données variables (ce qui signifie que la commande data = new int [] {3,8,1,7}) . <br>  Un exemple de déclaration, d'initialisation et d'utilisation de tableaux est présenté dans le Listing 3.1. </p><br><h4 id="listing-31-znakomstvo-s-odnomernymi-massivami">  Listing 3.1.  Présentation des tableaux unidimensionnels </h4><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  : int i,n; //   : int[] data; //  : data=new int[]{3,8,1,7}; //  : n=data.length; //  : int[] nums=new int[n]; //   : for(i=0;i&lt;nums.length;i++){ nums[i]=2*data[i]-3; System.out.println("nums["+i+"]="+nums[i]); } } }</span></span></code> </pre> <br><p>  Le programme déclare et initialise un tableau de données de quatre éléments.  La longueur du tableau est calculée par l'instruction data.length.  Cette valeur est écrite dans la variable entière n (commande n = data.length).  Ensuite, la commande int [] nums = new int [n] déclare un autre tableau nums entier.  Le nombre d'éléments dans ce tableau est déterminé par la valeur de la variable n, il coïncide donc avec la taille du tableau de données.  Le remplissage du tableau nums se fait à l'aide d'une instruction de boucle.  Les valeurs des éléments du tableau nums sont calculées sur la base des valeurs des éléments du tableau de données (commande nums [i] = 2 * data [i] -3).  Pour afficher les valeurs des éléments du tableau nums, utilisez la commande System.out.println ("nums [" + i + "] =" + nums [i]). </p><br><p>  Ce qui suit montre à quoi ressemble le résultat de l'exécution du programme: <br>  Le résultat du programme (extrait de l'extrait 3.1) </p><br><pre> <code class="java hljs">nums[<span class="hljs-number"><span class="hljs-number">0</span></span>]=<span class="hljs-number"><span class="hljs-number">3</span></span> nums[<span class="hljs-number"><span class="hljs-number">1</span></span>]=<span class="hljs-number"><span class="hljs-number">13</span></span> nums[<span class="hljs-number"><span class="hljs-number">2</span></span>]=-<span class="hljs-number"><span class="hljs-number">1</span></span> nums[<span class="hljs-number"><span class="hljs-number">3</span></span>]=<span class="hljs-number"><span class="hljs-number">11</span></span></code> </pre> <br><p>  Encore une fois, nous notons que l'indexation des éléments du tableau commence à zéro.  Par conséquent, dans l'opérateur de boucle, la variable d'index i est initialisée avec la valeur zéro initiale et l'opérateur d'inégalité stricte est utilisé dans la condition de test i &lt;nums.length. <br>  Il est également important que lors de la création du tableau nums, sa taille soit déterminée à l'aide de la variable n, dont la valeur est calculée lors de l'exécution du programme. </p><br><h2 id="dvumernye-i-mnogomernye-massivy">  Tableaux bidimensionnels et multidimensionnels </h2><br><p>  La dimension du tableau peut être supérieure à un.  Mais en pratique, les tableaux de dimension supérieure à la seconde sont rarement utilisés.  Ensuite, nous examinerons les moyens de déclarer, d'initialiser et d'utiliser des tableaux bidimensionnels dans lesquels l'accès à un élément d'un tableau est effectué à l'aide de deux index.  Si vous représentez un tableau à deux dimensions sous forme de tableau, le premier index de l'élément détermine la ligne dans laquelle se trouve l'élément et le deuxième index détermine la colonne dans laquelle se trouve l'élément. </p><br><blockquote>  DÉTAILS Bien qu'un tableau à deux dimensions soit commodément représenté sous forme de tableau, il est implémenté d'une manière complètement différente.  En fait, un tableau bidimensionnel en Java est un tableau unidimensionnel dont les éléments sont des variables de tableau.  Chacune de ces variables fait référence à un tableau unidimensionnel.  Lorsque vous utilisez cette construction, l'illusion se pose que nous avons affaire à une table. </blockquote><p>  La création de tableaux bidimensionnels est aussi simple que la création de tableaux unidimensionnels.  Mais lors de la déclaration d'une variable pour un tableau à deux dimensions, deux paires de crochets vides sont indiquées après l'identificateur de type, et l'instruction pour créer un tableau à deux dimensions - entre crochets séparés - indique la taille de chacun des indices (le nombre de lignes et de colonnes dans le tableau).  La syntaxe de déclaration d'un tableau à deux dimensions est la suivante: </p><br><pre> <code class="java hljs">[][] =<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [][];</code> </pre> <br><p>  Comme dans le cas d'un tableau unidimensionnel, cette commande peut être divisée en deux: </p><br><pre> <code class="java hljs">[][] ; =<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [][];</code> </pre> <br><p>  La première commande déclare une variable pour un tableau à deux dimensions.  La deuxième commande crée un tableau bidimensionnel réel avec les tailles spécifiées et une référence à ce tableau est affectée comme valeur de la variable de tableau.  Par exemple, la commande double [] [] data = new double [3] [4] crée un tableau à deux dimensions avec des éléments de type double.  Le tableau a 3 lignes et 4 colonnes et le lien vers le tableau est écrit dans la variable de données.  Les mêmes commandes donneront le même résultat: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] data; data=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">4</span></span>];</code> </pre> <br><p>  L'accès aux éléments d'un tableau à deux dimensions est effectué dans le format suivant: le nom du tableau est indiqué, entre crochets est le premier index de l'élément, entre autres crochets est le deuxième index de l'élément du tableau.  L'indexation dans toutes les dimensions commence à partir de zéro.  Par exemple, le lien data [0] [3] est un appel à un élément du tableau de données avec les indices 0 et 3, et c'est un élément dans la première ligne et la quatrième colonne. </p><br><p>  Pour initialiser un tableau à deux dimensions, des opérateurs de boucle imbriqués ou une liste composée de listes de valeurs sont utilisés.  Chacune de ces listes internes définit les valeurs des éléments du tableau dans une chaîne.  Voici des exemples d'initialisation d'un tableau à deux dimensions à l'aide d'une liste: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] data={{<span class="hljs-number"><span class="hljs-number">0.1</span></span>,<span class="hljs-number"><span class="hljs-number">0.2</span></span>,<span class="hljs-number"><span class="hljs-number">0.3</span></span>},{<span class="hljs-number"><span class="hljs-number">0.4</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>,<span class="hljs-number"><span class="hljs-number">0.6</span></span>}}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nums[][]={{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>},{<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>}};</code> </pre> <br><p>  La première commande crée et initialise un tableau de données bidimensionnel 2 x 3 (deux lignes et trois colonnes).  Le nombre de lignes est déterminé par le nombre d'éléments dans la liste externe.  Il existe deux de ces éléments - ce sont les listes {0.1,0.2,0.3} et {0.4,0.5,0.6}.  Chacune de ces listes comporte trois éléments.  De là, nous obtenons un tableau de taille 2 par 3. La liste {0.1,0.2,0.3} définit les valeurs des éléments de la première ligne, la liste {0.4,0.5,0.6} définit les valeurs des éléments de la deuxième ligne.  Par exemple, l'élément data [0] [0] obtient la valeur 0,1, l'élément data [0] [2] la valeur 0,3, l'élément data [1] [0] la valeur 0,4 et l'élément data [1] [2] la valeur 0,6 . </p><br><p>  La deuxième commande crée un tableau de nombres entiers, qui se compose de deux lignes (car il y a deux éléments à l'intérieur de la liste affectée - listes {1,2,3} et {4,5}).  Cependant, la première ligne du tableau créé contient trois éléments (puisque la liste contient {1,2,3} trois valeurs) et la deuxième ligne du tableau contient deux éléments (puisque la liste {4,5} a deux valeurs).  Dans le tableau créé, l'élément nums [0] [0] a la valeur 1, l'élément nums [0] [1] a la valeur 2, l'élément nums [0] [2] a la valeur 3, l'élément nums [1] [0] a la valeur 4 et l'élément nums [1] [1] est la valeur 5. </p><br><blockquote>  DÉTAILS Le problème est que le tableau nums dans différentes lignes contient un nombre différent d'éléments, non.  Techniquement, tout est mis en œuvre plus que simplement.  La variable du nombre de tableaux bidimensionnels fait en fait référence à un tableau unidimensionnel de deux éléments (le nombre de lignes dans le tableau bidimensionnel).  Mais les éléments de ce tableau ne sont pas des entiers, mais des variables qui peuvent faire référence à des tableaux entiers unidimensionnels (relativement parlant, les éléments sont de type int []).  La première variable fait référence à un tableau unidimensionnel de trois éléments (1, 2 et 3), et la deuxième variable fait référence à un tableau unidimensionnel de trois éléments (4 et 5).  Lorsque nous indexons (avec un index!) La variable nums, nous avons accès à l'élément du tableau unidimensionnel référencé par cette variable.  Par exemple, nums [0] est le premier élément et nums [1] est le deuxième élément du tableau mentionné à partir des variables du tableau.  Et ces éléments sont des références à des tableaux.  Ils peuvent être indexés.  Par conséquent, disons que nums [0] [1] est le deuxième élément du tableau auquel le premier élément nums [0] fait référence dans le tableau auquel la variable nums fait référence.  Donc, tout se passe vraiment.  Et nous interprétons l'instruction nums [0] [1] comme un appel à un élément de la première ligne et de la deuxième colonne d'un tableau à deux dimensions. </blockquote><p>  Le listing 3.2 montre un exemple de programme qui crée un tableau à deux dimensions rempli à l'aide d'instructions de boucles imbriquées. </p><br><h4 id="listing-32-sozdanie-dvumernogo-massiva">  Listing 3.2.  Créer un tableau à deux dimensions </h4><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i,j,n=<span class="hljs-number"><span class="hljs-number">3</span></span>,val=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   : int[][] nums=new int[n-1][n]; //   : for(i=0;i&lt;n-1;i++){ //    for(j=0;j&lt;n;j++){ //    //   : nums[i][j]=val++; //   : System.out.print(nums[i][j]+" "); } //    : System.out.println(); } } }</span></span></code> </pre> <br><p>  La commande int [] [] nums = new int [n-1] [n] crée un tableau de nombres entiers avec n-1 lignes et n colonnes.  La variable n est pré-affectée à la valeur 3. Le tableau est rempli à l'aide d'opérateurs de boucle imbriqués.  La valeur de l'élément de tableau (pour les indices i et j donnés) est affectée par la commande nums [i] [j] = val ++.  Ici, l'élément nums [i] [j] se voit attribuer la valeur actuelle de la variable val, et immédiatement après cela, la valeur de la variable val est augmentée de un. </p><br><blockquote>  AVIS Suite à l'exécution de l'instruction val ++, la valeur de la variable val est augmentée de un.  Mais puisque la forme postfixe de l'opérateur d'incrémentation est utilisée, la valeur de l'expression val ++ est l'ancienne valeur (avant d'augmenter d'une unité) de la variable val. </blockquote><p>  Après avoir calculé la valeur de l'élément, il s'affiche dans la zone de sortie.  Grâce au programme, nous obtenons: <br>  Le résultat du programme (extrait du listing 3.2) </p><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br><p>  Le listing 3.3 montre le code d'un programme qui crée un tableau à deux dimensions avec des chaînes de différentes longueurs. </p><br><h4 id="listing-33-massiv-so-strokami-raznoy-dliny">  Listing 3.3.  Tableau avec des chaînes de différentes longueurs </h4><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i,j,val=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   (   ): int[][] nums=new int[4][]; //     : for(i=0;i&lt;nums.length;i++){ //    : nums[i]=new int[i+1]; } //  : for(i=0;i&lt;nums.length;i++){ for(j=0;j&lt;nums[i].length;j++){ //   : nums[i][j]=val++; //   : System.out.print(nums[i][j]+" "); } //    : System.out.println(); } } }</span></span></code> </pre> <br><p>  La commande int [] [] nums = new int [4] [] crée un tableau nums entier bidimensionnel.  Ce tableau se compose de quatre lignes.  Cependant, la taille des lignes n'est pas spécifiée - la deuxième paire de crochets à la fin de la commande est vide.  Plus précisément, il n'y a pas encore de lignes.  Ils doivent être créés.  Les lignes sont créées dans l'instruction de boucle.  Dans cette instruction de boucle, la variable d'index i parcourt des valeurs de 0 à nums.length-1, inclus.  La commande nums [i] = new int [i + 1] crée une ligne d'un tableau à deux dimensions avec l'index i.  Une telle chaîne contient i + 1 élément. </p><br><blockquote>  DÉTAILS Techniquement, tout se passe comme ceci: la nouvelle instruction int [i + 1] crée un tableau unidimensionnel (une chaîne pour un tableau bidimensionnel) et une référence à ce tableau est écrite dans la variable nums [i].  Dans ce cas, nums [i] peut être interprété comme un lien vers une ligne d'index i.  La signification de l'instruction nums.length deviendra claire si vous vous souvenez qu'en fait, un tableau à deux dimensions est un tableau à une dimension, dont les éléments se réfèrent à des tableaux à une dimension.  Dans ce cas, nums.length donne une valeur pour le nombre d'éléments dans le tableau référencé par la variable nums - c'est-à-dire, c'est le nombre de lignes dans le tableau à deux dimensions. </blockquote><p>  En conséquence, nous obtenons un tableau bidimensionnel de type triangulaire: dans la première ligne du tableau, il y a un élément, dans le second - deux éléments, et ainsi de suite, jusqu'à la quatrième ligne du tableau. <br>  Le tableau créé est rempli à l'aide d'opérateurs de boucle imbriqués.  La variable d'index i dans l'opérateur de boucle externe prend des valeurs de 0 à nums.length-1 et définit une ligne dans le tableau nums bidimensionnel.  Pour la variable d'index j, la limite supérieure de la plage de variation est déterminée par l'instruction nums [i] .length, qui renvoie le nombre d'éléments de la ligne d'index i (la variable j passe de 0 à nums [i] .length-1 inclus). </p><br><blockquote>  DÉTAILS Il convient de noter que nums [i] est en fait une variable qui fait référence à un tableau unidimensionnel formant une chaîne d'index i.  Le nombre d'éléments dans ce tableau (chaîne) est déterminé par l'expression nums [i] .length. </blockquote><p>  La valeur des éléments du tableau est affectée par la commande nums [i] [j] = val ++.  Ce qui suit montre à quoi ressemble le résultat de l'exécution du programme: <br>  Le résultat du programme (de la liste 3.3) </p><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br><p>  Comme prévu, nous avons obtenu un tableau qui a différents nombres d'éléments dans différentes lignes. </p><br><blockquote>  AVIS Les tableaux dont la dimension est supérieure à deux sont créés de la même manière.  Lors de la déclaration d'une variable pour un tableau multidimensionnel, des paires de crochets vides sont indiquées après l'identifiant de type.  Le nombre de ces paires est déterminé par la dimension du réseau.  Dans la commande de création de tableau, la taille de chaque index est indiquée entre crochets séparés. </blockquote><p>  »Plus d'informations sur le livre sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de l'éditeur</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contenu</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Extrait</a> </p><br><p>  25% de réduction sur les colporteurs - <strong>Java</strong> </p><br><p>  Lors du paiement de la version papier du livre, un livre électronique est envoyé par e-mail. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472076/">https://habr.com/ru/post/fr472076/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472060/index.html">La police allemande a pris d'assaut un bunker militaire, qui abritait le centre de données nouvellement déclaré</a></li>
<li><a href="../fr472062/index.html">Monitoring + stress tests = prévision et pas d'échecs</a></li>
<li><a href="../fr472064/index.html">Ansible + auto git pull in virtual machine cluster in the cloud</a></li>
<li><a href="../fr472068/index.html">Utilisation du SSD NVME en tant que lecteur système sur les ordinateurs dotés d'un ancien BIOS et d'un système d'exploitation Linux</a></li>
<li><a href="../fr472072/index.html">PG12: une douzaine de patchs de Postgres Professional</a></li>
<li><a href="../fr472078/index.html">Risques bancaires ouverts</a></li>
<li><a href="../fr472084/index.html">Vulnérabilités des smartphones</a></li>
<li><a href="../fr472086/index.html">Utilisation des lois de la psychologie gestaltique dans la conception de l'interface utilisateur</a></li>
<li><a href="../fr472088/index.html">Comment nous avons choisi ServiceDesk. 2e partie</a></li>
<li><a href="../fr472092/index.html">Fonctions PHP non sécurisées</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>