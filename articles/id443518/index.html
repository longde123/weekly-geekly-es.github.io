<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ ğŸ’¾ ğŸ– RBKmoney Pembayaran di bawah tenda - layanan Microsoft, protokol dan konfigurasi platform ğŸ£ âš”ï¸ ğŸ¥š</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Habr! RBKmoney kembali menghubungi dan melanjutkan serangkaian artikel tentang cara menulis pemrosesan pembayaran do-it-yourself. 





 Saya ingi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RBKmoney Pembayaran di bawah tenda - layanan Microsoft, protokol dan konfigurasi platform</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/rbkmoney/blog/443518/"><p>  Hai Habr!  RBKmoney kembali menghubungi dan melanjutkan serangkaian artikel tentang cara menulis pemrosesan pembayaran do-it-yourself. </p><br><p><img src="https://habrastorage.org/webt/nc/w-/dh/ncw-dhwzrbb-b84-afrgy1syhri.jpeg"></p><br><p>  Saya ingin segera terjun ke detail deskripsi penerapan proses bisnis pembayaran sebagai mesin negara, menunjukkan contoh mesin seperti itu dengan serangkaian acara, fitur implementasi ... Tetapi sepertinya Anda tidak dapat melakukannya tanpa beberapa artikel ulasan lagi.  Area subjek ternyata terlalu besar.  Posting ini akan mengungkapkan nuansa kerja dan interaksi antara layanan microser platform kami, interaksi dengan sistem eksternal dan bagaimana kami mengelola konfigurasi bisnis. <a name="habracut"></a></p><br><h3 id="makroservis">  Layanan makro </h3><br><p>  Sistem kami terdiri dari banyak layanan mikro, yang, mengimplementasikan masing-masing bagian akhir dari logika bisnis, berinteraksi satu sama lain dan bersama-sama membentuk layanan makro.  Sebenarnya, layanan makro yang digunakan di pusat data, yang terhubung ke bank dan sistem pembayaran lainnya, adalah proses pembayaran kami. </p><br><h4 id="shablon-mikroservisa">  Templat microservice </h4><br><p>  Kami menggunakan pendekatan terpadu untuk pengembangan layanan Microsoft apa pun dalam bahasa apa pun yang ditulis.  Setiap microservice adalah wadah Docker yang berisi: </p><br><ul><li>  aplikasi itu sendiri yang mengimplementasikan logika bisnis yang ditulis dalam bahasa Erlang atau Jawa; </li><li>  RPClib - perpustakaan yang mengimplementasikan komunikasi antara layanan microser; <br><ul><li>  kami menggunakan Apache Thrift, keunggulan utamanya adalah pustaka server-klien yang siap pakai dan kemampuan untuk secara ketat menentukan deskripsi semua metode publik yang diberikan oleh setiap layanan mikro; </li><li> fitur kedua dari perpustakaan adalah implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Google Dapper kami</a> , yang memungkinkan kami untuk dengan cepat melacak permintaan dengan pencarian sederhana di Elasticsearch.  Layanan microser pertama yang menerima permintaan dari sistem eksternal menghasilkan <code>trace_id</code> unik, yang disimpan oleh setiap rantai permintaan berikutnya.  Selain itu, kami membuat dan menyimpan <code>parent_id</code> dan <code>span_id</code> , yang memungkinkan Anda untuk membangun pohon permintaan, memantau secara visual seluruh rantai layanan-layanan microser yang terlibat dalam pemrosesan permintaan; </li><li>  fitur ketiga - kami secara aktif menggunakan transfer pada tingkat transportasi dari berbagai informasi tentang konteks permintaan.  Misalnya, tenggat waktu (perkiraan waktu permintaan yang ditetapkan pada klien), atau atas nama siapa kami melakukan panggilan ke suatu metode; </li></ul></li><li>  Templat Konsul adalah agen penemuan layanan yang mengelola informasi tentang lokasi, ketersediaan, dan status layanan mikro.  Layanan Microsoft menemukan satu sama lain dengan nama DNS, zona TTL adalah nol, layanan yang telah meninggal atau belum lulus pemeriksaan kesehatan berhenti menyelesaikan dan dengan demikian menerima lalu lintas; </li><li>  log yang ditulis oleh aplikasi dalam format yang dapat dimengerti oleh Elasticsearch ke file container lokal dan <code>filebeat</code> , yang berjalan pada mesin host relatif terhadap container, mengambil log ini dan mengirimkannya ke cluster Elasticsearch; <br><ul><li>  karena kami menerapkan platform sesuai dengan model Pengadaan Acara, rantai log yang dihasilkan juga digunakan untuk visualisasi dalam berbagai dasbor Grafana, yang memungkinkan kami mengurangi waktu untuk mengimplementasikan metrik yang berbeda (kami juga menggunakan metrik terpisah). </li></ul></li></ul><br><p><img src="https://habrastorage.org/webt/2v/ac/a2/2vaca2u7qtih8_1iqtl0h_2ywoq.jpeg"></p><br><p>  Ketika mengembangkan layanan microser, kami menggunakan batasan yang telah kami ciptakan secara khusus, yang dirancang untuk memecahkan masalah ketersediaan tinggi platform dan toleransi kesalahannya: </p><br><ul><li>  batas memori ketat untuk setiap wadah, ketika Anda melampaui batas - OOM, sebagian besar layanan microsecer hidup dalam 256-512M.  Ini membuatnya lebih terfragmentasi dalam implementasi logika bisnis, melindungi terhadap penyimpangan terhadap monolit, mengurangi biaya titik kegagalan, memberikan keuntungan tambahan kemampuan untuk bekerja pada perangkat keras yang murah (platform digunakan dan berjalan pada server prosesor tunggal yang murah); </li><li>  sesedikit mungkin layanan microsoft stateful dan implementasi stateless sebanyak mungkin.  Ini memungkinkan kami untuk memecahkan masalah toleransi kesalahan, kecepatan pemulihan dan, secara umum, meminimalkan tempat dengan perilaku yang berpotensi tidak dapat dipahami.  Ini menjadi sangat penting dengan peningkatan umur sistem ketika warisan besar terakumulasi; </li><li>  biarkan crash dan "itu pasti akan merusak" pendekatan.  Kami tahu bahwa setiap bagian dari sistem kami pasti akan gagal, jadi kami mendesainnya sehingga ini tidak mempengaruhi kebenaran umum dari informasi yang terakumulasi dalam platform.  Membantu meminimalkan jumlah status tidak terdefinisi dalam sistem. </li></ul><br><p>  <em>Tentunya tidak asing lagi bagi banyak pihak yang berintegrasi dengan pihak ketiga, situasi.</em>  <em>Kami mengharapkan tanggapan dari pihak ketiga terhadap permintaan untuk menghapus uang sesuai dengan protokol, dan jawaban yang sama sekali berbeda datang, tidak dijelaskan dalam spesifikasi apa pun, yang tidak diketahui bagaimana menafsirkannya.</em> </p><br><p>  Dalam situasi ini, kami membunuh mesin negara yang melayani pembayaran ini, tindakan apa pun dari luar akan menerima kesalahan 500. Dan di dalam kami mengetahui keadaan pembayaran saat ini, membawa keadaan mesin sesuai dengan kenyataan dan menghidupkan kembali mesin negara. </p><br><h2 id="protocol-oriented-development">  Pengembangan yang Berorientasi pada Protokol </h2><br><p><img src="https://habrastorage.org/webt/my/8p/o1/my8po16kkxanpoanxnzrea_i7gg.jpeg"></p><br><p>  Pada saat penulisan, 636 cek berbeda telah didaftarkan dalam Penemuan Layanan kami untuk layanan yang memastikan berfungsinya platform.  Bahkan dengan mempertimbangkan bahwa beberapa pemeriksaan sedang dilakukan pada satu layanan, dan juga bahwa sebagian besar layanan tanpa kewarganegaraan bekerja dalam setidaknya tiga kali lipat, Anda masih bisa mendapatkan lima puluh aplikasi yang harus dapat terhubung entah bagaimana satu sama lain dan tidak gagal di neraka RPC. </p><br><p>  Situasinya diperumit oleh fakta bahwa kami memiliki tiga bahasa pengembangan pada stack - Erlang, Java, JS, dan mereka semua harus dapat berkomunikasi secara transparan satu sama lain. </p><br><p>  Tugas pertama yang perlu dipecahkan adalah merancang arsitektur yang benar untuk bertukar data antara layanan microser.  Sebagai dasar, kami mengambil Apache Thrift.  Semua microservices bertukar binari trift, kami menggunakan HTTP sebagai transportasi. </p><br><p>  Kami menempatkan spesifikasi fonta dalam bentuk repositori terpisah di github kami, sehingga mereka tersedia untuk setiap pengembang yang memiliki akses ke sana.  Awalnya, mereka menggunakan satu repositori umum untuk semua protokol, tetapi seiring waktu mereka sampai pada kesimpulan bahwa ini adalah kerja paralel - sambungan yang tidak nyaman pada protokol yang berubah menjadi sakit kepala yang konstan.  Tim yang berbeda dan bahkan pengembang yang berbeda dipaksa untuk menyetujui nama variabel, upaya untuk memecah menjadi namespace juga tidak membantu. </p><br><p>  Secara umum, kita dapat mengatakan bahwa kita memiliki pengembangan berbasis protokol.  Sebelum memulai implementasi apa pun, kami mengembangkan protokol layanan-mikro di masa depan dalam bentuk spesifikasi lift, melewati 7 lingkaran peninjauan, menarik pelanggan-pelanggan masa depan dari layanan-mikro ini, dan mendapatkan kesempatan untuk secara bersamaan mulai mengembangkan beberapa layanan-mikro secara paralel, karena kami tahu semua metode di masa depan dan kami sudah dapat menulis penangan mereka, opsional menggunakan moki. </p><br><p>  Langkah terpisah dalam proses pengembangan protokol adalah tinjauan keamanan, di mana orang-orang melihat dari sudut pandang pentester mereka pada nuansa spesifikasi yang dikembangkan. </p><br><p>  Kami juga menganggap perlu untuk menyoroti peran terpisah dari pemilik protokol dalam tim.  Tugasnya sulit, seseorang harus mengingat secara spesifik semua layanan mikro, tetapi terbayar dalam urutan besar dan adanya satu titik eskalasi. </p><br><p>  Tanpa persetujuan final dari permintaan penarikan oleh karyawan ini, protokol tidak dapat digabung menjadi cabang utama.  Ada fungsi yang sangat nyaman di github untuk ini - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemilik kode</a> , kami menggunakannya dengan senang hati. </p><br><p>  Jadi, kami memecahkan masalah komunikasi antara layanan microser, kemungkinan masalah kesalahpahaman seperti apa layanan microser muncul di platform, dan mengapa itu diperlukan.  Serangkaian protokol ini mungkin satu-satunya bagian dari platform di mana kami tanpa syarat memilih kualitas daripada biaya dan kecepatan pengembangan, karena implementasi satu layanan-mikro dapat ditulis ulang secara relatif tanpa rasa sakit, dan protokol di mana beberapa lusin sudah mahal dan menyakitkan. </p><br><p>  Sepanjang jalan, pencatatan yang akurat membantu dalam memecahkan masalah dokumentasi.  Nama metode dan parameter yang dipilih secara wajar, beberapa komentar, dan spesifikasi yang didokumentasikan sendiri menghemat banyak waktu! </p><br><p>  Sebagai contoh, ini adalah bagaimana spesifikasi metode salah satu dari layanan microser kami terlihat, memungkinkan Anda untuk mendapatkan daftar peristiwa yang terjadi di platform: </p><br><pre> <code class="plaintext hljs">/**    */ typedef i64 EventID /* Event sink service definitions */ service EventSink { /** *       ,   *    ,  ,  `range`.  *      `0`  `range.limit` . * *   `range.after`    ,   * ,        , *   `EventNotFound`. */ Events GetEvents (1: EventRange range) throws (1: EventNotFound ex1, 2: base.InvalidRequest ex2) /** *         *  . */ base.EventID GetLastEventID () throws (1: NoLastEvent ex1) } /* Events */ typedef list&lt;Event&gt; Events /** * ,    -,  . */ struct Event { /** *  . *    ,     *      (total order). */ 1: required base.EventID id /** *   . */ 2: required base.Timestamp created_at /** *  -,  . */ 3: required EventSource source /** *  ,    ( ) *   -,  . */ 4: required EventPayload payload /** *      . *    . */ 5: optional base.SequenceID sequence } // Exceptions exception EventNotFound {} exception NoLastEvent {} /** * ,       -   */ exception InvalidRequest { /**          */ 1: required list&lt;string&gt; errors }</code> </pre> <br><h3 id="thrift-console-client">  Klien konsol hemat </h3><br><p>  Terkadang kita dihadapkan dengan tugas memanggil metode-metode tertentu dari layanan-mikro yang diperlukan secara langsung, misalnya, dengan tangan kita dari terminal.  Ini bisa berguna untuk debugging, memperoleh kumpulan data mentah, atau ketika tugas sangat jarang sehingga pengembangan antarmuka pengguna yang terpisah tidak praktis. </p><br><p>  Oleh karena itu, kami mengembangkan alat untuk diri kami sendiri yang menggabungkan fungsi <code>curl</code> , tetapi memungkinkan Anda untuk membuat permintaan trift dalam bentuk struktur JSON.  Kami memanggilnya sesuai - <code>woorl</code> .  Utilitas bersifat universal, cukup untuk mentransfer lokasi sembarang spesifikasi lift dengan menggunakan parameter baris perintah, ia akan melakukan sisanya sendiri.  Utilitas yang sangat nyaman, Anda dapat memulai pembayaran langsung dari terminal, misalnya. </p><br><p>  Ini adalah bagaimana daya tarik terlihat langsung ke microservice platform, yang bertanggung jawab untuk mengelola aplikasi (misalnya, untuk membuat toko).  Saya meminta data pada akun pengujian saya: </p><br><p><img src="https://habrastorage.org/webt/zk/9f/zy/zk9fzypaopdlugw06vwkso2qt0q.jpeg"></p><br><p>  <em>Mengamati pembaca mungkin memperhatikan satu fitur di tangkapan layar.</em>  <em>Kami juga tidak suka itu.</em>  <em>Hal ini diperlukan untuk mempercepat otorisasi panggilan trift antara layanan microser, perlu untuk merekatkan TLS dengan cara yang baik.</em>  <em>Tetapi sementara sumber daya, seperti biasa, tidak cukup.</em>  <em>Kami membatasi diri pada selungkup total perimeter tempat pemrosesan layanan microser.</em> </p><br><h2 id="protokoly-obscheniya-s-vneshnimi-sistemami">  Protokol untuk berkomunikasi dengan sistem eksternal </h2><br><p>  Untuk mempublikasikan spesifikasi angkat luar dan memaksa pedagang kami untuk berkomunikasi menggunakan protokol biner, kami menganggapnya terlalu kejam bagi mereka.  Itu perlu untuk memilih protokol yang dapat dibaca manusia yang akan memungkinkan kita untuk berintegrasi dengan kami, men-debug dan dapat dengan mudah mendokumentasikan.  Kami memilih standar Open API, juga dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Swagger</a> . </p><br><p>  Kembali ke masalah dokumentasi protokol, Swagger memungkinkan Anda untuk dengan cepat dan murah menyelesaikan masalah ini.  Jaringan ini memiliki banyak implementasi dari desain yang indah dari spesifikasi Swagger dalam bentuk dokumentasi pengembang.  Kami melihat semua yang dapat kami temukan dan akhirnya memilih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReDoc</a> , perpustakaan JS yang menerima swagger.json sebagai input, dan menghasilkan dokumentasi tiga kolom seperti itu pada output: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://developer.rbk.money/api/</a> . </p><br><p>  Pendekatan untuk pengembangan kedua protokol, penghematan internal dan kesombongan eksternal, benar-benar identik untuk kita.  Ini menambah waktu untuk pengembangan, tetapi terbayar dalam jangka panjang. </p><br><p>  Kami juga perlu menyelesaikan masalah penting lainnya - kami tidak hanya menerima permintaan untuk menghapus uang, tetapi juga mengirimkannya lebih lanjut - ke bank dan sistem pembayaran. </p><br><p>  Memaksa mereka untuk menerapkan lift kami akan menjadi tugas yang bahkan lebih tidak praktis daripada mengirimkannya ke API publik. </p><br><p>  Oleh karena itu, kami membuat dan menerapkan konsep adapter protokol.  Ini hanyalah layanan microser lain yang mengimplementasikan spesifikasi pengangkatan internal kami di satu sisi, yang sama untuk seluruh platform, dan yang kedua adalah protokol eksternal khusus untuk bank atau PS tertentu. </p><br><p>  <em>Masalah yang muncul saat menulis adaptor seperti itu ketika Anda harus berinteraksi dengan pihak ketiga adalah topik yang kaya akan berbagai cerita.</em>  <em>Dalam praktik kami, kami telah bertemu hal-hal yang berbeda, jawaban dari formulir: "Anda, tentu saja, dapat menerapkan fungsi ini seperti yang dijelaskan dalam protokol yang kami berikan kepada Anda, tetapi saya tidak memberikan jaminan apa pun. Inilah pasien kami yang akan semua jawaban ini, dan Anda meminta konfirmasi kepadanya. "</em>  <em>Juga, situasi seperti itu tidak jarang: "ini adalah nama pengguna dan kata sandi dari server kami, pergi ke sana dan konfigurasikan semuanya sendiri."</em> </p><br><p>  <em>Saya merasa sangat menarik ketika kami terintegrasi dengan mitra pembayaran, yang, pada gilirannya, sebelumnya terintegrasi dengan platform kami dan berhasil melakukan pembayaran melalui kami (ini sering terjadi, spesifik bisnis dari industri pembayaran).</em>  <em>Menanggapi permintaan kami untuk lingkungan pengujian, mitra menjawab bahwa ia tidak memiliki lingkungan pengujian seperti itu, tetapi ia bisa mendapatkan lalu lintas untuk integrasi dengan RBC, yaitu, dengan platform kami, di mana kami dapat terlibat.</em>  <em>Begitulah kita, melalui pasangan, terintegrasi dengan diri kita sendiri sekali.</em> </p><br><p>  Dengan demikian, kami cukup memecahkan masalah penerapan koneksi paralel massal dari berbagai sistem pembayaran dan pihak ketiga lainnya.  Dalam sebagian besar kasus, Anda tidak perlu menyentuh kode platform untuk ini, cukup tulis adapter dan tambahkan lebih banyak instrumen pembayaran ke enum. </p><br><p>  Akibatnya, kami mendapat skema kerja seperti itu - kami melihat di luar layanan mikro RBKmoney API (kami menyebutnya API Umum, atau capi *, Anda melihatnya di konsul di atas), yang memvalidasi input data sesuai dengan spesifikasi Swagger publik, mengesahkan klien, menyiarkan metode ini untuk panggilan angkat internal kami dan mengirimkan permintaan ke rantai ke layanan microser berikutnya.  Selain itu, layanan ini menerapkan persyaratan platform lain, spesifikasi teknis yang dirumuskan sebagai: "sistem harus selalu memiliki kesempatan untuk mendapatkan kucing." </p><br><p>  Ketika kita perlu melakukan panggilan ke beberapa sistem eksternal, microservices internal menarik metode lift adaptor protokol yang sesuai, mereka menerjemahkannya ke dalam bahasa bank atau sistem pembayaran tertentu dan mengirimkannya keluar. </p><br><h3 id="trudnosti-obratnoy-sovmestimosti-protokolov">  Protokol Kesulitan Kompatibilitas Mundur </h3><br><p>  Platform ini terus berkembang, fungsi baru ditambahkan, yang lama diubah.  Dalam keadaan seperti itu, Anda harus berinvestasi dalam mendukung kompatibilitas ke belakang atau terus-menerus memperbarui layanan microsoft yang tergantung.  Dan jika situasi ketika bidang yang diperlukan berubah menjadi opsional sederhana, Anda tidak dapat melakukan apa pun, maka dalam kasus sebaliknya Anda harus menghabiskan sumber daya tambahan. </p><br><p>  Dengan seperangkat protokol internal, segalanya menjadi lebih mudah.  Industri pembayaran jarang berubah sehingga beberapa metode interaksi baru yang fundamental muncul.  Ambil, misalnya, tugas umum bagi kami - menghubungkan penyedia baru dengan instrumen pembayaran baru.  Misalnya, pemrosesan dompet lokal, yang memungkinkan Anda memproses pembayaran di Kazakhstan di tenge.  Ini adalah dompet baru untuk platform kami, tetapi pada prinsipnya dompet tidak berbeda dari dompet Qiwi yang sama - dompet ini selalu memiliki beberapa pengidentifikasi unik dan metode yang memungkinkan Anda untuk mendebet / membatalkan debit dari itu. </p><br><p>  Dengan demikian, spesifikasi lift kami untuk semua penyedia dompet terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">typedef string DigitalWalletID struct DigitalWallet { 1: required DigitalWalletProvider provider 2: required DigitalWalletID id } enum DigitalWalletProvider { qiwi rbkmoney }</code> </pre> <br><p>  dan menambahkan cara pembayaran baru dalam bentuk dompet baru hanya melengkapi enum: </p><br><pre> <code class="plaintext hljs">enum DigitalWalletProvider { qiwi rbkmoney newwallet }</code> </pre> <br><p>  Sekarang tinggal menabrak semua layanan microser menggunakan spesifikasi ini, menyinkronkan dengan wizard repositori dengan spesifikasi dan meluncurkannya melalui CI / CD. </p><br><p>  Protokol eksternal lebih rumit.  Setiap pembaruan spesifikasi Swagger, terutama tanpa kompatibilitas ke belakang, hampir tidak mungkin untuk diterapkan dalam jangka waktu yang wajar - tidak mungkin bahwa mitra kami akan menjaga sumber daya pengembang gratis khusus untuk memperbarui platform kami. </p><br><p>  <em>Dan kadang-kadang ini tidak mungkin, kami kadang-kadang menghadapi situasi seperti: "programmer menulis kepada kami dan pergi, mengambil kode sumber dengannya, bagaimana kami bekerja, kami tidak tahu, ini bekerja dan tidak menyentuhnya."</em> </p><br><p>  Oleh karena itu, kami berinvestasi dalam mendukung kompatibilitas ke belakang pada protokol eksternal.  Dalam arsitektur kami, ini sedikit lebih mudah - karena kami menggunakan adapter protokol terpisah untuk setiap versi tertentu dari Common API, kami hanya membiarkan layanan microsoft lama berfungsi, hanya mengubah bagian yang terlihat seperti trift di dalam platform jika perlu.  Jadi microservices <code>capi-v1</code> , <code>capi-v2</code> , <code>capi-v3</code> dan seterusnya muncul dan tetap bersama kita selamanya. </p><br><p>  Apa yang akan terjadi ketika <code>capi-v33</code> kami mungkin harus mencabut beberapa versi lama, mungkin. </p><br><p>  <em>Pada titik ini, saya biasanya mulai memahami dengan sangat baik perusahaan seperti Microsoft dan semua kesulitan mereka dalam mendukung kompatibilitas mundur solusi yang telah bekerja selama beberapa dekade.</em> </p><br><h2 id="nastraivaem-sistemu">  Sesuaikan sistem </h2><br><p>  Dan, mengakhiri topik, kami akan memberi tahu Anda bagaimana kami mengelola pengaturan platform khusus bisnis. </p><br><p>  Hanya melakukan pembayaran tidak semudah kelihatannya.  Untuk setiap pembayaran, pelanggan bisnis ingin melampirkan sejumlah besar kondisi - mulai dari komisi hingga, pada prinsipnya, kemungkinan implementasi yang sukses tergantung pada waktu hari.  Kami menetapkan tugas untuk mendigitalkan seluruh rangkaian kondisi yang dapat ditemukan oleh pelanggan bisnis sekarang dan di masa depan dan menerapkan set ini untuk setiap pembayaran yang baru diluncurkan. </p><br><p>  Sebagai hasilnya, kami memutuskan untuk mengembangkan DSL kami sendiri, di mana kami mengacaukan alat untuk manajemen yang nyaman yang memungkinkan kami untuk menggambarkan model bisnis dengan cara yang benar: pilihan adapter protokol, deskripsi rencana posting, yang menurutnya uang akan tersebar ke dalam akun dalam sistem, menetapkan batas, komisi, kategori dan hal-hal lain khusus untuk sistem pembayaran. </p><br><p>  Misalnya, ketika kami ingin mengambil komisi 1% untuk memperoleh kartu maestro dan MS dan menyebarkannya di akun di dalam sistem, kami mengonfigurasi domain seperti ini: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"cash_flow"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"decisions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"if_"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"any_of"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"condition"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"payment_tool"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bank_card"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"definition"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"payment_system_is"</span></span>: <span class="hljs-string"><span class="hljs-string">"maestro"</span></span> } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"condition"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"payment_tool"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bank_card"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"definition"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"payment_system_is"</span></span>: <span class="hljs-string"><span class="hljs-string">"mastercard"</span></span> } } } } } ] }, <span class="hljs-attr"><span class="hljs-attr">"then_"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"system"</span></span>: <span class="hljs-string"><span class="hljs-string">"settlement"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"destination"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"provider"</span></span>: <span class="hljs-string"><span class="hljs-string">"settlement"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"volume"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"share"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"parts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"p"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"q"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"of"</span></span>: <span class="hljs-string"><span class="hljs-string">"operation_amount"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"details"</span></span>: <span class="hljs-string"><span class="hljs-string">"1% processing fee"</span></span> } ] } } ] } }</code> </pre> <br><p>  ,         ,   .     ,             JSON.    ,    ,    ,  .        ,  ,     .  ,  CVS/SVN-. </p><br><p>    "               ". , ,     ,     1%,   ,    ,    .    ,        ,   .         ,         . </p><br><p> <em> cvs-like        ,       .   ,    â€”  stateless, ,               .         .         .</em> </p><br><p> <em>    -     .            ,      ,   .     ,    ,                   .</em> </p><br><p> <em>             .     ,   10   ,     ,           .</em> </p><br><p>     , ,    ,   -,       woorl-.    -        JSON-  .    -  JS,       ,      UX: </p><br><p><img src="https://habrastorage.org/webt/c0/ni/ge/c0nigeglg1reebztmvml6svc7ia.jpeg"></p><br><p>           ,    ,         ,          . </p><br><p>     , , . </p><br><p>        ,     ,       SaltStack. </p><br><p> ,    ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443518/">https://habr.com/ru/post/id443518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443508/index.html">Game papan pendidikan untuk programmer</a></li>
<li><a href="../id443510/index.html">Notebook Compaq Armada 7700 - sebagai pengembangan dari lini Compaq LTE</a></li>
<li><a href="../id443512/index.html">Analisis Data Hackathon di Nizhny Novgorod</a></li>
<li><a href="../id443514/index.html">Menulis lapisan jaringan Anda di Swift: pendekatan berorientasi protokol</a></li>
<li><a href="../id443516/index.html">Hacker Geohot memutuskan untuk membebaskan orang dari simulasi AI</a></li>
<li><a href="../id443520/index.html">Memilih mobil untuk spesialis IT, atau tips untuk poci teh dari poci teh</a></li>
<li><a href="../id443522/index.html">Hosting: opsi, perbandingan, statistik pengguna</a></li>
<li><a href="../id443524/index.html">Animasi Flash mandiri di Unity3D. Bagian Satu, Liris</a></li>
<li><a href="../id443526/index.html">Dari Algoritma ke Kanker: Ceramah dari School of Bioinformatics</a></li>
<li><a href="../id443528/index.html">Amazon merilis Open Distro untuk Elasticsearch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>