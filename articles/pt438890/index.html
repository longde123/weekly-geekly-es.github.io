<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚≠ïÔ∏è üë®üèø‚Äçüíª üë©üèº‚Äçü§ù‚Äçüë®üèæ Postgres em retrospecto ‚ò∏Ô∏è ‚ôìÔ∏è ‚è∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Trazemos a sua aten√ß√£o uma tradu√ß√£o do artigo de Joseph Hellerstein, ‚ÄúOlhando para tr√°s no Postgres‚Äù , publicado sob a afirma√ß√£o internacional de dire...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Postgres em retrospecto</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/438890/">  <em>Trazemos a sua aten√ß√£o uma tradu√ß√£o <strong>do</strong> artigo de <strong>Joseph Hellerstein, ‚ÄúOlhando para tr√°s no Postgres‚Äù</strong> , publicado sob a <strong>afirma√ß√£o</strong> internacional de <strong>direitos autorais</strong> da Creative Commons vers√£o 4.0 (CC-BY 4.0).</em>  <em>Os autores reservam-se o direito de distribuir este trabalho em sites pessoais e corporativos com um link adequado para a fonte.</em> <br><br>  <em>Tradu√ß√£o feita por Elena Indrupskaya.</em>  <em>Acrescentarei por conta pr√≥pria que "um programador que queria desesperadamente criar um sistema com v√°rias vers√µes" parece ser Vadim Mikheev, mas todos conhecemos os "volunt√°rios da R√∫ssia" que reescreveram o GiST.</em> <br><br><h1>  Anota√ß√£o </h1><br>  Esta √© uma lembran√ßa do projeto Postgres, realizado na Universidade da Calif√≥rnia em Berkeley e liderado por Mike Stonebraker, de meados da d√©cada de 1980 a meados da d√©cada de 90.  Como uma das muitas mem√≥rias pessoais e hist√≥ricas, este artigo foi solicitado para um livro [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bro19</a> ] sobre o Pr√™mio Turing de Stonebreaker.  Portanto, o foco do artigo √© o papel principal de Stonebreaker e seus pensamentos sobre design.  Mas Stonebreaker nunca foi um programador e n√£o interferiu em sua equipe de desenvolvimento.  A base de c√≥digo do Postgres foi o trabalho de uma equipe de estudantes brilhantes e, ocasionalmente, de programadores universit√°rios em tempo integral que tinham um pouco mais de experi√™ncia (e apenas um sal√°rio um pouco maior) do que os estudantes.  Tive a sorte de ingressar nesta equipe como estudante nos √∫ltimos anos do projeto.  Recebi material √∫til para este artigo de alguns dos alunos mais velhos envolvidos no projeto, mas quaisquer erros ou omiss√µes s√£o meus.  Se voc√™ notar algum deles, entre em contato comigo e tentarei consert√°-los. <br><a name="habracut"></a><br><h1>  1. Introdu√ß√£o </h1><br>  O Postgres foi o projeto mais ambicioso de Michael Stonebreaker - sua s√©ria tentativa de criar um sistema de banco de dados universal.  Por uma d√©cada, o projeto gerou mais artigos, PhDs, professores e empresas do que qualquer outra atividade do Stonebreaker.  O projeto tamb√©m abrangeu mais do campo t√©cnico do que qualquer outro sistema que ele construiu.  Apesar do risco inerente dessa magnitude, o Postgres tamb√©m se tornou o artefato de software mais bem-sucedido que saiu das equipes de pesquisa do Stonebreaker e sua principal contribui√ß√£o para o c√≥digo aberto.  Este √© um exemplo de um "segundo sistema" [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bro75</a> ] que foi bem-sucedido.  No momento da reda√ß√£o deste artigo, mais de trinta anos desde o in√≠cio do projeto, o sistema PostgreSQL de c√≥digo aberto √© o sistema de banco de dados de c√≥digo aberto independente mais popular do mundo e o quarto sistema de banco de dados mais popular.  Enquanto isso, as empresas criadas a partir do Postgres geraram um total de mais de US $ 2,6 bilh√µes (em custo de aquisi√ß√£o).  De qualquer forma, a vis√£o do Quebra-pedras do Postgres teve uma enorme resson√¢ncia duradoura. <br><br><h2>  1.1  Antecedentes </h2><br>  Stonebreaker foi um grande sucesso no in√≠cio de sua carreira com o projeto de pesquisa de Ingres Berkeley [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SHWK76</a> ] e a subsequente startup, que ele fundou com Larry Rowe e Eugene Wong: Relational Technology, Inc.  (RTI). <br><br>  √Ä medida que a RTI se desenvolveu no in√≠cio dos anos 80, o Stonebreaker come√ßou a trabalhar no suporte a tipos de dados em DBMSs que iam al√©m das linhas e colunas tradicionais do modelo relacional original do Codd (Edgar Frank Codd).  Um exemplo motivador da √©poca era a necessidade de bancos de dados para suportar ferramentas de projeto auxiliado por computador (CAD) para a ind√∫stria microeletr√¥nica.  Em um artigo de 1983 de Stonebreaker e estudantes, Brad Rubenstein e Antonin Guttman explicaram o quanto esse setor precisa para suportar "novos tipos de dados como pol√≠gonos, ret√¢ngulos, seq√º√™ncias de texto, etc.", " busca espacial efetiva ‚Äù,‚Äú restri√ß√µes complexas de integridade ‚Äù, bem como‚Äú hierarquias de design e m√∫ltiplas representa√ß√µes ‚Äùnas mesmas estruturas f√≠sicas [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SRG83</a> ].  Com essa motiva√ß√£o, o grupo come√ßou a trabalhar na indexa√ß√£o (incluindo o uso de √°rvores R de Guttman para indexa√ß√£o espacial [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gut84</a> ]) e na adi√ß√£o de tipos de dados abstratos (ADTs) ao sistema de banco de dados relacional.  Naquela √©poca, os ADTs eram um novo design popular de linguagens de programa√ß√£o, que foi introduzido pela primeira vez por Barbara Liskov, mais tarde ganhadora do Pr√™mio Turing e explorada na programa√ß√£o de aplicativos de banco de dados por Lonely Rowe, uma nova colaboradora do Stonebreaker.  Um artigo do SIGMOD Record [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OFS83</a> ] de 1983, Stonebreaker e os alunos James Ong e Dennis Fogg descrevem um estudo desse conceito na extens√£o de Ingres chamado ADT-Ingres, que inclu√≠a muitos dos conceitos de apresenta√ß√£o estudados mais profundamente e com melhor suporte ao sistema no Postgres. <br><br><h1>  2. Postgres: informa√ß√µes gerais </h1><br>  Como o nome indica, Postgres √© Post-Ingres: um sistema projetado para pegar o que Ingres poderia fazer e ir al√©m.  Uma caracter√≠stica distintiva do Postgres foi a introdu√ß√£o do que chamou de propriedades relacionais a objetos do banco de dados: suporte ao conceito de programa√ß√£o orientada a objetos no modelo de dados e na linguagem de consulta declarativa do sistema de banco de dados.  Mas o Stonebreaker tamb√©m planejava resolver uma s√©rie de outros problemas tecnol√≥gicos, independentemente do suporte orientado a objetos no Postgres, como regras de banco de dados ativo, dados de vers√£o, armazenamento de n√≠vel superior e simultaneidade. <br><br>  Dois artigos foram escritos sobre o design do Postgres: uma descri√ß√£o do design inicial em 1986 SIGMOD [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SR86</a> ] e uma descri√ß√£o intermedi√°ria no CACM 1991 [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SK91</a> ].  O projeto de pesquisa do Postgres foi gradualmente frustrado em 1992, com a funda√ß√£o da Illustra, uma startup que envolveu o Stonebreaker, o principal aluno de gradua√ß√£o Wei Hong e depois se tornou o programador-chefe Jeff Meredith.  Na lista abaixo, as oportunidades mencionadas no artigo de 1986 s√£o marcadas com um asterisco *, e as oportunidades do artigo de 1991, que n√£o estavam no artigo de 1986, s√£o marcadas com uma adaga <sup>‚Ä†</sup> .  As outras tarefas listadas abaixo foram realizadas no sistema e na literatura de pesquisa, mas n√£o foram encontradas em nenhuma especifica√ß√£o de projeto.  Muitos desses t√≥picos foram abordados no Postgres muito antes de serem estudados ou reinventados por outros.  Em muitos casos, o Postgres estava muito √† frente de seu tempo, e o interesse em t√≥picos aumentou mais tarde, de uma perspectiva moderna. <br><br><ol><li>  Suporte ADT no sistema de banco de dados <br><ul><li>  Objetos complexos (ou seja, dados aninhados ou dados de formul√°rio n√£o-primeiro-normal (formul√°rio n√£o-primeiro-normal - NF2)) * </li><li>  Tipos de dados abstratos personalizados e fun√ß√µes * </li><li>  M√©todos de acesso extens√≠veis para novos tipos de dados * </li><li>  Processamento de consultas otimizado com recursos caros definidos pelo usu√°rio </li></ul></li><li>  Bancos de dados ativos e sistemas de regras (gatilhos, avisos) * <br><ul><li>  Regras implementadas como reescrita de solicita√ß√£o <sup>‚Ä†</sup> </li><li>  Regras implementadas como gatilhos de n√≠vel de grava√ß√£o <sup>‚Ä†</sup> </li></ul></li><li>  Armazenamento e recupera√ß√£o com base em log <br><ul><li>  C√≥digo de recupera√ß√£o de complexidade reduzida que trata o log como dados *, usando mem√≥ria n√£o vol√°til para o estado de confirma√ß√£o <sup>‚Ä†</sup> </li><li>  Armazenamento n√£o reescrito e consultas temporais <sup>‚Ä†</sup> </li></ul></li><li>  Suporte para novas tecnologias de armazenamento profundo, especialmente discos √≥pticos * </li><li>  Suporte para multiprocessadores e processadores especializados * </li><li>  Suporte para v√°rios modelos de idiomas <br><ul><li>  Altera√ß√µes m√≠nimas no modelo relacional e suporte para consultas declarativas * </li><li>  Acesso ao "caminho r√°pido" das APIs internas ignorando o idioma da consulta <sup>‚Ä†</sup> </li><li>  Multilinguismo <sup>‚Ä†</sup> </li></ul></li></ol><br>  Discutiremos brevemente a contribui√ß√£o do Postgres para cada um desses itens em rela√ß√£o ao trabalho subsequente no campo da computa√ß√£o. <br><br><h2>  2.1  Suporte ADT no sistema de banco de dados </h2><br>  O objetivo claro do Postgres era oferecer suporte a novas propriedades relacionais a objetos: expandir a tecnologia de banco de dados para fornecer os benef√≠cios do processamento de consultas relacionais e da programa√ß√£o orientada a objetos.  Com o tempo, o conceito objeto-relacional que apareceu pela primeira vez no Postgres se tornou uma funcionalidade padr√£o na maioria dos sistemas de banco de dados modernos. <br><br><h3>  2.1.1  Objetos complexos </h3><br>  Frequentemente, os dados s√£o representados como entidades aninhadas ou "objetos".  Um exemplo cl√°ssico √© um pedido de compra, que possui um conjunto incorporado de produtos, suas quantidades e pre√ßos.  A religi√£o da modelagem relacional determinava que esses dados fossem reestruturados e salvos em um formato sem aninhamento, usando v√°rias tabelas simples de objetos (pedidos, produtos) e conectando tabelas simples de rela√ß√µes (product_in_order).  Um motivo t√≠pico para esse achatamento √© que ele reduz a duplica√ß√£o de dados (porque o produto √© descrito de forma redundante em muitos pedidos), o que, por sua vez, evita a complexidade ou os erros ao atualizar todas as c√≥pias redundantes.  Mas, em alguns casos, voc√™ deseja manter a subvis√£o, porque √© natural para a aplica√ß√£o (por exemplo, o mecanismo de layout do circuito no CAD), e as atualiza√ß√µes s√£o raras.  Esse debate sobre modelagem de dados √© pelo menos t√£o antigo quanto o modelo relacional. <br><br>  A principal abordagem do Postgres foi ‚Äúsentar em duas cadeiras‚Äù em termos de modelagem de dados: o Postgres salvou tabelas como o tipo de dados ‚Äúmais externo‚Äù, mas permitiu que as colunas tivessem tipos ‚Äúcomplexos‚Äù, incluindo tuplas ou tabelas aninhadas.  Uma de suas implementa√ß√µes menos comuns, investigada pela primeira vez no prot√≥tipo ADT-Ingres, era permitir que uma coluna de tipo de tabela fosse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">declarada</a> declarativamente como uma defini√ß√£o de consulta: "Quel como um tipo de dados" [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SAHR84</a> ] <em>(Quel - linguagem de consulta Ingres. - Aprox. .)</em> . <br><br>  O t√≥pico ‚Äúp√≥s-relacional‚Äù de suporte para consultas declarativas e dados incorporados reapareceu ao longo dos anos, geralmente gerado por disputas sobre qual √© o melhor.  Durante o Postgres nas d√©cadas de 1980 e 1990, alguns grupos envolvidos em bancos de dados orientados a objetos captaram essa id√©ia e a desenvolveram na linguagem OQL padr√£o, que deixou de ser usada. <br><br>  Na virada do mil√™nio, as consultas declarativas sobre objetos aninhados tornaram-se uma obsess√£o pela pesquisa para o segmento da comunidade de desenvolvedores de banco de dados na forma de bancos de dados XML.  A linguagem XQuery resultante (liderada por Don Chamberlin, a persona do SQL) √© necess√°ria para suportar objetos complexos na linguagem Postgel do Postgres.  O XQuery √© amplamente utilizado e amplamente utilizado na ind√∫stria, mas nunca foi popular entre os usu√°rios.  Hoje, esses conceitos est√£o sendo reexaminados em projetos de linguagem de consulta para o modelo de dados JSON, popular em aplicativos baseados em navegador.  Como o OQL, em grupos que inicialmente rejeitaram consultas declarativas em favor da programa√ß√£o orientada a desenvolvedores (o movimento ‚ÄúNoSQL‚Äù), essas linguagens geralmente emergem como uma adi√ß√£o tardia apenas do desejo de adicionar consultas ao sistema.  Ao mesmo tempo, √† medida que o Postgres cresceu ao longo dos anos (e passou da linguagem de consulta Postquel para as vers√µes SQL que atendem a muitos dos objetivos considerados), ele incluiu suporte para dados incorporados, como XML e JSON, em DBMSs de uso geral, sem a necessidade de ou redesenho significativo.  A controv√©rsia est√° ocorrendo com graus variados de sucesso, e a abordagem do Postgres de expandir a estrutura relacional usando extens√µes para dados aninhados provou repetidamente ser um estado final natural para todas as partes ap√≥s o t√©rmino dos argumentos. <br><br><h3>  2.1.2  Tipos de dados abstratos personalizados e fun√ß√µes </h3><br>  Al√©m de sugerir tipos aninhados, o Postgres prop√µe a id√©ia de introduzir ADTs opacas e extens√≠veis que s√£o armazenadas no banco de dados, mas n√£o s√£o interpretadas pelo kernel.  Basicamente, isso sempre fez parte do modelo relacional de Codd: n√∫meros inteiros e seq√º√™ncias de caracteres eram tradicionais, mas, na verdade, o modelo relacional abrange qualquer tipo de dado at√¥mico com predicados.  A tarefa era fornecer essa flexibilidade matem√°tica em software.  Para usar consultas que interpretam esses objetos e os manipulam, um programador de aplicativo deve poder registrar UDFs (fun√ß√µes definidas pelo usu√°rio) para esses tipos no sistema e chamar essas fun√ß√µes nas consultas.  Tamb√©m √© desej√°vel que as fun√ß√µes agregadas definidas pelo usu√°rio (UDA) resumam as cole√ß√µes desses objetos nas consultas.  O sistema de banco de dados Postgres foi inovador, oferecendo suporte abrangente a esses recursos. <br><br>  Por que colocar essa funcionalidade em um DBMS, em vez de em aplicativos de alto n√≠vel?  A resposta t√≠pica para essa pergunta foi uma vantagem significativa no desempenho do c√≥digo colocado nos dados sobre a "extra√ß√£o" dos dados para o c√≥digo.  O Postgres mostrou que isso √© bastante natural em um ambiente relacional: apenas pequenas altera√ß√µes foram necess√°rias no cat√°logo de metadados relacionais e foram criados mecanismos de chamada de c√≥digo de terceiros, mas a sintaxe da consulta, a sem√¢ntica e a arquitetura do sistema funcionaram de maneira simples e elegante. <br><br>  O Postgres est√° um pouco √† frente do seu tempo na explora√ß√£o dessa funcionalidade.  Em particular, naquele momento, a comunidade de pesquisa de banco de dados n√£o estava particularmente preocupada com as implica√ß√µes de seguran√ßa do download de c√≥digo n√£o seguro no servidor.  Isso come√ßou a ser percebido como um problema quando a tecnologia foi percebida no setor.  O Stonebreaker levou o Postgres ao mercado em sua startup Illustra, que a Informix adquiriu em grande parte por sua capacidade de oferecer suporte a pacotes de extens√£o DataBlade, incluindo UDF.  O Informix, com sua tecnologia baseada no Postgres e fortes ofertas de bancos de dados paralelos, tornou-se uma amea√ßa significativa para a Oracle.  A Oracle investiu pesadamente no marketing negativo dos riscos associados √† capacidade do Informix de executar o c√≥digo C do usu√°rio "inseguro".  Alguns atribuem a morte do Informix a esta campanha, embora a fraude financeira do Informix (e subsequente processo federal do seu ent√£o CEO) certamente tenha apresentado problemas mais s√©rios.  Agora, d√©cadas depois, todos os principais provedores de bancos de dados suportam fun√ß√µes personalizadas em um ou mais idiomas, usando novas tecnologias para proteger contra falhas no servidor ou corrup√ß√£o de dados. <br><br>  Enquanto isso, as pilhas de tecnologia dos big data dos anos 2000, incluindo o fen√¥meno MapReduce, que "estragou muito sangue" por Stonebreaker e David DeWitt [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DS08</a> ], s√£o uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reimplementa√ß√£o</a> da id√©ia do Postgres - c√≥digo de usu√°rio publicado como parte da solicita√ß√£o.  Parece que o MapReduce combina amplamente as id√©ias de desenvolvimento de software do Postgres com as id√©ias de simultaneidade de sistemas como Gamma e Teradata, com algumas pequenas inova√ß√µes em torno de reiniciar o processo de consulta para cargas de trabalho com extrema escalabilidade.  As startups baseadas no Postgres, Greenplum e Aster, por volta de 2007, mostraram que o paralelismo do Postgres poderia levar a algo muito mais funcional e pr√°tico do que o MapReduce para a maioria dos clientes, mas em 2008 o mercado ainda n√£o estava preparado para essa tecnologia. .  At√© agora, em 2018, quase toda pilha de big data lida basicamente com a carga de trabalho SQL paralela com o UDF, que √© muito semelhante ao design usado pelo Stonebreaker e pela equipe no Postgres. <br><br><h3>  2.1.3  M√©todos de acesso extens√≠vel para novos tipos de dados </h3><br>  Bancos de dados relacionais desenvolvidos na mesma √©poca que as √°rvores B no in√≠cio dos anos 70, e as √°rvores B ajudaram a Codd sonhar com ‚Äúindepend√™ncia do armazenamento f√≠sico de dados‚Äù: a indexa√ß√£o com √°rvores B fornece um n√≠vel de indire√ß√£o que Reorganiza adaptativamente o armazenamento f√≠sico sem exigir altera√ß√µes no aplicativo.  A principal limita√ß√£o das √°rvores B e de suas estruturas associadas era que elas suportam apenas pesquisas e consultas sobre igualdade no intervalo unidimensional.  Mas e se voc√™ tiver consultas de intervalo bidimensional t√≠picas de aplicativos de mapeamento e CAD?  Esse problema era conhecido durante o Postgres, e o R-tree [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gut84</a> ], desenvolvido por Antonin Guttman no grupo Stonebreaker, foi um dos novos √≠ndices de maior sucesso projetados para resolver esse problema na pr√°tica.  No entanto, a inven√ß√£o da estrutura de √≠ndice n√£o resolve o problema de suportar faixas multidimensionais em um DBMS para sistemas complexos.  H√° muitas perguntas.  Voc√™ pode adicionar facilmente um m√©todo de acesso, como √°rvores R, ao seu DBMS?  Voc√™ pode ensinar o otimizador a entender que o m√©todo de acesso especificado ser√° √∫til para determinadas consultas?  Voc√™ consegue a recupera√ß√£o correta e o acesso simult√¢neo?  Esse foi um ponto muito ousado no programa de a√ß√£o do Postgres: um problema de arquitetura de software que afeta a maior parte do mecanismo de banco de dados, do otimizador √† camada de armazenamento e o sistema de registro em di√°rio e recupera√ß√£o.  As √°rvores R do Postgres se tornaram uma for√ßa motriz poderosa e um excelente exemplo da extensibilidade elegante da camada do m√©todo de acesso e sua integra√ß√£o ao otimizador de consultas.  O Postgres mostrou, usando um ADT opaco, como registrar um m√©todo de acesso descrito abstratamente (neste caso, uma √°rvore R) e como um otimizador de consulta pode reconhecer um predicado de sele√ß√£o abstrata (nesse caso, uma op√ß√£o de intervalo) e combin√°-lo com esse m√©todo de acesso abstratamente descrito.  Menos aten√ß√£o foi dada ao controle de acesso simult√¢neo no trabalho inicial: a falta de ordem unidimensional de chaves tornou a trava usada nas √°rvores B neste caso inaplic√°vel. <br><br>  <em>As caracter√≠sticas promissoras dos m√©todos de acesso extens√≠vel do Postgres inspiraram um dos meus primeiros projetos de pesquisa no final da p√≥s-gradua√ß√£o: √Årvores de Pesquisa Generalizada - GiST [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HNP95</a> ] e o conceito subseq√ºente da teoria da indexa√ß√£o [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HKM <sup>+</sup> 02</a> ].</em>  <em>Eu implementei o GiST no Postgres por um semestre depois de concluir meu doutorado, o que tornou ainda mais f√°cil adicionar a nova l√≥gica de indexa√ß√£o ao Postgres.</em>  <em>A disserta√ß√£o de Marcel Kornacker de Berkeley (Marcel Kornacker) resolveu os problemas complexos de recupera√ß√£o e acesso simult√¢neo, apresentados pelo extens√≠vel tipo "modelo" de √≠ndice GiST [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">KMH97</a> ].</em> <br><br>  Hoje, o PostgreSQL combina favoravelmente a arquitetura original do software de m√©todos de acesso extens√≠vel (possui √≠ndices B-tree, GiST, SP-GiST e Gin) com a extensibilidade e intenso acesso competitivo da interface da √°rvore de pesquisa generalizada (GiST).  Os √≠ndices GiST suportam o popular sistema de informa√ß√£o geogr√°fica PostGIS baseado no PostgreSQL.  Os √≠ndices Gin fornecem suporte interno √† indexa√ß√£o de texto no PostgreSQL. <br><br><h3>  2.1.4  Otimizador de consultas com UDFs dispendiosos </h3><br>  Na otimiza√ß√£o de consulta tradicional, a tarefa era minimizar a quantidade de fluxo de tupla (e, portanto, opera√ß√µes de E / S) criadas ao processar a solicita√ß√£o.  Isso significava que as instru√ß√µes que filtram as tuplas (busca) s√£o boas no in√≠cio do plano de consulta, enquanto as instru√ß√µes que podem gerar novas tuplas (associa√ß√£o) precisam ser executadas posteriormente.  Como resultado, os otimizadores de consulta "empurram" os operadores de busca abaixo das conex√µes e os organizam aleatoriamente, concentrando-se na otimiza√ß√£o inteligente de conex√µes e acessos a disco.  As UDFs mudaram a abordagem: se voc√™ tiver UDFs caras em suas instru√ß√µes de amostra, a ordem de execu√ß√£o das UDFs pode ser cr√≠tica para otimizar o desempenho.  Al√©m disso, se o UDF no operador de sele√ß√£o realmente levar muito tempo, √© poss√≠vel que a sele√ß√£o seja realizada ap√≥s as conex√µes (ou seja, a sele√ß√£o deve ser "puxada para cima" - sele√ß√£o "puxada").  A considera√ß√£o desses fatores complicou o espa√ßo de pesquisa para o otimizador.  Tomei esse problema como a primeira tarefa dif√≠cil na p√≥s-gradua√ß√£o, e acabou sendo o assunto do trabalho de meu mestrado com Stonebreaker em Berkeley e meu Ph.D. em Wisconsin sob a dire√ß√£o de Jeff Naughton, mas com a ajuda constante de conselhos de Stonebreaker.  O Postgres foi o primeiro DBMS a armazenar o custo e a seletividade de fun√ß√µes definidas pelo usu√°rio em um diret√≥rio de banco de dados.  Abordamos o problema de otimiza√ß√£o, apresentando a ordem ideal das opera√ß√µes de amostragem e, em seguida, a altern√¢ncia ideal das opera√ß√µes de amostragem ao longo dos ramos de cada √°rvore de conex√£o considerada na pesquisa do plano.         System R           . <br><br> <em>    ,      ,               . ,     ,     .</em> <br><br>          PostgreSQL       ,            . ,   ,     , ,  2018       . , ,         ,      ,   ,       .    ,  Postgres    . <br><br> <em>  , ,    ,        PostgreSQL       (Neil Conway),                      ¬´ ¬ª .</em> <br><br><h2>  2.2       </h2><br>  Postgres                   .       :  ,      ¬´  ¬ª,     1990- . <br><br>              .  ‚Äî         Datalog.   ¬´  ¬ª  : , ,                . <br><br> <em>Datalog                ,  -   . Datalog ‚Äî     ¬´ ¬ª     .        ,     ,             .</em> <br><br>   ,     ,     ,             ,       .             . <br><br>             (Eric Hanson),     Ingres,       Postgres.         (Spyros Potamianos)  PRS2: Postgres Rules System 2.           .    ‚Äî     .      ,      Ingres.      ¬´   ¬ª   ¬´       ¬ª. ,   ¬´      ¬ª     ¬´    10%¬ª.     ,     ¬´   ¬ª,           .         (     ),    . <br><br> <em>      PRS2 ,   , .     Postgres       (,  )    Postgres  3.1  1991  (  ):</em> <br><br><pre> <em><font></font>
*        :<font></font>
*     .        <font></font>
*  (. .        <font></font>
* "" )    .   -  <font></font>
*   () .        .<font></font>
*   .    .     <font></font>
*   .  ...<font></font>
* ,  , ? ,    ,  .<font></font>
*         , <font></font>
*  ...</em> </pre><br>       Postgres    ,          ¬´¬ª ‚Äî      .            PostgreSQL,     -           . <br><br>   Postgres          ¬´  ¬ª     IBM Starburst  MCC HiPAC.      SQL        .      .      ,  ,   ,      ,    ¬´  ¬ª:        ,      .  ,   -       ,    ,    ,  ,   .       ,     ,      ,         ,     Postgres. <br><br><h2> 2.3. X      </h2><br>       Postgres  : <br><blockquote>    Postgres,      - .            (write-ahead log ‚Äî WAL),   ,     .  ,   Ingres 1970-     ,         . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SK91</a> ] <br></blockquote>   ,    ,       .               ,    IBM  Tandem    .           :      -  ,   ,      ,    . <br><br> X Postgres             .       ,           ,   , ‚Äî     ¬´  ¬ª  ¬´  ¬ª      .   ,  , ‚Äî         .     ,    ¬´¬ª       .      :                ,      .     Postgres,   ,           ,             ,      [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sto87</a> ].    Postgres   . <br><br>    ¬´ ¬ª           ,      ,        .                    .  ,        ,      ,        ,      Postgres.     Postgres      .         PostgreSQL      . <br><br> <em> , PostgreSQL       :        .   ,  PostgreSQL    ,      Postgres,   ,       Postgres  .    ,      (snapshot isolation) Oracle       -,             .</em> <br><br> <em>  (Mike Olson) ,       ,    B- Postgres    B-   Berkeley DB,       Postgres.         .    Berkeley DB     Sleepycat Corp.,    ()  PostgreSQL       ¬´ ¬ª.  :    ,        (MVCC),       ,   .</em> <br><br> <em>   PostgreSQL     .  Greenplum  PostgreSQL        .      (Matt McCline)‚Äî    (Jim Gray)   Tandem.      .</em> <br><br>         .  ,                   NoSQL (  ,   WAL),        (MMDB ‚Äî main memory databases,        ).              ,            .  ,             . <br><br><h2> 2.4.           </h2><br>  No meio do projeto Postgres, o Stonebreaker se inscreveu como um dos executivos de uma grande bolsa digital de ci√™ncias terrestres chamada Project Sequoia.  Parte da proposta de concess√£o foi o processamento de quantidades sem precedentes de imagens digitais de sat√©lite, exigindo at√© 100 terabytes de mem√≥ria, ou seja, uma quantidade muito maior de dados do que seria sensato armazenar em discos magn√©ticos naquele momento.  A base da solu√ß√£o proposta foi investigar a id√©ia de criar um DBMS (ou seja, o Postgres), que facilita o acesso ao armazenamento "terci√°rio" semi-aut√¥nomo fornecido por unidades rob√≥ticas com substitui√ß√£o autom√°tica de disco para gerenciar bibliotecas de discos ou fitas √≥pticas. <br><br>  Isso levou a v√°rios estudos diferentes.  Um deles era o sistema de arquivos Inversion - uma tentativa de fornecer uma abstra√ß√£o do sistema de arquivos UNIX atrav√©s de um DBMS relacional.  Em um artigo de revis√£o para Sequoia, Stonebreaker o descreveu em seu estilo usual de "exerc√≠cio simples" condescendente [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sto95</a> ].  De fato, Mike Olson, um estudante da Stonebreaker (e o subsequente fundador da Cloudera), est√° ocupado com isso h√° v√°rios anos, e o resultado final n√£o foi muito direto [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ols93</a> ] e n√£o sobreviveu na pr√°tica. <br><br>  <em>Alguns anos depois, o Inversion Bill Gates ‚Äúlutou contra os mesmos moinhos de vento‚Äù no WinFS - uma tentativa de recriar o sistema de arquivos mais usado no mundo atrav√©s do back-end de um banco de dados relacional.</em>  <em>O WinFS foi enviado em vers√µes de desenvolvimento do Windows, mas nunca entrou no mercado.</em>  <em>Mais tarde, Gates chamou sua maior decep√ß√£o na Microsoft.</em> <br><br>  Outra √°rea principal de pesquisa nessa √°rea foi a inclus√£o de um reposit√≥rio terci√°rio na pilha de bancos de dados relacionais mais t√≠picos, que foi objeto de uma tese de doutorado de Sunita Sarawagi.  O t√≥pico principal foi alterar a escala na qual voc√™ pensa em gerenciar o espa√ßo (isto √©, dados no armazenamento e a hierarquia de mem√≥ria) e o tempo (coordenar o planejamento e o cache de consultas para minimizar a E / S indesejada).  Um dos principais problemas deste trabalho foi armazenar grandes matrizes multidimensionais em um armazenamento terci√°rio e recuper√°-las, o que reflete o trabalho no campo da indexa√ß√£o multidimensional.  As ideias principais inclu√≠ram dividir a matriz em partes e armazenar juntas as partes selecionadas juntas, al√©m de replicar as partes para que a parte de dados possa ter v√°rios "vizinhos" f√≠sicos.  O segundo problema √© pensar em como o disco se torna um cache para armazenamento terci√°rio.  Por fim, a otimiza√ß√£o e o agendamento de consultas devem levar em considera√ß√£o o tempo necess√°rio para carregar dados do armazenamento terci√°rio e a import√¢ncia dos acertos no cache do disco.  Isso afeta o plano escolhido pelo otimizador de consulta e o tempo necess√°rio para concluir o plano. <br><br>  Atualmente, os rob√¥s em fitas e discos √≥pticos n√£o s√£o amplamente utilizados.  Mas os problemas de armazenamento terci√°rio s√£o muito comuns na nuvem, que em 2018 possui uma hierarquia profunda de armazenamento: de SSDs conectados a servi√ßos confi√°veis ‚Äã‚Äãde armazenamento semelhante a disco (por exemplo, AWS EBS), armazenamento de arquivamento (por exemplo, no AWS S3) e armazenamento profundo (por exemplo , Geleira da AWS).  Hoje, essas camadas de armazenamento ainda s√£o relativamente separadas e o racioc√≠nio sobre o armazenamento de ponta a ponta que abrange essas camadas praticamente n√£o √© suportado pelo banco de dados.  N√£o ficaria surpreso se as perguntas investigadas nessa frente no Postgres forem analisadas em breve. <br><br><h2>  2.5  Suporte para multiprocessador: XPRS </h2><br>  O Stonebreaker nunca criou um grande sistema de banco de dados paralelo, mas liderou muitas discuss√µes desafiadoras nessa √°rea.  Seu artigo ‚ÄúCase for Shared Nothing‚Äù [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sto86</a> ] documentou grandes solu√ß√µes arquitet√¥nicas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modulares</a> nessa √°rea.  Ele popularizou a terminologia usada na ind√∫stria e intrigou o suporte de arquiteturas sem recursos compartilhados, como Gamma e Teradata, que foram redescobertos nos anos 2000 pela comunidade de big data. <br><br>  Ironicamente, a contribui√ß√£o mais significativa do Stonebreaker para o campo de bancos de dados paralelos foi a arquitetura de "mem√≥ria compartilhada" chamada XPRS, que significava "eXtended Postgres on RAID and Sprite".  No in√≠cio dos anos 90, o XPRS era a ‚Äúliga da justi√ßa‚Äù para os sistemas de Berkeley: combina o sistema abreviado do Postgres Stonebreaker, John Ousterhout, o distribu√≠do OS Sprite e a arquitetura RAID de Dave Patterson e Randy Katz )  Como em muitos trabalhos interdisciplinares, a implementa√ß√£o do projeto XPRS foi realmente determinada pelos alunos de p√≥s-gradua√ß√£o que trabalharam nele.  Verificou-se que a principal contribui√ß√£o foi feita por Wei Hong, que escreveu sua tese de doutorado sobre otimiza√ß√£o de consultas paralelas em XPRS.  Assim, a principal contribui√ß√£o do XPRS para a literatura e a ind√∫stria foi otimizar solicita√ß√µes simult√¢neas sem abordar significativamente os problemas associados ao RAID ou Sprite. <br><br>  <em>Desses tr√™s projetos, o Postgres e o RAID tiveram um enorme impacto no futuro.</em>  <em>A Sprite √© mais lembrada pela disserta√ß√£o de doutorado de Mendel Rosenblum sobre Log Structured File Systems (LFS), que n√£o tinha nada de not√°vel a ver com sistemas operacionais distribu√≠dos.</em>  <em>Todos os tr√™s projetos continham novas id√©ias para armazenamento em disco, al√©m de modificar c√≥pias individuais em vigor.</em>  <em>O LFS e o gerenciador de reposit√≥rio do Postgres s√£o bastante semelhantes em seu novo tratamento do di√°rio como o reposit√≥rio principal e a necessidade de reorganiza√ß√£o de segundo plano dispendiosa.</em>  <em>Certa vez, examinei cuidadosamente o Stonebreaker sobre a rivalidade entre LFS e Postgres ou os "fatos fritos" acad√™micos sobre o relacionamento deles, mas nunca aprendi nada interessante com ele.</em>  <em>Talvez naquela √©poca em Berkeley algu√©m estivesse "mexendo na √°gua".</em> <br><br>  Em princ√≠pio, a simultaneidade ‚Äúexplode‚Äù o espa√ßo dos planos do otimizador de consultas, multiplicando as op√ß√µes tradicionais feitas durante a otimiza√ß√£o de consultas (acesso a dados, algoritmos de conex√£o, ordem de conex√£o) por todas as formas poss√≠veis de paralelizar cada op√ß√£o.  A principal id√©ia do ‚Äúotimizador Wei Hong‚Äù chamado por Stonebreaker era dividir o problema em dois: iniciar o otimizador de consulta tradicional no esp√≠rito do Sistema R para um n√≥ e depois ‚Äúparalelizar‚Äù o plano resultante, planejar o grau de paralelismo e posicionamento de cada operador com base na representa√ß√£o configura√ß√£o de dados e sistema.  Essa abordagem √© heur√≠stica, mas a simultaneidade aumenta o custo da otimiza√ß√£o de consulta tradicional de maneira aditiva, e n√£o multiplicativa. <br><br>  Embora o otimizador do Wei Hong tenha sido desenvolvido no contexto do Postgres, ele se tornou a abordagem padr√£o para muitos otimizadores de consulta simult√¢neos do setor. <br><br><h2>  2.6  Suporte para v√°rios modelos de idiomas </h2><br>  Entre os interesses do Stonebreaker, renovado v√°rias vezes desde a √©poca de Ingres, estava a interface de programa√ß√£o de aplicativos do sistema de banco de dados (API).  Em suas palestras na s√©rie Database Systems, ele frequentemente inclu√≠a a linguagem GEM Carlo Zaniolo como um t√≥pico que √© importante entender para os defensores do sistema de banco de dados.  Esse interesse na linguagem indubitavelmente o levou a fazer parceria com Larry Rowe no Postgres, o que por sua vez influenciou profundamente o design do modelo de dados do Postgres e sua abordagem objeto-relacional.  Seu trabalho foi focado principalmente em aplicativos para trabalhar com um grande volume de dados da esfera comercial, incluindo o processamento de informa√ß√µes de neg√≥cios e novos aplicativos, como CAD / CAM e GIS. <br><br>  Um dos problemas impostos ao Stonebreaker na √©poca era a id√©ia de "ocultar" os limites entre as constru√ß√µes da linguagem de programa√ß√£o e o reposit√≥rio de banco de dados.  V√°rios projetos de pesquisa concorrentes e empresas que pesquisam bancos de dados orientados a objetos (OODBs) t√™m como alvo a chamada "perda de conformidade" entre linguagens de programa√ß√£o imperativas orientadas a objetos como Smalltalk, C ++ e Java e relacional declarativa modelo.  A id√©ia do OODB era tornar os objetos da linguagem de programa√ß√£o, se desejado, marcados como "permanentes" e processados ‚Äã‚Äãautomaticamente pelo DBMS interno.  O Postgres suportava o armazenamento de objetos aninhados e tipos abstratos de dados, mas sua interface, baseada em consultas declarativas em um estilo relacional, assumia acesso n√£o natural ao banco de dados para o programador (exigia o uso de consultas declarativas), que tamb√©m eram caras (exigiam an√°lise e otimiza√ß√£o).  Para competir com os provedores de OODB, o Postgres forneceu a chamada interface Fast Path: essencialmente a API C / C ++ para armazenamento interno do banco de dados.  Isso permitiu ao Postgres ter desempenho m√©dio de refer√™ncia acad√™mica do OODB, mas nunca resolveu o problema de permitir que programadores em diferentes idiomas evitassem o problema de perder a conformidade.  Em vez disso, o Stonebreaker rotulou o Postgres como um r√≥tulo "objeto-relacional" e simplesmente ignorou o uso de bancos de dados orientados a objetos como um mercado de bilh√µes de d√≥lares.  Hoje, quase todos os sistemas comerciais de banco de dados relacional s√£o sistemas de banco de dados "objeto-relacional". <br><br>  Isso acabou por ser uma solu√ß√£o razo√°vel.  Hoje, nenhum dos produtos OODB existe na forma pretendida, e a id√©ia de "objetos persistentes" nas linguagens de programa√ß√£o foi amplamente descartada.  Por outro lado, o uso de camadas ORM (Object-Relational Mapping) √© generalizado, alimentado por trabalhos iniciais como Java Hibernate e Ruby on Rails, o que torna poss√≠vel ‚Äúcustomizar‚Äù bancos de dados declarativos com praticamente qualquer objeto imperativo. linguagem de programa√ß√£o orientada como bibliotecas.  Essa abordagem no n√≠vel do aplicativo difere dos bancos de dados relacionais de objetos OODB e Stonebreaker.  Al√©m disso, os armazenamentos leves de valores-chave tamb√©m s√£o usados ‚Äã‚Äãcom sucesso em formas n√£o transacionais e transacionais.  O descobridor foi a estudante de gradua√ß√£o Stonebreaker Margo Seltzer, que trabalhou no banco de dados Berkeley DB como parte de sua disserta√ß√£o de doutorado ao mesmo tempo que o grupo Postgres, que antecipou o crescimento de reposit√≥rios de valores-chave NoSQL distribu√≠dos, como o Dynamo , MongoDB e Cassandra. <br><br><h1>  3. Impacto no software </h1><br><h2>  3.1  C√≥digo aberto </h2><br>  O Postgres sempre foi um projeto de c√≥digo aberto com lan√ßamentos consistentes, mas no come√ßo era destinado a ser usado para pesquisa e n√£o para produ√ß√£o. <br><br>  Quando o projeto de pesquisa do Postgres foi encerrado, dois estudantes de Stonebreaker, Andrew Yu e Jolly Chen, modificaram o analisador de sistema para substituir a linguagem original do Postquel por uma variante extens√≠vel do SQL.  O primeiro lan√ßamento do Postgres suportando SQL foi o Postgres95, e o pr√≥ximo foi chamado PostgreSQL. <br><br>  Uma equipe de desenvolvimento de c√≥digo aberto ficou interessada no PostgreSQL e a ‚Äúaceitou‚Äù mesmo quando os interesses do restante da equipe de Berkeley mudaram.  A equipe principal do PostgreSQL permaneceu relativamente est√°vel ao longo do tempo, e o projeto de c√≥digo aberto tornou-se altamente desenvolvido.  Inicialmente, os esfor√ßos foram focados na estabilidade do c√≥digo e na funcionalidade vis√≠vel ao usu√°rio, mas, com o tempo, a comunidade de software de c√≥digo aberto mudou e melhorou significativamente o n√∫cleo do sistema, do otimizador ao acesso aos m√©todos e ao principal sistema de transa√ß√µes e armazenamento.  Desde meados dos anos 90, uma fra√ß√£o muito pequena dos componentes internos do PostgreSQL veio da equipe acad√™mica de Berkeley.  Sua √∫ltima contribui√ß√£o pode ter sido minha implementa√ß√£o do GiST na segunda metade dos anos 90, mas mesmo foi substancialmente reescrita e liberada por volunt√°rios da comunidade de c√≥digo aberto (neste caso, a R√∫ssia).  A parte da comunidade de c√≥digo aberto que trabalha no PostgreSQL merece os maiores elogios por seu processo simplificado, que por d√©cadas serviu para criar um projeto altamente eficiente e de longo prazo. <br><br>  Embora muita coisa tenha mudado nos √∫ltimos 25 anos, a arquitetura subjacente do PostgreSQL permanece muito semelhante √†s vers√µes da universidade do Postgres no in√≠cio dos anos 90, e os desenvolvedores familiarizados com o c√≥digo fonte atual do PostgreSQL achar√£o f√°cil ler o c√≥digo fonte do Postgres 3.1 (1991).  Tudo, desde a estrutura de diret√≥rio do c√≥digo-fonte √†s estruturas de processo e estruturas de dados, permanece surpreendentemente semelhante.  O c√≥digo da equipe do Postgres em Berkeley tinha uma grande espinha dorsal. <br><br>  Hoje, o PostgreSQL √© sem d√∫vida o sistema de gerenciamento de banco de dados de c√≥digo aberto com melhor desempenho e suporta funcionalidades que geralmente n√£o s√£o encontradas em produtos comerciais.  √â tamb√©m (de acordo com um influente site de classifica√ß√£o) o DBMS de c√≥digo aberto independente mais popular do mundo, e sua influ√™ncia continua a crescer: em 2017 e 2018, foi o banco de dados com a popularidade que mais cresce no mundo [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DE19c</a> ].  O PostgreSQL √© usado em uma ampla variedade de setores e tarefas, o que n√£o √© surpreendente, dado seu foco em amplas oportunidades. <br><br>  <em>Segundo a DB-Engines, o PostgreSQL hoje √© o quarto DBMS mais popular do mundo, depois do Oracle, MySQL e MS SQL Server, todos os tr√™s oferecidos por empresas espec√≠ficas (o MySQL foi adquirido pela Oracle h√° muitos anos) [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DE19a</a> ].</em>  <em>As regras de classifica√ß√£o s√£o discutidas na descri√ß√£o da metodologia de classifica√ß√£o DB-Engines [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DE19b</a> ].</em> <br><br>  Heroku √© o provedor de nuvem SaaS que agora faz parte do Salesforce.  O Postgres foi introduzido no Heroku em 2010 como o banco de dados padr√£o para sua plataforma.  Heroku escolheu o Postgres por confiabilidade.  Com o suporte do Heroku, plataformas de desenvolvimento de aplicativos maiores, como Ruby on Rails e Python para Django, come√ßaram a recomendar o Postgres como o banco de dados padr√£o. <br><br>  Hoje, o PostgreSQL suporta uma infraestrutura de extens√£o que facilita a adi√ß√£o de recursos adicionais ao sistema atrav√©s de fun√ß√µes definidas pelo usu√°rio e modifica√ß√µes relacionadas.  Agora existe um ecossistema de extens√µes do PostgreSQL, semelhante ao conceito llustra de pacotes de extens√£o do DataBlade, mas com c√≥digo-fonte aberto.  As extens√µes mais interessantes incluem, por exemplo, a biblioteca Apache MADlib para aprendizado de m√°quina na interface SQL e a biblioteca Citus para execu√ß√£o de consultas paralelas. <br><br>  Um dos aplicativos de c√≥digo aberto mais interessantes criados no Postgres √© o sistema de informa√ß√µes geogr√°ficas do PostGIS, usando muitos dos recursos do Postgres que originalmente inspiraram o Stonebreaker a iniciar o projeto. <br><br><h2>  3.2  Implementa√ß√£o comercial </h2><br>  O PostgreSQL tem sido um ponto de partida atraente para a cria√ß√£o de sistemas de banco de dados comerciais, devido ao seu uso sob a licen√ßa de software de c√≥digo aberto "totalmente admiss√≠vel", c√≥digo confi√°vel, flexibilidade e ampla funcionalidade.  Resumindo os custos de aquisi√ß√£o listados abaixo, vemos que o Postgres recebeu mais de US $ 2,6 bilh√µes em custos de aquisi√ß√£o. <br><br>  <em>Observe que essa √© uma medida em d√≥lares das transa√ß√µes financeiras reais e √© muito mais significativa do que os valores que s√£o frequentemente usados ‚Äã‚Äãem alta tecnologia.</em>  <em>N√∫meros em bilh√µes s√£o frequentemente usados ‚Äã‚Äãpara descrever o valor estimado de blocos de a√ß√µes, mas geralmente s√£o exagerados em 10 vezes ou mais em compara√ß√£o com o valor presente, na esperan√ßa de seu significado futuro.</em>  <em>Os d√≥lares das transa√ß√µes de aquisi√ß√£o da empresa medem seu valor real de mercado no momento da aquisi√ß√£o.</em>  <em>√â justo dizer que o Postgres criou mais de US $ 2,6 bilh√µes em valor comercial real.</em> <br><br>  Muitos dos esfor√ßos comerciais associados ao PostgreSQL se concentraram no que provavelmente √© sua principal limita√ß√£o: a capacidade de escalar para uma arquitetura paralela sem compartilhar recursos. <br><br>  <em>A paraleliza√ß√£o do PostgreSQL requer uma quantidade razo√°vel de trabalho, mas √© altamente vi√°vel por uma equipe pequena e experiente.</em>  <em>Hoje, os ramos da ind√∫stria de c√≥digo aberto do PostgreSQL, como Greenplum e CitusDB, oferecem essa oportunidade.</em>  <em>√â lament√°vel que o PostgreSQL n√£o tenha sido adequadamente paralelizado em c√≥digo aberto muito antes.</em>  <em>Se o PostgreSQL tivesse sido expandido no c√≥digo aberto com suporte para uma arquitetura sem compartilhamento de recursos no in√≠cio dos anos 2000, √© poss√≠vel que a dire√ß√£o do big data de c√≥digo aberto tivesse se desenvolvido de uma maneira completamente diferente e mais eficiente.</em> <br><br><ol><li>  A Illustra foi a segunda maior startup do Stonebreaker, fundada em 1992 para comercializar o Postgres, quando a RTI lan√ßou o Ingres no mercado. <br><br>  <em>Illustra era realmente o terceiro nome proposto para a empresa.</em>  <em>Continuando o tema da pintura, chamado Ingres, Illustra foi originalmente chamado de Miro.</em>  <em>Devido a problemas de marca comercial, o nome foi alterado para Montagem, mas tamb√©m encontrou problemas de marca comercial.</em> <br><br>  A equipe fundadora incluiu parte do n√∫cleo da equipe do Postgres, incluindo o rec√©m-formado Wei Hong e o ent√£o programador-chefe Jeff Meredith, al√©m de graduados de Ingres Paula Hawthorn e Michael Ubell.  O aluno de p√≥s-gradua√ß√£o Mike Olson ingressou logo ap√≥s a funda√ß√£o, e eu trabalhei na Illustra para otimizar recursos caros como parte do meu doutorado.  Illustra    :  SQL92      ,    Postquel,    Postgres               DataBlade ‚Äî       . Illustra   Informix  1997     400 . .  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mon96</a> ],    DataBlade         Informix  Informix Universal Server. <br></li><li> Netezza  ,   1999 ,    PostgreSQL             FPGA. Netezza     ,        2007 .       IBM  1,7 . .  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IBM10</a> ]. <br></li><li> Greenplum         PostgreSQL   .   2003 , Greenplum     PostgreSQL,      API PostgreSQL,  API   .    , Greenplum  PostgreSQL         ,   ,   Orca. Greenplum   EMC  2010   300 . . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mal10</a> ],   2012  EMC  Greenplum     Pivotal.  2015  Pivotal    Greenplum  Orca    .    Greenplum   Postgres API   MADlib     SQL [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HRS+12</a> ]. MADlib     Apache.        ,   Greenplum,  Apache HAWQ,   Pivotal,   ¬´ ¬ª Greenplum (. .         PostgreSQL)    ,     Hadoop. <br></li><li> EnterpriseDB    2004   ,          PostgreSQL   ,             .    EnterpriseDB Advanced Server      Oracle,     Oracle. <br></li><li>  Aster Data    2005    ,      .        PostgreSQL. Aster             ,        SQL  MapReduce. Aster Data    Teradata  2011   263 . . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sho11</a> ].  Teradata    Aster       ,  -  Aster             Teradata. <br></li><li>  ParAccel    2006 ,    PostgreSQL      . ParAccel   Postgres        .  2011  Amazon   ParAccel,   2012   AWS Redshift ‚Äî             ParAccel.  2013  ParAccel    Actian (   Ingres)    ,  ,        Actian.    AWS Redshift     Amazon ‚Äî            Amazon,   ,            ,   Teradata  Oracle Exadata.    Postgres       . <br></li><li>  CitusDB <em>(CitusDB ‚Äî  ;   Citus Data. ‚Äî . .)</em>    2010 ,     PostgreSQL   .      PostgreSQL,  2016  CitusDB    API  PostgreSQL        PostgreSQL.  2016   CitusDB     . <br></li></ol><br><h1> 4.  </h1><br>        Postgres,       . <br><br>   ,   ,   ,  Postgres   ¬´  ¬ª (Second System Effect)    (Fred Brooks) [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bro75</a> ].  ,          ,    -    . Postgres    ,  , ,     .      ,     ,       .     ‚Äî    Postgres     ,      .               :     ,    .  , ¬´ ¬ª  .    ,    ,      .       ¬´-¬ª    ,      ¬´-¬ª    . <br><br>     ,    , ¬´   ¬ª,       ,    .     <em>( 2001           (). ‚Äî . .)</em>          2000-   ¬´    ¬ª.          ,         Postgres. ,            ,       . <br><br> <em>   (Ralph Waldo Emerson), ¬´  ‚Äî   ¬ª.</em> <br><br> ,     ¬´    ¬ª (       ),   ,      ,      , ,               .  ,           .   ,        ,       - .    ,   .          ,     . <br><br>  ,     Postgres, ‚Äî   ,          .        ¬´ ¬ª  PostgreSQL,       ,        .  ,    : <br><blockquote>  ,  ,            ,          1995 .  Postgres,     ,     .       ,     ,            ,       . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sto14</a> ] <br></blockquote>  ,   ,     ,  ,   ¬´ ¬ª   .      ¬´ ¬ª.   , ,  ,         ,       Postgres.     - ,    : ¬´ -      ¬ª.   (  ),         . <br><br><h1> 5.  </h1><br>       Postgres  ,          ,     (Craig Kerstiens)      PostgreSQL. <br><br><h1>  Literatura </h1><br><ul><li><a name="Bro75"></a> [Bro75] Frederick P Brooks. The mythical man-month, 1975. </li><li><a name="Bro19"></a> [Bro19] Michael L. Brodie, editor. Making Databases Work. Morgan &amp; Claypool, 2019. </li><li><a name="DE19a"></a> [DE19a] DB-Engines. DB-Engines ranking, 2019. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">db-engines.com/en/ranking</a> . (Last accessed January 4, 2019). </li><li><a name="DE19b"></a> [DE19b] DB-Engines. Method of calculating the scores of the DB-Engines ranking, 2019. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">db-engines.com/en/ranking_definition</a> (Last accessed January 4, 2019). </li><li><a name="DE19c"></a> [DE19c] DB-Engines. PostgreSQL is the DBMS of the year 2018, January 2019. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">db-engines.com/en/blog_post/79</a> (Last accessed January 4, 2019). </li><li><a name="DS08"></a> [DS08] David DeWitt and Michael Stonebraker. Mapreduce: A major step backwards. The Database Column, 1:23, 2008. </li><li><a name="Gut84"></a> [Gut84] Antonin Guttman. R-trees: A dynamic index structure for spatial searching. In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, SIGMOD '84, pages 47‚Äì57, New York, NY, USA, 1984. ACM. </li><li><a name="HKM02"></a> [HKM <sup>+</sup> 02] Joseph M. Hellerstein, Elias Koutsoupias, Daniel P. Miranker, Christos H. Papadimitriou, and Vasilis Samoladas. On a model of indexability and its bounds for range queries. J. ACM, 49(1):35‚Äì55, January 2002. </li><li><a name="HNP95"></a> [HNP95] Joseph M. Hellerstein, Jeffrey F. Naughton, and Avi Pfeffer. Generalized search trees for database systems. In Proceedings of the 21th International Conference on Very Large Data Bases, VLDB '95, pages 562‚Äì573, San Francisco, CA, USA, 1995. Morgan Kaufmann Publishers Inc. </li><li><a name="HRS12"></a> [HRS <sup>+</sup> 12] Joseph M Hellerstein, Christoper Re, Florian Schoppmann, Daisy Zhe Wang, Eugene Fratkin, Aleksander Gorajek, Kee Siong Ng, Caleb Welton, Xixuan Feng, Kun Li, et al. The MADlib analytics library: or MAD skills, the SQL. Proceedings of the VLDB Endowment, 5(12):1700‚Äì1711, 2012. </li><li><a name="IBM10"></a> [IBM10] IBM to acquire Netezza, September 2010. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www-03.ibm.com/press/us/en/pressrelease/32514.wss#release</a> (Last accessed January 22, 2018). </li><li><a name="KMH97"></a> [KMH97] Marcel Kornacker, C. Mohan, and Joseph M. Hellerstein. Concurrency and recovery in generalized search trees. In Proceedings of the 1997 ACM SIGMOD International Conference on Management of Data, SIGMOD '97, pages 62‚Äì72, New York, NY, USA, 1997. ACM. </li><li><a name="Mal10"></a> [Mal10] Om Malik. Big Data = Big Money: EMC Buys Greenplum. In GigaOm, July 2010. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gigaom.com/2010/07/06/emc-buys-greenplum</a> . </li><li><a name="Mon96"></a> [Mon96] John Monroe. Informix acquires illustra for complex data management. In Federal Computer Week, January 1996. </li><li><a name="OFS83"></a> [OFS83] James Ong, Dennis Fogg, and Michael Stonebraker. Implementation of data abstraction in the relational database system ingres. ACM Sigmod Record, 14(1):1‚Äì14, 1983. </li><li><a name="Ols93"></a> [Ols93] Michael A. Olson. The design and implementation of the inversion file system. 1993. </li><li><a name="SAHR84"></a> [SAHR84] Michael Stonebraker, Erika Anderson, Eric Hanson, and Brad Rubenstein. Quel as a data type. In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, SIGMOD '84, pages 208‚Äì214, New York, NY, USA, 1984. ACM. </li><li><a name="Sho11"></a> [Sho11] Erick Shonfeld. Big pay day for big data. teradata buys aster data for $263 million. In TechCrunch, May 2011. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">techcrunch.com/2011/03/03/teradata-buys-aster-data-263-million</a> (Last accessed January 22, 2018). </li><li><a name="SHWK76"></a> [SHWK76] Michael Stonebraker, Gerald Held, Eugene Wong, and Peter Kreps. The design and implementation of ingres. ACM Transactions on Database Systems (TODS), 1(3):189‚Äì222, 1976. </li><li><a name="SK91"></a> [SK91] Michael Stonebraker and Greg Kemnitz. The postgres next generation database management system. Commun. ACM, 34(10):78‚Äì92, October 1991. </li><li><a name="SR86"></a> [SR86] Michael Stonebraker and Lawrence A. Rowe. The design of postgres. In Proceedings of the 1986 ACM SIGMOD International Conference on Management of Data, SIGMOD '86, pages 340‚Äì355, New York, NY, USA, 1986. ACM. </li><li><a name="SRG83"></a> [SRG83] M Stonebraker, B Rubenstein, and A Guttman. Application of abstract data types and abstract indices to cad bases. IEEE Trans, on Software Engineering, 1983. </li><li><a name="Sto86"></a> [Sto86] Michael Stonebraker. The case for shared nothing. IEEE Database Eng. Bull., 9(1):4‚Äì9, 1986. </li><li><a name="Sto87"></a> [Sto87] Michael Stonebraker. The design of the postgres storage system. In Proceedings of the 13th International Conference on Very Large Data Bases, VLDB '87, pages 289‚Äì300, San Francisco, CA, USA, 1987. Morgan Kaufmann Publishers Inc. </li><li><a name="Sto95"></a> [Sto95] Michael Stonebraker. An overview of the sequoia 2000 project. Digital Technical Journal, 7(3):39‚Äì49, 1995. </li><li><a name="Sto14"></a> [Sto14] Michael Stonebraker. The land sharks are on the squawk box, 2014. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.acm.org/turing-lecture-stonebraker</a> (Last accessed January 4, 2019). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438890/">https://habr.com/ru/post/pt438890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438878/index.html">A apari√ß√£o do filme em torrents ap√≥s a estr√©ia aumenta as bilheterias em 3%</a></li>
<li><a href="../pt438880/index.html">Quando usar var, let e const em Javascript [artigo de Tyler McGinnis]</a></li>
<li><a href="../pt438882/index.html">A probabilidade de ganhar uma partida com uma probabilidade conhecida de ganhar um ponto</a></li>
<li><a href="../pt438884/index.html">Hist√≥ria verdadeira de uma ag√™ncia de publicidade do interior: altos, baixos e implementa√ß√£o de CRM</a></li>
<li><a href="../pt438886/index.html">Morty, estamos no UltraHD! Como assistir a qualquer filme em 4K, completando-o atrav√©s de uma rede neural pouco conhecida</a></li>
<li><a href="../pt438892/index.html">O que √© uma blockchain corporativa?</a></li>
<li><a href="../pt438894/index.html">Por que o desenvolvimento web no Go √© melhor do que no PHP</a></li>
<li><a href="../pt438896/index.html">N√£o chore neg√≥cios</a></li>
<li><a href="../pt438898/index.html">Instala√ß√£o reversa e extens√£o do Chrome</a></li>
<li><a href="../pt438900/index.html">No caminho para os princ√≠pios f√≠sicos da evolu√ß√£o biol√≥gica. Fim + texto completo da tradu√ß√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>