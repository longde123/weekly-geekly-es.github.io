<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🎤 🥓 👩🏿‍🤝‍👨🏻 Programmation Java fonctionnelle avec Vavr 🚵🏽 👩🏾 🤶🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beaucoup ont entendu parler de langages fonctionnels tels que Haskell et Clojure. Mais il y a des langues comme Scala, par exemple. Il combine à la fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programmation Java fonctionnelle avec Vavr</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421839/">  Beaucoup ont entendu parler de langages fonctionnels tels que Haskell et Clojure.  Mais il y a des langues comme Scala, par exemple.  Il combine à la fois la POO et une approche fonctionnelle.  Et le bon vieux Java?  Est-il possible d'écrire des programmes dans un style fonctionnel et à quel point cela peut faire mal?  Oui, il y a Java 8 et lambdas avec des flux.  C'est un grand pas pour la langue, mais ce n'est toujours pas suffisant.  Est-il possible de trouver quelque chose dans cette situation?  Il s'avère que oui. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u2/tp/cr/u2tpcrdrjmcmw9yvj9ptnbsuiwo.jpeg"></div><br><a name="habracut"></a><br>  Pour commencer, essayons de déterminer ce que signifie l'écriture de code dans un style fonctionnel.  Premièrement, nous devons opérer non pas avec des variables et des manipulations avec elles, mais avec des chaînes de calculs.  Essentiellement, une séquence de fonctions.  De plus, nous devons avoir des structures de données spéciales.  Par exemple, les collections Java standard ne conviennent pas.  Il sera bientôt clair pourquoi. <br><br>  Examinons plus en détail les structures fonctionnelles.  Une telle structure doit satisfaire au moins deux conditions: <br><br><ul><li>  <b><i>immuable</i></b> - la structure doit être immuable.  Cela signifie que nous fixons l'état de l'objet au stade de la création et le laissons tel quel jusqu'à la fin de son existence.  Un exemple clair d'une violation de condition: ArrayList standard. </li><li>  <b>persistante</b> - la structure doit être stockée en mémoire aussi longtemps que possible.  Si nous avons créé un objet, au lieu d'en créer un nouveau avec le même état, nous devrions utiliser celui qui est prêt.  Plus formellement, ces structures conservent tous leurs états précédents lors de la modification.  Les références à ces conditions doivent rester pleinement opérationnelles. </li></ul><br>  De toute évidence, nous avons besoin d'une sorte de solution tierce.  Et il existe une telle solution: la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vavr</a> .  Aujourd'hui, c'est la bibliothèque <i>Java</i> la plus populaire pour travailler dans un style fonctionnel.  Ensuite, je décrirai les principales fonctionnalités de la bibliothèque.  De nombreux, mais en aucun cas tous, exemples et descriptions ont été tirés de la documentation officielle. <br><br><h2>  Les principales structures de données de la bibliothèque <b>vavr</b> </h2><br><h3>  Tuple </h3><br>  Les tuples sont l'une des structures de données fonctionnelles les plus simples et les plus simples.  Un tuple est un ensemble ordonné de longueur fixe.  Contrairement aux listes, un tuple peut contenir des données de tout type. <br><br><pre><code class="java hljs">Tuple tuple = Tuple.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"blablabla"</span></span>, .<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">42L</span></span>); <span class="hljs-comment"><span class="hljs-comment">// (1, blablabla, 0.0, 42)</span></span></code> </pre> <br>  Obtenir l'élément souhaité provient de l'appel du champ avec le numéro d'article dans le tuple. <br><br><pre> <code class="java hljs">((Tuple4) tuple)._1 <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br>  Remarque: l'indexation de tuple commence à 1!  De plus, pour obtenir l'élément souhaité, nous devons convertir notre objet en le type souhaité avec l'ensemble de méthodes approprié.  Dans l'exemple ci-dessus, nous avons utilisé un tuple de 4 éléments, ce qui signifie que la conversion doit être de type <i>Tuple4</i> .  En fait, personne ne nous empêche de faire initialement le bon type. <br><br><pre> <code class="java hljs">Tuple4 tuple = Tuple.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"blablabla"</span></span>, .<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">42L</span></span>); <span class="hljs-comment"><span class="hljs-comment">// (1, blablabla, 0.0, 42) System.out.println(tuple._1); // 1</span></span></code> </pre> <br><h3>  Top 3 des collections Vavr </h3><br><h4>  Liste </h4><br>  Créer une liste avec vavr est très simple.  Encore plus facile que sans <i>vavr</i> . <br><br><pre> <code class="java hljs">List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br>  Que pouvons-nous faire avec une telle liste?  Eh bien, tout d'abord, nous pouvons le transformer en une liste <i>java</i> standard. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> containThree = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .asJava() .stream() .anyMatch(x -&gt; x == <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  Mais en fait, ce n'est pas très nécessaire, car  nous pouvons faire, par exemple, comme ceci: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> containThree = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .find(x -&gt; x == <span class="hljs-number"><span class="hljs-number">1</span></span>) .isDefined();</code> </pre> <br>  En général, la <i>liste de</i> bibliothèques <i>vavr</i> standard <i>contient de</i> nombreuses méthodes utiles.  Par exemple, il existe une fonction de convolution assez puissante qui vous permet de combiner une liste de valeurs par une règle et un élément neutre. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   final int zero = 0; //   final BiFunction&lt;Integer, Integer, Integer&gt; combine = (x, y) -&gt; x + y; //   final int sum = List.of(1, 2, 3) .fold(zero, combine); //  </span></span></code> </pre> <br>  Il convient de noter ici un point important.  Nous avons des structures de données fonctionnelles, ce qui signifie que nous ne pouvons pas changer leur état.  Comment notre liste est-elle mise en œuvre?  Les tableaux ne nous conviennent tout simplement pas. <br><br>  <b>Liste liée comme liste par défaut</b> <br><br>  Faisons une liste simplement liée avec des objets immuables.  Cela ressemblera à ceci: <br><br><img src="https://habrastorage.org/webt/lr/4p/xn/lr4pxnezcvipnsgaownffgw6ewq.png" alt="image"><br><br><div class="spoiler">  <b class="spoiler_title">Exemple de code</b> <div class="spoiler_text"><pre> <code class="java hljs">List list = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br></div></div><br>  Chaque élément de la liste a deux méthodes principales: obtenir l'élément head (head) et tous les autres (tail). <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de code</b> <div class="spoiler_text"><pre> <code class="java hljs">list.head(); <span class="hljs-comment"><span class="hljs-comment">// 1 list.tail(); // List(2, 3)</span></span></code> </pre> <br></div></div><br>  Maintenant, si nous voulons changer le premier élément de la liste (de 1 à 0), alors nous devons créer une nouvelle liste avec la réutilisation des pièces finies. <br><br><img src="https://habrastorage.org/webt/hu/xc/lp/huxclpxqlaunelfqyqu259ayj9o.png" alt="image"><br><div class="spoiler">  <b class="spoiler_title">Exemple de code</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List tailList = list.tail(); <span class="hljs-comment"><span class="hljs-comment">//    tailList.prepend(0); //     </span></span></code> </pre> <br></div></div><br>  Et c'est tout!  Étant donné que nos objets dans la feuille de calcul sont immuables, nous obtenons une collection thread-safe et réutilisable.  Les éléments de notre liste peuvent être appliqués n'importe où dans l'application et c'est complètement sûr! <br><br><h4>  File d'attente </h4><br>  Une autre structure de données extrêmement utile est la file d'attente.  Comment faire une file d'attente pour construire des programmes efficaces et fiables dans un style fonctionnel?  Par exemple, nous pouvons prendre des structures de données que nous connaissons déjà: deux listes et un tuple. <br><br><img src="https://habrastorage.org/webt/bi/bp/sb/bibpsbx_odpxx2kdupxg0l4ufku.png" alt="image"><br><br><div class="spoiler">  <b class="spoiler_title">Exemple de code</b> <div class="spoiler_text"><pre> <code class="java hljs">Queue&lt;Integer&gt; queue = Queue.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .enqueue(<span class="hljs-number"><span class="hljs-number">4</span></span>) .enqueue(<span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br></div></div><br>  Lorsque le premier se termine, nous développons le second et l'utilisons pour la lecture. <br><br><img src="https://habrastorage.org/webt/b5/ho/zz/b5hozzqnmnm8fyhoebj3g3d7c_0.png" alt="image"><br><br><img src="https://habrastorage.org/webt/ld/_e/ly/ld_ely_1i5buzwbadpirjf0f1gc.png" alt="image"><br><br>  Il est important de se rappeler que la file d'attente doit être inchangée, comme toutes les autres structures.  Mais à quoi sert une file d'attente qui ne change pas?  En fait, il y a une astuce.  En tant que valeur acceptée de la file d'attente, nous obtenons un tuple de deux éléments.  Premièrement: l'élément de file d'attente souhaité, deuxièmement: ce qui est arrivé à la file d'attente sans cet élément. <br><br><pre> <code class="java hljs">System.out.println(queue); <span class="hljs-comment"><span class="hljs-comment">// Queue(1, 2, 3, 4, 5) Tuple2&lt;Integer, Queue&lt;Integer&gt;&gt; tuple2 = queue.dequeue(); System.out.println(tuple2._1); // 1 System.out.println(tuple2._2); // Queue(2, 3, 4, 5)</span></span></code> </pre> <br><h4>  Streams </h4><br>  La prochaine structure de données importante est le flux.  Un flux est un flux d'exécution de certaines actions sur un certain ensemble de valeurs, souvent abstrait. <br><br>  Quelqu'un peut dire que <i>Java 8 a</i> déjà des flux à part entière et nous n'en avons pas besoin du tout.  En est-il ainsi? <br><br>  Pour commencer, assurons-nous que le <i>flux java</i> n'est pas une structure de données fonctionnelle.  Vérifiez la structure pour la mutabilité.  Pour ce faire, créez un si petit flux: <br><pre> <code class="java hljs">IntStream standardStream = IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br>  Nous allons trier tous les éléments du flux: <br><br><pre> <code class="java hljs">standardStream.forEach(System.out::print);</code> </pre> <br>  En réponse, nous obtenons la sortie sur la console: <i>123456789</i> .  Répétons l'opération de force brute: <br><br><pre> <code class="java hljs">standardStream.forEach(System.out::print);</code> </pre> <br>  Oups, l'erreur suivante s'est produite: <br><br><pre> <code class="java hljs">java.lang.IllegalStateException: stream has already been operated upon or closed</code> </pre><br>  Le fait est que les flux standard ne sont qu'une sorte d'abstraction sur un itérateur.  Bien que les flux extérieurs semblent extrêmement indépendants et puissants, les inconvénients des itérateurs n'ont pas disparu. <br><br>  Par exemple, la définition d'un flux ne dit rien sur la limitation du nombre d'éléments.  Malheureusement, il existe dans l'itérateur, ce qui signifie qu'il se trouve dans les flux standard. <br><br>  Heureusement, la bibliothèque vavr résout ces problèmes.  Assurez-vous de ceci: <br><br><pre> <code class="java hljs">Stream stream = Stream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); stream.forEach(System.out::print); stream.forEach(System.out::print);</code> </pre> <br>  En réponse, nous obtenons <i>123456789123456789</i> .  Ce qui signifie que la première opération n'a pas «gâché» notre flux. <br><br>  Essayons de créer un flux sans fin: <br><br>  Stream infiniteStream = Stream.from (1); <br>  System.out.println (infiniteStream);  // Stream (1,?) <br><br>  Remarque: lors de l'impression d'un objet, nous n'obtenons pas une structure infinie, mais le premier élément et un point d'interrogation.  Le fait est que chaque élément suivant du flux est généré à la volée.  Cette approche est appelée initialisation paresseuse.  C'est lui qui vous permet de travailler en toute sécurité avec de telles structures. <br><br>  Si vous n'avez jamais travaillé avec des structures de données infinies, alors vous pensez probablement: pourquoi est-ce nécessaire?  Mais ils peuvent être extrêmement pratiques.  Nous écrivons un flux qui renvoie un nombre arbitraire de nombres impairs, les convertit en chaîne et ajoute un espace: <br><br><pre> <code class="java hljs">Stream oddNumbers = Stream .from(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  1   2 .map(x -&gt; x + " "); //  //   oddNumbers.take(5) .forEach(System.out::print); // 1 3 5 7 9 oddNumbers.take(10) .forEach(System.out::print); // 1 3 5 7 9 11 13 15 17 19</span></span></code> </pre> <br>  Si simple. <br><br><h3>  Structure générale des collections </h3><br>  Après avoir discuté des structures de base, il est temps de regarder l'architecture générale des collections fonctionnelles <i>vavr</i> : <br><br><img src="https://habrastorage.org/webt/m2/ae/wl/m2aewlwyky8-r-dktx1asgvxqgy.png"><br><br>  Chaque élément de la structure peut être utilisé comme itérable: <br><br><pre> <code class="java hljs">StringBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String word : List.of(<span class="hljs-string"><span class="hljs-string">"one"</span></span>, <span class="hljs-string"><span class="hljs-string">"two"</span></span>, <span class="hljs-string"><span class="hljs-string">"tree"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (builder.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { builder.append(<span class="hljs-string"><span class="hljs-string">", "</span></span>); } builder.append(word); } System.out.println(builder.toString()); <span class="hljs-comment"><span class="hljs-comment">// one, two, tree</span></span></code> </pre> <br>  Mais vous devriez réfléchir à deux fois et voir le dock avant d'utiliser pour.  La bibliothèque vous permet de faciliter les choses familières. <br><br><pre> <code class="java hljs">System.out.println(List.of(<span class="hljs-string"><span class="hljs-string">"one"</span></span>, <span class="hljs-string"><span class="hljs-string">"two"</span></span>, <span class="hljs-string"><span class="hljs-string">"tree"</span></span>).mkString(<span class="hljs-string"><span class="hljs-string">", "</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// one, two, tree</span></span></code> </pre> <br><h2>  Travailler avec des fonctions </h2><br>  La bibliothèque a un certain nombre de fonctions (8 pièces) et des méthodes utiles pour travailler avec elles.  Ce sont des interfaces fonctionnelles ordinaires avec de nombreuses méthodes intéressantes.  Le nom des fonctions dépend du nombre d'arguments acceptés (de 0 à 8).  Par exemple, <i>Function0</i> ne prend aucun argument, <i>Function1</i> prend un argument, <i>Function2 en</i> prend deux, etc. <br><br><pre> <code class="java hljs">Function2&lt;String, String, String&gt; combineName = (lastName, firstName) -&gt; firstName + <span class="hljs-string"><span class="hljs-string">" "</span></span> + lastName; System.out.println(combineName.apply(<span class="hljs-string"><span class="hljs-string">"Griffin"</span></span>, <span class="hljs-string"><span class="hljs-string">"Peter"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// Peter Griffin</span></span></code> </pre> <br>  Dans les fonctions de la bibliothèque vavr, nous pouvons faire beaucoup de choses sympas.  En termes de fonctionnalité, ils dépassent de loin la fonction standard, la bi-fonction, etc.  Par exemple, le curry.  Le curry est la construction de fonctions en plusieurs parties.  Regardons un exemple: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    Function2&lt;String, String, String&gt; combineName = (lastName, firstName) -&gt; firstName + " " + lastName; //           Function1&lt;String, String&gt; makeGriffinName = combineName .curried() .apply("Griffin"); //      System.out.println(makeGriffinName.apply("Peter")); // Peter Griffin System.out.println(makeGriffinName.apply("Lois")); // Lois Griffin</span></span></code> </pre> <br>  Comme vous pouvez le voir, très succinctement.  La méthode au <i>curry</i> est extrêmement simple, mais peut être très utile. <br><br><div class="spoiler">  <b class="spoiler_title">Implémentation de la méthode au curry</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Function1&lt;T1, Function1&lt;T2, R&gt;&gt; curried() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1 -&gt; t2 -&gt; apply(t1, t2); }</code> </pre><br></div></div><br>  Il existe de nombreuses autres méthodes utiles dans le jeu de <i>fonctions</i> .  Par exemple, vous pouvez mettre en cache le résultat de retour d'une fonction: <br><br><pre> <code class="java hljs">Function0&lt;Double&gt; hashCache = Function0.of(Math::random).memoized(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> randomValue1 = hashCache.apply(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> randomValue2 = hashCache.apply(); System.out.println(randomValue1 == randomValue2); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br><br><h2>  Lutte contre les exceptions </h2><br>  Comme nous l'avons dit plus tôt, le processus de programmation doit être sûr.  Pour cela, il faut éviter divers effets étrangers.  Les exceptions sont leurs générateurs explicites. <br><br>  Vous pouvez utiliser la classe <i>Try</i> pour gérer en toute sécurité les exceptions dans un style fonctionnel.  En fait, c'est une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">monade</a> typique.  Il n'est pas nécessaire de se plonger dans la théorie de l'utilisation.  Regardez simplement un exemple simple: <br><br><pre> <code class="java hljs">Try.of(() -&gt; <span class="hljs-number"><span class="hljs-number">4</span></span> / <span class="hljs-number"><span class="hljs-number">0</span></span>) .onFailure(System.out::println) .onSuccess(System.out::println);</code> </pre> <br>  Comme vous pouvez le voir sur l'exemple, tout est assez simple.  Nous suspendons simplement l'événement à une erreur potentielle et ne le dépassons pas des limites du calcul. <br><br><h2>  Correspondance de motifs </h2><br>  Il arrive souvent une situation dans laquelle nous devons vérifier la valeur d'une variable et modéliser le comportement du programme en fonction du résultat.  Dans de telles situations, un merveilleux moteur de recherche de modèles vient à la rescousse.  Vous n'avez plus besoin d'écrire un tas de <i>sinon</i> , configurez simplement toute la logique en un seul endroit. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> io.vavr.API.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> io.vavr.Predicates.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PatternMatchingDemo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ String s = Match(<span class="hljs-number"><span class="hljs-number">1993</span></span>).of( Case($(<span class="hljs-number"><span class="hljs-number">42</span></span>), () -&gt; <span class="hljs-string"><span class="hljs-string">"one"</span></span>), Case($(anyOf(isIn(<span class="hljs-number"><span class="hljs-number">1990</span></span>, <span class="hljs-number"><span class="hljs-number">1991</span></span>, <span class="hljs-number"><span class="hljs-number">1992</span></span>), is(<span class="hljs-number"><span class="hljs-number">1993</span></span>))), <span class="hljs-string"><span class="hljs-string">"two"</span></span>), Case($(), <span class="hljs-string"><span class="hljs-string">"?"</span></span>) ); System.out.println(s); <span class="hljs-comment"><span class="hljs-comment">// two } }</span></span></code> </pre> <br>  Veuillez noter que le cas est en majuscule, comme  case est un mot-clé et est déjà pris. <br><br><h2>  Conclusion </h2><br>  À mon avis, la bibliothèque est très cool, mais cela vaut la peine de l'utiliser très soigneusement.  Elle peut exceller dans le développement <i>événementiel</i> .  Cependant, son utilisation excessive et irréfléchie dans la programmation impérative standard basée sur un pool de threads peut apporter beaucoup de maux de tête.  De plus, souvent dans nos projets, nous utilisons Spring et Hibernate, qui ne sont pas toujours prêts pour une telle application.  Avant d'importer une bibliothèque dans votre projet, vous devez comprendre clairement comment et pourquoi elle sera utilisée.  Ce dont je parlerai dans un de mes prochains articles. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr421839/">https://habr.com/ru/post/fr421839/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr421827/index.html">Que lire sur Java en ce moment?</a></li>
<li><a href="../fr421829/index.html">L'anomalie de Frango - une romance fantastique avec de vraies personnes de l'informatique</a></li>
<li><a href="../fr421833/index.html">Nous écrivons notre programme le plus simple pour ARM Cortex-M3</a></li>
<li><a href="../fr421835/index.html">La Commission interinstitutions développe une nouvelle technologie pour bloquer Telegram</a></li>
<li><a href="../fr421837/index.html">Créer 1k d'intro Chaos pour ZX-Spectrum</a></li>
<li><a href="../fr421841/index.html">Robotaxi Waymo n'est pas tout à fait prêt pour l'accès aux voies publiques</a></li>
<li><a href="../fr421845/index.html">Que font réellement les analystes de données? Résultats de 35 entretiens</a></li>
<li><a href="../fr421847/index.html">Sautez dans le cloud. Création d'une solution IoT économique sur NodeMCU + Azure IoT Hub</a></li>
<li><a href="../fr421849/index.html">Evénements RH en TI en septembre 2018: My Circle Digest</a></li>
<li><a href="../fr421851/index.html">Problèmes de hibou et de globe: connexion de deux assemblys avec des espaces de noms et des noms de classe identiques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>