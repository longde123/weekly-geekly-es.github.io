<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßóüèΩ ü§üüèΩ üõ£Ô∏è QUIC DataChannels: Erste Schritte üé£ üê≤ üçù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="QUIC-basierte Datenkan√§le gelten als Alternative zum aktuellen SCTP-Transport. Die Google WebRTC-Arbeitsgruppe experimentiert bereits mit ihnen: 


 L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>QUIC DataChannels: Erste Schritte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/441168/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/xp/sd/nw/xpsdnwi56nmxblmreaybg-l2fgs.png"></div><br>  QUIC-basierte Datenkan√§le gelten als Alternative zum aktuellen SCTP-Transport.  Die Google WebRTC-Arbeitsgruppe experimentiert bereits mit ihnen: <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1091362841821618177"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Lass es uns auch versuchen.  Zu diesem Zweck erstellen wir eine einseitige Anwendung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, die dem Beispiel eines WebRTC-Kanals zum Senden von Text √§hnelt.</a> Dies ist ein voll funktionsf√§higes Beispiel (ohne Signalisierungsserver), das au√üerdem den Vergleich von Ans√§tzen zur Implementierung von WebRTC-Datenkan√§len erleichtert. <br><a name="habracut"></a><br>  Bevor wir beginnen, erinnern wir uns an die Grundlagen des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DataChannel</a> . <br><br><h2>  Kurz √ºber DataChannel </h2><br>  Mit den DataChannels von WebRTC k√∂nnen Teilnehmer beliebige Daten austauschen.  Sie k√∂nnen sowohl zuverl√§ssig sein - was beim √úbertragen von Dateien sehr n√ºtzlich ist - als auch unzuverl√§ssig, was f√ºr Informationen √ºber Positionen in Spielen akzeptabel ist.  Die API ist eine Erweiterung von <code>RTCPeerConnection</code> und sieht folgenderma√üen aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dc = pc.createDataChannel(<span class="hljs-string"><span class="hljs-string">"some label string"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ,    ‚Äì ,   ‚Äì //    send dc.send("some string"); //    otherPc.addEventListener('datachannel', e =&gt; { const channel = e.channel; channel.onmessage = event =&gt; { console.log('received', event.data); }); });</span></span></code> </pre> <br>  Auf der offiziellen WebRTC-Beispielseite finden Sie Beispiele f√ºr das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Senden von Zeichenfolgen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bin√§rdaten</a> . <br><br>  DataChannel verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SCTP</a> .  Es funktioniert parallel zum RTP-Transport f√ºr Audio- und Videostreams.  Im Gegensatz zu UDP, das √ºblicherweise von Audio- und Videostreams verwendet wird, bietet SCTP viele andere Funktionen, z. B. das Multiplexen von Kan√§len √ºber eine einzelne Verbindung oder zuverl√§ssige, teilweise zuverl√§ssige (d. H. Zuverl√§ssige, aber ungeordnete) und unzuverl√§ssige Modi. <br><br>  Google hat QUIC 2012 eingef√ºhrt (mehr √ºber den Protokollverlauf und seine Nuancen finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unserem anderen Material</a> - Anmerkung des √úbersetzers).  Wie WebRTC wurde auch das QUIC-Protokoll unter die Fittiche der IETF gestellt und hei√üt jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.zdnet.com/article/http-over-quic-to-be-renamed-">HTTP / 3</a> .  QUIC verf√ºgt √ºber eine Reihe gro√üartiger Innovationen, wie z. B. reduzierte Latenz, Bandbreitenberechnung basierend auf √úberlastungskontrolle, direkte Verz√∂gerungskorrektur (FEC) und Implementierung im Benutzerbereich (anstelle des Kernels) f√ºr ein schnelleres Rollen. <br><br>  QUIC k√∂nnte eine Alternative zu RTCP f√ºr WebRTC sein - wie ein Transport f√ºr DataChannel.  Das aktuelle Experiment versucht, die Verwendung der RTCPeerConnection-API ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und SDP!</a> ) Durch Verwendung einer separaten Version des ICE-Transports zu vermeiden.  Stellen Sie sich eine virtuelle Verbindung vor, die ein wenig Sicherheit und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viel NAT-Durchquerung bietet</a> . <br><br>  Im folgenden Video erkl√§rt Ian Swett vom Chrome-Netzwerkteam dieses Konzept.  Und obwohl diese Rede mehrere Jahre alt ist, bietet sie dennoch zus√§tzliche Informationen zum Thema: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mIvyOFu1c1Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Erste Schritte mit QUIC </h2><br>  Gl√ºcklicherweise bleibt der gr√∂√üte Teil des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codes aus dem Artikel von 2015</a> relevant und l√§sst sich leicht an die neue API anpassen.  Lass es uns herausfinden. <br><br>  Klonen Sie den Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier</a> oder versuchen Sie es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Bitte beachten Sie, dass Chrome (Version 73+ ist jetzt Canary) mit speziellen Flags ausgef√ºhrt werden muss, damit das Experiment lokal funktioniert: <br><br><pre> <code class="javascript hljs">google-chrome-unstable --enable-blink-features=RTCQuicTransport,RTCIceTransportExtension</code> </pre> <br><h2>  ICE-Transport-Setup </h2><br>  Die RTCIceTransport-Spezifikation basiert auf ORTC, daher √§hnelt das Setup dem alten Code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ice1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RTCIceTransport(); ice1.onstatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'ICE transport 1 state change'</span></span>, ice1.state); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ice2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RTCIceTransport(); ice2.onstatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'ICE transport 2 state change'</span></span>, ice2.state); }; <span class="hljs-comment"><span class="hljs-comment">//  ICE- ice1.onicecandidate = function(evt) { console.log('1 -&gt; 2', evt.candidate); if (evt.candidate) { ice2.addRemoteCandidate(evt.candidate); } }; ice2.onicecandidate = function(evt) { console.log('2 -&gt; 1', evt.candidate); if (evt.candidate) { ice1.addRemoteCandidate(evt.candidate); } }; //  ICE- ice1.start(ice2.getLocalParameters(), 'controlling'); ice2.start(ice1.getLocalParameters(), 'controlled'); ice1.gather(iceOptions); ice2.gather(iceOptions);</span></span></code> </pre> <br>  Beachten Sie, dass diese API im Gegensatz zu ORTC keinen RTCIceGatherer hat.  Weil wir bereits alles haben, was wir zur Installation des ICE-Transports ben√∂tigen. <br><br><h2>  QUIC-Transport konfigurieren </h2><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quic1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RTCQuicTransport(ice1); quic1.onstatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'QUIC transport 1 state change'</span></span>, quic1.state); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quic2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RTCQuicTransport(ice2); quic2.onstatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'QUIC transport 2 state change'</span></span>, quic2.state); }; <span class="hljs-comment"><span class="hljs-comment">//     QUIC quic2.addEventListener('quicstream', (e) =&gt; { console.log('QUIC transport 2 got a stream', e.stream); receiveStream = e.stream; });</span></span></code> </pre> <br>  Hier weicht das Experiment von einer Spezifikation ab, die eine zertifikatbasierte Authentifizierung verwendet.  Stattdessen wird der √∂ffentliche Schl√ºssel verwendet, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie im Beitrag der Google-Entwickler angegeben</a> : <br><blockquote>  Die RTCQuicTransport-Verbindung wird mit einem √∂ffentlichen API-Schl√ºssel konfiguriert.  Wir planen derzeit nicht, dass diese API die urspr√ºngliche Validierung ersetzt.  Es wird durch eine Remote-Zertifikatsignalisierung ersetzt, um selbstsignierte Zertifikate zu validieren - wenn QUIC dies in Chromium unterst√ºtzt. </blockquote>  So weit, so gut. <br><br><h2>  QUICStream zum Senden und Empfangen von Daten </h2><br>  Die Verwendung von QUICStream ist etwas schwieriger als die Verwendung von WebRTC DataChannel.  Die von der WHATWG-Arbeitsgruppe erstellte Streams-API ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">siehe Details zu MDN</a> ) wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">akzeptiert, aber nicht implementiert</a> . <br><br>  Wir erstellen <code>sendStream</code> erst, nachdem der QUIC-Transport in den Status "verbunden" versetzt wurde - in einem anderen Status w√ºrde dies zu einem Fehler f√ºhren: <br><br><pre> <code class="javascript hljs">quic1.onstatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'QUIC transport 1 state change'</span></span>, quic1.state); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (quic1.state === <span class="hljs-string"><span class="hljs-string">'connected'</span></span> &amp;&amp; !sendStream) { sendStream = quic1.createStream(<span class="hljs-string"><span class="hljs-string">'webrtchacks'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   createDataChannel. document.getElementById('sendButton').disabled = false; document.getElementById('dataChannelSend').disabled = false; } };</span></span></code> </pre> <br>  Dann h√§ngen wir die Handler an die Senden-Schaltfl√§che und das Eingabefeld an: Nach dem Klicken auf die Schaltfl√§che wird der Text aus dem Eingabefeld in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Uint8Array</a> codiert und in den Stream geschrieben: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'sendButton'</span></span>).onclick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rawData = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'dataChannelSend'</span></span>).value; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'dataChannelSend'</span></span>).value = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Uint8Array. ,       TextEncoder. const data = encoder.encode(rawData); sendStream.write({ data, }); };</span></span></code> </pre> <br>  Der erste Eintrag l√∂st das Ereignis <code>onquicstream</code> auf dem Remote-QUIC-Transport aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     QUIC quic2.addEventListener('quicstream', (e) =&gt; { console.log('QUIC transport 2 got a stream', e.stream); receiveStream = e.stream; receiveStream.waitForReadable(1) .then(ondata); });</span></span></code> </pre> <br>  ... und dann warten wir, bis die Daten lesbar sind: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ondata</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(receiveStream.readBufferedAmount); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res = receiveStream.readInto(buffer); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = decoder.decode(buffer); <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'dataChannelReceive'</span></span>).value = data; receiveStream.waitForReadable(<span class="hljs-number"><span class="hljs-number">1</span></span>) .then(ondata); }</code> </pre> <br>  Alle Daten von <code>receiveStream</code> werden gelesen, in Text dekodiert und in das Ausgabefeld <code>receiveStream</code> .  Und so erscheinen jedes Mal lesbare Daten. <br><br><h2>  Schlussfolgerung und Kommentare </h2><br>  Ich hoffe, dieses Beispiel ist leichter zu verstehen als das √§hnliche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Google-Blog</a> .  Diese Methode ist f√ºr P2P-Verbindungen kaum geeignet, der DataChannel auf SCTP ist f√ºr sie bereits in Ordnung.  Dies kann jedoch eine interessante Alternative zu Web-Sockets mit einem QUIC-Server am anderen Ende sein.  Bis dies geschieht, sollten Sie einen angemessenen Weg finden, um mit unzuverl√§ssigen und ungeordneten Kan√§len zu arbeiten.  Meiner Meinung nach √§hneln die Vorschl√§ge aus dem oben genannten Beitrag eher Hacks als Entscheidungen. <br><br>  Es ist auch unklar, auf welches Feedback die Entwickler von au√üen warten.  ‚ÄûF√ºhren Sie die Spezifikation bereits ein, anstatt die Verkn√ºpfungen erneut zu formen, was noch einige Jahre bei uns bleiben wird‚Äú, klingt zu offensichtlich.  Au√üerdem tendiert die allgemeine Meinung der Community dazu, WHATWG-Streams zu verwenden, was seltsame Lichtentwickler dazu bringt, ihre eigene API zum Lesen von Daten zu testen. <br><br>  Ich m√∂chte auch, dass SCTP in Chromium zus√§tzliche Funktionen bietet.  Zum Beispiel ist diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abfrage zu DataChannel</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºbrigens</a> die am h√∂chsten bewertete - drei Jahre lang fast unber√ºhrt geblieben.  Es ist nicht ganz klar, warum der Schwerpunkt auf QUIC liegt, wenn noch SCTP-Aufgaben vorhanden sind.  Dies sollte jedoch niemanden davon abhalten, QUIC und Feedback zu den Ergebnissen zu testen. <br><br><h2>  Kommentar von Voximplant </h2><br>  Ein Wort zu unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Frontend Lead Irbisadm</a> : <br><blockquote>  Unsere SDKs werden seit langem zur Signalisierung eines Web-Sockets verwendet.  Dies ist ein ausgezeichneter, bew√§hrter Standard, aber es gibt einige Probleme damit.  Der erste ist TCP.  Und TCP ist in Mobilfunknetzen nicht so gut und schnell und unterst√ºtzt kein Roaming zwischen Netzwerken.  Zweitens ist es oft textuell (es gibt auch einen Bin√§rmodus, aber Sie sehen ihn selten). <br><br>  Wir haben k√ºrzlich einen Closed Beta-Test des Signalisierungsprotokolls auf dem DataChannel gestartet.  Dieses Protokoll ist auch nicht ohne Minuspunkte, aber da es in schlechten Netzwerken und beim Roaming funktioniert, erobert es auf den ersten Blick.  Haben Sie das Netzwerk ge√§ndert?  Die Verbindung muss nicht neu erstellt werden.  <code>ICE Restart</code> hilft in den meisten F√§llen dabei, einen neuen Weg f√ºr den Verkehr zu finden.  Aber wie gesagt, das Protokoll hat immer noch Nachteile: Nicht alle Browser unterst√ºtzen alle Protokollerweiterungen, wie z. B. garantierte Zustellung und Unterst√ºtzung f√ºr Paketbestellungen.  Au√üerdem unterst√ºtzt das Protokoll gzip f√ºr den sofort einsatzbereiten Textmodus nicht.  All diese Probleme k√∂nnen jedoch auf der Anwendungsseite gel√∂st werden. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441168/">https://habr.com/ru/post/de441168/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441152/index.html">So minimieren Sie Fehler bei der Integration in externe Services: die Erfahrung eines Online-Brokers</a></li>
<li><a href="../de441154/index.html">Elf versteckte Perlen von Java 11</a></li>
<li><a href="../de441158/index.html">Wie Ethik zum teuersten Thema im Silicon Valley wurde und Philosophie zur praktischsten L√∂sung wurde</a></li>
<li><a href="../de441160/index.html">Wie man lernt zu bestimmen, wann man nein sagt</a></li>
<li><a href="../de441166/index.html">Wir erhalten das Master-Passwort vom gesperrten Passwort-Manager 1Password 4</a></li>
<li><a href="../de441172/index.html">Wie der 3D-Druckmarkt 2018 wuchs und was er f√ºr das Gesch√§ft bedeutet</a></li>
<li><a href="../de441174/index.html">OOP ist tot, es lebe OOP</a></li>
<li><a href="../de441180/index.html">Bew√∂lkt mit der M√∂glichkeit, die Sternenhimmelwerbung nicht zu deaktivieren</a></li>
<li><a href="../de441182/index.html">Maschinensyn√§sthetischer Ansatz zur Erkennung von Netzwerk-DDoS-Angriffen. Teil 2</a></li>
<li><a href="../de441184/index.html">Die erste Spielekonferenz der Mail.ru Group</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>