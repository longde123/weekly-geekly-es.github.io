<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéå üöæ ü§üüèº Le client Steam a √©limin√© une vuln√©rabilit√© dangereuse qui s'y cachait depuis dix ans üíÄ üåÑ üèÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le chercheur principal Tom Court of Context, une soci√©t√© de s√©curit√© de l'information, explique comment il a r√©ussi √† d√©tecter un bogue potentiellemen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le client Steam a √©limin√© une vuln√©rabilit√© dangereuse qui s'y cachait depuis dix ans</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413003/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5e/654/14d/b5e65414d10ab23ed9f334c7490b5b41.jpg" alt="image"></div><br>  <i>Le chercheur principal Tom Court of Context, une soci√©t√© de s√©curit√© de l'information, explique comment il a r√©ussi √† d√©tecter un bogue potentiellement dangereux dans le code client Steam.</i> <br><br>  Les joueurs de PC soucieux de la s√©curit√© ont remarqu√© que Valve a r√©cemment publi√© une nouvelle mise √† jour du client Steam. <br><br>  Dans cet article, je veux <s>trouver des excuses pour jouer √† des jeux au travail pour</s> raconter l'histoire d'un bogue connexe qui existait dans le client Steam depuis au moins dix ans, ce qui, jusqu'en juillet de l'ann√©e derni√®re, pourrait conduire √† l'ex√©cution de code √† distance (ex√©cution de code √† distance, RCE) au total 15 millions de clients actifs. <br><br>  Depuis juillet, lorsque Valve a (enfin) compil√© son code avec la protection contre les exploits moderne activ√©e, cela ne pouvait que conduire √† une d√©faillance du client, et RCE n'√©tait possible qu'en combinaison avec une vuln√©rabilit√© de fuite d'informations distincte. <br><br>  Nous avons d√©clar√© Valve une vuln√©rabilit√© le 20 f√©vrier 2018 et, au cr√©dit de la soci√©t√©, il l'a corrig√© dans la branche b√™ta moins de 12 heures plus tard.  Le correctif a √©t√© d√©plac√© vers la succursale stable le 22 mars 2018. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e75/1aa/558/e751aa55836f621b240641f85adbde62.jpg" alt="image"></div><br><h2>  Br√®ve revue </h2><br>  La vuln√©rabilit√© √©tait bas√©e sur des dommages au tas √† l'int√©rieur de la biblioth√®que client Steam, qui pouvait √™tre appel√©e √† distance, dans la partie du code impliqu√©e dans la r√©cup√©ration du datagramme fragment√© √† partir de plusieurs paquets UDP re√ßus. <br><br>  Le client Steam √©change des donn√©es via son propre protocole (protocole Steam), qui est impl√©ment√© par-dessus UDP.  Il y a deux domaines dans ce protocole qui sont particuli√®rement int√©ressants en raison de la vuln√©rabilit√©: <br><br><ul><li>  Longueur du paquet </li><li>  La longueur totale du datagramme reconstruit </li></ul><br>  L'erreur a √©t√© caus√©e par l'absence d'un simple contr√¥le.  Le code n'a pas v√©rifi√© que la longueur du premier datagramme fragment√© est inf√©rieure ou √©gale √† la longueur totale du datagramme.  Cela semble √™tre une erreur courante √©tant donn√© que pour tous les paquets suivants qui transmettent des fragments du datagramme, la v√©rification est effectu√©e. <br><br>  Sans bogues de fuite de donn√©es suppl√©mentaires, les dommages au tas sur les syst√®mes d'exploitation modernes sont tr√®s difficiles √† contr√¥ler, de sorte que l'ex√©cution de code √† distance est difficile √† impl√©menter.  Cependant, dans ce cas, gr√¢ce √† l'allocateur de m√©moire et √† l'ASLR de Steam, qui √©taient absents dans le fichier binaire steamclient.dll (jusqu'en juillet dernier), ce bogue pourrait √™tre utilis√© comme base pour un exploit tr√®s fiable. <br><br>  Vous trouverez ci-dessous une description technique de la vuln√©rabilit√© et de son exploit associ√© jusqu'√† <br>  impl√©mentations d'ex√©cution de code. <br><br><h2>  D√©tails de vuln√©rabilit√© </h2><br><h3>  Informations n√©cessaires √† la compr√©hension </h3><br><h4>  Protocole </h4><br>  Des tiers (par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://imfreedom.org/wiki/Steam_Friends</a> ), sur la base de l'analyse du trafic g√©n√©r√© par le client Steam, ont effectu√© une r√©tro-ing√©nierie et cr√©√© une documentation d√©taill√©e du protocole Steam.  Initialement, le protocole a √©t√© document√© en 2008 et n'a pas beaucoup chang√© depuis lors. <br><br>  Le protocole est impl√©ment√© comme un protocole de transmission avec l'√©tablissement d'une connexion sur un flux de datagrammes UDP.  Les packages, conform√©ment √† la documentation du lien ci-dessus, ont la structure suivante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94b/d59/e25/94bd59e25c5dfac228e3a63b62192717.jpg" alt="image"></div><br>  Aspects importants: <br><br><ul><li>  Tous les paquets commencent par 4 octets de " <em>VS01</em> " </li><li>  <em>packet_len</em> d√©crit la longueur des informations utiles (pour les datagrammes non fragment√©s, la valeur est √©gale √† la longueur des donn√©es) </li><li>  <em>type</em> d√©crit le type de package, qui peut avoir les valeurs suivantes: <br><ul><li>  Authentification d'appel 0x2 </li><li>  0x4 Accepter la connexion </li><li>  0x5 R√©initialiser la connexion </li><li>  0x6 Un paquet est un fragment d'un datagramme </li><li>  Le package 0x7 est un datagramme distinct </li></ul></li><li>  Les champs <em>source</em> et <em>destination</em> sont des identifiants attribu√©s pour acheminer correctement les paquets sur plusieurs connexions dans le client Steam </li><li>  Dans le cas o√π le paquet est un fragment d'un datagramme: <br><ul><li>  <em>split_count</em> indique le nombre de fragments dans <em>lesquels</em> le datagramme est divis√© </li><li>  <em>data_len</em> indique la longueur totale du datagramme r√©cup√©r√© </li></ul></li><li>  Le traitement initial de ces paquets UDP se produit dans la fonction <em>CUDPConnection :: UDPRecvPkt √† l'</em> int√©rieur de <em>steamclient.dll</em> </li></ul><br><h4>  Cryptage </h4><br>  Les informations utiles du paquet datagramme sont crypt√©es par AES-256 √† l'aide d'une cl√©, qui est n√©goci√©e entre le client et le serveur √† chaque session.  La n√©gociation des cl√©s s'effectue comme suit: <br><br><ul><li>  Le client g√©n√®re une cl√© al√©atoire AES de 32 octets et RSA la chiffre avec la cl√© publique Valve avant de l'envoyer au serveur. </li><li>  Le serveur, poss√©dant une cl√© priv√©e, peut d√©chiffrer cette valeur et l'accepter comme cl√© AES-256, qui sera utilis√©e dans la session </li><li>  Une fois la cl√© accept√©e, toutes les informations utiles de la session en cours sont crypt√©es avec cette cl√©. </li></ul><br><h3>  Vuln√©rabilit√© </h3><br>  Une vuln√©rabilit√© est pr√©sente dans la m√©thode <em>RecvFragment</em> de la classe <em>CUDPConnection</em> .  Il n'y a pas de symboles dans la version finale de la biblioth√®que steamclient, cependant, lors de la recherche dans les lignes binaires dans une fonction qui nous int√©resse, un lien vers " <em>CUDPConnection :: RecvFragment</em> " est trouv√©.  La saisie de cette fonction s'effectue lorsque le client re√ßoit un paquet UDP contenant un datagramme Steam de type 0x6 (un ¬´fragment de datagramme¬ª). <br><br>  1. La fonction commence par v√©rifier l'√©tat de la connexion pour s'assurer qu'elle est √† l'√©tat " <em>Connect√©</em> ". <br>  2. Ensuite, le champ <em>data_len</em> du datagramme Steam est v√©rifi√© pour s'assurer qu'il contient moins de <em>0x20000060</em> octets (il semble que cette valeur soit choisie arbitrairement). <br>  3. Si la v√©rification est r√©ussie, la fonction v√©rifie si la connexion collecte des fragments d'un datagramme ou s'il s'agit du premier paquet du flux. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb3/19b/451/cb319b451e64f08c718a78f0f2c5995c.jpg" alt="image"></div><br>  4. S'il s'agit du premier paquet du flux, le champ <em>split_count</em> est <em>v√©rifi√©</em> pour voir combien de paquets ce flux va √©tirer. <br>  5. Si le flux est divis√© en plusieurs paquets, le champ <em>seq_no_of_first_pkt</em> est <em>v√©rifi√©</em> pour s'assurer qu'il correspond au num√©ro de s√©rie du paquet actuel.  Cela garantit que le paquet est le premier du flux. <br>  6. Le champ <em>data_len</em> est √† nouveau <em>v√©rifi√© par</em> rapport √† la limite de <em>0x20000060</em> octets.  De plus, il est v√©rifi√© que <em>split_count est</em> inf√©rieur √† <em>0x709b</em> paquets. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e6/19b/250/7e619b25083dc91558888ef6ca1b6ef4.jpg" alt="image"></div><br>  7. Si ces conditions sont remplies, une valeur bool√©enne est d√©finie pour indiquer que nous collectons maintenant des fragments.  Il v√©rifie √©galement que nous n'avons pas encore de tampon allou√© pour stocker des fragments. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69a/8b2/8c4/69a8b28c40e56f3de825d6a6c8c483c0.jpg" alt="image"></div><br>  8. Si le pointeur vers le tampon de collecte de fragments n'est pas nul, le tampon de collecte de fragments actuel est lib√©r√© et un nouveau tampon est allou√© (voir le rectangle jaune dans la figure ci-dessous).  C'est l√† que l'erreur appara√Æt.  Le tampon de collecte de fragments devrait √™tre allou√© dans la taille des octets <em>data_len</em> .  Si tout a r√©ussi (et que le code ne v√©rifie pas - une erreur mineure), les informations utiles du datagramme sont copi√©es dans ce tampon √† l'aide de <em>memmove</em> , en faisant confiance que le nombre d'octets √† copier est indiqu√© dans <em>packet_len</em> . <br><br>  <strong>La surveillance la plus importante du d√©veloppeur √©tait que la v√©rification " <em>packet_len est</em> inf√©rieur ou √©gal √† <em>data_len</em> " n'est pas effectu√©e.</strong>  <strong>Cela signifie qu'il est possible de transf√©rer <em>data_len</em> moins que <em>packet_len</em> et d'avoir jusqu'√† 64 Ko de donn√©es (car le champ <em>packet_len fait</em> 2 octets de large) copi√©s dans un tr√®s petit tampon, ce qui permet d'exploiter la corruption de tas.</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4c/6ae/a31/d4c6aea31e05f0479552817bbc95a1e3.jpg" alt="image"></div><br><h2>  Exploitation de la vuln√©rabilit√© </h2><br>  Cette section suppose qu'il existe une solution de contournement pour ASLR.  Cela conduit au fait qu'avant de commencer l'op√©ration, l'adresse de d√©part de steamclient.dll est connue. <br><br><h3>  Usurpation de paquets </h3><br>  Pour que les paquets UDP attaquants soient re√ßus par le client, il doit examiner le datagramme sortant (client -&gt; serveur), qui est envoy√© afin de trouver les identifiants de la connexion client / serveur, ainsi que le num√©ro de s√©rie.  Ensuite, l'attaquant doit usurper les adresses IP et les ports source / destination ainsi que les identifiants client / serveur et augmenter d'un num√©ro le num√©ro de s√©rie appris. <br><br><h3>  Gestion de la m√©moire </h3><br>  Pour allouer plus de 1024 octets (0x400) de m√©moire, un allocateur syst√®me standard est utilis√©.  Pour allouer de la m√©moire inf√©rieure ou √©gale √† 1024 octets, Steam utilise son propre allocateur qui fonctionne de la m√™me sur toutes les plateformes prises en charge.  Cet article ne traitera pas en d√©tail de ce distributeur, √† l'exception des aspects cl√©s suivants: <br><br><ol><li>  De grands blocs de m√©moire sont demand√©s √† l'allocateur syst√®me, qui sont ensuite divis√©s en fragments de taille fixe pour une utilisation dans les demandes d'allocation de m√©moire du client Steam. </li><li>  La s√©lection est effectu√©e s√©quentiellement, entre les fragments utilis√©s, aucune m√©tadonn√©e ne les s√©pare. </li><li>  Chaque grand bloc stocke sa propre liste de m√©moire libre, impl√©ment√©e sous la forme d'une liste li√©e individuellement. </li><li>  Le haut de la liste de m√©moire libre indique le premier fragment libre en m√©moire et les 4 premiers octets de ce fragment indiquent le prochain fragment libre (s'il en existe un). </li></ol><br><h4>  Allocation de m√©moire </h4><br>  Lors de l'allocation de m√©moire, le premier bloc libre est d√©connect√© du haut de la liste de m√©moire libre et les 4 premiers octets de ce bloc, correspondant √† <em>next_free_block</em> , sont copi√©s dans la <em>variable</em> membre <em>freelist_head</em> √† l'int√©rieur de la classe d' <em>allocateur</em> . <br><br><h4>  M√©moire libre </h4><br>  Lorsqu'un bloc est lib√©r√©, le champ <em>freelist_head est</em> copi√© dans les 4 premiers octets du bloc lib√©r√© ( <em>next_free_block</em> ) et l'adresse du bloc lib√©r√© est copi√©e dans la <em>variable</em> membre <em>freelist_head</em> de la classe de distributeur. <br><br><h3>  Comment obtenir une primitive d'enregistrement </h3><br>  Un d√©bordement de tampon se produit sur le tas, et selon la taille des paquets √† l'origine de la corruption, l'allocation de m√©moire peut √™tre contr√¥l√©e soit par l'allocateur Windows standard (lorsque l'allocation de m√©moire est sup√©rieure √† 0x400 octets) ou par le propre allocateur de Steam (lorsque l'allocation de m√©moire est inf√©rieure √† 0x400 octets).  En raison du manque de mesures de s√©curit√© dans mon propre distributeur Steam, j'ai d√©cid√© qu'il √©tait plus facile de l'utiliser pour un exploit. <br><br>  Revenons √† la section sur la gestion de la m√©moire: il est connu que le haut de la liste de m√©moire libre des blocs d'une taille donn√©e est stock√© en tant que variable membre de la classe de distributeur, et le pointeur sur le bloc libre suivant dans la liste est stock√© comme les 4 premiers octets de chaque bloc libre de la liste. <br><br>  S'il y a un bloc libre √† c√¥t√© du bloc dans lequel le d√©bordement s'est produit, les dommages au tas nous permettent d'√©craser le pointeur <em>next_free_block</em> .  Si vous consid√©rez qu'un groupe peut √™tre pr√©par√© pour cela, le pointeur <em>next_free_block</em> r√©√©crit peut √™tre d√©fini sur une adresse pour l'√©criture, apr√®s quoi l'allocation de m√©moire suivante sera √©crite √† cet endroit. <br><br><h3>  Quoi utiliser: datagrammes ou fragments </h3><br>  Une erreur de corruption de m√©moire se produit dans le code responsable du traitement des fragments de datagrammes (paquets de type 6).  Apr√®s l'occurrence de dommages, la fonction <em>RecvFragment ()</em> est dans un √©tat dans lequel elle s'attend √† recevoir d'autres fragments.  Cependant, s'ils arrivent, une v√©rification est effectu√©e: <br><br> <code>fragment_size + num_bytes_already_received &lt; sizeof(collection_buffer)</code> <br> <br>  Mais √©videmment, ce n'est pas le cas, car notre premier package a d√©j√† viol√© cette r√®gle (l'existence d'une erreur est possible de sauter cette v√©rification) et une erreur se produira.  Pour √©viter cela, vous devez √©viter la <em>m√©thode CUDPConnection :: RecvFragment ()</em> apr√®s une <em>corruption de</em> m√©moire. <br><br>  Heureusement, <em>CUDPConnection :: RecvDatagram ()</em> peut toujours recevoir et traiter les paquets envoy√©s de type 7 (datagrammes) jusqu'√† <em>ce</em> que <em>RecvFragment ()</em> soit valide, et cela peut √™tre utilis√© pour d√©marrer la primitive d'enregistrement. <br><br><h3>  Probl√®mes de cryptage </h3><br>  Les paquets re√ßus par <em>RecvDatagram ()</em> et <em>RecvFragment ()</em> devraient √™tre chiffr√©s.  Dans le cas de <em>RecvDatagram (), le</em> d√©chiffrement est effectu√© presque imm√©diatement apr√®s sa r√©ception.  Dans le cas de <em>RecvFragment (),</em> cela se produit apr√®s avoir re√ßu le dernier fragment de la session. <br><br>  Le probl√®me de l'exploitation de la vuln√©rabilit√© se pose car nous ne connaissons pas la cl√© de chiffrement cr√©√©e √† chaque session.  Cela signifie que tout code OP / code shell que nous envoyons sera ¬´d√©chiffr√©¬ª en utilisant AES256, ce qui transformera nos donn√©es en ordures.  Par cons√©quent, il est n√©cessaire de trouver une m√©thode de fonctionnement, qui est possible presque imm√©diatement apr√®s la r√©ception du paquet, avant que les proc√©dures de d√©chiffrement puissent traiter les informations utiles contenues dans le tampon de paquets. <br><br><h3>  Comment r√©aliser l'ex√©cution de code </h3><br>  Compte tenu de la restriction de d√©chiffrement d√©crite ci-dessus, l'op√©ration doit √™tre effectu√©e avant le d√©chiffrement des donn√©es entrantes.  Cela impose des restrictions suppl√©mentaires, mais la t√¢che est toujours r√©alisable: vous pouvez r√©√©crire le pointeur afin qu'il pointe vers l'objet <em>CWorkThreadPool</em> stock√© dans un endroit pr√©visible √† l'int√©rieur de la section de donn√©es du fichier binaire.  Bien que les d√©tails et les fonctionnalit√©s internes de cette classe soient inconnus, son nom peut supposer qu'elle prend en charge un pool de threads que vous pouvez utiliser lorsque vous avez besoin de "travailler".  Apr√®s avoir √©tudi√© plusieurs lignes de d√©bogage dans un fichier binaire, vous pouvez comprendre que parmi ces travaux, il y a le chiffrement et le d√©chiffrement ( <em>CWorkItemNetFilterEncrypt</em> , <em>CWorkItemNetFilterDecrypt</em> ), donc lorsque ces t√¢ches sont mises en file d'attente, la classe <em>CWorkThreadPool</em> est <em>utilis√©e</em> .  En √©crasant ce pointeur et en y √©crivant l'emplacement souhait√©, nous pouvons simuler le pointeur vtable et la vtable qui lui est associ√©e, ce qui nous permet d'ex√©cuter du code, par exemple, lorsque <em>CWorkThreadPool :: AddWorkItem () est</em> appel√©, ce qui doit se produire avant tout processus de d√©cryptage. <br><br>  La figure ci-dessous montre l'exploitation r√©ussie de la vuln√©rabilit√© jusqu'au stade de la prise de contr√¥le du registre EIP. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a8/383/537/4a83835371112599ca429941e449e734.jpg" alt="image"></div><br>  √Ä partir de maintenant, vous pouvez cr√©er une cha√Æne ROP qui m√®ne √† l'ex√©cution de code arbitraire.  La vid√©o ci-dessous montre comment un attaquant d√©marre √† distance une calculatrice Windows dans une version enti√®rement corrig√©e de Windows 10. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0QaozC8S0Aw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Pour r√©sumer </h2><br>  Si vous arrivez √† cette partie de l'article, merci de votre pers√©v√©rance!  J'esp√®re que vous comprenez qu'il s'agit d'un bogue tr√®s simple qui a √©t√© assez facile √† exploiter en raison du manque de moyens modernes de protection contre les exploits.  Le code vuln√©rable √©tait probablement tr√®s ancien, mais sinon il fonctionnait bien, donc les d√©veloppeurs n'ont pas vu la n√©cessit√© de l'examiner ou de mettre √† jour ses scripts de construction.  La le√ßon ici est qu'il est important pour les d√©veloppeurs de revoir p√©riodiquement l'ancien code et de construire des syst√®mes pour s'assurer qu'ils sont conformes aux normes de s√©curit√© modernes, m√™me si la fonctionnalit√© du code lui-m√™me reste inchang√©e.  C'√©tait incroyable de trouver en 2018 un bug aussi simple avec des cons√©quences aussi graves sur une plate-forme logicielle tr√®s populaire.  Cela devrait √™tre une incitation √† rechercher de telles vuln√©rabilit√©s pour tous les chercheurs! <br><br>  Enfin, il convient de parler du processus de divulgation responsable des informations.  Nous avons signal√© ce bogue √† Valve dans une lettre √† son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©quipe de</a> s√©curit√© ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">security@valvesoftware.com</a> ) vers 16 heures GMT et seulement 8 heures plus tard, un correctif a √©t√© cr√©√© et lanc√© dans le client b√™ta Steam.  Gr√¢ce √† cela, Valve est d√©sormais en premi√®re place dans notre tableau (imaginaire) du concours ¬´Qui corrigera la vuln√©rabilit√© plus rapidement¬ª - une exception agr√©able par rapport √† la divulgation d'erreurs √† d'autres entreprises, ce qui entra√Æne souvent un long processus d'approbation. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Une page qui d√©crit les d√©tails de toutes les mises √† jour du client</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413003/">https://habr.com/ru/post/fr413003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr412993/index.html">Infrastructure de cl√© publique: utilitaire de g√©n√©ration de demande de certificat qualifi√©</a></li>
<li><a href="../fr412995/index.html">SAP rapide</a></li>
<li><a href="../fr412997/index.html">Cache-cache, ou le premier botnet qui n'a pas peur de red√©marrer</a></li>
<li><a href="../fr412999/index.html">Du bourdonnement des girafes aux sons d'oiseaux mim√©tiques - √©couter la nature ensemble</a></li>
<li><a href="../fr413001/index.html">SamsPcbGuide, Part 5: Tracing Signal Lines. Distorsion de ligne et adaptation d'imp√©dance</a></li>
<li><a href="../fr413005/index.html">Blockchain - un rem√®de contre les principales maladies de l'√©ducation moderne</a></li>
<li><a href="../fr413007/index.html">√âtrange synth√®se en travaillant avec FPGA</a></li>
<li><a href="../fr413009/index.html">Gestion de l'environnement Python avec Pipenv</a></li>
<li><a href="../fr413011/index.html">Sous-sol de la mort</a></li>
<li><a href="../fr413013/index.html">Le d√©sir de transparence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>