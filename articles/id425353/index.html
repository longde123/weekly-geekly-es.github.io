<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✌🏽 👨🏾‍💻 💈 Seluruh kebenaran tentang RTOS. Artikel # 13. Struktur data tugas dan panggilan API yang tidak didukung 🎙️ 😀 👂🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel tugas ketiga dan terakhir ini, saya akan melihat struktur data Nucleus SE dan menjelaskan panggilan RTOS API yang tidak diterapkan di Nu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seluruh kebenaran tentang RTOS. Artikel # 13. Struktur data tugas dan panggilan API yang tidak didukung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425353/"><img src="https://habrastorage.org/webt/a2/hi/au/a2hiaum17nhh6_ibldqgahpgaxo.jpeg"><br><br>  Dalam artikel tugas ketiga dan terakhir ini, saya akan melihat struktur data Nucleus SE dan menjelaskan panggilan RTOS API yang tidak diterapkan di Nucleus SE, serta masalah kompatibilitas lainnya. <br><a name="habracut"></a><br>  Artikel sebelumnya dalam seri: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan untuk bekerja dengan tugas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas: konfigurasi dan pengantar API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: fitur canggih dan pelestarian konteks</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: implementasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Desain dan Penyebaran Internal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan RTOS lainnya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Interaksi tugas dan sinkronisasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas, pengalihan konteks, dan interupsi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas dan Perencanaan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: Struktur dan mode waktu-nyata</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: pengantar.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a> <br><h2>  Struktur data </h2><br>  Tugas menggunakan berbagai struktur data (baik dalam RAM dan ROM), yang, seperti objek Nucleus SE lainnya, adalah seperangkat tabel yang ukurannya sesuai dengan jumlah tugas dan parameter yang dipilih. <br><br>  Saya sangat merekomendasikan kode aplikasi mengakses struktur data ini menggunakan fungsi API, dan tidak secara langsung.  Ini menghindari efek samping yang tidak diinginkan, ketidakcocokan dengan versi Nucleus SE yang akan datang, dan juga menyederhanakan porting aplikasi ke Nucleus RTOS.  Untuk pemahaman yang lebih baik tentang pengoperasian kode panggilan layanan dan proses debugging, deskripsi terperinci dari struktur data diberikan di bawah ini. <br><br><h3>  Struktur Data Kernel Hosted dalam RAM </h3><br>  Struktur data ini meliputi: <br><br>  <b>NUSE_Task_Context [] []</b> - array dua dimensi dari tipe <b>ADDR</b> , memiliki satu baris untuk setiap tugas.  Jumlah kolom tergantung pada arsitektur controller dan ditentukan oleh simbol <b>NUSE_REGISTERS</b> , yang didefinisikan dalam <b>nuse_types.h</b> .  Array ini digunakan oleh penjadwal untuk menyimpan konteks setiap tugas dan telah dijelaskan secara rinci di bagian "Menyimpan Konteks" artikel # 10.  Tidak dibuat jika penjadwal RTC digunakan. <br>  <b>NUSE_Task_Signal_Flags []</b> - larik tipe <b>U8</b> , dibuat jika sinyal diaktifkan, dan berisi 8 flag sinyal untuk setiap tugas.  Sinyal akan dibahas dalam salah satu artikel berikut. <br>  <b>NUSE_Task_Timeout_Counter []</b> adalah larik tipe <b>U16</b> , terdiri dari pengurangan penghitung untuk setiap tugas dan dibuat jika panggilan ke API <b>NUSE_Task_Sleep ()</b> diaktifkan. <br>  <b>NUSE_Task_Status []</b> - larik tipe U8, berisi status setiap tugas - <b>NUSE_READY</b> atau menangguhkan status.  Dibuat hanya jika penangguhan tugas diaktifkan. <br>  <b>NUSE_Task_Blocking_Return []</b> - larik tipe U8, dibuat jika pemblokiran panggilan API diaktifkan.  Ini berisi kode kembali yang akan digunakan setelah memblokir panggilan API.  Biasanya berisi <b>NUSE_SUCCESS</b> atau kode yang menunjukkan bahwa objek telah disetel ulang (misalnya, <b>NUSE_MAILBOX_WAS_RESET</b> ). <br>  <b>NUSE_Task_Schedule_Count []</b> - larik tipe <b>U16</b> , berisi penghitung untuk setiap tugas dan dibuat hanya jika jumlah penjadwal telah diaktifkan. <br><br>  <b>NUSE_Task_Context [] []</b> diinisialisasi terutama oleh nol, kecuali untuk entri yang berkaitan dengan register status (register status, SR), penghitung program (penghitung program, PC) dan penunjuk tumpukan (penunjuk tumpukan, SP), yang diberi nilai awal (lihat "Data dalam ROM "di bawah), dan semua struktur data lainnya <b>NUSE_Init_Task ()</b> ditugaskan nol ketika memulai Nucleus SE.  Salah satu artikel berikut akan berisi daftar lengkap prosedur awal Nucleus SE dengan uraiannya. <br><br>  Berikut ini adalah definisi dari struktur data yang terkandung dalam file nuse_init.c. <br><br><img src="https://habrastorage.org/webt/fj/hr/le/fjhrlehn7si_hkt5lnnyk6dosno.jpeg"><br><br><h3>  Data pengguna RAM </h3><br>  Pengguna harus menentukan tumpukan untuk setiap tugas (jika penjadwal RTC tidak digunakan).  Ini haruslah array <b>ADDR</b> , yang biasanya didefinisikan dalam <b>nuse_config.c</b> .  Alamat dan ukuran tumpukan harus ditempatkan dalam entri tugas <b>NUSE_Task_Stack_Base []</b> dan <b>NUSE_Task_Stack_Size [],</b> masing-masing (lihat Data dalam ROM). <br><br><h3>  Data ROM </h3><br>  ROM menyimpan dari satu hingga empat struktur data yang terkait dengan tugas.  Jumlah pasti tergantung pada parameter yang dipilih: <br><br>  <b>NUSE_Task_Start_Address []</b> adalah larik jenis <b>ADDR</b> yang memiliki satu entri untuk setiap tugas, yang merupakan penunjuk ke titik entri kode untuk tugas tersebut. <br>  <b>NUSE_Task_Stack_Base []</b> adalah larik tipe <b>ADDR</b> yang memiliki satu entri untuk setiap tugas, yang merupakan penunjuk ke alamat dasar tumpukan untuk tugas tersebut.  Array ini dibuat jika ada penjadwal selain RTC yang digunakan. <br>  <b>NUSE_Task_Stack_Size []</b> adalah larik tipe <b>U16</b> yang memiliki satu entri untuk setiap tugas, yang menunjukkan ukuran tumpukan untuk tugas tersebut (dalam kata-kata).  Array ini dibuat jika ada penjadwal selain RTC yang digunakan. <br>  <b>NUSE_Task_Initial_State []</b> adalah larik tipe <b>U8</b> , memiliki satu entri untuk setiap tugas, yang menunjukkan status awal tugas.  Ini dapat berupa <b>NUSE_READY</b> atau <b>NUSE_PURE_SUSPEND</b> .  Array ini dibuat jika dukungan untuk keadaan awal tugas dipilih. <br><br>  Struktur data ini dideklarasikan dan diinisialisasi (secara statis) di <b>nuse_config.c</b> : <br><br><img src="https://habrastorage.org/webt/2g/pp/bu/2gppbu3zs8wc0gipo3kggntvxek.jpeg"><br><br><h3>  Jumlah memori untuk menyimpan data tugas (Footprint Data Tugas) </h3><br>  Seperti semua objek inti Nucleus SE, jumlah memori yang diperlukan untuk menyimpan data dapat diprediksi. <br><br>  Ukuran ROM (dalam byte) diperlukan untuk semua tugas aplikasi: <br>  <b>NUSE_TASK_NUMBER * sizeof (ADDR)</b> <br><br>  Plus, jika ada penjadwal selain RTC dipilih: <br>  <b>NUSE_TASK_NUMBER * (sizeof (ADDR) +2)</b> <br><br>  Plus, jika dukungan untuk keadaan awal tugas dipilih: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  Untuk menyimpan data dalam RAM, jumlah memori (dalam byte) ditentukan oleh parameter yang dipilih, dan dapat memiliki nilai nol jika tidak ada parameter yang dipilih. <br>  Jika penjadwal selain RTC dipilih: <br>  <b>NUSE_TASK_NUMBER * NUSE REGISTERS * sizeof (ADDR)</b> <br><br>  Plus, jika dukungan sinyal dipilih: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  Plus, jika panggilan ke NUSE_Task_Sleep () API diaktifkan: <br>  <b>NUSE_TASK_NUMBER * 2</b> <br><br>  Plus, jika penangguhan tugas diaktifkan: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  Plus, jika pemblokiran panggilan API diaktifkan: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  Plus, jika penghitung penjadwal diaktifkan: <br>  <b>NUSE_TASK_NUMBER * 2</b> <br><br><h2>  Panggilan API tidak diterapkan di Nucleus SE </h2><br>  Di bawah ini adalah tujuh panggilan API yang tersedia di Nucleus RTOS yang tidak diterapkan di Nucleus SE. <br><br><h3>  Buat Tugas </h3><br>  Panggilan API ini menciptakan tugas aplikasi.  Nucleus SE tidak memerlukan fitur ini karena tugas dibuat secara statis. <br><br>  Prototipe panggilan: <br><br>  <b>STATUS NU_Create_Task (NU_TASK * tugas, CHAR * nama, VOID (* task_entry) (TIDAK DITANDATANGANI, VOID *), argc TIDAK TANDA, VOID * stack_address, stack_address yang TIDAK DITANDATANGANI, prioritas TAMBAHAN, ukuran OPSI, prioritas OPSI, prioritas waktu TANDA, prioritas OPTION, OPTION prioritas</b> <br><br>  Parameter: <br><br>  <b>task</b> - pointer ke blok kontrol tugas pengguna, dapat digunakan sebagai pegangan / tautan ("handle") dari tugas dalam panggilan API lainnya; <br>  <b>name</b> - pointer ke nama tugas, string 7-karakter dengan nol penghentian; <br>  <b>task_entry</b> - menunjukkan fungsi input untuk tugas; <br>  <b>argc</b> - Elemen data yang tidak <b>ditandai</b> yang dapat digunakan untuk meneruskan informasi awal ke tugas; <br>  <b>argv</b> - pointer yang dapat digunakan untuk mengirimkan informasi ke tugas; <br>  <b>stack_address</b> - mengatur sektor awal memori untuk tumpukan tugas; <br>  <b>stack_size</b> - menunjukkan jumlah byte di stack; <br>  <b>priority</b> - menunjukkan nilai prioritas tugas: dari 0 hingga 255, di mana angka yang lebih rendah sesuai dengan prioritas tertinggi; <br>  <b>time_slice</b> - menunjukkan jumlah <b>irisan</b> waktu maksimum yang dapat dilewati selama tugas ini.  Nilai "0" menonaktifkan pengiris waktu untuk tugas ini; <br>  <b>preempt</b> - menunjukkan apakah tugas digantikan atau tidak.  Mungkin memiliki nilai <b>NU_PREEMPT</b> dan <b>NU_NO_PREEMPT</b> ; <br>  <b>auto_start</b> - menunjukkan status awal tugas.  <b>NU_START</b> berarti bahwa tugas tersebut siap untuk dieksekusi, dan <b>NU_NO_START berarti</b> bahwa tugas tersebut ditangguhkan. <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - menunjukkan keberhasilan penyelesaian layanan; <br>  <b>NU_INVALID_TASK</b> - menunjukkan bahwa penunjuk ke unit kontrol tugas adalah <b>NULL</b> ; <br>  <b>NU_INVALID_ENTRY</b> - menunjukkan bahwa penunjuk ke fungsi input tugas adalah <b>NULL</b> ; <br>  <b>NU_INVALID_MEMORY</b> - menunjukkan bahwa sektor memori yang ditetapkan oleh parameter stack_address adalah nol ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - menunjukkan bahwa ukuran tumpukan yang ditentukan tidak cukup; <br>  <b>NU_INVALID_PREEMPT</b> - menunjukkan bahwa parameter <b>preempt</b> diatur secara tidak benar; <br>  <b>NU_INVALID_START</b> - menunjukkan bahwa parameter <b>auto_start</b> diatur secara tidak benar. <br><br><h3>  Hapus Tugas </h3><br>  Panggilan API ini menghapus tugas aplikasi yang dibuat sebelumnya yang harus <i>Selesai</i> atau <i>Dihentikan</i> .  Panggilan ini juga tidak perlu untuk Nucleus SE, karena tugas dibuat secara statis dan tidak dapat dihapus. <br><br>  Prototipe panggilan: <br><br>  <b>STATUS NU_Delete_Task (tugas NU_TASK *);</b> <br><br>  Parameter: <br><br>  penunjuk tugas ke blok kontrol tugas <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - menunjukkan keberhasilan penyelesaian layanan; <br>  <b>NU_INVALID_TASK</b> - menunjukkan bahwa penunjuk ke tugas diatur secara tidak benar; <br>  <b>NU_INVALID_DELETE</b> - Menunjukkan bahwa tugas tidak dalam status Selesai atau Dihentikan. <br><br><h3>  Dapatkan Penunjuk Tugas </h3><br>  Panggilan API ini membuat daftar petunjuk berurutan untuk semua tugas dalam sistem.  Tidak diperlukan dalam Nucleus SE, karena tugas diidentifikasi menggunakan indeks sederhana, bukan pointer. <br><br>  Prototipe panggilan: <br><br>  <b>NU_Task_Pointers TIDAK DITANDATANGANI (NU_TASK ** pointer_list, maksimum_pointers UNSIGNED);</b> <br><br>  Parameter: <br><br>  <b>pointer_list</b> - pointer ke array pointer <b>NU_TASK</b> .  Array ini akan diisi dengan pointer ke tugas-tugas yang diinstal dalam sistem; <br>  <b>maximum_pointers</b> - jumlah maksimum pointer yang dapat ditempatkan dalam array. <br><br>  Nilai pengembalian: <br><br>  Jumlah pointer <b>NU_TASK</b> ditempatkan dalam array. <br><br><h3>  Ubah Prioritas Tugas </h3><br>  Panggilan API ini memberi tugas prioritas baru.  Dalam Nucleus SE, itu tidak diperlukan, karena prioritas tugas adalah konstan. <br><br>  Prototipe panggilan: <br><br>  <b>OPTION NU_Change_Priority (tugas NU_TASK *, OPTION new_priority);</b> <br><br>  Parameter: <br><br>  <b>tugas</b> - pointer ke blok kontrol tugas; <br>  <b>new_priority</b> - menetapkan prioritas dari 0 hingga 255. <br><br>  Nilai pengembalian: <br>  Nilai prioritas tugas sebelumnya. <br><br><h3>  Ubah Algoritma Preemption Tugas </h3><br>  Panggilan API ini mengubah urutan penyelesaian tugas yang sedang berlangsung.  Nucleus SE tidak membutuhkannya karena menggunakan algoritma penjadwalan yang lebih sederhana. <br><br>  Prototipe panggilan: <br>  <b>OPTION NU_Change_Preemption (preempt OPTION);</b> <br><br>  Parameter: <br>  <b>preempt</b> - algoritma <b>preemptive</b> baru, menerima <b>NU_PREEMPT</b> atau <b>NU_NO_PREEMPT</b> <br><br>  Nilai pengembalian: <br>  Algoritma sebelumnya untuk crowding out tugas. <br><br><h3>  Ubah Irisan Waktu Tugas </h3><br>  Panggilan API ini mengubah irisan waktu tugas tertentu.  Nucleus SE tidak membutuhkannya, karena irisan waktu tugas sudah diperbaiki. <br><br>  Prototipe panggilan: <br>  <b>NU_Change_Time_Slice UNSIGNED (tugas NU_TASK *, UNSIGNED time_slice);</b> <br><br>  Parameter: <br>  <b>tugas</b> - pointer ke blok kontrol tugas; <br>  <b>time_slice</b> - jumlah maksimum <b>irisan</b> waktu yang dapat berlalu selama tugas ini, nilai nol bidang ini menonaktifkan kuantisasi waktu untuk tugas ini. <br><br>  Nilai pengembalian: <br>  Nilai sebelumnya dari kuantum waktu tugas. <br><br><h3>  Hentikan Tugas </h3><br>  Panggilan API ini menyelesaikan tugas tertentu.  Nucleus SE tidak memerlukan ini karena keadaan <i>Dihentikan</i> tidak didukung. <br><br>  Prototipe panggilan: <br>  <b>STATUS NU_Terminate_Task (tugas NU_TASK *);</b> <br><br>  Parameter: <br>  <b>task</b> - pointer ke blok kontrol tugas. <br><br>  Nilai pengembalian: <br>  <b>NU_SUCCESS</b> - menunjukkan keberhasilan penyelesaian layanan; <br>  <b>NU_INVALID_TASK</b> - Menunjukkan bahwa penunjuk tugas salah. <br><br><h2>  Kompatibel dengan RTOS Inti </h2><br>  Ketika mengembangkan Nucleus SE, salah satu tujuan utama adalah untuk memastikan tingkat kompatibilitas kode yang tinggi dengan Nucleus RTOS.  Tugas tidak terkecuali dan, dari sudut pandang pengguna, mereka diimplementasikan dalam banyak cara yang sama seperti pada Nucleus RTOS.  Ada beberapa area yang tidak kompatibel di mana saya sampai pada kesimpulan bahwa ketidakcocokan seperti itu akan dapat diterima, mengingat bahwa kode akhir lebih mudah dipahami dan dapat menggunakan memori lebih efisien.  Namun, selain ketidakcocokan ini, sisa panggilan Nucleus RTOS API dapat digunakan hampir secara langsung sebagai panggilan Nucleus SE.  Salah satu artikel berikut akan memberikan rincian lebih lanjut tentang transisi dari Nucleus RTOS ke Nucleus SE <br><br><h3>  Pengidentifikasi Objek </h3><br>  Dalam Nucleus RTOS, semua objek dijelaskan oleh struktur data (unit kontrol) yang dari tipe tertentu.  Penunjuk ke unit kontrol ini berfungsi sebagai pengidentifikasi untuk tugas tersebut.  Di Nucleus SE, saya memutuskan bahwa diperlukan pendekatan yang berbeda untuk penggunaan memori yang efisien.  Semua objek kernel dijelaskan oleh satu set tabel dalam RAM dan / atau ROM.  Ukuran tabel ini ditentukan oleh jumlah jenis objek.  Pengidentifikasi objek tertentu adalah indeks dalam tabel ini.  Jadi saya mendefinisikan <b>NUSE_TASK</b> sebagai setara dengan <b>U8</b> .  Variabel jenis ini (bukan penunjuk) berfungsi sebagai pengidentifikasi untuk tugas.  Ini adalah ketidakcocokan kecil yang mudah diketahui jika kode porting ke atau dari Nucleus RTOS.  Pengidentifikasi objek biasanya disimpan dan dikirim tidak berubah. <br><br>  Nucleus RTOS juga mendukung penamaan tugas.  Nama-nama ini hanya digunakan untuk debugging.  Saya mengecualikan mereka dari Nucleus SE untuk menghemat memori. <br><br><h3>  Status tugas </h3><br>  Dalam Nucleus RTOS, tugas bisa di salah satu dari beberapa negara: <i>Eksekusi</i> , <i>Siap</i> , <i>Ditangguhkan</i> (yang mengarah ke ketidakpastian: tugas dalam keadaan siaga atau diblokir oleh panggilan API), <i>Dihentikan,</i> atau Selesai. <br><br>  Nucleus SE juga mendukung status <i>Eksekusi</i> dan <i>Siap</i> .  Ketiga opsi <i>Penangguhan</i> didukung secara opsional.  <i>Dihentikan</i> dan Selesai tidak didukung.  Tidak ada panggilan API untuk menyelesaikan tugas.  Fungsi tugas eksternal seharusnya tidak pernah mengembalikan nilai baik secara eksplisit maupun implisit (ini akan menghasilkan status <i>jadi</i> dalam Nucleus RTOS). <br><br><h3>  Panggilan API yang belum direalisasi </h3><br>  Nucleus RTOS mendukung 16 panggilan kantor untuk bekerja dengan tugas.  Dari jumlah tersebut, 7 tidak diimplementasikan dalam Nucleus SE.  Deskripsi mereka, serta alasan pengecualian mereka dijelaskan di atas. <br><br>  Pada artikel selanjutnya, kita akan mulai melihat manajemen memori RTOS. <br><br>  <b>Tentang Pengarang:</b> Colin Walls telah bekerja di industri elektronik selama lebih dari tiga puluh tahun, mencurahkan sebagian besar waktunya untuk firmware.  Dia sekarang adalah seorang insinyur firmware di Mentor Embedded (sebuah divisi dari Mentor Graphics).  Colin Walls sering berbicara di konferensi dan seminar, penulis berbagai artikel teknis dan dua buku tentang firmware.  Tinggal di Inggris.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blog</a> profesional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Colin</a> , email: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425353/">https://habr.com/ru/post/id425353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425343/index.html">25 alat Kubernet yang berguna: penyebaran dan manajemen</a></li>
<li><a href="../id425345/index.html">Penyederhanaan nama: 802.11ax menjadi Wi-Fi 6</a></li>
<li><a href="../id425347/index.html">Topeng Dumping: mitos atau kenyataan</a></li>
<li><a href="../id425349/index.html">Forum Positive Hack Days 9 akan diadakan 21 dan 22 Mei di Crocus Expo</a></li>
<li><a href="../id425351/index.html">Pemrogram DIY kehilangan pekerjaan mereka</a></li>
<li><a href="../id425355/index.html">Peringkat Keamanan Proyek ICO</a></li>
<li><a href="../id425357/index.html">Bagaimana kami mengumpulkan tumpukan teknologi 12 lantai dan tidak menjadi gila</a></li>
<li><a href="../id425359/index.html">Orang Cina menggunakan microchip untuk mengendalikan komputer Amerika</a></li>
<li><a href="../id425361/index.html">Pemblokiran konten, ekstensi untuk peramban kromium</a></li>
<li><a href="../id425363/index.html">Kiat untuk programmer mahasiswa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>