<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè§ üê∫ ‚öúÔ∏è Conceptos b√°sicos de inyecci√≥n de dependencia üê≥ üë®üèª‚Äçüç≥ üéÖüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo, hablar√© sobre los conceptos b√°sicos de la inyecci√≥n de dependencia (Ing. Dependency Injection, DI ) en un lenguaje simple, y tambi√©n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conceptos b√°sicos de inyecci√≥n de dependencia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434380/"><p><img src="https://habrastorage.org/getpro/habr/post_images/741/7ce/850/7417ce8508eb0e9c8dbd12b14d37f383.jpg" alt="Conceptos b√°sicos de inyecci√≥n de dependencia"></p><br><p>  En este art√≠culo, hablar√© sobre los conceptos b√°sicos de la inyecci√≥n de dependencia (Ing. <em>Dependency Injection, DI</em> ) en un lenguaje simple, y tambi√©n sobre las razones para usar este enfoque.  Este art√≠culo est√° dirigido a aquellos que no saben qu√© es la inyecci√≥n de dependencia o que dudan de la necesidad de utilizar esta t√©cnica.  Entonces comencemos. </p><a name="habracut"></a><br><h2 id="chto-takoe-zavisimost">  ¬øQu√© es la adicci√≥n? </h2><br><p> Veamos primero un ejemplo.  Tenemos <code>ClassA</code> , <code>ClassB</code> y <code>ClassC</code> como se muestra a continuaci√≥n: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><p>  Puede ver que la clase <code>ClassA</code> contiene una instancia de la clase <code>ClassB</code> , por lo que podemos decir que la clase <code>ClassA</code> depende de la clase <code>ClassB</code> .  Por qu√©  Porque <code>ClassA</code> necesita <code>ClassB</code> para funcionar correctamente.  Tambi√©n podemos decir que la clase <code>ClassB</code> es una dependencia de la clase <code>ClassA</code> . </p><br><p>  Antes de continuar, quiero aclarar que tal relaci√≥n es buena, porque no necesitamos una clase para hacer todo el trabajo en la aplicaci√≥n.  Necesitamos dividir la l√≥gica en diferentes clases, cada una de las cuales ser√° responsable de una determinada funci√≥n.  Y en este caso, las clases podr√°n interactuar de manera efectiva. </p><br><h2 id="kak-rabotat-s-zavisimostyami">  ¬øC√≥mo trabajar con dependencias? </h2><br><p>  Veamos tres m√©todos que se utilizan para realizar tareas de inyecci√≥n de dependencia: </p><br><h3 id="pervyy-sposob-sozdavat-zavisimosti-v-zavisimom-klasse">  Primera forma: crear dependencias en una clase dependiente </h3><br><p>  En pocas palabras, podemos crear objetos siempre que los necesitemos.  Eche un vistazo al siguiente ejemplo: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someMethodOrConstructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { classB = ClassB() classB.doSomething() } }</code> </pre> <br><p>  Es muy facil!  Creamos una clase cuando la necesitamos. </p><br><p>  <strong>Los beneficios</strong> </p><br><ul><li>  Es facil y sencillo. </li><li>  La clase dependiente ( <code>ClassA</code> en nuestro caso) controla completamente c√≥mo y cu√°ndo crear las dependencias. </li></ul><br><p>  <strong>Desventajas</strong> </p><br><ul><li>  <code>ClassA</code> y <code>ClassB</code> estrechamente relacionadas entre s√≠.  Por lo tanto, cada vez que necesitemos usar <code>ClassA</code> , nos veremos obligados a usar <code>ClassB</code> , y <strong>ser√° imposible reemplazar <code>ClassB</code> con otra cosa</strong> . </li><li>  Con cualquier cambio en la inicializaci√≥n de la clase <code>ClassB</code> , deber√° ajustar el c√≥digo dentro de la clase <code>ClassA</code> (y todas las dem√°s clases dependientes de <code>ClassB</code> ).  Esto complica el proceso de cambiar la dependencia. </li><li>  <strong><code>ClassA</code> no puede ser probada.</strong>  Si necesita probar una clase y, sin embargo, este es uno de los aspectos m√°s importantes del desarrollo de software, deber√° realizar pruebas unitarias de cada clase por separado.  Esto significa que si desea verificar el funcionamiento correcto de la clase <code>ClassA</code> y crear varias pruebas unitarias para verificarlo, entonces, como se muestra en el ejemplo, en cualquier caso tambi√©n crear√° una instancia de la clase <code>ClassB</code> , incluso cuando no le interese.  Si se produce un error durante la prueba, no podr√° comprender d√≥nde se encuentra: en <code>ClassA</code> o <code>ClassB</code>  Despu√©s de todo, existe la posibilidad de que parte del c√≥digo en <code>ClassB</code> provoc√≥ un error, mientras que <code>ClassA</code> funciona correctamente.  En otras palabras, las pruebas unitarias no son posibles porque los m√≥dulos (clases) no se pueden separar entre s√≠. </li><li>  <code>ClassA</code> debe configurarse de modo que pueda inyectar dependencias.  En nuestro ejemplo, necesita saber c√≥mo crear un <code>ClassC</code> y usarlo para crear un <code>ClassB</code> .  Ser√≠a mejor si no supiera nada al respecto.  Por qu√©  Debido al <strong>principio de responsabilidad √∫nica</strong> . </li></ul><br><blockquote>  <em>Cada clase solo debe hacer su trabajo.</em> </blockquote><p>  Por lo tanto, no queremos que las clases sean responsables de otra cosa que no sean sus propias tareas.  La implementaci√≥n de dependencias es una tarea adicional que establecemos para ellos. </p><br><h3 id="vtoroy-sposob-vnedryat-zavisimosti-cherez-polzovatelskiy-klass">  Segunda forma: inyectar dependencias a trav√©s de una clase personalizada </h3><br><p>  Entonces, entender que inyectar dependencias dentro de una clase dependiente no es una buena idea, exploremos una forma alternativa.  Aqu√≠, la clase dependiente define todas las dependencias que necesita dentro del constructor y permite que la clase de usuario las proporcione.  ¬øEs esta una soluci√≥n a nuestro problema?  Lo sabremos un poco m√°s tarde. </p><br><p>  Eche un vistazo al c√≥digo de muestra a continuaci√≥n: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classB: ClassB){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classB = classB } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classC: ClassC){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classC = classC } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserClass</span></span></span></span>(){ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classC = ClassC(); <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classB = ClassB(classC); <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classA = ClassA(classB); classA.someMethod(); } } view rawDI Example In Medium -</code> </pre> <br><p>  Ahora <code>ClassA</code> obtiene todas las dependencias dentro del constructor y simplemente puede llamar a los m√©todos de la clase <code>ClassB</code> sin inicializar nada. </p><br><p>  <strong>Los beneficios</strong> </p><br><ul><li>  <code>ClassA</code> y la <code>ClassB</code> ahora <code>ClassB</code> acopladas de manera flexible, y podemos reemplazar a la <code>ClassB</code> sin romper el c√≥digo dentro de la <code>ClassA</code>  Por ejemplo, en lugar de pasar <code>ClassB</code> podemos pasar <code>AssumeClassB</code> , que es una subclase de <code>ClassB</code> , y nuestro programa funcionar√° correctamente. </li><li>  <code>ClassA</code> ahora se puede probar.  Al escribir una prueba unitaria, podemos crear nuestra propia versi√≥n de <code>ClassB</code> (objeto de prueba) y pasarla a <code>ClassA</code> .  Si se produce un error al pasar la prueba, ahora sabemos con certeza que este es definitivamente un error en la <code>ClassA</code> </li><li>  <code>ClassB</code> libre de trabajar con dependencias y puede centrarse en sus tareas. </li></ul><br><p>  <strong>Desventajas</strong> </p><br><ul><li>  Este m√©todo se asemeja a un mecanismo de cadena, y en alg√∫n momento la cadena deber√≠a interrumpirse.  En otras palabras, el usuario de la clase <code>ClassA</code> debe saber todo sobre la inicializaci√≥n de <code>ClassB</code> , lo que a su vez requiere conocimiento sobre la inicializaci√≥n de <code>ClassC</code> , etc.  Entonces, ver√° que cualquier cambio en el constructor de cualquiera de estas clases puede conducir a un cambio en la clase de llamada, sin mencionar que <code>ClassA</code> puede tener m√°s de un usuario, por lo que se repetir√° la l√≥gica de crear objetos. </li><li>  A pesar de que nuestras dependencias son claras y f√°ciles de entender, el c√≥digo de usuario no es trivial y es dif√≠cil de administrar.  Por lo tanto, no todo es tan simple.  Adem√°s, el c√≥digo viola el principio de responsabilidad √∫nica, ya que es responsable no solo de su trabajo, sino tambi√©n de la implementaci√≥n de dependencias en clases dependientes. </li></ul><br><p>  El segundo m√©todo obviamente funciona mejor que el primero, pero a√∫n tiene sus defectos.  ¬øEs posible encontrar una soluci√≥n m√°s adecuada?  Antes de considerar la tercera v√≠a, hablemos primero sobre el concepto mismo de inyecci√≥n de dependencia. </p><br><h3 id="chto-takoe-vnedrenie-zavisimostey">  ¬øQu√© es la inyecci√≥n de dependencia? </h3><br><blockquote>  La inyecci√≥n de dependencias es una forma de manejar dependencias fuera de la clase dependiente cuando la clase dependiente no necesita hacer nada. </blockquote><p>  Basado en esta definici√≥n, nuestra primera soluci√≥n obviamente no usa la idea de inyecci√≥n de dependencia, y la segunda forma es que la clase dependiente no hace nada para proporcionar las dependencias.  Pero a√∫n creemos que la segunda soluci√≥n es mala.  POR QU√â? </p><br><p>  Dado que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">definici√≥n de inyecci√≥n de dependencia</a> no dice nada sobre d√≥nde deber√≠a llevarse a cabo el trabajo con dependencias (excepto fuera de la clase dependiente), el desarrollador debe elegir un lugar adecuado para la inyecci√≥n de dependencia.  Como puede ver en el segundo ejemplo, la clase de usuario no es el lugar correcto. </p><br><p>  ¬øC√≥mo hacerlo mejor?  Veamos una tercera forma de manejar dependencias. </p><br><h3 id="tretiy-sposob-pust-kto-nibud-eschyo-obrabatyvaet-zavisimosti-vmesto-nas">  Tercera forma: deje que otra persona maneje las dependencias en lugar de nosotros </h3><br><p>  Seg√∫n el primer enfoque, las clases dependientes son responsables de obtener sus propias dependencias, y en el segundo enfoque, trasladamos el procesamiento de dependencias de la clase dependiente a la clase de usuario.  Imaginemos que hay alguien m√°s que podr√≠a manejar las dependencias, como resultado de lo cual ni el dependiente ni las clases de usuario har√≠an el trabajo.  Este m√©todo le permite trabajar con dependencias en la aplicaci√≥n directamente. </p><br><blockquote>  <strong><em>Una implementaci√≥n "limpia" de inyecci√≥n de dependencia (en mi opini√≥n personal)</em></strong> <br><br>  <em>La responsabilidad del manejo de dependencias recae en un tercero, por lo que ninguna parte de la aplicaci√≥n interactuar√° con ellos.</em> </blockquote><p>  La inyecci√≥n de dependencia no es una tecnolog√≠a, un marco, una biblioteca o algo as√≠.  Esto es solo una idea.  La idea es trabajar con dependencias fuera de la clase dependiente (preferiblemente en una parte especialmente asignada).  Puede aplicar esta idea sin usar bibliotecas o marcos.  Sin embargo, generalmente recurrimos a marcos para implementar dependencias, porque simplifica el trabajo y evita escribir c√≥digo de plantilla. </p><br><p>  Cualquier marco de inyecci√≥n de dependencia tiene dos caracter√≠sticas inherentes.  Otras funciones adicionales pueden estar disponibles para usted, pero estas dos funciones siempre estar√°n presentes: </p><br><p>  En primer lugar, estos marcos ofrecen una forma de determinar los campos (objetos) que deben implementarse.  Algunos marcos hacen esto anotando un campo o constructor usando la anotaci√≥n <code>@Inject</code> , pero hay otros m√©todos.  Por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Koin</a> utiliza las funciones de lenguaje integradas de Kotlin para determinar la implementaci√≥n.  <code>Inject</code> significa que la dependencia debe ser manejada por el marco DI.  El c√≥digo se ver√° as√≠: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classB: ClassB){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classB = classB } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classC: ClassC){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classC = classC } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ } }</code> </pre> <br><p>  En segundo lugar, los marcos le permiten determinar c√≥mo proporcionar cada dependencia, y esto sucede en un archivo (s) separado (s).  Aproximadamente se ve as√≠ (tenga en cuenta que esto es solo un ejemplo, y puede diferir de un marco a otro): </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OurThirdPartyGuy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideClassC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ClassC() <span class="hljs-comment"><span class="hljs-comment">//just creating an instance of the object and return it. } fun provideClassB(classC: ClassC){ return ClassB(classC) } fun provideClassA(classB: ClassB){ return ClassA(classB) } }</span></span></code> </pre> <br><p>  Entonces, como puede ver, cada funci√≥n es responsable de procesar una dependencia.  Por lo tanto, si necesitamos usar <code>ClassA</code> en alg√∫n lugar de la aplicaci√≥n, suceder√° lo siguiente: nuestro marco DI crea una instancia de la clase <code>ClassC</code> llamando a <code>provideClassC</code> , pas√°ndola a <code>provideClassB</code> y recibiendo una instancia de <code>ClassB</code> , que se pasa a <code>provideClassA</code> , y como resultado, se crea <code>ClassA</code> .  Esto es casi m√°gico.  Ahora examinemos las ventajas y ventajas del tercer m√©todo. </p><br><p>  <strong>Los beneficios</strong> </p><br><ul><li>  Todo es lo m√°s simple posible.  Tanto la clase dependiente como la clase que proporciona las dependencias son claras y simples. </li><li>  Las clases est√°n unidas libremente y son f√°cilmente reemplazables por otras clases.  Supongamos que queremos reemplazar <code>ClassC</code> con <code>AssumeClassC</code> , que es una subclase de <code>ClassC</code> .  Para hacer esto, solo necesita cambiar el c√≥digo del proveedor de la siguiente manera, y donde <code>ClassC</code> se use <code>ClassC</code> , la nueva versi√≥n ahora se usar√° autom√°ticamente: </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideClassC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AssumeClassC() }</code> </pre> <br><p>  Tenga en cuenta que ning√∫n c√≥digo dentro de la aplicaci√≥n cambia, solo el m√©todo del proveedor.  Parece que nada podr√≠a ser a√∫n m√°s simple y m√°s flexible. </p><br><ul><li>  Incre√≠ble capacidad de prueba.  Puede reemplazar f√°cilmente las dependencias con versiones de prueba durante la prueba.  De hecho, la inyecci√≥n de dependencia es su principal ayuda cuando se trata de pruebas. </li><li>  Mejora de la estructura del c√≥digo, como  la aplicaci√≥n tiene un lugar separado para el procesamiento de dependencia.  Como resultado, el resto de la aplicaci√≥n puede enfocarse exclusivamente en sus funciones y no superponerse con dependencias. </li></ul><br><p>  <strong>Desventajas</strong> </p><br><ul><li>  Los marcos DI tienen un cierto umbral de entrada, por lo que el equipo del proyecto necesita pasar tiempo y estudiarlo antes de usarlo de manera efectiva. </li></ul><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><ul><li>  El manejo de dependencias sin DI es posible, pero puede provocar bloqueos en la aplicaci√≥n. </li><li>  DI es solo una idea efectiva, seg√∫n la cual es posible manejar dependencias fuera de la clase dependiente. </li><li>  Es m√°s efectivo usar DI en ciertas partes de la aplicaci√≥n.  Muchos marcos contribuyen a esto. </li><li>  Los marcos y las bibliotecas no son necesarios para DI, pero pueden ayudar mucho. </li></ul><br><p>  En este art√≠culo, trat√© de explicar los conceptos b√°sicos del trabajo con el concepto de inyecci√≥n de dependencia, y tambi√©n enumer√© las razones para usar esta idea.  Hay muchos m√°s recursos que puede explorar para obtener m√°s informaci√≥n sobre el uso de DI en sus propias aplicaciones.  Por ejemplo, una secci√≥n separada en la parte avanzada de nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">curso de profesi√≥n de Android est√°</a> dedicada a este tema. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es434380/">https://habr.com/ru/post/es434380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es434362/index.html">NO pronosticado para 2019</a></li>
<li><a href="../es434364/index.html">Hangfire Queue Support</a></li>
<li><a href="../es434368/index.html">Aprendizaje autom√°tico para encontrar errores en el c√≥digo: c√≥mo hice pr√°cticas en JetBrains Research</a></li>
<li><a href="../es434370/index.html">Otro conquistador de la sombra en Phaser, o el uso de bicicletas.</a></li>
<li><a href="../es434374/index.html">Comprobaci√≥n de RBAC en Kubernetes</a></li>
<li><a href="../es434382/index.html">Portar Alpine Linux a RISC-V</a></li>
<li><a href="../es434384/index.html">Sobre la responsabilidad de los artistas int√©rpretes o ejecutantes.</a></li>
<li><a href="../es434386/index.html">Douglas Engelbart: "Aumento del intelecto humano: un marco conceptual"</a></li>
<li><a href="../es434394/index.html">Bugatti Autom√≥viles prueba con √©xito la pinza de freno impresa en 3D</a></li>
<li><a href="../es434398/index.html">Vanivar Bush: "Como podemos pensar". Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>