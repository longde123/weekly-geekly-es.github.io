<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📈 🗽 👩🏻‍⚕️ 角度双向绑定，多一点理解 🎮 👩🏾‍🔬 ☔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="来自翻译  从翻译人员那里：两年前，我在Angular（2+）上开始了我的第一个项目，具有丰富而成功的AngularJS背景。 过渡需要一种明显的思维方式，因为在A1和A2 +上做的太多“有些不同”。 过渡的痛苦极大地减少了我的想法 。 一年前，我获得了翻译这篇文章的许可，“关于每个人都基本且容易理...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>角度双向绑定，多一点理解</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453696/"><div class="spoiler">  <b class="spoiler_title">来自翻译</b> <div class="spoiler_text">  <b>从翻译人员</b>那里：两年前，我在Angular（2+）上开始了我的第一个项目，具有丰富而成功的AngularJS背景。 过渡需要一种明显的思维方式，因为在A1和A2 +上做的太多“有些不同”。 过渡的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">痛苦极大</a>地减少了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">想法</a> 。 一年前，我获得了翻译这篇文章的许可，“关于每个人都基本且容易理解的”。 但是它们就是这样的手（他们的文章是一堆未完成的文章）。 令人惊讶的是，该文章在Google翻译上的翻译效果很好。 但是此翻译中的一些细微差别已丢失，更不用说作者的风格了。 在我的版本中，作者的风格尚未完全保留。 但是，我希望能够传达出本文的心情和想法。 <br><br> 我知道Angular不是哈布雷（Habré）上最受欢迎的话题，但是我希望翻译能够对某人有所帮助，就像原始文章曾经对我有所帮助一样。 <br></div></div><br> 这就是在旧版AngularJS中引起哇效果的原因，所以它是“双向绑定”。 这种魔力立即爱上了AngularJS，打破了所有有关无聊的页面编程和（令人恐惧的！）Web表单的想法。 数据更改立即显示在屏幕上，反之亦然。 那些以前开发jQuery应用程序的人将链接视为童话。 留着胡须的怪兽，在jQuery之前吸引了很多胖客户，开始疯狂地计算那些愚蠢的迷途工友。 <br><br> 而且，双向绑定的魔力不仅适用于特殊符号和选定的组件。 我们可以在我们自己的指令和组件中轻松使用它（仅通过设置配置参数即可）。 <br><br>  <b>在Angular2 +中，创建者放弃了内置的双向数据绑定</b> （通过ngModel除外）。 但这并不意味着我们不能在自己的指令中使用双向绑定...仅仅是免费赠品已经结束，现在我们需要自己做一些事情。 并且，最好是了解它在Angular中的工作方式。 <br><a name="habracut"></a><br><h3> 目录 </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">双向绑定</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了解ngModel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">创建自己的双向数据绑定</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结论</a> </li></ul><br><a name="in2word"></a><h3> 双向绑定 </h3><br> 在A2 +中，只有一个指令可实现双向数据绑定： <b>ngModel</b> 。 乍一看，这与AngularJS中的魔术相同（只是用不同的表示法）。 但是到底是什么呢？ <br><br> 令人惊讶的是，在幕后，一切都相对简单且合乎逻辑：双向绑定简化为属性绑定和事件绑定。 是两个单边绑定，而不是一个双边绑定？ 好，我们两个。 <br><br> 并立即举一个例子： <br><br><pre><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> [(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModel</span></span></span><span class="hljs-tag">)]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {{username}}!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 是的，是的，这是2009年的一个美丽而令人惊叹的Angular2演示。 不开玩笑，美丽。 更改字段时， <b>用户名</b>值将落入模型中，并立即反映在表单上的欢迎消息中。 <br><br> 但是它是如何工作的呢？ 回想一下，Angular2中的双向绑定是属性绑定和事件绑定。 是的，它们可以在一个指令中同时可用。 而且，即使没有<b>ngModel</b> ，我们也可以轻松实现双向数据绑定。 例如，像这样： <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">input</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username = $event.target.value"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {{username}}!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br> 输出<b>{{username}}很</b>清楚，但是<b>输入中</b>写了什么？ 让我们了解一下： <br><br><ul><li>  <b>[value] =“用户名”</b> -用方括号表示，将用户名表达式与value属性相关联 </li><li>  <b>（input）=“ expression”</b> -带括号的表示法，该表达式附加到<b>输入</b>事件（是的，有这样的事件）。 在我们的情况下： <br><ul><li>  <b>username = $ event.target.value-</b>该表达式将响应输入事件而执行 </li><li>  <b>$ event</b>是Angular事件中的一个合成变量，带有一个有效负载：在这种情况下，它包含有关发生的情况及其周围环境的信息 </li></ul></li></ul><br> 越来越清楚了吗？ 我们修复它。 <br><br> 我们将Angular模型的<b>username</b>属性绑定到浏览器输入元素的<b>value</b>属性（从模型到视图的单向绑定）。 <br><br> 我们还将表达式绑定到元素的<b>输入</b>事件。 它将<b>$ event.target.value</b>的值分配给模型的<b>username</b>属性。 <br><br> 什么是<b>$ event.target.value</b> ？ 如前所述， <b>$ event</b>充满了有关该事件的各种有用信息。 在这种情况下，它是一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">InputEventObject</a> ，其中<b>target</b>属性引用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">触发</a>事件的DOM元素（即我们的input元素）。 <br><br> 因此，我们基本上要做的就是在用户输入值时读取输入元素（ <b>$ event.target</b> ）的内容（ <b>值</b> ）。 当我们分配该用户名值时，视图数据将发送到模型。 <br><br>  <b>仅此而已。</b>  <b>这是“简而言之双向绑定”。</b> 美丽吗 <br><br> 但是<b>ngModel</b>什么时候起作用？ 使用输入元素的场景非常普遍并且需求很大。 出于某种原因，我想拥有一个隐藏实现并从额外的击键中省下来的指令。 <br><br><a name="ngModel"></a><h3> 了解ngModel </h3><br> 如果您查看源代码，则可以确保<b>ngModel</b>也具有对属性和事件的绑定。 这是我们的ngModel示例的样子，但是没有使用速记语法： <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModel</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModelChange</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username = $event"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {{username}}!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 几乎所有事物都是一样的。  <b>[ngModel]属性</b>的绑定负责更新输入元素的值。 事件绑定<b>（ngModelChange）</b>通知世界DOM中正在发生更改。 <br><br> 并且您注意到处理程序表达式仅使用<b>$ event</b> ，而不使用<b>$ event.target.value</b> 。 这有什么问题吗？ 一点也不。 如上所述， <b>$ event</b>是一个携带<b>有效载荷</b>的综合变量。  Angular会决定哪些内容有用。 换句话说， <b>ngModelChange</b>负责从内部<b>$事件</b>中提取<b>target.value</b> ，并且仅提供我们想要的内容，而无需包装和手鼓。 从技术上讲，这些是<a href="">DefaultValueAccessor的对象</a> ：正是他提取数据并将其传输到基本DOM对象，尽管...您根本无法考虑它）。 <br><br> 最后但并非最不重要的一点是，由于两次写入<b>用户名</b>和<b>ngModel</b>仍然是多余的，因此Angular允许使用缩写语法<b>[[]]</b> ，也称为“盒子里的香蕉”。 这与前面的示例相似，并从本节的开头使我们返回到该示例，但对<b>ngModel</b>实现<b>有所</b>了解。 提供相同的双向绑定。 <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> [(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModel</span></span></span><span class="hljs-tag">)]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {{username}}!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><a name="bindings"></a><br><h3> 创建自己的双向数据绑定 </h3><br> 现在我们足够了解创建自己的双向数据绑定。 您需要做的只是遵循与<b>ngModel</b>相同的规则，即： <br><br><ul><li> 输入属性绑定（例如： <b>[foo]</b> ） </li><li> 绑定到具有相同名称和后缀<b>Change</b>的事件（例如： <b>（fooChange）</b> ） </li><li> 确保事件绑定负责检索属性（如有必要） </li></ul><br> 注意，创建双向数据绑定比AngularJS需要更多的工作吗？ 如果我们尝试尽可能使用自己的双向绑定，这可能会使我们非常沮丧。 在现实生活中，您应该始终考虑我们是否需要双向绑定，如果有必要，利用ngModel是否更容易。 例如，后者在创建<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自定义表单控件时发生</a> 。 <br><br> 但是，假设我们创建了一个自定义计数器组件（并且不想使用自定义表单控件）。 <br><br><pre> <code class="javascript hljs">@Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'custom-counter'</span></span>, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">` &lt;button (click)="decrement()"&gt;-&lt;/button&gt; &lt;span&gt;{{counter}}&lt;/span&gt; &lt;button (click)="increment()"&gt;+&lt;/button&gt; `</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomCounterComponent</span></span></span><span class="hljs-class"> </span></span>{ counterValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; get counter() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue; } set counter(value) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue = value; } decrement() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter--; } increment() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter++; } }</code> </pre><br> 我们具有<b>计数器</b>组件的属性以显示<b>计数器</b>的当前值。 要为它提供双向绑定，首先要做的是将其转换为<b>Input</b>参数。 为此， <b>@Input（）</b>装饰器非常有用： <br><br><pre> <code class="javascript hljs">@Component() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomCounterComponent</span></span></span><span class="hljs-class"> </span></span>{ counterValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; @Input() get counter() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue; } ... }</code> </pre><br> 这已经允许您将组件属性绑定到使用者，如下所示： <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-counter</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">counter</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"someValue"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-counter</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br> 现在我们需要将<b>@Output（）</b>事件设置为相同的名称（ <b>counter</b> ）和后缀<b>Change</b> （原来是counterChange）。 每当<b>计数器</b>更改时，我们都希望引发此事件。 为什么要添加<b>@Output（）</b>属性。 然后，我们在几个getter中完成了计数器设置器，在该方法中，我们将拦截值的更改，并使用当前计数器值抛出事件： <br><br><pre> <code class="javascript hljs">@Component() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomCounterComponent</span></span></span><span class="hljs-class"> </span></span>{ ... @Output() counterChange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter(); set counter(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue = val; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterChange.emit(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue); } ... }</code> </pre><br> 就是这个！ 现在，我们可以使用双向数据绑定语法将表达式绑定到此属性： <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-counter</span></span></span><span class="hljs-tag"> [(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">counter</span></span></span><span class="hljs-tag">)]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"someValue"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-counter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>counterValue = {{someValue}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br> 查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演示</a>并尝试！ <br><br> 同样，请记住，最好使用自定义窗体控件来实现诸如自定义计数器之类的组件，并利用<b>ngModel</b>来实现双向数据绑定，如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文所述</a> 。 <br><br><a name="conclusion"></a><h3> 结论 </h3><br>  Angular不再带有内置的双向数据绑定。 相反，框中有一些API，可让您将完全绑定作为绑定属性和事件来实现。 <br><br>  <b>ngModel在FormsModule</b>中作为内置的双向绑定指令来提供（请记住将其添加到<b>@NgModule</b>声明的<b>imports</b>部分：大约。）。 创建用作自定义表单控件的组件时，应首选通过ngModel进行链接。 否则，一切都取决于您的想象力。 <br><br>  <b>译者的PS：</b> <i>A2 +中的绑定实现变得更加现代。</i>  <i>现在，几乎“免费的”设置器通常被“风水”用来监视更改（尽管很明显，脏检查的机制仍然存在，至少对于高级用户组件而言）。</i>  <i>这样就可以放弃100,500个观察者（用于监视“其”数据中的更改的过程）。</i>  <i>A1中的哪个喜欢在浏览器上造成恶意负载，并且在计划丰富的交互式页面时需要异常直接的帮助。</i> <i><br><br></i>  <i>通过正确设计的组件，开箱即用的A2响应速度大大提高。</i>  <i>让我们以牺牲程序员的工作为代价。</i>  <i>现在，您可以在页面上放置大量组件，而不必担心处理器资源。</i> <i><br><br></i>  <i>硬币的另一面是A2 +中“输入过程”的初始成本，这影响了框架的普及。</i>  <i>但是A1的进入成本也很高，只是降级到了大联盟。</i>  <i>由于缺乏对如何组织大型应用程序的了解，许多原型在A1上“起飞”，然后“崩溃”并对应于React和Vue。</i> <i><br><br></i>  <i>我希望通过这篇文章，我将有助于稍微降低A2 +首次进入的门槛，而A2 +仍然仍然是需求（我是第一手知道的）。</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN453696/">https://habr.com/ru/post/zh-CN453696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN453682/index.html">为Redd中安装的FPGA开发最简单的“固件”。 第2部分。程序代码</a></li>
<li><a href="../zh-CN453686/index.html">安全周22：威胁统计信息，银行木马和流行漏洞</a></li>
<li><a href="../zh-CN453688/index.html">Java不仅是血腥的企业，而且还是对延迟敏感的快速应用程序</a></li>
<li><a href="../zh-CN453692/index.html">初学者3D游戏着色器：效果</a></li>
<li><a href="../zh-CN453694/index.html">像在Linux中一样通过SSH连接到Windows</a></li>
<li><a href="../zh-CN453698/index.html">量子意识中的量子信息</a></li>
<li><a href="../zh-CN453700/index.html">有关SDL 2的课程：第1课-您好，SDL 2</a></li>
<li><a href="../zh-CN453706/index.html">我如何通过Google Cloud Professional数据工程师认证考试</a></li>
<li><a href="../zh-CN453708/index.html">在BASCOM AVR环境中用于MK AVR的AQUA RTOS实时操作系统</a></li>
<li><a href="../zh-CN453710/index.html">大型项目的开发实践：mitp SberPractice iOS＃1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>