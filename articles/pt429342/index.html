<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔒 👨🏼‍✈️ 💪🏼 Angular 6+ é um guia completo de injeção de dependência. fornecida em vs provedores: [] 👩🏽‍⚖️ 👰🏾 🦕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Angular 6 introduziu uma nova sintaxe aprimorada para incorporar dependências de serviço em um aplicativo ( allowIn ). Apesar do fato de o Angular 7...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angular 6+ é um guia completo de injeção de dependência. fornecida em vs provedores: []</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429342/"><img src="https://habrastorage.org/getpro/habr/post_images/878/6df/25a/8786df25a4fd4d9b0699cabbfc8dcaec.jpg" alt="imagem"><br><br>  O Angular 6 introduziu uma nova sintaxe aprimorada para incorporar dependências de serviço em um aplicativo ( <b>allowIn</b> ).  Apesar do fato de o Angular 7 já ter sido lançado, esse tópico ainda é relevante.  <b>Há muita confusão nos comentários do GitHub, Slack e Stack Overflow, então vamos dar uma olhada mais de perto neste tópico.</b> <b><br></b> <br><h3>  Neste artigo, consideraremos: </h3><br><ol><li>  <b>Injeção de dependência</b> </li><li>  Maneira antiga de injetar dependências no Angular ( <b>provedores: []</b> ); </li><li>  Uma nova maneira de injetar dependências no Angular ( <b>fornecido em: 'root' | SomeModule</b> ); </li><li>  <b>Os</b> cenários <b>UseIn fornecem</b> ; </li><li>  Recomendações para usar a nova sintaxe em aplicativos; </li><li>  Para resumir. </li></ol><a name="habracut"></a><br><h3>  Injeção de Dependência </h3><br>  Você pode pular esta seção se já tiver uma idéia sobre o <b>DI</b> . <br><blockquote>  A <b>injeção de</b> dependência ( <b>DI</b> ) é uma maneira de criar objetos que dependem de outros objetos.  O sistema de injeção de dependência fornece objetos dependentes quando instancia uma classe. <br><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Documentação angular</a> </blockquote><br>  Explicações formais são boas, mas vamos dar uma olhada no que é injeção de dependência. <br><br>  Todos os componentes e serviços são classes.  Cada classe possui um método <b>construtor</b> especial, que, quando chamado, cria um objeto de instância dessa classe, que é usado no aplicativo. <br><br>  Suponha que em um de nossos serviços haja o seguinte código: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private http: HttpClient)</code> </pre> <br>  Se você o criar sem usar o mecanismo de injeção de dependência, deverá adicionar o <b>HttpClient</b> manualmente.  Em seguida, o código ficará assim: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyService(httpClient)</code> </pre> <br>  Mas onde, neste caso, para obter <b>httpClient</b> ?  Também precisa ser criado: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(httpHandler)</code> </pre> <br>  Mas onde obter o <b>httpHandler</b> agora?  E assim por diante, até que todas as classes necessárias sejam instanciadas.  Como podemos ver, a criação manual pode ser complicada e erros podem ocorrer no processo. <br><br>  <b>O mecanismo de injeção de dependência angular faz tudo isso automaticamente.</b>  <b>Tudo o que precisamos fazer é especificar as dependências no construtor do componente e elas serão adicionadas sem nenhum esforço de nossa parte.</b> <br><br><h3>  Maneira antiga de injetar dependências no Angular (provedores: []) </h3><br>  Para executar o aplicativo, o Angular precisa conhecer cada objeto individual que queremos implementar em componentes e serviços.  Antes do lançamento do Angular 6, a única maneira de fazer isso era especificar os serviços na propriedade de <b>provedores: []</b> decoradores <b>@NgModule</b> , <b>@</b> <b>omponent</b> e <b>@Directive</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f6c/3a7/433/f6c3a7433a1f72dc45b9e9cd2b5edc18.png" alt="imagem"><br><br>  Aqui estão três principais usos dos <b>provedores: []</b> : <br><br><ol><li>  No decorador <b>@NgModule</b> do módulo imediatamente carregado ( <b>ansioso</b> ); </li><li>  No decorador <b>@NgModule</b> do módulo de carregamento atrasado ( <b>lento</b> ); </li><li>  Nos decoradores <b>@Component</b> e <b>@Directive</b> . </li></ol><br><h4>  Módulos baixados com o aplicativo (Eager) </h4><br>  Nesse caso, o serviço é registrado no escopo global como singleton.  Será um singleton, mesmo se incluído nos <b>provedores [] de</b> vários módulos.  É criada uma única instância da classe de serviço que será registrada no nível raiz do aplicativo. <br><br><h4>  Módulos de Carga Diferida (Preguiçoso) </h4><br>  Uma instância do serviço conectado ao módulo <b>lento</b> será criada durante sua inicialização.  Adicionar um serviço desse tipo ao componente <b>ansioso</b> do módulo resultará em um erro: <b>Nenhum provedor para MyService!</b>  <b>erro</b> . <br><br><h4>  Implementação em @ Component e @ Directiva </h4><br>  Quando implementada em um componente ou diretiva, é criada uma instância separada do serviço, que estará disponível neste componente e em todos os filhos.  <b>Nessa situação, o serviço não será um singleton, sua instância será criada sempre que o componente for usado e excluído, juntamente com a remoção do componente do DOM.</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b0/4fc/6a9/6b04fc6a974ad8278ba910524a3e062e.png" alt="imagem"><br><br>  Nesse caso, o <b>RandomService</b> não <b>é</b> implementado no nível do módulo e não é um singleton, <br>  mas registrado com <b>provedores: []</b> do componente <b>RandomComponent</b> .  Como resultado, obteremos um novo número aleatório sempre que usarmos <b>&lt;rand®m&gt; &lt;/ rand®m&gt;</b> . <br><br><h3>  Nova maneira de injetar dependências no Angular (fornecido em: 'root' | SomeModule) </h3><br>  No Angular 6, obtivemos uma nova ferramenta <b>"Provedores</b> que podem ser <b>sacudidos em árvore"</b> para <b>injetar</b> dependências em um aplicativo, que pode ser usado usando a propriedade <b>fornecidaIn</b> do decorador <b>@Injectable</b> . <br><br>  <b>Você pode imaginar <b>fornecido</b> como a implementação de dependências na direção oposta: antes que o módulo descrevesse os serviços nos quais será conectado, agora o serviço define o módulo ao qual está conectado.</b> <br><br>  O serviço pode ser incorporado na raiz do aplicativo ( <b>fornecidoIn: 'root'</b> ) ou em qualquer módulo ( <b>fornecidoIn: SomeModule</b> ).  <b>fornecidoIn: 'root'</b> é uma abreviação para implementação no <b>AppModule</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c41/57a/fa6/c4157afa6304838f407ab76f4665aaa8.png" alt="imagem"><br><br>  Vamos analisar os principais cenários para usar a nova sintaxe: <br><br><ol><li>  Implementação no módulo raiz do aplicativo ( <b>fornecido em: 'raiz'</b> ); </li><li>  Implementação no módulo imediatamente carregado ( <b>ansioso</b> ); </li><li>  Implementação no módulo com carregamento atrasado ( <b>lento</b> ). </li></ol><br><h4>  Implementação no módulo raiz do aplicativo (fornecido em: 'root') </h4><br>  Esta é a opção de injeção de dependência mais comum.  Nesse caso, o serviço será adicionado ao aplicativo de pacote configurável apenas se for realmente usado, ou seja,  incorporado em um componente ou outro serviço. <br><br>  Ao usar a nova abordagem, não haverá muita diferença em um aplicativo SPA monolítico, onde todos os serviços escritos são usados, no entanto, <b>desde que</b> In <b>: 'root'</b> seja útil ao escrever bibliotecas. <br><br>  Anteriormente, todos os serviços de biblioteca precisavam ser adicionados aos <b>provedores: [] de</b> seu módulo.  Após importar a biblioteca para o aplicativo, todos os serviços foram adicionados ao pacote, mesmo que apenas um fosse usado.  No caso de <b>allowedIn: 'root',</b> não há necessidade de conectar o módulo da biblioteca.  Basta incorporar o serviço no componente desejado. <br><br><h4>  Módulo de carregamento atrasado (lento) e fornecidoIn: 'root' </h4><br>  O que acontece se você implementar o serviço com o item <b>fornecido: raiz</b> no módulo <b>lento</b> ? <br><br>  Tecnicamente, <b>'root'</b> significa <b>AppModule</b> , mas Angular é inteligente o suficiente para adicionar um serviço ao pacote <b>lento</b> de um módulo se ele for implementado apenas em seus componentes e serviços.  Mas há um problema (embora algumas pessoas afirmem que esse é um recurso).  Se posteriormente você introduzir o serviço usado apenas no módulo <b>lento</b> no módulo principal, o serviço será transferido para o pacote principal.  Em aplicativos grandes com muitos módulos e serviços, isso pode levar a problemas de rastreamento de dependência e comportamento imprevisível. <br><br>  <b>Cuidado!</b>  <b>A implementação de um serviço em vários módulos pode levar a dependências ocultas difíceis de entender e impossíveis de desvendar.</b> <br><br>  Felizmente, existem maneiras de evitar isso, e as consideraremos abaixo. <br><br><h3>  Injeção de dependência no módulo imediatamente carregado (ansioso) </h3><br>  Como regra geral, este caso não faz sentido e, em vez disso, podemos usar a opção <b>fornecido em: 'root'</b> .  A conexão de um serviço no <b>EagerModule</b> pode ser usada para encapsulamento e impedirá a implementação sem a conexão de um módulo, mas na maioria dos casos isso não é necessário. <br><br>  Se você realmente precisar limitar o escopo do serviço, é mais fácil usar o antigo <b>provedor: []</b> , pois certamente não levará a dependências cíclicas. <br><br>  <b>Se possível, tente usar o método fornecido em: 'root' em todos os módulos ansiosos.</b> <br><br><h4>  Nota  A vantagem dos módulos de carregamento atrasado (lento) </h4><br>  Uma das principais características do Angular é a capacidade de dividir facilmente o aplicativo em fragmentos, o que oferece as seguintes vantagens: <br><br><ol><li>  O tamanho pequeno do pacote principal do aplicativo, devido ao qual o aplicativo é carregado e iniciado mais rapidamente; </li><li>  O módulo de carregamento atrasado está bem isolado e é conectado ao aplicativo uma vez na propriedade <b>loadChildren</b> da rota correspondente. </li></ol><br>  <b>Graças ao atraso no carregamento, um módulo inteiro com centenas de serviços e componentes pode ser removido ou movido para um aplicativo ou biblioteca separado, com pouco ou nenhum esforço.</b> <br><br>  Outra vantagem do isolamento do módulo <b>lento</b> é que um erro cometido nele não afetará o restante do aplicativo.  Agora você pode dormir em paz, mesmo no dia do lançamento. <br><br><h3>  Implementação em um módulo com carregamento atrasado (fornecido em: LazyModule) </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/6ce/a76/ebd/6cea76ebda5a5fe9190c79554065f399.png" alt="imagem"><br><br>  A injeção de dependência em um módulo específico impede o uso do serviço em outras partes do aplicativo.  Isso preserva a estrutura de dependência, que é especialmente útil para aplicativos grandes em que a injeção de dependência desarrumada pode causar confusão. <br><br>  <b>Fato interessante: Se você implementar o serviço lento na parte principal do aplicativo, o assembly (mesmo AOT) falhará sem erros, mas o aplicativo falhará com o erro "Nenhum provedor para LazyService".</b> <br><br><h4>  O problema com dependência cíclica </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/789/f3d/551/789f3d551cca5651454027e49a1513c3.png" alt="imagem"><br><br>  Você pode reproduzir o erro da seguinte maneira: <br><br><ol><li>  Crie o módulo <b>LazyModule</b> ; </li><li>  Criamos o serviço <b>LazyService</b> e nos conectamos usando <b>fornecidoIn: LazyModule</b> ; </li><li>  Criamos o componente <b>LazyComponent</b> e o conectamos ao <b>LazyModule</b> ; </li><li>  Adicione <b>LazyService</b> ao construtor do componente <b>LazyComponent</b> ; </li><li>  Temos um erro com uma dependência cíclica. </li></ol><br>  Esquematicamente, fica assim: <b>service -&gt; module -&gt; component -&gt; service</b> . <br><br>  Você pode resolver esse problema criando um submódulo <b>LazyServiceModule</b> , que será conectado ao <b>LazyModule</b> .  Conecte serviços ao submódulo. <br><img src="https://habrastorage.org/getpro/habr/post_images/c9c/da3/bae/c9cda3bae241d0c3e748ca16007ed816.jpg" alt="imagem"><br><br>  Nesse caso, você precisará criar um módulo adicional, mas ele não exigirá muito esforço e dará as seguintes vantagens: <br><br><ol><li>  Isso impedirá a introdução do serviço em outros módulos de aplicativos; </li><li>  Um serviço será incluído no pacote configurável apenas se estiver incorporado em um componente ou outro serviço usado no módulo. </li></ol><br><h4>  Incorporando um serviço em um componente (fornecido em: SomeComponent) </h4><br>  É possível incorporar um serviço no <b>@Component</b> ou no <b>@Directive</b> usando a nova sintaxe? <br><br>  <b>Não no momento!</b> <br><br>  Para criar uma instância do serviço para cada componente, você ainda precisa usar <b>provedores: []</b> nos <b>decoradores</b> <b>@</b> <b>omponent</b> ou <b>@Directive</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46b/56b/6af/46b56b6af20ae67ffe30cff15fc0eb47.png" alt="imagem"><br><br><h3>  Práticas recomendadas para o uso de nova sintaxe em aplicativos </h3><br><h4>  Bibliotecas </h4><br>  <b>allowedIn: 'root'</b> é bom para criar bibliotecas.  Essa é uma maneira realmente conveniente de conectar apenas a parte da funcionalidade usada diretamente ao aplicativo principal e reduzir o tamanho da montagem final. <br><br>  <b>Um exemplo prático é a biblioteca do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modelo ngx</a> , que foi reescrita usando a nova sintaxe e agora é chamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ angular-extensions / model</a> .</b>  <b>Na nova implementação, não há necessidade de conectar o NgxModelModule ao aplicativo, basta incorporar o ModelFactory no componente necessário.</b>  <b>Detalhes da implementação podem ser encontrados <a href="">aqui</a> .</b> <br><br><h4>  Módulos de Download Adiado (lento) </h4><br>  Use o módulo separado <b>fornecido em: LazyServicesModule</b> para serviços e conecte-o ao <b>LazyModule</b> .  Essa abordagem encapsula serviços e evita que eles sejam conectados a outros módulos.  Isso definirá limites e ajudará a criar uma arquitetura escalável. <br><br>  <b>De acordo com minha experiência, a introdução acidental no módulo principal ou adicional (usando o método fornecidoIn: 'root') pode causar confusão e não é a melhor solução!</b> <br><br>  <b>fornecido no: 'root'</b> também funcionará corretamente, mas ao usar o <b>fornecido no LazyServideModule</b> , obtemos um erro de <b>"provedor ausente"</b> quando implementado em outros módulos e podemos corrigir a arquitetura.  <b>Mova o serviço para um local mais apropriado na parte principal do aplicativo.</b> <br><br><h4>  Quando os provedores devem ser usados: []? </h4><br>  Nos casos em que é necessário configurar o módulo.  Por exemplo, conecte o serviço apenas a <b>SomeModule.forRoot (someConfig)</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fe3/244/6e1/fe32446e118077fc5fb5839bb32c7501.png" alt="imagem"><br><br>  <b>Por outro lado, nessa situação, você pode usar a opção fornecido em: 'root'.</b>  <b>Isso garantirá que o serviço seja adicionado ao aplicativo apenas uma vez.</b> <br><br><h3>  Conclusões </h3><br><ol><li>  Use a opção <b>allowedIn: 'root'</b> para registrar o serviço como um singleton, disponível em todo o aplicativo. </li><li>  Para o módulo incluído no pacote principal, use <b>fornecidoIn: 'root'</b> , não <b>fornecidoIn: EagerlyImportedModule</b> .  Em casos excepcionais, use <b>provedores: []</b> para encapsulamento. </li><li>  Crie um submódulo com serviços para limitar seu escopo <b>fornecido em: LazyServiceModule</b> ao usar carregamento <b>lento</b> . </li><li>  Conecte o módulo <b>LazyServiceModule</b> ao <b>LazyModule</b> para evitar dependência circular. </li><li>  Use <b>provedores: []</b> nos <b>decoradores</b> <b>@</b> <b>omponent</b> e <b>@Directive</b> para criar uma nova instância de serviço para cada nova instância de componente.  Uma instância de serviço também estará disponível em todos os componentes filhos. </li><li>  Sempre limite o escopo das dependências para melhorar a arquitetura e evitar dependências confusas. </li></ol><br><h3>  Referências </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo original</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Angular é uma comunidade de língua russa.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Meetups de Angular em Rússia</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt429342/">https://habr.com/ru/post/pt429342/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt429328/index.html">Módulo de software para digitalização de documentos danificados</a></li>
<li><a href="../pt429330/index.html">Mitos e lendas do Agile - dos faraós até os dias atuais</a></li>
<li><a href="../pt429336/index.html">Comunicação entre driver e dispositivo pelo método _HID ACPI usando o GPIO do controlador Lynxpoint como exemplo</a></li>
<li><a href="../pt429338/index.html">Armazenamento Android: Interno, Externo, Removível. Parte 1/3</a></li>
<li><a href="../pt429340/index.html">Pense duas vezes antes de usar o Helm.</a></li>
<li><a href="../pt429344/index.html">Leitura de fim de semana: Recursos de ajuste de áudio e design de alto-falante</a></li>
<li><a href="../pt429346/index.html">Para o programa de mestrado sem exames: uma nova direção "Big Data" nas Olimpíadas "Eu sou um Profissional"</a></li>
<li><a href="../pt429348/index.html">Por que no futuro o Agile não será necessário</a></li>
<li><a href="../pt429350/index.html">Mercado de cabeamento e cablagem de energia eólica offshore atinge £ 14 bilhões</a></li>
<li><a href="../pt429356/index.html">Gerenciamento de riscos - por que os procedimentos são tão raros?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>