<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆕 💌 👩🏾‍🚀 我踩过的9台Elasticsearch耙 🎞️ 👍🏻 🎐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="“训练有素的人也正在踩耙。 
 但另一方面，笔在哪里。” 

 Elasticsearch是一个很棒的工具，但是每个工具不仅需要调整和维护 ，还需要注意细节。 有些微不足道，躺在地上，而另一些则隐藏得如此之深，以至于需要超过一天的时间进行搜索，而不是十几杯咖啡和一公里的神经。 在本文中，我将向您介绍...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我踩过的9台Elasticsearch耙</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yamoney/blog/419041/"><img src="https://habrastorage.org/webt/ap/2k/jc/ap2kjcsehhaliahrmgg6a3r27xw.jpeg" alt="安东·古迪姆的插图"><br><br><br>  <i>“训练有素的人也正在踩耙。</i> <i><br></i>  <i>但另一方面，笔在哪里。”</i> <br><br>  Elasticsearch是一个很棒的工具，但是每个工具不仅需要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调整</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">维护</a> ，还需要注意细节。 有些微不足道，躺在地上，而另一些则隐藏得如此之深，以至于需要超过一天的时间进行搜索，而不是十几杯咖啡和一公里的神经。 在本文中，我将向您介绍我踩踏的弹性设置中的九种出色的耙子。 <br><a name="habracut"></a><br> 我将按照证据的降序排列耙。 从在生产状态下建立并进入集群的阶段可以预见和规避的那些，到带来最多体验（和眼睛中的星星）的非常奇怪的那些。 <br><br><h2> 数据节点必须相同 </h2><br>  “集群正在以最慢的数据节点的速度运行”-一个痛苦的公理。 但是还有一个与性能无关的明显点：弹性器不考虑磁盘空间，而是考虑分片，并尝试在数据节点之间平均分配它们。 如果某些数据节点比其他数据节点有更多的空间，那么闲置将毫无用处。 <br><br><h2> 弃用日志 </h2><br> 可能发生的情况是，有人没有使用最现代的方式将数据发送到弹性模块，从而无法在执行查询时设置Content-Type。 在此列表中，例如heka，或日志通过内置方式离开设备时）。 在这种情况下，不建议使用。 日志开始以惊人的速度增长，并且对于每个请求，其中都会显示以下几行： <br><br><pre><code class="hljs markdown">[<span class="hljs-string"><span class="hljs-string">2018-07-07T14:10:26,659</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">WARN </span></span>][<span class="hljs-string"><span class="hljs-string">oedrRestController</span></span>] Content type detection for rest requests is deprecated. Specify the content type using the [<span class="hljs-string"><span class="hljs-string">Content-Type</span></span>] header. [<span class="hljs-string"><span class="hljs-string">2018-07-07T14:10:26,670</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">WARN </span></span>][<span class="hljs-string"><span class="hljs-string">oedrRestController</span></span>] Content type detection for rest requests is deprecated. Specify the content type using the [<span class="hljs-string"><span class="hljs-string">Content-Type</span></span>] header. [<span class="hljs-string"><span class="hljs-string">2018-07-07T14:10:26,671</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">WARN </span></span>][<span class="hljs-string"><span class="hljs-string">oedrRestController</span></span>] Content type detection for rest requests is deprecated. Specify the content type using the [<span class="hljs-string"><span class="hljs-string">Content-Type</span></span>] header. [<span class="hljs-string"><span class="hljs-string">2018-07-07T14:10:26,673</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">WARN </span></span>][<span class="hljs-string"><span class="hljs-string">oedrRestController</span></span>] Content type detection for rest requests is deprecated. Specify the content type using the [<span class="hljs-string"><span class="hljs-string">Content-Type</span></span>] header. [<span class="hljs-string"><span class="hljs-string">2018-07-07T14:10:26,677</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">WARN </span></span>][<span class="hljs-string"><span class="hljs-string">oedrRestController </span></span>] Content type detection for rest requests is deprecated. Specify the content type using the [Content-Type] header.</code> </pre> <br> 平均而言，每5到10毫秒发送一次请求-每次将新行添加到日志中。 这会对磁盘子系统的性能产生负面影响，并增加iowait。 可以关闭Deprecation.log，但这不是太合理。 为了将弹性日志收集到其中，而不收集垃圾，我仅禁用了oedrRestController类的日志。 <br><br> 为此，将以下构造添加到logs4j2.properties： <br><br><pre> <code class="hljs pgsql">logger.restcontroller.name = org.elasticsearch.deprecation.rest.RestController logger.restcontroller.<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> = error</code> </pre><br> 它将把此类的日志提高到错误级别，并且它们将不再属于deprecation.log。 <br><br><h2>  .kibana </h2><br> 典型的群集安装过程是什么样的？ 我们放置节点，将它们组合成一个集群，放置x-pack（需要它的人），当然还有Kibana。 我们开始，确认一切正常，并且Kibana看到了集群，然后继续进行配置。 问题在于，在新安装的群集上，默认模板如下所示： <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"default"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"order"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"template"</span></span>: <span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"settings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"number_of_shards"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"number_of_replicas"</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"mappings"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"aliases"</span></span>: {} }</code> </pre> <br> 存储所有设置的.kibana索引在一个副本中创建。 <br><br> 曾经有一种情况，由于硬件故障，群集中的一个数据节点被杀死。 它很快进入一致状态，从相邻的数据节点中产生了该碎片的副本，但是幸运的是，唯一具有.kibana索引的碎片位于此数据节点上。 情况陷入僵局-集群处于活动状态，处于工作状态，Kibana处于红色状态，而我的电话因迫切需要其日志的员工的电话而被撕毁。 <br><br> 所有这些都可以简单地解决。 到目前为止，什么都没有下降： <br><br><pre> <code class="hljs objectivec">XPUT .kibana/_settings { <span class="hljs-string"><span class="hljs-string">"index"</span></span>: { <span class="hljs-string"><span class="hljs-string">"number_of_replicas"</span></span>: <span class="hljs-string"><span class="hljs-string">"&lt;__&gt;"</span></span> } }</code> </pre> <br><h2>  XMX / XMS </h2><br> 该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a>说“不超过32 GB”，这是正确的。 但这是正确的，您不需要在服务设置中进行安装 <br><pre> <code class="hljs powershell"><span class="hljs-literal"><span class="hljs-literal">-Xms32g</span></span> <span class="hljs-literal"><span class="hljs-literal">-Xmx32g</span></span></code> </pre> <br> 因为它已经超过32 GB，所以在这里我们遇到了一个有趣的Java处理内存细微差别。 超过一定限制后，Java将停止使用压缩指针，并开始不合理地消耗大量内存。 检查压缩的指针是否使用运行Elasticsearch的Java机器非常简单。 我们在服务日志中查看： <br><br><pre> <code class="hljs powershell">[<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">07</span></span>-<span class="hljs-number"><span class="hljs-number">29</span></span><span class="hljs-type"><span class="hljs-type">T15</span></span>:<span class="hljs-number"><span class="hljs-number">04</span></span>:<span class="hljs-number"><span class="hljs-number">22</span></span>,<span class="hljs-number"><span class="hljs-number">041</span></span>][<span class="hljs-type"><span class="hljs-type">INFO</span></span>][<span class="hljs-type"><span class="hljs-type">oeeNodeEnvironment</span></span>][<span class="hljs-type"><span class="hljs-type">log</span></span>-<span class="hljs-type"><span class="hljs-type">elastic</span></span>-<span class="hljs-type"><span class="hljs-type">hot3</span></span>] heap size [<span class="hljs-number"><span class="hljs-number">31.6</span></span><span class="hljs-type"><span class="hljs-type">gb</span></span>], compressed ordinary object pointers [<span class="hljs-type"><span class="hljs-type">true</span></span>]</code> </pre> <br> 不应超过的内存量尤其取决于所使用的Java版本。 要计算您所需要的确切体积，请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a> 。 <br><br> 现在我已经在弹性的所有数据节点上安装了： <br><br><pre> <code class="hljs powershell"><span class="hljs-literal"><span class="hljs-literal">-Xms32766m</span></span> <span class="hljs-literal"><span class="hljs-literal">-Xmx32766m</span></span></code> </pre> <br> 这似乎是一个平庸的事实，并且文档描述得很好，但是我经常遇到我错过了这一点的Elasticsearch安装，并且Xms / Xmx设置为32g。 <br><br><h2>  / var / lib / elasticsearch </h2><br> 这是在Elasticsearch中存储数据的默认路径。  yml： <br><br><pre> <code class="hljs kotlin">path.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/elasticsearch</code> </pre> <br> 我通常在那里安装一个大型RAID阵列，这就是为什么：我们为ES指定几种存储数据的方式，例如： <br><br><pre> <code class="hljs kotlin">path.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/elasticsearch/data1, /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/elasticsearch/data2</code> </pre> <br> 在data1和data2中安装了不同的磁盘或RAID阵列。 但是弹性不会平衡，并且不会在这些路径之间分配负载。 首先，他填写了一个部分，然后开始写另一个部分，因此存储上的负载将不均衡。 知道了这一点，我做出了明确的决定-将RAID0 / 1中的所有磁盘组合在一起，并将其安装在path.data中指定的路径中。 <br><br><h2>  available_processors </h2><br> 不，我不是说现在摄取节点上的处理器。 如果查看正在运行的节点的属性（通过_nodes API），则会看到类似以下内容： <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"os"</span></span>. { <span class="hljs-string"><span class="hljs-string">"refresh_interval_in_millis"</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Linux"</span></span>, <span class="hljs-string"><span class="hljs-string">"arch"</span></span>: <span class="hljs-string"><span class="hljs-string">"amd64"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"4.4.0-87-generic"</span></span>, <span class="hljs-string"><span class="hljs-string">"available_processors"</span></span>: <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-string"><span class="hljs-string">"allocated_processors"</span></span>: <span class="hljs-number"><span class="hljs-number">28</span></span> }</code> </pre> <br> 可以看出，该节点在具有28个核心的主机上运行，​​并且Elastic正确地确定了它们的数量并在所有核心上启动。 但是，如果有32个以上的内核，则有时会发生以下情况： <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"os"</span></span>: { <span class="hljs-string"><span class="hljs-string">"refresh_interval_in_millis"</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Linux"</span></span>, <span class="hljs-string"><span class="hljs-string">"arch"</span></span>: <span class="hljs-string"><span class="hljs-string">"amd64"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"4.4.0-116-generic"</span></span>, <span class="hljs-string"><span class="hljs-string">"available_processors"</span></span>: <span class="hljs-number"><span class="hljs-number">72</span></span>, <span class="hljs-string"><span class="hljs-string">"allocated_processors"</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span> }</code> </pre> <br> 您必须强制该服务可用的处理器数量-这对节点的性能有很好的影响。 <br><br><pre> <code class="hljs">processors: 72</code> </pre> <br><h2>  thread_pool.bulk.queue_size </h2><br> 在上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇文章</a>的thread_pool.bulk.rejected部分中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，有</a>一个指标-请求添加数据失败的次数。 <br><br> 我写道，该指标的增长是一个非常糟糕的信号，开发人员建议不要设置线程池，而是向群集中添加新节点-可以解决性能问题。 但是需要规则以便有时打破规则。 而且，并非总是可以“用铁抛出问题”，因此，应对批量请求失败的措施之一就是增加此队列的大小。 <br><br> 默认情况下，队列设置如下所示： <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"thread_pool"</span></span>: { <span class="hljs-string"><span class="hljs-string">"bulk"</span></span>: { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"fixed"</span></span>, <span class="hljs-string"><span class="hljs-string">"min"</span></span>: <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-string"><span class="hljs-string">"max"</span></span>: <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-string"><span class="hljs-string">"queue_size"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span> } }</code> </pre> <br> 算法如下： <br><br><ol><li> 我们收集白天平均队列大小的统计信息（即时值存储在thread_pool.bulk.queue中）； </li><li> 小心地将queue_size的大小增加到略大于活动队列的平均大小的大小-因为超过该大小时会发生故障； </li><li> 我们增加了池的大小-这不是必需的，但可以接受。 </li></ol><br> 为此，请将以下内容添加到主机设置中（当然，您将拥有自己的值）： <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">thread_pool</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.bulk</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.size</span></span>: 32 <span class="hljs-selector-tag"><span class="hljs-selector-tag">thread_pool</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.bulk</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.queue_size</span></span>: 500</code> </pre> <br> 并且在重启节点之后，我们一定会监视负载，I / O，内存消耗。 并在必要时回滚所有设置。 <br><br>  <i>重要提示：这些设置仅对正在接收新数据的节点有意义。</i> <br><br><h2> 初步索引创建 </h2><br> 正如我在本系列的第一<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">篇文章中</a>所说的，我们使用Elasticsearch存储所有微服务的日志。 底线很简单-一个索引可以一天存储一个组件的日志。 <br><br> 随之而来的是，每天都会根据微服务的数量创建新索引-因此，每天晚上早些时候，弹性体陷入崩溃大约8分钟，而同时又创建了一百个新索引，数百个新分片，磁盘加载计划不可用，队列增加了将日志发送到主机上的弹性设备，Zabbix像圣诞树一样发出警报。 <br><br> 为避免这种情况，编写Python脚本来预先创建索引是常识。 脚本的工作方式是这样的：它查找今天的索引，提取它们的映射，并使用相同的映射创建新索引，但是要保留前一天的索引。 它在cron上运行，在Elastic负载最少的那几个小时内运行。 该脚本使用elasticsearch库，可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上使用</a> 。 <br><br><h2> 透明的父级大页面 </h2><br> 一旦发现运行数据接收的弹性节点在高峰时段开始在负载下挂起。 而且有一个非常奇怪的症状：所有处理器内核的使用率都降为零，但是该服务挂在内存中，正确侦听端口，不执行任何操作，不响应请求，并在一段时间后退出集群。 该服务不响应systemctl重新启动。 只有好的旧杀-9有所帮助。 <br><br> 直到坠落的那一刻，服务日志中的常规图片-才是空的，这在标准的监视工具上并没有发现。 此时，java机器的内存转储也是不可能的。 <br><br> 但是，正如他们所说，“我们是专业人士，所以一段时间后，我们用谷歌搜索了解决方案。” 一个类似的问题覆盖在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">describe.elastic.co</a>上的线程中，结果证明是与透明大页面有关的内核错误。 一切都通过使用sysfsutils软件包关闭内核中的thp来解决。 <br><br> 检查是否启用了透明的大页面很简单： <br><br><pre> <code class="hljs powershell">cat /sys/kernel/mm/transparent_hugepage/enabled always madvise [<span class="hljs-type"><span class="hljs-type">never</span></span>]</code> </pre> <br> 如果[总是]在那里，则有潜在的危险。 <br><br><h2> 结论 </h2><br> 这是主要的因素（实际上，当然还有更多），作为Elasticsearch集群的管理员，我碰巧踩了一年半。 我希望这些信息能在通往理想的Elasticsearch集群的艰难而神秘的旅程中派上用场。 <br><br> 感谢插图Anton Gudim-他的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">instagram上</a>还有很多好处。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN419041/">https://habr.com/ru/post/zh-CN419041/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN419027/index.html">银行无现金支付的信息安全。 第六部分-银行犯罪分析</a></li>
<li><a href="../zh-CN419029/index.html">Fortnite已成为一种社会现象。 父母越来越多地为他们的孩子聘请教练并与他们一起玩</a></li>
<li><a href="../zh-CN419033/index.html">关于在kubernetes集群中运行vue.js的主题的简短说明</a></li>
<li><a href="../zh-CN419035/index.html">本书“头先敏捷。 灵活的项目管理”</a></li>
<li><a href="../zh-CN419037/index.html">在stm32f4-discovery上的PPPOS实现</a></li>
<li><a href="../zh-CN419043/index.html">难以捉摸的帧定时问题</a></li>
<li><a href="../zh-CN419047/index.html">Reddit在2005-2007年间使用密码和电子邮件对数据库进行了黑客入侵，泄漏</a></li>
<li><a href="../zh-CN419049/index.html">GeekBrains推出“在数字中寻找自己”免费在线教育马拉松</a></li>
<li><a href="../zh-CN419051/index.html">Flant如何帮助初学者</a></li>
<li><a href="../zh-CN419053/index.html">测试Adaptec RAID缓存技术</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>