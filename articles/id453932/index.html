<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕎 🧞 🙌🏿 Beberapa kata untuk membela monolit 👨 🌊 👩‍❤️‍👩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami membandingkan fitur-fitur dari microservice dan arsitektur monolitik, kelebihan dan kekurangannya. Artikel ini disiapkan untuk Habr berdasarkan b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beberapa kata untuk membela monolit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/simbirsoft/blog/453932/">  Kami membandingkan fitur-fitur dari microservice dan arsitektur monolitik, kelebihan dan kekurangannya.  Artikel ini disiapkan untuk Habr berdasarkan bahan meta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hot Backend kami</a> , yang diadakan di Samara pada 9 Februari 2019.  Kami mempertimbangkan faktor-faktor pilihan arsitektur tergantung pada tugas spesifik. <a name="habracut"></a><br><br>  Bahkan 5 tahun yang lalu, tidak ada yang pernah mendengar tentang layanan microser.  Namun, popularitas mereka meningkat dari tahun ke tahun, menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">statistik dari</a> Google Trends. <br><br><img src="https://habrastorage.org/webt/1_/of/jd/1_ofjdwx6pauxathtq1srtfdsas.png"><br><br><h2>  Monolith dan layanan mikro: contoh </h2><br>  Jika proyek menggunakan arsitektur monolitik, maka pengembang hanya memiliki satu aplikasi, semua komponen dan modul yang bekerja dengan basis tunggal. <br><br><img src="https://habrastorage.org/webt/8q/pt/px/8qptpxklg15wtydbx847sqk2c9o.jpeg"><br><br>  Arsitektur microservice melibatkan penguraian menjadi modul yang dijalankan sebagai proses terpisah dan dapat memiliki server terpisah.  Setiap microservice bekerja dengan basis datanya sendiri, dan semua layanan ini dapat berkomunikasi satu sama lain baik secara sinkron (http) maupun secara tidak sinkron.  Selain itu, untuk mengoptimalkan arsitektur, diharapkan untuk meminimalkan hubungan antar layanan. <br><br>  Diagram di bawah ini disederhanakan, itu mencerminkan, pertama-tama, komponen bisnis. <br><br><img src="https://habrastorage.org/webt/q2/gi/y-/q2giy-br8pq2amiqihkrkzmn2e4.jpeg"><br><br><h2>  Layanan Mikro: manfaat </h2><br>  Setidaknya ada empat keunggulan arsitektur layanan mikro: <br><br>  <b>Penskalaan dan Penerapan Independen</b> <br><br>  Penyebaran independen disediakan untuk setiap layanan mikro, dan ini nyaman saat memperbarui modul individu.  Jika beban pada modul meningkat, microservice yang sesuai dapat diskalakan tanpa mempengaruhi yang lain.  Ini memungkinkan Anda untuk secara fleksibel mendistribusikan beban dan menghemat sumber daya. <br><br>  <b>Pengembangan mandiri</b> <br><br>  Setiap perangkat mikro (misalnya, modul memori) dapat dikembangkan oleh satu tim untuk meningkatkan kecepatan pembuatan produk perangkat lunak. <br><br>  <b>Keberlanjutan</b> <br><br>  Kegagalan satu microservice tidak mempengaruhi kinerja modul lainnya. <br><br>  <b>Heterogenitas</b> <br><br>  Setiap tim bebas memilih bahasa dan teknologinya sendiri untuk mengimplementasikan layanan-layanan microser, namun diharapkan memiliki antarmuka yang kompatibel. <br><br>  Di antara pengembang, Anda dapat mendengar pendapat bahwa arsitektur monolitik sudah ketinggalan zaman, sulit untuk mempertahankan dan skala, itu tumbuh dengan cepat di "benjolan besar kotoran" dan praktis antipernah, yaitu, keberadaannya dalam kode tidak diinginkan.  Perusahaan besar, seperti Netflix, yang beralih ke arsitektur microservice dalam proyek mereka, sering dikutip sebagai bukti pendapat ini. <br><br>  Mari kita lihat apakah semua orang benar-benar harus beralih dari monolith ke layanan microser mengikuti contoh merek terbesar? <br><br><h2>  Beralih ke layanan microser: kemungkinan kesulitan </h2><br>  <b>Masalah Satu: Dekomposisi</b> <br><br>  Idealnya, aplikasi harus dibagi ke dalam layanan-layanan mikro sehingga mereka saling berinteraksi sesedikit mungkin, jika tidak, aplikasi tersebut akan sulit dipertahankan.  Pada saat yang sama, dekomposisi sulit diimplementasikan pada awal pengembangan, ketika masalah bisnis dan bidang studi masih dapat berubah dengan munculnya persyaratan baru.  Refactoring itu mahal. <br><br>  Jika menjadi perlu untuk mentransfer bagian dari fungsi dari layanan A ke layanan B, maka kesulitan mungkin terjadi di sini: misalnya, layanan dieksekusi dalam berbagai bahasa, panggilan internal ke layanan menjadi jaringan, perpustakaan lain harus terhubung.  Kami dapat memverifikasi kebenaran refactoring hanya dengan bantuan tes. <br><br><img src="https://habrastorage.org/webt/ms/sb/zd/mssbzdbu2gw0mkt3xxsxd7cozuo.jpeg"><br><br>  <b>Masalah Dua: Transaksi</b> <br><br>  Masalah lain adalah bahwa layanan microser tidak memiliki konsep transaksi terdistribusi.  Kami dapat menjamin integritas arsitektur operasi bisnis hanya dalam satu layanan microser.  Jika operasi melibatkan beberapa layanan mikro, basis data yang berbeda dapat digunakan di sana, dan transaksi seperti itu harus ditinggalkan.  Untuk mengatasi masalah ini, ada berbagai metode yang digunakan dalam bisnis ketika aksesibilitas lebih penting daripada integritas.  Pada saat yang sama, mekanisme kompensasi disediakan jika terjadi kesalahan.  Misalnya, jika barang tidak tersedia, Anda perlu melakukan pengembalian dana ke akun pembeli. <br><br>  Jika sebuah monolith memberi kita integritas arsitektur secara otomatis, maka dengan layanan microser Anda perlu menemukan mekanisme Anda sendiri dan menggunakan perpustakaan dengan solusi yang sudah jadi.  Saat mendistribusikan operasi antar layanan, lebih baik meminta data secara sinkron, dan melakukan tindakan selanjutnya secara tidak sinkron.  Jika tidak mungkin mengakses salah satu layanan, tim akan antri segera setelah tersedia lagi. <br><br>  Dalam hal ini, perlu untuk merevisi pendekatan ke antarmuka pengguna.  Pengguna harus diberitahu bahwa beberapa tindakan tidak dilakukan segera, tetapi dalam waktu tertentu.  Ketika aplikasi diproses, ia menerima undangan untuk melihat hasilnya. <br><br><img src="https://habrastorage.org/webt/j3/ms/1m/j3ms1mf_jzbabdwangp62th2uru.jpeg"><br><br>  <b>Masalah Tiga: Pelaporan</b> <br><br>  Jika kami menggunakan arsitektur monolitik dengan satu basis data, untuk membuat laporan yang kompleks, Anda dapat menulis pilih dan menarik beberapa label data: cepat atau lambat akan ditampilkan.  Namun, pada layanan microser data ini dapat tersebar di berbagai basis. <br><br>  Misalnya, kita perlu membuat daftar perusahaan dengan metrik tertentu.  Dengan daftar perusahaan yang sederhana, semuanya berfungsi.  Dan jika Anda perlu menambahkan metrik yang ada di database lain?  Ya, kami dapat membuat permintaan tambahan dan meminta metrik oleh TIN.  Dan jika daftar ini perlu disaring dan disortir?  Daftar perusahaan bisa sangat besar, dan kemudian kami harus memperkenalkan layanan tambahan dengan database sendiri - laporan. <br><br><img src="https://habrastorage.org/webt/lz/kq/sn/lzkqsn07kbbjovz9_rttgfqbfmg.jpeg"><br><br>  <b>Masalah Empat: Kompleksitas Pengembangan Tinggi</b> <br><br>  Bekerja pada layanan terdistribusi lebih rumit: semua permintaan dilakukan melalui jaringan dan dapat dimatikan, Anda perlu menyediakan mekanisme panggilan balik (akankah membuat panggilan lagi? Berapa kali?).  Ini adalah "batu bata" yang secara bertahap menumpuk dan berkontribusi untuk meningkatkan kompleksitas proyek. <br><br>  Layanan dapat dikembangkan oleh beberapa tim yang berbeda, dan Anda perlu mendokumentasikannya, memperbarui dokumentasinya, memperingatkan tim lain ketika mengubah versi.  Ini adalah biaya tenaga kerja tambahan. <br><br>  Jika setiap tim memiliki penerapan independen, Anda harus mempertahankan setidaknya versi sebelumnya dan menonaktifkannya hanya setelah semua konsumen layanan beralih ke API baru. <br>  Tentu saja, kita dapat mengambil semua API menjadi semacam artefak yang akan tersedia untuk umum.  Tetapi, pertama, layanan dapat ditulis dalam berbagai bahasa, dan kedua, ini tidak disarankan.  Misalnya, di salah satu proyek kami, kami menolak ini atas permintaan pelanggan, terkait pertimbangan keamanan.  Setiap microservice memiliki repositori terpisah, dan pelanggan tidak memberikan akses kepada mereka. <br><br>  Dalam proses pengembangan, semuanya dapat bekerja dengan benar, dan kemudian - tidak.  Itu terjadi bahwa dalam kasus pengecualian, aplikasi tanpa batas mencoba untuk memprosesnya, dan ini memberikan beban besar - seluruh sistem "meletakkan".  Untuk menghindari situasi seperti itu, Anda harus mengonfigurasi semuanya, misalnya, untuk membatasi jumlah upaya, untuk tidak mengembalikan panggilan ini ke antrian di detik yang sama, dll. <br><br><img src="https://habrastorage.org/webt/_w/jd/oj/_wjdoj3ln-k7ysfb6wuh8kz1ycg.jpeg"><br><br><img src="https://habrastorage.org/webt/ae/rr/xc/aerrxc3udwi9pgafnmkzc7xy2du.jpeg"><br><br>  <b>Masalah kelima: kompleksitas pengujian, penelusuran dan debugging</b> <br><br>  Untuk menguji masalah, Anda harus mengunduh semua layanan microsoft yang terlibat.  Debugging menjadi tugas yang tidak sepele, dan semua log harus dikumpulkan di suatu tempat di satu tempat.  Dalam hal ini, Anda perlu log sebanyak mungkin untuk mencari tahu apa yang terjadi.  Untuk melacak masalah, Anda perlu memahami seluruh jalur yang dilalui pesan.  Tes unit tidak cukup di sini, karena kesalahan mungkin terjadi di persimpangan layanan.  Saat melakukan perubahan, dimungkinkan untuk memverifikasi pengoperasian hanya setelah berjalan di dudukan.  Kami dapat membatasi masing-masing layanan Microsoft hingga jumlah memori tertentu (misalnya, 500 megabita), tetapi ada saat-saat beban puncak saat dibutuhkan hingga dua gigabita.  Ada kalanya sistem mulai melambat.  Akibatnya, sumber daya dapat dihabiskan untuk sesuatu yang bukan milik tugas langsung klien: misalnya, hanya ada dua layanan microser bisnis, dan setengah dari sumber daya dihabiskan untuk tiga layanan microser tambahan yang mendukung pekerjaan yang lain. <br><br><img src="https://habrastorage.org/webt/pl/bn/36/plbn36qdp9gnyslu-b0xbecfo7c.jpeg"><br><br><h2>  Layanan mikro atau monolit: kriteria seleksi </h2><br>  Ketika memilih antara arsitektur monolitik dan microservice, pertama-tama, Anda perlu melanjutkan dari kerumitan area subjek dan kebutuhan untuk penskalaan. <br><br>  Jika area subjek sederhana, dan peningkatan global dalam jumlah pengguna tidak diharapkan, maka layanan microser dapat digunakan tanpa keraguan.  Dalam kasus lain, lebih baik memulai pengembangan dengan monolit dan menghemat sumber daya jika penskalaan tidak diperlukan.  Jika area subjek kompleks, dan pada tahap awal persyaratan akhir tidak ditentukan, juga lebih baik untuk memulai dengan monolith - agar tidak mengulangi layanan microsec beberapa kali.  Dengan pengembangan lebih lanjut dari proyek, adalah mungkin untuk membedakan bagian-bagian individual dalam layanan-layanan microser. <br><br><img src="https://habrastorage.org/webt/bl/5c/9e/bl5c9elyajqq00pivozpby_yauy.jpeg"><br><br>  Nilai plus adalah adanya batas pada awal proyek, karena hal ini akan membantu untuk tidak mematahkannya selama proses pengembangan.  Masuk akal juga untuk memulai dengan satu basis data, tetapi untuk menentukan skema untuk setiap modul (misalnya, skema pembayaran).  Selanjutnya, ini akan membantu menyederhanakan pembagian modul menjadi layanan microser.  Dalam hal ini, kami mengamati batas-batas modul dan dapat menggunakan layanan microser. <br><br>  Setiap modul harus memiliki API sendiri, sehingga nantinya dapat dialokasikan dan menjadikan modul sebagai layanan mikro. <br><br><img src="https://habrastorage.org/webt/6i/rp/b9/6irpb9ewnkmgleylittjhh5z-f8.jpeg"><br><br>  Setelah menentukan batas-batas modul, Anda dapat melanjutkan ke dekomposisi ke dalam layanan microser, jika perlu.  Dalam sekitar 90% kasus akan memungkinkan untuk tetap menggunakan monolit, tetapi jika perlu akan lebih mudah dan lebih murah untuk mengubah arsitektur. <br><br>  Dalam praktik kami bekerja dengan monolit dan layanan mikro, kami sampai pada kesimpulan berikut: <br><ul><li>  Jangan beralih ke layanan microser hanya karena digunakan oleh Netflix, Twitter, Facebook </li><li>  Mulailah dengan dua atau tiga layanan microser yang berinteraksi satu sama lain, tentukan semua persyaratan non-fungsional secara terperinci (keamanan, toleransi kesalahan, skalabilitas, dll.) Dan baru kemudian beralih ke layanan lain </li><li>  Otomatiskan semua yang mungkin </li><li>  Atur pemantauan </li><li>  Tulis autotest </li><li>  Jangan gunakan transaksi terdistribusi (tapi ini bukan alasan untuk menolak jaminan integritas data). </li><li>  Jika Anda ingin menggunakan arsitektur layanan mikro, bersiaplah untuk kenyataan bahwa pengembangan dapat dikenakan biaya sekitar 3 kali lebih banyak daripada pada monolit.  Namun, kedua teknologi memiliki kelemahan dan kelebihan masing-masing, masing-masing memiliki ceruk masing-masing. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453932/">https://habr.com/ru/post/id453932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453914/index.html">Petunjuk Instalasi Klien TON Test</a></li>
<li><a href="../id453916/index.html">Bagaimana melindungi diri Anda dari penipu seluler</a></li>
<li><a href="../id453920/index.html">Bagaimana mengendalikan infrastruktur jaringan Anda. Bab Empat Otomasi Templat</a></li>
<li><a href="../id453926/index.html">Bagaimana layanan berbagi mobil bekerja dan bekerja</a></li>
<li><a href="../id453930/index.html">Perbandingan dan pemilihan sistem migrasi data</a></li>
<li><a href="../id453934/index.html">11 pertanyaan untuk didiskusikan sebelum mulai bekerja</a></li>
<li><a href="../id453938/index.html">NB-IoT Pelacakan Sepeda Dicuri</a></li>
<li><a href="../id453942/index.html">Tentang Etika dengan Contoh Codex PMI</a></li>
<li><a href="../id453944/index.html">Bug bertopeng di embedd</a></li>
<li><a href="../id453950/index.html">Anda seharusnya ada di sini! 22 tahun rilis game legendaris Duke Nukem 3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>