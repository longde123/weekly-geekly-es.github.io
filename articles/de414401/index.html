<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ü üë®üèΩ‚Äçüíº üßïüèΩ 100.500 Caching-Methoden in der Oracle-Datenbank üö± üåπ ü•Ñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zu sagen, was Caches sind, was Ergebnis-Cache ist, wie es in Oracle und in anderen Datenbanken erstellt wird, ist nicht sehr interessant und h√ºbsch. A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>100.500 Caching-Methoden in der Oracle-Datenbank</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/414401/">  Zu sagen, was Caches sind, was Ergebnis-Cache ist, wie es in Oracle und in anderen Datenbanken erstellt wird, ist nicht sehr interessant und h√ºbsch.  Aber bei bestimmten Beispielen nimmt alles ganz andere Farben an.  <strong>Alexander Tokarev</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">shtock</a> ) hat seinen Bericht √ºber Highload ++ 2017 basierend auf F√§llen erstellt.  Und genau auf der Grundlage von F√§llen sagte er mir, wann ein selbst erstellter Cache praktisch sein k√∂nnte, was der serverseitige Ergebniscache schmerzt und wie er durch einen clientseitigen ersetzt werden kann, und im Allgemeinen habe ich eine Reihe n√ºtzlicher Tipps zum Einrichten des Ergebniscaches in Oracle angesprochen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/hTCXaAKIArk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>√úber den Redner:</strong> Alexander Tokarev arbeitet bei DataArt und befasst sich mit Fragen im Zusammenhang mit Datenbanken, sowohl im Hinblick auf das Erstellen von Systemen von Grund auf als auch auf die Optimierung bestehender Systeme. <br><br>  Beginnen wir mit ein paar rhetorischen Fragen.  Haben Sie mit Oracle Result Cache gearbeitet?  Glauben Sie, dass Oracle eine Datenbank ist, die f√ºr alle Gelegenheiten geeignet ist?  Nach Alexanders Erfahrung verneinen die meisten Menschen die letzte Frage, <strong>einhundert Tr√§umer haben einen Tr√§umer</strong> .  Aber dank seines Glaubens bewegt sich der Fortschritt. <br><br>  √úbrigens hat Oracle bereits 14 Datenbanken - bisher 14 - was in Zukunft passieren wird, ist unbekannt. <br><br>  Wie bereits erw√§hnt, werden alle Probleme und L√∂sungen in bestimmten F√§llen dargestellt.  Dies sind zwei F√§lle aus DataArt-Projekten und ein Beispiel eines Drittanbieters. <br><a name="habracut"></a><br><h2>  Datenbank-Caches <br></h2><br>  Zun√§chst, welche Caches sich in den Datenbanken befinden.  Hier ist alles klar: <br><br><ul><li>  Puffercache - Datencache - Cache f√ºr Datenseiten / Datenbl√∂cke; </li><li>  Anweisungscache - Cache von Anweisungen und ihren Pl√§nen - Cache von Abfrageplan; </li><li>  Ergebnis-Cache - Cache der Zeilenergebnisse - Zeilen aus Abfragen; </li><li>  Betriebssystem-Cache - Betriebssystem-Cache. </li></ul><br>  Dar√ºber hinaus wird der Ergebnis-Cache im Gro√üen und Ganzen nur in Oracle verwendet.  Er war einmal in MySQL, aber dann wurde er heldenhaft herausgeschnitten.  In PostgreSQL ist es auch nicht vorhanden, es ist in der einen oder anderen Form nur im pgpool-Produkt eines Drittanbieters vorhanden. <br><br><h2>  Fall 1. H√§ndlergew√∂lbe <br></h2><br><img src="https://habrastorage.org/webt/qo/cq/t5/qocqt5zzctiqj1hh5n-6hc9skkm.jpeg"><br><br>  Oben sehen Sie das Produktdiagramm, das wir begleitet haben - das Repository (Oracle 11, 20 TB, 300 Benutzer), und es enth√§lt eine Art trostlosen Bericht, in dem 350 eindeutige Produkte pro 5000 Datenzeilen enthalten waren.  Es dauerte ungef√§hr 20 Minuten, und die Benutzer waren traurig. <br><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Pr√§sentation</a> dieses Berichts ist wie alle anderen auf der Highload ++ - Konferenzseite verf√ºgbar. </blockquote><br>  Dieser Bericht enth√§lt SELECT, JOINs und eine Funktion.  Eine Funktion als Funktion, alles w√§re in Ordnung, nur berechnet sie einen mysteri√∂sen Parameter namens "Verrechnungspreiswert", es funktioniert f√ºr 0,2 s - es scheint nichts zu sein, aber es wird so oft aufgerufen, wie es Zeilen in der Tabelle gibt.  Diese Funktion hat seitdem 400 Zeilen SQL + PL / SQL  Das Produkt wird unterst√ºtzt. Es ist be√§ngstigend, es zu √§ndern. <br><br>  Aus dem gleichen Grund konnte result_cache nicht verwendet werden. <br><br><img src="https://habrastorage.org/webt/1o/u5/ct/1ou5ctbufxqrsme66mbz60bieuy.jpeg"><br><br>  Um das Problem zu l√∂sen, verwenden wir den Standardansatz <strong>mit handgemachtem Caching</strong> : Wir belassen die ersten 3 Bl√∂cke der Schaltung so wie sie waren, benennen einfach unsere Funktion sku_detail () in sku_full () um und deklarieren ein assoziatives Array, wobei: <br><br><ul><li>  Schl√ºssel sind unsere SKUs (Commodity Items), <br></li><li>  Die Werte sind der berechnete Transferumwandlungspreis. <br></li></ul><br>  Wir machen die Cache-Funktion (sku) offensichtlich: Wenn unser assoziatives Array keine solche ID enth√§lt, wird unsere Funktion gestartet, das Ergebnis zwischengespeichert, gespeichert und zur√ºckgegeben.  Wenn dementsprechend eine solche ID vorliegt, geschieht dies alles nicht.  Tats√§chlich haben wir einen <strong>On-Demand-Cache erhalten</strong> . <br><br>  Daher haben wir die Anzahl der Funktionsaufrufe auf den tats√§chlich ben√∂tigten Betrag reduziert.  <strong>Die Bearbeitungszeit f√ºr Berichte verringerte sich auf 4 Minuten</strong> . Alle Benutzer f√ºhlten sich gut. <br><br><h3>  <strong>Handgemachter Cache-Speicher</strong> <br></h3><br>  Die Nachteile und Vorteile dieses Systems werden aus diesem gro√üen intelligenten Bild deutlich, auf das wir viel eingehen werden - dies ist die Speicherarchitektur. <br><br><img src="https://habrastorage.org/webt/ku/e4/2o/kue42onfhkjjpxxyk0klg0-at50.jpeg"><br><br>  Es ist wichtig zu verstehen, in welchem ‚Äã‚ÄãSpeicherbereich sich die Sammlungen befinden.  Sie befinden sich in einem Speicherbereich namens PGA.  <strong>Der globale Programmbereich wird</strong> bei jeder Verbindung zur Datenbank instanziiert.  Dies bestimmt die Vor- und Nachteile, da mehr Verbindungen - mehr Speicher und <strong>teurer Speicher, Server</strong> , Administratoren - zart sind. <br><br><img src="https://habrastorage.org/webt/7c/gi/hd/7cgihdigefzcded25cmfondxkcc.jpeg"><br><br><ul><li>  <strong>Vorteile:</strong> Alles funktioniert sehr schnell, ist sehr einfach zu erledigen, keine Konfiguration erforderlich, keine Probleme mit der Interprozessbeteiligung. <br></li><li>  <strong>Die Nachteile</strong> sind verst√§ndlich: Wenn gespeicherte Logik im Projekt verboten ist, k√∂nnen sie nicht verwendet werden, es gibt keinen Mechanismus f√ºr die automatische Ung√ºltigmachung, und da der Speicher im Cache innerhalb einer Datenbanksitzung und nicht einer Instanz zugewiesen wird, wird sein <strong>Verbrauch √ºberbewertet</strong> .  Dar√ºber hinaus m√ºssen Sie im Fall des Anwendungsfalls des Verbindungspools daran denken, die Caches zu leeren, wenn f√ºr jede Sitzung ein anderes Caching vorhanden sein sollte. <br></li></ul><br>  Es gibt andere Optionen f√ºr handgefertigte Caches, die auf materialisierten Ansichten und tempor√§ren Tabellen basieren, aber von diesen wird das Eingabe-Ausgabe-System stark belastet, sodass wir sie hier nicht ber√ºcksichtigen.  Sie sind eher auf andere Datenbanken anwendbar, in denen solche Probleme normalerweise gel√∂st werden, indem die gespeicherte Prozedur in einer Zwischentabelle gespeichert und die Daten daraus entnommen werden, bevor auf eine umfangreiche Anforderung zugegriffen wird.  Und nur wenn nicht gefunden wurde, was ben√∂tigt wird, wird die erste Anfrage aufgerufen. <br><br><img src="https://habrastorage.org/webt/mh/8u/xg/mh8uxg2hjytjwrp0fbds1gvoc4k.jpeg"><br><br>  Das Obige veranschaulicht diesen Ansatz f√ºr das Caching-Problem, um eine Liste verwandter Produkte in MsSQL zu erhalten.  Im Allgemeinen ist der Ansatz relativ √§hnlich, funktioniert jedoch im Datenbankspeicher nicht sowohl hinsichtlich des Abrufs von Daten als auch hinsichtlich der Prim√§rf√ºllung. Aufgrund dessen <strong>kann er langsamer sein</strong> . <br><br>  Im Allgemeinen wird der selbst erstellte result_cache aktiv verwendet, der datenbankinterne result_cache ist jedoch ein anderer Ansatz f√ºr die Implementierung dieser Aufgabe.  Es und wie es nicht schnell geklappt hat, werden wir weiter √ºberlegen. <br><br><h2>  Fall 2. Verarbeitung der Finanzdokumentation <br></h2><br>  Also unser zweiter Fall. <br><br><img src="https://habrastorage.org/webt/dd/zn/wy/ddznwymy92vgt32eox6fvwanepq.jpeg"><br><br>  Dies ist ein halbautomatisches Verarbeitungssystem f√ºr Finanzdokumentationen - ein trostloses Unternehmen mit einer klassischen Architektur, das Folgendes umfasst: <br><br><ul><li>  Thin Client; <br></li><li>  4.000 Benutzer, die in verschiedenen Teilen der Welt leben; <br></li><li>  Balancer; <br></li><li>  2 JBoss zur Berechnung der Gesch√§ftslogik; <br></li><li>  In-Memory-Cluster; <br></li><li>  Kern Oracle; <br></li><li>  Oracle-Backup <br></li></ul><br>  Eine der vielen Aufgaben dieses Systems ist die <strong>Berechnung von Empfehlungen</strong> . <br><br><img src="https://habrastorage.org/webt/dm/rt/cf/dmrtcfcgvy2q94g-jl52qnhatbo.jpeg"><br><br>  Es gibt Dokumente. F√ºr jeden Indikator, der vom System nicht automatisch erkannt wird, wird eine Reihe von Indikatoren entweder aus fr√ºheren Kundendokumenten oder aus einer √§hnlichen Branche oder mit √§hnlicher Rentabilit√§t angeboten, w√§hrend der Indikator mit dem erkannten Wert verglichen wird, um nicht zu viel zu bieten.  Wichtig ist, dass die <strong>Dokumente mehrsprachig sind</strong> . <br><br>  Der Benutzer w√§hlt den gew√ºnschten Wert aus und wiederholt den Vorgang f√ºr jede leere Zeile. <br><br>  Vereinfacht gesagt besteht diese Aufgabe aus Folgendem: Dokumente kommen in Form von Schl√ºssel-Wert-Paaren aus verschiedenen Erkennungssystemen an, und Parameter werden irgendwo erkannt, aber nicht irgendwo.  Es muss sichergestellt werden, dass die Benutzer am Ende die Dokumente verarbeiten und alle Werte erkannt werden.  Die Empfehlung zielt genau auf die Vereinfachung dieser Aufgabe ab und ber√ºcksichtigt: <br><br><ol><li>  Mehrsprachigkeit - ca. 30 Sprachen.  Jede Sprache hat ihre eigenen St√§mme, Synonyme und andere Merkmale. </li><li>  Die vorherigen Daten dieses Kunden oder, falls nicht vorhanden, die Daten eines Kunden aus derselben Branche oder eines Kunden mit √§hnlichem Gewinn. </li></ol><br>  In der Tat sind dies ungef√§hr 12 sehr komplexe Regeln. <br><br>  <strong>Anfangsannahmen:</strong> <br><br><ul><li>  Nicht mehr als 100 Benutzer gleichzeitig; </li><li>  2-3 Spalten zur Erkennung; </li><li>  100 Zeilen. </li></ul><br>  <strong>√úberhaupt keine Hochlast</strong> - alles ist langweilig. <br><br>  Es ist also Zeit f√ºr die Ver√∂ffentlichung.  Das Einfrieren des Codes ist passiert, Java hat Angst vor Ber√ºhrungen und die Verarbeitung eines Dokuments dauert mindestens 5 Minuten. <br><br>  Sie kommen zum Datenbankentwicklungsteam und bitten um Hilfe.  Nat√ºrlich, denn <em>wenn sich etwas in der JVM verlangsamt, m√ºssen Sie die Datenbank selbst √§ndern oder reparieren</em> . <br><br><img src="https://habrastorage.org/webt/ae/q_/tm/aeq_tm3cua2tkk3ohgxl7rntova.jpeg"><br><br>  Wir haben die Dokumente untersucht und festgestellt, dass Werte in Schl√ºssel-Wert-Paaren h√§ufig wiederholt werden - 5-10 Mal.  Dementsprechend haben wir uns entschieden, die Datenbank zum Zwischenspeichern zu verwenden, da sie bereits getestet wurde. <br><br>  Wir haben uns f√ºr den serverseitigen Ergebniscache von Oracle entschieden, weil: <br><br><ol><li>  Die M√∂glichkeiten zur Optimierung von SQL wurden ausgesch√∂pft, da die Oracle-Volltextsuchmaschine verwendet wird. <br></li><li>  Der Cache wird f√ºr doppelte Parameter verwendet. <br></li><li>  Die meisten Daten f√ºr Empfehlungen werden einmal pro Stunde neu berechnet, da sie einen Volltextindex verwenden. <br></li><li>  <strong>PL / SQL ist verboten</strong> . <br></li></ol><br><h3>  <strong>Oracle-Ergebniscache</strong> <br></h3><br>  Der Ergebnis-Cache - Oracle-Caching von Ergebnissen - hat die folgenden Eigenschaften: <br><br><ul><li>  Dies ist der Speicherbereich, in dem alle Abfrageergebnisse durchsucht werden. </li><li>  Lesen Sie konsistent, und seine automatische Ung√ºltigmachung tritt auf; </li><li>  Es sind nur minimale √Ñnderungen an der Anwendung erforderlich.  Sie k√∂nnen daf√ºr sorgen, dass die Anwendung √ºberhaupt nicht ge√§ndert werden muss. </li><li>  Bonus - Sie k√∂nnen PL / SQL-Logik zwischenspeichern, dies ist hier jedoch verboten. </li></ul><br>  <strong>Wie aktiviere ich es?</strong> <br><br><h4>  Methodennummer 1 <br></h4><br><img src="https://habrastorage.org/webt/qo/im/jv/qoimjvcbfclnfsp_pncn6uf-74g.jpeg"><br><br>  Es ist sehr einfach <strong>, die Anweisung result_cache anzugeben</strong> .  Die Folie zeigt, dass die Ergebniskennung angezeigt wurde.  Dementsprechend f√ºhrt die Datenbank bei der ersten Ausf√ºhrung der Abfrage einige Arbeiten aus, w√§hrend der nachfolgenden Ausf√ºhrung ist in diesem Fall keine Arbeit erforderlich.  Alles ist gut. <br><br><h4>  Methode Nummer 2 <br></h4><br><img src="https://habrastorage.org/webt/5x/uy/d5/5xuyd5seajh5kshz1xmdvmd6fu0.jpeg"><br><br>  Der zweite Weg erm√∂glicht es Anwendungsentwicklern, nichts zu tun - dies sind die sogenannten Annotationen.  Wir geben ein H√§kchen f√ºr die Tabelle an, dass die Anforderung an sie in result_cache gestellt werden soll.  Dementsprechend gibt es keinen Hinweis, wir ber√ºhren die Anwendung nicht und alles befindet sich bereits im result_cache. <br><br><blockquote>  Was denken Sie √ºbrigens, wenn sich eine Abfrage auf zwei Tabellen bezieht, von denen eine als result_cache markiert ist und die zweite nicht, wird das Ergebnis einer solchen Abfrage zwischengespeichert? <br><br>  Die Antwort ist nein, √ºberhaupt nicht. <br></blockquote><br>  Damit es zwischengespeichert werden kann, m√ºssen alle an der Abfrage beteiligten Tabellen mit der Annotation result_cache versehen sein. <br><br><h3>  <strong>Abh√§ngigkeitsverfolgung</strong> <br></h3><br>  Es gibt relevante Ansichten, in denen Sie sehen k√∂nnen, welche Abh√§ngigkeiten bestehen. <br><br><img src="https://habrastorage.org/webt/ni/12/bp/ni12bpiy04zhswxncy1rsq1h29s.jpeg"><br><br>  Im obigen Beispiel ist die JOIN-Abfrage eine Tabelle, in der es eine Abh√§ngigkeit gibt.  Warum?  Weil Oracle die Abh√§ngigkeit nicht nur durch Parsen bestimmt, sondern sie <strong>entsprechend den Ergebnissen des Arbeitsplans</strong> implementiert. <br><br>  In diesem Fall wurde ein solcher Plan ausgew√§hlt, da nur eine Tabelle verwendet wird und die Jobtabelle √ºber eine Fremdschl√ºsseleinschr√§nkung mit der Mitarbeitertabelle verkn√ºpft ist.  Wenn wir die Fremdschl√ºsseleinschr√§nkung entfernen, die diese Join-Eliminierungstransformation erm√∂glicht, werden zwei Abh√§ngigkeiten angezeigt, da sich der Plan auf diese Weise √§ndert. <br><br>  <strong>Oracle verfolgt nicht, was nicht verfolgt werden muss</strong> . <br><br>  In PL / SQL wird die Abh√§ngigkeit zur Laufzeit ausgef√ºhrt, sodass Sie dynamisches SQL verwenden und andere Aufgaben ausf√ºhren k√∂nnen. <br><br><img src="https://habrastorage.org/webt/3j/nh/fk/3jnhfkrft2dgbs-4nyvnwg6nfkm.jpeg"><br><br>  Bitte beachten Sie, dass Sie nicht nur die gesamte Anforderung zwischenspeichern k√∂nnen, sondern <strong>auch die Inline-Ansicht mit und von zwischenspeichern k√∂nnen</strong> .  Nehmen wir zum einen an, wir brauchen einen Cache, und zum anderen ist es besser, aus der Datenbank zu lesen, um ihn nicht zu belasten.  Wir nehmen eine Inline-Ansicht, deklarieren sie erneut als result_cache und stellen fest, dass nur ein Teil zwischengespeichert wird, und f√ºr den zweiten greifen wir jedes Mal auf die Datenbank zu. <br><br><img src="https://habrastorage.org/webt/zq/ze/7z/zqze7zgbnbljnme7a9j8qfbewdo.jpeg"><br><br>  Und schlie√ülich haben die <strong>Datenbanken auch eine Kapselung</strong> , obwohl niemand daran glaubt.  Wir sehen uns das an, setzen result_cache ein und unsere Programmierer erkennen nicht einmal, dass es zwischengespeichert ist.  Unten sehen wir, dass tats√§chlich nur ein Teil davon funktioniert. <br><br><img src="https://habrastorage.org/webt/-x/-a/mt/-x-amt3jzaygadispddtfx_fojy.jpeg"><br><br><h3>  Behinderung <br></h3><br>  Lassen Sie uns also sehen, wann Oracle result_cache ung√ºltig macht. Der Status "Ver√∂ffentlicht" zeigt den aktuellen Status der Cache-G√ºltigkeit an.  Bei der Anforderung an result_cache befinden sich, wie gesagt, keine Jobs in der Datenbank <br><br><img src="https://habrastorage.org/webt/uv/9b/at/uv9batcfvtszo6tudxpovnhzy8s.jpeg"><br><br>  Wenn wir das Update durchgef√ºhrt haben, ist der Status immer noch ver√∂ffentlicht, da das Update nicht festgeschrieben wurde und andere Sitzungen den alten result_cache sehen sollten.  Dies ist die ber√ºchtigte Lesekonsistenz. <br><br>  In der aktuellen Sitzung werden wir jedoch feststellen, dass die Last weg ist, da in dieser Sitzung der Cache ignoriert wird.  Das ist ziemlich vern√ºnftig, machen wir ein Commit - das Ergebnis wird ung√ºltig, alles funktioniert von selbst. <br><br><img src="https://habrastorage.org/webt/-r/sn/rt/-rsnrtdyj9bk6vthaott4qondaq.jpeg"><br><br>  Es scheint - ein Traum!  Die Abh√§ngigkeit wird als korrekt angesehen - nur abh√§ngig von der Anforderung.  Aber nein, eine Reihe von Nuancen wurden enth√ºllt.  <strong>Oracle produziert Behinderungen und in einer Reihe von nicht offensichtlichen F√§llen</strong> : <br><br><ol><li>  Bei jedem Aufruf von SELECT FOR UPDATE verschwinden die Abh√§ngigkeiten. </li><li>  Wenn die Tabelle nicht indizierte Fremdschl√ºssel enth√§lt und eine Aktualisierung der mit result_cache gekennzeichneten Tabelle erfolgt, die sich auf nichts auswirkt, sich jedoch in der √ºbergeordneten Tabelle etwas ge√§ndert hat, wird der Cache ebenfalls ung√ºltig. </li><li>  Dies ist die interessanteste Sache, die das Leben so sehr wie m√∂glich beeintr√§chtigt - wenn die als result_cache gekennzeichnete Tabelle nicht erfolgreich aktualisiert wurde, hat nichts funktioniert, aber in derselben Transaktion wurden alle anderen √Ñnderungen angewendet, die sich irgendwie auf die erste Tabelle auswirkten result_cache wird zur√ºckgesetzt. </li></ol><br>  Es gibt immer noch ein solches Antipattern bei result_cache, wenn Entwickler, die geh√∂rt haben, dass es so eine coole Sache gibt, denken: ‚ÄûOh, da ist Speicher!  Jetzt nehmen wir eine Anfrage entgegen, die auf 2-3 Partitionen funktioniert - markieren Sie sie am aktuellen und am vorherigen Datum als result_cache und sie wird immer aus dem Speicher genommen! " <br><br>  Wenn Sie jedoch im Nachhinein Patricia √§ndern, fliegt der gesamte Cache, da die Einheit der Abh√§ngigkeitsverfolgung in result_cache immer eine Tabelle ist und ich nicht wei√ü, ob es jemals Partitionen geben wird oder nicht. <br><br>  Wir dachten und beschlossen, mit solchen Dingen ein Empfehlungssystem zu erstellen: <br><br><ul><li>  <strong>Wir werden nicht alle unsere Tabellen zwischenspeichern, wir werden nur die notwendigen nehmen.</strong> <br></li><li>  <strong>Legen Sie result_cache f√ºr die lang laufende Abfrage fest.</strong> <br></li></ul><br>  Wir haben alles √ºberpr√ºft, Leistungstests durchgef√ºhrt, <strong>Verarbeitungszeit - 30 s</strong> .  Alles ist toll, geh in die Produktion! <br><br>  Abgest√ºrzt - ging schlafen.  Wir kommen am Morgen an.  Wir sehen einen Brief: "Die Erkennung dauert mindestens 20 Minuten, die Sitzungen frieren ein."  Warum frieren sie?  Wie wurden aus <strong>30 Sekunden 20 Minuten</strong> ? <br><br>  Sie begannen zu verstehen, schauten in die Datenbank: <br><br><ul><li>  aktive Sitzungen - 400; </li><li>  durchschnittlich Zeilen in einem Dokument zur Anerkennung - 500; </li><li>  Spalten mindestens - 5-8; </li><li>  Die Anzahl der Sitzungen in der Datenbank entspricht immer der Anzahl der Benutzeranwendungen multipliziert mit 3!  Und result_cache mag keinen h√§ufigen Zugriff darauf. </li></ul><br>  Nach einer internen Untersuchung stellten wir fest, dass Java-Entwickler in drei Threads erkennen. <br><br>  Wir waren ver√§rgert - eine 5-fache Belastung, ein Abfall, eine Verschlechterung und selbst mit solchen Parametern h√§tte ein solches Absinken nicht passieren d√ºrfen. <br><br>  Nat√ºrlich m√ºssen Sie verstehen. <br><br><h3>  √úberwachung <br></h3><br><img src="https://habrastorage.org/webt/b6/iq/iw/b6iqiwwevjqyua9xr6p8j2aq0bu.jpeg"><br><br>  F√ºr die √úberwachung haben wir zwei wichtige Dinge: <br><br><ol><li>  V $ RESULT_CACHE_OBJECTS - eine Liste aller Objekte; </li><li>  V $ RESULT_CACHE_STATISTICS - Aggregierte Statistik des gesamten Ergebniscaches. </li></ol><br>  MEMORY_REPORT sind Variationen eines Themas, wir werden sie nicht brauchen. <br><br>  Oracle ist magisch!  Es gibt eine gro√üartige Dokumentation, die jedoch f√ºr diejenigen gedacht ist, die von anderen Datenbanken wechseln, damit sie lesen und denken, dass Oracle sehr cool ist!  <strong>Alle Informationen zu result_cache liegen jedoch nur bei der Unterst√ºtzung</strong> . <br><br><img src="https://habrastorage.org/webt/vm/u1/bt/vmu1bt35lwpsvebw9o-rnxxasgs.jpeg"><br><br>  Es gibt eine Nuance, die darin besteht, dass wir, sobald wir uns diesen Objekten zuwenden, um das Problem zu l√∂sen, es versch√§rfen, indem wir uns endg√ºltig begraben!  Bis Oracle12.2, vor dessen Patch es im Oktober letzten Jahres ver√∂ffentlicht wurde, machen diese Anforderungen result_cache f√ºr den Status und das Schreiben unzug√§nglich, bis sie vollst√§ndig gez√§hlt sind. <br><br><img src="https://habrastorage.org/webt/8b/nd/4y/8bnd4ygeerwxy7n38lqjrqrfwnw.jpeg"><br><br>  In der Ansicht v $ result_cache_objects haben wir festgestellt, dass die Liste der zwischengespeicherten Objekte Tausende von Eintr√§gen enth√§lt - viel mehr als erwartet.  Dar√ºber hinaus waren dies Objekte aus einigen unserer Abfragen in seltsamen Tabellen - kleine Tablets und last_modified_date-Abfragen.  Offensichtlich hat <strong>jemand ETL auf unsere Basis gesetzt</strong> . <br><br>  Bevor wir uns bei ETL-Entwicklern beschworen haben, haben wir √ºberpr√ºft, ob die Option result_cache force f√ºr diese Tabellen aktiviert ist, und uns daran erinnert, dass wir sie selbst aktiviert haben, da einige dieser Daten h√§ufig von der Anwendung ben√∂tigt wurden und das Caching angemessen war. <br><br><img src="https://habrastorage.org/webt/u1/wq/28/u1wq28jkvtylav6ndpx7qql6koo.jpeg"><br><br>  Es stellte sich jedoch heraus, dass <strong>all diese Anfragen nur unseren Cache nehmen und waschen</strong> .  Gl√ºcklicherweise hatten die Entwickler die M√∂glichkeit, die ETL in der Produktion zu beeinflussen, sodass wir result_cache √§ndern konnten, um diese winzigen Anforderungen auszuschlie√üen. <br><br>  Denkst du, es ist einfacher?  - F√ºhl dich nicht besser!  Die Anzahl der zwischengespeicherten Objekte nahm ab und stieg dann wieder auf 12.000. Wir untersuchten weiter, was noch zwischengespeichert wurde, da sich die Geschwindigkeit nicht √§nderte. <br><br><img src="https://habrastorage.org/webt/iy/1o/di/iy1odismaewdpasdhlh_uidjeay.jpeg"><br><br>  Wir sehen aus - eine Menge Anfragen, und so klug, aber alles unverst√§ndlich.  Obwohl jeder, der mit Oracle 12 gearbeitet hat, wei√ü, dass DS SVC eine adaptive Statistik ist.  Es wird ben√∂tigt, um die Leistung zu verbessern, aber wenn es result_cache gibt, stellt sich heraus, dass es ihn umbringt, weil Wettbewerb stattfindet.  Dies ist nat√ºrlich <strong>nur zur Unterst√ºtzung geschrieben</strong> . <br><br>  Wir wussten, wie die Arbeitsbelastung angeordnet ist, und haben verstanden, dass adaptive Statistiken in unserem Fall unsere Pl√§ne nicht besonders radikal verbessern w√ºrden.  Deshalb haben wir es heldenhaft ausgeschaltet - das Ergebnis, wie es im geheimen Handbuch geschrieben steht, betr√§gt 10 Minuten pro Dokument.  Nicht schlecht, aber nicht genug. <br><br><h3>  Riegel <br></h3><br>  <strong>Die Konkurrenz zwischen result_cache und DS SVC</strong> beruht auf der Tatsache, dass Oracle Latches hat - leichte kleine Schl√∂sser. <br><br><img src="https://habrastorage.org/webt/d5/ts/nd/d5tsndbmieve1hguz6yv-qzq2jk.jpeg"><br><br>  Ohne auf Details zu ihrer Funktionsweise einzugehen, versuchen wir mehrmals, einen benannten Latch zu platzieren - es hat nicht funktioniert - Oracle nimmt auf und schl√§ft ein <br><br>  Jeder, der sich im Betreff befindet, kann sagen, dass im result_cache zwei Latches mit Fetch auf jeden Block gesetzt werden.  Das sind die Details.  Es gibt zwei Arten von Latches in result_cache: <br><br>  1. Latch f√ºr den Zeitraum, w√§hrend wir Daten in result_cache schreiben. <br><br><img src="https://habrastorage.org/webt/pv/db/qe/pvdbqeunmn4qjgcybpkxai3thne.jpeg"><br><br>  Das hei√üt, wenn Ihre Anfrage 8 Sekunden lang funktioniert hat, k√∂nnen andere gleiche Anfragen (das Schl√ºsselwort ‚Äûsame‚Äú) f√ºr den Zeitraum dieser 8 Sekunden nichts tun, da sie warten, bis die Daten in result_cache geschrieben sind.  Andere Anfragen werden aufgezeichnet, warten jedoch nur in der ersten Zeile auf die Sperre.  Wie viel sie warten m√ºssen, ist unbekannt. Dies ist der undokumentierte Parameter result_cache_timeout.  Danach beginnen sie, result_cache sozusagen zu ignorieren und arbeiten langsam.  Sobald jedoch die Sperre der letzten Zeile an der T√ºr aufgehoben wurde, arbeiten sie automatisch wieder mit result_cache. <br><br>  2. Die zweite Art von Sperren - von result_cache auch von der ersten bis zur letzten Zeile zu empfangen. <br>  Da der Abruf jedoch aus dem Sofortspeicher stammt, werden sie sehr schnell entfernt. <br><br><img src="https://habrastorage.org/webt/pl/es/ds/plesds8v7w0qd8vjfrecofbmwno.jpeg"><br><br>  Denken Sie daran, dass der DBA, wenn er Latches in der Datenbank sieht, sagt: ‚ÄûLatches!  Wartezeit - alles ist weg!  ¬ªUnd hier beginnt das interessanteste Spiel: <strong>√úberzeugen Sie DBA davon, dass die Wartezeit von den Latches tats√§chlich unvergleichlich k√ºrzer ist als die Wiederholungszeit f√ºr Abfragen</strong> . <br><br><img src="https://habrastorage.org/webt/ii/du/sv/iidusv3bzptakrexkjrco7cubsw.jpeg"><br><br>  Wie unsere Erfahrung zeigt, <strong>belegen</strong> unsere Messungen, <strong>Latches f√ºr result_cache, 10% der Anforderungen selbst</strong> . <br><br><img src="https://habrastorage.org/webt/7-/o8/8a/7-o88agtahp-edtfts_lb2ss6s4.jpeg"><br><br>  Dies sind aggregierte Statistiken.  Die Tatsache, dass alles schlecht ist, kann durch die Tatsache verstanden werden, dass der Cache verstopft ist.  Eine weitere Best√§tigung ist, dass die richtigen Ergebnisse gel√∂scht werden.  Das hei√üt, der <strong>Cache wird √ºberschrieben</strong> .  Es scheint, dass wir klug sind und immer die Gr√∂√üe des Speichers ber√ºcksichtigen - wir haben die Zeilengr√∂√üe unseres zwischengespeicherten Ergebnisses f√ºr unsere Empfehlung verwendet, multipliziert mit der Anzahl der Zeilen, und etwas ist schiefgegangen. <br><br><img src="https://habrastorage.org/webt/mg/lh/5e/mglh5eorzkulnfqoewvrreqpb_u.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Unterst√ºtzung wurden zwei Fehler gefunden, die besagen, dass </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bei einem √úberlauf von result_cache Leistungseinbu√üen auftreten</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Und dies wurde auch in demselben geheimen Patch behoben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Geheimnis ist, dass der Speicher in Bl√∂cken zugewiesen wird. </font><font style="vertical-align: inherit;">In unserem Fall wurde nat√ºrlich die Tatsache hinzugef√ºgt, dass sich die Arbeitsbelastung um das F√ºnffache erh√∂hte. </font><font style="vertical-align: inherit;">Daher muss bei der Berechnung der Speicher nicht mit der Breite Ihrer Daten multipliziert werden, sondern mit der Gr√∂√üe des Blocks, und dann wird es gl√ºcklich. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was kann noch angepasst werden? </font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter Meer: Es gibt dokumentierte und nicht dokumentierte Parameter. </font><font style="vertical-align: inherit;">Tats√§chlich ben√∂tigen wir nicht alle diese Parameter. </font></font><br><br><img src="https://habrastorage.org/webt/2i/qm/_j/2iqm_jbqws8mw7udadiwhkrngao.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Tat sind 4 Parameter ausreichend:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RESULT_CACHE_MAX_SIZE; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RESULT_CACHE_MAX_RESULT; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RESULT_CACHE_MODE; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> _RESULT_CACHE_MAX_TIMEOUT. </font></font><br></li></ul><br><img src="https://habrastorage.org/webt/bt/fr/wp/btfrwpqmjmcs6evdykbcvizgte4.jpeg"><br><br>     ‚Äî  .  ,    100   512,      6 . <br><br>    ,    - . , Invalidation Count = 10000. <br><br>   ,    .     ,   job  ,      . ,   .   job   ,    ,      . <br><br><img src="https://habrastorage.org/webt/2b/m0/dl/2bm0dl2vlmo6bbv16wyksdoora0.jpeg"><br><br>    , invalid     ,    . <strong>         40 </strong> . <br><br>  ,    .     ,     ,     Oracle.  ! <br><br><img src="https://habrastorage.org/webt/wj/dd/jw/wjddjwnlpkmemk8lglmb7rczgb0.jpeg"><br><br> <strong>SHELFLIVE</strong> ‚Äî ,    read-consistent  ,       10 ,   .        . ,     ,    . <br><br>      ‚Äî <strong>SNAPSHOT</strong> .  ,       ,     read-consistent    ‚Äî       . <br><br> <strong></strong> : <br><br><img src="https://habrastorage.org/webt/bj/ts/pd/bjtspdkmsfo2d2xicp_pmxgtqag.jpeg"><br><br><ol><li>  ‚Äî       SYS. </li><li>      . ,    ,  Oracle    ,     ,        .  , Oracle ,   ,   12.2     . ,  external  -    support,    . </li><li>    sql  pl/sql : current_date, current_time  .   ,     current_time,          . </li><li>    . </li><li>          ,    CLOB, BLOB  . </li></ol><br><h3> Result cache inside Oracle <br></h3><br> Result_cache ‚Äî   Oracle Core.        , ,    job  result_cache (,    hint,    )  ,    APEX. <br><br><img src="https://habrastorage.org/webt/6n/u3/wf/6nu3wfqtrqzz3n5r_kyfdfwfv8c.jpeg"><br><br> ,    Dynamic sampling    ,   ,      ,   result_cache. <br><br><img src="https://habrastorage.org/webt/qa/gr/al/qagralka35xxjh68wtrfpprgrii.jpeg"><br><br><h2> Oracle internals for result cache <br></h2><br>         result_cache: <br><br><ol><li>        (storage)   ; <br></li><li>         result_cache; <br></li><li> result_cache   shared pool. <br></li></ol><br><img src="https://habrastorage.org/webt/yx/29/pk/yx29pkuz-o_c4dbgk9dbjwbn0lm.jpeg"><br><br>  <strong>Vorteile:</strong> <br><br><ul><li>     . <br></li><li>           read-consistent. </li><li> Result_cache,   ,  . </li></ul><br>  <strong>Nachteile:</strong> <br><br><ul><li>    . <br></li><li>     ,    . <br></li></ul><br><h2>   ! <br></h2><br>      ,    .    support Oracle, ,  29  2017 .:   Oracle E-Business suite    result_cache,      . <br><br><img src="https://habrastorage.org/webt/zh/h3/eu/zhh3eud6fphqdaiuukx1yoklczu.jpeg"><br><br> ,       ,     .          support        ,    ,      . <br><br><img src="https://habrastorage.org/webt/qp/e8/5i/qpe85iwdofjvbxhgtrrihdjmxb4.jpeg"><br><br>             : <br><br><ol><li>  -    ; <br></li><li> , , , ,  v$result_cache_memory  dbms_result_cache.memory_report,       . <br></li></ol><br> ,     ,      ,   v_result_cache_objects  . <br><br><blockquote>   ,  support note ‚Äî   support ,   . <br></blockquote><br><img src="https://habrastorage.org/webt/me/ut/5o/meut5o7krxdlelwjxgavdxrq-fe.jpeg"><br><br>    ,       ,   :     - .    ,    ,      : <br><br><ol><li>  hint result_cache; </li><li>  hint no result_cache; </li><li>  black_list,  ,   ,   -. </li></ol><br> <strong>    ?</strong> <br><br><ul><li>   ,  - , ,      ; </li><li>     ,    ,   . ,   - ,  ,   . </li></ul><br>   , <strong>     ‚Äî     </strong> .  Oracle  ,  . <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Clientseitiger Ergebniscache </font></font><br></h3><br><img src="https://habrastorage.org/webt/mk/6s/5m/mk6s5m24srinff6gkhrmxxei7xu.jpeg"><br><br>  Das Diagramm seines Ger√§ts ist oben dargestellt. Dies sind die Hauptkomponenten der Datenbank und des Treibers. <br><br>  Beim ersten Zugriff auf die Clientseite geht der Ergebniscache in die vorkonfigurierte Datenbank, empf√§ngt die Gr√∂√üe des Clientcaches aus der Datenbank und installiert diesen Cache bei der ersten Verbindung einmalig auf dem Client.  Die zwischengespeicherte Abfrage greift zuerst auf die Datenbank zu und schreibt Daten in den Cache.  Die verbleibenden Threads fordern einen gemeinsam genutzten Treibercache an, wodurch Serverspeicher und -ressourcen gespart werden.  √úbrigens sendet der Treiber manchmal abh√§ngig von der Auslastung Statistiken √ºber die Verwendung des Caches an die Datenbank, die dann angezeigt werden k√∂nnen. <br><br>  <strong>Eine interessante Frage ist, wie kommt es zu einer Behinderung?</strong> <br><br>  Es gibt zwei Arten der Ung√ºltigmachung, die durch den Parameter Invalidierungsverz√∂gerung gesch√§rft werden.  Auf diese Weise l√§sst Oracle zu, dass der Treibercache nicht konsistent ist. <br><br>  Der erste Modus wird verwendet, wenn Anforderungen h√§ufig gestellt werden und die Invalidierungsverz√∂gerung nicht auftritt.  In diesem Fall wird der Stream in die Datenbank verschoben, die Caches aktualisiert und die Daten daraus gelesen. <br><br><img src="https://habrastorage.org/webt/ah/wo/u1/ahwou1tplbgyiq4w8lizx0raeto.jpeg"><br><br>  Wenn die Invalidierungsverz√∂gerung fehlschl√§gt, wird f√ºr jede nicht zwischengespeicherte Anforderung, die sich auf die Datenbank bezieht, zus√§tzlich zu den Abfrageergebnissen eine Liste ung√ºltiger Objekte angezeigt.  Dementsprechend werden sie im Cache als ung√ºltig markiert, und alles funktioniert wie im Bild aus dem ersten Szenario. <br><br>  Im zweiten Fall, wenn mehr Zeit als die Invalidierungsverz√∂gerung vergangen ist, geht der client result_cache selbst in die Datenbank und sagt: "Geben Sie mir eine Liste der √Ñnderungen!"  Das hei√üt, er selbst beh√§lt seinen angemessenen Zustand bei. <br><br>  <strong>Das Konfigurieren des clientseitigen Ergebniscaches ist sehr einfach</strong> .  Es gibt 2 M√∂glichkeiten: <br><br><ol><li>  CLIENT_RESULT_CACHE_LAG - Cache-Verz√∂gerungswert; </li><li>  CLIENT_RESULT_CACHE_SIZE - Gr√∂√üe (mindestens 32 KB, maximal 2 GB). </li></ol><br><img src="https://habrastorage.org/webt/ky/zl/mh/kyzlmhtgmgjkodcgtwkjm6sqoym.jpeg"><br><br>  Aus Sicht des Anwendungsentwicklers unterscheidet sich der Client-Cache nicht sehr vom Server-Cache, sondern sie haben auch den Hinweis result_cache eingegeben.  Wenn dies der Fall ist, wird es nur vom Client verwendet - sowohl unter .NET als auch unter Java. <br><br><img src="https://habrastorage.org/webt/xo/bv/of/xobvof-_m9gwfhdocpw5dywqshe.jpeg"><br><br>  Nachdem ich 10 Iterationen der Abfrage durchgef√ºhrt hatte, erhielt ich Folgendes. <br><br><img src="https://habrastorage.org/webt/vq/zs/di/vqzsdifg9jkvb18jnrgy_bu9je4.jpeg"><br><br>  Der erste Aufruf ist die Erstellung, dann 9 Cache-Zugriffe.  Die Tabelle zeigt an, dass der Speicher auch in Bl√∂cken zugeordnet ist.  Achten Sie auch auf SELECT - es ist nicht sehr intuitiv.  Um ehrlich zu sein, bevor ich damit anfing, wusste ich nicht einmal, dass es eine solche Darstellung von <code>GV$SESSION_CONNECT_INFO</code> .  Warum Oracle es nicht direkt in diese Tabelle aufgenommen hat (und dies ist eine Tabelle, keine Ansicht), konnte ich nicht verstehen.  Deshalb glaube ich, dass diese Funktionalit√§t nicht sehr beliebt ist, obwohl sie meiner Meinung nach sehr n√ºtzlich ist. <br><br>  <strong>Vorteile des Client-Caching:</strong> <br><br><ul><li>  billiger Client-Speicher; </li><li>  jeder verf√ºgbare Treiber - JDBC, .NET usw.; </li><li>  minimale Auswirkung auf den Anwendungscode. </li><li>  Reduzierung der Belastung der CPU, der E / A und allgemein der Datenbank; </li><li>  Sie m√ºssen nicht alle Arten von Smart-Caching-Ebenen und APIs lernen und verwenden. </li><li>  keine Riegel. </li></ul><br>  <strong>Nachteile:</strong> <br><br><ul><li>  Konsistenz beim Lesen mit Verz√∂gerung - im Prinzip ist dies nun ein Trend; </li><li>  ben√∂tigen Oracle OCI Client; </li><li>  Beschr√§nkung auf 2 GB pro Client, aber im Allgemeinen sind 2 GB viel; </li><li>  F√ºr mich pers√∂nlich ist die Hauptbeschr√§nkung ein paar Informationen √ºber die Produktion. </li></ul><br>  Bei der Unterst√ºtzung, die wir immer bei der Arbeit mit result_cache verwenden, habe ich nur 5 Fehler gefunden.  Dies deutet darauf hin, dass es h√∂chstwahrscheinlich nur wenige Menschen brauchen. <br><br>  Also bringen wir alles zusammen, was oben gesagt wurde. <br><br><h3>  <strong>Handgemachter Cache</strong> <br></h3><br>  <strong>Schlechte Szenarien:</strong> <br><br><ul><li>  Sofortige √Ñnderung - Wenn der Cache nach dem √Ñndern der Daten sofort irrelevant wird.  Bei selbst erstellten Caches ist es schwierig, bei √Ñnderungen an den Objekten, auf denen sie basieren, die richtige Ung√ºltigmachung zu erstellen. </li><li>  Wenn die Verwendung von in der Datenbank gespeicherter Logik durch Entwicklungsrichtlinien verboten ist. </li></ul><br>  <strong>Gute Szenarien:</strong> <br><br><ul><li>  Es gibt ein starkes Datenbankentwicklungsteam. </li><li>  Implementierte PL / SQL-Logik. </li><li>  Es gibt Einschr√§nkungen, die verhindern, dass andere Caching-Techniken verwendet werden. </li></ul><br><h3>  <strong>Serverseitiger Ergebniscache</strong> <br></h3><br>  <strong>Schlechte Szenarien:</strong> <br><br><ul><li>  Viele verschiedene Ergebnisse, die nur den gesamten Cache waschen; </li><li>  Anforderungen dauern l√§nger als _RESULT_CACHE_TIMEOUT oder dieser Parameter ist falsch konfiguriert. </li><li>  Ergebnisse von sehr gro√üen Sitzungen werden in parallelen Threads in den Cache geladen. </li></ul><br>  <strong>Gute Szenarien:</strong> <br><br><ul><li>  Angemessene Anzahl zwischengespeicherter Ergebnisse. </li><li>  Relativ kleine Datens√§tze (200‚Äì300 Zeilen). </li><li>  Ziemlich teures SQL, sonst wird die ganze Zeit an Latches gehen. </li><li>  Mehr oder weniger statische Tabellen. </li><li>  Es gibt einen DBA, der im Falle von etwas kommt und alle rettet. </li></ul><br><h3>  <strong>Clientseitiger Ergebniscache</strong> <br></h3><br>  <strong>Schlechte Szenarien:</strong> <br><br><ul><li>  Wenn das Problem der sofortigen Behinderung auftritt. </li><li>  D√ºnne Treiber erforderlich. <br></li></ul><br>  <strong>Gute Szenarien:</strong> <br><br><ul><li>  Es gibt ein normales Entwicklungsteam f√ºr die mittlere Schicht. </li><li>  Es wird bereits viel SQL verwendet, ohne dass eine externe Caching-Schicht verwendet wird, die problemlos verbunden werden kann. </li><li>  Es gibt Einschr√§nkungen f√ºr die Dr√ºsen. </li></ul><br><br><h2>  Schlussfolgerungen <br></h2><br>  Ich glaube, dass meine Geschichte √ºber serverseitige Ergebnis-Cache-Schmerzen handelt, daher lauten die Schlussfolgerungen wie folgt: <br><br><ol><li>  Bewerten Sie die Speichergr√∂√üe immer korrekt unter Ber√ºcksichtigung der Anzahl der Abfragen und nicht der Anzahl der Ergebnisse, d. H.: Bl√∂cke, APEX, Job, adaptive Statistiken usw. </li><li>  Haben Sie keine Angst, automatische Cache-Leergutoptionen (Snapshot + Shelflife) zu verwenden. </li><li>  √úberladen Sie den Cache nicht mit Anforderungen, w√§hrend Sie gro√üe Datenmengen laden. Deaktivieren Sie zuvor result_cache.  Erw√§rmen Sie den Cache. </li><li>  Stellen Sie sicher, dass _result_cache_timeout Ihren Erwartungen entspricht. </li><li>  Verwenden Sie FORCE NIEMALS f√ºr die gesamte Datenbank.  Ben√∂tigen Sie eine Datenbank im Speicher? Verwenden Sie eine spezielle In-Memory-L√∂sung. </li><li>  √úberpr√ºfen Sie, ob die FORCE-Option f√ºr einzelne Tabellen geeignet ist, damit sie nicht wie bei einer ETL eines Drittanbieters funktioniert. </li><li>  Entscheiden Sie, ob die adaptiven Statistiken so gut sind wie von Oracle beschrieben (_optimizer_ads_use_result_cache = false). </li></ol><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Highload ++ Siberia am</a> kommenden Montag ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeitplan</a> fertig und wird auf der Site ver√∂ffentlicht.  Es gibt mehrere Berichte zum Thema dieses Artikels: <br><br><ul><li>  <strong>Alexander Makarov</strong> (CFT GC) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wird am</a> Beispiel der Oracle-Datenbank <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine</a> Methode zur Identifizierung von Engp√§ssen auf der Serverseite der Software <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">demonstrieren</a> . <br></li><li>  <strong>Ivan Sharov</strong> und <strong>Konstantin Poluektov erkl√§ren</strong> Ihnen, welche Probleme bei der Migration des Produkts auf neue Versionen der Oracle-Datenbank auftreten, und versprechen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, Empfehlungen</a> zur Organisation und Durchf√ºhrung solcher Arbeiten zu geben. <br></li><li>  <strong>Nikolay Golov</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erkl√§rt Ihnen,</a> wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> die Datenintegrit√§t in einer Microservice-Architektur ohne verteilte Transaktionen und enge Konnektivit√§t sicherstellen k√∂nnen. <br></li></ul><br>  <strong>Treffen Sie mich in Nowosibirsk!</strong> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414401/">https://habr.com/ru/post/de414401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414389/index.html">Analysieren von Cisco-Ger√§teprotokollen mit Splunk Cisco Security Suite</a></li>
<li><a href="../de414393/index.html">Sprachgesteuerter Roboter im Jahr 1961</a></li>
<li><a href="../de414395/index.html">Einfacher als es klingt. Bruch</a></li>
<li><a href="../de414397/index.html">FCS schl√§gt vor, den Duty-Free-Schwellenwert auf Null zu senken</a></li>
<li><a href="../de414399/index.html">Der Einsatz digitaler Produktion in der realen Wirtschaft und Bildung</a></li>
<li><a href="../de414403/index.html">Fujitsu hat eine neue molekulare Modellierungstechnologie entwickelt</a></li>
<li><a href="../de414405/index.html">Installieren Sie das Zertifikat auf dem Apache HTTP-Server</a></li>
<li><a href="../de414411/index.html">Wiren Board 6: wieder auf Habr√© mit der neuen Version der Steuerung f√ºr die Automatisierung</a></li>
<li><a href="../de414413/index.html">Zusammenfassung und Video der Geschichte √ºber das Networking in der Spielebranche mit dem Gamedev des Festivals</a></li>
<li><a href="../de414415/index.html">Tarantool-Konferenz 21. Juni - nicht nur √ºber Tarantool, sondern allgemein √ºber In-Memory-Computing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>