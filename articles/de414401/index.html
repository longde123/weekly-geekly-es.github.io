<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥟 👨🏽‍💼 🧕🏽 100.500 Caching-Methoden in der Oracle-Datenbank 🚱 🌹 🥄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zu sagen, was Caches sind, was Ergebnis-Cache ist, wie es in Oracle und in anderen Datenbanken erstellt wird, ist nicht sehr interessant und hübsch. A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>100.500 Caching-Methoden in der Oracle-Datenbank</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/414401/">  Zu sagen, was Caches sind, was Ergebnis-Cache ist, wie es in Oracle und in anderen Datenbanken erstellt wird, ist nicht sehr interessant und hübsch.  Aber bei bestimmten Beispielen nimmt alles ganz andere Farben an.  <strong>Alexander Tokarev</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">shtock</a> ) hat seinen Bericht über Highload ++ 2017 basierend auf Fällen erstellt.  Und genau auf der Grundlage von Fällen sagte er mir, wann ein selbst erstellter Cache praktisch sein könnte, was der serverseitige Ergebniscache schmerzt und wie er durch einen clientseitigen ersetzt werden kann, und im Allgemeinen habe ich eine Reihe nützlicher Tipps zum Einrichten des Ergebniscaches in Oracle angesprochen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/hTCXaAKIArk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Über den Redner:</strong> Alexander Tokarev arbeitet bei DataArt und befasst sich mit Fragen im Zusammenhang mit Datenbanken, sowohl im Hinblick auf das Erstellen von Systemen von Grund auf als auch auf die Optimierung bestehender Systeme. <br><br>  Beginnen wir mit ein paar rhetorischen Fragen.  Haben Sie mit Oracle Result Cache gearbeitet?  Glauben Sie, dass Oracle eine Datenbank ist, die für alle Gelegenheiten geeignet ist?  Nach Alexanders Erfahrung verneinen die meisten Menschen die letzte Frage, <strong>einhundert Träumer haben einen Träumer</strong> .  Aber dank seines Glaubens bewegt sich der Fortschritt. <br><br>  Übrigens hat Oracle bereits 14 Datenbanken - bisher 14 - was in Zukunft passieren wird, ist unbekannt. <br><br>  Wie bereits erwähnt, werden alle Probleme und Lösungen in bestimmten Fällen dargestellt.  Dies sind zwei Fälle aus DataArt-Projekten und ein Beispiel eines Drittanbieters. <br><a name="habracut"></a><br><h2>  Datenbank-Caches <br></h2><br>  Zunächst, welche Caches sich in den Datenbanken befinden.  Hier ist alles klar: <br><br><ul><li>  Puffercache - Datencache - Cache für Datenseiten / Datenblöcke; </li><li>  Anweisungscache - Cache von Anweisungen und ihren Plänen - Cache von Abfrageplan; </li><li>  Ergebnis-Cache - Cache der Zeilenergebnisse - Zeilen aus Abfragen; </li><li>  Betriebssystem-Cache - Betriebssystem-Cache. </li></ul><br>  Darüber hinaus wird der Ergebnis-Cache im Großen und Ganzen nur in Oracle verwendet.  Er war einmal in MySQL, aber dann wurde er heldenhaft herausgeschnitten.  In PostgreSQL ist es auch nicht vorhanden, es ist in der einen oder anderen Form nur im pgpool-Produkt eines Drittanbieters vorhanden. <br><br><h2>  Fall 1. Händlergewölbe <br></h2><br><img src="https://habrastorage.org/webt/qo/cq/t5/qocqt5zzctiqj1hh5n-6hc9skkm.jpeg"><br><br>  Oben sehen Sie das Produktdiagramm, das wir begleitet haben - das Repository (Oracle 11, 20 TB, 300 Benutzer), und es enthält eine Art trostlosen Bericht, in dem 350 eindeutige Produkte pro 5000 Datenzeilen enthalten waren.  Es dauerte ungefähr 20 Minuten, und die Benutzer waren traurig. <br><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Präsentation</a> dieses Berichts ist wie alle anderen auf der Highload ++ - Konferenzseite verfügbar. </blockquote><br>  Dieser Bericht enthält SELECT, JOINs und eine Funktion.  Eine Funktion als Funktion, alles wäre in Ordnung, nur berechnet sie einen mysteriösen Parameter namens "Verrechnungspreiswert", es funktioniert für 0,2 s - es scheint nichts zu sein, aber es wird so oft aufgerufen, wie es Zeilen in der Tabelle gibt.  Diese Funktion hat seitdem 400 Zeilen SQL + PL / SQL  Das Produkt wird unterstützt. Es ist beängstigend, es zu ändern. <br><br>  Aus dem gleichen Grund konnte result_cache nicht verwendet werden. <br><br><img src="https://habrastorage.org/webt/1o/u5/ct/1ou5ctbufxqrsme66mbz60bieuy.jpeg"><br><br>  Um das Problem zu lösen, verwenden wir den Standardansatz <strong>mit handgemachtem Caching</strong> : Wir belassen die ersten 3 Blöcke der Schaltung so wie sie waren, benennen einfach unsere Funktion sku_detail () in sku_full () um und deklarieren ein assoziatives Array, wobei: <br><br><ul><li>  Schlüssel sind unsere SKUs (Commodity Items), <br></li><li>  Die Werte sind der berechnete Transferumwandlungspreis. <br></li></ul><br>  Wir machen die Cache-Funktion (sku) offensichtlich: Wenn unser assoziatives Array keine solche ID enthält, wird unsere Funktion gestartet, das Ergebnis zwischengespeichert, gespeichert und zurückgegeben.  Wenn dementsprechend eine solche ID vorliegt, geschieht dies alles nicht.  Tatsächlich haben wir einen <strong>On-Demand-Cache erhalten</strong> . <br><br>  Daher haben wir die Anzahl der Funktionsaufrufe auf den tatsächlich benötigten Betrag reduziert.  <strong>Die Bearbeitungszeit für Berichte verringerte sich auf 4 Minuten</strong> . Alle Benutzer fühlten sich gut. <br><br><h3>  <strong>Handgemachter Cache-Speicher</strong> <br></h3><br>  Die Nachteile und Vorteile dieses Systems werden aus diesem großen intelligenten Bild deutlich, auf das wir viel eingehen werden - dies ist die Speicherarchitektur. <br><br><img src="https://habrastorage.org/webt/ku/e4/2o/kue42onfhkjjpxxyk0klg0-at50.jpeg"><br><br>  Es ist wichtig zu verstehen, in welchem ​​Speicherbereich sich die Sammlungen befinden.  Sie befinden sich in einem Speicherbereich namens PGA.  <strong>Der globale Programmbereich wird</strong> bei jeder Verbindung zur Datenbank instanziiert.  Dies bestimmt die Vor- und Nachteile, da mehr Verbindungen - mehr Speicher und <strong>teurer Speicher, Server</strong> , Administratoren - zart sind. <br><br><img src="https://habrastorage.org/webt/7c/gi/hd/7cgihdigefzcded25cmfondxkcc.jpeg"><br><br><ul><li>  <strong>Vorteile:</strong> Alles funktioniert sehr schnell, ist sehr einfach zu erledigen, keine Konfiguration erforderlich, keine Probleme mit der Interprozessbeteiligung. <br></li><li>  <strong>Die Nachteile</strong> sind verständlich: Wenn gespeicherte Logik im Projekt verboten ist, können sie nicht verwendet werden, es gibt keinen Mechanismus für die automatische Ungültigmachung, und da der Speicher im Cache innerhalb einer Datenbanksitzung und nicht einer Instanz zugewiesen wird, wird sein <strong>Verbrauch überbewertet</strong> .  Darüber hinaus müssen Sie im Fall des Anwendungsfalls des Verbindungspools daran denken, die Caches zu leeren, wenn für jede Sitzung ein anderes Caching vorhanden sein sollte. <br></li></ul><br>  Es gibt andere Optionen für handgefertigte Caches, die auf materialisierten Ansichten und temporären Tabellen basieren, aber von diesen wird das Eingabe-Ausgabe-System stark belastet, sodass wir sie hier nicht berücksichtigen.  Sie sind eher auf andere Datenbanken anwendbar, in denen solche Probleme normalerweise gelöst werden, indem die gespeicherte Prozedur in einer Zwischentabelle gespeichert und die Daten daraus entnommen werden, bevor auf eine umfangreiche Anforderung zugegriffen wird.  Und nur wenn nicht gefunden wurde, was benötigt wird, wird die erste Anfrage aufgerufen. <br><br><img src="https://habrastorage.org/webt/mh/8u/xg/mh8uxg2hjytjwrp0fbds1gvoc4k.jpeg"><br><br>  Das Obige veranschaulicht diesen Ansatz für das Caching-Problem, um eine Liste verwandter Produkte in MsSQL zu erhalten.  Im Allgemeinen ist der Ansatz relativ ähnlich, funktioniert jedoch im Datenbankspeicher nicht sowohl hinsichtlich des Abrufs von Daten als auch hinsichtlich der Primärfüllung. Aufgrund dessen <strong>kann er langsamer sein</strong> . <br><br>  Im Allgemeinen wird der selbst erstellte result_cache aktiv verwendet, der datenbankinterne result_cache ist jedoch ein anderer Ansatz für die Implementierung dieser Aufgabe.  Es und wie es nicht schnell geklappt hat, werden wir weiter überlegen. <br><br><h2>  Fall 2. Verarbeitung der Finanzdokumentation <br></h2><br>  Also unser zweiter Fall. <br><br><img src="https://habrastorage.org/webt/dd/zn/wy/ddznwymy92vgt32eox6fvwanepq.jpeg"><br><br>  Dies ist ein halbautomatisches Verarbeitungssystem für Finanzdokumentationen - ein trostloses Unternehmen mit einer klassischen Architektur, das Folgendes umfasst: <br><br><ul><li>  Thin Client; <br></li><li>  4.000 Benutzer, die in verschiedenen Teilen der Welt leben; <br></li><li>  Balancer; <br></li><li>  2 JBoss zur Berechnung der Geschäftslogik; <br></li><li>  In-Memory-Cluster; <br></li><li>  Kern Oracle; <br></li><li>  Oracle-Backup <br></li></ul><br>  Eine der vielen Aufgaben dieses Systems ist die <strong>Berechnung von Empfehlungen</strong> . <br><br><img src="https://habrastorage.org/webt/dm/rt/cf/dmrtcfcgvy2q94g-jl52qnhatbo.jpeg"><br><br>  Es gibt Dokumente. Für jeden Indikator, der vom System nicht automatisch erkannt wird, wird eine Reihe von Indikatoren entweder aus früheren Kundendokumenten oder aus einer ähnlichen Branche oder mit ähnlicher Rentabilität angeboten, während der Indikator mit dem erkannten Wert verglichen wird, um nicht zu viel zu bieten.  Wichtig ist, dass die <strong>Dokumente mehrsprachig sind</strong> . <br><br>  Der Benutzer wählt den gewünschten Wert aus und wiederholt den Vorgang für jede leere Zeile. <br><br>  Vereinfacht gesagt besteht diese Aufgabe aus Folgendem: Dokumente kommen in Form von Schlüssel-Wert-Paaren aus verschiedenen Erkennungssystemen an, und Parameter werden irgendwo erkannt, aber nicht irgendwo.  Es muss sichergestellt werden, dass die Benutzer am Ende die Dokumente verarbeiten und alle Werte erkannt werden.  Die Empfehlung zielt genau auf die Vereinfachung dieser Aufgabe ab und berücksichtigt: <br><br><ol><li>  Mehrsprachigkeit - ca. 30 Sprachen.  Jede Sprache hat ihre eigenen Stämme, Synonyme und andere Merkmale. </li><li>  Die vorherigen Daten dieses Kunden oder, falls nicht vorhanden, die Daten eines Kunden aus derselben Branche oder eines Kunden mit ähnlichem Gewinn. </li></ol><br>  In der Tat sind dies ungefähr 12 sehr komplexe Regeln. <br><br>  <strong>Anfangsannahmen:</strong> <br><br><ul><li>  Nicht mehr als 100 Benutzer gleichzeitig; </li><li>  2-3 Spalten zur Erkennung; </li><li>  100 Zeilen. </li></ul><br>  <strong>Überhaupt keine Hochlast</strong> - alles ist langweilig. <br><br>  Es ist also Zeit für die Veröffentlichung.  Das Einfrieren des Codes ist passiert, Java hat Angst vor Berührungen und die Verarbeitung eines Dokuments dauert mindestens 5 Minuten. <br><br>  Sie kommen zum Datenbankentwicklungsteam und bitten um Hilfe.  Natürlich, denn <em>wenn sich etwas in der JVM verlangsamt, müssen Sie die Datenbank selbst ändern oder reparieren</em> . <br><br><img src="https://habrastorage.org/webt/ae/q_/tm/aeq_tm3cua2tkk3ohgxl7rntova.jpeg"><br><br>  Wir haben die Dokumente untersucht und festgestellt, dass Werte in Schlüssel-Wert-Paaren häufig wiederholt werden - 5-10 Mal.  Dementsprechend haben wir uns entschieden, die Datenbank zum Zwischenspeichern zu verwenden, da sie bereits getestet wurde. <br><br>  Wir haben uns für den serverseitigen Ergebniscache von Oracle entschieden, weil: <br><br><ol><li>  Die Möglichkeiten zur Optimierung von SQL wurden ausgeschöpft, da die Oracle-Volltextsuchmaschine verwendet wird. <br></li><li>  Der Cache wird für doppelte Parameter verwendet. <br></li><li>  Die meisten Daten für Empfehlungen werden einmal pro Stunde neu berechnet, da sie einen Volltextindex verwenden. <br></li><li>  <strong>PL / SQL ist verboten</strong> . <br></li></ol><br><h3>  <strong>Oracle-Ergebniscache</strong> <br></h3><br>  Der Ergebnis-Cache - Oracle-Caching von Ergebnissen - hat die folgenden Eigenschaften: <br><br><ul><li>  Dies ist der Speicherbereich, in dem alle Abfrageergebnisse durchsucht werden. </li><li>  Lesen Sie konsistent, und seine automatische Ungültigmachung tritt auf; </li><li>  Es sind nur minimale Änderungen an der Anwendung erforderlich.  Sie können dafür sorgen, dass die Anwendung überhaupt nicht geändert werden muss. </li><li>  Bonus - Sie können PL / SQL-Logik zwischenspeichern, dies ist hier jedoch verboten. </li></ul><br>  <strong>Wie aktiviere ich es?</strong> <br><br><h4>  Methodennummer 1 <br></h4><br><img src="https://habrastorage.org/webt/qo/im/jv/qoimjvcbfclnfsp_pncn6uf-74g.jpeg"><br><br>  Es ist sehr einfach <strong>, die Anweisung result_cache anzugeben</strong> .  Die Folie zeigt, dass die Ergebniskennung angezeigt wurde.  Dementsprechend führt die Datenbank bei der ersten Ausführung der Abfrage einige Arbeiten aus, während der nachfolgenden Ausführung ist in diesem Fall keine Arbeit erforderlich.  Alles ist gut. <br><br><h4>  Methode Nummer 2 <br></h4><br><img src="https://habrastorage.org/webt/5x/uy/d5/5xuyd5seajh5kshz1xmdvmd6fu0.jpeg"><br><br>  Der zweite Weg ermöglicht es Anwendungsentwicklern, nichts zu tun - dies sind die sogenannten Annotationen.  Wir geben ein Häkchen für die Tabelle an, dass die Anforderung an sie in result_cache gestellt werden soll.  Dementsprechend gibt es keinen Hinweis, wir berühren die Anwendung nicht und alles befindet sich bereits im result_cache. <br><br><blockquote>  Was denken Sie übrigens, wenn sich eine Abfrage auf zwei Tabellen bezieht, von denen eine als result_cache markiert ist und die zweite nicht, wird das Ergebnis einer solchen Abfrage zwischengespeichert? <br><br>  Die Antwort ist nein, überhaupt nicht. <br></blockquote><br>  Damit es zwischengespeichert werden kann, müssen alle an der Abfrage beteiligten Tabellen mit der Annotation result_cache versehen sein. <br><br><h3>  <strong>Abhängigkeitsverfolgung</strong> <br></h3><br>  Es gibt relevante Ansichten, in denen Sie sehen können, welche Abhängigkeiten bestehen. <br><br><img src="https://habrastorage.org/webt/ni/12/bp/ni12bpiy04zhswxncy1rsq1h29s.jpeg"><br><br>  Im obigen Beispiel ist die JOIN-Abfrage eine Tabelle, in der es eine Abhängigkeit gibt.  Warum?  Weil Oracle die Abhängigkeit nicht nur durch Parsen bestimmt, sondern sie <strong>entsprechend den Ergebnissen des Arbeitsplans</strong> implementiert. <br><br>  In diesem Fall wurde ein solcher Plan ausgewählt, da nur eine Tabelle verwendet wird und die Jobtabelle über eine Fremdschlüsseleinschränkung mit der Mitarbeitertabelle verknüpft ist.  Wenn wir die Fremdschlüsseleinschränkung entfernen, die diese Join-Eliminierungstransformation ermöglicht, werden zwei Abhängigkeiten angezeigt, da sich der Plan auf diese Weise ändert. <br><br>  <strong>Oracle verfolgt nicht, was nicht verfolgt werden muss</strong> . <br><br>  In PL / SQL wird die Abhängigkeit zur Laufzeit ausgeführt, sodass Sie dynamisches SQL verwenden und andere Aufgaben ausführen können. <br><br><img src="https://habrastorage.org/webt/3j/nh/fk/3jnhfkrft2dgbs-4nyvnwg6nfkm.jpeg"><br><br>  Bitte beachten Sie, dass Sie nicht nur die gesamte Anforderung zwischenspeichern können, sondern <strong>auch die Inline-Ansicht mit und von zwischenspeichern können</strong> .  Nehmen wir zum einen an, wir brauchen einen Cache, und zum anderen ist es besser, aus der Datenbank zu lesen, um ihn nicht zu belasten.  Wir nehmen eine Inline-Ansicht, deklarieren sie erneut als result_cache und stellen fest, dass nur ein Teil zwischengespeichert wird, und für den zweiten greifen wir jedes Mal auf die Datenbank zu. <br><br><img src="https://habrastorage.org/webt/zq/ze/7z/zqze7zgbnbljnme7a9j8qfbewdo.jpeg"><br><br>  Und schließlich haben die <strong>Datenbanken auch eine Kapselung</strong> , obwohl niemand daran glaubt.  Wir sehen uns das an, setzen result_cache ein und unsere Programmierer erkennen nicht einmal, dass es zwischengespeichert ist.  Unten sehen wir, dass tatsächlich nur ein Teil davon funktioniert. <br><br><img src="https://habrastorage.org/webt/-x/-a/mt/-x-amt3jzaygadispddtfx_fojy.jpeg"><br><br><h3>  Behinderung <br></h3><br>  Lassen Sie uns also sehen, wann Oracle result_cache ungültig macht. Der Status "Veröffentlicht" zeigt den aktuellen Status der Cache-Gültigkeit an.  Bei der Anforderung an result_cache befinden sich, wie gesagt, keine Jobs in der Datenbank <br><br><img src="https://habrastorage.org/webt/uv/9b/at/uv9batcfvtszo6tudxpovnhzy8s.jpeg"><br><br>  Wenn wir das Update durchgeführt haben, ist der Status immer noch veröffentlicht, da das Update nicht festgeschrieben wurde und andere Sitzungen den alten result_cache sehen sollten.  Dies ist die berüchtigte Lesekonsistenz. <br><br>  In der aktuellen Sitzung werden wir jedoch feststellen, dass die Last weg ist, da in dieser Sitzung der Cache ignoriert wird.  Das ist ziemlich vernünftig, machen wir ein Commit - das Ergebnis wird ungültig, alles funktioniert von selbst. <br><br><img src="https://habrastorage.org/webt/-r/sn/rt/-rsnrtdyj9bk6vthaott4qondaq.jpeg"><br><br>  Es scheint - ein Traum!  Die Abhängigkeit wird als korrekt angesehen - nur abhängig von der Anforderung.  Aber nein, eine Reihe von Nuancen wurden enthüllt.  <strong>Oracle produziert Behinderungen und in einer Reihe von nicht offensichtlichen Fällen</strong> : <br><br><ol><li>  Bei jedem Aufruf von SELECT FOR UPDATE verschwinden die Abhängigkeiten. </li><li>  Wenn die Tabelle nicht indizierte Fremdschlüssel enthält und eine Aktualisierung der mit result_cache gekennzeichneten Tabelle erfolgt, die sich auf nichts auswirkt, sich jedoch in der übergeordneten Tabelle etwas geändert hat, wird der Cache ebenfalls ungültig. </li><li>  Dies ist die interessanteste Sache, die das Leben so sehr wie möglich beeinträchtigt - wenn die als result_cache gekennzeichnete Tabelle nicht erfolgreich aktualisiert wurde, hat nichts funktioniert, aber in derselben Transaktion wurden alle anderen Änderungen angewendet, die sich irgendwie auf die erste Tabelle auswirkten result_cache wird zurückgesetzt. </li></ol><br>  Es gibt immer noch ein solches Antipattern bei result_cache, wenn Entwickler, die gehört haben, dass es so eine coole Sache gibt, denken: „Oh, da ist Speicher!  Jetzt nehmen wir eine Anfrage entgegen, die auf 2-3 Partitionen funktioniert - markieren Sie sie am aktuellen und am vorherigen Datum als result_cache und sie wird immer aus dem Speicher genommen! " <br><br>  Wenn Sie jedoch im Nachhinein Patricia ändern, fliegt der gesamte Cache, da die Einheit der Abhängigkeitsverfolgung in result_cache immer eine Tabelle ist und ich nicht weiß, ob es jemals Partitionen geben wird oder nicht. <br><br>  Wir dachten und beschlossen, mit solchen Dingen ein Empfehlungssystem zu erstellen: <br><br><ul><li>  <strong>Wir werden nicht alle unsere Tabellen zwischenspeichern, wir werden nur die notwendigen nehmen.</strong> <br></li><li>  <strong>Legen Sie result_cache für die lang laufende Abfrage fest.</strong> <br></li></ul><br>  Wir haben alles überprüft, Leistungstests durchgeführt, <strong>Verarbeitungszeit - 30 s</strong> .  Alles ist toll, geh in die Produktion! <br><br>  Abgestürzt - ging schlafen.  Wir kommen am Morgen an.  Wir sehen einen Brief: "Die Erkennung dauert mindestens 20 Minuten, die Sitzungen frieren ein."  Warum frieren sie?  Wie wurden aus <strong>30 Sekunden 20 Minuten</strong> ? <br><br>  Sie begannen zu verstehen, schauten in die Datenbank: <br><br><ul><li>  aktive Sitzungen - 400; </li><li>  durchschnittlich Zeilen in einem Dokument zur Anerkennung - 500; </li><li>  Spalten mindestens - 5-8; </li><li>  Die Anzahl der Sitzungen in der Datenbank entspricht immer der Anzahl der Benutzeranwendungen multipliziert mit 3!  Und result_cache mag keinen häufigen Zugriff darauf. </li></ul><br>  Nach einer internen Untersuchung stellten wir fest, dass Java-Entwickler in drei Threads erkennen. <br><br>  Wir waren verärgert - eine 5-fache Belastung, ein Abfall, eine Verschlechterung und selbst mit solchen Parametern hätte ein solches Absinken nicht passieren dürfen. <br><br>  Natürlich müssen Sie verstehen. <br><br><h3>  Überwachung <br></h3><br><img src="https://habrastorage.org/webt/b6/iq/iw/b6iqiwwevjqyua9xr6p8j2aq0bu.jpeg"><br><br>  Für die Überwachung haben wir zwei wichtige Dinge: <br><br><ol><li>  V $ RESULT_CACHE_OBJECTS - eine Liste aller Objekte; </li><li>  V $ RESULT_CACHE_STATISTICS - Aggregierte Statistik des gesamten Ergebniscaches. </li></ol><br>  MEMORY_REPORT sind Variationen eines Themas, wir werden sie nicht brauchen. <br><br>  Oracle ist magisch!  Es gibt eine großartige Dokumentation, die jedoch für diejenigen gedacht ist, die von anderen Datenbanken wechseln, damit sie lesen und denken, dass Oracle sehr cool ist!  <strong>Alle Informationen zu result_cache liegen jedoch nur bei der Unterstützung</strong> . <br><br><img src="https://habrastorage.org/webt/vm/u1/bt/vmu1bt35lwpsvebw9o-rnxxasgs.jpeg"><br><br>  Es gibt eine Nuance, die darin besteht, dass wir, sobald wir uns diesen Objekten zuwenden, um das Problem zu lösen, es verschärfen, indem wir uns endgültig begraben!  Bis Oracle12.2, vor dessen Patch es im Oktober letzten Jahres veröffentlicht wurde, machen diese Anforderungen result_cache für den Status und das Schreiben unzugänglich, bis sie vollständig gezählt sind. <br><br><img src="https://habrastorage.org/webt/8b/nd/4y/8bnd4ygeerwxy7n38lqjrqrfwnw.jpeg"><br><br>  In der Ansicht v $ result_cache_objects haben wir festgestellt, dass die Liste der zwischengespeicherten Objekte Tausende von Einträgen enthält - viel mehr als erwartet.  Darüber hinaus waren dies Objekte aus einigen unserer Abfragen in seltsamen Tabellen - kleine Tablets und last_modified_date-Abfragen.  Offensichtlich hat <strong>jemand ETL auf unsere Basis gesetzt</strong> . <br><br>  Bevor wir uns bei ETL-Entwicklern beschworen haben, haben wir überprüft, ob die Option result_cache force für diese Tabellen aktiviert ist, und uns daran erinnert, dass wir sie selbst aktiviert haben, da einige dieser Daten häufig von der Anwendung benötigt wurden und das Caching angemessen war. <br><br><img src="https://habrastorage.org/webt/u1/wq/28/u1wq28jkvtylav6ndpx7qql6koo.jpeg"><br><br>  Es stellte sich jedoch heraus, dass <strong>all diese Anfragen nur unseren Cache nehmen und waschen</strong> .  Glücklicherweise hatten die Entwickler die Möglichkeit, die ETL in der Produktion zu beeinflussen, sodass wir result_cache ändern konnten, um diese winzigen Anforderungen auszuschließen. <br><br>  Denkst du, es ist einfacher?  - Fühl dich nicht besser!  Die Anzahl der zwischengespeicherten Objekte nahm ab und stieg dann wieder auf 12.000. Wir untersuchten weiter, was noch zwischengespeichert wurde, da sich die Geschwindigkeit nicht änderte. <br><br><img src="https://habrastorage.org/webt/iy/1o/di/iy1odismaewdpasdhlh_uidjeay.jpeg"><br><br>  Wir sehen aus - eine Menge Anfragen, und so klug, aber alles unverständlich.  Obwohl jeder, der mit Oracle 12 gearbeitet hat, weiß, dass DS SVC eine adaptive Statistik ist.  Es wird benötigt, um die Leistung zu verbessern, aber wenn es result_cache gibt, stellt sich heraus, dass es ihn umbringt, weil Wettbewerb stattfindet.  Dies ist natürlich <strong>nur zur Unterstützung geschrieben</strong> . <br><br>  Wir wussten, wie die Arbeitsbelastung angeordnet ist, und haben verstanden, dass adaptive Statistiken in unserem Fall unsere Pläne nicht besonders radikal verbessern würden.  Deshalb haben wir es heldenhaft ausgeschaltet - das Ergebnis, wie es im geheimen Handbuch geschrieben steht, beträgt 10 Minuten pro Dokument.  Nicht schlecht, aber nicht genug. <br><br><h3>  Riegel <br></h3><br>  <strong>Die Konkurrenz zwischen result_cache und DS SVC</strong> beruht auf der Tatsache, dass Oracle Latches hat - leichte kleine Schlösser. <br><br><img src="https://habrastorage.org/webt/d5/ts/nd/d5tsndbmieve1hguz6yv-qzq2jk.jpeg"><br><br>  Ohne auf Details zu ihrer Funktionsweise einzugehen, versuchen wir mehrmals, einen benannten Latch zu platzieren - es hat nicht funktioniert - Oracle nimmt auf und schläft ein <br><br>  Jeder, der sich im Betreff befindet, kann sagen, dass im result_cache zwei Latches mit Fetch auf jeden Block gesetzt werden.  Das sind die Details.  Es gibt zwei Arten von Latches in result_cache: <br><br>  1. Latch für den Zeitraum, während wir Daten in result_cache schreiben. <br><br><img src="https://habrastorage.org/webt/pv/db/qe/pvdbqeunmn4qjgcybpkxai3thne.jpeg"><br><br>  Das heißt, wenn Ihre Anfrage 8 Sekunden lang funktioniert hat, können andere gleiche Anfragen (das Schlüsselwort „same“) für den Zeitraum dieser 8 Sekunden nichts tun, da sie warten, bis die Daten in result_cache geschrieben sind.  Andere Anfragen werden aufgezeichnet, warten jedoch nur in der ersten Zeile auf die Sperre.  Wie viel sie warten müssen, ist unbekannt. Dies ist der undokumentierte Parameter result_cache_timeout.  Danach beginnen sie, result_cache sozusagen zu ignorieren und arbeiten langsam.  Sobald jedoch die Sperre der letzten Zeile an der Tür aufgehoben wurde, arbeiten sie automatisch wieder mit result_cache. <br><br>  2. Die zweite Art von Sperren - von result_cache auch von der ersten bis zur letzten Zeile zu empfangen. <br>  Da der Abruf jedoch aus dem Sofortspeicher stammt, werden sie sehr schnell entfernt. <br><br><img src="https://habrastorage.org/webt/pl/es/ds/plesds8v7w0qd8vjfrecofbmwno.jpeg"><br><br>  Denken Sie daran, dass der DBA, wenn er Latches in der Datenbank sieht, sagt: „Latches!  Wartezeit - alles ist weg!  »Und hier beginnt das interessanteste Spiel: <strong>Überzeugen Sie DBA davon, dass die Wartezeit von den Latches tatsächlich unvergleichlich kürzer ist als die Wiederholungszeit für Abfragen</strong> . <br><br><img src="https://habrastorage.org/webt/ii/du/sv/iidusv3bzptakrexkjrco7cubsw.jpeg"><br><br>  Wie unsere Erfahrung zeigt, <strong>belegen</strong> unsere Messungen, <strong>Latches für result_cache, 10% der Anforderungen selbst</strong> . <br><br><img src="https://habrastorage.org/webt/7-/o8/8a/7-o88agtahp-edtfts_lb2ss6s4.jpeg"><br><br>  Dies sind aggregierte Statistiken.  Die Tatsache, dass alles schlecht ist, kann durch die Tatsache verstanden werden, dass der Cache verstopft ist.  Eine weitere Bestätigung ist, dass die richtigen Ergebnisse gelöscht werden.  Das heißt, der <strong>Cache wird überschrieben</strong> .  Es scheint, dass wir klug sind und immer die Größe des Speichers berücksichtigen - wir haben die Zeilengröße unseres zwischengespeicherten Ergebnisses für unsere Empfehlung verwendet, multipliziert mit der Anzahl der Zeilen, und etwas ist schiefgegangen. <br><br><img src="https://habrastorage.org/webt/mg/lh/5e/mglh5eorzkulnfqoewvrreqpb_u.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Unterstützung wurden zwei Fehler gefunden, die besagen, dass </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bei einem Überlauf von result_cache Leistungseinbußen auftreten</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Und dies wurde auch in demselben geheimen Patch behoben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Geheimnis ist, dass der Speicher in Blöcken zugewiesen wird. </font><font style="vertical-align: inherit;">In unserem Fall wurde natürlich die Tatsache hinzugefügt, dass sich die Arbeitsbelastung um das Fünffache erhöhte. </font><font style="vertical-align: inherit;">Daher muss bei der Berechnung der Speicher nicht mit der Breite Ihrer Daten multipliziert werden, sondern mit der Größe des Blocks, und dann wird es glücklich. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was kann noch angepasst werden? </font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter Meer: Es gibt dokumentierte und nicht dokumentierte Parameter. </font><font style="vertical-align: inherit;">Tatsächlich benötigen wir nicht alle diese Parameter. </font></font><br><br><img src="https://habrastorage.org/webt/2i/qm/_j/2iqm_jbqws8mw7udadiwhkrngao.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Tat sind 4 Parameter ausreichend:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RESULT_CACHE_MAX_SIZE; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RESULT_CACHE_MAX_RESULT; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RESULT_CACHE_MODE; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> _RESULT_CACHE_MAX_TIMEOUT. </font></font><br></li></ul><br><img src="https://habrastorage.org/webt/bt/fr/wp/btfrwpqmjmcs6evdykbcvizgte4.jpeg"><br><br>     —  .  ,    100   512,      6 . <br><br>    ,    - . , Invalidation Count = 10000. <br><br>   ,    .     ,   job  ,      . ,   .   job   ,    ,      . <br><br><img src="https://habrastorage.org/webt/2b/m0/dl/2bm0dl2vlmo6bbv16wyksdoora0.jpeg"><br><br>    , invalid     ,    . <strong>         40 </strong> . <br><br>  ,    .     ,     ,     Oracle.  ! <br><br><img src="https://habrastorage.org/webt/wj/dd/jw/wjddjwnlpkmemk8lglmb7rczgb0.jpeg"><br><br> <strong>SHELFLIVE</strong> — ,    read-consistent  ,       10 ,   .        . ,     ,    . <br><br>      — <strong>SNAPSHOT</strong> .  ,       ,     read-consistent    —       . <br><br> <strong></strong> : <br><br><img src="https://habrastorage.org/webt/bj/ts/pd/bjtspdkmsfo2d2xicp_pmxgtqag.jpeg"><br><br><ol><li>  —       SYS. </li><li>      . ,    ,  Oracle    ,     ,        .  , Oracle ,   ,   12.2     . ,  external  -    support,    . </li><li>    sql  pl/sql : current_date, current_time  .   ,     current_time,          . </li><li>    . </li><li>          ,    CLOB, BLOB  . </li></ol><br><h3> Result cache inside Oracle <br></h3><br> Result_cache —   Oracle Core.        , ,    job  result_cache (,    hint,    )  ,    APEX. <br><br><img src="https://habrastorage.org/webt/6n/u3/wf/6nu3wfqtrqzz3n5r_kyfdfwfv8c.jpeg"><br><br> ,    Dynamic sampling    ,   ,      ,   result_cache. <br><br><img src="https://habrastorage.org/webt/qa/gr/al/qagralka35xxjh68wtrfpprgrii.jpeg"><br><br><h2> Oracle internals for result cache <br></h2><br>         result_cache: <br><br><ol><li>        (storage)   ; <br></li><li>         result_cache; <br></li><li> result_cache   shared pool. <br></li></ol><br><img src="https://habrastorage.org/webt/yx/29/pk/yx29pkuz-o_c4dbgk9dbjwbn0lm.jpeg"><br><br>  <strong>Vorteile:</strong> <br><br><ul><li>     . <br></li><li>           read-consistent. </li><li> Result_cache,   ,  . </li></ul><br>  <strong>Nachteile:</strong> <br><br><ul><li>    . <br></li><li>     ,    . <br></li></ul><br><h2>   ! <br></h2><br>      ,    .    support Oracle, ,  29  2017 .:   Oracle E-Business suite    result_cache,      . <br><br><img src="https://habrastorage.org/webt/zh/h3/eu/zhh3eud6fphqdaiuukx1yoklczu.jpeg"><br><br> ,       ,     .          support        ,    ,      . <br><br><img src="https://habrastorage.org/webt/qp/e8/5i/qpe85iwdofjvbxhgtrrihdjmxb4.jpeg"><br><br>             : <br><br><ol><li>  -    ; <br></li><li> , , , ,  v$result_cache_memory  dbms_result_cache.memory_report,       . <br></li></ol><br> ,     ,      ,   v_result_cache_objects  . <br><br><blockquote>   ,  support note —   support ,   . <br></blockquote><br><img src="https://habrastorage.org/webt/me/ut/5o/meut5o7krxdlelwjxgavdxrq-fe.jpeg"><br><br>    ,       ,   :     - .    ,    ,      : <br><br><ol><li>  hint result_cache; </li><li>  hint no result_cache; </li><li>  black_list,  ,   ,   -. </li></ol><br> <strong>    ?</strong> <br><br><ul><li>   ,  - , ,      ; </li><li>     ,    ,   . ,   - ,  ,   . </li></ul><br>   , <strong>     —     </strong> .  Oracle  ,  . <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Clientseitiger Ergebniscache </font></font><br></h3><br><img src="https://habrastorage.org/webt/mk/6s/5m/mk6s5m24srinff6gkhrmxxei7xu.jpeg"><br><br>  Das Diagramm seines Geräts ist oben dargestellt. Dies sind die Hauptkomponenten der Datenbank und des Treibers. <br><br>  Beim ersten Zugriff auf die Clientseite geht der Ergebniscache in die vorkonfigurierte Datenbank, empfängt die Größe des Clientcaches aus der Datenbank und installiert diesen Cache bei der ersten Verbindung einmalig auf dem Client.  Die zwischengespeicherte Abfrage greift zuerst auf die Datenbank zu und schreibt Daten in den Cache.  Die verbleibenden Threads fordern einen gemeinsam genutzten Treibercache an, wodurch Serverspeicher und -ressourcen gespart werden.  Übrigens sendet der Treiber manchmal abhängig von der Auslastung Statistiken über die Verwendung des Caches an die Datenbank, die dann angezeigt werden können. <br><br>  <strong>Eine interessante Frage ist, wie kommt es zu einer Behinderung?</strong> <br><br>  Es gibt zwei Arten der Ungültigmachung, die durch den Parameter Invalidierungsverzögerung geschärft werden.  Auf diese Weise lässt Oracle zu, dass der Treibercache nicht konsistent ist. <br><br>  Der erste Modus wird verwendet, wenn Anforderungen häufig gestellt werden und die Invalidierungsverzögerung nicht auftritt.  In diesem Fall wird der Stream in die Datenbank verschoben, die Caches aktualisiert und die Daten daraus gelesen. <br><br><img src="https://habrastorage.org/webt/ah/wo/u1/ahwou1tplbgyiq4w8lizx0raeto.jpeg"><br><br>  Wenn die Invalidierungsverzögerung fehlschlägt, wird für jede nicht zwischengespeicherte Anforderung, die sich auf die Datenbank bezieht, zusätzlich zu den Abfrageergebnissen eine Liste ungültiger Objekte angezeigt.  Dementsprechend werden sie im Cache als ungültig markiert, und alles funktioniert wie im Bild aus dem ersten Szenario. <br><br>  Im zweiten Fall, wenn mehr Zeit als die Invalidierungsverzögerung vergangen ist, geht der client result_cache selbst in die Datenbank und sagt: "Geben Sie mir eine Liste der Änderungen!"  Das heißt, er selbst behält seinen angemessenen Zustand bei. <br><br>  <strong>Das Konfigurieren des clientseitigen Ergebniscaches ist sehr einfach</strong> .  Es gibt 2 Möglichkeiten: <br><br><ol><li>  CLIENT_RESULT_CACHE_LAG - Cache-Verzögerungswert; </li><li>  CLIENT_RESULT_CACHE_SIZE - Größe (mindestens 32 KB, maximal 2 GB). </li></ol><br><img src="https://habrastorage.org/webt/ky/zl/mh/kyzlmhtgmgjkodcgtwkjm6sqoym.jpeg"><br><br>  Aus Sicht des Anwendungsentwicklers unterscheidet sich der Client-Cache nicht sehr vom Server-Cache, sondern sie haben auch den Hinweis result_cache eingegeben.  Wenn dies der Fall ist, wird es nur vom Client verwendet - sowohl unter .NET als auch unter Java. <br><br><img src="https://habrastorage.org/webt/xo/bv/of/xobvof-_m9gwfhdocpw5dywqshe.jpeg"><br><br>  Nachdem ich 10 Iterationen der Abfrage durchgeführt hatte, erhielt ich Folgendes. <br><br><img src="https://habrastorage.org/webt/vq/zs/di/vqzsdifg9jkvb18jnrgy_bu9je4.jpeg"><br><br>  Der erste Aufruf ist die Erstellung, dann 9 Cache-Zugriffe.  Die Tabelle zeigt an, dass der Speicher auch in Blöcken zugeordnet ist.  Achten Sie auch auf SELECT - es ist nicht sehr intuitiv.  Um ehrlich zu sein, bevor ich damit anfing, wusste ich nicht einmal, dass es eine solche Darstellung von <code>GV$SESSION_CONNECT_INFO</code> .  Warum Oracle es nicht direkt in diese Tabelle aufgenommen hat (und dies ist eine Tabelle, keine Ansicht), konnte ich nicht verstehen.  Deshalb glaube ich, dass diese Funktionalität nicht sehr beliebt ist, obwohl sie meiner Meinung nach sehr nützlich ist. <br><br>  <strong>Vorteile des Client-Caching:</strong> <br><br><ul><li>  billiger Client-Speicher; </li><li>  jeder verfügbare Treiber - JDBC, .NET usw.; </li><li>  minimale Auswirkung auf den Anwendungscode. </li><li>  Reduzierung der Belastung der CPU, der E / A und allgemein der Datenbank; </li><li>  Sie müssen nicht alle Arten von Smart-Caching-Ebenen und APIs lernen und verwenden. </li><li>  keine Riegel. </li></ul><br>  <strong>Nachteile:</strong> <br><br><ul><li>  Konsistenz beim Lesen mit Verzögerung - im Prinzip ist dies nun ein Trend; </li><li>  benötigen Oracle OCI Client; </li><li>  Beschränkung auf 2 GB pro Client, aber im Allgemeinen sind 2 GB viel; </li><li>  Für mich persönlich ist die Hauptbeschränkung ein paar Informationen über die Produktion. </li></ul><br>  Bei der Unterstützung, die wir immer bei der Arbeit mit result_cache verwenden, habe ich nur 5 Fehler gefunden.  Dies deutet darauf hin, dass es höchstwahrscheinlich nur wenige Menschen brauchen. <br><br>  Also bringen wir alles zusammen, was oben gesagt wurde. <br><br><h3>  <strong>Handgemachter Cache</strong> <br></h3><br>  <strong>Schlechte Szenarien:</strong> <br><br><ul><li>  Sofortige Änderung - Wenn der Cache nach dem Ändern der Daten sofort irrelevant wird.  Bei selbst erstellten Caches ist es schwierig, bei Änderungen an den Objekten, auf denen sie basieren, die richtige Ungültigmachung zu erstellen. </li><li>  Wenn die Verwendung von in der Datenbank gespeicherter Logik durch Entwicklungsrichtlinien verboten ist. </li></ul><br>  <strong>Gute Szenarien:</strong> <br><br><ul><li>  Es gibt ein starkes Datenbankentwicklungsteam. </li><li>  Implementierte PL / SQL-Logik. </li><li>  Es gibt Einschränkungen, die verhindern, dass andere Caching-Techniken verwendet werden. </li></ul><br><h3>  <strong>Serverseitiger Ergebniscache</strong> <br></h3><br>  <strong>Schlechte Szenarien:</strong> <br><br><ul><li>  Viele verschiedene Ergebnisse, die nur den gesamten Cache waschen; </li><li>  Anforderungen dauern länger als _RESULT_CACHE_TIMEOUT oder dieser Parameter ist falsch konfiguriert. </li><li>  Ergebnisse von sehr großen Sitzungen werden in parallelen Threads in den Cache geladen. </li></ul><br>  <strong>Gute Szenarien:</strong> <br><br><ul><li>  Angemessene Anzahl zwischengespeicherter Ergebnisse. </li><li>  Relativ kleine Datensätze (200–300 Zeilen). </li><li>  Ziemlich teures SQL, sonst wird die ganze Zeit an Latches gehen. </li><li>  Mehr oder weniger statische Tabellen. </li><li>  Es gibt einen DBA, der im Falle von etwas kommt und alle rettet. </li></ul><br><h3>  <strong>Clientseitiger Ergebniscache</strong> <br></h3><br>  <strong>Schlechte Szenarien:</strong> <br><br><ul><li>  Wenn das Problem der sofortigen Behinderung auftritt. </li><li>  Dünne Treiber erforderlich. <br></li></ul><br>  <strong>Gute Szenarien:</strong> <br><br><ul><li>  Es gibt ein normales Entwicklungsteam für die mittlere Schicht. </li><li>  Es wird bereits viel SQL verwendet, ohne dass eine externe Caching-Schicht verwendet wird, die problemlos verbunden werden kann. </li><li>  Es gibt Einschränkungen für die Drüsen. </li></ul><br><br><h2>  Schlussfolgerungen <br></h2><br>  Ich glaube, dass meine Geschichte über serverseitige Ergebnis-Cache-Schmerzen handelt, daher lauten die Schlussfolgerungen wie folgt: <br><br><ol><li>  Bewerten Sie die Speichergröße immer korrekt unter Berücksichtigung der Anzahl der Abfragen und nicht der Anzahl der Ergebnisse, d. H.: Blöcke, APEX, Job, adaptive Statistiken usw. </li><li>  Haben Sie keine Angst, automatische Cache-Leergutoptionen (Snapshot + Shelflife) zu verwenden. </li><li>  Überladen Sie den Cache nicht mit Anforderungen, während Sie große Datenmengen laden. Deaktivieren Sie zuvor result_cache.  Erwärmen Sie den Cache. </li><li>  Stellen Sie sicher, dass _result_cache_timeout Ihren Erwartungen entspricht. </li><li>  Verwenden Sie FORCE NIEMALS für die gesamte Datenbank.  Benötigen Sie eine Datenbank im Speicher? Verwenden Sie eine spezielle In-Memory-Lösung. </li><li>  Überprüfen Sie, ob die FORCE-Option für einzelne Tabellen geeignet ist, damit sie nicht wie bei einer ETL eines Drittanbieters funktioniert. </li><li>  Entscheiden Sie, ob die adaptiven Statistiken so gut sind wie von Oracle beschrieben (_optimizer_ads_use_result_cache = false). </li></ol><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Highload ++ Siberia am</a> kommenden Montag ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeitplan</a> fertig und wird auf der Site veröffentlicht.  Es gibt mehrere Berichte zum Thema dieses Artikels: <br><br><ul><li>  <strong>Alexander Makarov</strong> (CFT GC) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wird am</a> Beispiel der Oracle-Datenbank <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine</a> Methode zur Identifizierung von Engpässen auf der Serverseite der Software <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">demonstrieren</a> . <br></li><li>  <strong>Ivan Sharov</strong> und <strong>Konstantin Poluektov erklären</strong> Ihnen, welche Probleme bei der Migration des Produkts auf neue Versionen der Oracle-Datenbank auftreten, und versprechen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, Empfehlungen</a> zur Organisation und Durchführung solcher Arbeiten zu geben. <br></li><li>  <strong>Nikolay Golov</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erklärt Ihnen,</a> wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> die Datenintegrität in einer Microservice-Architektur ohne verteilte Transaktionen und enge Konnektivität sicherstellen können. <br></li></ul><br>  <strong>Treffen Sie mich in Nowosibirsk!</strong> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414401/">https://habr.com/ru/post/de414401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414389/index.html">Analysieren von Cisco-Geräteprotokollen mit Splunk Cisco Security Suite</a></li>
<li><a href="../de414393/index.html">Sprachgesteuerter Roboter im Jahr 1961</a></li>
<li><a href="../de414395/index.html">Einfacher als es klingt. Bruch</a></li>
<li><a href="../de414397/index.html">FCS schlägt vor, den Duty-Free-Schwellenwert auf Null zu senken</a></li>
<li><a href="../de414399/index.html">Der Einsatz digitaler Produktion in der realen Wirtschaft und Bildung</a></li>
<li><a href="../de414403/index.html">Fujitsu hat eine neue molekulare Modellierungstechnologie entwickelt</a></li>
<li><a href="../de414405/index.html">Installieren Sie das Zertifikat auf dem Apache HTTP-Server</a></li>
<li><a href="../de414411/index.html">Wiren Board 6: wieder auf Habré mit der neuen Version der Steuerung für die Automatisierung</a></li>
<li><a href="../de414413/index.html">Zusammenfassung und Video der Geschichte über das Networking in der Spielebranche mit dem Gamedev des Festivals</a></li>
<li><a href="../de414415/index.html">Tarantool-Konferenz 21. Juni - nicht nur über Tarantool, sondern allgemein über In-Memory-Computing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>