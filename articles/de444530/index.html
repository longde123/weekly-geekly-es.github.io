<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎨 🌱 🤵🏻 Die Zukunft der Abhängigkeitsinjektion in Android 👨🏾‍🤝‍👨🏼 🚒 ♉️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich mache Sie auf eine Übersetzung des Originalartikels von Jamie Sanson aufmerksam 

 Aktivitäten vor Android 9 Pie erstellen 


 Die Abhängigkeitsin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Zukunft der Abhängigkeitsinjektion in Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444530/"><p>  <sup><em>Ich mache Sie auf eine Übersetzung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originalartikels</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jamie Sanson aufmerksam</a></em></sup> <br><img src="https://habrastorage.org/getpro/habr/post_images/392/ae0/ac2/392ae0ac22d5b2d9b82a01e41d975278.jpg" alt="Bild"></p><br><h3 id="sozdanie-activity-do-android-9-pie">  Aktivitäten vor Android 9 Pie erstellen </h3><br><p> <em>Die Abhängigkeitsinjektion (DI)</em> ist ein gängiges Modell, das aus verschiedenen Gründen in allen Entwicklungsformen verwendet wird.  Dank des Dagger-Projekts wird es als Vorlage für die Entwicklung für Android verwendet.  Die jüngsten Änderungen in Android 9 Pie haben dazu geführt, dass wir jetzt mehr Optionen für DI haben, insbesondere mit der neuen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>AppComponentFactory</code></a> Klasse. </p><br><hr><br><p>  DI ist sehr wichtig für die moderne Android-Entwicklung.  Auf diese Weise können Sie die Gesamtmenge an Code reduzieren, wenn Sie Links zu Diensten erhalten, die zwischen Klassen verwendet werden, und die Anwendung im Allgemeinen gut in Komponenten unterteilen.  In diesem Artikel konzentrieren wir uns auf Dagger 2, die in der Android-Entwicklung am häufigsten verwendete DI-Bibliothek.  Es wird davon ausgegangen, dass Sie bereits Grundkenntnisse darüber haben, wie dies funktioniert, aber es ist nicht erforderlich, alle Feinheiten zu verstehen.  Es ist erwähnenswert, dass dieser Artikel ein kleines Abenteuer ist.  Das ist interessant und alles, aber zum Zeitpunkt des Schreibens erschien Android 9 Pie noch nicht einmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Plattformversionsfenster</a> , sodass dieses Thema wahrscheinlich für mindestens einige Jahre nicht für die alltägliche Entwicklung relevant sein wird. </p><a name="habracut"></a><br><h3 id="vnedrenie-zavisimostey-v-android-segodnya">  Abhängigkeitsinjektion in Android heute </h3><br><p>  Einfach ausgedrückt, verwenden wir DI, um unseren abhängigen Klassen, dh denjenigen, die die Arbeit erledigen, Instanzen von Abhängigkeitsklassen bereitzustellen.  Angenommen, wir verwenden das <a href="">Repository-Muster</a> , um unsere datenbezogene Logik zu verarbeiten, und möchten unser Repository in Aktivität verwenden, um dem Benutzer einige Daten anzuzeigen.  Möglicherweise möchten wir dasselbe Repository an mehreren Stellen verwenden. Daher verwenden wir die Abhängigkeitsinjektion, um die gemeinsame Nutzung derselben Instanz zwischen mehreren Klassen zu vereinfachen. </p><br><p>  Zunächst stellen wir ein Repository bereit.  Wir werden die <code>Provides</code> Funktion im Modul definieren, damit Dagger weiß, dass dies genau die Instanz ist, die wir implementieren möchten.  Bitte beachten Sie, dass unser Repository eine Kontextinstanz für die Arbeit mit Dateien und dem Netzwerk benötigt.  Wir werden es mit dem Anwendungskontext versehen. </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appContext: Context) { <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-meta"><span class="hljs-meta">@ApplicationScope</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideApplicationContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Context = appContext <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-meta"><span class="hljs-meta">@ApplicationScope</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Context</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Repository = Repository(context) }</code> </pre> <br><p>  Jetzt müssen wir <code>Component</code> definieren, um die Implementierung der Klassen zu handhaben, in denen wir unser <code>Repository</code> möchten. </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@ApplicationScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component(modules = [AppModule::class])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MainActivity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Schließlich können wir unsere <code>Activity</code> so konfigurieren, dass sie unser Repository verwendet.  Angenommen, wir haben eine Instanz unserer <code>ApplicationComponent</code> anderen Stelle erstellt. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repository: Repository <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) <span class="hljs-comment"><span class="hljs-comment">//    application.applicationComponent.inject(this) //       } }</span></span></code> </pre> <br><p>  Das ist alles!  Wir haben gerade die Abhängigkeitsinjektion innerhalb der Anwendung mit Dagger eingerichtet.  Es gibt verschiedene Möglichkeiten, dies zu tun, aber dies scheint der einfachste Ansatz zu sein. </p><br><h3 id="chto-ne-tak-s-tekuschim-podhodom">  Was ist falsch an dem aktuellen Ansatz? </h3><br><p>  In den obigen Beispielen haben wir zwei verschiedene Arten von Injektionen gesehen, eine offensichtlicher als die andere. </p><br><p>  Das erste, das Sie möglicherweise übersehen haben, wird als <strong>Einbettung in den Konstruktor bezeichnet</strong> .  Dies ist eine Methode zum Bereitstellen von Abhängigkeiten über den Konstruktor einer Klasse. Dies bedeutet, dass eine Klasse, die Abhängigkeiten verwendet, keine Ahnung vom Ursprung der Instanzen hat.  Dies wird als die reinste Form der Abhängigkeitsinjektion angesehen, da sie unsere Injektionslogik perfekt in unsere <code>Module</code> einkapselt.  In unserem Beispiel haben wir diesen Ansatz verwendet, um ein Repository bereitzustellen: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Context</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Repository = Repository(context)</code> </pre> <br><p>  Dafür brauchten wir <code>Context</code> , den wir in der Funktion <code>provideApplicationContext()</code> bereitgestellt haben. </p><br><p>  Das zweite, offensichtlichere, was wir gesehen haben, ist die <strong>Implementierung der Klasse vor Ort</strong> .  Diese Methode wurde in unserer <code>MainActivity</code> , um unser Geschäft bereitzustellen.  Hier definieren wir die Felder als Empfänger der Injektionen unter Verwendung der <code>Inject</code> Annotation.  Anschließend <code>onCreate</code> wir <code>ApplicationComponent</code> in unserer Funktion <code>onCreate</code> dass Abhängigkeiten in unsere Felder <code>onCreate</code> werden müssen.  Es sieht nicht so sauber aus wie das Einbetten in einen Konstruktor, da wir einen expliziten Verweis auf unsere Komponente haben, was bedeutet, dass das Konzept des Einbetten in unsere abhängigen Klassen eindringt.  Ein weiterer Fehler in den Android Framework-Klassen, da wir sicher sein müssen, dass wir als erstes Abhängigkeiten bereitstellen.  Wenn dies zum falschen Zeitpunkt im Lebenszyklus geschieht, versuchen wir möglicherweise versehentlich, ein Objekt zu verwenden, das noch nicht initialisiert wurde. </p><br><p>  Idealerweise sollten Sie die Implementierungen in den Klassenfeldern vollständig entfernen.  Dieser Ansatz überspringt Implementierungsinformationen für Klassen, die nichts darüber wissen müssen, und kann möglicherweise Lebenszyklusprobleme verursachen.  Wir haben Versuche gesehen, es besser zu machen, und <em>Dagger</em> auf Android ist ein ziemlich zuverlässiger Weg, aber am Ende wäre es besser, wenn wir nur die Konstruktorinjektion verwenden könnten.  Derzeit können wir diesen Ansatz nicht für eine Reihe von Framework-Klassen verwenden, z. B. "Aktivität", "Service", "Anwendung" usw., da diese vom System für uns erstellt werden.  Es scheint, dass wir im Moment nicht in der Lage sind, Klassen in Felder einzuführen.  Trotzdem bereitet Android 9 Pie etwas Interessantes vor, das vielleicht alles grundlegend verändern wird. </p><br><h3 id="vnedrenie-zavisimostey-v-android-9-pie">  Abhängigkeitsinjektion in Android 9 Pie </h3><br><p>  Wie am Anfang des Artikels erwähnt, verfügt Android 9 Pie über eine AppComponentFactory-Klasse.  Die Dokumentation dafür ist eher knapp und wird einfach als solche auf der Entwickler-Website veröffentlicht: </p><br><blockquote>  <em>Die Schnittstelle zur Steuerung der Erstellung von Manifestelementen.</em> </blockquote><p>  Es ist faszinierend.  "Manifest-Elemente" bezieht sich hier auf die Klassen, die wir in unserer <code>AndroidManifest</code> Datei <code>AndroidManifest</code> , z. B. Aktivität, Dienst und unsere Anwendungsklasse.  Auf diese Weise können wir die Erstellung dieser Elemente "steuern". Können wir nun die Regeln für die Erstellung unserer Aktivitäten festlegen?  Was für eine Freude! </p><br><p>  Lassen Sie uns tiefer graben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>AppComponentFactory</code></a> erweitern wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>AppComponentFactory</code></a> und überschreiben die <code>instantiateActivity</code> Methode. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InjectionComponentFactory</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppComponentFactory</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> repository = NonContextRepository() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instantiateActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ClassLoader</span></span></span></span><span class="hljs-function"><span class="hljs-params">, className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, intent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Intent</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: Activity { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { className == MainActivity::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span></span>(repository) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.instantiateActivity(cl, className, intent) } } }</code> </pre> <br><p>  Jetzt müssen wir unsere Komponentenfactory im Manifest innerhalb des <strong>Anwendungs-</strong> Tags deklarieren. </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:allowBackup</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@string/app_name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:icon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@mipmap/ic_launcher"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".InjectionApp"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:appComponentFactory</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.mypackage.injectiontest.component.InjectionComponentFactory"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:theme</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@style/AppTheme"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">tools:replace</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android:appComponentFactory"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Endlich können wir unsere Anwendung starten ... und es funktioniert!  Unser <code>NonContextRepository</code> über den MainActivity-Konstruktor bereitgestellt.  Anmutig! </p><br><p>  Bitte beachten Sie, dass es einige Vorbehalte gibt.  Wir können <code>Context</code> hier nicht verwenden, da bereits vor seiner Existenz ein Aufruf unserer Funktion erfolgt - das ist verwirrend!  Wir können noch weiter gehen, damit der Konstruktor unsere Anwendungsklasse implementiert, aber lassen Sie uns sehen, wie Dagger dies noch einfacher machen kann. </p><br><h3 id="vstrechayte--dagger-multi-binds">  Treffen Sie - Dolch Multi-Binds </h3><br><p>  Ich werde nicht auf die Details des Dolch-Mehrfachbindungsvorgangs unter der Haube eingehen, da dies den Rahmen dieses Artikels sprengt.  Alles, was Sie wissen müssen, ist, dass es eine gute Möglichkeit bietet, in den Klassenkonstruktor einzufügen, ohne den Konstruktor manuell aufrufen zu müssen.  Wir können dies verwenden, um Framework-Klassen auf skalierbare Weise einfach zu implementieren.  Mal sehen, wie sich alles summiert. </p><br><p>  Lassen Sie uns zuerst unsere Aktivität einrichten, um herauszufinden, wohin wir als nächstes gehen sollen. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> repository: NonContextRepository ): Activity() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) <span class="hljs-comment"><span class="hljs-comment">//       } }</span></span></code> </pre> <br><p>  Dies zeigt sofort, dass die Abhängigkeitsinjektion fast <em>nicht</em> erwähnt wird.  Das einzige, was wir sehen, ist die <code>Inject</code> Annotation vor dem Konstruktor. </p><br><p>  Jetzt müssen Sie die Komponente und das Dolchmodul ändern: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Component(modules = [ApplicationModule::class])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(factory: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">InjectionComponentFactory</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Module(includes = [ComponentModule::class])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: NonContextRepository = NonContextRepository() }</code> </pre> <br><p>  Es hat sich nicht viel geändert.  Jetzt müssen wir nur noch unsere Komponentenfabrik implementieren, aber wie erstellen wir unsere Manifestelemente?  Hier brauchen wir ein <code>ComponentModule</code> .  Mal sehen: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-meta"><span class="hljs-meta">@IntoMap</span></span> <span class="hljs-meta"><span class="hljs-meta">@ComponentKey(MainActivity::class)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindMainActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MainActivity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Any <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindComponentHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(componentHelper: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ComponentHelper</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ComponentInstanceHelper } <span class="hljs-meta"><span class="hljs-meta">@Target(AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.PROPERTY_SETTER)</span></span> <span class="hljs-meta"><span class="hljs-meta">@Retention(AnnotationRetention.RUNTIME)</span></span> <span class="hljs-meta"><span class="hljs-meta">@MapKey</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">annotation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentKey</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clazz: KClass&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Any&gt;)</code> </pre> <br><p>  Ja, nur ein paar Anmerkungen.  Hier verbinden wir unsere <code>Activity</code> mit einer Map, implementieren diese Map in unsere <code>ComponentHelper</code> Klasse und stellen diesen <code>ComponentHelper</code> bereit - alles in zwei <code>Binds</code> Anweisungen.  Dagger weiß dank der <code>MainActivity</code> Annotation <code>Inject</code> wie er unsere <code>MainActivity</code> instanziiert <code>Inject</code> sodass er den Provider an diese Klasse binden und automatisch die Abhängigkeiten bereitstellen kann, die wir für den Konstruktor benötigen.  Unser <code>ComponentHelper</code> wie folgt. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentHelper</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> creators: Map&lt;Class&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Any&gt;, <span class="hljs-meta"><span class="hljs-meta">@JvmSuppressWildcards</span></span> Provider&lt;Any&gt;&gt; ): ComponentInstanceHelper { <span class="hljs-meta"><span class="hljs-meta">@Suppress(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UNCHECKED_CAST"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: T? = creators .filter { it.key.name == className } .values .firstOrNull() ?.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? T } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InstanceComponentHelper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: T? }</code> </pre> <br><p>  Einfach ausgedrückt, wir haben jetzt eine Klassenübersicht für Lieferanten für diese Klassen.  Wenn wir versuchen, eine Klasse nach Namen aufzulösen, suchen wir einfach den Anbieter für diese Klasse (falls vorhanden), rufen ihn auf, um eine neue Instanz dieser Klasse abzurufen, und geben ihn zurück. </p><br><p>  Schließlich müssen wir Änderungen an unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>AppComponentFactory</code></a> , um unsere neue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>AppComponentFactory</code></a> verwenden zu können. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InjectionComponentFactory</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppComponentFactory</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> componentHelper: ComponentInstanceHelper <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { DaggerApplicationComponent.create().inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instantiateActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ClassLoader</span></span></span></span><span class="hljs-function"><span class="hljs-params">, className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, intent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Intent</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: Activity { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> componentHelper .resolve&lt;Activity&gt;(className) ?.apply { setIntent(intent) } ?: <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.instantiateActivity(cl, className, intent) } }</code> </pre> <br><p>  Führen Sie den Code erneut aus.  Es funktioniert alles!  Was für eine Freude. </p><br><h3 id="problemy-vnedreniya-v-konstruktor">  Probleme bei der Implementierung des Konstruktors </h3><br><p>  Ein solcher Titel mag nicht sehr beeindruckend aussehen.  Obwohl wir die meisten Instanzen im normalen Modus einbetten können, indem wir sie in den Konstruktor einfügen, haben wir keine offensichtliche Möglichkeit, den Kontext für unsere Abhängigkeiten auf standardmäßige Weise bereitzustellen.  Aber der <code>Context</code> in Android ist alles.  Es wird für den Zugriff auf Einstellungen, Netzwerk, Anwendungskonfiguration und vieles mehr benötigt.  Bei unseren Abhängigkeiten handelt es sich häufig um Dinge, die datenbezogene Dienste wie Netzwerk und Einstellungen verwenden.  Wir können dies umgehen, indem wir unsere Abhängigkeiten in reine Funktionen umschreiben oder alles mit Kontextinstanzen in unserer <code>Application</code> initialisieren. Es ist jedoch viel mehr Arbeit erforderlich, um den besten Weg zu finden, dies zu tun. </p><br><p>  Ein weiterer Nachteil dieses Ansatzes ist die Definition des Anwendungsbereichs.  In Dagger ist eines der Schlüsselkonzepte für die Implementierung einer Hochleistungs-Abhängigkeitsinjektion mit einer guten Trennung der Klassenbeziehungen die Modularität des Objektgraphen und die Verwendung des Bereichs.  Obwohl dieser Ansatz die Verwendung von Modulen nicht verbietet, schränkt er die Verwendung des Anwendungsbereichs ein.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>AppComponentFactory</code></a> befindet sich auf einer völlig anderen Abstraktionsebene als unsere Standard-Framework-Klassen. Wir können keinen programmgesteuerten Link dazu erhalten, sodass wir keine Anweisung haben, Abhängigkeiten für <code>Activity</code> in einem anderen Bereich bereitzustellen. </p><br><p>  Es gibt viele Möglichkeiten, unsere Probleme mit Bereichen in der Praxis zu lösen. Eine davon ist die Verwendung einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>FragmentFactory</code></a> , um unsere Fragmente in einen Konstruktor mit Bereichen einzubetten.  Ich werde nicht auf Details eingehen, aber es stellt sich heraus, dass wir jetzt eine Methode zur Steuerung der Erstellung von Fragmenten haben, die uns nicht nur viel mehr Spielraum gibt, sondern auch Abwärtskompatibilität bietet. </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  Android 9 Pie hat eine Möglichkeit eingeführt, die Einbettung in den Konstruktor zu verwenden, um Abhängigkeiten in unseren Framework-Klassen wie "Aktivität" und "Anwendung" bereitzustellen.  Wir haben gesehen, dass wir mit <em>Dagger Multi-Binding</em> problemlos Abhängigkeiten auf Anwendungsebene bereitstellen können. </p><br><p>  Ein Konstruktor, der alle unsere Komponenten implementiert, ist äußerst attraktiv, und wir können sogar etwas tun, damit er mit Kontextinstanzen ordnungsgemäß funktioniert.  Dies ist eine vielversprechende Zukunft, die jedoch erst ab API 28 verfügbar ist. Wenn Sie weniger als 0,5% der Benutzer erreichen möchten, können Sie es versuchen.  Andernfalls sollten Sie abwarten, ob eine solche Methode in einigen Jahren relevant bleibt. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444530/">https://habr.com/ru/post/de444530/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444520/index.html">2. Check Point Erste Schritte R80.20. Lösungsarchitektur</a></li>
<li><a href="../de444522/index.html">Die Apokalypse wird abgebrochen</a></li>
<li><a href="../de444524/index.html">Lambdas: von C ++ 11 bis C ++ 20. Teil 1</a></li>
<li><a href="../de444526/index.html">DOTS-Stapel: C ++ & C #</a></li>
<li><a href="../de444528/index.html">Situation: Japan kann das Herunterladen von Inhalten aus dem Netzwerk einschränken - wir verstehen und diskutieren</a></li>
<li><a href="../de444534/index.html">Schwachstellen-Scan und sichere Entwicklung. Teil 1</a></li>
<li><a href="../de444536/index.html">MVCC-2. Ebenen, Dateien, Seiten</a></li>
<li><a href="../de444540/index.html">Intel ist bereit, mit der Produktion von MRAM-Speicher zu beginnen</a></li>
<li><a href="../de444542/index.html">Live-Stream und Konferenzplan für SmartMail Conf: Maschinelles Lernen</a></li>
<li><a href="../de444544/index.html">Etwas über verteilte Rechenzentren für Unternehmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>