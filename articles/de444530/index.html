<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüé® üå± ü§µüèª Die Zukunft der Abh√§ngigkeitsinjektion in Android üë®üèæ‚Äçü§ù‚Äçüë®üèº üöí ‚ôâÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich mache Sie auf eine √úbersetzung des Originalartikels von Jamie Sanson aufmerksam 

 Aktivit√§ten vor Android 9 Pie erstellen 


 Die Abh√§ngigkeitsin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Zukunft der Abh√§ngigkeitsinjektion in Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444530/"><p>  <sup><em>Ich mache Sie auf eine √úbersetzung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originalartikels</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jamie Sanson aufmerksam</a></em></sup> <br><img src="https://habrastorage.org/getpro/habr/post_images/392/ae0/ac2/392ae0ac22d5b2d9b82a01e41d975278.jpg" alt="Bild"></p><br><h3 id="sozdanie-activity-do-android-9-pie">  Aktivit√§ten vor Android 9 Pie erstellen </h3><br><p> <em>Die Abh√§ngigkeitsinjektion (DI)</em> ist ein g√§ngiges Modell, das aus verschiedenen Gr√ºnden in allen Entwicklungsformen verwendet wird.  Dank des Dagger-Projekts wird es als Vorlage f√ºr die Entwicklung f√ºr Android verwendet.  Die j√ºngsten √Ñnderungen in Android 9 Pie haben dazu gef√ºhrt, dass wir jetzt mehr Optionen f√ºr DI haben, insbesondere mit der neuen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>AppComponentFactory</code></a> Klasse. </p><br><hr><br><p>  DI ist sehr wichtig f√ºr die moderne Android-Entwicklung.  Auf diese Weise k√∂nnen Sie die Gesamtmenge an Code reduzieren, wenn Sie Links zu Diensten erhalten, die zwischen Klassen verwendet werden, und die Anwendung im Allgemeinen gut in Komponenten unterteilen.  In diesem Artikel konzentrieren wir uns auf Dagger 2, die in der Android-Entwicklung am h√§ufigsten verwendete DI-Bibliothek.  Es wird davon ausgegangen, dass Sie bereits Grundkenntnisse dar√ºber haben, wie dies funktioniert, aber es ist nicht erforderlich, alle Feinheiten zu verstehen.  Es ist erw√§hnenswert, dass dieser Artikel ein kleines Abenteuer ist.  Das ist interessant und alles, aber zum Zeitpunkt des Schreibens erschien Android 9 Pie noch nicht einmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Plattformversionsfenster</a> , sodass dieses Thema wahrscheinlich f√ºr mindestens einige Jahre nicht f√ºr die allt√§gliche Entwicklung relevant sein wird. </p><a name="habracut"></a><br><h3 id="vnedrenie-zavisimostey-v-android-segodnya">  Abh√§ngigkeitsinjektion in Android heute </h3><br><p>  Einfach ausgedr√ºckt, verwenden wir DI, um unseren abh√§ngigen Klassen, dh denjenigen, die die Arbeit erledigen, Instanzen von Abh√§ngigkeitsklassen bereitzustellen.  Angenommen, wir verwenden das <a href="">Repository-Muster</a> , um unsere datenbezogene Logik zu verarbeiten, und m√∂chten unser Repository in Aktivit√§t verwenden, um dem Benutzer einige Daten anzuzeigen.  M√∂glicherweise m√∂chten wir dasselbe Repository an mehreren Stellen verwenden. Daher verwenden wir die Abh√§ngigkeitsinjektion, um die gemeinsame Nutzung derselben Instanz zwischen mehreren Klassen zu vereinfachen. </p><br><p>  Zun√§chst stellen wir ein Repository bereit.  Wir werden die <code>Provides</code> Funktion im Modul definieren, damit Dagger wei√ü, dass dies genau die Instanz ist, die wir implementieren m√∂chten.  Bitte beachten Sie, dass unser Repository eine Kontextinstanz f√ºr die Arbeit mit Dateien und dem Netzwerk ben√∂tigt.  Wir werden es mit dem Anwendungskontext versehen. </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appContext: Context) { <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-meta"><span class="hljs-meta">@ApplicationScope</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideApplicationContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Context = appContext <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-meta"><span class="hljs-meta">@ApplicationScope</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Context</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Repository = Repository(context) }</code> </pre> <br><p>  Jetzt m√ºssen wir <code>Component</code> definieren, um die Implementierung der Klassen zu handhaben, in denen wir unser <code>Repository</code> m√∂chten. </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@ApplicationScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component(modules = [AppModule::class])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MainActivity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Schlie√ülich k√∂nnen wir unsere <code>Activity</code> so konfigurieren, dass sie unser Repository verwendet.  Angenommen, wir haben eine Instanz unserer <code>ApplicationComponent</code> anderen Stelle erstellt. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repository: Repository <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) <span class="hljs-comment"><span class="hljs-comment">//    application.applicationComponent.inject(this) //       } }</span></span></code> </pre> <br><p>  Das ist alles!  Wir haben gerade die Abh√§ngigkeitsinjektion innerhalb der Anwendung mit Dagger eingerichtet.  Es gibt verschiedene M√∂glichkeiten, dies zu tun, aber dies scheint der einfachste Ansatz zu sein. </p><br><h3 id="chto-ne-tak-s-tekuschim-podhodom">  Was ist falsch an dem aktuellen Ansatz? </h3><br><p>  In den obigen Beispielen haben wir zwei verschiedene Arten von Injektionen gesehen, eine offensichtlicher als die andere. </p><br><p>  Das erste, das Sie m√∂glicherweise √ºbersehen haben, wird als <strong>Einbettung in den Konstruktor bezeichnet</strong> .  Dies ist eine Methode zum Bereitstellen von Abh√§ngigkeiten √ºber den Konstruktor einer Klasse. Dies bedeutet, dass eine Klasse, die Abh√§ngigkeiten verwendet, keine Ahnung vom Ursprung der Instanzen hat.  Dies wird als die reinste Form der Abh√§ngigkeitsinjektion angesehen, da sie unsere Injektionslogik perfekt in unsere <code>Module</code> einkapselt.  In unserem Beispiel haben wir diesen Ansatz verwendet, um ein Repository bereitzustellen: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Context</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Repository = Repository(context)</code> </pre> <br><p>  Daf√ºr brauchten wir <code>Context</code> , den wir in der Funktion <code>provideApplicationContext()</code> bereitgestellt haben. </p><br><p>  Das zweite, offensichtlichere, was wir gesehen haben, ist die <strong>Implementierung der Klasse vor Ort</strong> .  Diese Methode wurde in unserer <code>MainActivity</code> , um unser Gesch√§ft bereitzustellen.  Hier definieren wir die Felder als Empf√§nger der Injektionen unter Verwendung der <code>Inject</code> Annotation.  Anschlie√üend <code>onCreate</code> wir <code>ApplicationComponent</code> in unserer Funktion <code>onCreate</code> dass Abh√§ngigkeiten in unsere Felder <code>onCreate</code> werden m√ºssen.  Es sieht nicht so sauber aus wie das Einbetten in einen Konstruktor, da wir einen expliziten Verweis auf unsere Komponente haben, was bedeutet, dass das Konzept des Einbetten in unsere abh√§ngigen Klassen eindringt.  Ein weiterer Fehler in den Android Framework-Klassen, da wir sicher sein m√ºssen, dass wir als erstes Abh√§ngigkeiten bereitstellen.  Wenn dies zum falschen Zeitpunkt im Lebenszyklus geschieht, versuchen wir m√∂glicherweise versehentlich, ein Objekt zu verwenden, das noch nicht initialisiert wurde. </p><br><p>  Idealerweise sollten Sie die Implementierungen in den Klassenfeldern vollst√§ndig entfernen.  Dieser Ansatz √ºberspringt Implementierungsinformationen f√ºr Klassen, die nichts dar√ºber wissen m√ºssen, und kann m√∂glicherweise Lebenszyklusprobleme verursachen.  Wir haben Versuche gesehen, es besser zu machen, und <em>Dagger</em> auf Android ist ein ziemlich zuverl√§ssiger Weg, aber am Ende w√§re es besser, wenn wir nur die Konstruktorinjektion verwenden k√∂nnten.  Derzeit k√∂nnen wir diesen Ansatz nicht f√ºr eine Reihe von Framework-Klassen verwenden, z. B. "Aktivit√§t", "Service", "Anwendung" usw., da diese vom System f√ºr uns erstellt werden.  Es scheint, dass wir im Moment nicht in der Lage sind, Klassen in Felder einzuf√ºhren.  Trotzdem bereitet Android 9 Pie etwas Interessantes vor, das vielleicht alles grundlegend ver√§ndern wird. </p><br><h3 id="vnedrenie-zavisimostey-v-android-9-pie">  Abh√§ngigkeitsinjektion in Android 9 Pie </h3><br><p>  Wie am Anfang des Artikels erw√§hnt, verf√ºgt Android 9 Pie √ºber eine AppComponentFactory-Klasse.  Die Dokumentation daf√ºr ist eher knapp und wird einfach als solche auf der Entwickler-Website ver√∂ffentlicht: </p><br><blockquote>  <em>Die Schnittstelle zur Steuerung der Erstellung von Manifestelementen.</em> </blockquote><p>  Es ist faszinierend.  "Manifest-Elemente" bezieht sich hier auf die Klassen, die wir in unserer <code>AndroidManifest</code> Datei <code>AndroidManifest</code> , z. B. Aktivit√§t, Dienst und unsere Anwendungsklasse.  Auf diese Weise k√∂nnen wir die Erstellung dieser Elemente "steuern". K√∂nnen wir nun die Regeln f√ºr die Erstellung unserer Aktivit√§ten festlegen?  Was f√ºr eine Freude! </p><br><p>  Lassen Sie uns tiefer graben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>AppComponentFactory</code></a> erweitern wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>AppComponentFactory</code></a> und √ºberschreiben die <code>instantiateActivity</code> Methode. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InjectionComponentFactory</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppComponentFactory</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> repository = NonContextRepository() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instantiateActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ClassLoader</span></span></span></span><span class="hljs-function"><span class="hljs-params">, className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, intent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Intent</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: Activity { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { className == MainActivity::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span></span>(repository) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.instantiateActivity(cl, className, intent) } } }</code> </pre> <br><p>  Jetzt m√ºssen wir unsere Komponentenfactory im Manifest innerhalb des <strong>Anwendungs-</strong> Tags deklarieren. </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:allowBackup</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@string/app_name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:icon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@mipmap/ic_launcher"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".InjectionApp"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:appComponentFactory</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.mypackage.injectiontest.component.InjectionComponentFactory"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:theme</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@style/AppTheme"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">tools:replace</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android:appComponentFactory"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Endlich k√∂nnen wir unsere Anwendung starten ... und es funktioniert!  Unser <code>NonContextRepository</code> √ºber den MainActivity-Konstruktor bereitgestellt.  Anmutig! </p><br><p>  Bitte beachten Sie, dass es einige Vorbehalte gibt.  Wir k√∂nnen <code>Context</code> hier nicht verwenden, da bereits vor seiner Existenz ein Aufruf unserer Funktion erfolgt - das ist verwirrend!  Wir k√∂nnen noch weiter gehen, damit der Konstruktor unsere Anwendungsklasse implementiert, aber lassen Sie uns sehen, wie Dagger dies noch einfacher machen kann. </p><br><h3 id="vstrechayte--dagger-multi-binds">  Treffen Sie - Dolch Multi-Binds </h3><br><p>  Ich werde nicht auf die Details des Dolch-Mehrfachbindungsvorgangs unter der Haube eingehen, da dies den Rahmen dieses Artikels sprengt.  Alles, was Sie wissen m√ºssen, ist, dass es eine gute M√∂glichkeit bietet, in den Klassenkonstruktor einzuf√ºgen, ohne den Konstruktor manuell aufrufen zu m√ºssen.  Wir k√∂nnen dies verwenden, um Framework-Klassen auf skalierbare Weise einfach zu implementieren.  Mal sehen, wie sich alles summiert. </p><br><p>  Lassen Sie uns zuerst unsere Aktivit√§t einrichten, um herauszufinden, wohin wir als n√§chstes gehen sollen. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> repository: NonContextRepository ): Activity() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) <span class="hljs-comment"><span class="hljs-comment">//       } }</span></span></code> </pre> <br><p>  Dies zeigt sofort, dass die Abh√§ngigkeitsinjektion fast <em>nicht</em> erw√§hnt wird.  Das einzige, was wir sehen, ist die <code>Inject</code> Annotation vor dem Konstruktor. </p><br><p>  Jetzt m√ºssen Sie die Komponente und das Dolchmodul √§ndern: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Component(modules = [ApplicationModule::class])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(factory: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">InjectionComponentFactory</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Module(includes = [ComponentModule::class])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: NonContextRepository = NonContextRepository() }</code> </pre> <br><p>  Es hat sich nicht viel ge√§ndert.  Jetzt m√ºssen wir nur noch unsere Komponentenfabrik implementieren, aber wie erstellen wir unsere Manifestelemente?  Hier brauchen wir ein <code>ComponentModule</code> .  Mal sehen: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-meta"><span class="hljs-meta">@IntoMap</span></span> <span class="hljs-meta"><span class="hljs-meta">@ComponentKey(MainActivity::class)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindMainActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MainActivity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Any <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindComponentHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(componentHelper: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ComponentHelper</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ComponentInstanceHelper } <span class="hljs-meta"><span class="hljs-meta">@Target(AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.PROPERTY_SETTER)</span></span> <span class="hljs-meta"><span class="hljs-meta">@Retention(AnnotationRetention.RUNTIME)</span></span> <span class="hljs-meta"><span class="hljs-meta">@MapKey</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">annotation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentKey</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clazz: KClass&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Any&gt;)</code> </pre> <br><p>  Ja, nur ein paar Anmerkungen.  Hier verbinden wir unsere <code>Activity</code> mit einer Map, implementieren diese Map in unsere <code>ComponentHelper</code> Klasse und stellen diesen <code>ComponentHelper</code> bereit - alles in zwei <code>Binds</code> Anweisungen.  Dagger wei√ü dank der <code>MainActivity</code> Annotation <code>Inject</code> wie er unsere <code>MainActivity</code> instanziiert <code>Inject</code> sodass er den Provider an diese Klasse binden und automatisch die Abh√§ngigkeiten bereitstellen kann, die wir f√ºr den Konstruktor ben√∂tigen.  Unser <code>ComponentHelper</code> wie folgt. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentHelper</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> creators: Map&lt;Class&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Any&gt;, <span class="hljs-meta"><span class="hljs-meta">@JvmSuppressWildcards</span></span> Provider&lt;Any&gt;&gt; ): ComponentInstanceHelper { <span class="hljs-meta"><span class="hljs-meta">@Suppress(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UNCHECKED_CAST"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: T? = creators .filter { it.key.name == className } .values .firstOrNull() ?.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? T } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InstanceComponentHelper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: T? }</code> </pre> <br><p>  Einfach ausgedr√ºckt, wir haben jetzt eine Klassen√ºbersicht f√ºr Lieferanten f√ºr diese Klassen.  Wenn wir versuchen, eine Klasse nach Namen aufzul√∂sen, suchen wir einfach den Anbieter f√ºr diese Klasse (falls vorhanden), rufen ihn auf, um eine neue Instanz dieser Klasse abzurufen, und geben ihn zur√ºck. </p><br><p>  Schlie√ülich m√ºssen wir √Ñnderungen an unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>AppComponentFactory</code></a> , um unsere neue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>AppComponentFactory</code></a> verwenden zu k√∂nnen. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InjectionComponentFactory</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppComponentFactory</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> componentHelper: ComponentInstanceHelper <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { DaggerApplicationComponent.create().inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instantiateActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ClassLoader</span></span></span></span><span class="hljs-function"><span class="hljs-params">, className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, intent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Intent</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: Activity { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> componentHelper .resolve&lt;Activity&gt;(className) ?.apply { setIntent(intent) } ?: <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.instantiateActivity(cl, className, intent) } }</code> </pre> <br><p>  F√ºhren Sie den Code erneut aus.  Es funktioniert alles!  Was f√ºr eine Freude. </p><br><h3 id="problemy-vnedreniya-v-konstruktor">  Probleme bei der Implementierung des Konstruktors </h3><br><p>  Ein solcher Titel mag nicht sehr beeindruckend aussehen.  Obwohl wir die meisten Instanzen im normalen Modus einbetten k√∂nnen, indem wir sie in den Konstruktor einf√ºgen, haben wir keine offensichtliche M√∂glichkeit, den Kontext f√ºr unsere Abh√§ngigkeiten auf standardm√§√üige Weise bereitzustellen.  Aber der <code>Context</code> in Android ist alles.  Es wird f√ºr den Zugriff auf Einstellungen, Netzwerk, Anwendungskonfiguration und vieles mehr ben√∂tigt.  Bei unseren Abh√§ngigkeiten handelt es sich h√§ufig um Dinge, die datenbezogene Dienste wie Netzwerk und Einstellungen verwenden.  Wir k√∂nnen dies umgehen, indem wir unsere Abh√§ngigkeiten in reine Funktionen umschreiben oder alles mit Kontextinstanzen in unserer <code>Application</code> initialisieren. Es ist jedoch viel mehr Arbeit erforderlich, um den besten Weg zu finden, dies zu tun. </p><br><p>  Ein weiterer Nachteil dieses Ansatzes ist die Definition des Anwendungsbereichs.  In Dagger ist eines der Schl√ºsselkonzepte f√ºr die Implementierung einer Hochleistungs-Abh√§ngigkeitsinjektion mit einer guten Trennung der Klassenbeziehungen die Modularit√§t des Objektgraphen und die Verwendung des Bereichs.  Obwohl dieser Ansatz die Verwendung von Modulen nicht verbietet, schr√§nkt er die Verwendung des Anwendungsbereichs ein.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>AppComponentFactory</code></a> befindet sich auf einer v√∂llig anderen Abstraktionsebene als unsere Standard-Framework-Klassen. Wir k√∂nnen keinen programmgesteuerten Link dazu erhalten, sodass wir keine Anweisung haben, Abh√§ngigkeiten f√ºr <code>Activity</code> in einem anderen Bereich bereitzustellen. </p><br><p>  Es gibt viele M√∂glichkeiten, unsere Probleme mit Bereichen in der Praxis zu l√∂sen. Eine davon ist die Verwendung einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>FragmentFactory</code></a> , um unsere Fragmente in einen Konstruktor mit Bereichen einzubetten.  Ich werde nicht auf Details eingehen, aber es stellt sich heraus, dass wir jetzt eine Methode zur Steuerung der Erstellung von Fragmenten haben, die uns nicht nur viel mehr Spielraum gibt, sondern auch Abw√§rtskompatibilit√§t bietet. </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  Android 9 Pie hat eine M√∂glichkeit eingef√ºhrt, die Einbettung in den Konstruktor zu verwenden, um Abh√§ngigkeiten in unseren Framework-Klassen wie "Aktivit√§t" und "Anwendung" bereitzustellen.  Wir haben gesehen, dass wir mit <em>Dagger Multi-Binding</em> problemlos Abh√§ngigkeiten auf Anwendungsebene bereitstellen k√∂nnen. </p><br><p>  Ein Konstruktor, der alle unsere Komponenten implementiert, ist √§u√üerst attraktiv, und wir k√∂nnen sogar etwas tun, damit er mit Kontextinstanzen ordnungsgem√§√ü funktioniert.  Dies ist eine vielversprechende Zukunft, die jedoch erst ab API 28 verf√ºgbar ist. Wenn Sie weniger als 0,5% der Benutzer erreichen m√∂chten, k√∂nnen Sie es versuchen.  Andernfalls sollten Sie abwarten, ob eine solche Methode in einigen Jahren relevant bleibt. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444530/">https://habr.com/ru/post/de444530/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444520/index.html">2. Check Point Erste Schritte R80.20. L√∂sungsarchitektur</a></li>
<li><a href="../de444522/index.html">Die Apokalypse wird abgebrochen</a></li>
<li><a href="../de444524/index.html">Lambdas: von C ++ 11 bis C ++ 20. Teil 1</a></li>
<li><a href="../de444526/index.html">DOTS-Stapel: C ++ & C #</a></li>
<li><a href="../de444528/index.html">Situation: Japan kann das Herunterladen von Inhalten aus dem Netzwerk einschr√§nken - wir verstehen und diskutieren</a></li>
<li><a href="../de444534/index.html">Schwachstellen-Scan und sichere Entwicklung. Teil 1</a></li>
<li><a href="../de444536/index.html">MVCC-2. Ebenen, Dateien, Seiten</a></li>
<li><a href="../de444540/index.html">Intel ist bereit, mit der Produktion von MRAM-Speicher zu beginnen</a></li>
<li><a href="../de444542/index.html">Live-Stream und Konferenzplan f√ºr SmartMail Conf: Maschinelles Lernen</a></li>
<li><a href="../de444544/index.html">Etwas √ºber verteilte Rechenzentren f√ºr Unternehmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>