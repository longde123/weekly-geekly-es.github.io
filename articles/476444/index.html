<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë™ üå¶Ô∏è ‚õ∏Ô∏è Desmitificaci√≥n de los principios de la computaci√≥n cu√°ntica. ‚ùå üçì üßõüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Creo que puedo decir con seguridad que nadie entiende la mec√°nica cu√°ntica", Richard Feynman 

 El tema de la computaci√≥n cu√°ntica siempre ha atra√≠do...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desmitificaci√≥n de los principios de la computaci√≥n cu√°ntica.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/476444/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/7de/0de/1cc7de0de64ab4691f4d12f2b54a51ab.png" width="400"></div><br>  "Creo que puedo decir con seguridad que nadie entiende la mec√°nica cu√°ntica", Richard Feynman <br><br>  El tema de la computaci√≥n cu√°ntica siempre ha atra√≠do a escritores t√©cnicos y periodistas.  Su potencial computacional y su complejidad le dieron una especie de halo m√≠stico.  Con demasiada frecuencia, los art√≠culos tem√°ticos y las infograf√≠as describen en detalle todo tipo de perspectivas para esta industria, mientras apenas tocan los temas de su aplicaci√≥n pr√°ctica: esto puede confundir a un lector no demasiado cuidadoso. <br><a name="habracut"></a><br>  En los art√≠culos de divulgaci√≥n cient√≠fica, se omiten descripciones de sistemas cu√°nticos y declaraciones como: <br><br>  <i>Un bit normal puede ser igual a "1" o "0", pero un qubit puede ser simult√°neamente igual a "1" y "0".</i> <br><br>  Si tienes mucha suerte (de lo que no estoy seguro), te dir√°n que: <br><br>  <i>El qubit est√° en una superposici√≥n entre "1" y "0".</i> <br><br>  Ninguna de estas explicaciones parece plausible, porque estamos tratando de formular un fen√≥meno de mec√°nica cu√°ntica utilizando herramientas de lenguaje creadas en un mundo muy tradicional.  Para explicar claramente los principios de la computaci√≥n cu√°ntica, es necesario usar otro lenguaje: matem√°tico. <br><br>  En esta gu√≠a, hablar√© sobre las herramientas matem√°ticas necesarias para modelar y comprender los sistemas de computaci√≥n cu√°ntica, y c√≥mo ilustrar y aplicar la l√≥gica de la computaci√≥n cu√°ntica.  Adem√°s, dar√© un ejemplo de un algoritmo cu√°ntico y dir√© cu√°l es su ventaja sobre una computadora tradicional. <br><br>  Har√© todo lo posible para hablar de todo esto en un lenguaje comprensible, pero aun as√≠ espero que los lectores de este art√≠culo tengan ideas b√°sicas sobre √°lgebra lineal y l√≥gica digital ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> se describe el √°lgebra lineal, la l√≥gica digital est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ). <br><br>  Para comenzar, repasemos los principios de la l√≥gica digital.  Se basa en el uso de circuitos el√©ctricos para los c√°lculos.  Para hacer nuestra descripci√≥n m√°s abstracta, simplificamos el estado del cable a "1" o "0", que corresponder√° a los estados "encendido" o "apagado".  Habiendo construido transistores en una secuencia determinada, crearemos los llamados elementos l√≥gicos que toman uno o m√°s valores de las se√±ales de entrada y los convertimos en una se√±al de salida basada en ciertas reglas de la l√≥gica booleana. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ec/872/e40/4ec872e405490899e02ed8c8c9923055.png"></div><br><h2>  Elementos l√≥gicos comunes y tablas de estado </h2><br>  Sobre la base de las cadenas de estos elementos b√°sicos, puede crear elementos m√°s complejos, y sobre la base de las cadenas de elementos m√°s complejos, en √∫ltima instancia, podemos confiar en obtener un an√°logo del procesador central con un alto grado de abstracci√≥n. <br><br>  Como mencion√© anteriormente, necesitamos una forma de mapear matem√°ticamente la l√≥gica digital.  Primero, introduzcamos la l√≥gica matem√°tica tradicional.  Usando √°lgebra lineal, los bits cl√°sicos con los valores "1" y "0" se pueden representar como dos vectores de columna: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9c/434/3df/c9c4343df6118928be1a7bca294bbf9b.png" width="200"></div><br>  donde los n√∫meros a la izquierda son la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">notaci√≥n</a> vectorial de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dirac</a> .  Al representar nuestros bits de esta manera, podemos modelar operaciones l√≥gicas en bits utilizando transformaciones vectoriales.  Tenga en cuenta: a pesar del hecho de que cuando usa dos bits en elementos l√≥gicos, puede realizar muchas operaciones (‚ÄúAND‚Äù (AND), ‚ÄúNot‚Äù (NOT), ‚ÄúExclude Or‚Äù (XOR), etc.), cuando usa uno bits es posible realizar solo cuatro operaciones: conversi√≥n de identidad, negaci√≥n, c√°lculo de la constante "0" y c√°lculo de la constante "1".  Durante la conversi√≥n id√©ntica, el bit permanece sin cambios, cuando se niega, el valor del bit se invierte (de "0" a "1" o de "1" a "0"), y el c√°lculo de la constante "1" o "0" establece el bit a "1" o "0" independientemente de su valor anterior. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/8bd/c76/7a88bdc760e2f03ffd3da0030335445c.png" width="400"></div><br><div class="scrollable-table"><table><tbody><tr><td>  Identidad <br></td><td>  Transformaci√≥n de la identidad <br></td></tr><tr><td>  Negaci√≥n <br></td><td>  Negaci√≥n <br></td></tr><tr><td>  Constante-0 <br></td><td>  C√°lculo de la constante "0" <br></td></tr><tr><td>  Constante-1 <br></td><td>  C√°lculo de la constante "1" <br></td></tr></tbody></table></div><br>  Basado en nuestra nueva representaci√≥n de un bit, es bastante f√°cil realizar operaciones en el bit correspondiente usando la transformaci√≥n vectorial: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3f/6f4/92d/a3f6f492dc62d70852f3be02a1323a69.png" width="400"></div><br><br>  Antes de continuar, veamos el concepto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">computaci√≥n reversible</a> , que solo implica que para garantizar la reversibilidad de una operaci√≥n o elemento l√≥gico, es necesario determinar una lista de valores de se√±al de entrada en funci√≥n de las se√±ales de salida y los nombres de las operaciones utilizadas.  Por lo tanto, podemos concluir que la transformaci√≥n de identidad y la negaci√≥n son reversibles, pero la operaci√≥n de calcular las constantes "1" y "0" no lo es.  Debido a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">unitaridad de</a> la mec√°nica cu√°ntica, las computadoras cu√°nticas utilizan operaciones exclusivamente reversibles, por lo que nos centraremos en ellas.  A continuaci√≥n, convertiremos los elementos irreversibles en elementos reversibles para garantizar que puedan ser utilizados por una computadora cu√°ntica. <br><br>  Usando el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">producto tensor de</a> bits individuales, se pueden representar muchos bits: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21c/07e/a5f/21c07ea5f6329faf6214fcff5fbbcc5e.png" width="400"></div><br>  Ahora que tenemos casi todos los conceptos matem√°ticos necesarios, pasaremos a nuestro primer elemento de l√≥gica cu√°ntica.  Este es el operador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CNOT</a> , o el "NO" controlado (NO), que es de gran importancia en la computaci√≥n reversible y cu√°ntica.  El elemento CNOT se aplica a dos bits y devuelve dos bits.  El primer bit se asigna como "control" y el segundo - "control".  Si el bit de control se establece en "1", el bit de control cambia su valor;  si el bit de control se establece en "0", el bit de control no cambia. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2e/55a/f27/f2e55af2760a72e7389a1ce0777cc216.png"></div><br>  Este operador se puede representar como el siguiente vector de transformaci√≥n: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c18/c12/c0a/c18c12c0a3d170ae5d6cc02726f9e24a.png"></div><br>  Para demostrar todo lo que ya hemos tratado, le mostrar√© c√≥mo usar el elemento CNOT con respecto a muchos bits: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdb/1f0/ef0/bdb1f0ef078a62a045af5a3432ff5eaa.png"></div><br>  Resumimos lo que ya se ha dicho: en el primer ejemplo, descomponemos | 10‚ü© en partes de su producto tensor y utilizamos la matriz CNOT para obtener un nuevo estado correspondiente del producto;  entonces lo factorizamos a | 11‚ü© de acuerdo con la tabla de valores CNOT dada anteriormente. <br><br>  Entonces, recordamos todas las reglas matem√°ticas que nos ayudar√°n a lidiar con los c√°lculos tradicionales y los bits ordinarios, y finalmente podemos pasar a la computaci√≥n cu√°ntica moderna y los qubits. <br><br>  Si lees hasta este lugar, entonces tengo buenas noticias para ti: los qubits se pueden expresar f√°cilmente matem√°ticamente.  En general, si el bit cl√°sico (cbit) se puede establecer en | 1‚ü© o | 0‚ü©, el qubit est√° simplemente en superposici√≥n y puede ser igual a | 0‚ü© y | 1‚ü© antes de la medici√≥n.  Despu√©s de la medici√≥n, colapsa en | 0‚ü© o | 1‚ü©.  En otras palabras, un qubit se puede representar como una combinaci√≥n lineal de | 0‚ü© y | 1‚ü© de acuerdo con la siguiente f√≥rmula: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd7/ec8/e2e/fd7ec8e2e1b3dd8167d584664a4bfa90.png" width="200"></div><br>  donde <i>a‚ÇÄ</i> y <i>a‚ÇÅ</i> representan, respectivamente, las amplitudes | 0‚ü© y | 1‚ü©.  Pueden considerarse como "probabilidades cu√°nticas", que representan la probabilidad de que un qubit se colapse en cualquiera de los estados despu√©s de su medici√≥n, ya que en la mec√°nica cu√°ntica un objeto en superposici√≥n se colapsa en uno de los estados despu√©s de la fijaci√≥n.  Expanda esta expresi√≥n y obtenga lo siguiente: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c80/3ae/a51/c803aea51e4c1afa3d1fb2120f02333b.png" width="200"></div><br>  Para simplificar mi explicaci√≥n, utilizar√© esta misma noci√≥n en este art√≠culo. <br><br>  Para este qubit, la probabilidad de colapso de <i>a‚ÇÄ</i> despu√©s de la medici√≥n es |  <i>a</i> ‚ÇÄ | ¬≤, y la posibilidad de colapso en <i>a</i> ‚ÇÅ es igual a |  <i>a</i> ‚ÇÅ | ¬≤.  Por ejemplo, para el siguiente qubit: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1a/d62/80d/b1ad6280d3eb193391b69bcd43fa28c7.png" width="200"></div><br>  la posibilidad de colapso en "1" es | 1 / ‚àö2 | ¬≤, o ¬Ω, es decir, 50/50. <br><br>  Dado que en el sistema cl√°sico todas las probabilidades en la suma deben dar unidad (para una distribuci√≥n de probabilidad completa), podemos concluir que los cuadrados de los valores absolutos de las amplitudes | 0‚ü© y | 1‚ü© deben sumar uno.  En base a esta informaci√≥n, podemos componer la siguiente ecuaci√≥n: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74e/96b/6aa/74e96b6aa455eaab9c77562b3286648b.png"></div><br>  Si est√° familiarizado con la trigonometr√≠a, notar√° que esta ecuaci√≥n corresponde al teorema de Pit√°goras (a¬≤ + b¬≤ = c¬≤), es decir, podemos representar gr√°ficamente los posibles estados del qubit en forma de puntos en el c√≠rculo unitario, a saber: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/792/666/ef3/792666ef38e24cb8ce453e802f2fac6e.png" width="400"></div><br>  Los operadores y elementos l√≥gicos se aplican a los qubits, as√≠ como en el caso de los bits cl√°sicos, basados ‚Äã‚Äãen la transformaci√≥n de la matriz.  Todos los operadores de matriz reversibles que hemos recordado hasta la fecha, en particular, CNOT, se pueden usar para trabajar con qubits.  Tales operadores de matriz hacen posible usar cada una de las amplitudes de un qubit sin medirlo ni colapsarlo.  Perm√≠teme darte un ejemplo del uso del operador de negaci√≥n para dejar de fumar: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/8f9/17b/fa48f917b87b850ee63c2d85abc95a83.png"></div><br>  Antes de continuar, recuerdo que las amplitudes <i>a</i> ‚ÇÄ y <i>a</i> ‚ÇÅ son en realidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">n√∫meros complejos</a> , por lo que el estado qubit se puede mostrar con mayor precisi√≥n en una esfera de unidad tridimensional, tambi√©n conocida como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esfera de Bloch</a> : <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12c/e7e/1b4/12ce7e1b4211732a27bcf4b9b45d1be4.png" width="400"></div><br>  Sin embargo, para simplificar la explicaci√≥n, aqu√≠ nos restringimos a los n√∫meros reales. <br><br>  Parece que ha llegado el momento de discutir algunos elementos l√≥gicos que tienen sentido exclusivamente en el contexto de la computaci√≥n cu√°ntica. <br><br>  Uno de los operadores m√°s importantes es el "elemento Hadamard": toma un poco en el estado "0" o "1" y lo coloca en la superposici√≥n correspondiente con un 50% de posibilidades de colapsarlo a "1" o "0" despu√©s de la medici√≥n. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/587/3c7/11c/5873c711c538223c223588bb2767b080.png" width="400"></div><br>  Tenga en cuenta que hay un n√∫mero negativo en el lado inferior derecho del operador Hadamard.  Esto se debe al hecho de que el resultado del uso del operador depende del valor de la se√±al de entrada: - | 1‚ü© o | 0‚ü©, y por lo tanto el c√°lculo es reversible. <br><br>  Otro punto importante relacionado con el elemento Hadamard es su reversibilidad, es decir, puede tomar un qubit en la superposici√≥n correspondiente y convertirlo a | 0‚ü© o | 1‚ü©. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/803/8e1/e67/8038e1e6747112de2a6f516e42932c5d.png" width="400"></div><br>  Esto es muy importante porque nos permite transformarnos de un estado cu√°ntico sin determinar el estado del qubit, y, en consecuencia, sin colapsarlo.  Entonces, podemos estructurar la computaci√≥n cu√°ntica sobre la base de un principio determinista en lugar de un principio probabil√≠stico. <br><br>  Los operadores cu√°nticos que contienen n√∫meros exclusivamente reales son lo opuesto, por lo que podemos presentar el resultado de aplicar el operador a un qubit como una transformaci√≥n dentro del c√≠rculo unitario en forma de m√°quina de estados: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/505/c91/b24/505c91b2434b2d73e8738fbd31545718.png" width="400"></div><br>  Por lo tanto, el qubit, cuyo estado se muestra en el diagrama anterior, despu√©s de aplicar la operaci√≥n Hadamard se convierte al estado indicado por la flecha correspondiente.  De manera similar, podemos construir otra m√°quina de estados que ilustrar√° la transformaci√≥n de un qubit usando el operador de negaci√≥n, como se muestra arriba (tambi√©n conocido como el operador de negaci√≥n de Pauli o inversi√≥n de bits), como se muestra a continuaci√≥n: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/854/3d9/b1b/8543d9b1bf8a155b7a8945d814edfc00.png" width="400"></div><br>  Para realizar operaciones m√°s complejas con nuestro qubit, puede usar una cadena de muchos operadores o aplicar elementos muchas veces.  Un ejemplo de una transformaci√≥n en serie basada en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">representaci√≥n de una cadena cu√°ntica es la</a> siguiente: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/134/ef3/1cb/134ef31cb001fc1c9ff3c3854d32838b.png"></div><br>  Es decir, si comenzamos con el bit | 0‚ü©, aplicamos la inversi√≥n de bits, y luego la operaci√≥n Hadamard, luego otra inversi√≥n de bits, y nuevamente la operaci√≥n Hadamard, despu√©s de la cual la inversi√≥n de bits final, obtenemos el vector en el lado derecho de la cadena.  Al superponer varias m√°quinas de estado una encima de la otra, podemos comenzar con | 0‚ü© y rastrear las flechas de colores correspondientes a cada una de las transformaciones para comprender c√≥mo funciona todo esto. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad5/d18/c3f/ad5d18c3f9158b0e90d72403ad04564e.png" width="400"></div><br>  Como hemos llegado tan lejos, es hora de considerar uno de los tipos de algoritmos cu√°nticos, a saber, el algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Deutsch-Joji</a> , y mostrar su ventaja sobre una computadora cl√°sica.  Vale la pena se√±alar que el algoritmo Deutsch-Yogi es completamente determinista, es decir, devuelve la respuesta correcta en el 100% de los casos (a diferencia de muchos otros algoritmos cu√°nticos basados ‚Äã‚Äãen la determinaci√≥n probabil√≠stica de qubits). <br><br>  Imaginemos que tiene un cuadro negro que contiene una funci√≥n / operador en un bit (recuerde: cuando se usa un bit, solo son posibles cuatro operaciones: id√©nticamente transformar, negar, calcular la constante "0" y calcular la constante "1").  ¬øQu√© funci√≥n se realiza en una caja?  Sin embargo, no sabe cu√°l puede clasificar tantas variantes de los valores de entrada como desee y evaluar los resultados de salida. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c5e/f24/938/c5ef249384466b29fb07ea99b2c1b000.png"></div><br>  ¬øCu√°ntas se√±ales de entrada y salida deber√°n pasar por el cuadro negro para averiguar qu√© funci√≥n se utiliza?  Pi√©nsalo por un segundo. <br><br>  En el caso de una computadora cl√°sica, deber√° realizar 2 consultas para determinar la funci√≥n utilizada.  Por ejemplo, si al ingresar ‚Äú1‚Äù obtenemos ‚Äú0‚Äù en la salida, queda claro que se utiliza la funci√≥n para calcular la constante ‚Äú0‚Äù o la funci√≥n de negaci√≥n, despu√©s de lo cual deber√° cambiar el valor de la se√±al de entrada a ‚Äú0‚Äù y ver qu√© sucede. A la salida. <br><br>  En el caso de una computadora cu√°ntica, tambi√©n necesitar√° dos consultas, ya que a√∫n necesita dos valores de salida diferentes para determinar la funci√≥n exacta que se aplica al valor de entrada.  Sin embargo, si reformulamos un poco la pregunta, resulta que las computadoras cu√°nticas a√∫n tienen una gran ventaja: si quisiera saber si la funci√≥n utilizada es constante o variable, la superioridad estar√≠a del lado de las computadoras cu√°nticas. <br><br>  La funci√≥n utilizada en el cuadro es una variable, si diferentes valores de la se√±al de entrada dan resultados diferentes en la salida (por ejemplo, conversi√≥n e inversi√≥n id√©nticas de un bit), y si el valor de salida no cambia independientemente del valor de entrada, entonces la funci√≥n es constante (por ejemplo, calcular la constante "1" o el c√°lculo de la constante "0"). <br><br>  Usando el algoritmo cu√°ntico, puede determinar si una funci√≥n en un cuadro negro es constante o variable en base a una sola solicitud.  Pero antes de examinar en detalle c√≥mo hacer esto, necesitamos encontrar una manera que nos permita estructurar cada una de estas funciones en una computadora cu√°ntica.  Como cualquier operador cu√°ntico debe ser invertible, inmediatamente encontramos un problema: las funciones para calcular las constantes "1" y "0" no lo son. <br><br>  En la computaci√≥n cu√°ntica, a menudo se usa la siguiente soluci√≥n: se agrega un qubit de salida adicional, que devuelve cualquier valor de la se√±al de entrada recibida por la funci√≥n. <br><div class="scrollable-table"><table><tbody><tr><td>  Para: <br></td><td>  Despu√©s: <br></td></tr><tr><td><img src="https://habrastorage.org/webt/xi/kq/k3/xikqk3njz-k-xetlo8efjhjsggk.png"><br></td><td><img src="https://habrastorage.org/webt/lj/rq/f9/ljrqf955o6xtubsf9mrrvridfko.png"><br></td></tr></tbody></table></div>  Por lo tanto, podemos determinar los valores de entrada √∫nicamente en funci√≥n del valor obtenido en la salida, y la funci√≥n se vuelve invertible.  La estructura de los circuitos cu√°nticos crea la necesidad de un bit de entrada adicional.  En aras de desarrollar los operadores correspondientes, suponemos que el qubit de entrada adicional se establece en | 0‚ü©. <br><br>  Aplicando la misma representaci√≥n de la cadena cu√°ntica que usamos anteriormente, veremos c√≥mo cada uno de los cuatro elementos (transformaci√≥n de identidad, negaci√≥n, c√°lculo de la constante "0" y c√°lculo de la constante "1") se puede implementar utilizando operadores cu√°nticos. <br><br>  Por ejemplo, de esta manera puede implementar la funci√≥n de calcular la constante "0": <br><br>  <b>C√°lculo de la constante "0":</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/395/b09/e52/395b09e5258ce87f8f9a873d573853c2.png"></div><br>  Aqu√≠ no necesitamos operadores en absoluto.  El primer qubit de entrada (que tomamos igual a | 0‚ü©) ‚Äã‚Äãregresa con el mismo valor, y el segundo valor de entrada regresa a s√≠ mismo, como de costumbre. <br><br>  Con la funci√≥n para calcular la constante "1", la situaci√≥n es ligeramente diferente: <br><br>  <b>C√°lculo de la constante "1":</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbe/82d/51e/fbe82d51e97a2c5cc8d7b4d5446555c8.png"></div><br>  Como aceptamos que el primer qubit de entrada siempre se establece en | 0‚ü©, como resultado de aplicar el operador de inversi√≥n de bits, siempre da uno en la salida.  Y como de costumbre, el segundo qubit da su propio valor en la salida. <br><br>  Cuando se muestra el operador de transformaci√≥n de identidad, la tarea comienza a ser m√°s complicada.  Aqu√≠ se explica c√≥mo hacerlo: <br><br>  <b>Transformaci√≥n de identidad:</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bc/a2c/0c9/3bca2c0c97de2080ae979084924569a6.png"></div><br>  El s√≠mbolo utilizado aqu√≠ denota el elemento CNOT: la l√≠nea superior indica el bit de control y la l√≠nea inferior indica el bit de control.  Perm√≠tame recordarle que cuando utiliza el operador CNOT, el valor del bit de control cambia si el bit de control es | 1‚ü©, pero permanece sin cambios si el bit de control es | 0‚ü©.  Como asumimos que el valor de la l√≠nea superior siempre es igual a | 0‚ü©, su valor siempre se asigna a la l√≠nea inferior. <br><br>  Del mismo modo, actuamos con el operador de negaci√≥n: <br><br>  <b>Negaci√≥n:</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e0/9ea/05e/3e09ea05eb3aa4509360adb50250a57d.png" width="400"></div><br>  Simplemente invertimos el bit al final de la l√≠nea de salida. <br><br>  Ahora que hemos descubierto la presentaci√≥n preliminar, veamos las ventajas espec√≠ficas de una computadora cu√°ntica sobre una computadora tradicional cuando se trata de determinar la constancia o variabilidad de una funci√≥n oculta en un cuadro negro usando solo una consulta. <br><br>  Para resolver este problema utilizando la computaci√≥n cu√°ntica en una sola solicitud, es necesario traducir los qubits de entrada en una superposici√≥n antes de transferirlos a la funci√≥n, como se muestra a continuaci√≥n: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e76/ed6/9ca/e76ed69ca877e88a0cc269a5a3a27770.png"></div><br>  El elemento Hadamard se vuelve a aplicar al resultado del uso de la funci√≥n para derivar qubits de la superposici√≥n y hacer que el algoritmo sea determinista.  Iniciamos el sistema en el estado | 00‚ü© y por las razones de las que hablar√© ahora, obtenemos el resultado | 11‚ü© si la funci√≥n utilizada es constante.  Si la funci√≥n dentro del cuadro negro es variable, despu√©s de medir el sistema devuelve el resultado | 01‚ü©. <br><br>  Para tratar el resto del art√≠culo, pasemos a la ilustraci√≥n que mostr√© anteriormente: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad5/d18/c3f/ad5d18c3f9158b0e90d72403ad04564e.png" width="400"></div><br>  Usando el operador de inversi√≥n de bits y luego aplicando el elemento Hadamard a ambos valores de entrada iguales a | 0‚ü©, aseguraremos su traducci√≥n a la misma superposici√≥n | 0 | y | 1‚ü©, a saber: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a0/f37/764/6a0f37764e197dc76be36173f72b2f7a.png" width="400"></div><br>  Usando el ejemplo de transferir este valor de una funci√≥n a un cuadro negro, es f√°cil demostrar que ambas funciones de un valor constante dan | 11‚ü© a la salida. <br><br>  <b>C√°lculo de la constante "0":</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/959/675/2ca/9596752cadbc0194e1883322fed9ba2d.png" width="400"></div><br> ,  ,     ¬´1¬ª     |11‚ü©,  : <br><br> <b>  ¬´1¬ª:</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/628/2d3/bd76282d39512c75f15d30cbc18ade2a.png" width="400"></div><br>  :       |1‚ü©,  -1¬≤ = 1. <br><br>      ,             |01‚ü© (    ),     . <br><br> <b> :</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/771/51d/245/77151d245aa16fa8f8832ef4a4026576.png" width="400"></div><br>  CNOT   ,        ,                   CNOT    : <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d11/c25/1ee/d11c251ee0068742d7004e5fe2fe0fe8.png"></div><br>             |01‚ü©,       : <br><br> <b>:</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29b/9a3/120/29b9a31201cd3ce106480ba82f40970e.png" width="400"></div><br>  ,     ,       ,    . <br><br><h2>   ? </h2><br>    .     .    ,    , ,           ,   ,            . <br><br>            ‚Äî , ,       ,      -     (,       !).        ‚Äî ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> ,    |0‚ü©  |1‚ü©          . <br><br>           , <i></i>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬´   ¬ª (An Introduction to Quantum Algorithms)</a>  :     ,         . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/476444/">https://habr.com/ru/post/476444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../476428/index.html">Nginx VTS Stats, Mockify - simulacro de API, comparaci√≥n de Wiremock y Mockify</a></li>
<li><a href="../476430/index.html">C√≥mo crear el portafolio t√©cnico perfecto</a></li>
<li><a href="../476434/index.html">Escribimos controladores USB para dispositivos abandonados.</a></li>
<li><a href="../476436/index.html">Informes de la primera reuni√≥n en Rusia de desarrolladores de robots sobre Robot Operating System</a></li>
<li><a href="../476442/index.html">Dar algo de espacio o un microcontrolador como un medidor de frecuencia</a></li>
<li><a href="../476446/index.html">Complementos de Jira: algunos ejemplos de la invenci√≥n exitosa de la bicicleta</a></li>
<li><a href="../476448/index.html">Exploraci√≥n del sombreador de arena del juego Journey.</a></li>
<li><a href="../476450/index.html">Descripci√≥n general de cPanel: una consola basada en web para administrar sitios y hosting</a></li>
<li><a href="../476452/index.html">Almacenamiento de valor clave o c√≥mo nuestras aplicaciones se han vuelto m√°s convenientes</a></li>
<li><a href="../476454/index.html">Se acerca el 5G: qu√© empresas garantizar√°n la introducci√≥n de nuevas tecnolog√≠as en 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>