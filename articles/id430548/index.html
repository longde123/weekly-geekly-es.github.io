<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜 📫 🕠 Mengganggu dari perangkat eksternal dalam sistem x86. Bagian 1. Evolusi pengendali interupsi 👩🏻‍🌾 👩🏾‍🤝‍👨🏿 👼🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini, saya ingin mempertimbangkan mekanisme pengiriman interupsi dari perangkat eksternal dalam sistem x86 dan mencoba menjawab pertanyaan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengganggu dari perangkat eksternal dalam sistem x86. Bagian 1. Evolusi pengendali interupsi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430548/">  Pada artikel ini, saya ingin mempertimbangkan mekanisme pengiriman interupsi dari perangkat eksternal dalam sistem x86 dan mencoba menjawab pertanyaan: <br><br><ul><li>  Apa itu PIC dan untuk apa? </li><li>  Apa itu APIC dan untuk apa?  Untuk apa LAPIC dan I / O APIC? </li><li>  Apa perbedaan antara APIC, xAPIC dan x2APIC? </li><li>  Apa itu MSI?  Apa perbedaan antara MSI dan MSI-X? </li><li>  Bagaimana tabel $ PIR, MPtable, ACPI terkait dengan ini? </li></ul><br>  Jika Anda tertarik menerima jawaban untuk semua pertanyaan ini atau jika Anda hanya ingin membiasakan diri dengan evolusi pengontrol interupsi dalam sistem x86, selamat datang di cat. <br><a name="habracut"></a><br><h3>  Pendahuluan </h3><br>  Kita semua tahu apa itu gangguan.  Bagi yang bukan, kutipan dari wikipedia: <br><br><blockquote> Gangguan (Bahasa Inggris interupsi) - sinyal dari perangkat lunak atau perangkat keras yang menginformasikan prosesor tentang terjadinya peristiwa apa pun yang membutuhkan perhatian segera.  Gangguan memberitahu prosesor tentang terjadinya peristiwa prioritas tinggi yang memerlukan gangguan kode saat ini yang dijalankan oleh prosesor.  Prosesor merespons dengan menangguhkan aktivitasnya saat ini, menyimpan keadaannya dan menjalankan fungsi yang disebut pengendali interupsi (atau interrupt handler) yang merespons peristiwa dan layanan itu, setelah itu mengembalikan kontrol ke kode yang terputus. <br><br>  Tergantung pada sumber sinyal interupsi, mereka dibagi menjadi: <br><br><ul><li>  asynchronous, atau eksternal (perangkat keras) - peristiwa yang berasal dari perangkat perangkat keras eksternal (seperti perangkat periferal) dan dapat terjadi kapan saja secara sewenang-wenang: sinyal dari timer, kartu jaringan atau drive disk, penekanan tombol, gerakan mouse.  Fakta bahwa gangguan seperti itu terjadi dalam sistem ditafsirkan sebagai permintaan interupsi (IRQ) - perangkat melaporkan bahwa mereka memerlukan perhatian dari OS; </li><li>  peristiwa sinkron atau internal pada prosesor itu sendiri sebagai akibat dari pelanggaran kondisi tertentu ketika menjalankan kode mesin: pembagian dengan nol atau stack overflow, akses ke alamat memori yang tidak valid atau kode operasi yang tidak valid; </li></ul></blockquote>  Pada artikel ini, saya ingin membahas interupsi IRQ eksternal. <br><br>  Mengapa mereka dibutuhkan?  Misalkan kita ingin melakukan beberapa tindakan dengan paket input untuk kartu jaringan ketika tiba.  Agar tidak meminta kartu jaringan terus-menerus "apakah Anda memiliki paket baru?"  dan jangan sia-siakan sumber daya prosesor untuk hal ini, Anda dapat menggunakan interupsi IRQ.  Jalur interupsi perangkat terhubung ke jalur INTR prosesor, dan ketika sebuah paket diterima, kartu jaringan "menarik" garis ini.  Prosesor mengerti bahwa ada informasi untuknya dan membaca paket. <br><br>  Tetapi bagaimana jika ada banyak perangkat?  Anda tidak bisa mendapatkan cukup dari semua perangkat eksternal dari kaki prosesor. <br><br><img src="https://habrastorage.org/webt/vg/3q/3v/vg3q3v7kx8vjttp43xo99o8pccs.png"><br><br>  Untuk mengatasi masalah ini, mereka datang dengan sebuah chip - sebuah pengontrol interupsi. <br><br><h3>  Foto </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">osdev</a> ) <br><br>  Yang pertama adalah chip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Intel 8259 PIC</a> .  8 jalur input (IRQ0-7), dan satu output menghubungkan controller dengan jalur INTR prosesor.  Ketika interupsi dari suatu perangkat terjadi, 8259 menarik garis INTR, prosesor memahami bahwa beberapa perangkat memberi sinyal interupsi dan mensurvei PIC untuk memahami kaki IRQx yang menyebabkan interupsi.  Ada penundaan tambahan untuk survei ini, tetapi jumlah garis interupsi meningkat menjadi 8. <br><br><img src="https://habrastorage.org/webt/le/yf/6e/leyf6enogyzp6flpijo2d0x1w9g.png"><br><br>  Namun, 8 baris dengan cepat berubah menjadi kecil, dan untuk menambah jumlahnya, 2 8259 controller (master dan slave) yang terhubung dalam cascade (Dual PIC) digunakan. <br><br>  IRQ 0 hingga 7 diproses oleh Intel 8259 PIC (master) pertama, dan IRQs 8 hingga 15 diproses oleh 8259 PIC kedua (slave).  Hanya master yang memberi sinyal terjadinya interupsi.  Jika interupsi terjadi pada baris 8-15, PIC kedua (slave) memberi sinyal interupsi ke master melalui IRQ 2, dan master pada gilirannya memberi sinyal CPU.  Interupsi cascading ini mengambil salah satu dari 16 baris, tetapi pada akhirnya memberikan 15 interupsi yang tersedia untuk perangkat. <br><br><img src="https://habrastorage.org/webt/xj/yn/dh/xjyndhabujjwz0alrbx831zfzt8.png"><br><br>  Sirkuit telah memantapkan dirinya, dan inilah yang mereka maksud ketika mereka berbicara tentang PIC (Programm Interrupt Controller) sekarang.  Selanjutnya, pengendali 8259 menerima beberapa peningkatan, dan kemudian dikenal sebagai 8259A, dan sirkuit ini termasuk dalam chipset.  Pada saat bus utama untuk menghubungkan perangkat eksternal adalah bus ISA, sistem seperti itu secara keseluruhan sudah cukup.  Itu hanya perlu untuk memastikan bahwa perangkat yang berbeda tidak terhubung ke saluran IRQ yang sama untuk menghindari konflik, karena ISA menyela tidak dibagi. <br><br>  Biasanya tata letak interupsi untuk perangkat lebih atau kurang standar <br><br>  Contoh (diambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> ): <br>  IRQ 0 - timer sistem <br>  IRQ 1 - pengontrol keyboard <br>  IRQ 2 - cascade (interupsi dari slave controller) <br>  IRQ 3 - port serial COM2 <br>  IRQ 4 - port serial COM1 <br>  IRQ 5 - port paralel 2 dan 3 atau kartu suara <br>  IRQ 6 - pengontrol floppy <br>  IRQ 7 - port paralel 1 <br>  Penghitung waktu IRQ 8 - RTC <br>  IRQ 9 - ACPI <br>  IRQ 10 - terbuka / SCSI / NIC <br>  IRQ 11 - terbuka / SCSI / NIC <br>  IRQ 12 - pengendali mouse <br>  IRQ 13 - co-prosesor matematika <br>  IRQ 14 - saluran ATA 1 <br>  IRQ 15 - saluran ATA 2 <br><br>  Konfigurasi dan kerja dengan sirkuit mikro 8259 dilakukan melalui port I / O: <br><div class="scrollable-table"><table><tbody><tr><th>  Chip </th><th>  Daftar </th><th>  I / O port </th></tr><tr><td>  Master pic </td><td>  Perintah </td><td>  0x0020 </td></tr><tr><td>  Master pic </td><td>  Data </td><td>  0x0021 </td></tr><tr><td>  Foto budak </td><td>  Perintah </td><td>  0x00A0 </td></tr><tr><td>  Foto budak </td><td>  Data </td><td>  0x00A1 </td></tr></tbody></table></div><br>  → Dokumentasi untuk 8259A dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> <br><br>  Bus ISA digantikan oleh bus PCI.  Dan jumlah perangkat jelas mulai melebihi angka 15, ditambah, tidak seperti bus ISA statis, dalam hal ini, perangkat dapat ditambahkan ke sistem secara dinamis.  Tapi untungnya di bus ini interupsi dapat dibagi (yaitu, beberapa perangkat dapat dihubungkan ke jalur IRQ yang sama).  Akibatnya, untuk mengatasi masalah kurangnya jalur IRQ, mereka memutuskan untuk mengelompokkan interupsi dari semua perangkat PCI ke dalam jalur PIRQ (Programmable Interrupt Request). <br><br>  Katakanlah kita memiliki 4 jalur interupsi secara bebas pada pengontrol PIC, dan 20 perangkat PCI.  Kami menggabungkan interupsi dari 5 perangkat per baris PIRQx dan menghubungkan garis PIRQx ke controller.  Jika terjadi interupsi pada jalur PIRQx, prosesor harus menginterogasi semua perangkat yang terhubung ke jalur ini untuk memahami dari siapa datangnya interupsi, tetapi secara umum ini menyelesaikan masalah.  Perangkat yang mengikat jalur interupsi PCI dalam jalur PIRQ sering disebut router PIR. <br><br>  Dalam metode ini, Anda harus memastikan bahwa garis PIRQx tidak terhubung ke jalur IRQx di mana ISA menyela sudah dimulai (karena ini akan menyebabkan konflik), dan bahwa garis PIRQx seimbang (karena semakin banyak perangkat yang kami sambungkan ke jalur PIRQ yang sama, semakin banyak perangkat yang Anda butuhkan akan menginterogasi prosesor untuk memahami perangkat mana yang menyebabkan interupsi ini). <br><br><img src="https://habrastorage.org/webt/u_/jr/u9/u_jru9pemdeda2xvvbqihvgtp3y.png"><br><br>  <b>Catatan</b> : perangkat PCI -&gt; pemetaan PIR ditampilkan secara abstrak dalam gambar, karena sebenarnya ini agak lebih rumit.  Pada kenyataannya, setiap perangkat PCI memiliki 4 jalur interupsi (INTA, INTB, INTC, INTD).  Setiap perangkat PCI dapat memiliki hingga 8 fungsi, dan sekarang setiap fungsi memiliki satu interupsi INTx.  INTx yang mana setiap fungsi perangkat akan menarik ditentukan oleh konfigurasi chipset. <br><br>  Intinya, fungsi adalah blok logis yang terpisah.  Misalnya, dalam satu perangkat PCI mungkin ada fungsi pengontrol Smbus, fungsi pengontrol SATA, fungsi jembatan LPC.  Di sisi OS, setiap fungsi adalah perangkat terpisah dengan ruang konfigurasi PCI Config-nya sendiri. <br><br>  OS mengirimkan informasi tentang rute interupsi pada BIOS pengontrol PIC menggunakan tabel $ PIR dan dengan mengisi 3Ch (INT_LN Interrupt Line (R / W)) dan register 3Dh (INT_PN Interrupt Pin (RO)) dari ruang konfigurasi PCI untuk setiap fungsi.  Spesifikasi untuk tabel $ PIR sebelumnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di situs web Microsoft</a> , tetapi sekarang tidak ada lagi.  Isi baris dari tabel $ PIR dapat dipahami dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spesifikasi PCI BIOS</a> [4.2.2.  Dapatkan Opsi Routing Interupsi PCI] atau baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> <br><br><h3>  Apic </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">osdev</a> ) <br><br>  Metode sebelumnya bekerja hingga sistem multiprosesor muncul.  Faktanya adalah bahwa dalam perangkatnya PIC dapat mentransmisikan interupsi hanya ke satu prosesor utama.  Tapi saya ingin agar prosesor pada penanganan interupsi seimbang.  Solusi untuk masalah ini adalah antarmuka APIC baru (Advanced PIC). <br><br>  Untuk setiap prosesor, pengontrol LAPIC khusus (APIC Lokal) ditambahkan dan pengontrol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">I / O APIC</a> ditambahkan untuk merutekan interupsi dari perangkat.  Semua pengendali ini digabungkan dalam bus umum yang disebut APIC (sistem baru sekarang terhubung melalui bus sistem standar). <br><br>  Ketika interupsi dari perangkat tiba di pin I / O APIC, pengontrol merutekan interupsi ke LAPIC dari salah satu prosesor.  Kehadiran I / O APIC memungkinkan Anda untuk menyeimbangkan distribusi interupsi dari perangkat eksternal antar prosesor. <br><br>  Chip APIC pertama adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">82489DX</a> , itu adalah chip terpisah yang menggabungkan LAPIC dan I / O APIC.  Untuk membuat sistem 2 prosesor, 3 mikrosirkuit seperti itu diperlukan.  2 akan berfungsi sebagai LAPIC dan satu sebagai I / O APIC.  Kemudian, fungsi LAPIC secara langsung dimasukkan dalam prosesor, dan fungsi I / O APIC dibingkai dalam chip 82093AA. <br><br>  I / O APIC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">82093AA</a> berisi 24 pin input, dan arsitektur APIC dapat mendukung hingga 16 CPU.  Untuk menjaga kompatibilitas dengan sistem yang lebih lama, 0 ~ 15 interupsi dialokasikan untuk interupsi ISA lama.  Dan gangguan dari perangkat PCI mulai ditampilkan pada jalur IRQ 16-23.  Sekarang mungkin untuk tidak memikirkan konflik interupsi dari perangkat ISA dan PCI.  Juga, berkat peningkatan jumlah jalur interupsi gratis, juga dimungkinkan untuk meningkatkan jumlah saluran PIRQx. <br><br><img src="https://habrastorage.org/webt/mc/ra/hj/mcrahjn-owk9qrcmyiixcmhomcq.png"><br><br>  Pemrograman I / O APIC dan LAPIC dilakukan melalui MMIO.  Register LAPIC biasanya terletak di 0xFEE00000, register I / O APIC di 0xFE00000.  Meskipun, pada prinsipnya, semua alamat ini dapat dikonfigurasi ulang. <br><br>  Seperti dalam kasus PIC, awalnya, chip individu kemudian menjadi bagian dari chipset. <br><br>  Selanjutnya, arsitektur APIC menerima modernisasi dan versi baru disebut xAPIC (x - extended).  Kompatibilitas mundur yang dipertahankan dengan versi sebelumnya.  Jumlah CPU yang mungkin dalam sistem meningkat menjadi 256. <br><br>  Putaran pengembangan arsitektur selanjutnya disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">x2APIC</a> .  Jumlah CPU yang mungkin dalam sistem meningkat menjadi 2 ^ 32.  Pengontrol dapat bekerja dalam mode kompatibilitas xAPIC, atau dalam mode x2APIC baru, di mana pemrograman LAPIC dilakukan bukan melalui MMIO, tetapi melalui register MSR (yang jauh lebih cepat).  Dilihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oleh tautan ini,</a> dukungan IOMMU diperlukan agar mode ini berfungsi. <br><br>  Perlu dicatat bahwa sistem mungkin memiliki beberapa pengontrol APIC I / O.  Misalnya, satu untuk 24 gangguan di jembatan selatan, yang lain untuk 32 di utara.  Dalam konteks I / O APIC interupsi sering disebut sebagai GSI (Global System Interrupt).  Jadi dalam sistem seperti itu akan menjadi GSI 0-55. <br><br>  Apakah ada built-in LAPIC di CPU dan arsitektur mana yang dapat dipahami oleh flag bit di CPUID. <br>  Agar sistem mendeteksi LAPIC dan I / O APIC, BIOS harus memberikan informasi tentang mereka ke sistem baik melalui MPtable (metode lama) atau melalui tabel ACPI (MADT dalam kasus ini).  Selain informasi umum, MPtable dan ACPI (kali ini dalam tabel DSDT) harus berisi informasi tentang perutean interupsi, yaitu, informasi tentang perangkat mana yang berada pada garis interupsi (mirip dengan tabel $ PIR). <br><br>  Tabel MPTable dapat ditemukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20121002210153/">spesifikasi</a> resmi.  Sebelumnya, spesifikasinya ada di situs web Intel, tetapi sekarang hanya dapat ditemukan di arsip.  Spesifikasi ACPI sekarang terletak di situs web UEFI (versi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6.2</a> saat ini).  Perlu dicatat bahwa menggunakan ACPI Anda dapat menentukan perutean interupsi untuk sistem tanpa APIC (daripada menggunakan tabel $ PIR). <br><br><h3>  Msi </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki</a> ) <br><br>  Versi sebelumnya dengan APIC bagus, tetapi bukan tanpa cacat.  Semua jalur interupsi perangkat ini memperumit sirkuit dan meningkatkan kemungkinan kesalahan.  Bus PCI digantikan oleh PCI express, di mana jalur interupsi diputuskan untuk dihapus.  Untuk menjaga kompatibilitas, sinyal interupsi (INTx #) ditiru oleh jenis pesan tertentu.  Dalam skema ini, penambahan logis garis interupsi, yang dulu dilakukan dengan koneksi fisik kabel, jatuh di pundak jembatan PCI.  Namun, dukungan interupsi legacy INTx hanya mendukung kompatibilitas mundur dengan bus PCI.  Bahkan, PCI express telah mengusulkan metode baru untuk mengirimkan pesan interupsi - MSI (Message Signaled Interrupts).  Dalam metode ini, untuk memberi sinyal gangguan, perangkat cukup menulis ke area MMIO yang dialokasikan untuk LAPIC prosesor. <br><br><img src="https://habrastorage.org/webt/8z/qw/7h/8zqw7him-vupzm_wi5glkqtr1ja.png"><br><br>  Sebelumnya, hanya 4 interupsi yang dialokasikan untuk satu perangkat PCI (yaitu, untuk semua fungsinya), tetapi sekarang telah menjadi mungkin untuk mengatasi hingga 32 interupsi. <br><br>  Dalam kasus MSI, tidak ada pembagian untuk saluran, masing-masing interupsi sesuai dengan perangkatnya. <br><br>  MSI menyela juga memecahkan masalah lain.  Misalkan perangkat melakukan transaksi penulisan-memori, dan ingin melaporkan penyelesaiannya melalui interupsi.  Tetapi transaksi tulis mungkin tertunda di bus selama proses transfer (yang tidak diketahui perangkat sama sekali), dan sinyal interupsi akan tiba sebelum prosesor.  Dengan demikian, CPU masih akan membaca data yang tidak valid.  Jika MSI digunakan, informasi tentang MSI ditransmisikan serta data, dan tidak akan dapat datang lebih awal. <br><br>  Perlu dicatat bahwa interupsi MSI tidak dapat bekerja tanpa LAPIC, tetapi menggunakan MSI dapat menggantikan kami dengan I / O APIC (penyederhanaan desain). <br><br>  Selanjutnya, metode ini menerima ekstensi MSI-X.  Sekarang setiap perangkat dapat memiliki hingga 2048 interupsi.  Dan menjadi mungkin untuk menunjukkan secara individual untuk setiap interupsi pada prosesor mana yang harus dieksekusi.  Ini bisa sangat berguna untuk perangkat yang banyak dimuat seperti kartu jaringan. <br><br>  Tidak diperlukan tabel BIOS tambahan untuk dukungan MSI.  Tetapi perangkat harus melaporkan dukungan MSI di salah satu Kemampuan dalam PCI Config-nya, dan driver perangkat harus mendukung bekerja dengan MSI. <br><br><h3>  Kesimpulan </h3><br>  Dalam artikel ini, kami memeriksa evolusi pengendali interupsi, dan menerima informasi teoretis umum tentang pengiriman interupsi dari perangkat eksternal dalam sistem x86. <br><br>  Pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">selanjutnya,</a> kita akan melihat bagaimana menggunakan di Linux masing-masing pengendali yang dijelaskan dalam praktek. <br><br><h4>  Referensi: </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Interrupt Controllers (Stuff in the Middle)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa yang dilakukan berbagai interupsi dalam PCIe?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengurangi Latensi Interupsi Melalui Penggunaan Pesan Signaling Interrupts</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur Pemrosesan Interupsi untuk Sistem yang Kompatibel dengan Intel</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430548/">https://habr.com/ru/post/id430548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430534/index.html">Membuat templat untuk Zabbix menggunakan DVR Trassir SDK sebagai contoh</a></li>
<li><a href="../id430536/index.html">Merancang fungsi jendela diringkas menjadi satu unit dengan tingkat tumpang tindih yang diberikan</a></li>
<li><a href="../id430538/index.html">Apakah Anda membaca Scaladoc untuk metode pengumpulan yang "jelas"? Atau mengapa kemalasan tidak selalu baik</a></li>
<li><a href="../id430542/index.html">Buka webinar "Infrastruktur sebagai kode"</a></li>
<li><a href="../id430546/index.html">"Diyakini bahwa kode tersebut akan diganti oleh diagram UML, tetapi tidak perlu diuji": sebuah wawancara dengan Alexei Barantsev</a></li>
<li><a href="../id430550/index.html">Membangun sistem komponen reaktif dengan Kotlin</a></li>
<li><a href="../id430552/index.html">Startup of the day (September-Oktober 2018)</a></li>
<li><a href="../id430554/index.html">Google mematenkan sepatu VR yang bisa Anda jalani selamanya</a></li>
<li><a href="../id430556/index.html">GeekBrains Meluncurkan Kursus Pelatihan Manajer Produk</a></li>
<li><a href="../id430558/index.html">Cara penilaian bekerja di industri berbagi mobil. Bagian 1. Ikhtisar alat populer pada data nyata</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>