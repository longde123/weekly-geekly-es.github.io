<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜó ü•ô üèì ValueTask <TResult> - mengapa, mengapa dan bagaimana? üôãüèª üßöüèΩ ü§∏üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kata pengantar untuk terjemahan 


 Tidak seperti artikel ilmiah, artikel jenis ini sulit diterjemahkan "mendekati teks", dan cukup banyak adaptasi ya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ValueTask <TResult> - mengapa, mengapa dan bagaimana?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/465259/"><h3 id="predislovie-k-perevodu">  <em>Kata pengantar untuk terjemahan</em> </h3><br><p>  <em>Tidak seperti artikel ilmiah, artikel jenis ini sulit diterjemahkan "mendekati teks", dan cukup banyak adaptasi yang harus dilakukan.</em>  <em>Untuk alasan ini, saya meminta maaf atas beberapa kebebasan, untuk bagian saya, dalam berurusan dengan teks artikel asli.</em>  <em>Saya hanya dibimbing oleh satu tujuan - untuk membuat terjemahan dapat dimengerti, bahkan jika di tempat itu sangat menyimpang dari artikel asli.</em>  <em>Saya akan berterima kasih atas kritik konstruktif dan koreksi / penambahan terjemahan.</em> </p><br><h2 id="vvedenie">  Pendahuluan </h2><br><p> <code>System.Threading.Tasks</code> namespace dan kelas <code>Task</code> pertama kali diperkenalkan di .NET Framework 4. Sejak saat itu, tipe ini, dan class turunannya <code>Task&lt;TResult&gt;</code> , telah dengan kuat memasuki praktik pemrograman di .NET dan telah menjadi aspek kunci dari model asinkron. diimplementasikan dalam C # 5, dengan <code>async/await</code> .  Pada artikel ini, saya akan berbicara tentang tipe-tipe baru <code>ValueTask/ValueTask&lt;TResult&gt;</code> yang diperkenalkan untuk meningkatkan kinerja kode asinkron, dalam kasus di mana overhead memori memainkan peran kunci. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/f4/7b/3c/f47b3cblzfyn77xgh1odpwfgy5i.jpeg"></a> </p><a name="habracut"></a><br><h2 id="task">  Tugas </h2><br><p>  <code>Task</code> melayani beberapa tujuan, tetapi yang utama adalah "janji" - objek yang mewakili kemampuan untuk menunggu penyelesaian operasi.  Anda memulai operasi dan mendapatkan <code>Task</code> .  <code>Task</code> ini akan selesai ketika operasi itu sendiri selesai.  Dalam hal ini, ada tiga opsi: </p><br><ol><li>  Operasi selesai secara sinkron di utas inisiator.  <em>Misalnya, ketika mengakses beberapa data yang sudah ada di buffer</em> . </li><li>  Operasi dilakukan secara tidak sinkron, tetapi berhasil diselesaikan <em>pada saat</em> inisiator menerima <code>Task</code> .  <em>Misalnya, ketika melakukan akses cepat ke data yang belum di-buffer</em> </li><li>  Operasi dilakukan secara tidak sinkron, dan berakhir <em>setelah</em> inisiator menerima <code>Task</code> <em>contohnya adalah penerimaan data melalui jaringan</em> . </li></ol><br><p>  Untuk mendapatkan hasil panggilan asinkron, klien dapat memblokir utas panggilan sambil menunggu penyelesaian, yang sering bertentangan dengan ide asinkron, atau menyediakan metode panggilan balik yang akan dieksekusi setelah penyelesaian operasi asinkron.  Model panggilan balik di .NET 4 disajikan secara eksplisit, menggunakan metode <code>ContinueWith</code> dari objek kelas <code>Task</code> , yang menerima delegasi yang dipanggil setelah penyelesaian operasi asinkron. </p><br><pre> <code class="plaintext hljs">SomeOperationAsync().ContinueWith(task =&gt; { try { TResult result = task.Result; UseResult(result); } catch (Exception e) { HandleException(e); } });</code> </pre> <br><p>  Dengan .NET Frmaework 4.5 dan C # 5, mendapatkan hasil dari operasi asinkron disederhanakan dengan memperkenalkan kata kunci <code>async/await</code> dan mekanisme di baliknya.  Mekanisme ini, kode yang dihasilkan, mampu mengoptimalkan semua kasus yang disebutkan di atas, dengan benar menangani penyelesaian terlepas dari jalan di mana ia tercapai. </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  Kelas <code>Task</code> cukup fleksibel dan memiliki beberapa keunggulan.  Misalnya, Anda dapat "mengharapkan" objek kelas ini beberapa kali, Anda dapat mengharapkan hasilnya secara kompetitif, oleh sejumlah konsumen.  Contoh kelas dapat disimpan dalam kamus untuk sejumlah panggilan berikutnya, dengan tujuan "menunggu" di masa depan.  Skenario yang dijelaskan memungkinkan Anda untuk mempertimbangkan objek <code>Task</code> sebagai jenis cache hasil yang diperoleh secara tidak sinkron.  Selain itu, <code>Task</code> menyediakan kemampuan untuk memblokir utas tunggu sampai operasi selesai jika skrip mengharuskannya.  Ada juga yang disebut.  kombinator untuk berbagai strategi untuk menunggu penyelesaian set tugas, misalnya, "Task.WhenAny" - secara asinkron menunggu penyelesaian dari banyak tugas pertama. </p><br><p>  Tetapi, bagaimanapun, kasus penggunaan yang paling umum hanyalah memulai operasi asinkron dan kemudian menunggu hasil dari eksekusi.  Kasus sederhana seperti itu, sangat umum, tidak memerlukan fleksibilitas di atas: </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  Ini sangat mirip dengan cara kami menulis kode sinkron (mis. <code>TResult result = SomeOperation();</code> ).  Opsi ini secara alami diterjemahkan ke dalam <code>async/await</code> . </p><br><p>  Selain itu, untuk semua kelebihannya, jenis <code>Task</code> memiliki kelemahan potensial.  <code>Task</code> adalah kelas, yang berarti bahwa setiap operasi yang membuat turunan tugas mengalokasikan objek pada heap.  Semakin banyak objek yang kita buat, semakin banyak pekerjaan yang dibutuhkan dari GC, dan semakin banyak sumber daya yang dihabiskan untuk pekerjaan pengumpul sampah, sumber daya yang dapat digunakan untuk tujuan lain.  Ini menjadi masalah yang jelas untuk kode, di mana, di satu sisi, instance <code>Task</code> sering dibuat, dan di sisi lain, yang telah meningkatkan persyaratan untuk throughput dan kinerja. </p><br><p>  Runtime dan pustaka utama, dalam banyak situasi, berhasil mengurangi efek ini.  Misalnya, jika Anda menulis metode seperti di bawah ini: </p><br><pre> <code class="plaintext hljs">public async Task WriteAsync(byte value) { if (_bufferedCount == _buffer.Length) { await FlushAsync(); } _buffer[_bufferedCount++] = value; }</code> </pre> <br><p>  dan, paling sering, akan ada cukup ruang di buffer, operasi akan berakhir secara serempak.  Jika demikian, maka tidak ada yang istimewa tentang tugas yang dikembalikan, tidak ada nilai balik, dan operasi sudah selesai.  Dengan kata lain, kita berhadapan dengan <code>Task</code> , setara dengan operasi <code>void</code> sinkron.  Dalam situasi seperti itu, runtime dengan mudah meng-cache objek <code>Task</code> , dan menggunakannya setiap kali sebagai hasil untuk tugas <code>async Task</code> - metode yang selesai secara sinkron ( <code>Task.ComletedTask</code> ).  Contoh lain, katakanlah Anda menulis: </p><br><pre> <code class="plaintext hljs">public async Task&lt;bool&gt; MoveNextAsync() { if (_bufferedCount == 0) { await FillBuffer(); } return _bufferedCount &gt; 0; }</code> </pre> <br><p>  Misalkan, dengan cara yang sama, bahwa dalam banyak kasus, ada beberapa data dalam buffer.  Metode ini memeriksa <code>_bufferedCount</code> , melihat bahwa variabel lebih besar dari nol, dan mengembalikan <code>true</code> .  Hanya jika pada saat verifikasi data tidak disangga, operasi asinkron diperlukan.  Namun, hanya ada dua kemungkinan hasil logis ( <code>true</code> dan <code>false</code> ), dan hanya dua kemungkinan kembali melalui <code>Task&lt;bool&gt;</code> .  Berdasarkan penyelesaian sinkron, atau asinkron, tetapi sebelum keluar dari metode, runtime cache dua instance dari <code>Task&lt;bool&gt;</code> (satu untuk <code>true</code> dan satu untuk <code>false</code> ), dan mengembalikan yang diinginkan, menghindari alokasi tambahan.  Satu-satunya opsi ketika Anda harus membuat objek <code>Task&lt;bool&gt;</code> adalah kasus eksekusi asinkron, yang berakhir setelah "kembali".  Dalam hal ini, metode harus membuat objek <code>Task&lt;bool&gt;</code> , karena  pada saat keluar dari metode, hasil operasi belum diketahui.  Objek yang dikembalikan harus unik, karena  pada akhirnya akan menyimpan hasil operasi asinkron. </p><br><p>  Ada contoh lain dari caching serupa dari runtime.  Tetapi strategi seperti itu tidak berlaku di mana-mana.  Sebagai contoh, metode: </p><br><pre> <code class="plaintext hljs">public async Task&lt;int&gt; ReadNextByteAsync() { if (_bufferedCount == 0) { await FillBuffer(); } if (_bufferedCount == 0) { return -1; } _bufferedCount--; return _buffer[_position++]; }</code> </pre> <br><p>  juga sering berakhir secara serempak.  Tetapi, tidak seperti contoh sebelumnya, metode ini mengembalikan hasil integer yang memiliki sekitar empat miliar nilai yang mungkin.  Untuk melakukan cache <code>Task&lt;int&gt;</code> , dalam situasi ini, diperlukan ratusan gigabytes memori.  Lingkungan di sini juga mendukung cache kecil untuk <code>Task&lt;int&gt;</code> , untuk beberapa nilai kecil.  Jadi, misalnya, jika operasi selesai secara sinkron (data ada di buffer), dengan hasil 4, cache akan digunakan.  Tetapi jika hasilnya, meskipun sinkron, penyelesaiannya adalah 42, objek <code>Task&lt;int&gt;</code> akan dibuat, mirip dengan memanggil <code>Task.FromResult(42)</code> . </p><br><p>  Banyak implementasi perpustakaan mencoba mengurangi situasi ini dengan mendukung cache mereka sendiri.  Salah satu contoh adalah kelebihan <code>MemoryStream.ReadAsync</code> .  Operasi ini, diperkenalkan di .NET Framework 4.5, selalu berakhir secara sinkron, karena  itu hanya pembacaan dari ingatan.  <code>ReadAsync</code> mengembalikan <code>Task&lt;int&gt;</code> mana hasil integer mewakili jumlah byte yang dibaca.  Cukup sering, dalam kode, situasi terjadi ketika <code>ReadAsync</code> digunakan dalam satu lingkaran.  Apalagi jika ada gejala-gejala berikut: </p><br><ul><li>  Jumlah byte yang diminta tidak berubah untuk sebagian besar iterasi loop; </li><li>  Di sebagian besar iterasi, <code>ReadAsync</code> dapat membaca jumlah byte yang diminta. </li></ul><br><p>  Yaitu, untuk panggilan berulang, <code>ReadAsync</code> berjalan secara sinkron dan mengembalikan objek <code>Task&lt;int&gt;</code> , dengan hasil yang sama dari iterasi ke iterasi.  Adalah logis bahwa <code>MemoryStream</code> cache tugas terakhir yang berhasil diselesaikan, dan untuk semua panggilan berikutnya, jika hasil yang baru cocok dengan yang sebelumnya, ia akan mengembalikan instance dari cache.  Jika hasilnya tidak cocok, maka <code>Task.FromResult</code> digunakan untuk membuat contoh baru, yang, pada gilirannya, juga di-cache sebelum kembali. </p><br><p>  Tetapi, bagaimanapun, ada banyak kasus ketika operasi dipaksa untuk membuat objek <code>Task&lt;TResult&gt;</code> baru, bahkan ketika secara bersamaan diselesaikan. </p><br><h2 id="valuetasktresult-i-sinhronnoe-zavershenie">  ValueTask &lt;TResult&gt; dan penyelesaian sinkron </h2><br><p>  Semua ini, pada akhirnya, berfungsi sebagai motivasi untuk memperkenalkan tipe baru <code>ValueTask&lt;TResult&gt;</code> ke .NET Core 2.0.  Juga, melalui nuget-package <code>System.Threading.Tasks.Extensions</code> , tipe ini tersedia di rilis .NET lainnya. </p><br><p>  <code>ValueTask&lt;TResult&gt;</code> diperkenalkan di .NET Core 2.0 sebagai struktur yang mampu membungkus <code>TResult</code> atau <code>Task&lt;TResult&gt;</code> .  Ini berarti bahwa objek jenis ini dapat dikembalikan dari metode <code>async</code> .  Nilai tambah pertama dari pengenalan tipe ini langsung terlihat: jika metode berhasil diselesaikan dan disinkronkan, tidak perlu membuat sesuatu di heap, cukup membuat instance <code>ValueTask&lt;TResult&gt;</code> dengan nilai hasil.  Hanya jika metode keluar secara sinkron, kita perlu membuat <code>Task&lt;TResult&gt;</code> .  Dalam hal ini, <code>ValueTask&lt;TResult&gt;</code> digunakan sebagai pembungkus lebih dari <code>Task&lt;TResult&gt;</code> .  Keputusan untuk membuat <code>ValueTask&lt;TResult&gt;</code> dapat menggabungkan <code>Task&lt;TResult&gt;</code> dibuat dengan tujuan pengoptimalan: jika berhasil dan jika gagal, metode asinkron menciptakan <code>Task&lt;TResult&gt;</code> , dari sudut pandang optimasi memori, lebih baik menggabungkan <code>Task&lt;TResult&gt;</code> objek <code>Task&lt;TResult&gt;</code> itu sendiri <code>Task&lt;TResult&gt;</code> daripada menyimpan bidang tambahan di <code>ValueTask&lt;TResult&gt;</code> untuk berbagai kasus penyelesaian (misalnya, untuk menyimpan pengecualian). </p><br><p>  Mengingat hal di atas, tidak ada lagi kebutuhan untuk caching dalam metode seperti <code>MemoryStream.ReadAsync</code> atas, tetapi sebaliknya dapat diimplementasikan sebagai berikut: </p><br><pre> <code class="plaintext hljs">public override ValueTask&lt;int&gt; ReadAsync(byte[] buffer, int offset, int count) { try { int bytesRead = Read(buffer, offset, count); return new ValueTask&lt;int&gt;(bytesRead); } catch (Exception e) { return new ValueTask&lt;int&gt;(Task.FromException&lt;int&gt;(e)); } }</code> </pre> <br><h2 id="valuetasklttresultgt-i-asinhronnoe-zavershenie">  ValueTask &lt;TResult&gt; dan Pemutusan Asinkron </h2><br><p>  Memiliki kemampuan untuk menulis metode asinkron yang tidak memerlukan alokasi memori tambahan untuk hasilnya, dengan penyelesaian yang sinkron, benar-benar merupakan nilai tambah yang besar.  Seperti yang dinyatakan di atas, ini adalah tujuan utama untuk memperkenalkan tipe <code>ValueTask&lt;TResult&gt;</code> dalam .NET Core 2.0.  Semua metode baru yang diharapkan akan digunakan di "jalan panas" sekarang menggunakan <code>ValueTask&lt;TResult&gt;</code> alih-alih <code>Task&lt;TResult&gt;</code> sebagai tipe pengembalian.  Misalnya, kelebihan baru metode <code>ReadAsync</code> untuk <code>Stream</code> , dalam .NET Core 2.1 (yang menggunakan <code>Memory&lt;byte&gt;</code> alih-alih <code>byte[]</code> sebagai parameter), mengembalikan instance <code>ValueTask&lt;int&gt;</code> .  Ini memungkinkan untuk secara signifikan mengurangi jumlah alokasi ketika bekerja dengan stream (sangat sering metode <code>ReadAsync</code> selesai secara sinkron, seperti dalam contoh dengan <code>MemoryStream</code> ). </p><br><p>  Namun, ketika mengembangkan layanan dengan bandwidth tinggi, di mana penghentian asinkron tidak jarang terjadi, kita perlu melakukan yang terbaik untuk menghindari alokasi tambahan. </p><br><p>  Seperti disebutkan sebelumnya, dalam model <code>async/await</code> , operasi apa pun yang selesai secara tidak sinkron harus mengembalikan objek unik untuk menunggu penyelesaian.  Unik karena  itu akan berfungsi sebagai saluran untuk melakukan panggilan balik.  Perhatikan, bagaimanapun, bahwa konstruksi ini tidak mengatakan apa-apa tentang apakah objek menunggu yang dikembalikan dapat <em>digunakan kembali</em> setelah selesainya operasi asinkron.  Jika suatu objek dapat digunakan kembali, maka API dapat mempertahankan kumpulan untuk jenis objek ini.  Namun, dalam kasus ini, kumpulan ini tidak dapat mendukung akses bersamaan - objek dari kumpulan akan beralih dari status "selesai" ke status "tidak selesai" dan sebaliknya. </p><br><p>  Untuk mendukung kemungkinan bekerja dengan kumpulan seperti itu, <code>IValueTaskSource&lt;TResult&gt;</code> ditambahkan ke .NET Core 2.1, dan struktur <code>ValueTask&lt;TResult&gt;</code> diperluas: sekarang objek jenis ini tidak hanya dapat membungkus objek <code>TResult</code> atau <code>Task&lt;TResult&gt;</code> , tetapi juga contoh dari <code>IValueTaskSource&lt;TResult&gt;</code> .  Antarmuka baru menyediakan fungsionalitas dasar yang memungkinkan objek <code>ValueTask&lt;TResult&gt;</code> bekerja dengan <code>IValueTaskSource&lt;TResult&gt;</code> dengan cara yang sama seperti dengan <code>Task&lt;TResult&gt;</code> : </p><br><pre> <code class="plaintext hljs">public interface IValueTaskSource&lt;out TResult&gt; { ValueTaskSourceStatus GetStatus(short token); void OnCompleted( Action&lt;object&gt; continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags); TResult GetResult(short token); }</code> </pre> <br><p>  <code>GetStatus</code> dimaksudkan untuk digunakan di properti <code>ValueTask&lt;TResult&gt;.IsCompleted/IsCompletedSuccessfully</code> - memungkinkan Anda untuk mengetahui apakah operasi selesai atau tidak (berhasil atau tidak).  <code>OnCompleted</code> digunakan dalam <code>ValueTask&lt;TResult&gt;</code> untuk memicu panggilan balik.  <code>GetResult</code> digunakan untuk mendapatkan hasilnya, atau untuk melemparkan pengecualian. </p><br><p>  Sebagian besar pengembang tidak mungkin pernah perlu berurusan dengan <code>IValueTaskSource&lt;TResult&gt;</code>  metode asinkron, ketika dikembalikan, sembunyikan di balik <code>ValueTask&lt;TResult&gt;</code> .  Antarmuka itu sendiri terutama ditujukan bagi mereka yang mengembangkan API berkinerja tinggi dan berupaya menghindari pekerjaan yang tidak perlu dengan sekelompok. </p><br><p>  Di .NET Core 2.1, ada beberapa contoh API semacam ini.  Yang paling terkenal dari ini adalah kelebihan baru dari <code>Socket.ReceiveAsync</code> <code>Socket.SendAsync</code> metode <code>Socket.SendAsync</code> dan <code>Socket.SendAsync</code> .  Sebagai contoh: </p><br><pre> <code class="plaintext hljs">public ValueTask&lt;int&gt; ReceiveAsync( Memory&lt;byte&gt; buffer, SocketFlags socketFlags, CancellationToken cancellationToken = default);</code> </pre> <br><p>  Objek tipe <code>ValueTask&lt;int&gt;</code> digunakan sebagai nilai balik. <br>  Jika metode keluar secara sinkron, maka ia mengembalikan <code>ValueTask&lt;int&gt;</code> dengan nilai yang sesuai: </p><br><pre> <code class="plaintext hljs">int result = ‚Ä¶; return new ValueTask&lt;int&gt;(result);</code> </pre> <br><p>  Jika operasi selesai secara tidak sinkron, maka objek yang di-cache digunakan yang mengimplementasikan <code>IValueTaskSource&lt;TResult&gt;</code> : </p><br><pre> <code class="plaintext hljs">IValueTaskSource&lt;int&gt; vts = ‚Ä¶; return new ValueTask&lt;int&gt;(vts);</code> </pre> <br><p>  Implementasi <code>Socket</code> mendukung satu objek cache untuk menerima, dan satu untuk mengirim data, selama masing-masing digunakan tanpa persaingan (tidak, misalnya, pengiriman data kompetitif).  Strategi ini mengurangi jumlah memori tambahan yang dialokasikan, bahkan dalam kasus eksekusi asinkron. <br>  Optimalisasi <code>Socket</code> dijelaskan dalam .NET Core 2.1 memiliki dampak positif pada kinerja <code>NetworkStream</code> .  Kelebihannya adalah metode <code>ReadAsync</code> dari kelas <code>Stream</code> : </p><br><pre> <code class="plaintext hljs">public virtual ValueTask&lt;int&gt; ReadAsync( Memory&lt;byte&gt; buffer, CancellationToken cancellationToken);</code> </pre> <br><p>  hanya mendelegasikan pekerjaan ke metode <code>Socket.ReceiveAsync</code> .  Meningkatkan efisiensi metode soket, dalam hal bekerja dengan memori, meningkatkan efisiensi metode <code>NetworkStream</code> . </p><br><h2 id="non-generic-valuetask">  ValueTask non-generik </h2><br><p>  Sebelumnya, saya mencatat beberapa kali bahwa tujuan asli <code>ValueTask&lt;T&gt;</code> , dalam .NET Core 2.0, adalah untuk mengoptimalkan kasus penyelesaian metode yang sinkron dengan hasil "tidak kosong".  Ini berarti bahwa tidak perlu <code>ValueTask</code> diketik: dalam kasus penyelesaian sinkron, metode menggunakan singleton melalui properti <code>Task.CompletedTask</code> , dan runtime untuk metode <code>async Task</code> juga diterima secara implisit. </p><br><p>  Tetapi, dengan munculnya kemampuan untuk menghindari alokasi yang tidak perlu dan dengan eksekusi asinkron, kebutuhan untuk <code>ValueTask</code> diketik lagi menjadi relevan.  Untuk alasan ini, di .NET Core 2.1, kami memperkenalkan <code>ValueTask</code> dan <code>IValueTaskSource</code> .  Mereka adalah analog dari tipe generik yang sesuai, dan digunakan dengan cara yang sama, tetapi untuk metode dengan pengembalian kosong ( <code>void</code> ). </p><br><h2 id="realizaciya-ivaluetasksource--ivaluetasksourcelttgt">  Terapkan IValueTaskSource / IValueTaskSource &lt;T&gt; </h2><br><p>  Sebagian besar pengembang tidak perlu mengimplementasikan antarmuka ini.  Dan implementasi mereka bukanlah tugas yang mudah.  Jika Anda memutuskan bahwa Anda perlu mengimplementasikannya sendiri, maka, di dalam .NET Core 2.1, ada beberapa implementasi yang dapat berfungsi sebagai contoh: </p><br><ul><li>  <a href="">AocketableSocketAsyncEventArgs</a> </li><li>  <a href="">AsyncOperation &lt;TResult&gt;</a> </li><li>  <a href="">DefaultPipeReader</a> </li></ul><br><p>  Untuk menyederhanakan tugas-tugas ini (implementasi <code>IValueTaskSource / IValueTaskSource&lt;T&gt;</code> ), kami berencana untuk memperkenalkan tipe <code>ManualResetValueTaskSourceCore&lt;TResult&gt;</code> di .NET Core 3.0.  Struktur ini akan merangkum semua logika yang diperlukan.  Contoh <code>ManualResetValueTaskSourceCore&lt;TResult&gt;</code> dapat digunakan di objek lain yang mengimplementasikan <code>IValueTaskSource&lt;TResult&gt;</code> dan / atau <code>IValueTaskSource</code> , dan mendelegasikan sebagian besar pekerjaan untuk itu.  Anda dapat mempelajari lebih lanjut tentang ini di ttps: //github.com/dotnet/corefx/issues/32664. </p><br><h2 id="pravilnaya-model-ispolzovaniya-valuetasks">  Model yang benar untuk menggunakan ValueTasks </h2><br><p>  Bahkan pemeriksaan sepintas <code>ValueTask</code> bahwa <code>ValueTask</code> dan <code>ValueTask&lt;TResult&gt;</code> lebih terbatas daripada <code>Task</code> dan <code>Task&lt;TResult&gt;</code> .  Dan ini normal, bahkan diinginkan, karena tujuan utama mereka adalah menunggu selesainya eksekusi asinkron. </p><br><p>  Secara khusus, keterbatasan signifikan muncul karena fakta bahwa <code>ValueTask</code> dan <code>ValueTask&lt;TResult&gt;</code> dapat menggabungkan objek yang dapat digunakan kembali.  Secara umum, operasi berikut * <em>TIDAK PERNAH harus dilakukan ketika menggunakan</em> <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> * <em>(</em> biarkan saya merumuskan kembali melalui "Never" *): </p><br><ul><li>  <strong>Jangan pernah menggunakan objek <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> berulang kali</strong> </li></ul><br><p>  <em>Motivasi:</em> <code>Task</code> dan contoh <code>Task&lt;TResult&gt;</code> tidak pernah berubah dari keadaan "selesai" ke keadaan "tidak lengkap", kita dapat menggunakannya untuk menunggu hasil sebanyak yang kita inginkan - setelah selesai kita akan selalu mendapatkan hasil yang sama.  Sebaliknya, karena <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> , mereka dapat bertindak sebagai pembungkus objek yang digunakan kembali, yang berarti bahwa keadaan mereka dapat berubah, karena  keadaan objek yang digunakan kembali berubah menurut definisi - untuk beralih dari "selesai" ke "tidak lengkap" dan sebaliknya. </p><br><ul><li>  <strong>Jangan Pernah <code>ValueTask</code> / <code>ValueTask&amp;lt;TResult&amp;gt;</code></strong>  <strong>dalam mode kompetitif.</strong> </li></ul><br><p>  <em>Motivasi:</em> Objek yang dibungkus mengharapkan untuk bekerja hanya dengan satu panggilan balik, dari satu konsumen pada satu waktu, dan upaya untuk bersaing secara kompetitif dapat dengan mudah menyebabkan kondisi balapan dan kesalahan pemrograman yang halus.  Harapan kompetitif, ini adalah salah satu opsi yang dijelaskan di atas <strong>beberapa harapan</strong> .  Perhatikan bahwa <code>Task</code> / <code>Task&lt;TResult&gt;</code> memungkinkan sejumlah harapan kompetitif. </p><br><ul><li>  <strong>Jangan pernah gunakan <code>.GetAwaiter().GetResult()</code> sampai operasi selesai</strong> . </li></ul><br><p>  <em>Motivasi:</em> Implementasi <code>IValueTaskSource</code> / <code>IValueTaskSource&lt;TResult&gt;</code> tidak boleh mendukung penguncian sampai operasi selesai.  Memblokir, pada kenyataannya, mengarah pada kondisi balapan, tidak mungkin bahwa ini akan menjadi perilaku yang diharapkan dari pihak konsumen.  Sementara <code>Task</code> / <code>Task&lt;TResult&gt;</code> memungkinkan Anda untuk melakukan ini, dengan demikian memblokir utas panggilan sampai operasi selesai. </p><br><p>  Tetapi bagaimana jika, bagaimanapun, Anda perlu melakukan salah satu operasi yang dijelaskan di atas, dan metode yang dipanggil mengembalikan instance dari <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> ?  Untuk kasus seperti itu, <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> menyediakan metode <code>.AsTask()</code> .  Dengan memanggil metode ini, Anda akan mendapatkan instance dari <code>Task</code> / <code>Task&lt;TResult&gt;</code> , dan Anda sudah dapat melakukan operasi yang diperlukan dengannya.  Menggunakan kembali objek asli setelah memanggil <code>.AsTask()</code> <em>tidak diperbolehkan</em> . </p><br><p> <strong>  </strong> : <em>    <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>  ,   ( <code>await</code> )   (,    <code>.ConfigureAwait(false)</code> ),   <code>.AsTask()</code> ,        <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> .</em> </p><br><pre> <code class="plaintext hljs">// Given this ValueTask&lt;int&gt;-returning method‚Ä¶ public ValueTask&lt;int&gt; SomeValueTaskReturningMethodAsync(); ‚Ä¶ // GOOD int result = await SomeValueTaskReturningMethodAsync(); // GOOD int result = await SomeValueTaskReturningMethodAsync().ConfigureAwait(false); // GOOD Task&lt;int&gt; t = SomeValueTaskReturningMethodAsync().AsTask(); // WARNING ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); ... // storing the instance into a local makes it much more likely it'll be misused, // but it could still be ok // BAD: awaits multiple times ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = await vt; int result2 = await vt; // BAD: awaits concurrently (and, by definition then, multiple times) ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); Task.Run(async () =&gt; await vt); Task.Run(async () =&gt; await vt); // BAD: uses GetAwaiter().GetResult() when it's not known to be done ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = vt.GetAwaiter().GetResult();</code> </pre> <br><p>    , "",  ,       (    ,      ). </p><br><p>   <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>  ,       .  ,  <code>IsCompleted</code>  <code>true</code> ,    (   ,  ),    ‚Äî <code>false</code> ,  <code>IsCompletedSuccessfully</code>  <code>true</code>     .   " " ,   , ,    ,    ,    .            <code>await</code> / <code>.AsTask()</code>     <code>.Result</code> .  ,   <code>SocketsHttpHandler</code>  .NET Core 2.1,     <code>.ReadAsync</code> ,   <code>ValueTask&lt;int&gt;</code> .    ,       , ,  .      ,         ..   .  Karena    ,     , ,  ,    : </p><br><pre> <code class="plaintext hljs">int bytesRead; { ValueTask&lt;int&gt; readTask = _connection.ReadAsync(buffer); if (readTask.IsCompletedSuccessfully) { bytesRead = readTask.Result; } else { using (_connection.RegisterCancellation()) { bytesRead = await readTask; } } }</code> </pre> <br><p>    , .. <code>ValueTask&lt;int&gt;</code> ,     <code>.Result</code> ,    <code>await</code> ,     . </p><br><h2 id="dolzhny-li-vse-novye-asinhronnye-api-vozvraschat-valuetask--valuetasklttresultgt">      API  ValueTask / ValueTask&lt;TResult&gt;? </h2><br><p>  ,  .      <code>Task</code> / <code>ValueTask&lt;TResult&gt;</code> . </p><br><p>    ,   <code>Task</code> / <code>Task&lt;TResult&gt;</code>     .   ,       ""  / ,    <code>Task</code> / <code>Task&lt;TResult&gt;</code> . ,  ,      <code>ValueTask&lt;TResult&gt;</code>  <code>Task&lt;TResult&gt;</code> : ,   ,  <code>await</code>     <code>Task&lt;TResult&gt;</code>   <code>ValueTask&lt;TResult&gt;</code> .  ,       (,  API  <code>Task</code>  <code>Task&lt;bool&gt;</code> ), ,    ,   <code>Task</code> ( <code>Task&lt;bool&gt;</code> ).  , <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>    .  ,    async-,              <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> ,       . </p><br><p>     , <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>   , : </p><br><ol><li>  ,    API    , </li><li>  API        ,  </li><li>   ,      ,         ,    . </li></ol><br><p>  ,     <code>abstract</code> / <code>virtual</code>  ,    ,           /  ? </p><br><h2 id="chto-dalshe">  Apa selanjutnya </h2><br><p>    .NET,     API,  <code>Task</code> / <code>Task&lt;TResult&gt;</code> . ,  ,     API c <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> ,     .         <code>IAsyncEnumerator&lt;T&gt;</code> ,      .NET Core 3.0.  <code>IEnumerator&lt;T&gt;</code>   <code>MoveNext</code> ,    .   ‚Äî <code>IAsyncEnumerator&lt;T&gt;</code>   <code>MoveNextAsync</code> .      ,        <code>Task&lt;bool&gt;</code> ,        ,    .  ,       ,       ,      (        ),   ,   ,         <code>await foreach</code> -,  ,      <code>MoveNextAsync</code> ,  <code>ValueTask&lt;bool&gt;</code> .         , ,   ,     " " ,         . ,  C#      ,           . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465259/">https://habr.com/ru/post/id465259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465247/index.html">Sudut Memahami @Input, @Output, dan EventEmitter</a></li>
<li><a href="../id465249/index.html">Kuliah oleh Richard Stallman di Politeknik Moskow. Agustus 2019</a></li>
<li><a href="../id465251/index.html">Musim panas hampir berakhir. Hampir tidak ada data yang bocor</a></li>
<li><a href="../id465255/index.html">Implementasi Pool Connection WCF untuk .Net Core Menggunakan HttpClientFactory</a></li>
<li><a href="../id465257/index.html">"Waspadalah, FAS!": Trik McDonald's, shawarma ilahi, Clooney palsu dan beberapa sihir jalanan</a></li>
<li><a href="../id465261/index.html">Kekuatan sihir makro, atau cara membuat hidup lebih mudah bagi programmer assembler AVR</a></li>
<li><a href="../id465263/index.html">Locks in PostgreSQL: 3. Mengunci objek lain</a></li>
<li><a href="../id465267/index.html">TypeScript Sihir Ekspresi</a></li>
<li><a href="../id465269/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 26. DNS dan DHCP</a></li>
<li><a href="../id465271/index.html">Peretas mencuri dan mencuci uang melalui pengiriman makanan dan layanan pemesanan hotel.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>