<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍⚕️ 🧑🏿‍🤝‍🧑🏽 🧗🏿 Berlatih dalam bekerja dengan ban khusus dari kompleks Redd ⏩ 💅🏻 🙆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel terakhir, kami memeriksa teori mengelola ribuan hal kecil di kompleks Redd, tetapi agar tidak menambah volume, kami menunda praktik di w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berlatih dalam bekerja dengan ban khusus dari kompleks Redd</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484706/"> Dalam <a href="https://habr.com/ru/post/483724/">artikel terakhir,</a> kami memeriksa teori mengelola ribuan hal kecil di kompleks Redd, tetapi agar tidak menambah volume, kami menunda praktik di waktu berikutnya.  Waktunya telah tiba untuk melakukan eksperimen praktis.  Mereka yang tidak menggunakan kompleks Redd juga akan dapat menemukan pengetahuan yang berguna dalam artikel ini, yaitu, metodologi untuk mengirim perintah Vendor ke drive USB dari Linux, karena, sebagaimana telah disebutkan, pengontrol STM32 di kompleks melakukan fungsi pembaca SD, yaitu, berkendara. <br><br><img src="https://habrastorage.org/webt/_e/hh/5n/_ehh5nw2j8tiw7myjovthvvc_va.png"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Artikel siklus sebelumnya</b> <div class="spoiler_text"><ol><li>  <a href="https://habr.com/ru/post/452656/">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd, dan debugging menggunakan tes memori sebagai contoh.</a> </li><li>  <a href="https://habr.com/ru/post/453682/">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd.</a>  <a href="https://habr.com/ru/post/453682/">Bagian 2. Kode program.</a> </li><li>  <a href="https://habr.com/ru/post/454938/">Pengembangan intinya sendiri untuk ditanamkan dalam sistem prosesor berbasis FPGA.</a> </li><li>  <a href="https://habr.com/ru/post/456008/">Pengembangan program untuk prosesor pusat Redd pada contoh akses ke FPGA.</a> </li><li>  <a href="https://habr.com/ru/post/462253/">Eksperimen pertama menggunakan protokol streaming pada contoh koneksi CPU dan prosesor di FPGA kompleks Redd.</a> </li><li>  <a href="https://habr.com/ru/post/464795/">Merry Quartusel, atau bagaimana prosesor telah hidup seperti itu.</a> </li><li>  <a href="https://habr.com/ru/post/467353/">Metode Optimasi Kode untuk Redd.</a>  <a href="https://habr.com/ru/post/467353/">Bagian 1: efek cache.</a> </li><li>  <a href="https://habr.com/ru/post/468027/">Metode Optimasi Kode untuk Redd.</a>  <a href="https://habr.com/ru/post/468027/">Bagian 2: memori non-cache dan operasi bus paralel.</a> </li><li>  <a href="https://habr.com/ru/post/469985/">Optimalisasi kode ekstensif: mengganti generator jam untuk meningkatkan kinerja sistem.</a> </li><li>  <a href="https://habr.com/ru/post/477662/">Akses ke Redd Bus Diimplementasikan pada Pengendali FTDI</a> </li><li>  <a href="https://habr.com/ru/post/483724/">Bekerja dengan kompleks ban custom Redd</a> </li></ol><br></div></div><br><h2>  Drive klasifikasi dengan sistem perintah </h2><br>  Saat bekerja dengan drive, Anda harus membedakan antara antarmuka fisik dan sistem perintah.  Khususnya, drive CD / DVD / BD dan optik lainnya.  Secara tradisional, mereka terhubung ke kabel SATA (sebelumnya IDE).  Tetapi secara khusus pada kawat ini, hanya perintah PACKET yang dijalankan selama operasi, di blok data yang perintahnya disandikan sesuai dengan prinsip yang sama sekali berbeda ditempatkan (kita akan segera mengetahui yang mana).  Oleh karena itu, sekarang kita tidak akan berbicara banyak tentang kabel, tetapi tentang tim yang menjalankannya.  Saya tahu tiga sistem perintah umum untuk bekerja dengan drive. <br><br><ul><li>  MMC  Ini dipahami oleh kartu SD.  Jujur saja, bagi saya ini adalah sistem komando yang paling misterius.  Cara mengirimkannya, tampaknya, jelas, tetapi cara mengelola drive tanpa hati-hati membaca dokumen yang mengandung banyak grafik transisi - Saya selalu bingung.  Untungnya, ini tidak mengganggu kita hari ini, karena meskipun kita bekerja dengan kartu SD, pengendali STM32 dalam mode "kotak hitam" bekerja dengannya. </li><li>  ATA  Awalnya, perintah-perintah ini dijalankan pada bus IDE, kemudian pada SATA.  Sistem komando yang luar biasa, tetapi hari ini kami juga hanya menyebutkan bahwa itu ada. </li><li>  SCSI  Sistem perintah ini digunakan pada berbagai perangkat.  Pertimbangkan penggunaannya dalam drive.  Di sana, hari ini tim SCSI menjalankan, pertama-tama, di sepanjang kabel bus SAS (omong-omong, bahkan SSD dengan antarmuka SAS kini sedang populer).  Anehnya, drive optis yang terhubung secara fisik ke bus SATA juga berfungsi melalui perintah SCSI.  Di bus USB saat bekerja sesuai dengan standar Mass Storage Device, perintah juga masuk dalam format SCSI.  Mikrokontroler STM32 terhubung ke kompleks Redd melalui bus USB, yaitu, dalam kasus kami, perintah mengikuti jalur berikut: <br><br><img src="https://habrastorage.org/webt/hy/iy/f4/hyiyf4m9sjgr8etz8ily8joxsrc.png"><br></li></ul><br>  Dari PC ke controller, melalui USB, perintahnya dalam format SCSI.  Pengontrol mentranskode perintah sesuai dengan aturan MMC dan mengirimkannya melalui bus SDIO.  Tetapi kita harus menulis sebuah program untuk PC, sehingga tim meninggalkan kita dalam format SCSI.  Mereka disiapkan oleh driver perangkat Mass Storage Device, yang kami berkomunikasi dengan melalui driver sistem file.  Apakah mungkin untuk menggabungkan permintaan dengan perangkat lain untuk permintaan ini?  Mari kita perbaiki. <br><br><h2>  Detail Sistem Perintah SCSI </h2><br>  Jika Anda mendekati masalah ini secara formal, maka deskripsi standar SCSI tersedia di t10.org, tetapi kami akan realistis.  Tidak ada yang akan membacanya dengan sukarela.  Lebih tepatnya, bukan miliknya, tetapi milik mereka: ada setumpuk dokumen terbuka dan segunung dokumen tertutup. Hanya kebutuhan ekstrem yang akan membuat Anda membenamkan diri dalam bahasa rumit yang menjadi standar penulisan ini (ini, omong-omong, berlaku untuk standar ATA di t13.org).  Jauh lebih mudah untuk membaca dokumentasi untuk drive nyata.  Itu ditulis dalam bahasa yang lebih hidup, dan bagian hipotetis tetapi tidak benar-benar digunakan dipotong dari itu.  Dalam mempersiapkan artikel, saya menemukan dokumen (2016) yang agak baru dari Seagate's <b>Commands Reference Manual Manual</b> (tautan langsung <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">www.seagate.com/files/staticfiles/support/docs/manual/Interface%20manuals/100293068j.pdf</a> tetapi, seperti biasa, Saya tidak tahu berapa lama dia akan hidup).  Saya pikir jika seseorang ingin menguasai sistem perintah ini, ia harus mulai dengan dokumen ini.  Kami hanya ingat bahwa pembaca SD menerapkan subset perintah yang bahkan lebih kecil dari deskripsi itu. <br><br>  Secara singkat, unit perintah dengan panjang 6 hingga 16 byte dikirim ke drive.  Blok data dapat dilampirkan ke blok perintah baik dari PC ke drive, atau dari drive ke PC (standar SCSI juga memungkinkan pertukaran dua arah, tetapi untuk Mass Storage Device via USB hanya satu blok yang diizinkan, yang berarti bahwa arahnya hanya satu).  Dalam blok instruksi, byte pertama selalu merupakan kode perintah.  Byte yang tersisa adalah argumennya.  Aturan untuk mengisi argumen dijelaskan secara eksklusif oleh rincian implementasi perintah. <br><br><img src="https://habrastorage.org/webt/xt/1l/eb/xt1lebwoznye5dag98pwbtiuxfm.png"><br><br>  Pada awalnya saya memasukkan banyak contoh ke dalam artikel, tetapi kemudian saya menyadari bahwa mereka membuat sulit membaca.  Oleh karena itu, saya menyarankan semua orang untuk membandingkan bidang perintah READ CAPACITY (10) dari tabel 119 dari dokumen Seigate dan bidang-bidang perintah READ (10) dari tabel 97 dari dokumen yang sama (lihat tautan di atas).  Siapa yang tidak menemukan koneksi - jangan khawatir.  Itulah yang ingin saya tunjukkan.  Selain bidang "perintah" dalam byte nol, tujuan semua bidang hanya bergantung pada spesifikasi perintah tertentu.  Anda selalu perlu membuka dokumen dan mempelajari tujuan dari bidang yang tersisa di dalamnya. <br><br>  Jadi: <br><br><ul><li>  Untuk berkomunikasi dengan drive, Anda harus membentuk blok perintah dengan panjang 6 hingga 16 byte (tergantung pada format perintah, angka yang tepat ditunjukkan dalam dokumentasi untuk itu). </li><li>  Yang paling penting adalah byte nol dari blok: dialah yang menetapkan kode perintah. </li><li>  Bytes blok yang tersisa tidak memiliki tujuan yang jelas.  Untuk memahami cara mengisinya, Anda harus membuka dokumentasi untuk tim tertentu. </li><li>  Blok data yang dapat ditransfer ke atau dari drive dapat dilampirkan ke perintah. </li></ul><br>  Sebenarnya itu saja.  Kami mempelajari aturan untuk mengeluarkan perintah SCSI.  Sekarang kita bisa mengirimkannya, akan ada dokumentasi tentang mereka.  Tetapi bagaimana melakukannya di tingkat sistem operasi? <br><br><h2>  Perintah Linux SCSI </h2><br><h3>  Cari perangkat target </h3><br>  Untuk mengeluarkan perintah, buka perangkat disk.  Ayo cari namanya.  Untuk melakukan ini, kita akan pergi dengan cara yang persis sama seperti pada <a href="https://habr.com/ru/post/477662/">artikel tentang port serial</a> .  Mari kita lihat daftar "file" di <b>direktori / dev</b> (ingat bahwa pada perangkat Linux juga ditampilkan sebagai file dan daftar mereka ditampilkan dengan <b>perintah ls yang</b> sama). <br><br>  Hari ini kami memperhatikan <b>disk</b> direktori virtual: <br><br><img src="https://habrastorage.org/webt/t_/py/kj/t_pykjsq2_2gdno-u0oc9wdpltm.png"><br><br>  Kami melihat isinya: <br><br><img src="https://habrastorage.org/webt/cp/yp/n_/cpypn_cslhfibis7ixhbez64q4y.png"><br><br>  Kumpulan direktori bersarang yang familier!  Kami mencoba untuk mempertimbangkan direktori <b>by-id</b> , menggunakan <b>–l</b> switch dari <b>perintah ls</b> , yang sudah akrab bagi kami dari artikel di port serial: <br><br><img src="https://habrastorage.org/webt/jq/8s/zn/jq8sznkl6pimg5oxevbdp8m7l4w.png"><br><br>  Kata-kata yang disorot berbicara sendiri.  Ini adalah drive yang berisi kartu SD internal kompleks Redd.  Hebat!  Sekarang kita tahu bahwa perangkat <b>MIR_Redd_Internal_SD</b> sesuai dengan perangkat <b>/ dev / sdb dan / dev / sdb1</b> .  Yang tanpa nomor adalah drive itu sendiri, kami akan bekerja dengannya, dan dengan nomor itu adalah sistem file yang terletak pada media yang dimasukkan ke dalamnya.  Dalam hal bekerja dengan kartu SD, <b>/ dev / sdb</b> adalah pembaca, dan <b>/ dev / sdb1</b> adalah sistem file pada kartu yang dimasukkan ke dalamnya. <br><br><h3>  Fungsi sistem operasi untuk mengeluarkan perintah </h3><br>  Biasanya, dalam OS apa pun, semua hal non-standar dengan perangkat dilakukan melalui permintaan langsung ke pengemudi.  Di Linux, fungsi <b>ioctl ()</b> tersedia untuk mengirim permintaan tersebut.  Kasus kami tidak terkecuali.  Sebagai argumen, kami meneruskan permintaan SG_IO yang dijelaskan dalam file header <b>sg.h.</b>  Struktur <b>sg_io_hdr_t</b> yang berisi parameter permintaan juga dijelaskan di sana.  Saya tidak akan memberikan struktur penuh, karena tidak semua bidangnya harus diisi.  Saya hanya akan memberikan yang paling penting di antara mereka: <br><br><pre><code class="plaintext hljs">typedef struct sg_io_hdr { int interface_id; /* [i] 'S' for SCSI generic (required) */ int dxfer_direction; /* [i] data transfer direction */ unsigned char cmd_len; /* [i] SCSI command length ( &lt;= 16 bytes) */ unsigned char mx_sb_len; /* [i] max length to write to sbp */ unsigned short int iovec_count; /* [i] 0 implies no scatter gather */ unsigned int dxfer_len; /* [i] byte count of data transfer */ void * dxferp; /* [i], [*io] points to data transfer memory or scatter gather list */ unsigned char * cmdp; /* [i], [*i] points to command to perform */ unsigned char * sbp; /* [i], [*o] points to sense_buffer memory */ unsigned int timeout; /* [i] MAX_UINT-&gt;no timeout (unit: millisec) */</code> </pre> <br>  Tidak masuk akal untuk menggambarkan bidang-bidang yang didokumentasikan dengan baik dalam komentar ( <b>interface_id, dxfer_direction, timeout</b> ).  Artikel sudah berkembang. <br><br>  Bidang <b>cmd_len</b> berisi jumlah byte di blok perintah, dan <b>cmdp berisi</b> pointer ke blok ini.  Anda tidak dapat melakukannya tanpa perintah, sehingga jumlah byte harus nol (dari 6 hingga 16). <br><br>  Data bersifat opsional.  Jika ya, maka panjang buffer yang dipilih ditentukan dalam bidang <b>dxfer_len</b> , dan penunjuknya ditentukan dalam bidang <b>dxferp</b> .  Drive secara fisik dapat mentransfer lebih sedikit data daripada ukuran buffer yang ditentukan.  Arah transmisi ditentukan dalam bidang <b>dxfer_direction</b> .  Nilai Perangkat Mass Storage USB yang valid adalah: <b>SG_DXFER_NONE, SG_DXFER_TO_DEV, SG_DXFER_FROM_DEV</b> .  Ada satu hal lagi dalam file header, tetapi standar Mass Storage Device tidak memungkinkan untuk mengimplementasikannya secara fisik. <br><br>  Anda juga dapat meminta pengembalian kode kesalahan yang diperluas ( <b>SENSE</b> ).  Apa itu dapat ditemukan di dokumen Segate, bagian 2.4.  Panjang buffer yang dialokasikan ditunjukkan di bidang <b>mx_sb_len</b> , dan pointer ke buffer itu sendiri ditunjukkan di bidang <b>sbp</b> . <br><br>  Seperti yang Anda lihat, semua yang saya bicarakan di atas terisi dalam struktur ini (ditambah Anda dapat memperoleh informasi tambahan tentang kesalahan).  Baca lebih lanjut tentang bekerja dengan permintaan <b>SG_IO di</b> sini: <a href="http://sg.danny.cz/sg/sg_io.html">sg.danny.cz/sg/sg_io.html</a> <br><br><h3>  Kami mengirim perintah standar ke drive </h3><br>  Kami menemukan format perintah, kami mencari tahu perangkat mana yang akan dikirim, kami menemukan fungsi untuk menelepon.  Mari kita coba mengirim beberapa perintah standar ke perangkat kita.  Biarkan ini menjadi perintah untuk mendapatkan nama drive.  Ini adalah bagaimana itu dijelaskan dalam dokumen Sigeyt: <br><br><img src="https://habrastorage.org/webt/nj/qk/ca/njqkcamj1tnhjznoczjnrdfni60.png"><br><br>  Harap dicatat bahwa menurut ideologi-SCSI, semua bidang dalam perintah standar diisi dengan notasi Big Endian, yaitu byte maju ke depan.  Oleh karena itu, kami mengisi bidang dengan panjang buffer tidak dalam format "0x80, 0x00", tetapi sebaliknya - "0x00, 0x80".  Tapi ini dalam perintah standar.  Dalam non-standar semuanya mungkin, Anda harus selalu berkonsultasi dengan deskripsi.  Sebenarnya, hanya kode perintah ( <b>12 jam</b> ) dan panjang yang harus kita isi.  Kami akan meminta halaman nol, dan bidang lainnya dicadangkan, atau kedaluwarsa, atau default ke nol.  Jadi isi semuanya dengan nol. <br><br><div class="spoiler">  <b class="spoiler_title">Kami membuat program yang memberikan perintah ini:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; // open #include &lt;unistd.h&gt; // close #include &lt;sys/ioctl.h&gt; #include &lt;scsi/scsi.h&gt; #include &lt;scsi/sg.h&gt; int main() { printf("hello from SdAccessTest!\n"); int s_fd = open("/dev/sdb", O_NONBLOCK | O_RDWR); if (s_fd &lt; 0) { printf("Cannot open file\n"); return -1; } sg_io_hdr_t header; memset(&amp;header;, 0, sizeof(header)); uint8_t cmd12h[] = { 0x12,0x00,0x00,0x00,0x80,0x00}; uint8_t data[0x80]; uint8_t sense[0x80]; header.interface_id = 'S'; //  'S' //  header.cmd_len = sizeof(cmd12h); header.cmdp = cmd12h; //  header.dxfer_len = sizeof(data); header.dxferp = data; header.dxfer_direction = SG_DXFER_TO_FROM_DEV; //     header.mx_sb_len = sizeof(sense); header.sbp = sense; // header.timeout = 100; // 100  int res = ioctl(s_fd, SG_IO, &amp;header;); close(s_fd); return 0; }</code> </pre><br></div></div><br><br>  Bagaimana menjalankan program tersebut pada perangkat Redd jarak jauh, kita telah membahas di salah satu <a href="https://habr.com/ru/post/456008/">artikel sebelumnya</a> .  Benar, memulainya untuk pertama kalinya, saya segera menerima kesalahan memanggil fungsi <b>open ()</b> .  Ternyata pengguna secara default tidak memiliki hak yang cukup untuk membuka perangkat disk.  Yang mana dari saya adalah spesialis Linux, saya menulis berkali-kali, tetapi pada jaringan saya berhasil menemukan bahwa untuk mengatasi masalah ini, Anda dapat mengubah hak akses ke perangkat dengan mengeluarkan perintah: <br><br>  <b>sudo chmod 666 / dev / sdb</b> <br><br>  Namun, bos saya (dan dia adalah spesialis hebat dalam OS ini) kemudian mencatat bahwa solusinya valid sampai sistem operasi di-boot ulang.  Untuk mendapatkan hak pasti, Anda perlu menambahkan pengguna ke grup <b>disk</b> . <br><br>  Mana pun dari dua jalur ini yang kita tuju, tetapi setelah semuanya berhasil, letakkan breakpoint pada baris <b>tutup (s_fd);</b>  dan periksa hasilnya pada saat itu dicapai dalam lingkungan pengembangan (karena program ini bahkan bukan satu hari, yang berarti bahwa kita tidak punya waktu untuk menghabiskan waktu dan upaya memasukkan pembuat peta, jika lingkungan pengembangan dapat menunjukkan kepada kita segalanya).  Nilai <b>res</b> adalah nol.  Jadi tim bekerja tanpa kesalahan. <br><br><img src="https://habrastorage.org/webt/ih/2o/40/ih2o40ujbpv2p0qk9m_qiwdw9do.png"><br><br>  Apa yang datang ke buffer?  Ketika saya memasukkan kata <b>data</b> di alamat untuk dump, mereka mengatakan kepada saya bahwa mereka tidak dapat menghitung nilainya, saya harus memasukkan <b>&amp; data;</b>  .  Aneh, karena <b>data</b> adalah pointer, ketika debugging di Windows semuanya berfungsi, tapi saya perhatikan fakta ini, kerjanya seperti ini: lihat hasil yang didapat seperti ini: <br><br><img src="https://habrastorage.org/webt/bj/tk/ae/bjtkaehd8ucyzdufbdsn1392tgm.png"><br><br>  Itu benar, mereka mengembalikan nama dan revisi drive kepada kami.  Informasi lebih lanjut tentang format struktur yang dihasilkan dapat ditemukan dalam dokumen Segate (bagian 3.6.2, tabel 59).  Buffer <b>indra</b> tidak mengisi, tetapi deskripsi IOCTL dari permintaan mengatakan bahwa itu diisi hanya ketika kesalahan terjadi yang mengembalikan sesuatu di buffer ini.  Secara harfiah: <b>Sense data (hanya digunakan ketika 'status' adalah PERIKSA KONDISI atau (driver_status &amp; DRIVER_SENSE) adalah benar)</b> . <br><br><h2>  Format Perintah Kustom untuk Redd Internal SD Drive </h2><br>  Sekarang kita tidak hanya mempelajari deskripsi kering dari standar, tetapi juga mencoba segala sesuatu dalam praktik, setelah mengalami apa itu command block, kita sudah dapat menunjukkan format perintah yang dengannya Anda dapat memanggil fungsi-fungsi non-standar yang "di-flash" ke pengontrol STM32 pada papan kompleks.  Saya memilih kode perintah dari awal rentang <b>spesifik Vendor</b> dari perintah.  Itu sama dengan 0xC0.  Secara tradisional, dalam deskripsi perintah SCSI, tulis <b>C0h</b> .  Panjang perintah selalu 10 byte.  Format tim disatukan dan disajikan dalam tabel di bawah ini. <br><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Byte</b> </td><td>  <b>Janji temu</b> </td></tr><tr><td>  0 </td><td>  Kode Perintah C0h </td></tr><tr><td>  1 </td><td>  Kode Sub-Perintah </td></tr><tr><td>  2 </td><td rowspan="4">  Argumen arg1.  Diatur dalam notasi Little Endian (forward byte rendah) </td></tr><tr><td>  3 </td></tr><tr><td>  4 </td></tr><tr><td>  5 </td></tr><tr><td>  6 </td><td rowspan="4">  Argumen arg2.  Diatur dalam notasi Little Endian (forward byte rendah) </td></tr><tr><td>  7 </td></tr><tr><td>  8 </td></tr><tr><td>  9 </td></tr></tbody></table></div><br>  Seperti yang Anda lihat, argumen diberikan dalam notasi Little Endian.  Ini akan memungkinkan Anda untuk menggambarkan perintah dalam bentuk struktur dan mengakses bidangnya secara langsung, tanpa menggunakan fungsi permutasi byte.  Masalah perataan (kata-kata dobel dalam struktur memiliki offset yang bukan kelipatan empat) pada arsitektur x86 dan x64 tidak sepadan. <br><br>  Kode sub-perintah dijelaskan oleh enumerasi berikut: <br><pre> <code class="plaintext hljs">enum vendorSubCommands { subCmdSdEnable = 0, // 00 Switch SD card to PC or Outside subCmdSdPower, // 01 Switch Power of SD card On/Off subCmdSdReinit, // 02 Reinitialize SD card (for example, after Power Cycle) subCmdSpiFlashEnable, // 03 Switch SPI Flash to PC or Outside subCmdSpiFlashWritePage, // 04 Write Page to SPI Flash subCmdSpiFlashReadPage, // 05 Read Page from SPI Flash subCmdSpiFlashErasePage,// 06 Erase Pages on SPI Flash (4K block) subCmdRelaysOn, // 07 Switch relays On by mask subCmdRelaysOff, // 08 Switch relays off by mask subCmdRelaysSet, // 09 Set state of all relays by data subCmdFT4222_1_Reset, // 0A Activate Reset State or switch chip to normal mode subCmdFT4222_2_Reset, // 0B Activate Reset State or switch chip to normal mode subCmdFT4222_3_Reset, // 0C Activate Reset State or switch chip to normal mode subCmdFT4232_Reset, // 0D Activate Reset State or switch chip to normal mode subCmdFT2232_Reset, // 0E Activate Reset State or switch chip to normal mode subCmdMAX3421_Reset, // 0F Activate Reset State or switch chip to normal mode subCmdFT4222_1_Cfg, // 10 Write to CFG pins of FT4222_1 subCmdFT4222_2_Cfg, // 11 Write to CFG pins of FT4222_2 subCmdFT4222_3_Cfg, // 12 Write to CFG pins of FT4222_3 };</code> </pre><br>  Mereka dapat dibagi menjadi beberapa kelompok. <br><br><h3>  Berpindah perangkat ke mode internal dan eksternal </h3><br>  Perintah <b>subCmdSdEnable</b> dan <b>subCmdSpiFlashEnable</b> masing-masing mengganti kartu SD dan flash SPI.  Parameter <b>arg1</b> melewati salah satu nilai berikut: <br><br><pre> <code class="plaintext hljs">enum enableMode { enableModeToPC = 0, enableModeOutside };</code> </pre> <br>  Secara default, kedua perangkat terhubung ke PC. <br><br><h3>  Peralihan daya </h3><br>  Protokol SDIO membutuhkan cukup banyak manipulasi selama inisialisasi.  Kadang-kadang berguna untuk mengatur ulang kartu SD ke keadaan awal (misalnya, ketika mengganti jalurnya ke konektor eksternal).  Untuk melakukan ini, matikan, lalu nyalakan daya.  Ini dapat dilakukan dengan menggunakan <b>perintah subCmdSdPower</b> .  Dalam argumen <b>arg1,</b> salah satu dari nilai berikut ini diteruskan: 0 - matikan, 1 - matikan.  Ingatlah untuk memberikan waktu untuk melepaskan kapasitor pada saluran listrik. <br><br>  Setelah menyalakan daya, kartu, jika terhubung ke PC, harus diinisialisasi ulang.  Untuk melakukan ini, gunakan perintah <b>subCmdSdReinit</b> (tidak memiliki argumen). <br><br><h3>  Bekerja dengan SPI flash drive </h3><br>  Jika kartu SD terhubung ke sistem sebagai drive penuh, chip akses dalam versi saat ini sangat terbatas.  Anda hanya dapat mengakses halaman individualnya (256 byte) dan hanya satu per satu.  Jumlah memori dalam rangkaian mikro sedemikian rupa sehingga bahkan ketika bekerja di halaman, prosesnya tidak akan memakan banyak waktu, tetapi pendekatan ini sangat menyederhanakan "firmware" dari mikrokontroler. <br><br>  Perintah <b>subCmdSpiFlashReadPage</b> membaca halaman.  Alamatnya ditentukan dalam parameter arg1, jumlah halaman yang akan dikirim dalam parameter arg2.  Tetapi dalam versi saat ini, jumlah halaman harus sama dengan satu.  Perintah akan mengembalikan 256 byte data. <br><br>  <b>Dicerminkan</b> baginya adalah perintah <b>subCmdSpiFlashWritePage</b> .  Argumen untuknya diisi oleh prinsip yang sama.  Arah transfer data adalah ke perangkat. <br><br>  Kekhasan memori flash adalah bahwa hanya bit tunggal yang dapat diganti dengan nol bit selama perekaman.  Untuk mengembalikannya ke nilai tunggal, halaman harus dihapus.  Ada perintah <b>subCmdSpiFlashErasePage</b> untuk <b>ini</b> .  Benar, karena fitur dari sirkuit mikro yang digunakan, itu bukan halaman tunggal yang diatur dalam parameter <b>arg1</b> yang dihapus, tetapi blok 4 kilobyte yang mengandungnya. <br><br><h3>  Manajemen Relay Solid State </h3><br>  Kompleks ini memiliki enam relai keadaan padat.  Ada tiga tim untuk mengelolanya. <br><br>  <b>subCmdRelaysSet</b> - menetapkan nilai keenam relay secara bersamaan.  Dalam parameter <b>arg1,</b> nilai dilewatkan, setiap bit yang sesuai dengan relay sendiri (nol bit - relay dengan indeks 0, bit pertama dengan indeks 1, dll).  Nilai bit tunggal menutup relai, nilai nol menyebabkannya terbuka. <br><br>  Metode operasi ini bagus ketika semua relay bekerja sebagai satu kelompok.  Jika mereka bekerja secara independen satu sama lain, dengan pendekatan ini Anda harus memulai variabel penyangga yang menyimpan nilai keadaan semua relay.  Jika relay yang berbeda dikendalikan oleh program yang berbeda, masalah penyimpanan nilai agregat menjadi sangat akut.  Dalam hal ini, Anda dapat menggunakan dua perintah lain: <br><br>  <b>subCmdRelaysOn</b> - memungkinkan relay terpilih dengan mask.  Relai yang sesuai dengan bit unit dalam argumen <b>arg1</b> akan diaktifkan.  Relay yang sesuai dengan nol di topeng akan mempertahankan statusnya saat ini. <br><br>  Perintah <b>subCmdRelaysOff yang mencerminkan</b> perintah <b>itu</b> akan mematikan relai yang dipilih oleh mask.  Relai yang sesuai dengan bit tunggal dalam argumen <b>arg1</b> akan dimatikan.  Relay yang sesuai dengan nol di topeng akan mempertahankan statusnya saat ini. <br><br><h3>  Setel ulang pengontrol FTDI dan Maxim </h3><br>  Untuk mengirim sinyal reset ke sirkuit mikro FTDI dan Maxim, kelompok perintah <b>subCmdFT4222_1_Reset</b> , <b>subCmdFT4222_2_Reset</b> , <b>subCmdFT4222_3_Reset</b> , <b>subCmdFT4232_Reset</b> , <b>subCmdFT2232_Reset</b> , <b>subCmdFT2232_Reset</b> , dan <b>subCmdMA_21 digunakan</b> .  Dari namanya, Anda dapat melihat chip mana yang mereka kontrol dengan mengatur ulang sinyal.  Jembatan FT4222, seperti yang kita bahas sebelumnya, adalah dua di sirkuit (indeksnya 1 dan 2), jembatan FT4222 lainnya mentransfer data ke chip MAX3421, yang akan kita bahas dalam artikel berikutnya. <br><br>  Parameter <b>arg1</b> melewati salah satu nilai berikut: <br><br><pre> <code class="plaintext hljs">enum ResetState { resetStateActive =0, resetStateNormalOperation };</code> </pre> <br>  Secara default, semua jembatan dalam kondisi kerja normal.  Seperti yang sudah disebutkan dalam <a href="https://habr.com/ru/post/483724/">artikel sebelumnya</a> , kami sendiri tidak yakin apakah fungsi ini diperlukan, tetapi ketika tidak ada akses langsung ke perangkat, lebih baik untuk mengatur ulang semuanya dari jarak jauh. <br><br><h3>  Berpindah jalur konfigurasi chip FT4222 </h3><br>  Chip FT4222 memiliki empat mode.  Tidak mungkin ada orang yang memerlukan mode selain "00", tetapi jika Anda tiba-tiba membutuhkannya, Anda dapat menggunakan <b>subCmdFT4222_1_Cfg</b> , <b>subCmdFT4222_2_Cfg,</b> dan <b>perintah subCmdFT4222_3_Cfg</b> untuk <b>beralih</b> untuk chip pertama, kedua, dan ketiga.  Nilai garis CFG0 dan CFG1 diatur dalam dua bit lebih rendah dari parameter <b>arg1</b> . <br><br><h2>  Pengalaman praktis dalam mengeluarkan perintah ke pengontrol STM32 </h2><br>  Untuk menguji materi teoretis yang diperoleh dalam praktik, kami akan mencoba untuk mematikan kartu SD.  Untuk melakukan ini, <b>keluarkan</b> perintah <b>subCmdSdEnable</b> dengan kode 0x00 dengan argumen <b>enableModeOutside</b> dengan kode 0x01.  Bagus  Kami menulis ulang program dari pengalaman masa lalu sebagai berikut. <br><br><div class="spoiler">  <b class="spoiler_title">Program ditulis ulang:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; // open #include &lt;unistd.h&gt; // close #include &lt;sys/ioctl.h&gt; #include &lt;scsi/scsi.h&gt; #include &lt;scsi/sg.h&gt; int main() { printf("hello from SdAccessTest!\n"); int s_fd = open("/dev/sdb", O_NONBLOCK | O_RDWR); if (s_fd &lt; 0) { printf("Cannot open file\n"); return -1; } sg_io_hdr_t header; memset(&amp;header;, 0, sizeof(header)); uint8_t cmdSdToOutside[] = { 0xC0,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }; uint8_t cmdSdToPC[] = { 0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }; uint8_t sense[32]; memset(sense, 0, sizeof(sense)); header.interface_id = 'S'; //  'S' //  header.cmd_len = sizeof(cmdSdToOutside); header.cmdp = cmdSdToOutside; //  ( ) header.dxfer_len = 0; header.dxferp = 0; header.dxfer_direction = SG_DXFER_NONE; //     header.mx_sb_len = sizeof(sense); header.sbp = sense; // header.timeout = 100; // 100  int res = ioctl(s_fd, SG_IO, &amp;header;); //   header.cmdp = cmdSdToPC; res = ioctl(s_fd, SG_IO, &amp;header;); close(s_fd); return 0; }</code> </pre><br></div></div><br>  Kami mengubah panjang perintah menjadi sepuluh byte dan menghapus blok data.  Yah, mereka menuliskan kode perintah dengan argumen, sesuai kebutuhan.  Kalau tidak, semuanya tetap sama.  Kita mulai ... Dan ... Tidak ada yang berhasil.  Fungsi <b>ioctl ()</b> mengembalikan kesalahan.  Alasannya dijelaskan dalam <b>dokumen</b> perintah <b>SG_IO</b> .  Faktanya adalah bahwa kita memberikan perintah Vendor Specific <b>C0h</b> , dan berikut ini dikatakan tentang mereka secara harfiah: <br><blockquote>  Perintah SCSI (opcode) lainnya yang tidak disebutkan untuk driver sg membutuhkan O_RDWR.  Perintah SCSI (opcode) lainnya yang tidak disebutkan untuk lapisan blok SG_IO ioctl membutuhkan pengguna dengan kemampuan CAP_SYS_RAWIO. </blockquote><br>  Seperti yang dijelaskan bos kepada saya (saya hanya menceritakan kembali kata-katanya), nilai <b>kapabilitas</b> ditugaskan ke file yang dapat dieksekusi.  Untuk alasan ini, saya harus melacak dari lingkungan pengembangan dengan masuk sebagai <b>root</b> .  Bukan solusi terbaik, tetapi setidaknya sesuatu.  Bahkan, pada Windows, permintaan <b>IOCTL_SCSI_PASS_THROUGH_DIRECT</b> juga memerlukan hak administrator.  Mungkin di komentar seseorang akan memberikan saran tentang cara mengatasi masalah penelusuran tanpa langkah drastis seperti itu, tetapi Anda dapat menjalankan program yang sudah ditulis tanpa <b>root</b> , jika Anda mendaftarkan <b>kemampuan yang</b> benar <b>untuk itu</b> .  Sementara itu, ubah nama pengguna di lingkungan pengembangan dan atur breakpoint di telepon: <br><br><pre> <code class="plaintext hljs">int res = ioctl(s_fd, SG_IO, &amp;header;);</code> </pre> <br>  dan sebelum memanggil fungsi <b>ioctl ()</b> , kita melihat daftar perangkat penyimpanan: <br><br><img src="https://habrastorage.org/webt/ys/ef/ls/yseflsambpnn83pbywoqfuazoqi.png"><br><br>  Panggil <b>ioctl ()</b> dan lihat daftar lagi: <br><br><img src="https://habrastorage.org/webt/ro/2g/33/ro2g331krziu9uslxuzo28hylxa.png"><br><br>  Perangkat <b>/ dev / sdb</b> tetap (secara kasar, ini adalah pembaca kartu SD itu sendiri), dan <b>/ dev / sdb1</b> menghilang.  Perangkat ini sesuai dengan sistem file di media.  Pembawa terputus dari komputer - tidak lagi terlihat.  Kami terus melacak.  Setelah memanggil fungsi <b>ioctl ()</b> kedua, kami kembali melihat daftar perangkat: <br><br><img src="https://habrastorage.org/webt/rd/wi/zx/rdwizxqu4amrqeuhzghnrptvkly.png"><br><br>  Kartu SD dihubungkan kembali ke sistem, sehingga <b>/ dev / sdb1</b> kembali ke tempatnya.  Sebenarnya, kami belajar cara mengeluarkan perintah khusus vendor dan mengelola perangkat berbasis mikrokontroler STM32 di kompleks Redd.  Perintah lain akan diserahkan kepada pembaca untuk belajar mandiri.  Anda dapat mengontrol operasi beberapa dari mereka dengan cara yang sama.  Jika beberapa chip <b>ftdi masuk</b> ke kondisi reset, perangkat yang sesuai akan menghilang dari sistem.  Pengoperasian relai dan kontrol kaki konfigurasi harus dikontrol dengan alat ukur.  Nah, Anda dapat memeriksa pekerjaan dengan flash drive dengan menulis halaman dengan kontrol bacaan berikutnya. <br><br><h2>  Kesimpulan </h2><br>  Kami memeriksa dua topik besar yang tidak terkait dengan FPGA di kompleks Redd.  Yang ketiga tetap - bekerja dengan chip MAX3421, yang memungkinkan implementasi perangkat USB 2.0 FS.  Sebenarnya, ada host juga, tetapi ada banyak host dan motherboard.  Fungsionalitas perangkat akan memungkinkan kompleks untuk berpura-pura menjadi USB flash drive (untuk mengirim pembaruan "firmware"), keyboard USB (untuk mengontrol unit eksternal), dll.  Kami akan mempertimbangkan topik ini di artikel selanjutnya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484706/">https://habr.com/ru/post/id484706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484688/index.html">Kami mendekati batas daya komputasi - kami membutuhkan programmer baru</a></li>
<li><a href="../id484690/index.html">Seminar, konferensi, mitap: mempelajari statistik 18.000 acara</a></li>
<li><a href="../id484692/index.html">Vitamin C - Apakah saya perlu mengonsumsi suplemen atau apakah ini merupakan langkah komersial?</a></li>
<li><a href="../id484700/index.html">Java 14: catatan pratinjau</a></li>
<li><a href="../id484702/index.html">Alternatif Prestashop pada tahun 2020: Platform eCommerce Teratas</a></li>
<li><a href="../id484708/index.html">Richard Hamming "Bab tidak ada": Bagaimana kita tahu apa yang kita ketahui (versi lengkap)</a></li>
<li><a href="../id484710/index.html">Melanggar Aturan Pengumpulan Sampah Persatuan</a></li>
<li><a href="../id484712/index.html">Kompatibilitas biner reaktive: bagaimana kami menyediakannya</a></li>
<li><a href="../id484716/index.html">Berhenti memanggil semuanya AI</a></li>
<li><a href="../id484718/index.html">Printer modern HP menolak untuk bekerja tanpa berlangganan tinta</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>