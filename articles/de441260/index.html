<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ú°Ô∏è ü§¶ üê≥ Wie neuronale Netzwerkgrafiken geholfen haben üë∞ üë©üèª‚Äç‚öïÔ∏è üêÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1943 entwickelten die amerikanischen Neuropsychologen McCallock und Pitts ein Computermodell eines neuronalen Netzwerks, und 1958 erkannte das erste f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie neuronale Netzwerkgrafiken geholfen haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/441260/">  1943 entwickelten die amerikanischen Neuropsychologen McCallock und Pitts ein Computermodell eines neuronalen Netzwerks, und 1958 erkannte das <strong>erste funktionierende</strong> einschichtige Netzwerk einige Buchstaben.  Jetzt werden neuronale Netze einfach nicht mehr f√ºr das verwendet, um den Wechselkurs vorherzusagen, Krankheiten zu diagnostizieren, Autopiloten zu erstellen und Grafiken in Computerspielen zu erstellen.  Fast das letzte und reden. <br><br>  <strong>Evgeni Tumanov</strong> arbeitet als Deep Learning-Ingenieur bei <strong>NVIDIA</strong> .  Basierend auf den Ergebnissen seiner Rede auf der HighLoad ++ - Konferenz haben wir eine Geschichte √ºber die Verwendung von maschinellem Lernen und Deep Learning in Grafiken vorbereitet.  Maschinelles Lernen endet nicht mit NLP, Computer Vision, Empfehlungssystemen und Suchaufgaben.  Auch wenn Sie mit diesem Bereich nicht sehr vertraut sind, k√∂nnen Sie die Best Practices aus dem Artikel in Ihrem Bereich oder Ihrer Branche anwenden. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/eeCYmJQAyKA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Die Geschichte wird aus drei Teilen bestehen.  Wir werden die Aufgaben in der Grafik √ºberpr√ºfen, die mit Hilfe des maschinellen Lernens gel√∂st werden, die Hauptidee erhalten und den Fall der Anwendung dieser Idee in einer bestimmten Aufgabe und speziell beim <b>Rendern von Wolken beschreiben</b> . <a name="habracut"></a><br><br><h2>  Betreutes DL / ML in Grafik oder Lehrerausbildung in Grafik </h2><br>  Lassen Sie uns zwei Gruppen von Aufgaben analysieren.  Zun√§chst bezeichnen wir sie kurz. <br><br>  <strong>Real-World oder Render-Engine</strong> : <br><br><ul><li>  Erstellung glaubw√ºrdiger Animationen: Fortbewegung, Gesichtsanimation. </li><li>  Nachbearbeitung gerenderter Bilder: Supersampling, Anti-Aliasing. </li><li>  Slowmotion: Frame-Interpolation. </li><li>  Erzeugung von Materialien. </li></ul><br>  Die zweite Gruppe von Aufgaben wird jetzt √ºblicherweise als " <strong>schwerer Algorithmus</strong> " bezeichnet.  Wir umfassen Aufgaben wie das Rendern komplexer Objekte wie Wolken und <strong>physikalische Simulationen</strong> : Wasser, Rauch. <br><br>  Unser Ziel ist es, den grundlegenden Unterschied zwischen den beiden Gruppen zu verstehen.  Lassen Sie uns die Aufgaben genauer betrachten. <br><br><h3>  Erstellung glaubw√ºrdiger Animationen: Fortbewegung, Gesichtsanimation <br></h3><br>  In den letzten Jahren sind viele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel erschienen</a> , in denen Forscher neue M√∂glichkeiten anbieten, um sch√∂ne Animationen zu generieren.  Die Arbeit von K√ºnstlern zu verwenden ist teuer, und sie durch einen Algorithmus zu ersetzen, w√§re f√ºr alle sehr vorteilhaft.  Vor einem Jahr arbeiteten wir bei NVIDIA an einem Projekt, bei dem wir uns mit der Gesichtsanimation von Charakteren in Spielen besch√§ftigten: das Synchronisieren des Gesichts des Helden mit der Audiospur der Sprache.  Wir haben versucht, das Gesicht so wiederzubeleben, dass sich jeder Punkt darauf und vor allem die Lippen bewegte, da dies der schwierigste Moment in der Animation ist.  Manuell ein K√ºnstler, um dies teuer und f√ºr eine lange Zeit zu tun.  Welche M√∂glichkeiten gibt es, um dieses Problem zu l√∂sen und einen <strong>Datensatz</strong> daf√ºr zu <strong>erstellen</strong> ? <br><br>  Die erste M√∂glichkeit besteht darin <strong>, Vokale</strong> zu <strong>identifizieren: Der Mund √∂ffnet sich auf den Vokalen, der Mund schlie√üt sich auf den Konsonanten</strong> .  Dies ist ein einfacher Algorithmus, aber zu einfach.  In Spielen wollen wir mehr Qualit√§t.  Die zweite M√∂glichkeit besteht darin <strong>, die Leute dazu zu bringen, verschiedene Texte zu lesen und ihre Gesichter aufzuschreiben und dann die Buchstaben, die sie aussprechen, mit den Gesichtsausdr√ºcken zu vergleichen.</strong>  Dies ist eine gute Idee, und wir haben dies in einem gemeinsamen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt</a> mit Remedy Entertainment getan.  Der einzige Unterschied ist, dass wir im Spiel kein Video zeigen, sondern ein 3D-Modell von Punkten.  Um einen Datensatz zusammenzustellen, m√ºssen Sie verstehen, wie sich bestimmte Punkte auf dem Gesicht bewegen.  Wir nahmen Schauspieler mit, baten darum, Texte mit unterschiedlichen Intonationen zu lesen, drehten mit sehr guten Kameras aus verschiedenen Winkeln, stellten dann das 3D-Modell der Gesichter auf jedem Bild wieder her und sagten die Position der Punkte auf dem Gesicht durch Ton voraus. <br><br><h3>  Bildnachbearbeitung rendern: Supersampling, Anti-Aliasing <br></h3><br>  Stellen Sie sich einen Fall aus einem bestimmten Spiel vor: Wir haben eine Engine, die Bilder in verschiedenen Aufl√∂sungen generiert.  Wir m√∂chten das Bild in einer Aufl√∂sung von 1000 √ó 500 Pixel rendern und dem Player 2000 √ó 1000 zeigen - dies wird sch√∂ner.  Wie erstelle ich einen Datensatz f√ºr diese Aufgabe? <br><br>  Rendern Sie das Bild zuerst in hoher Aufl√∂sung, verringern Sie dann die Qualit√§t und versuchen Sie dann, das System so zu trainieren, dass das Bild von niedriger Aufl√∂sung in hohe Aufl√∂sung konvertiert wird. <br><br><h3>  Slowmotion: Frame-Interpolation <br></h3><br>  Wir haben ein Video und m√∂chten, dass das Netzwerk Frames in der Mitte hinzuf√ºgt - um Frames zu interpolieren.  Die Idee liegt auf der Hand - ein echtes Video mit einer gro√üen Anzahl von Bildern aufzunehmen, Zwischenbilder zu entfernen und vorherzusagen, was vom Netzwerk entfernt wurde. <br><br><h3>  Materialerzeugung <br></h3><br>  Wir werden uns nicht viel mit der Erzeugung von Materialien befassen.  Das Wesentliche ist, dass wir zum Beispiel ein St√ºck Holz in verschiedenen Beleuchtungswinkeln nehmen und die Ansicht aus anderen Winkeln interpolieren. <br><br>  Wir haben die erste Gruppe von Problemen untersucht.  Der zweite ist grundlegend anders.  Wir werden sp√§ter √ºber das Rendern komplexer Objekte wie Wolken sprechen, aber jetzt werden wir uns mit physikalischen Simulationen befassen. <br><br><h3>  Physikalische Simulationen von Wasser und Rauch <br></h3><br>  Stellen Sie sich einen Pool vor, in dem sich bewegte feste Objekte befinden.  Wir wollen die Bewegung von Fl√ºssigkeitsteilchen vorhersagen.  Zum Zeitpunkt <strong>t</strong> befinden sich Partikel im Pool, und zum Zeitpunkt <strong>t + Œît</strong> m√∂chten wir ihre Position ermitteln.  F√ºr jedes Teilchen rufen wir ein neuronales Netzwerk auf und erhalten eine Antwort, wo es sich im n√§chsten Frame befindet. <br><br>  Um das Problem zu l√∂sen, verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wir die</a> <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Navier-Stokes-Gleichung</a></strong> , die die Bewegung einer Fl√ºssigkeit beschreibt.  F√ºr eine plausible, physikalisch korrekte Simulation von Wasser m√ºssen wir die Gleichung oder Ann√§herung daran l√∂sen.  Dies kann auf rechnerische Weise erfolgen, von denen viele in den letzten 50 Jahren erfunden wurden: der SPH-, FLIP- oder positionsbasierte Fluid-Algorithmus. <br><br><h3>  Der Unterschied zwischen der ersten Aufgabengruppe und der zweiten <br></h3><br>  In der ersten Gruppe ist der Lehrer f√ºr den Algorithmus etwas oben: eine Aufzeichnung aus dem wirklichen Leben, wie im Fall von Einzelpersonen, oder etwas aus der Engine, zum Beispiel das Rendern von Bildern.  In der zweiten Gruppe von Problemen verwenden wir die Methode der Computermathematik.  Aus dieser thematischen Aufteilung entsteht eine Idee. <br><br><h2>  Hauptidee <br></h2><br>  Wir haben eine rechnerisch komplexe Aufgabe, die mit der klassischen Methode der Computeruniversit√§t lang, schwer und schwer zu l√∂sen ist.  Um es zu l√∂sen und zu beschleunigen, vielleicht sogar ein wenig an Qualit√§t zu verlieren, brauchen wir: <br><br><blockquote><ul><li>  Finden Sie den zeitaufw√§ndigsten Ort in der Aufgabe, an dem der Code am l√§ngsten dauert. </li><li>  sehen, was diese Linie produziert; </li><li>  Versuchen Sie, das Ergebnis einer Linie mithilfe eines neuronalen Netzwerks oder eines anderen Algorithmus f√ºr maschinelles Lernen vorherzusagen. </li></ul></blockquote><br>  Dies ist eine allgemeine Methodik und die Hauptidee ist ein Rezept, wie man eine Anwendung f√ºr maschinelles Lernen findet.  Was sollten Sie tun, um diese Idee n√ºtzlich zu machen?  Es gibt keine genaue Antwort - nutzen Sie Kreativit√§t, schauen Sie sich Ihre Arbeit an und finden Sie sie.  Ich mache Grafiken und bin mit anderen Bereichen nicht so vertraut, aber ich kann mir vorstellen, dass man im akademischen Umfeld - in Physik, Chemie, Robotik - definitiv Anwendung finden kann.  Wenn Sie eine komplexe physikalische Gleichung an Ihrem Arbeitsplatz l√∂sen, finden Sie m√∂glicherweise auch Anwendung f√ºr diese Idee.  Betrachten Sie der Klarheit halber einen bestimmten Fall. <br><br><h2>  Cloud-Rendering-Aufgabe <br></h2><br>  Wir waren vor sechs Monaten bei NVIDIA an diesem Projekt beteiligt: ‚Äã‚ÄãDie Aufgabe besteht darin, eine physikalisch korrekte Wolke zu zeichnen, die als Dichte der Fl√ºssigkeitstr√∂pfchen im Weltraum dargestellt wird. <br><br><blockquote>  Eine Wolke ist ein physikalisch komplexes Objekt, eine Suspension von Fl√ºssigkeitstr√∂pfchen, die nicht als festes Objekt modelliert werden kann. </blockquote><br>  Es wird nicht m√∂glich sein, der Wolke eine Textur aufzuerlegen und zu rendern, da Wassertropfen im 3D-Raum nur schwer geometrisch lokalisiert und an sich komplex sind: Sie absorbieren praktisch keine Farbe, sondern reflektieren sie anisotrop - in alle Richtungen auf unterschiedliche Weise. <br><br>  Wenn Sie einen Wassertropfen betrachten, auf den die Sonne scheint, und die Vektoren von Auge und Sonne auf einem Tropfen parallel sind, wird ein gro√üer Lichtintensit√§tspeak beobachtet.  Dies erkl√§rt das physikalische Ph√§nomen, das jeder gesehen hat: Bei sonnigem Wetter ist einer der Wolkenr√§nder sehr hell, fast wei√ü.  Wir betrachten den Rand der Wolke, und die Sichtlinie und der Vektor von diesem Rand zur Sonne sind fast parallel. <br><img src="https://habrastorage.org/webt/yt/hz/ij/ythzijgn-xfjhl3xri9mefn4vrg.png"><br><br>  Die Wolke ist ein physikalisch komplexes Objekt und ihre Wiedergabe nach dem klassischen Algorithmus erfordert viel Zeit.  Wir werden etwas sp√§ter √ºber den klassischen Algorithmus sprechen.  Abh√§ngig von den Parametern kann der Vorgang Stunden oder sogar Tage dauern.  Stellen Sie sich vor, Sie sind K√ºnstler und zeichnen einen Film mit Spezialeffekten.  Sie haben eine komplizierte Szene mit unterschiedlicher Beleuchtung, mit der Sie spielen m√∂chten.  Wir haben eine Wolkentopologie gezeichnet - sie gef√§llt mir nicht, und Sie m√∂chten sie neu zeichnen und genau dort eine Antwort erhalten.  Es ist wichtig, so schnell wie m√∂glich eine Antwort auf eine Parameter√§nderung zu erhalten.  Das ist ein Problem.  Versuchen wir daher, diesen Prozess zu beschleunigen. <br><br><h3>  Klassische L√∂sung <br></h3><br>  Um das Problem zu l√∂sen, m√ºssen Sie diese komplizierte Gleichung l√∂sen. <br><img src="https://habrastorage.org/webt/vs/fg/hq/vsfghqwn4s0rkmnsnescb1h62ma.png"><br><br>  Die Gleichung ist hart, aber lassen Sie uns ihre physikalische Bedeutung verstehen.  Stellen Sie sich einen Strahl vor, der von einer Wolke durchbohrt wird, die eine Wolke durchbohrt.  Wie gelangt Licht in diese Richtung in die Kamera?  Erstens kann das Licht den Austrittspunkt des Strahls aus der Wolke erreichen und sich dann entlang dieses Strahls innerhalb der Wolke ausbreiten. <br><br>  F√ºr die zweite Methode der "Lichtausbreitung entlang der Richtung" ist der integrale Term der Gleichung.  Seine physikalische Bedeutung ist wie folgt. <br><br>  Betrachten Sie das Segment innerhalb der Wolke auf dem Strahl - vom Eintrittspunkt zum Austrittspunkt.  Die Integration erfolgt genau √ºber dieses Segment, und f√ºr jeden Punkt darauf betrachten wir die sogenannte <strong>indirekte Lichtenergie L (x, œâ)</strong> - die Bedeutung des Integrals I <sub>1</sub> - indirekte Beleuchtung am Punkt.  Es erscheint aufgrund der Tatsache, dass Tropfen auf unterschiedliche Weise Sonnenlicht reflektieren.  Dementsprechend kommt eine gro√üe Menge von vermittelten Strahlen von umgebenden Tr√∂pfchen auf den Punkt.  I <sub>1</sub> ist das Integral √ºber der Kugel, das einen Punkt auf dem Strahl umgibt.  Im klassischen Algorithmus wird es nach der <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monte-Carlo-</a></strong> Methode gez√§hlt. <br><br>  Der klassische Algorithmus. <br><br><ul><li>  Rendern Sie ein Bild aus Pixeln und erzeugen Sie einen Strahl, der von der Mitte der Kamera zu einem Pixel und dann weiter geht. </li><li>  Wir √ºberqueren den Strahl mit der Wolke, wir finden die Eintritts- und Austrittspunkte. </li><li>  Wir betrachten den letzten Term der Gleichung: kreuzen, mit der Sonne verbinden. </li><li>  Erste Schritte <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wichtige Stichproben</a></strong> </li></ul><br>  Wie man die Monte-Carlo-Sch√§tzung I <sub>1 betrachtet, werden</sub> wir nicht analysieren, da sie schwierig und nicht so wichtig ist.  Es gen√ºgt zu sagen, dass dies der l√§ngste und schwierigste Teil des gesamten Algorithmus ist. <br><br><h3>  Wir verbinden neuronale Netze <br></h3><br>  Aus der Hauptidee und Beschreibung des klassischen Algorithmus folgt ein Rezept, wie neuronale Netze auf diese Aufgabe angewendet werden k√∂nnen.  Am schwierigsten ist es, den Monte-Carlo-Wert zu berechnen.  Es gibt eine Zahl, die indirekte Beleuchtung an einem Punkt bedeutet, und genau das wollen wir vorhersagen. <br><img src="https://habrastorage.org/webt/nz/on/st/nzonstvyqkk3uaiylmqjbs6fny0.png"><br><br>  Wir haben uns f√ºr den Ausgang entschieden, jetzt werden wir den Eingang verstehen - aus welchen Informationen wird ersichtlich, wie gro√ü das indirekte Licht am Punkt ist.  Dies ist Licht, das von den vielen Wassertropfen reflektiert wird, die den Punkt umgeben.  Die Lichttopologie wird stark von der Dichte-Topologie um den Punkt, der Richtung zur Quelle und der Richtung zur Kamera beeinflusst. <br><img src="https://habrastorage.org/webt/ks/x6/hc/ksx6hc2boi4sgdp3_j7det6firo.png"><br><br>  Um den Eingang zum neuronalen Netzwerk zu konstruieren, beschreiben wir die lokale Dichte.  Es gibt viele M√∂glichkeiten, dies zu tun, aber wir haben uns auf den Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deep Scattering: Rendern atmosph√§rischer Wolken mit Strahlungsvorhersage neuronaler Netze konzentriert, Kallwcit et al.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2017</a> und viele Ideen kamen von dort. <br><br>  Kurz gesagt sieht die Methode der lokalen Darstellung der Dichte um einen Punkt so aus. <br><br><ul><li>  <strong>Fixiere eine ziemlich kleine Konstante</strong> .  Sei es der mittlere freie Weg in der Wolke. <br></li><li>  <strong>Zeichnen Sie um einen Punkt in unserem Segment ein volumetrisches rechteckiges Gitter fester Gr√∂√üe</strong> , z. B. 5 * 5 * 9.  In der Mitte dieses W√ºrfels wird unser Punkt sein.  Der Gitterabstand ist eine kleine feste Konstante.  An den Gitterknoten messen wir die Dichte der Wolke. </li><li>  <strong>Erh√∂hen wir die Konstante um das Zweifache</strong> , zeichnen ein gr√∂√üeres Gitter und machen dasselbe - messen Sie die Dichte an den Knoten des Gitters. </li><li>  <strong>Wiederholen Sie den vorherigen Schritt mehrmals</strong> .  Wir haben dies 10 Mal gemacht und nach dem Verfahren haben wir 10 Gitter erhalten - 10 Tensoren, von denen jeder die Wolkendichte speichert, und jeder der Tensoren deckt eine immer gr√∂√üere Nachbarschaft um den Punkt ab. </li></ul><br>  Dieser Ansatz gibt uns die detaillierteste Beschreibung eines kleinen Gebiets - je n√§her am Punkt, desto detaillierter die Beschreibung.  √úber die Ausgabe und Eingabe des Netzwerks entschieden, bleibt abzuwarten, wie es trainiert wird. <br><br><h3>  Schulung <br></h3><br>  Wir werden 100 verschiedene Wolken mit unterschiedlichen Topologien erzeugen.  Wir werden sie einfach mit dem klassischen Algorithmus rendern, aufschreiben, was der Algorithmus in der Zeile empf√§ngt, in der er die Monte-Carlo-Integration durchf√ºhrt, und Eigenschaften aufschreiben, die dem Punkt entsprechen.  So erhalten wir einen Datensatz, √ºber den wir lernen k√∂nnen. <br><img src="https://habrastorage.org/webt/yc/im/rh/ycimrhfbcbhfhx_rjwsqoc-xt1q.png"><br><br><h3>  Was zu lehren oder Netzwerkarchitektur <br></h3><br>  Die Netzwerkarchitektur f√ºr diese Aufgabe ist nicht der wichtigste Moment, und wenn Sie nichts verstehen - keine Sorge - ist dies nicht das Wichtigste, was ich vermitteln wollte.  Wir haben die folgende Architektur verwendet: F√ºr jeden Punkt gibt es 10 Tensoren, von denen jeder auf einem immer gr√∂√üer werdenden Gitter berechnet wird.  Jeder dieser Tensoren f√§llt in den entsprechenden Block. <br><br><ul><li>  Zuerst in die erste regul√§re <strong>vollst√§ndig verbundene Schicht</strong> . </li><li>  Nach dem Verlassen der ersten vollst√§ndig verbundenen Schicht in der zweiten vollst√§ndig verbundenen Schicht, die keine Aktivierung hat. </li></ul><br>  Eine vollst√§ndig verbundene Schicht ohne Aktivierung ist nur eine Multiplikation mit einer Matrix.  Zum Ergebnis der Multiplikation mit der Matrix addieren wir die Ausgabe des vorherigen <strong>Restblocks</strong> und wenden erst dann die Aktivierung an. <br><img src="https://habrastorage.org/webt/he/fb/pn/hefbpncqogvya11gpsmzjwxtawi.png"><br><br>  Wir nehmen einen Punkt, z√§hlen die Werte auf jedem der Gitter, setzen die erhaltenen Tensoren in den entsprechenden Restblock - und Sie k√∂nnen <strong>R√ºckschl√ºsse auf das neuronale Netzwerk ziehen</strong> - Produktionsmodus des Netzwerks.  Wir haben das gemacht und daf√ºr gesorgt, dass wir Bilder von Wolken bekommen. <br><br><h3>  Ergebnisse <br></h3><br>  Die erste Beobachtung - wir haben bekommen, was wir wollten: Ein neuronaler Netzanruf funktioniert im Vergleich zur Monte-Carlo-Sch√§tzung schneller, was bereits gut ist. <br><br>  Es gibt jedoch noch eine andere Beobachtung zu den Ergebnissen des Trainings - es ist die Konvergenz der Anzahl der Proben.  Wor√ºber sprichst du? <br><img src="https://habrastorage.org/webt/mb/wd/eg/mbwdegnr_cpk6irbcsvrmyhe3n4.png"><br><br>  Wenn Sie ein Bild rendern, schneiden Sie es in kleine Kacheln - Pixelquadrate, z. B. 16 * 16.  Betrachten Sie eine Bildkachel ohne Verlust der Allgemeinheit.  Wenn wir diese Kachel rendern, setzen wir f√ºr jedes Pixel der Kamera viele Strahlen frei, die einem Pixel entsprechen, und f√ºgen den Strahlen ein wenig Rauschen hinzu, so dass sie sich geringf√ºgig unterscheiden.  Diese Strahlen werden als <strong>Anti-Aliasing bezeichnet</strong> und wurden erfunden, um das Rauschen im endg√ºltigen Bild zu reduzieren. <br><br><ul><li>  Wir setzen f√ºr jedes Pixel mehrere Anti-Aliasing-Strahlen frei. </li><li>  Im inneren Teil des Strahls von der Kamera, in der Wolke, in einem Segment berechnen wir <em>n</em> Stichproben von Punkten, an denen wir eine Monte-Carlo-Bewertung durchf√ºhren oder ein Netzwerk f√ºr sie aufrufen m√∂chten. </li></ul><br>  Es gibt noch Beispiele, die der Verbindung mit den Lichtquellen entsprechen.  Sie erscheinen, wenn wir einen Punkt mit einer Lichtquelle verbinden, zum Beispiel mit der Sonne.  Dies ist einfach zu tun, da die Sonne die Strahlen sind, die parallel zueinander auf die Erde fallen.  Zum Beispiel ist der Himmel als Lichtquelle viel komplizierter, weil er als unendlich entfernte Kugel erscheint, die in Richtung eine Farbfunktion hat.  Wenn der Vektor gerade vertikal in den Himmel schaut, ist die Farbe blau.  Je niedriger desto heller.  Am unteren Rand der Kugel befindet sich normalerweise eine neutrale Farbe, die die Erde imitiert: gr√ºn, braun. <br><br>  Wenn wir einen Punkt mit dem Himmel verbinden, um zu verstehen, wie viel Licht in ihn eindringt, setzen wir immer ein paar Strahlen frei, um eine Antwort zu erhalten, die zur Wahrheit konvergiert.  Wir geben mehr als einen Strahl frei, um eine bessere Note zu erhalten.  Daher ben√∂tigt das gesamte <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pipeline-Rendering</a></strong> so viele Beispiele. <br><br>  Als wir das neuronale Netzwerk trainierten, stellten wir fest, dass es eine viel durchschnittlichere L√∂sung lernt.  Wenn wir die Anzahl der Stichproben festlegen, sehen wir, dass der klassische Algorithmus in der linken Zeile der Bildspalte konvergiert und das Netzwerk nach rechts lernt.  Dies bedeutet nicht, dass die urspr√ºngliche Methode schlecht ist - wir konvergieren nur schneller.  Wenn wir die Anzahl der Proben erh√∂hen, wird die urspr√ºngliche Methode immer n√§her an dem sein, was wir erhalten. <br><br>  Unser Hauptergebnis, das wir erzielen wollten, ist eine Erh√∂hung der Rendergeschwindigkeit.  F√ºr eine bestimmte Wolke in einer bestimmten Aufl√∂sung mit Beispielparametern sehen wir, dass die vom Netzwerk und der klassischen Methode erhaltenen Bilder nahezu identisch sind, aber wir erhalten das richtige Bild 800-mal schneller. <br><img src="https://habrastorage.org/webt/qp/ly/xn/qplyxntotijyhtzhgeqzsygahmc.png"><br><br><h2>  Implementierung <br></h2><br>  Es gibt ein Open Source-Programm f√ºr die 3D-Modellierung - <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blender</a></strong> , das den klassischen Algorithmus implementiert.  Wir selbst haben keinen Algorithmus geschrieben, sondern dieses Programm verwendet: Wir haben in Blender trainiert und alles aufgeschrieben, was wir f√ºr den Algorithmus brauchten.  Die Produktion erfolgte ebenfalls im Programm: Wir haben das Netzwerk in <strong>TensorFlow</strong> geschult, es mit TensorRT auf C ++ √ºbertragen und das TensorRT-Netzwerk bereits in Blender integriert, da sein Code offen ist. <br><br>  Da wir alles f√ºr Blender getan haben, bietet unsere L√∂sung alle Funktionen des Programms: Wir k√∂nnen jede Art von Szene und viele Wolken rendern.  Die Wolken in unserer L√∂sung werden durch Erstellen eines W√ºrfels festgelegt, in dem wir die Dichtefunktion auf eine bestimmte Weise f√ºr 3D-Programme bestimmen.  Wir haben diesen Prozess optimiert - die Cache-Dichte.  Wenn der Benutzer dieselbe Wolke auf einem Haufen unterschiedlicher Szeneneinstellungen zeichnen m√∂chte: unter verschiedenen Lichtbedingungen mit unterschiedlichen Objekten auf der B√ºhne, muss er die Dichte der Wolke nicht st√§ndig neu berechnen.  Was passiert ist, k√∂nnen Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video sehen</a> . <br><br>  Abschlie√üend wiederhole ich noch einmal die Hauptidee, die ich vermitteln wollte: <em>Wenn Sie in Ihrer Arbeit lange und hart etwas als einen bestimmten Rechenalgorithmus betrachten und dies nicht zu Ihnen passt - finden Sie den schwierigsten Platz im Code, ersetzen Sie ihn durch ein neuronales Netzwerk und Vielleicht hilft dir das.</em> <br><br><blockquote>  Neuronale Netze und k√ºnstliche Intelligenz sind eines der neuen Themen, die wir im April auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Saint HighLoad ++ 2019</a> diskutieren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> .  Wir haben bereits mehrere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bewerbungen</a> zu diesem Thema erhalten. Wenn Sie eine coole Erfahrung haben, nicht unbedingt in neuronalen Netzen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reichen Sie</a> vor <strong>dem 1. M√§rz</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Bewerbung f√ºr einen Bericht ein</a> .  Wir freuen uns, Sie unter unseren Referenten zu sehen. <br><br>  Abonnieren Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Newsletter,</a> um auf dem Laufenden zu bleiben, wie das Programm aufgebaut ist und welche Berichte akzeptiert werden.  Darin ver√∂ffentlichen wir nur thematische Sammlungen von Berichten, Artikel√ºbersichten und neuen Videos. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441260/">https://habr.com/ru/post/de441260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441248/index.html">Russland belegte im globalen SSL-Rating den 9. Platz vor China, D√§nemark und der Schweiz</a></li>
<li><a href="../de441250/index.html">Schnellstart: Los + Apache Kafka + Redis</a></li>
<li><a href="../de441252/index.html">‚ÄûBlowjob-Artikel‚Äú: Wissenschaftler verarbeiteten 109 Stunden Oralsex, um eine KI zu entwickeln, die einen Schwanz lutscht</a></li>
<li><a href="../de441254/index.html">Seminar ‚ÄûWarum wir mit Kubernetes in Kontakt getreten sind und was wir davon haben‚Äú, 28. Februar, Moskau</a></li>
<li><a href="../de441258/index.html">Voll funktionsf√§higes dynamisches Tracing unter Linux mit eBPF und bpftrace</a></li>
<li><a href="../de441262/index.html">Einfache und lange Aufgaben beseitigen Kandidaten besser als kurze und komplexe</a></li>
<li><a href="../de441264/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 2</a></li>
<li><a href="../de441266/index.html">Wie das tiOPF-Framework f√ºr Delphi / Lazarus funktioniert. Besuchervorlage</a></li>
<li><a href="../de441268/index.html">Ceedling + Eclipse oder Unit-Tests f√ºr Mikrocontroller</a></li>
<li><a href="../de441270/index.html">Schauen Sie sich zuerst Apples FoundationDB an</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>