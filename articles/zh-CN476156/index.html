<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🤝‍👨🏼 🧖🏽 👨🏼‍🚒 使用Apache Kafka的同步请求-响应 👨🏿 🥚 📡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="总体而言， 事件驱动架构 ，尤其是Apache Kafka ，最近引起了很多关注。 为了充分利用事件驱动的体系结构，事件委托机制必须实质上是异步的。 但是，可能存在一些特定的使用场景/流程，这些场景/流程需要使用Synchronous Request-Response的语义。 此版本显示了如何使用A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用Apache Kafka的同步请求-响应</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476156/">总体而言， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件驱动架构</a> ，尤其是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apache Kafka</a> ，最近引起了很多关注。 为了充分利用事件驱动的体系结构，事件委托机制必须实质上是异步的。 但是，可能存在一些特定的使用场景/流程，这些场景/流程需要使用<b>Synchronous Request-Response</b>的语义。 此版本显示了如何使用<b>Apache Kafka</b>实现<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请求-响应</a></b> 。 <br><br> 由<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@middle_java</a></b>翻译 <br><a name="habracut"></a><br> 原始文章日期：2018年10月26日 <br><br>  Apache Kafka本质上是异步的。 因此，Apache Kafka <b>的请求-响应</b>语义是不自然的。 但是，这一挑战并不新鲜。 企业集成模式<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请求-应答</a></b>为异步通道上的同步消息传递提供了一种行之有效的机制： <br><br><img src="https://habrastorage.org/webt/ww/cy/0h/wwcy0hvrj6iie7amwxpk1twfbui.gif"><br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Return Address</a></b>模式用一种机制来补充<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Request-Reply</a></b>模式，该机制使请求者可以指示将响应发送到的地址： <br><br><img src="https://habrastorage.org/webt/rw/nd/qq/rwndqqxh42kt82xadcbvgjb76wa.gif"><br><br> 最近， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Spring Kafka</a> <b>2.1.3</b>增加了来自Request Request模式框的支持，在<b>2.2</b>版中，它的一些粗糙度被抛光。 让我们看看这种支持是如何工作的： <br><br><h2> 客户端：ReplyingKafkaTemplate </h2><br>  <b>模板</b>的众所周知的抽象构成了Spring中Request-Reply机制的客户端部分的基础。 <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReplyingKafkaTemplate &lt; String, Request, Reply &gt; replyKafkaTemplate( ProducerFactory &lt; String, Request &gt; pf, KafkaMessageListenerContainer &lt; String, Reply &gt; lc) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReplyingKafkaTemplate &lt; &gt; (pf, lc); }</code> </pre> <br> 这里的一切都非常简单：我们设置了<b>ReplyingKafkaTemplate</b> ，它使用String键发送请求消息，并使用String键接收响应消息。 但是，ReplyingKafkaTemplate必须基于具有适当使用者和生产者配置的ProducerFactory请求，ConsumerFactory响应和MessageListenerContainer。 因此，所需的配置非常重要： <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.topic.car.reply}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String replyTopic; <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Map &lt; String, Object &gt; consumerConfigs() { Map &lt; String, Object &gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap &lt; &gt; (); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class); props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Map &lt; String, Object &gt; producerConfigs() { Map &lt; String, Object &gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap &lt; &gt; (); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ProducerFactory &lt; String, Request &gt; requestProducerFactory() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaProducerFactory &lt; &gt; (producerConfigs()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ConsumerFactory &lt; String, Reply &gt; replyConsumerFactory() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaConsumerFactory &lt; &gt; (consumerConfigs(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringDeserializer(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonSerializer &lt; Reply &gt; ()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaMessageListenerContainer &lt; String, Reply &gt; replyListenerContainer() { ContainerProperties containerProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContainerProperties(replyTopic); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KafkaMessageListenerContainer &lt; &gt; (replyConsumerFactory(), containerProperties); }</code> </pre> <br> 在这种情况下，使用<b>replyKafkaTemplate</b>发送同步请求并接收响应如下： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.topic.car.request}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String requestTopic; <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.topic.car.reply}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String replyTopic; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ReplyingKafkaTemplate &lt; String, Request, Reply &gt; requestReplyKafkaTemplate; ... RequestReply request = RequestReply.request(...); <span class="hljs-comment"><span class="hljs-comment">// producer record ProducerRecord &lt; String, Request &gt; record = new ProducerRecord &lt; String, Request &gt; (requestTopic, request); //       record.headers().add(new RecordHeader(KafkaHeaders.REPLY_TOPIC, requestReplyTopic.getBytes())); //     Kafka          RequestReplyFuture &lt; String, Request, Reply &gt; sendAndReceive = requestReplyKafkaTemplate.sendAndReceive(record); sendAndReceive.addCallback(new ListenableFutureCallback &lt; ConsumerRecord &lt; String, Reply &gt;&gt; () { @Override public void onSuccess(ConsumerRecord &lt; String, Reply &gt; result) { //   consumer record Reply reply = result.value(); System.out.println("Reply: " + reply.toString()); } });</span></span></code> </pre> <br> 还有很多样板文件和一个低级API，甚至是这个过时的<b>ListenableFuture</b> API，而不是现代的<b>CompletableFuture</b> 。 <br><br>  <b>requestReplyKafkaTemplate</b>负责生成和设置<b>KafkaHeaders.CORRELATION_ID</b>标头，但是我们必须为请求显式设置<b>KafkaHeaders.REPLY_TOPIC</b>标头。 另请注意，在<b>replyListenerContainer中</b> ，答案的同一主题太无意了。 糟透了 不完全符合我对Spring抽象的期望。 <br><br><h2> 服务器端：@SendTo </h2><br> 在服务器端，通常在<b>KafkaListener上</b>侦听请求主题的地方还附加了<b>@SendTo</b>批注，以提供响应消息。 由侦听器方法返回的对象将自动包装在响应消息中，添加<b>CORRELATION_ID，</b>并将响应发布在<b>REPLY_TOPIC</b>标头中指定的主题中。 <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Map &lt; String, Object &gt; consumerConfigs() { Map &lt; String, Object &gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap &lt; &gt; (); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonSerializer.class); props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Map &lt; String, Object &gt; producerConfigs() { Map &lt; String, Object &gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap &lt; &gt; (); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ConsumerFactory &lt; String, Request &gt; requestConsumerFactory() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaConsumerFactory &lt; &gt; (consumerConfigs(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringDeserializer(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonSerializer &lt; Request &gt; ()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory &lt; ConcurrentMessageListenerContainer &lt; String, Request &gt;&gt; requestListenerContainerFactory() { ConcurrentKafkaListenerContainerFactory &lt; String, Request &gt; factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory &lt; &gt; (); factory.setConsumerFactory(requestConsumerFactory()); factory.setReplyTemplate(replyTemplate()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ProducerFactory &lt; String, Reply &gt; replyProducerFactory() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaProducerFactory &lt; &gt; (producerConfigs()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaTemplate &lt; String, Reply &gt; replyTemplate() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KafkaTemplate &lt; &gt; (replyProducerFactory()); }</code> </pre> <br> 这里也需要一些配置，但是侦听器配置更简单： <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@KafkaListener</span></span>(topics = <span class="hljs-string"><span class="hljs-string">"${kafka.topic.car.request}"</span></span>, containerFactory = <span class="hljs-string"><span class="hljs-string">"requestListenerContainerFactory"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@SendTo</span></span>() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Reply </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request request)</span></span></span><span class="hljs-function"> </span></span>{ Reply reply = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reply; }</code> </pre> <br><h2> 但是消费者的多个实例呢？ </h2><br> 直到我们使用了多个消费者实例，一切似乎都可以正常工作。 如果我们有多个客户端实例，则需要确保将响应发送到正确的客户端实例。  Spring Kafka文档假定每个使用者都可以使用唯一的主题，或者随请求一起发送附加的<b>KafkaHeaders</b>标头值<b>RESPONSE_PARTITION</b>是一个四字节字段，其中包含整数部分编号的BIG-ENDIAN表示形式。 为不同的客户使用单独的主题显然不是很灵活，因此我们选择显式的<b>REPLY_PARTITION</b>设置。 然后，客户端应知道将其分配给哪个分区。 该文档建议使用显式配置来选择特定分区。 让我们将其添加到我们的示例中： <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.topic.car.reply.partition}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> replyPartition; ... <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaMessageListenerContainer &lt; String, RequestReply &gt; replyListenerContainer() { ContainerProperties containerProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContainerProperties(replyTopic); TopicPartitionInitialOffset initialOffset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TopicPartitionInitialOffset(replyTopic, replyPartition); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KafkaMessageListenerContainer &lt; &gt; (replyConsumerFactory(), containerProperties, initialOffset); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] intToBytesBigEndian(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] { (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), }; } ... record.headers().add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RecordHeader(KafkaHeaders.REPLY_TOPIC, requestReplyTopic.getBytes())); record.headers().add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RecordHeader(KafkaHeaders.REPLY_PARTITION, intToBytesBigEndian(replyPartition))); RequestReplyFuture &lt; String, RequestReply, RequestReply &gt; sendAndReceive = requestReplyKafkaTemplate.sendAndReceive(record); ...</code> </pre> <br> 不是很漂亮，但是可以。 所需的配置广泛，API看起来很底层。 显式配置分区的需求使动态扩展客户端数量的过程变得复杂。 显然，您可以做得更好。 <br><br><h2> 封装主题处理以进行响应和分区 </h2><br> 让我们从封装“ <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">返回地址”</a></b>模式开始，然后传递响应和分区的主题。 响应的主题必须注入<b>RequestReplyTemplate中</b> ，因此，根本不应该出现在API中。 当涉及到答案的分区时，我们将执行相反的操作：提取分配给该主题侦听器的答案的分区，然后自动转移该分区。 这消除了客户端处理这些标头的需要。 <br> 同时，让我们使API看起来像标准的<b>KafkaTemplate</b> （ <b>使用</b>简化的参数重载<b>sendAndReceive（）</b>方法<b>，</b>并使用默认主题添加相应的重载方法）： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PartitionAwareReplyingKafkaTemplate</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReplyingKafkaTemplate</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> &gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PartitionAwareReplyingKafkaTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProducerFactory &lt; K, V &gt; producerFactory, GenericMessageListenerContainer &lt; K, R &gt; replyContainer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(producerFactory, replyContainer); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TopicPartition </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirstAssignedReplyTopicPartition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getAssignedReplyTopicPartitions() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; getAssignedReplyTopicPartitions().iterator().hasNext()) { TopicPartition replyPartition = getAssignedReplyTopicPartitions().iterator().next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.logger.isDebugEnabled()) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.logger.debug(<span class="hljs-string"><span class="hljs-string">"Using partition "</span></span> + replyPartition.partition()); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> replyPartition; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KafkaException(<span class="hljs-string"><span class="hljs-string">"Illegal state: No reply partition is assigned to this instance"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] intToBytesBigEndian(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] { (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), }; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RequestReplyFuture &lt; K, V, R &gt; sendAndReceiveDefault(<span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> V data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sendAndReceive(getDefaultTopic(), data); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RequestReplyFuture &lt; K, V, R &gt; sendAndReceiveDefault(K key, <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> V data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sendAndReceive(getDefaultTopic(), key, data); } ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RequestReplyFuture &lt; K, V, R &gt; sendAndReceive(String topic, <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> V data) { ProducerRecord &lt; K, V &gt; record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProducerRecord &lt; &gt; (topic, data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSendAndReceive(record); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RequestReplyFuture &lt; K, V, R &gt; sendAndReceive(String topic, K key, <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> V data) { ProducerRecord &lt; K, V &gt; record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProducerRecord &lt; &gt; (topic, key, data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSendAndReceive(record); } ... <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RequestReplyFuture &lt; K, V, R &gt; sendAndReceive(ProducerRecord &lt; K, V &gt; record) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSendAndReceive(record); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> RequestReplyFuture &lt; K, V, R &gt; doSendAndReceive(ProducerRecord &lt; K, V &gt; record) { TopicPartition replyPartition = getFirstAssignedReplyTopicPartition(); record.headers() .add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RecordHeader(KafkaHeaders.REPLY_TOPIC, replyPartition.topic().getBytes())) .add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RecordHeader(KafkaHeaders.REPLY_PARTITION, intToBytesBigEndian(replyPartition.partition()))); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.sendAndReceive(record); } }</code> </pre> <br> 下一步：使<b>ListenableFuture</b>适应更现代的<b>CompletableFuture</b> 。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletableFutureReplyingKafkaTemplate</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PartitionAwareReplyingKafkaTemplate</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> &gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompletableFutureReplyingKafkaTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProducerFactory &lt; K, V &gt; producerFactory, GenericMessageListenerContainer &lt; K, R &gt; replyContainer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(producerFactory, replyContainer); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CompletableFuture &lt; R &gt; requestReplyDefault(V value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> adapt(sendAndReceiveDefault(value)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CompletableFuture &lt; R &gt; requestReplyDefault(K key, V value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> adapt(sendAndReceiveDefault(key, value)); } ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CompletableFuture &lt; R &gt; requestReply(String topic, V value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> adapt(sendAndReceive(topic, value)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CompletableFuture &lt; R &gt; requestReply(String topic, K key, V value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> adapt(sendAndReceive(topic, key, value)); } ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CompletableFuture &lt; R &gt; adapt(RequestReplyFuture &lt; K, V, R &gt; requestReplyFuture) { CompletableFuture &lt; R &gt; completableResult = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompletableFuture &lt; R &gt; () { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mayInterruptIfRunning)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = requestReplyFuture.cancel(mayInterruptIfRunning); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.cancel(mayInterruptIfRunning); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }; <span class="hljs-comment"><span class="hljs-comment">//       requestReplyFuture.getSendFuture().addCallback(new ListenableFutureCallback &lt; SendResult &lt; K, V &gt;&gt; () { @Override public void onSuccess(SendResult &lt; K, V &gt; sendResult) { // NOOP } @Override public void onFailure(Throwable t) { completableResult.completeExceptionally(t); } }); //     requestReplyFuture.addCallback(new ListenableFutureCallback &lt; ConsumerRecord &lt; K, R &gt;&gt; () { @Override public void onSuccess(ConsumerRecord &lt; K, R &gt; result) { completableResult.complete(result.value()); } @Override public void onFailure(Throwable t) { completableResult.completeExceptionally(t); } }); return completableResult; } }</span></span></code> </pre> <br> 我们将其打包到一个实用程序库中，现在我们有了一个与Spring <b>的</b>主要设计理念<b>“ Convention over Configuration”</b>更加一致的API。 这是最终的客户代码： <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CompletableFutureReplyingKafkaTemplate &lt; String, Request, Reply &gt; requestReplyKafkaTemplate; ... requestReplyKafkaTemplate.requestReply(request).thenAccept(reply - &gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Reply: "</span></span> + reply.toString()); );</code> </pre> <br><h2> 总结一下 </h2><br> 总而言之，Spring for Kafka 2.2在Apache Kafka中提供了<b>Request-Reply</b>模式的全功能实现，但是API仍然有些粗糙。 在本期中，我们看到API的一些其他抽象和改编可以提供更合乎逻辑的高级API。 <br><br>  <b>警告1：</b> <br> 事件驱动的体系结构的主要优点之一是事件产生者和消费者的解耦，这使得创建更加灵活和不断发展的系统成为可能。 当请求方和响应方密切相关时，使用同步语义“请求-响应”是完全相反的。 因此，仅应在必要时使用。 <br><br>  <b>警告2：</b> <br> 如果需要<b>同步的Request-Response</b> ，那么与使用<b>诸如Apache Kafka之类的异步通道</b>相比，基于<b>HTTP</b>的<b>协议</b>要简单得多且效率更高。 <br> 但是，在某些情况下， <b>通过Kafka</b>进行<b>同步请求-响应</b>很有意义。 合理地选择最佳的工作工具。 <br><br> 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/callistaenterprise/blog-synchronous-kafka</a>找到完整的工作示例。 <br><br><h2> 留言 </h2><br>  <i>Federico•7个月前</i> <br> 当我们有混合需求时，例如，在50％的情况下，我们需要请求-响应，而在50％的情况下，我们需要事件管理？ 我们该怎么做？  Spring Kafka所需的配置看起来非常糟糕。 <br><br>  <i>Jehanzeb Qayyum•6个月前</i> <br> 现在，Spring在响应的一个常见主题中使用分区来提供默认支持。 <br><br> 从版本2.2开始，模板尝试从已配置的响应容器（答复容器）确定响应或分区的主题。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://docs.spring.io/spring-kafka/reference/html/#replying-template</a> <br><br>  <i>尼尔·罗森伯格•8个月前</i> <br> 你好 <br> 在上一段中，您写道，在某些情况下，与HTTP相比，通过Kafka进行同步的Request-Response有意义。 <br> 你能举这样的例子吗？ <br> 谢谢啦 <br> 尼尔 <br><br>  <i>Janne Keskitalo nir rozenberg•8个月前</i> <br> 我们将把一个大容量的交易处理系统分成几个微服务，我有一个想法，就是使用Kafka的Request-Response消息传递来实现类似的处理亲和力。 基本上，Kafka用于将所有呼叫从一个客户端路由到同一事务处理器进程，然后依次一次执行一个。 这种类型的处理可确保线性化（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://stackoverflow.com/a/19515375/7430325</a> ），因果关系，并且还可以进行有效的缓存。 本质上，协调工作将从数据库转移到Kafka，我们可以在Serializable严格隔离模式下启动数据库。 <br> 我还没有深入研究事务语义的细节，以了解它的不足之处，所以这只是一个主意。 <br><br> 由<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@middle_java</a></b>翻译 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN476156/">https://habr.com/ru/post/zh-CN476156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN476140/index.html">如果您知道7000个单词但听不懂，该如何提高听力？</a></li>
<li><a href="../zh-CN476142/index.html">为什么要避免使用异常来控制Java流</a></li>
<li><a href="../zh-CN476144/index.html">使用我玩“秘密圣诞老人”的机器人示例，您如何以及不需要为机器人编写聊天记录</a></li>
<li><a href="../zh-CN476146/index.html">如何扩展数据中心。 Yandex报告</a></li>
<li><a href="../zh-CN476148/index.html">FreeBSD上的postfix + dovecot + mysql</a></li>
<li><a href="../zh-CN476160/index.html">教育软件的诞生及其历史：从机械机器到第一台计算机</a></li>
<li><a href="../zh-CN476162/index.html">我们创建了一个现代的Web应用程序。 熟悉项目并做好工作准备。 第一部分</a></li>
<li><a href="../zh-CN476164/index.html">“这也是数据分析。” 与Mikhail Gelfand谈生物信息学</a></li>
<li><a href="../zh-CN476166/index.html">“真正的钢铁侠”打破了飞行速度纪录</a></li>
<li><a href="../zh-CN476172/index.html">黑帽美国会议。 致富或丧命：使用Black Hat在互联网上赚钱。 第二部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>