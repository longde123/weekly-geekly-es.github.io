<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌅 🛌🏽 👩‍🎤 Lambdas: dari C ++ 11 ke C ++ 20. Bagian 2 💺 👼🏽 🗯️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, Habrovsk. Sehubungan dengan dimulainya rekrutmen ke dalam grup baru pada kursus “Pengembang C ++” , kami membagikan kepada Anda terjemahan dari b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lambdas: dari C ++ 11 ke C ++ 20. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/455978/">  Hai, Habrovsk.  Sehubungan dengan dimulainya rekrutmen ke dalam grup baru pada kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Pengembang C ++”</a> , kami membagikan kepada Anda terjemahan dari bagian kedua artikel “Lambdas: dari C ++ 11 ke C ++ 20”.  Bagian pertama bisa dibaca di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><img src="https://habrastorage.org/webt/1v/wn/ec/1vwnecq2qaxmin6vtdxqcuv77ja.png"><br><br>  Pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama dari seri,</a> kami melihat lambdas dalam hal C ++ 03, C ++ 11, dan C ++ 14.  Dalam artikel ini, saya menggambarkan motivasi di balik fitur C ++ yang kuat ini, penggunaan dasar, sintaksis, dan peningkatan di setiap standar bahasa.  Saya juga menyebutkan beberapa kasus perbatasan. <br>  Sekarang saatnya untuk beralih ke C ++ 17 dan melihat masa depan (sangat dekat!): C ++ 20. <a name="habracut"></a><br><br>  <b>Entri</b> <br><br>  Pengingat cepat: ide untuk seri ini muncul setelah salah satu pertemuan Kelompok Pengguna C ++ kami baru-baru ini di Krakow. <br><br>  Kami memiliki sesi pemrograman langsung tentang "sejarah" ekspresi lambda.  Percakapan dilakukan oleh pakar C ++ Thomas Kaminsky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat profil Thomas's Linkedin</a> ).  Inilah acaranya: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lambdas: Dari C ++ 11 ke C ++ 20 - C ++ Grup Pengguna Krakow</a> . <br><br>  Saya memutuskan untuk mengambil kode dari Thomas (dengan izinnya!) Dan menulis artikel berdasarkan itu. Pada bagian pertama dari seri saya berbicara tentang ekspresi lambda sebagai berikut: <br><br><ul><li>  Sintaks dasar </li><li>  Tipe lambda </li><li>  Hubungi operator </li><li>  Menangkap variabel (dapat diubah, global, variabel statis, anggota kelas dan penunjuk ini, objek yang hanya dapat bergerak, menyimpan konstanta): <br><br><ul><li>  Jenis kembali </li><li>  IIFE - Ekspresi Fungsi Segera Diminta </li><li>  Konversi ke penunjuk fungsi </li><li>  Jenis kembali </li><li>  IIFE - Ekspresi yang Segera Diminta </li><li>  Konversi ke pointer fungsi </li></ul></li><li>  Perbaikan dalam C ++ 14 <br><br><ul><li>  Jenis keluaran kembali </li><li>  Abadikan dengan penginisialisasi </li><li>  Tangkap variabel anggota </li><li>  Ekspresi lambda generik </li></ul></li></ul><br>  Daftar di atas hanya bagian dari sejarah ekspresi lambda! <br><br>  Sekarang mari kita lihat apa yang telah berubah di C ++ 17 dan apa yang kita dapatkan di C ++ 20! <br><br>  <b>Perbaikan dalam C ++ 17</b> <br><br>  Standar (konsep sebelum publikasi) bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">N659</a> tentang lambdas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[expr.prim.lambda]</a> .  C ++ 17 membawa dua perbaikan signifikan pada ekspresi lambda: <br><br><ul><li>  constexpr lambda </li><li>  Tangkap * ini </li></ul><br>  Apa arti inovasi ini bagi kita?  Mari kita cari tahu. <br><br>  <i><b>ekspresi constexpr lambda</b></i> <br><br>  Dimulai dengan C ++ 17, standar secara implisit mendefinisikan <code>operator()</code> untuk tipe lambda sebagai <code>constexpr</code> , jika mungkin: <br><blockquote>  Dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">expr.prim.lambda # 4</a> : <br>  Operator panggilan fungsi adalah fungsi constexpr jika pernyataan parameter kondisi ekspresi lambda yang sesuai diikuti oleh constexpr, atau memenuhi persyaratan untuk fungsi constexpr. </blockquote><br>  Sebagai contoh: <br><br><pre> <code class="bash hljs">constexpr auto Square = [] (int n) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> n*n; }; // implicitly constexpr static_assert(Square(2) == 4);</code> </pre> <br>  Ingatlah bahwa dalam C ++ 17 <code>constexpr</code> fungsi harus mengikuti aturan ini: <br><br><ul><li>  seharusnya tidak virtual; <br><br><ul><li>  tipe pengembaliannya harus tipe literal; </li><li>  masing-masing tipe parameternya harus tipe literal; </li><li>  tubuhnya harus = delete, = default atau pernyataan majemuk yang tidak mengandung <br><ul><li>  definisi asm </li><li>  ekspresi kebotakan, </li><li>  tag </li><li>  coba blokir atau </li><li>  definisi variabel non-literal, variabel statis, atau variabel memori streaming yang inisialisasi tidak dilakukan. </li></ul></li></ul></li></ul><br>  Bagaimana dengan contoh yang lebih praktis? <br><br><pre> <code class="bash hljs">template&lt;typename Range, typename Func, typename T&gt; constexpr T SimpleAccumulate(const Range&amp; range, Func func, T init) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto &amp;&amp;elem: range) { init += func(elem); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> init; } int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { constexpr std::array arr{ 1, 2, 3 }; static_assert(SimpleAccumulate(arr, [](int i) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> i * i; }, 0) == 14); }</code> </pre><br>  Anda dapat bermain dengan kode di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ Wandbox</a> <br><br>  Kode menggunakan lambda <code>constexpr</code> , dan kemudian diteruskan ke algoritma <code>SimpleAccumulate</code> sederhana.  Algoritme menggunakan beberapa elemen C ++ 17: penambahan <code>constexpr</code> ke <code>std::array</code> , <code>std::begin</code> dan <code>std::end</code> (digunakan dalam <code>for</code> loop dengan range) sekarang juga <code>constexpr</code> , jadi ini berarti semua kode dapat dieksekusi pada waktu kompilasi. <br><br>  Tentu saja tidak semuanya. <br><br>  Anda dapat menangkap variabel (asalkan mereka juga <code>constexpr</code> ): <br><br><pre> <code class="bash hljs">constexpr int add(int const&amp; t, int const&amp; u) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> t + u; } int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { constexpr int x = 0; constexpr auto lam = [x](int n) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> add(x, n); }; static_assert(lam(10) == 10); }</code> </pre><br>  Tetapi ada kasus menarik ketika Anda tidak meneruskan variabel yang ditangkap lebih lanjut, misalnya: <br><br><pre> <code class="bash hljs">constexpr int x = 0; constexpr auto lam = [x](int n) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> n + x };</code> </pre> <br>  Dalam hal ini, di Dentang kita bisa mendapatkan peringatan berikut: <br><br> <code>warning: lambda capture 'x' is not required to be captured for this use</code> <br> <br>  Ini mungkin karena fakta bahwa x dapat diubah di tempat dengan setiap penggunaan (kecuali jika Anda mentransfernya lebih lanjut atau mengambil alamat nama ini). <br><br>  Tapi tolong beri tahu saya jika Anda tahu aturan resmi untuk perilaku ini.  Saya hanya menemukan (dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cppreference</a> ) (tapi saya tidak dapat menemukannya di draft ...) <br><br>  <i><b>(Catatan Penerjemah: ketika pembaca kami menulis, maksud saya mungkin mengganti nilai 'x' di setiap tempat di mana ia digunakan. Jelas tidak mungkin untuk mengubahnya.)</b></i> <br><br>  <i>Ekspresi lambda dapat membaca nilai variabel tanpa menangkapnya jika variabel</i> <i><br></i>  <i>* memiliki integer <code>non-volatile</code> konstan atau tipe enumerated dan telah diinisialisasi dengan <code>constexpr</code> atau</i> <i><br></i>  <i>* adalah <code>constexpr</code> dan tidak memiliki anggota yang bisa berubah.</i> <br><br>  Bersiaplah untuk masa depan: <br><br>  Dalam C ++ 20, kita akan memiliki algoritma standar <code>constexpr</code> dan, mungkin, bahkan beberapa kontainer, jadi <code>constexpr</code> akan sangat berguna dalam konteks ini.  Kode Anda akan terlihat sama untuk versi run-time dan juga untuk versi <code>constexpr</code> (versi waktu kompilasi)! <br><br>  Singkatnya: <br><br>  <code>constexpr</code> lambda memungkinkan Anda untuk konsisten dengan pemrograman boilerplate dan mungkin memiliki kode yang lebih pendek. <br><br>  Sekarang mari kita beralih ke fitur penting kedua yang tersedia di C ++ 17: <br><br>  <b>Tangkapan * ini</b> <br>  <i><b>Tangkap * ini</b></i> <br><br>  Apakah Anda ingat masalah kami ketika kami ingin menangkap anggota kelas?  Secara default, kami menangkap ini (sebagai penunjuk!), Dan karena itu kami mungkin memiliki masalah ketika objek sementara keluar dari ruang lingkup ... Ini dapat diperbaiki menggunakan metode penangkapan dengan penginisialisasi (lihat bagian pertama dari seri).  Tetapi sekarang, di C ++ 17, kami memiliki cara yang berbeda.  Kami dapat membungkus salinan * ini: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#include &lt;iostream&gt; struct Baz { auto foo() { return [*this] { std::cout &lt;&lt; s &lt;&lt; std::endl; }; } std::string s; }; int main() { auto f1 = Baz{"ala"}.foo(); auto f2 = Baz{"ula"}.foo(); f1(); f2(); }</span></span></code> </pre> <br>  Anda dapat bermain dengan kode di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ Wandbox</a> <br><br>  Menangkap variabel anggota yang diinginkan menggunakan tangkapan dengan penginisialisasi melindungi Anda dari kemungkinan kesalahan dengan nilai sementara, tetapi kami tidak dapat melakukan hal yang sama ketika kami ingin memanggil metode seperti: <br><br>  Sebagai contoh: <br><br><pre> <code class="bash hljs">struct Baz { auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [this] { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(); }; } void <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>() const { std::cout &lt;&lt; s &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } std::string s; };</code> </pre> <br>  Di C ++ 14, satu-satunya cara untuk membuat kode lebih aman adalah dengan menangkap <code>this</code> dengan initializer: <br><br><pre> <code class="bash hljs">auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [self=*this] { self.print(); }; }   C ++ 17    : auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [*this] { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(); }; }</code> </pre> <br>  Satu hal lagi: <br><br>  Perhatikan bahwa jika Anda menulis <code>[=]</code> dalam fungsi anggota, <code>this</code> ditangkap secara implisit!  Ini dapat menyebabkan kesalahan di masa depan ... dan itu akan menjadi usang di C ++ 20. <br><br>  Jadi kita sampai pada bagian selanjutnya: masa depan. <br><br>  <b>Masa depan dengan C ++ 20</b> <br><br>  Di C ++ 20, kita mendapatkan fungsi-fungsi berikut: <br><br><ul><li>  Izinkan <code>[=, this]</code> sebagai tangkapan lambda - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P0409R2</a> dan batalkan penangkapan implisit ini melalui <code>[=]</code> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P0806</a> </li><li>  Ekstensi paket dalam <code>lambda init-capture: ... args = std::move (args)] () {}</code> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P0780</a> </li><li>  <code>thread_local</code> statis, <code>thread_local</code> dan lambda untuk binding terstruktur - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P1091</a> </li><li>  pola lambda (juga dengan konsep) - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P0428R2</a> </li><li>  Penyederhanaan Lambda Capture - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P0588R1</a> </li><li>  Lambda Konstruktif dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditugaskan</a> tanpa menyimpan keadaan default - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P0624R2</a> </li><li>  Lambdas dalam konteks yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak dihitung</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P0315R4</a> </li></ul><br>  Dalam kebanyakan kasus, fungsi yang baru diperkenalkan "membersihkan" penggunaan lambda, dan mereka memungkinkan untuk beberapa kasus penggunaan lanjutan. <br><br>  Misalnya, dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P1091</a> Anda dapat menangkap ikatan terstruktur. <br><br>  Kami juga memiliki klarifikasi terkait dengan menangkap ini.  Di C ++ 20, Anda akan mendapatkan peringatan jika Anda menangkap <code>[=]</code> dalam metode: <br><br><pre> <code class="bash hljs">struct Baz { auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [=] { std::cout &lt;&lt; s &lt;&lt; std::endl; }; } std::string s; }; GCC 9: warning: implicit capture of <span class="hljs-string"><span class="hljs-string">'this'</span></span> via <span class="hljs-string"><span class="hljs-string">'[=]'</span></span> is deprecated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> C++20</code> </pre> <br>  Jika Anda benar-benar perlu menangkap ini, Anda harus menulis <code>[=, this]</code> . <br><br>  Ada juga perubahan yang terkait dengan kasus penggunaan tingkat lanjut, seperti konteks tanpa kewarganegaraan dan lambdas tanpa kewarganegaraan yang dapat dibangun secara default. <br><br>  Dengan kedua perubahan, Anda dapat menulis: <br><br><pre> <code class="bash hljs">std::map&lt;int, int, decltype([](int x, int y) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> x &gt; y; })&gt; map;</code> </pre> <br>  Baca motif untuk fitur-fitur ini dalam versi pertama kalimat: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P0315R0</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P0624R0</a> . <br><br>  Tapi mari kita lihat satu fitur menarik: templat lambda. <br><br>  <b>Pola lambd</b> <br><br>  Di C ++ 14, kami mendapatkan lambdas umum, yang berarti bahwa parameter yang dideklarasikan sebagai otomatis adalah parameter templat. <br><br>  Untuk lambda: <br><br><pre> <code class="bash hljs">[](auto x) { x; }</code> </pre> <br>  Kompiler menghasilkan pernyataan panggilan yang cocok dengan metode boilerplate berikut: <br><br><pre> <code class="bash hljs">template&lt;typename T&gt; void operator(T x) { x; }</code> </pre> <br>  Tetapi tidak ada cara untuk mengubah parameter template ini dan menggunakan argumen template yang sebenarnya.  Dalam C ++ 20, ini akan dimungkinkan. <br><br>  Misalnya, bagaimana kita dapat membatasi lambda kita hanya untuk bekerja dengan vektor dari beberapa jenis? <br><br>  Kita dapat menulis lambda umum: <br><br><pre> <code class="bash hljs">auto foo = []&lt;typename T&gt;(const auto&amp; vec) { std::cout&lt;&lt; std::size(vec) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; std::cout&lt;&lt; vec.capacity() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; };</code> </pre> <br>  Tetapi jika Anda menyebutnya dengan parameter int (misalnya, <code>foo(10);</code> ), Anda mungkin mendapatkan beberapa kesalahan yang sulit dibaca: <br><br><pre> <code class="bash hljs">prog.cc: In instantiation of <span class="hljs-string"><span class="hljs-string">'main()::&lt;lambda(const auto:1&amp;)&gt; [with auto:1 = int]'</span></span>: prog.cc:16:11: required from here prog.cc:11:30: error: no matching <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> call to <span class="hljs-string"><span class="hljs-string">'size(const int&amp;)'</span></span> 11 | std::cout&lt;&lt; std::size(vec) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>;</code> </pre><br>  Dalam C ++ 20 kita dapat menulis: <br><br><pre> <code class="bash hljs">auto foo = []&lt;typename T&gt;(std::vector&lt;T&gt; const&amp; vec) { std::cout&lt;&lt; std::size(vec) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; std::cout&lt;&lt; vec.capacity() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; };</code> </pre> <br>  Lambda di atas memungkinkan pernyataan panggilan templat: <br><br><pre> <code class="bash hljs">&lt;typename T&gt; void operator(std::vector&lt;T&gt; const&amp; s) { ... }</code> </pre> <br>  Parameter templat mengikuti klausa tangkap <code>[]</code> . <br><br>  Jika Anda menyebutnya dengan <code>int (foo(10);)</code> , Anda akan mendapatkan pesan yang lebih bagus: <br><br><pre> <code class="bash hljs">note: mismatched types <span class="hljs-string"><span class="hljs-string">'const std::vector&lt;T&gt;'</span></span> and <span class="hljs-string"><span class="hljs-string">'int'</span></span></code> </pre> <br><br>  Anda dapat bermain dengan kode di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ Wandbox</a> <br><br>  Dalam contoh di atas, kompiler dapat memperingatkan kita tentang ketidakkonsistenan dalam antarmuka lambda daripada dalam kode di dalam tubuh. <br><br>  Aspek penting lainnya adalah bahwa dalam lambda universal Anda hanya memiliki variabel, bukan tipe templatnya.  Oleh karena itu, jika Anda ingin mengaksesnya, Anda harus menggunakan decltype (x) (untuk ekspresi lambda dengan argumen (auto x)).  Ini membuat beberapa kode lebih verbose dan rumit. <br><br>  Misalnya (menggunakan kode dari P0428): <br><br><pre> <code class="bash hljs">auto f = [](auto const&amp; x) { using T = std::decay_t&lt;decltype(x)&gt;; T copy = x; T::static_function(); using Iterator = typename T::iterator; }</code> </pre> <br>  Sekarang Anda dapat menulis sebagai: <br><br><pre> <code class="bash hljs">auto f = []&lt;typename T&gt;(T const&amp; x) { T::static_function(); T copy = x; using Iterator = typename T::iterator; }</code> </pre> <br>  Pada bagian di atas, kami memiliki gambaran umum singkat tentang C ++ 20, tetapi saya memiliki case use tambahan untuk Anda.  Teknik ini bahkan mungkin di C ++ 14.  Jadi baca terus. <br><br>  <b>Bonus - LIFTing dengan lambdas</b> <br><br>  Saat ini kami memiliki masalah ketika Anda memiliki kelebihan fungsi dan Anda ingin meneruskannya ke algoritma standar (atau apa pun yang memerlukan beberapa objek yang disebut): <br><br><pre> <code class="bash hljs">// two overloads: void foo(int) {} void foo(<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>) {} int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { std::vector&lt;int&gt; vi; std::for_each(vi.begin(), vi.end(), foo); }</code> </pre> <br>  Kami mendapatkan kesalahan berikut dari GCC 9 (trunk): <br><br><pre> <code class="bash hljs">error: no matching <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> call to for_each(std::vector&lt;int&gt;::iterator, std::vector&lt;int&gt;::iterator, &lt;unresolved overloaded <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>&gt;) std::for_each(vi.begin(), vi.end(), foo); ^^^^^</code> </pre> <br>  Namun, ada trik di mana kita dapat menggunakan lambda dan kemudian memanggil fungsi kelebihan yang diinginkan. <br><br>  Dalam bentuk dasar, untuk tipe nilai sederhana, untuk dua fungsi kami, kami dapat menulis kode berikut: <br><br><pre> <code class="bash hljs">std::for_each(vi.begin(), vi.end(), [](auto x) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> foo(x); });</code> </pre> <br>  Dan dalam bentuk yang paling umum, kita perlu mengetik lebih banyak: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#define LIFT(foo) \ [](auto&amp;&amp;... x) \ noexcept(noexcept(foo(std::forward&lt;decltype(x)&gt;(x)...))) \ -&gt; decltype(foo(std::forward&lt;decltype(x)&gt;(x)...)) \ { return foo(std::forward&lt;decltype(x)&gt;(x)...); }</span></span></code> </pre> <br>  Kode yang cukup rumit ... bukan?  :) <br><br>  Mari kita coba mendekripsi: <br><br>  Kami membuat lambda generik dan kemudian meneruskan semua argumen yang kami dapatkan.  Untuk menentukannya dengan benar, kita perlu menentukan noexcept dan jenis nilai pengembalian.  Itu sebabnya kami harus menduplikasi kode panggilan - untuk mendapatkan tipe yang benar. <br>  Makro LIFT seperti itu berfungsi di kompiler apa pun yang mendukung C ++ 14. <br><br>  Anda dapat bermain dengan kode di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ Wandbox</a> <br><br>  <b>Kesimpulan</b> <br><br>  Dalam posting ini, kami melihat perubahan signifikan dalam C ++ 17, dan memberikan gambaran umum fitur-fitur baru di C ++ 20. <br><br>  Anda mungkin memperhatikan bahwa dengan setiap iterasi bahasa, ekspresi lambda bercampur dengan elemen C ++ lainnya.  Sebagai contoh, sebelum C ++ 17, kita tidak bisa menggunakannya dalam konteks constexpr, tetapi sekarang dimungkinkan.  Demikian pula dengan lambdas generik yang dimulai dengan C ++ 14 dan evolusinya menjadi C ++ 20 dalam bentuk templat lambdas.  Apakah saya melewatkan sesuatu?  Mungkin Anda punya contoh menarik?  Tolong beri tahu saya di komentar! <br><br>  <b>Referensi</b> <br><br>  C ++ 11 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[expr.prim.lambda]</a> <br>  C ++ 14 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[expr.prim.lambda]</a> <br>  C ++ 17 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[expr.prim.lambda]</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ekspresi Lambda di C ++ |</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumen Microsoft</a> <br>  Simon Brand - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Passing overload set ke fungsi</a> <br>  Jason Turner - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C ++ Weekly - Ep 128 - C ++ 20's Sintaks Templat Untuk Lambdas</a> <br>  Jason Turner - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C ++ Mingguan - Ep 41 - C ++ 17's Dukungan Lambda constexpr</a> <br><br>  Kami mengundang semua orang ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">webinar</a> tradisional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gratis</a> pada kursus, yang akan berlangsung besok 14 Juni. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455978/">https://habr.com/ru/post/id455978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455966/index.html">5 perusahaan pengembang aplikasi seluler teratas di Inggris</a></li>
<li><a href="../id455968/index.html">Saya membuat setengah roda gigi besar di panel surya untuk 250.000 rubel (1 bagian)</a></li>
<li><a href="../id455970/index.html">Semua yang ingin Anda ketahui tentang SwiftUI tetapi takut untuk bertanya</a></li>
<li><a href="../id455972/index.html">Slurm: ulat telah berubah menjadi kupu-kupu</a></li>
<li><a href="../id455976/index.html">Kabinet, modul, atau unit - apa yang harus dipilih untuk manajemen daya di pusat data?</a></li>
<li><a href="../id455980/index.html">iOS Digest No. 7 (31 Mei - 13 Juni)</a></li>
<li><a href="../id455982/index.html">Sudah waktunya untuk mengganti GIF dengan video AV1</a></li>
<li><a href="../id455984/index.html">Cara memahami bahwa tautan berfungsi: metrik dan pembuatan tautan KPI</a></li>
<li><a href="../id455986/index.html">Mengapa teknisi TI harus mengambil otak?</a></li>
<li><a href="../id455988/index.html">Struktur Data dari Status Blockchain Cash Plasma</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>