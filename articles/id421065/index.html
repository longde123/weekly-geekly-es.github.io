<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏽 🌌 👩🏾‍🍳 Bagaimana saya mengajar AI bermain Tetris untuk NES. Bagian 2: AI 🕊️ 💪🏾 👨‍👩‍👦‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian pertama (analisis kode) ada di sini: https://habr.com/post/420725/ . 

 Algoritma 
 Deskripsi 
 Algoritme secara terus menerus melakukan langka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana saya mengajar AI bermain Tetris untuk NES. Bagian 2: AI</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421065/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfd/2c5/a7e/cfd2c5a7e44131bfc188c3eea6ad5139.png" alt="gambar"></div><br>  Bagian pertama (analisis kode) ada di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/post/420725/</a> . <br><br><h2>  Algoritma </h2><br><h3>  Deskripsi </h3><br>  Algoritme secara terus menerus melakukan langkah-langkah berikut: <br><br><ol><li>  Dia menunggu sampai tetrimino baru dibuat. </li><li>  Periksa jenis tetrimino yang baru dibuat, jenis tetrimino berikutnya (gambar di bidang pratinjau) dan konten dari lapangan bermain. </li><li>  Jelajahi semua cara yang mungkin untuk menambahkan dua tetrimino ke lapangan bermain dan mengevaluasi setiap probabilitas. </li><li>  Memindahkan tetrimino yang baru dibuat sehingga cocok dengan lokasi probabilitas yang paling terdeteksi. </li></ol><br>  Setiap langkah ini dijelaskan secara rinci di bawah ini. <br><br><h3>  Kunci pencarian </h3><br>  Pertimbangkan versi Tetris yang disederhanakan, di mana bentuknya tidak jatuh secara otomatis.  Satu-satunya cara untuk menurunkan angka adalah dengan menurunkannya dengan lembut.  Setelah menghapus timing dari permainan, kita dapat sepenuhnya menggambarkan keadaan tetrimino aktif berdasarkan posisi dan orientasinya.  Angka tersebut memiliki tempat penciptaan awal yang diketahui, dan operasi berikut digunakan untuk mengkonversi dari satu kondisi ke kondisi lain: <br><br><ul><li>  Satu langkah ke bawah </li><li>  Satu langkah lagi </li><li>  Pindahkan satu langkah ke kanan </li><li>  Putar satu langkah berlawanan arah jarum jam </li><li>  Rotasi searah jarum jam </li></ul><a name="habracut"></a><br>  Operasi ini hanya berlaku ketika kuadrat tetrimino yang dihasilkan sesuai dengan sel-sel kosong dari lapangan bermain.  Ketika mustahil untuk bergerak satu langkah ke bawah, negara dianggap diblokir.  Namun, karena kami menyederhanakan Tetris dan menunggu penguncian pada dasarnya tidak terbatas, keadaan terkunci dapat diubah lebih lanjut oleh operasi lain dengan menggeser dan menggulir. <br><br>  Banyak negara yang diblokir dengan urutan operasi minimal yang membuatnya dapat ditemukan menggunakan pencarian breadth-first (BFS).  Seperti yang dinyatakan di bawah ini, ia menggunakan antrian untuk menyimpan hasil antara. <br><br><ol><li>  Kami mengantri negara saat membuat. </li><li>  Kami menyimpulkan negara dari antrian. </li><li>  Kami mendapatkan status berikut menggunakan operasi konversi. </li><li>  Jika tidak ada gerakan ke bawah di antara mereka, maka negara yang dihapus dari antrian diblokir. </li><li>  Kami mengantri status berikutnya yang belum kami kunjungi. </li><li>  Jika antrian tidak kosong, ulangi dari langkah 2. </li></ol><br>  Program ini mewakili setiap negara sebagai objek dengan bidang-bidang berikut: <br><br> <code>{ x, y, rotation, visited, predecessor }</code> <br> <br>  Dalam proses persiapan, program membuat array tiga-dimensi objek negara (20 baris × 10 kolom × 4 putaran), menginisialisasi <code>x</code> , <code>y</code> dan <code>rotation</code> sesuai. <br><br>  Bidang yang <code>visited</code> ditandai ketika negara antri.  Dalam BFS, ini valid karena setiap keadaan berikutnya meningkatkan panjang lintasan total dengan 1. Artinya, dengan meningkatkan panjang lintasan tidak mungkin untuk membuat keadaan berikutnya yang perlu dimasukkan di tempat lain selain akhir antrian untuk menjaga ketertiban. <br><br>  Bidang <code>predecessor</code> menunjukkan objek keadaan dari mana kondisi saat ini diturunkan.  Sudah diatur ketika negara antri.  Keadaan penciptaan tidak memiliki status sebelumnya. <br><br>  Himpunan negara yang diblokir terdeteksi selama pencarian ditentukan oleh jenis tetrimino dan blok yang diisi di lapangan bermain.  Urutan gerakan yang menghasilkannya dapat diklarifikasi (dalam urutan terbalik) dengan mengikuti tautan sebelumnya ke kondisi pembuatan.  Ketika <code>PLAY_FAST</code> konstan disetel ke <code>true</code> di awal program, ia benar-benar melewatkan status sebelumnya dengan langsung menempatkan tetrimino di lapangan dan memblokirnya. <br><br>  Array tiga dimensi objek negara, antrian, dan BFS dikemas ke dalam kelas.  Dia memiliki metode pencarian yang menerima lapangan bermain (array dua dimensi), jenis tetrimino dan pendengar.  Setiap kali keadaan terkunci terdeteksi, lapangan bermain diperbarui dengan menambahkan tetrimino ke lokasi yang sesuai.  Kemudian, bidang permainan yang diubah bersama dengan informasi tentang perubahan dikirimkan ke pendengar untuk diproses.  Setelah pendengar menyelesaikan pengembalian, bidang bermain dikembalikan. <br><br>  Pendengar digunakan untuk menggabungkan beberapa operasi pencarian dalam sebuah rantai, yang memungkinkan untuk menemukan semua cara yang mungkin untuk menambahkan dua (atau lebih) tetriminos ke lapangan bermain.  Mesin pencari pertama dalam rantai hanya mengeksekusi BFS sekali.  Namun, mesin pencari kedua mengeksekusi BFS setiap kali pencarian pertama mendeteksi keadaan terkunci.  Dan seterusnya, jika ada mesin pencari lain dalam rantai tersebut. <br><br>  Pendengar mesin pencari terakhir mengevaluasi bidang permainan yang berubah.  Ketika dia menemukan lapangan bermain lebih baik dari apa yang telah diselidiki sebelumnya, dia menuliskan objek yang digunakan dari keadaan terkunci, yang saat ini menggunakan mesin pencari pertama dalam rantai.  Karena mesin pencari pertama hanya mengeksekusi BFS sekali, bidang <code>predecessor</code> dari objek-objek negara tetap valid hingga selesainya seluruh proses pencarian.  Artinya, pendengar terakhir pada dasarnya mencatat jalur yang harus dilalui tetrimino pertama untuk mencapai konfigurasi terbaik dari lapangan permainan sebagai hasilnya. <br><br><h3>  Fungsi evaluasi </h3><br>  Fungsi penilaian memberi nilai pada bidang bermain yang diubah - jumlah terbobot dari berbagai parameter yang memengaruhi.  Fungsi evaluasi yang digunakan dalam kasus ini didasarkan pada fungsi yang dikembangkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Islam Al-Ashi</a> .  Ini menggunakan parameter berikut: <br><br><ul><li>  <b>Total jumlah baris yang dihapus</b> : ini adalah jumlah total baris yang akan dihapus dengan penambahan dua tetriminos. </li><li>  <b>Tinggi pemblokiran total</b> : <b>tinggi pemblokiran</b> adalah ketinggian di atas lantai bidang bermain tempat gambar itu dikunci.  Ini adalah jarak vertikal yang akan dikunci oleh angka yang dikunci jika Anda menghapus semua kotak yang ditempati lain dari lapangan bermain dan menjaga orientasi gambar tersebut.  Tinggi pemblokiran total adalah jumlah ketinggian pemblokiran kedua tetrimino. </li><li>  <b>Jumlah total sel "baik"</b> : <b>sel</b> sumur adalah sel kosong yang terletak di atas semua sel yang ditempati dalam kolom sehingga tetangga kiri dan kanannya adalah sel yang ditempati;  ketika menentukan sumur, dinding lapangan dianggap sel yang ditempati.  Idenya adalah bahwa sumur adalah struktur yang terbuka di bagian atas, ditutup di bagian bawah dan dikelilingi oleh dinding di kedua sisi.  Kemungkinan kesenjangan yang terputus-putus di dinding sumur berarti bahwa sel-sel sumur tidak perlu terjadi dalam tumpukan terus menerus dalam kolom. </li><li>  <b>Total jumlah lubang di kolom</b> : lubang di kolom adalah sel kosong yang terletak tepat di bawah sel yang ditempati.  Jenis kelamin lapangan bermain tidak dibandingkan dengan sel di atasnya.  Tidak ada lubang di kolom kosong. </li><li>  <b>Jumlah total transisi dalam kolom</b> : transisi dalam kolom adalah sel kosong yang berdekatan dengan sel sibuk (atau sebaliknya) dalam satu kolom.  Kombinasi blok kolom yang ditempati paling atas dengan ruang kosong di atasnya tidak dianggap sebagai transisi.  Demikian pula, lantai lapangan bermain juga tidak dibandingkan dengan sel di atasnya.  Oleh karena itu, tidak ada transisi dalam kolom yang benar-benar kosong. </li><li>  <b>Jumlah total transisi dalam baris</b> : transisi dalam baris adalah sel kosong yang berdekatan dengan sel sibuk (atau sebaliknya) dalam baris yang sama.  Sel-sel kosong di dekat dinding lapangan bermain dianggap transisi.  Jumlah total dihitung untuk semua garis lapangan bermain.  Namun, baris yang benar-benar kosong tidak diperhitungkan dalam jumlah total transisi. </li></ul><br>  El-Ashi menyarankan bahwa bobot yang berguna dapat ditemukan menggunakan algoritme optimasi partikel (PSO), yang secara iteratif meningkatkan serangkaian solusi dengan meniru perilaku kerumunan yang diamati di alam.  Dalam kasus kami, setiap solusi adalah vektor bobot, dan kesesuaian opsi ditentukan oleh gim di Tetris;  ini adalah jumlah total tetriminos di mana dia selamat sampai akhir pertandingan. <br><br>  Ide-ide ini diterapkan dalam versi Java yang dijelaskan di bawah ini;  ini berjalan di luar FCEUX dan dapat dikonfigurasikan untuk permainan non-grafis, di dalam memori yang berjalan pada kecepatan yang jauh lebih tinggi.  Setelah menyiapkan PSO, saya terkejut melihat bahwa algoritma tidak bergerak lebih jauh setelah iterasi awal.  Setelah iterasi ini, beberapa varian solusi yang dihasilkan secara acak sudah bermain cukup baik.  Selama beberapa hari, ukuran set ini menurun hingga hanya satu opsi yang tersisa.  Berikut adalah nilai-nilai untuk solusi ini: <br><br><table><tbody><tr><th>  Parameter </th><th>  Berat </th></tr><tr><td>  Total jumlah baris yang dihapus </td><td> <code>1.000000000000000</code> </td> </tr><tr><td>  Tinggi pemblokiran total </td><td> <code>12.885008263218383</code> </td> </tr><tr><td>  Jumlah total sel sumur </td><td> <code>15.842707182438396</code> </td> </tr><tr><td>  Jumlah total lubang di kolom </td><td> <code>26.894496507795950</code> </td> </tr><tr><td>  Jumlah total transisi dalam kolom </td><td> <code>27.616914062397015</code> </td> </tr><tr><td>  Garis Total Melompat </td><td> <code>30.185110719279040</code> </td> </tr></tbody></table><br>  Lapangan bermain diperkirakan dengan mengalikan parameter dengan bobot masing-masing dan menambahkan hasilnya.  Semakin rendah nilainya, semakin baik solusinya.  Karena semua parameter dan bobot memiliki nilai positif, semua parameter membahayakan penilaian keseluruhan;  masing-masing harus diminimalkan.  Ini juga berarti bahwa skor terbaik adalah 0. <br><br>  Karena bobot ini dipilih secara acak, kisaran nilai yang cocok bisa sangat luas.  Seperangkat angka tertentu dan perkiraan kepentingan relatif dari masing-masing parameter mungkin tidak relevan.  Namun demikian, akan menarik untuk memperhatikan mereka dengan seksama. <br><br>  Parameter yang paling tidak berbahaya adalah jumlah baris yang dihapus.  Fakta bahwa opsi ini berbahaya adalah berlawanan dengan intuisi.  Tetapi tujuan utama AI adalah bertahan hidup.  Dia tidak berusaha untuk mendapatkan poin terbanyak.  Sebagai gantinya, ia bermain konservatif, biasanya membersihkan peringkat satu per satu.  Untuk mendapatkan Double, Triple atau Tetris, Anda harus menumbuhkan banyak yang bertentangan dengan tujuan jangka panjang. <br><br>  Berikutnya dalam daftar adalah tinggi total pemblokiran.  Ini dapat diminimalkan dengan menurunkan tetrimino sedekat mungkin ke lantai.  Ini adalah strategi sederhana yang berkontribusi dalam jangka panjang untuk bertahan hidup, dan dalam jangka pendek untuk pengemasan potongan berkualitas. <br><br>  Bobot yang ditetapkan untuk jumlah total sel sumur tampaknya sedikit mengejutkan, karena pemain berpengalaman biasanya dengan sengaja membangun sumur dalam untuk mengumpulkan beberapa Tetris (kombinasi empat baris) berturut-turut.  Tetapi seperti yang disebutkan di atas, ini adalah permainan yang berisiko, bertentangan dengan tujuan utama - bertahan hidup.  Selain itu, jumlah sumur merupakan indikator “kekasaran” tiang.  Tingkat ketidakmerataan tertentu bermanfaat ketika menempatkan angka atau kombinasi angka tertentu.  Namun kekasaran yang tinggi menyebabkan kerusakan pada pengemasan yang ketat. <br><br>  Jumlah total lubang di kolom adalah sekitar setengah dari jumlah total transisi dalam kolom.  Parameter ini dapat digabungkan dan diciutkan menjadi parameter terkait umum, memperoleh parameter yang lebih luas dan paling berbahaya: jumlah total transisi. <br><br>  Daerah padat memiliki sejumlah transisi ke segala arah.  Oleh karena itu, strategi utama, didorong oleh kecerdasan buatan, dapat secara singkat dijelaskan sebagai berikut: kemas potongan-potongan sedekat mungkin satu sama lain. <br><br><h3>  Pilihan lain </h3><br>  Berikut adalah daftar beberapa parameter lagi yang saya coba selama pengembangan AI: <br><br><ul><li>  <b>Tinggi tumpukan</b> : blok yang sibuk dapat menggantung di atas sel kosong, menciptakan tonjolan dan lubang;  Namun, tidak mungkin untuk mengunci blok yang ditempati di atas garis yang benar-benar kosong.  Oleh karena itu, ketinggian tumpukan adalah jumlah baris yang mengandung setidaknya satu blok sibuk. </li><li>  <b>Total jumlah kolom yang ditempati</b> : ini adalah jumlah kolom yang mengandung setidaknya satu sel yang ditempati. </li><li>  <b>Total jumlah sel yang ditempati</b> : jumlah sel yang ditempati di lapangan bermain. </li><li>  <b>Total jumlah area yang terhubung</b> : algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengisian</a> digunakan di sini untuk menghitung jumlah area yang terhubung secara terus-menerus.  Selain menemukan "pulau-pulau" yang diduduki, ia menemukan lubang yang membentang di kedua sumbu. </li><li>  <b>Penyebaran tinggi kolom</b> : Ini adalah ukuran statistik dari variasi ketinggian kolom.  Ini merupakan indikator kekasaran permukaan. </li><li>  <b>Nilai adaptasi total</b> : menghitung nilai adaptasi heap untuk gambar tak dikenal berikutnya.  Ini menghitung jumlah total cara di mana 7 jenis bentuk dapat ditambahkan ke lapangan bermain tanpa munculnya lubang baru.  Untuk penghitungan yang akurat, diperlukan penggunaan BFS berulang kali.  Tetapi untuk perhitungan perkiraan, pohon pencarian bisa sangat terpotong. </li><li>  <b>Peringkat rata-rata untuk gambar berikutnya</b> : parameter ini memperdalam pencarian dengan menganalisis semua kemungkinan untuk angka yang tidak diketahui berikutnya.  Ini menggunakan parameter lain untuk memisahkan lokasi masing-masing jenis angka, dan kemudian mengembalikan rata-rata untuk 7 peringkat.  Untuk setiap penempatan gambar, BFS diperlukan. </li><li>  <b>Game simulasi rata-rata</b> : parameter mensimulasikan serangkaian game di Tetris, memilih game menggunakan generator nomor pseudo-acak sendiri dan menggunakan AI untuk bekerja dengannya.  Di akhir setiap pertandingan, lapangan bermain dievaluasi menggunakan parameter lain.  Nilai rata-rata untuk semua batch dikembalikan. </li></ul><br>  Semua parameter dapat disesuaikan dengan menambahkan faktor khusus.  Misalnya, alih-alih hanya menghitung baris yang dihapus, Anda dapat menetapkan bobot Anda sendiri untuk Single, Double, Triple dan Tetris, yang mensimulasikan sistem titik.  Jika pembersihan beberapa baris secara bersamaan merusak tujuan jangka panjang untuk bertahan hidup, maka baris tunggal dapat diberi bobot negatif, sementara yang lain bisa menjadi positif. <br><br>  Faktor lain yang bermanfaat adalah nilai offset.  Sebagai contoh, permukaan tumpukan rata yang sempurna memiliki dispersi ketinggian kolom 0. Tetapi permukaan yang rata sempurna tidak beradaptasi dengan S dan Z, serta kombinasi bentuk lainnya.  Oleh karena itu, dengan mengurangi konstanta, varians harus dipusatkan di sekitar kekasaran optimal. <br><br>  Parameter yang disesuaikan dan bias dapat dinaikkan ke tingkat tertentu sehingga sebelum menghitung jumlah tertimbang mereka dapat menskalakan logaritmik atau eksponensial.  Semua probabilitas ini dapat dianggap sebagai bobot tambahan yang berpotensi dioptimalkan dengan metode seperti PSO. <br><br>  Banyak parameter memberikan pemahaman tentang seberapa baik tumpukan dapat menangani potongan tambahan, misalnya, yang berhubungan dengan kekasaran permukaan, tetapi “Jumlah total adaptasi”, “Nilai rata-rata dari gambar berikutnya” dan “Permainan simulasi rata-rata” mengevaluasi bidang permainan yang diubah memasukkan angka yang tidak termasuk dalam dua yang diketahui.  Dalam studi angka-angka berikutnya, karena eliminasi seri yang cepat, jumlah pengetahuan tambahan yang diperoleh berkurang dengan kedalaman.  Ini berarti bahwa masa lalu yang panjang dari partai tidak begitu penting, dan jalannya partai di masa depan yang jauh juga tidak terlalu penting.  Bahkan, jika urutan angka pendek secara acak salah, maka AI dengan cepat mengembalikan permainan, menggunakan beberapa angka berikut untuk menghapus baris yang terpengaruh.  Menentukan nilai optimal untuk analisis angka-angka selanjutnya membutuhkan penelitian lebih lanjut. <br><br>  Aspek lain dari kegunaan parameter adalah biaya komputasi.  Biaya sangat meningkat karena fungsi evaluasi dipanggil untuk setiap kemungkinan penempatan dua angka.  Karena AI harus dapat memainkan Tetris dalam waktu nyata, faktor biaya yang memberikan informasi berharga dapat ditukar dengan teknik perkiraan lainnya yang berjalan lebih cepat. <br><br><h3>  Pelatihan AI </h3><br>  Ada urutan patologis yang dapat menyebabkan Game Over, terlepas dari strategi.  Contoh paling sederhana adalah urutan tiada akhir dari tetrimino S dan Z, yang, seperti yang ditunjukkan dalam animasi, dengan cepat menyebabkan AI hilang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb2/66a/2ba/cb266a2ba3575a43876e33f6a2948737.gif"></div><br>  Karena dibutuhkan beberapa hari untuk menjalankan varian AI sebelum menyelesaikan beberapa batch dan menghitung rata-rata, maka sama sekali tidak praktis untuk menggunakan durasi batch rata-rata sebagai metrik kontrol PSO.  Sebagai gantinya, Anda dapat meningkatkan kompleksitas gim dengan kecepatan terkontrol dengan meningkatkan frekuensi S dan Z, yang seiring waktu akan mengarah pada penciptaan alternatif dari hanya sepasang angka ini. <br><br>  Saya mencoba menggunakan metode pengajaran ini, tetapi menemukan bahwa mengajar AI untuk bekerja dengan S dan Z sering benar-benar membahayakan kemampuan untuk mengatasi bentuk acak yang didistribusikan secara merata. <br><br>  Dalam metode alternatif yang terinspirasi oleh game B-Type, metrik PSO mengontrol frekuensi pembersihan baris.  Lapangan bermain adalah diagram 10-baris dari blok-blok sampah acak, dan setiap kali garis tersebut dihapus, garis-garis sampah baru muncul di bawah, memulihkan ketinggian tumpukan.  Karena lapangan bermain memiliki lebar 10 kolom, dan rata-rata setiap tetrimino terdiri dari 4 kotak, AI harus menghapus setiap baris setiap 2,5 tetrimino.  Dan untuk menghilangkan sampah, dia harus melakukannya lebih cepat lagi. <br><br>  Sayangnya, teknik ini juga tidak meningkatkan kinerja.  Salah satu alasan yang mungkin adalah bahwa lubang sampah acak tidak benar-benar cocok dengan string yang ditangani AI dalam permainan nyata.  Selain itu, membersihkan baris adalah tujuan jangka pendek;  pembersihan baris serakah tidak selalu meningkatkan kelangsungan hidup jangka panjang.  Dari waktu ke waktu, baris tidak boleh disentuh untuk memproses kombinasi angka-angka berikutnya. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Colin Fei</a> menyarankan pendekatan berbeda di halaman web-nya.  Dia menciptakan histogram yang menunjukkan persentase bentuk yang diblokir di setiap baris selama lot percobaan.  Menariknya, semua histogram terlihat hampir identik terlepas dari jumlah angka yang dibuat.  Berdasarkan hal ini, ia menyarankan agar Anda dapat menggunakan gambar perkiraan fungsi untuk kumpulan percobaan saat mengevaluasi ekspektasi statistik untuk memblokir angka di garis kreasi, sehingga mendapatkan waktu selama AI akan bermain sampai akhir permainan.  Saya memutuskan untuk mengeksplorasi kemungkinan ini. <br><br>  Di bawah ini adalah peta panas dari banyak batch percobaan, secara total mengandung 2.039.900.000 tetrimino.  Setiap sel diwarnai berdasarkan persentase bentuk yang terkunci di dalamnya.  Untuk meningkatkan kontras visual, palet non-linear dipilih.  Peta dibuat dengan menormalkan nilai sel dengan membaginya dengan persentase sel maksimum, dan kemudian mengumumkan hingga kekuatan 0,19 (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"koreksi gamma"</a> ). <br><br><table><tbody><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d13/bcd/196/d13bcd1968b1f71c3311f7007c6f573e.png"></div></td><td><table><tbody><tr><th>  Warna </th><th>  Persentase </th></tr><tr><td>  <font color="#000000">■</font> </td><td> <code>0.00000000</code> </td> </tr><tr><td>  <font color="#0066FF">■</font> </td><td> <code>0.00000315</code> </td> </tr><tr><td>  <font color="#00CCFF">■</font> </td><td> <code>0.00024227</code> </td> </tr><tr><td>  <font color="#00FFCC">■</font> </td><td> <code>0.00307038</code> </td> </tr><tr><td>  <font color="#00FF66">■</font> </td><td> <code>0.01860818</code> </td> </tr><tr><td>  <font color="#00FF00">■</font> </td><td> <code>0.07527774</code> </td> </tr><tr><td>  <font color="#66FF00">■</font> </td><td> <code>0.23582574</code> </td> </tr><tr><td>  <font color="#CCFF00">■</font> </td><td> <code>0.61928352</code> </td> </tr><tr><td>  <font color="#FFCC00">■</font> </td><td> <code>1.42923040</code> </td> </tr><tr><td>  <font color="#FF6600">■</font> </td><td> <code>2.98867416</code> </td> </tr><tr><td>  <font color="#FF0000">■</font> </td><td> <code>5.78182519</code> </td> </tr></tbody></table></td></tr></tbody></table><br>  Garis-garis oranye dan merah gelap di garis 17 dan 18 berarti bahwa sebagian besar angka berakhir di sana.  Rona hijau pucat dari bawah adalah konsekuensi dari geometri angka-angka: hanya 4 dari 7 jenis tetrimino yang dapat muncul di garis bawah.  Sudut bawah berwarna hitam karena tidak mungkin untuk sampai ke sana. <br><br>  Warna di sepanjang setiap garis hampir seragam, dan ini menunjukkan bahwa bentuknya didistribusikan secara horizontal secara merata.  Kesenjangan kecil dapat dijelaskan dengan melihat histogram dari masing-masing jenis bentuk: <br><br><table><tbody><tr><td>  <b>T</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82c/fb3/c14/82cfb3c1456fce7726985859554021d8.png"></div></td><td>  <b>J</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebd/f38/1a2/ebdf381a25323b9c73eaed6c467064b5.png"></div></td><td>  <b>Z</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/381/986/389/38198638921c4dcbc3a8f1978e665b89.png"></div></td><td>  <b>O</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/669/be1/5e4/669be15e4ba1b9becffb4ee97e398cbb.png"></div></td><td>  <b>S</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc8/79c/2a5/dc879c2a52f1020a69f76e9554fca978.png"></div></td><td>  <b>L.</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbf/204/acb/fbf204acb6d376818fc6e98f8f517e4e.png"></div></td><td>  <b>Saya</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/e41/92b/7bbe4192bbb2204d4b677a9a36354da2.png"></div></td></tr></tbody></table><br>  T ternyata menjadi tipe yang paling universal: histogramnya lebih seragam daripada yang lainnya.  Anomali dalam histogram J - hasil dari pengaruh dinding;  hanya <code>Jr</code> dan <code>Jl</code> dapat berada di kolom samping, yang membuat AI menggunakan kolom 1 dan 9 lebih sering untuk mengkompensasi. Hal yang sama berlaku untuk L. Histogram Z dan S terlihat kurang lebih sama, yang menekankan ketidakseimbangan karena fakta bahwa <code>Zv</code> dan <code>Sv</code> bukan gambar cermin sempurna satu sama lain.  Tipe O terbatas pada bidang bermain 19 × 9, dan sepertinya AI lebih cenderung menggunakan O di sisi daripada di tengah.  Tetrimino I bergeser ke kanan, karena titik awalnya terletak di sana;  oleh karena itu, mengunci di kolom 1 jarang terjadi. <br><br>  Tabel menunjukkan persentase angka yang diblokir di setiap baris. <br><br><table><tbody><tr><th>  Tali </th><th>  Persentase </th></tr><tr><td>  0 </td><td>  0,0000000000 </td></tr><tr><td>  1 </td><td>  0,0000000000 </td></tr><tr><td>  2 </td><td>  0,0000004902 </td></tr><tr><td>  3 </td><td>  0,0000026472 </td></tr><tr><td>  4 </td><td>  0,0000066180 </td></tr><tr><td>  5 </td><td>  0,0000172557 </td></tr><tr><td>  6 </td><td>  0,0000512280 </td></tr><tr><td>  7 </td><td>  0,0001759400 </td></tr><tr><td>  8 </td><td>  0,0006681210 </td></tr><tr><td>  9 </td><td>  0,0023187901 </td></tr><tr><td>  10 </td><td>  0,0077928820 </td></tr><tr><td>  11 </td><td>  0,0259672043 </td></tr><tr><td>  12 </td><td>  0,0866187068 </td></tr><tr><td>  13 </td><td>  0,2901315751 </td></tr><tr><td>  14 </td><td>  0,9771663807 </td></tr><tr><td>  15 </td><td>  3.3000408353 </td></tr><tr><td>  16 </td><td>  10.6989059268 </td></tr><tr><td>  17 </td><td>  28.5687976371 </td></tr><tr><td>  18 </td><td>  50.0335706162 </td></tr><tr><td>  19 </td><td>  6.0077671454 </td></tr></tbody></table><br>  Berikut adalah grafik nilai-nilai: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a6/943/9d8/8a69439d8d818e46921cc5c9b75bd345.png"></div><br>  Jika baris 19 tidak diperhitungkan, maka grafik menunjukkan pertumbuhan eksponensial. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berikut ini adalah daftar rasio jumlah bentuk terkunci di baris yang berdekatan. </font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">String </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / String </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></sub> </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rasio (%) </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1/2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,00 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2/3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 18.52 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3/4 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 40.00 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4/5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 38.35 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5/6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 33.68 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6/7 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12/29 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7/8 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 26.33 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8/9 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 28.81 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9/10 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 29,76 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10/11 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 01/30 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11/12 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 29,98 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12/13 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 29.85 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 13/14 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 29.69 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14/15 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 29.61 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15/16 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 30.84 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16/17 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 37.45 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 17/18 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 57.10 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 18/19 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 832.81 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Garis-garis </font></font><code>16–19</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memperhitungkan angka-angka yang berinteraksi dengan lantai lapangan bermain, sehingga mereka dapat dibuang. Dalam baris, </font></font><code>0–5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pemilihannya terlalu kecil untuk bermakna. Rasio yang tersisa, pasangan 6 / 7-14 / 15, hampir identik; nilai rata-rata mereka adalah 29,24%. Ini berarti bahwa kemungkinan timbunan tumbuh oleh satu garis kira-kira sama terlepas dari tinggi timbunan. Ini logis, karena aturan Tetris membatasi interaksi di bagian atas tumpukan ketika itu padat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grafik berikut menunjukkan log </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> persen dari angka di baris 6-15.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd6/7ec/745/fd67ec745b6509ae7c165ae0ebabedcc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu dekat dengan garis lurus sempurna dengan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">koefisien determinasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mendekati 1 </font><font style="vertical-align: inherit;">. Rumus yang berasal dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regresi linier yang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ditunjukkan di atas </font><font style="vertical-align: inherit;">memberi kita persimpangan dengan sumbu Y, dengan asumsi bahwa persentase bentuk di baris 0 adalah sekitar 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">−7,459</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> %. Kebalikan dari nilai ini memberi kita harapan statistik dari 2.877.688.349 tetrimino atau 1.151.175.340 baris sampai akhir pertandingan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini membuat kita mengerti bahwa log </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">persentase angka di setiap garis tetap linier hingga garis 0. Namun, ketika tumpukan hampir mencapai langit-langit lapangan permainan, kebebasan bergerak dibatasi sedemikian rupa sehingga properti ini dilanggar. Selain itu, memblokir bagian pada baris 0 tidak berarti game over; Anda masih bisa diselamatkan jika ada tempat untuk membuat angka baru. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara lain untuk menilai kekuatan AI adalah untuk mengukur jumlah rata-rata bentuk yang dibuat antara pembersihan penuh dari lapangan bermain. Pembersihan lengkap dapat diperoleh hanya dengan 5 tetriminos. Misalnya, di antara kemungkinan-kemungkinan lain, ini dapat dicapai dengan lima angka O yang diletakkan di lantai lapangan bermain.Secara umum, karena setiap tetrimino terdiri dari 4 kotak dan lebar lapangan bermain adalah 10 kotak, jumlah angka yang dibuat antara pembersihan penuh harus kelipatan 5 ( sejak itu</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 × 5n = 2 × 10n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AI saya memiliki jumlah rata-rata bentuk yang dibuat antara pembersihan lapangan penuh 1.181 - jumlah yang cukup kecil. Karena pembersihan penuh adalah seperti memulai kembali game, batch penuh dapat dilihat sebagai seri restart game yang sangat panjang, diikuti dengan kemajuan cepat ke game over. Seperti urutan alternatif yang dijelaskan di atas </font></font><code>SZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, urutan patologis yang mengarah ke akhir permainan biasanya sangat singkat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Histogram di bawah ini menunjukkan probabilitas (dalam persen) bahwa AI akan mencapai pembukaan lapangan setelah jumlah angka yang dibuat.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7f/665/112/f7f66511246ef114d27d325a21c9b785.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urutan derajat dalam formula di atas menentukan laju penurunan dan, mungkin, kekuatan AI. Menurut rumus ini, sekitar 0,4%, atau sekitar 1 dari 253 pertandingan dimulai dengan lapangan kosong, berakhir dengan pembersihan lengkap setelah hanya 5 tetriminos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berbeda dengan apa yang disarankan Faye, konstanta dalam pendekatan linier dan eksponensial membutuhkan ukuran sampel yang sangat besar sehingga R </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mendekati 1, jadi metode ini tidak berlaku untuk PSO. </font><font style="vertical-align: inherit;">Namun, konstanta yang diperoleh dengan batch panjang dapat digunakan untuk mengoptimalkan fungsi aproksimasi yang menciptakan kemungkinan nilai konstan untuk batch pendek. </font><font style="vertical-align: inherit;">Dalam semacam loop umpan balik pengembangan, fungsi perkiraan yang dioptimalkan dapat digunakan dalam PSO, yang meningkatkan AI, yang pada gilirannya dapat digunakan untuk menghitung konstanta baru, yang berfungsi sebagai kriteria referensi untuk fungsi aproksimasi.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Versi Java </font></font></h3><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tentang program ini </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk pengembang yang tidak terbiasa dengan Lua, saya menambahkan </font><font style="vertical-align: inherit;">port Java AI </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke file zip sumber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Kelas adalah terjemahan baris-demi-baris </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari objek Lua berdasarkan penutupan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paket </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kode ini dibagi menjadi dua paket: </font></font><br><br><ul><li> <code>tetris.ai</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berisi kelas dan antarmuka AI. </font></font></li><li> <code>tetris.gui</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menciptakan model grafis dari lapangan bermain. </font></font></li></ul><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kelas dan antarmuka AI </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas dengan nama yang sesuai </font></font><code>Tetriminos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggambarkan tetrimino. </font><font style="vertical-align: inherit;">Ini digunakan dengan cara yang sama </font></font><code>enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan mengandung konstanta untuk semua jenis tetrimino:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NONE = -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> T = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> J = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Z = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> O = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> S = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> L = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> I = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br> <code>NONE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berarti nilai yang belum ditetapkan. </font><font style="vertical-align: inherit;">Ini digunakan untuk sel-sel kosong dari lapangan bermain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga </font></font><code>Tetriminos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi dua model tabel orientasi. </font></font><code>PATTERNS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ini adalah array bilangan bulat 4 dimensi (tipe × rotasi × ​​kuadrat × koordinat) yang berisi koordinat relatif kuadrat; </font><font style="vertical-align: inherit;">garis-garis diatur sedemikian rupa sehingga pada setiap jenis orientasi penciptaan bentuk adalah yang pertama. </font></font><code>ORIENTATIONS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adalah model lain, array 2 dimensi (tipe × rotasi) objek </font></font><code>Orientation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Masing </font></font><code>Orientation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">masing </font><font style="vertical-align: inherit;">berisi koordinat bujur sangkar sebagai larik objek </font></font><code>Point</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini juga memiliki bidang yang menggambarkan kisaran posisi yang diizinkan untuk orientasi yang sesuai.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Orientation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Point[] squares = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minX; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxX; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxY; ... }</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rotasi tetrimino (indeks kedua di kedua tabel orientasi) digunakan dalam objek </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang dimanipulasi BFS.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rotation; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> visited; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> State predecessor; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> State next; ... }</code> </pre> <br> <code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>rotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bersama </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">sama menggambarkan posisi dan orientasi gambar. Karena tipe Tetrimino tetap konstan dari saat penciptaan hingga pemblokiran, bidang untuk itu adalah opsional. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang berisi algoritma BFS membuat set lengkap semua objek yang mungkin </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ketika dibuat:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createStates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ states = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State[AI.PLAYFIELD_HEIGHT][AI.PLAYFIELD_WIDTH][<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; AI.PLAYFIELD_HEIGHT; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; AI.PLAYFIELD_WIDTH; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rotation = <span class="hljs-number"><span class="hljs-number">0</span></span>; rotation &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; rotation++) { states[y][x][rotation] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(x, y, rotation); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun Java memiliki API Koleksi kaya, ini </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi implementasi antrian sendiri. Kelas </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">digunakan </font></font><code>State.next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menggabungkan objek </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke dalam daftar tertaut. Karena semua objek </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sudah ditentukan sebelumnya, dan masing-masing </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat ditambahkan ke antrian tidak lebih dari sekali, antrian dapat bekerja di tempat, yang menghilangkan kebutuhan untuk objek kontainer sementara yang tidak perlu digunakan dalam implementasi antrian umum. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Jantung" BFS adalah metode yang ditunjukkan di bawah ini </font></font><code>search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] playfield, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tetriminoType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxRotation = Tetriminos.ORIENTATIONS[tetriminoType].length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mark = globalMark++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!addChild(playfield, tetriminoType, mark, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(queue.isNotEmpty()) { State state = queue.dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxRotation != <span class="hljs-number"><span class="hljs-number">0</span></span>) { addChild(playfield, tetriminoType, mark, state, state.x, state.y, state.rotation == <span class="hljs-number"><span class="hljs-number">0</span></span> ? maxRotation : state.rotation - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxRotation != <span class="hljs-number"><span class="hljs-number">1</span></span>) { addChild(playfield, tetriminoType, mark, state, state.x, state.y, state.rotation == maxRotation ? <span class="hljs-number"><span class="hljs-number">0</span></span> : state.rotation + <span class="hljs-number"><span class="hljs-number">1</span></span>); } } addChild(playfield, tetriminoType, mark, state, state.x - <span class="hljs-number"><span class="hljs-number">1</span></span>, state.y, state.rotation); addChild(playfield, tetriminoType, mark, state, state.x + <span class="hljs-number"><span class="hljs-number">1</span></span>, state.y, state.rotation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!addChild(playfield, tetriminoType, mark, state, state.x, state.y + <span class="hljs-number"><span class="hljs-number">1</span></span>, state.rotation)) { lockTetrimino(playfield, tetriminoType, id, state); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini memunculkan antrian dengan keadaan tetrimino yang dibuat, dan kemudian secara berurutan mengambil elemen anak dari status yang dihapus dari antrian, menambahkan mereka kembali ke antrian ketika mereka muncul di lapangan bermain. </font><font style="vertical-align: inherit;">Bidang permainan yang berisi kombinasi sel sibuk dan kosong, tipe Tetrimino yang dibuat, dan pengidentifikasi sewenang-wenang diteruskan ke </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode </font></font><code>search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Selama pelaksanaan BFS, seorang pendengar dipanggil setiap kali posisi kunci terdeteksi.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISearchListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] playfield, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tetriminoType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, State state)</span></span></span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendengar menerima bidang bermain yang diubah yang berisi tetrimino terkunci di tempatnya. Jenis Tetrimino yang dibuat dan pengidentifikasi arbitrer juga ditransmisikan. Parameter terakhir adalah </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana tetrimino diblokir. Dengan mengikuti rantai tautan </font></font><code>State.predecessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Anda dapat memulihkan sepenuhnya kembali ke </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membuat bentuk. </font></font><br><br> <code>State.visited</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat diimplementasikan sebagai </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; tapi dengan semua fasilitas yang diperlukan untuk memilah-milah sebelum mencari </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk bantuan </font></font><code>visited</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sebaliknya, saya membuat </font></font><code>visited</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dibandingkan dengan penghitung, bertambah dengan setiap panggilan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode</font></font><code>addChild</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pra-antrian keadaan selanjutnya. Keadaan berikutnya harus berada di dalam bidang dan terletak di 4 sel kosong dari lapangan bermain. Selain itu, negara bagian berikutnya harus dikunjungi </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jika posisi itu valid, </font></font><code>addChild</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kembalikan </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bahkan jika negara bagian berikutnya tidak dapat antri karena sudah dikunjungi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode ini </font></font><code>search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakan nilai kembali </font></font><code>addChild</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menentukan apakah suatu bentuk dapat dibuat. Jika angka tidak dapat dibuat, maka tumpukan telah mencapai bagian atas dan pencarian tidak lagi dapat dilakukan; karena itu ia kembali </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dikembalikan</font></font><code>addChild</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Signifikansi juga sedang dipelajari untuk kemungkinan turun langkah lain. Jika ini tidak dapat dilakukan, maka keadaan saat ini adalah posisi kunci dan panggilan dimulai </font></font><code>lockTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Metode ini </font></font><code>lockTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengubah bidang bermain, memanggil pendengar, dan kemudian mengembalikan bidang bermain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap baris array </font></font><code>playfield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi 1 elemen tambahan, yang menyimpan jumlah sel yang ditempati di baris. Menambah elemen dilakukan dengan metode ini </font></font><code>lockTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">karena menandai sel sebagai sibuk. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika pendengar menerima lapangan bermain yang dimodifikasi, ia memanggil</font></font><code>PlayfieldUtil.clearRows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menghapus baris yang diisi metode mengenalinya dengan memeriksa nilai dalam elemen tambahan dari array. Untuk menghapus string, kode memanfaatkan fakta bahwa di Jawa, array dua dimensi pada dasarnya adalah array array; itu hanya menekan tautan ke string. </font></font><code>PlayfieldUtil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengandung garis bebas; dia menyelesaikan proses pembersihan dengan memasukkan tautan ke salah satunya. Sebelum melakukan shift, indeks baris yang dihapus disimpan dalam elemen baris tambahan. Kemudian tautan ke garis didorong ke tumpukan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian pendengar memanggil</font></font><code>PlayfieldUtil.restoreRows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk membuang perubahan yang dilakukan ke lapangan bermain. </font><font style="vertical-align: inherit;">Langkah-langkah dibatalkan dalam urutan terbalik. </font><font style="vertical-align: inherit;">Pertama, kita mendapatkan baris gratis dari atas. </font><font style="vertical-align: inherit;">Kemudian, baris yang diisi diambil dari tumpukan dan indeks dari elemen tambahan dipulihkan. </font><font style="vertical-align: inherit;">Ini digunakan untuk menggeser referensi garis dan untuk kembali ke tempat baris yang dihapus. </font><font style="vertical-align: inherit;">Akhirnya, elemen tambahan dikembalikan, ia diberi nilai lebar lapangan bermain - jumlah sel yang ditempati di baris yang diisi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada </font></font><code>PlayfieldUtil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juga metode </font></font><code>evaluatePlayfield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang menghitung dan menulis 4 parameter evaluasi ke dalam kelas wadah yang ditunjukkan di bawah ini.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlayfieldEvaluation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> holes; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> columnTransitions; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rowTransitions; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wells; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas mengelola semua ini </font></font><code>AI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini berisi dua objek yang </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terhubung bersama oleh pendengar yang ditunjukkan di bawah ini.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] playfield, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tetriminoType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, State state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == <span class="hljs-number"><span class="hljs-number">0</span></span>) { result0 = state; } Orientation orientation = Tetriminos.ORIENTATIONS[tetriminoType][state.rotation]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rows = playfieldUtil.clearRows(playfield, state.y); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalTotalRows = totalRows; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalTotalDropHeight = totalDropHeight; totalRows += rows; totalDropHeight += orientation.maxY - state.y; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextID = id + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextID == tetriminoIndices.length) { playfieldUtil.evaluatePlayfield(playfield, e); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> fitness = computeFitness(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fitness &lt; bestFitness) { bestFitness = fitness; bestResult = result0; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchers[nextID].search(playfield, tetriminoIndices[nextID], nextID); } totalDropHeight = originalTotalDropHeight; totalRows = originalTotalRows; playfieldUtil.restoreRows(playfield, rows); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas </font></font><code>AI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat menangani sejumlah objek </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi Nintendo Tetris hanya menunjukkan satu bentuk di muka. Objek </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disimpan dalam array, dan kode yang ditunjukkan di atas berfungsi sebagai pendengar umum mereka. Pengidentifikasi acak yang diteruskan ke metode </font></font><code>Searcher.search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebenarnya adalah indeks array, yang juga merupakan kedalaman pencarian. Ketika pendengar dipanggil, pengenal mengarahkan panggilan ke yang berikutnya </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam rantai. Jika ia mencapai akhir array, maka evaluasi bidang bermain. Dan ketika dia menemukan lapangan bermain dengan skor kebugaran yang lebih tinggi, dia menuliskan yang diblokir </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari yang pertama </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam rantai. </font></font><br><br> <code>AI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi metode </font></font><code>search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang menerima lapangan bermain dan array yang berisi jenis tetrimino yang dibuat dan berikutnya. Dia kembali</font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi posisi dan rotasi di mana tetrimino pertama harus diblokir. </font><font style="vertical-align: inherit;">Dia tidak fokus pada tetrimino kedua; </font><font style="vertical-align: inherit;">pada saat dipanggil, itu menghitung ulang skor. </font><font style="vertical-align: inherit;">Jika tumpukan terlalu tinggi dan rantai </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gagal menempatkan kedua tetrimino, maka itu </font></font><code>AI.search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan kembali </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] playfield, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] tetriminoIndices)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tetriminoIndices = tetriminoIndices; bestResult = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; bestFitness = Double.MAX_VALUE; searchers[<span class="hljs-number"><span class="hljs-number">0</span></span>].search(playfield, tetriminoIndices[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bestResult; }</code> </pre> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tantangan AI </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena versi Java tidak terikat dengan FCEUX, ini berpotensi dapat digunakan untuk proyek lain. Bagi mereka yang tertarik untuk mengintegrasikan AI di tempat lain, bagian ini menjelaskan semua yang Anda butuhkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, buat sebuah instance </font></font><code>AI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, instance, </font></font><code>PlayfieldUtil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan array untuk menampung semua jenis tetrimino yang diketahui. Selain itu, buat </font></font><code>PlayfieldUtil.createPlayfield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instance lapangan bermain dengan </font><font style="vertical-align: inherit;">memanggil </font><font style="vertical-align: inherit;">; mengembalikan array dua dimensi dengan kolom tambahan, yang kami periksa di atas. Anda mungkin juga membutuhkan generator angka acak.</font></font><br><br><pre> <code class="java hljs">AI ai = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AI(); PlayfieldUtil playfieldUtil = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PlayfieldUtil(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] tetriminos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[AI.TETRIMINOS_SEARCHED]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] playfield = playfieldUtil.createPlayfield(); Random random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awalnya, lapangan bermain kosong, dan semua sel relevan </font></font><code>Tetriminos.NONE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jika Anda mengisi sel secara terprogram, maka jangan lupa untuk menuliskan </font></font><code>playfield[rowIndex][AI.PLAYFIELD_WIDTH]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jumlah sel yang ditempati di setiap baris. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isi larik jenis tetrimino dengan jenis bentuk yang awalnya dibuat dan bentuk berikutnya, yang biasanya dipilih secara manual.</font></font><br><br><pre> <code class="java hljs">tetriminos[<span class="hljs-number"><span class="hljs-number">0</span></span>] = random.nextInt(<span class="hljs-number"><span class="hljs-number">7</span></span>); tetriminos[<span class="hljs-number"><span class="hljs-number">1</span></span>] = random.nextInt(<span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lalu kami melewati bidang bermain dan array tipe ke metode </font></font><code>AI.search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dia akan kembali </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana Anda perlu memblokir tetrimino pertama. </font><font style="vertical-align: inherit;">Jika dia kembali </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka game over tidak bisa dihindari.</font></font><br><br><pre> <code class="java hljs">State state = ai.search(playfield, tetriminos);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda membutuhkan cara dari membuat gambar hingga mengunci, maka meneruskannya ke </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode </font></font><code>AI.buildStateList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="java hljs">State[] states = ai.buildStatesList(state);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memperbarui lapangan bermain, kami akan meneruskannya </font></font><code>PlayfieldUtil.lockTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beserta jenis dan objeknya </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Metode ini secara otomatis menghapus baris yang diisi.</font></font><br><br><pre> <code class="java hljs">playfieldUtil.lockTetrimino(playfield, tetriminos[<span class="hljs-number"><span class="hljs-number">0</span></span>], state);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum menelepon lagi, </font></font><code>AI.search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda perlu secara acak memilih tetrimino berikutnya.</font></font><br><br><pre> <code class="java hljs">tetriminos[<span class="hljs-number"><span class="hljs-number">0</span></span>] = tetriminos[<span class="hljs-number"><span class="hljs-number">1</span></span>]; tetriminos[<span class="hljs-number"><span class="hljs-number">1</span></span>] = random.nextInt(<span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bersama-sama, ini terlihat seperti ini: </font></font><br><br><pre> <code class="java hljs">AI ai = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AI(); PlayfieldUtil playfieldUtil = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PlayfieldUtil(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] tetriminos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[AI.TETRIMINOS_SEARCHED]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] playfield = playfieldUtil.createPlayfield(); Random random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); tetriminos[<span class="hljs-number"><span class="hljs-number">0</span></span>] = random.nextInt(<span class="hljs-number"><span class="hljs-number">7</span></span>); tetriminos[<span class="hljs-number"><span class="hljs-number">1</span></span>] = random.nextInt(<span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// ... print playfield ... State state = ai.search(playfield, tetriminos); if (state == null) { break; // game over } playfieldUtil.lockTetrimino(playfield, tetriminos[0], state); tetriminos[0] = tetriminos[1]; tetriminos[1] = random.nextInt(7); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alih-alih menampilkan bidang bermain dalam bentuk teks, Anda dapat menggunakan cara yang lebih menarik untuk menampilkan apa yang terjadi ... </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tampilan bidang bermain </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas </font></font><code>TetrisFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meniru grafis Nintendo Tetris, termasuk fitur perilaku yang dijelaskan pada bagian sebelumnya dari artikel.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d58/dac/a4c/d58daca4c668408a42efa51ad7508d75.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melihatnya beraksi, jalankan </font></font><code>tetris.gui.Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seperti halnya versi Lua, kita dapat menyesuaikan kecepatan game dengan mengubah nilai konstan di awal file.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> PLAY_FAST = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;</code> </pre> <br> <code>TetrisFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memiliki 4 metode untuk memanipulasi layar. </font><font style="vertical-align: inherit;">Metode ini </font></font><code>displayTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membuat tetrimino aktif dalam koordinat yang ditentukan. </font><font style="vertical-align: inherit;">Ini menerima parameter penundaan, yang menyebabkan metode menunggu sebelum mengembalikan jumlah frame animasi yang ditentukan.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayTetrimino</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delay)</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode ini </font></font><code>lockTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengunci gambar pada tempatnya. </font><font style="vertical-align: inherit;">Penghitung baris, titik, level, dan warna tetrimino diperbarui sesuai, menunjukkan perilaku penasaran yang diharapkan ketika nilai melebihi nilai yang diizinkan. </font><font style="vertical-align: inherit;">Menetapkan </font></font><code>animate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai </font><font style="vertical-align: inherit;">ke parameter </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mencakup animasi pembersihan baris dan kerlipan layar saat menerima Tetris. </font><font style="vertical-align: inherit;">Metode ini diblokir sampai animasi selesai.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lockTetrimino</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> animate)</span></span></span></span></code> </pre> <br> <code>updateStatisticsAndNext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> melakukan penambahan penghitung statistik untuk tetrimino yang baru dibuat dan memperbarui tampilan gambar berikutnya. </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateStatisticsAndNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> activeTetrimino, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nextTetrimino)</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode ini </font></font><code>dropTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menciptakan bentuk dan memungkinkannya untuk turun di bawah pengaruh "gravitasi", tanpa membuat upaya untuk memutar atau memindahkannya. </font></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakannya untuk dua angka terakhir ketika </font></font><code>AI.search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kembali </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jika parameter </font></font><code>animate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penting </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka jika tidak mungkin untuk membuat angka, tirai akhir permainan akan turun. Seperti semua metode lain, metode ini memblokir hingga animasi selesai. Ini kembali </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya ketika itu dapat membuat angka di lapangan bermain yang sibuk.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dropTetrimino</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> animate)</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 metode ini harus dipanggil oleh alur kerja, tetapi </font></font><code>TetrisFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus dibuat di Thread Pengiriman Acara itu sendiri. Untuk melihat bagaimana ini dilakukan, lihat kelas </font></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demi kepentingan, ia </font></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakan kelas </font></font><code>Randomizer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang mensimulasikan pseudo-random number generator dari Nintendo Tetris. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paket ini </font></font><code>tetris.gui.images</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi file terkait tampilan. </font></font><code>tiles.png</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ini adalah tabel pola yang berisi semua grafik ubin. </font></font><code>background.dat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyimpan pengidentifikasi ubin yang membentuk latar belakang; data diekstraksi dari </font></font><code>$BF3F</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dan itu </font></font><code>colors.dat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi byte yang menghasilkan warna kotak yang tidak biasa yang muncul dari level 138. Ini </font></font><br><br> <code>ImageLoader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi tabel palet NES, dan </font></font><code>ImagePane</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">set lengkap nilai level yang ditampilkan disimpan.</font></font><br><br><h4>  Proyek lainnya </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berpotensi, kode dapat digunakan alih-alih menulis untuk mode demo. Bahkan, demo seperti itu dapat dilakukan selamanya, mengambil keuntungan dari seberapa cepat AI mampu membersihkan seluruh lapangan bermain. Untuk mencapai hal ini, dalam generator angka pseudo-acak, Anda perlu menggunakan konstanta arbitrer sebagai seed, yang akan memberi kami urutan tetrimino deterministik. Dua urutan tetrimino pertama akan direkam. Ketika AI mencapai pembersihan lapangan penuh, dua tetriminos berikutnya akan dibandingkan dengan dua urutan pertama. Jika mereka cocok (acara ini diharapkan setiap 49 pembersihan lapangan penuh), maka generator angka acak semu dapat dilewati konstan yang sama dengan seed, yang akan membuat loop demo tanpa batas. Durasi siklus bisa sangat lama untuk menyembunyikan fakta bahwa itu adalah siklus. Jugademo dapat dimulai pada titik acak di loop, membuat demo baru setiap kali.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemungkinan lain menggunakan AI adalah untuk membuat mode "pemain versus komputer". Dalam Tetris multi-pemain, saat membersihkan beberapa garis pada saat yang sama, garis sampah muncul di bagian bawah bidang lawan, meningkatkan lapangan bermain. AI harus dapat melindungi dirinya sendiri dari puing-puing dengan alasan yang sama bahwa ia dapat memainkan game Tipe-B. Namun, seperti yang dinyatakan sebelumnya, AI bermain secara konservatif, biasanya berusaha untuk menghapus satu baris pada satu waktu. Artinya, ia akan dapat mempertahankan diri dari serangan, tetapi ia tidak dapat menyerang. Untuk dapat mengubah perilakunya, saya membuat antarmuka yang disebut </font></font><code>IChildFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IChildFilter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] playfield, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tetriminoType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotation)</span></span></span></span>; }</code> </pre> <br> <code>AI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memiliki konstruktor alternatif yang mendapat implementasi </font></font><code>IChildFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jika tersedia, </font></font><code>IChildFilter.validate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini berfungsi sebagai pemeriksaan tambahan untuk izin negara anak; jika kembali </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka status anak tidak antri. </font></font><br><br> <code>WellFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merupakan implementasi</font></font><code>IChildFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditujukan untuk mengambil empat baris (Tetris). </font><font style="vertical-align: inherit;">Seperti pemain yang hidup, dia secara bertahap membangun sumur di kolom paling kanan dari lapangan bermain, naik baris demi baris dari bawah ke atas. </font><font style="vertical-align: inherit;">Karena ini bekerja baris demi baris, ia menolak status anak yang menambahkan kotak ke kolom paling kanan. </font><font style="vertical-align: inherit;">Ketika seluruh baris, dengan pengecualian kolom sumur, benar-benar penuh, AI melanjutkan ke baris berikutnya. </font><font style="vertical-align: inherit;">Ketika 4 atau lebih dari garis-garis ini siap, itu memungkinkan "tongkat" jatuh ke dalam sumur dan mendapatkan Tetris. </font><font style="vertical-align: inherit;">Selain itu, ketinggian tumpukan dilacak; </font><font style="vertical-align: inherit;">jika terlalu besar, maka tidak </font></font><code>WellFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lagi mempengaruhi AI.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82b/c27/710/82bc27710c0e5200d599be07bf549206.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengujinya dalam operasi, buat </font></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perubahan berikut:</font></font><br><br><pre> <code class="java hljs">AI ai = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WellFilter());</code> </pre> <br> <code>WellFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bekerja, tetapi tidak terlalu efektif. Berisi heuristik sederhana yang dirancang untuk menunjukkan konsep. Untuk mendapatkan Tetris lebih sering, Anda perlu menggunakan strategi yang lebih canggih, mungkin salah satu yang dapat dioptimalkan menggunakan PSO. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, Anda dapat menggunakan pemfilteran status anak untuk menghasilkan pola. Di bawah ini adalah contoh dari apa yang dia mampu </font></font><code>PatternFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/569/e21/15f/569e2115f8936fc3391d1bb330017d8a.png"></div><br> <code>PatternFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat gambar garis demi garis dari bawah ke atas, mirip dengan cara kerjanya </font></font><code>WellFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">Namun, alih-alih mempertahankan kolom paling kanan, itu </font></font><code>PatternFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya menyetujui status anak yang sesuai dengan pola tertentu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstruktor </font></font><code>PatternFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mendapatkan nama salah satu gambar dalam paket </font></font><code>tetris.gui.patterns</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang digunakannya sebagai templat. </font><font style="vertical-align: inherit;">Setiap gambar 20 × 10 berisi piksel hitam dan putih yang terkait dengan sel-sel di lapangan bermain.</font></font><br><br><pre> <code class="java hljs">AI ai = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PatternFilter(<span class="hljs-string"><span class="hljs-string">"tetriminos"</span></span>));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Baris kode yang ditunjukkan di atas menciptakan siluet tujuh jenis tetrimino. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb3/0c8/d79/cb30c8d795e12e41d3831a0735637a55.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contoh lain dengan T tetrimino besar diputar pada suatu sudut. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf0/f95/14c/cf0f9514c3a08b88c4f67117614ade91.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh lain. </font><font style="vertical-align: inherit;">Jika Anda melihat lebih dekat, Anda akan melihat nama permainannya.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a26/712/284/a267122840a2373e7bb5fb6fa6282018.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti </font></font><code>WellFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, itu </font></font><code>PatternFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak lebih dari bukti konsep. </font><font style="vertical-align: inherit;">Pola yang dia proses terbatas pada dasar lapangan karena fakta bahwa upaya untuk mendapatkannya biasanya berakhir dengan permainan berakhir. </font><font style="vertical-align: inherit;">Namun, ini adalah ide yang menarik untuk diteliti lebih lanjut.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Versi Gamepad </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skrip Lua dan program Java mengabaikan gravitasi; bagi mereka, kecepatan turun tidak penting, karena tergantung pada konfigurasi, mereka baik memindahkan angka langsung ke lokasi yang diinginkan, atau menyeret sepanjang jalur yang dipilih. Di satu sisi, mereka hanya meniru Tetris, tidak memainkannya. Namun, dalam </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">file zip dengan sumber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ada skrip Lua lain yang diputar dengan menghasilkan sinyal dari tombol gamepad, yang memungkinkan game untuk mengontrol pergerakan angka, gravitasi dan segala sesuatu lainnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menambahkan gravitasi sangat memperluas ruang pencarian, memaksa AI untuk memperhitungkan aturan licik memanipulasi bentuk. Detail aturan ini dijelaskan di bagian pertama artikel, dan dapat sepenuhnya dihargai dengan studi kode secara langsung.</font></font> Inilah yang paling penting: <br><br><ul><li>       : ,   . </li><li>   «»   . </li><li>   «»  «»    . </li><li>         . </li><li>          . </li><li>          . </li><li>          . </li><li>   ,        . </li><li>   A  B           . </li><li>  «»  «»       6      16 .     «»  «»   ,     . </li><li>  «»            3 . </li><li>       96 .    ,    — . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengakomodasi semua aturan ini, informasi historis harus disematkan di negara pencarian. Mereka membutuhkan bidang di mana jumlah frame penahan untuk setiap tombol dan jumlah frame setelah rilis otomatis terakhir akan disimpan. Setiap rangkaian nilai unik, termasuk koordinat </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan rotasi tetrimino mencirikan keadaan yang terpisah dan unik. Sayangnya, jumlah kemungkinan sangat besar sehingga pencarian penuh ruang ini tidak praktis. Versi AI untuk gamepad hanya mengeksplorasi sebagian saja. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AI menggunakan objek </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan bidang-bidang berikut:</font></font><br><br><pre> <code class="java hljs">{ x, y, rotation, Left, Right, Down, A, B, fallTimer, visited, predecessor }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih menggunakan pergeseran AI otomatis dalam bingkai alternatif, tekan dan lepaskan tombol shift. </font><font style="vertical-align: inherit;">Karena itu, ia perlu memantau hanya kemudian apakah tombol ditekan, dan tidak berapa lama ditekan. </font><font style="vertical-align: inherit;">Karena tidak ada rotasi otomatis, ide yang sama berlaku untuk tombol A dan B. Oleh karena itu lapangan </font></font><code>Left</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Right</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat diartikan sebagai daftar yang berisi salah satu dari nilai berikut:</font></font><br><br><pre> <code class="java hljs">{ RELEASED, PRESSED }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di sisi lain, untuk keturunan lembut, Anda harus menekan tombol "Turun" selama tiga frame, yang mensyaratkan adanya 4 status: </font></font><br><br><pre> <code class="java hljs">{ RELEASED, PRESSED_FOR_1_FRAME, PRESSED_FOR_2_FRAMES, PRESSED_FOR_3_FRAMES }</code> </pre> <br> <code>Down</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secara bertahap meningkat dari nilai </font></font><code>RELEASED</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke </font></font><code>PRESSED_FOR_3_FRAMES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, di mana terjadi soft descent. Setelah itu, ia dapat menerima nilai </font></font><code>RELEASED</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau kembali ke </font></font><code>PRESSED_FOR_2_FRAMES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, menyebabkan penurunan lembut setiap frame kedua setelah penundaan awal. Itu tidak bisa </font></font><code>RELEASED</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari </font></font><code>PRESSED_FOR_1_FRAME</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau dari </font></font><code>PRESSED_FOR_2_FRAMES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebenarnya, kode Lua menggunakan konstanta integer, tetapi prinsipnya sama. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demikian pula, </font></font><code>visited</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>predecessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>fallTimer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu ditugaskan nilai yang diperoleh saat menulis di negara anak antrian; itu </font></font><code>fallTimer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan menjadi satu lebih dari nilai negara induk. Kondisi yang mengandung</font></font><code>fallTimer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sama dengan kecepatan descent, menyiratkan bahwa descent otomatis terjadi pada frame ini, dan untuk keadaan selanjutnya dari state ini nilainya </font></font><code>fallTimer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pre-mendefinisikan </font></font><code>8-</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">array yang berisi semua state yang mungkin ( </font></font><code>20  × 10  × 4  × 2  × 2  × 4  × 2 A × 2 B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), dan BFS dieksekusi sama dengan metode yang ditunjukkan untuk </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">array. </font><font style="vertical-align: inherit;">Pseudo-code yang ditunjukkan di bawah ini menjelaskan bagaimana status selanjutnya diperoleh dari status diam.</font></font><br><br><pre> <code class="cpp hljs">Slide = (Left == PRESSED) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (Right == PRESSED) Rotate = (A == PRESSED) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (B == PRESSED) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Down == RELEASED <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> Down == PRESSED_FOR_3_FRAMES then <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Down == RELEASED then nextDown = PRESSED_FOR_1_FRAME <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> nextDown = PRESSED_FOR_2_FRAMES end addChild(Down = nextDown) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Rotate then addChild(A = PRESSED, Down = nextDown) addChild(B = PRESSED, Down = nextDown) end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Slide then addChild() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Rotate then addChild(A = PRESSED) addChild(B = PRESSED) end <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> addChild(Left = PRESSED) addChild(Right = PRESSED) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Rotate then addChild(Left = PRESSED, A = PRESSED) addChild(Left = PRESSED, B = PRESSED) addChild(Right = PRESSED, A = PRESSED) addChild(Right = PRESSED, B = PRESSED) end end <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Down == PRESSED_FOR_1_FRAME then nextDown = PRESSED_FOR_2_FRAMES <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> nextDown = PRESSED_FOR_3_FRAMES end addChild(Down = nextDown) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Rotate then addChild(A = PRESSED, Down = nextDown) addChild(B = PRESSED, Down = nextDown) end end</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang ditunjukkan pada kode pseudo di bawah ini, fungsi </font></font><code>addChild</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memperhitungkan urutan peristiwa yang terjadi di setiap frame (misalnya, shift, rotasi, dan keturunan).</font></font><br><br><pre> <code class="cpp hljs">nextFallTimer = fallTimer + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Left == PRESSED <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> testPosition(x - <span class="hljs-number"><span class="hljs-number">1</span></span>, y, rotation) then x = x - <span class="hljs-number"><span class="hljs-number">1</span></span> elseif Right == PRESSED <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> testPosition(x + <span class="hljs-number"><span class="hljs-number">1</span></span>, y, rotation) then x = x + <span class="hljs-number"><span class="hljs-number">1</span></span> end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> A == PRESSED <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> testPosition(x, y, nextClockwiseRotation) then rotation = nextClockwiseRotation elseif B == PRESSED <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> testPosition(x, y, nextCounterclockwiseRotation) then rotation = nextCounterclockwiseRotation end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Down == PRESSED_FOR_3_FRAMES <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> nextFallTimer &gt;= dropSpeed then <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> testPosition(x, y + <span class="hljs-number"><span class="hljs-number">1</span></span>, rotation) then y = y + <span class="hljs-number"><span class="hljs-number">1</span></span> nextFallTimer = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> lockTetrimino() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> end end childState = states[y][x][rotation][Left][Right][Down][A][B] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> childState.visited then childState.visited = mark childState.predecessor = state childState.fallTimer = nextFallTimer <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.enqueue(childState) end</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti pada versi sebelumnya, ia </font></font><code>AI.search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengembalikan serangkaian objek </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Namun dalam hal ini, masing </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">masing </font><font style="vertical-align: inherit;">berisi banyak tombol yang perlu ditekan di setiap frame. Bidang </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>rotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak digunakan untuk memanipulasi bentuk, tetapi dapat digunakan untuk memverifikasi gerakan bentuk yang benar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun ruang pencarian telah berkurang secara signifikan karena keterbatasan yang dijelaskan di atas, dibutuhkan 1-3 detik untuk menyelesaikan pencarian. Jika Anda menjalankannya, Anda akan melihat jeda setelah membuat setiap tetrimino. Selain itu, gerakannya terlihat sangat tidak wajar; biasanya belokan dilakukan sesaat sebelum mengunci. Namun, AI ini memainkan cara yang hampir sama dengan versi yang mengabaikan gravitasi, bahkan pada kecepatan maksimum.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memeriksanya, jalankan </font></font><code>lua/NintendoTetrisAIGamepadVersion.lua</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang terletak di </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">file zip dengan sumber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara yang lebih sederhana untuk memperhitungkan gravitasi adalah membatasi pergerakan figur hanya dengan memutar, diikuti oleh pergeseran, dan kemudian turun ke bawah. </font><font style="vertical-align: inherit;">Idenya adalah bahwa jika Anda menyingkirkan geser dan gulir, maka kecepatan vertikal dari angka-angka tersebut akan memiliki sedikit efek pada AI; </font><font style="vertical-align: inherit;">semua yang perlu dia lakukan adalah memberikan angka ke kolom yang diinginkan, dan gravitasi akan melakukan sisanya. </font><font style="vertical-align: inherit;">Keuntungan lain dari teknik ini adalah ruang pencariannya sangat kecil, yang memungkinkan Anda bermain secara real time, tanpa penundaan untuk perhitungan. </font><font style="vertical-align: inherit;">Namun, kelemahan dari pendekatan ini adalah bahwa tanpa sliding dan scrolling, AI bermain jauh lebih buruk. </font><font style="vertical-align: inherit;">Namun, Tetris AI, yang tidak dapat bermain dalam waktu nyata, secara praktis tidak berharga.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selain itu </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfd/2c5/a7e/cfd2c5a7e44131bfc188c3eea6ad5139.png" alt="Tetris"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelumnya, saya menulis sebuah plugin yang secara prosedural mensimulasikan seorang pemain di Tetris. </font><font style="vertical-align: inherit;">Namun, proyek saya memiliki beberapa kelemahan:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bot mematikan gravitasi, memungkinkan Anda untuk melakukan luncuran dan pengguliran, melebihi kemampuan pemain di level paling minimum Nintendo Tetris. </font><font style="vertical-align: inherit;">Dia tidak pernah menaikkan angka ke bawah, tetapi satu-satunya cara untuk menurunkan angka ke bawah adalah keturunan lembut yang terkontrol. </font><font style="vertical-align: inherit;">Artinya, ia bermain di dunia teoretis dan ideal. </font><font style="vertical-align: inherit;">Terus terang, dia curang.</font></font></li><li>   .    —  ,      .     Double, Triple  Tetris,         —  ,    .         90.    ,   ,       29   -     . </li><li>          .      .       .     ,  Tetris      . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bagian ini, saya akan berbicara tentang bot canggih yang memainkan Nintendo Tetris tanpa menonaktifkan gravitasi. </font><font style="vertical-align: inherit;">Dia menilai risiko dan mengelolanya, secara agresif berusaha untuk mendapatkan jumlah poin maksimum sebelum mencapai kecepatan keturunan yang tinggi.</font></font><br><br><hr><br><h1>  Video </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tonton bot dapatkan jumlah maksimum titik Tetris Nintendo mulai dari level 19 di semua video yang ditunjukkan di bawah ini. </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/l2YOt_GdfA0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zsd3eAYMlN0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://www.youtube.com/embed/efh-_zeQH4Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><hr><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unduh </font></font></h1><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TetrisAI_2018-01-28.zip</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> File ini </font></font><code>.zip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi:</font></font><br><br><ul><li> <code>src</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - pohon kode sumber. </font></font></li><li> <code>TetrisAI.jar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Mengompilasi file biner. </font></font></li><li> <code>lgpl-2.1.txt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - lisensi perangkat lunak gratis. </font></font></li></ul><br><hr><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Luncurkan </font></font></h1><br><h2>  Prasyarat </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nintaco</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah emulator NES / Famicom.</font></font></li><li> <code>Tetris (U) [!].nes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - File Nintendo Tetris ROM. </font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Peluncuran plugin </font></font></h2><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luncurkan Nintaco dan buka </font></font><code>Tetris (U) [!].nes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ekstrak </font></font><code>TetrisAI.jar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari yang diunduh </font></font><code>.zip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buka jendela Jalankan Program dengan memilih Alat | </font><font style="vertical-align: inherit;">Jalankan Program ...</font></font></li><li>        JAR        Find JAR… . </li><li>  Load JAR,   . </li><li>  Run. </li><li>        ,       <code>GAME TYPE</code>  <code>MUSIC TYPE</code> .   <code>D-pad</code> (     )  <code>A-TYPE</code>   .   Start (Enter),      . </li><li>    <code>A-TYPE</code>  <code>D-pad</code> (  )   <code>LEVEL 9</code> . ,    <code>A</code>    Start (   <code>X</code>   Enter),     19,    . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patut dipertimbangkan bahwa bot dirancang hanya untuk level 19 dan di atasnya. </font><font style="vertical-align: inherit;">Pada level yang lebih rendah, dia tidak akan bisa mengendalikan bidak.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Referensi kecepatan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar game berjalan lebih cepat, pilih Mesin | </font><font style="vertical-align: inherit;">Kecepatan | </font><font style="vertical-align: inherit;">Maks</font></font><br><br><hr><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Detail </font></font></h1><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dataran tinggi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bawah level 10, kecepatan turun di setiap level sedikit lebih tinggi dari yang sebelumnya. </font><font style="vertical-align: inherit;">Tetapi pada level 10 ke atas ada beberapa dataran tinggi di mana kecepatan tetap konstan untuk beberapa level. </font><font style="vertical-align: inherit;">Ini adalah konsekuensi dari cara mekanisme pemicu bekerja. </font><font style="vertical-align: inherit;">Kecepatan disajikan sebagai jumlah frame per keturunan, yang merupakan nilai integer. </font><font style="vertical-align: inherit;">Yaitu, untuk level yang lebih tinggi tidak ada banyak pilihan yang tersisa: 10–12, 13–15, 16–18, 19–28, dan 29+ adalah 5, 4, 3, 2, dan 1 frame untuk keturunan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bot dikembangkan dengan mempertimbangkan hanya dataran tinggi 19-28. Dalam bingkai yang rata, ia mengklik gamepad "Kiri", "Kanan", A, B atau tidak sama sekali. Dan dalam bingkai aneh, ini memungkinkan penurunan otomatis tanpa menekan tombol apa pun. Tampaknya permainan tidak merasakan gerakan horizontal yang bertepatan dengan rotasi; oleh karena itu, setiap tombol ditekan secara independen dalam bingkai genap. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak seperti master yang bermain di level tinggi, bot tidak memanfaatkan Delayed Auto Shift (DAS), yang juga dikenal sebagai auto-repeat, dan teknik terkait. Karyanya lebih mengingatkan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada teknik ibu jari bergetar dari Thor Akerlund</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Namun, itu meningkatkan frekuensi getaran ke maksimum teoritis yang diizinkan oleh permainan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemain dihargai dengan 40, 100, 300 dan 1200 poin untuk Single, Double, Triple dan Tetris. </font><font style="vertical-align: inherit;">Dan poin-poin dikalikan dengan angka level ditambah 1. Dengan kata lain, untuk mendapatkan skor maksimum, pemain harus berjuang untuk jumlah Tetris maksimum, bermain selama mungkin di level tinggi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Level 19 adalah yang tertinggi yang dapat dipilih sebagai yang awal, yang memungkinkan bot untuk melompat langsung ke dataran 19–28. </font><font style="vertical-align: inherit;">Namun, karena bug dalam mekanisme perhitungan level yang saya sebutkan di bagian sebelumnya, game akan pergi ke level 20 setelah menghapus 140 baris, bukannya 200 yang diharapkan. Setelah itu, game akan mengubah level setiap 10 baris. </font><font style="vertical-align: inherit;">Namun, setelah mencapai 230 baris, bot akan naik dari dataran tinggi dan menyerah dengan cepat. </font><font style="vertical-align: inherit;">Artinya, dia perlu memutar Tetris sebanyak mungkin sebelum membersihkan 230 baris.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Keturunan lembut </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soft descent juga dapat meningkatkan jumlah poin. </font><font style="vertical-align: inherit;">Untuk mendapatkan poin, angka tersebut harus diturunkan dengan lembut untuk mengunci lapangan permainan. </font><font style="vertical-align: inherit;">Keturunan lunak jangka pendek apa pun yang terjadi di sepanjang jalan saat memposisikan angka tidak akan memengaruhi skor. </font><font style="vertical-align: inherit;">Jika keturunan berhasil, pemain akan menerima satu poin untuk setiap garis yang dilintasi selama keturunan lembut. </font><font style="vertical-align: inherit;">Dan nilai yang dihasilkan tidak dikalikan dengan angka level, bahkan jika keturunan lembut mengarah pada membersihkan baris. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soft descent tidak banyak berpengaruh pada skor keseluruhan. </font><font style="vertical-align: inherit;">Namun, jika memungkinkan, bot menyelesaikan penempatan gambar dengan mengklik "Turun" untuk mendapatkan poin ini. </font><font style="vertical-align: inherit;">Dalam kasus yang jarang terjadi, itu dapat rata-rata perbedaan antara skor yang sangat tinggi dan melebihi skor maksimum.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritma AI </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat membuat bentuk, bot mengeksplorasi setiap kemungkinan penempatan bentuk saat ini dan selanjutnya. Penempatan yang diizinkan adalah posisi di mana gambar berada di sel yang ditempati atau di lantai lapangan bermain. Dari tempat penciptaan gambar, posisi ini dapat dicapai melalui urutan gerakan horizontal, belokan dan turun. Lokasi dan urutan jalur yang valid ditemukan menggunakan BSF. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menempatkan sepotong di lapangan bermain memiliki konsekuensi: 4 sel kosong menjadi sibuk, dan semua baris diisi dihapus, membiarkan baris turun. Untuk setiap penempatan yang diperbolehkan dari gambar saat ini dan konsekuensi yang terkait dengannya, bot memeriksa setiap penempatan yang diijinkan dari gambar berikutnya, mengevaluasi kombinasi konsekuensi. Rantai pencarian seperti itu disajikan </font></font><code>SearchChain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap konsekuensi gabungan ditransfer ke fungsi evaluasi yang menghitung isi dari lapangan bermain. </font><font style="vertical-align: inherit;">Kombinasi dengan skor terendah menang dan bagian saat ini ditempatkan sesuai. </font><font style="vertical-align: inherit;">Hasil rantai pencarian hanya memengaruhi bentuk saat ini. </font><font style="vertical-align: inherit;">Saat membuat gambar berikutnya, itu dievaluasi dalam kombinasi dengan angka yang mengikutinya, dan seterusnya.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fungsi evaluasi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fungsi evaluasi adalah jumlah tertimbang dari parameter berikut: </font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jumlah baris yang dihapus</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah jumlah baris yang dihapus dengan penambahan kedua tetriminos.</font></font></li><li> <strong>  </strong> –      ,   .     —   ,        ,       . </li><li> <strong>  -</strong> –    . </li><li> <strong>   </strong> –  ,     -. </li><li> <strong>    </strong> –   ,      .         .     . </li><li> <strong>     </strong> –      .       ,   1.   ,         ,           . </li><li> <strong>     </strong> –         ,    .  —        ,    —          . </li><li> <strong>    </strong> –     .   ,         (20). </li><li> <strong>    </strong> –     .   ,      0. </li><li> <strong>    </strong> –   ,     ( )    . </li><li> <strong>    </strong> :    —   ,     ( )    .         .        .          . </li><li> <strong>   </strong> –           . ,   1  ,   1,     —  0. </li><li> <strong> </strong> –   . </li><li> <strong>  </strong> –         . </li><li> <strong>   </strong> –      . </li><li> <strong>    </strong> –     .     . </li><li> <strong>  </strong> –        . </li></ul><br><h2>  Pembelajaran mesin </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menemukan bobot fungsi evaluasi, kami menggunakan varian metode Particle Swarm Optimization (PSO) yang dijelaskan dalam catatan kaki [1]. Untuk mendapatkan perilaku konvergen yang baik, inersia yang diusulkan dan koefisien percepatan diterapkan. Dan ukuran maksimum langkah-langkah partikel ditentukan oleh batasan nilai kecepatannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selama setiap iterasi, partikel dievaluasi secara paralel untuk memanfaatkan sepenuhnya sumber daya komputasi yang tersedia. Selain itu, setelah konvergensi terdeteksi (tidak ada peningkatan setelah sejumlah iterasi), PSO diatur untuk memulai kembali secara otomatis dengan bobot yang dipilih secara acak, yang memungkinkan kami untuk menjelajahi lebih jauh ruang pencarian.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap vektor posisi partikel dievaluasi dengan mensimulasikan penyelesaian 100 batch di dataran tinggi level 19-28. Batch penuh melibatkan pembersihan 230 baris, tetapi banyak yang berakhir dengan luapan lapangan. Skor batch diurutkan, dan skor partikel ditentukan sebagai rata-rata 33 dari 100 batch. Idenya adalah memilih berdasarkan pada agresivitas. Partikel di sepertiga atas hanya digunakan untuk urutan angka yang diinginkan, yang membatasi kebutuhan untuk permainan konservatif. Akibatnya, mereka cenderung mendorong game yang biasa ke jurang, menunggu "tongkat" berikutnya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urutan pola untuk 100 batch dihasilkan sebelum PSO, dan urutan yang sama digunakan lagi dan lagi. Ini diperlukan untuk memperbaiki ruang pencarian, sehingga opsi solusi dapat dibandingkan satu sama lain. Urutan dibuat menggunakan logika PRNG Nintendo Tetris nyata, yang dirancang untuk mengurangi kemungkinan duplikat mengikuti satu sama lain. Tetapi PRNG juga memiliki kelemahan (lihat bagian “Memilih Tetrimino” dari artikel sebelumnya): PRNG tidak memilih angka secara merata. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Upaya awal menghasilkan bot bertindak terlalu agresif. Jika mereka mengatasi dataran tinggi 19–28, mereka biasanya mencapai skor maksimum. Namun, sayangnya, mereka sering terlalu dini menyebabkan luapan lapangan. Menanggapi ini, empat langkah diambil untuk "menenangkan" bot:</font></font><br><br><ol><li>    :        Tetris,   .      «»          .          .     ;     230 .  ,      Tetris   .        Single, Double  Triple.          ;        . </li><li>          .      ,   ,      7 .         . </li><li>  ,          ,           .        ,       7 . </li><li>          ,      ,      .       ,       .         ,      . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setelah menerapkan semua aturan ini untuk "menenangkan" bot, metode PSO memberikan bobot berikut: </font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parameter </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berat </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Total jumlah baris yang dihapus </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.286127095297893900 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tinggi pemblokiran total </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.701233676909959200 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jumlah total sel sumur </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.711304230768307700 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Total jumlah sumur dalam </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,910665415998680400 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jumlah total lubang di kolom </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.879338064244357000 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Total Lubang Kolom Tertimbang </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.168463848297177000 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jumlah total kedalaman lubang di kolom </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> −0.265587111961757270 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kedalaman Lubang Kolom Minimum </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,289886584949610500 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kedalaman Lubang Kolom Maksimum </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.362361055261181730 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jumlah total transisi dalam kolom </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> −0.028668795795469625 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Garis Total Melompat </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.874179981113233100 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tinggi total kolom </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> −0.507409683144361900 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tinggi tumpukan </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> −2.148676202831281000 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sebaran Tinggi Kolom </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> −1.187558540281141700 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jumlah total sel yang ditempati </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> −2.645656132241128000 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Total jumlah sel yang terisi </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.242043416268706620 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penyebaran Ketinggian Kolom </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.287838126164431440 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena rantai berusaha untuk kombinasi yang meminimalkan fungsi evaluasi, parameter yang memiliki bobot positif dapat dianggap bonus, dan sisanya - denda. </font><font style="vertical-align: inherit;">Tetapi bobot tidak selalu menunjukkan signifikansi dari parameter yang sesuai; </font><font style="vertical-align: inherit;">mereka tidak dinormalisasi, oleh karena itu mereka tidak dapat dibandingkan.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kekuatan AI </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menilai kekuatan AI, sekitar 1,7 juta hasil (dalam poin) dari game simulasi dikumpulkan di dataran tinggi 19-28. Skor tidak mencerminkan permainan di level 29 atau lebih tinggi, dan tidak memperhitungkan poin akun yang diperoleh dari keturunan lunak. Namun, itu termasuk game yang diselesaikan sebelum waktunya karena luapan lapangan. Logika Nintendo Tetris PRNG digunakan untuk menghasilkan urutan Tetrimino. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di antara hasil ini, skor terbesar adalah 1.313.600. Minimal adalah 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rata </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">rata adalah 816.379, dan tampaknya kecil. Tetapi seperti yang disebutkan di bawah ini, data terdistorsi, sehingga skor rata-rata 989.200 poin memberikan ide yang lebih baik dari nilai tipikal.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang dinyatakan di atas, PSO mengoptimalkan bobot berdasarkan rata-rata sepertiga terbaik batch. </font><font style="vertical-align: inherit;">Dalam hal ini, skor rata-rata ketiga terbaik adalah 1 108 860. Faktanya, skor rata-rata 75% terbaik adalah 1.000.000. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bot memiliki probabilitas 47% untuk mencapai batas poin ke level 29. Ia memiliki probabilitas 61% untuk mendapatkan 900.000 poin ke level tersebut. 29. Grafik di bawah ini menunjukkan probabilitas untuk mencetak hingga level 29.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a8/082/43a/5a808243a35de546e886bcf6cc8663aa.png" alt="kepadatan probabilitas"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampaknya probabilitasnya menurun secara linear menjadi sekitar 900.000 poin. </font><font style="vertical-align: inherit;">Kemudian masuk ke kurva sigmoid terbalik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bawah ini adalah histogram yang diperhalus dengan jumlah pihak untuk setiap poin yang dicetak. </font><font style="vertical-align: inherit;">Bentuknya ditentukan oleh turunan dari grafik yang ditunjukkan di atas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b4/cf4/a7c/7b4cf4a7cfc06203bedef3b81243d20b.png" alt="histogram"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda mengabaikan fluktuasi, maka sekitar 900.000 itu datar, dan kemudian masuk ke distribusi normal dengan pusat sekitar 1.050.000 poin. </font><font style="vertical-align: inherit;">Alasan fluktuasi tidak jelas. </font><font style="vertical-align: inherit;">Tampaknya jumlah poin lebih suka untuk melompat dengan peningkatan 20.000 poin. </font><font style="vertical-align: inherit;">Mungkin ini karena siklus pembangunan tumpukan dan mendapatkan Tetris.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RAM dan alokasi ROM </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memanipulasi memori CPU, kirim klik tombol dan terima acara rendering bingkai, plugin menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nintaco API</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Semua alamat memori ditemukan menggunakan alat debugging Nintaco, dan informasi ditambahkan ke </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wiki Data Crystal ROMhacking.net</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dalam kode sumber, mereka terlihat seperti konstanta di antarmuka </font></font><code>Addresses</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><hr><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Referensi </font></font></h1><br><ol><li> van den Bergh, F.; Engelbrecht, AP (2006) <br> A study of particle swarm optimization particle trajectories <br> In: <i>Information Sciences 176 (2006)</i> (pp. 937–971) <br> Retrieved from <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://researchspace.csir.co.za/dspace/bitstream/handle/10204/1155/van%20den%20bergh_2006_D.pdf</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421065/">https://habr.com/ru/post/id421065/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421055/index.html">Pengembangan web khusus: bagaimana mengukur proyek yang terus berkembang</a></li>
<li><a href="../id421057/index.html">Cara merakit kereta untuk kereta penumpang</a></li>
<li><a href="../id421059/index.html">Mempercepat situs dengan kiat awal</a></li>
<li><a href="../id421061/index.html">PostgreSQL: bagaimana dan mengapa WAL membengkak</a></li>
<li><a href="../id421063/index.html">Buku-Buku Baru tentang Pemrograman Anak-Anak di Awal</a></li>
<li><a href="../id421067/index.html">Bagaimana kami mengembangkan aplikasi AR untuk meninjau tempat-tempat bersejarah</a></li>
<li><a href="../id421069/index.html">Bobby Urban Backpack: Inside the Castle</a></li>
<li><a href="../id421071/index.html">Mod dan sisanya tidak sama</a></li>
<li><a href="../id421073/index.html">Episode 1. Biaya Retas</a></li>
<li><a href="../id421075/index.html">Kamus Digital A hingga Z</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>