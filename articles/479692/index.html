<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐗 😥 🐩 Indexación de miles de millones de vectores de texto 🎅🏼 🔛 👨🏿‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Al extraer información, a menudo surge la tarea de encontrar dichos fragmentos de texto. En el contexto de una búsqueda, el usuario puede generar una ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indexación de miles de millones de vectores de texto</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/479692/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/id/dd/fg/idddfg6zku7xq-zv9f0m8xemyiy.jpeg"></div><br>  Al extraer información, a menudo surge la tarea de encontrar <i>dichos</i> fragmentos de texto.  En el contexto de una búsqueda, el usuario puede generar una consulta (por ejemplo, el texto que el usuario ingresa en el motor de búsqueda) o el propio sistema.  A menudo necesitamos hacer coincidir una consulta entrante con consultas ya indexadas.  En este artículo, veremos cómo puede construir un sistema que resuelva este problema en relación con miles de millones de solicitudes sin gastar una fortuna en la infraestructura del servidor. <br><a name="habracut"></a><br>  Primero, definimos formalmente el problema: <br><br><blockquote>  Dado un conjunto fijo de consultas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-1"> Q </script>  solicitud entrante <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-2"> q </script>  y entero <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-3"> k </script>  .  Necesito encontrar un subconjunto de consultas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="noError" id="MJXp-Span-8" style="display: inline-block;">R&nbsp;=&nbsp;\&nbsp;left&nbsp;\&nbsp;{q0,&nbsp;q1,&nbsp;...,&nbsp;qk&nbsp;\&nbsp;right&nbsp;\}&nbsp;\&nbsp;subset&nbsp;Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-4"> R = \ left \ {q0, q1, ..., qk \ right \} \ subset Q </script>  a cada solicitud <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-msubsup" id="MJXp-Span-10"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11" style="margin-right: 0.05em;">q</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-12" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-13">i</span></span></span><span class="MJXp-mtext" id="MJXp-Span-14">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-15">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-5"> q_ {i} \ en R </script>  fue más como <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-18"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-6"> q </script>  que cualquier otra solicitud en <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-20"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">Q</span><span class="MJXp-mo" id="MJXp-Span-22" style="margin-left: 0.267em; margin-right: 0.267em;">∖</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7"> Q ∖ R </script>  . </blockquote><br>  Por ejemplo, con este conjunto de consultas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-24"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-25">Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> Q </script>  : <br><br><pre><code class="plaintext hljs">{tesla cybertruck, beginner bicycle gear, eggplant dishes, tesla new car, how expensive is cybertruck, vegetarian food, shimano 105 vs ultegra, building a carbon bike, zucchini recipes}</code> </pre> <br>  y <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">k</span><span class="MJXp-mo" id="MJXp-Span-28" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-29">3</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> k = 3 </script>  Puede esperar este resultado: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Solicitud de entrada <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> q </script><br></th><th>  Consultas similares <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-32"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> R </script><br></th></tr><tr><td>  recogida de tesla <br></td><td>  {Tesla Cybertruck, Tesla New Car, lo caro que es Cybertruck} <br></td></tr><tr><td>  mejor bicicleta 2019 <br></td><td>  {shimano 105 vs ultegra, son mejores las bicicletas de carbono, el engranaje de la bicicleta} <br></td></tr><tr><td>  cocinar con verduras <br></td><td>  {platos de berenjenas, recetas de calabacín, comida vegetariana} <br></td></tr></tbody></table></div><br>  Tenga en cuenta que todavía no hemos definido un criterio de <i>similitud</i> .  En este contexto, esto puede significar casi cualquier cosa, pero generalmente se reduce a alguna forma de similitud basada en palabras clave o vectores.  Usando la similitud basada en palabras clave, podemos encontrar dos consultas similares si contienen suficientes palabras comunes.  Por ejemplo, las consultas "abrir un restaurante en munich" y "mejor restaurante de munich" son similares porque contienen las palabras "restaurante" y "munich".  Y las consultas "mejor restaurante de munich" y "dónde comer en munich" ya son menos similares, porque solo tienen una palabra en común.  Sin embargo, alguien que busque un restaurante en Munich estaría mejor si el segundo par de solicitudes resultara similar.  Y en esto ayudaremos a la comparación basada en vectores. <br><br><h1>  Representación vectorial de palabras </h1><br>  La representación vectorial de palabras es una técnica de aprendizaje automático utilizada en el procesamiento del lenguaje natural para convertir texto o palabras en vectores.  Moviendo la tarea al espacio vectorial, podemos usar operaciones matemáticas con vectores, sumando y calculando distancias.  Para establecer enlaces entre palabras similares, puede usar métodos tradicionales de agrupación de vectores.  <i>El significado de</i> estas operaciones en el espacio de palabras original puede no ser obvio, pero la ventaja es que ahora tenemos acceso a una amplia gama de herramientas matemáticas.  Si está interesado en los detalles sobre los vectores de palabras y su aplicación, lea sobre <a href="https://arxiv.org/pdf/1301.3781.pdf">word2vec</a> y <a href="https://nlp.stanford.edu/pubs/glove.pdf">GloVe</a> . <br><br>  Tenemos una forma de generar vectores a partir de palabras, ahora los recopilaremos en vectores de texto (vectores de documentos o expresiones).  La forma más fácil de hacer esto es agregando (o promediando) los vectores de todas las palabras en el texto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/692/bc5/b0c/692bc5b0ccbbe7a89392528365645708.png"><br>  <i><sup>Figura 1: Vectores de consulta.</sup></i> <br><br>  Ahora puede determinar la similitud de dos fragmentos de texto (o consultas) representándolos en el espacio vectorial y calculando la distancia entre los vectores.  Típicamente, se usa una distancia angular para esto. <br><br>  Como resultado, la representación vectorial de las palabras permite la coincidencia textual de un tipo diferente, lo que complementa la coincidencia basada en palabras clave.  Puede explorar la similitud semántica de las solicitudes (por ejemplo, "el mejor restaurante de munich" y "dónde comer en munich"), como no podíamos hacer antes. <br><br><h1>  Búsqueda aproximada de vecinos más cercanos </h1><br>  Ahora podemos refinar nuestro problema original de coincidencia de consultas: <br><br><blockquote>  Dado un conjunto fijo de vectores de consulta <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-34"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35">Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> Q </script>  vector entrante <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-36"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> q </script>  y entero <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-38"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> k </script>  .  Necesitas encontrar un subconjunto de vectores <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-40"><span class="noError" id="MJXp-Span-41" style="display: inline-block;">R&nbsp;=&nbsp;\&nbsp;left&nbsp;\&nbsp;{q0,&nbsp;q1,&nbsp;...,&nbsp;qk&nbsp;\&nbsp;right&nbsp;\}&nbsp;\&nbsp;subset&nbsp;Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> R = \ left \ {q0, q1, ..., qk \ right \} \ subset Q </script>  para que la distancia angular de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-42"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> q </script>  a cada vector <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-44"><span class="MJXp-msubsup" id="MJXp-Span-45"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46" style="margin-right: 0.05em;">q</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-47" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-48">i</span></span></span><span class="MJXp-mtext" id="MJXp-Span-49">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> q_ {i} \ en R </script>  era más corta que la distancia a cualquier otro vector en <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-53"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54">Q</span><span class="MJXp-mo" id="MJXp-Span-55" style="margin-left: 0.267em; margin-right: 0.267em;">∖</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> Q ∖ R </script>  . </blockquote><br>  Esto se llama la tarea de encontrar al vecino más cercano.  Hay una <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0_%25D0%25B1%25D0%25BB%25D0%25B8%25D0%25B6%25D0%25B0%25D0%25B9%25D1%2588%25D0%25B5%25D0%25B3%25D0%25BE_%25D1%2581%25D0%25BE%25D1%2581%25D0%25B5%25D0%25B4%25D0%25B0">serie de algoritmos</a> para su solución rápida en espacios de baja dimensión.  Pero cuando trabajamos con representaciones vectoriales de palabras, generalmente operamos con vectores de alta dimensión (100-1000 dimensiones).  Y aquí los métodos mencionados ya no funcionan. <br><br>  No hay una forma adecuada de determinar rápidamente los vecinos más cercanos en espacios de alta dimensión.  Por lo tanto, simplificamos el problema al permitir el uso de resultados aproximados: en lugar de devolver siempre <i>los</i> vectores más cercanos, nos contentaremos con solo algunos de los vecinos más cercanos o <i>en cierta medida</i> cercanos.  Esto se llama la búsqueda aproximada de la tarea de vecinos más cercanos y es un área de investigación activa. <br><br><h3>  Pequeño mundo jerárquico </h3><br>  El gráfico jerárquico de mundo pequeño navegable ( <a href="https://arxiv.org/abs/1603.09320">HNSW</a> ) es uno de los algoritmos más rápidos para la búsqueda aproximada de vecinos más cercanos.  El índice de búsqueda en HNSW es ​​una estructura multinivel en la que cada nivel es un gráfico de proximidad.  Cada nodo del gráfico corresponde a uno de los vectores de consulta. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42e/55e/4b7/42e55e4b72cd088b45e5aff56159f7fb.png"><br>  <sup><i>Figura 2: Gráfico de proximidad multinivel.</i></sup> <br>  Encontrar vecinos más cercanos en HNSW utiliza el método de acercamiento.  Comienza en el nodo de entrada del nivel más alto y realiza recursivamente un recorrido de gráfico codicioso en cada nivel hasta que alcanza un mínimo local en la parte inferior. <br><br>  Los detalles sobre el algoritmo y la técnica de búsqueda están bien descritos en el trabajo científico.  Es importante recordar que cada ciclo de búsqueda de los vecinos más cercanos consiste en atravesar los nodos de los gráficos con el cálculo de las distancias entre los vectores.  Observaremos estos pasos a continuación para utilizar este método para crear un índice a gran escala. <br><br><h1>  La dificultad de indexar miles de millones de consultas </h1><br>  Supongamos que necesitamos indexar 4 mil millones de vectores de consulta de 200 dimensiones, con cada dimensión representada por un número de coma flotante de cuatro bytes (4 mil millones es suficiente para hacer que la tarea sea interesante, pero aún puede almacenar las ID de nodo en números regulares de cuatro bytes) .  Un cálculo aproximado nos dice que el tamaño de los vectores solo será de aproximadamente 3 TB.  Dado que la mayoría de las bibliotecas existentes utilizan una capacidad de RAM para una búsqueda aproximada de los vecinos más cercanos, necesitaremos un servidor muy grande para insertar al menos vectores en la RAM.  Tenga en cuenta que esto no tiene en cuenta el índice de búsqueda adicional, que es necesario para la mayoría de los métodos. <br><br>  En toda la historia del desarrollo de nuestro motor de búsqueda, hemos utilizado varios enfoques diferentes para resolver este problema.  Consideremos algunos de ellos. <br><br><h3>  Subconjunto de datos </h3><br>  El primer y más simple enfoque, que no nos permitió resolver completamente el problema, fue limitar el número de vectores en el índice.  Tomando una décima parte de los datos, creamos un índice que necesita, sorpresa, el 10% de la memoria.  Sin embargo, la calidad de la búsqueda se ha deteriorado, porque ahora hemos operado con menos consultas. <br><br><h3>  Cuantización </h3><br>  Aquí utilizamos todos los datos, pero los redujimos mediante la <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B2%25D0%25B0%25D0%25BD%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">cuantización</a> (utilizamos diferentes técnicas de cuantificación, por ejemplo, la cuantificación del producto, pero no pudimos lograr la calidad de trabajo deseada con esta cantidad de datos).  Al redondear algunos errores, pudimos reemplazar todos los números de cuatro bytes en los vectores originales con versiones cuantificadas de un solo byte.  La cantidad de RAM para los vectores disminuyó en un 75%.  Sin embargo, todavía necesitábamos 750 GB de memoria (sin contar el tamaño del índice en sí), y este sigue siendo un servidor muy grande. <br><br><h1>  Resolviendo problemas de memoria con Granne </h1><br>  Los enfoques descritos tenían sus ventajas, pero requerían muchos recursos y daban una mala calidad de búsqueda.  Aunque <a href="http://ann-benchmarks.com/">hay bibliotecas</a> que responden en menos de 1 ms, podríamos sacrificar la velocidad a cambio de menores requisitos de hardware. <br><br>  <a href="https://github.com/granne/granne">Granne</a> (vecinos más cercanos aproximados basados ​​en gráficos) es una biblioteca HNSW desarrollada y utilizada por Cliqz para buscar tales consultas.  Tiene código fuente abierto, pero la biblioteca aún está en desarrollo activo.  Se publicará una versión mejorada en <a href="https://crates.io/">crates.io</a> en 2020.  Está escrito en Rust con insertos de Python, diseñado para manejar miles de millones de vectores utilizando la competitividad.  Desde el punto de vista de los vectores de consulta, es interesante que Granne tenga un modo especial que requiere mucha menos memoria en comparación con otras bibliotecas. <br><br><h3>  Representación compacta de vectores de consulta </h3><br>  Reducir el tamaño de los vectores de consulta nos dará muchos beneficios.  Para hacer esto, regresemos y consideremos crear vectores.  Como las consultas están formadas por palabras y los vectores de consulta son sumas de vectores de palabras, podemos negarnos explícitamente a almacenar los vectores de consulta y calcularlos según sea necesario. <br><br>  Puede almacenar consultas en forma de conjuntos de palabras y usar la tabla de búsqueda para encontrar los vectores correspondientes.  Sin embargo, evitamos la redirección almacenando cada consulta como una lista de ID enteros correspondientes a los vectores de palabras en la consulta.  Por ejemplo, guarde la consulta "mejor restaurante de munich" como <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-57"><span class="MJXp-mo" id="MJXp-Span-58" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mrow" id="MJXp-Span-59"><span class="MJXp-msubsup" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-62" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-63">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66">t</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-67" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-68"><span class="MJXp-msubsup" id="MJXp-Span-69"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-71" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-72">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-73">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-75">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-78">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-79">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-80">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-81">t</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-82" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-83"><span class="MJXp-msubsup" id="MJXp-Span-84"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-86" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-88">f</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-89" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-90"><span class="MJXp-msubsup" id="MJXp-Span-91"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-92" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-93" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-94">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-95">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-96">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99">h</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-100" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> [{i_ {best}}, {i_ {restaurant}}, {i_ {of}}, {i_ {munich}}] </script>  donde <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-101"><span class="MJXp-mrow" id="MJXp-Span-102"><span class="MJXp-msubsup" id="MJXp-Span-103"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-104" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-105" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-106">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-108">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-109">t</span></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> {i_ {best}} </script>  - esta es la ID de vector de la palabra "mejor", etc. Supongamos que tenemos menos de 16 millones de vectores de palabras (más de esto costará 1 byte por palabra), entonces puede usar 3 bytes para representar todas las ID de palabras.  Es decir, en lugar de almacenar 800 bytes (o 200 bytes en el caso de vectores cuantificados), solo almacenaremos 12 bytes para esta solicitud (esto no es del todo cierto. Dado que las solicitudes consisten en un número diferente de palabras, también debemos almacenar el desplazamiento de la lista en el índice de palabras). esto requerirá 5 bytes por solicitud). <br><br>  En cuanto a la palabra vectores, todos los necesitamos.  Sin embargo, el número de palabras es mucho menor que el número de consultas que se pueden crear combinando estas palabras.  Y eso significa que el tamaño de las palabras no es tan importante.  Si almacena vectores de palabras como versiones de coma flotante de cuatro bytes en una matriz simple <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-110"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-111">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> v </script>  , entonces necesitamos menos de 1 GB por cada millón de palabras.  Este volumen puede caber fácilmente en la RAM.  Ahora el vector de consulta se ve así: <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-112"><span class="noError" id="MJXp-Span-113" style="display: inline-block;">{v&nbsp;_&nbsp;{{i_&nbsp;{best}}}}&nbsp;+&nbsp;{v&nbsp;_&nbsp;{{i_&nbsp;{restaurant}}}&nbsp;+&nbsp;{v&nbsp;_&nbsp;{{i_&nbsp;{of}}}&nbsp;+&nbsp;{v&nbsp;_&nbsp;{{i_&nbsp;{munich}}}}</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> {v _ {{i_ {best}}}} + {v _ {{i_ {restaurant}}} + {v _ {{i_ {of}}} + {v _ {{i_ {munich}}}} </script>  . <br><br>  El tamaño final del envío de la consulta depende del número total de palabras en la consulta.  Para 4 mil millones de consultas, esto es aproximadamente 80 GB (incluidos los vectores de palabras).  En otras palabras, en comparación con los vectores de palabras originales, el tamaño disminuyó en un 97% y en comparación con los vectores cuantificados, en un 90%. <br><br>  Y una cosa más.  Para una búsqueda, necesitamos visitar aproximadamente 200-300 nodos del gráfico.  Cada nodo tiene 20-30 vecinos.  Por lo tanto, necesitamos calcular la distancia desde el vector de consulta de entrada a los vectores 4000-9000 en el índice.  Y lo que es más, necesitamos generar vectores.  ¿Cuánto tiempo lleva crear vectores de consulta sobre la marcha? <br><br>  Resulta que con un procesador bastante nuevo, este problema se puede resolver en unos pocos milisegundos.  Una solicitud que solía ejecutarse en 1 ms ahora se ejecuta en aproximadamente 5 ms.  Pero luego redujimos la cantidad de memoria para vectores en un 90%.  Con mucho gusto aceptamos tal compromiso. <br><br><h3>  Visualización en memoria de vectores e índices. </h3><br>  Arriba, resolvimos el problema de reducir la cantidad de memoria para los vectores.  Pero después de resolver este problema, la estructura del índice se convirtió en un factor limitante.  Ahora necesita reducir su tamaño. <br><br>  En Granne, la estructura del gráfico se almacena de forma compacta en forma de una lista de adyacencia con un número variable de vecinos para cada nodo.  Es decir, la memoria apenas se desperdicia en los metadatos.  El tamaño de la estructura del índice depende en gran medida de los parámetros de diseño y las propiedades del gráfico.  Sin embargo, para tener una idea del tamaño del índice, es suficiente decir que podemos construir un índice para 4 mil millones de vectores con un tamaño total de aproximadamente 240 GB.  Esto puede ser aceptable para uso en memoria en un servidor grande, pero se puede hacer mejor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e73/daa/0de/e73daa0dea90e3e84afe9aaec7bd6a8e.jpg"><br>  <sup><i>Figura 3: Dos diseños diferentes en RAM y SSD.</i></sup> <br><br>  Una propiedad importante de Granne es la capacidad de <a href="https://ru.wikipedia.org/wiki/Mmap">mostrar el</a> índice y los vectores de consulta <a href="https://ru.wikipedia.org/wiki/Mmap">en la memoria</a> .  Esto nos permite cargar perezosamente el índice y compartir memoria con múltiples procesos.  Los archivos de índice y consulta se dividen en archivos de visualización separados en la memoria y se pueden usar en diferentes diseños en RAM y SSD.  Si los requisitos para la demora son un poco menores, entonces colocando el índice en el SSD, las solicitudes a la RAM, mantenemos una velocidad aceptable sin un consumo excesivo de memoria.  Al final del artículo veremos cómo se ve este compromiso. <br><br><h3>  Mejorando la localidad de datos </h3><br>  En nuestra configuración actual, cuando el índice está en un SSD, cada solicitud requiere hasta 200-300 lecturas del disco.  Puede intentar aumentar la localidad de los datos organizando los elementos cuyos vectores están tan cerca que sus nodos HNSW se encuentran en el índice, no muy lejos el uno del otro.  La localidad de los datos mejora el rendimiento, porque es más probable que una sola operación de lectura (generalmente extraída de 4 KB) contenga otros nodos necesarios para atravesar el gráfico.  Y esto, a su vez, reduce el número de recuperaciones de datos por una búsqueda. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f8/1d2/2f4/1f81d22f418256c704bb12b7514e68a1.jpg"><br>  <sup><i>Figura 4: La localidad de datos reduce la recuperación de información.</i></sup> <br><br>  Cabe señalar que reordenar elementos no afecta los resultados de búsqueda, esta es una forma de acelerarlo.  Es decir, el orden puede ser cualquiera, pero no todas las opciones acelerarán la búsqueda.  Es muy difícil encontrar el orden óptimo.  Sin embargo, la heurística que hemos utilizado con éxito es ordenar las consultas por la palabra más <i>importante</i> en cada consulta. <br><br><h1>  Conclusión </h1><br>  Utilizamos Granne para crear y mantener índices multimillonarios con vectores de consulta para buscar consultas similares con un consumo de memoria relativamente bajo.  La siguiente tabla muestra los requisitos para diferentes métodos.  Sea escéptico sobre los valores absolutos de los retrasos durante la búsqueda, ya que dependen en gran medida de lo que se considera una respuesta aceptable.  Sin embargo, esta información describe el rendimiento relativo de los métodos. <br><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Valor inicial <br></th><th>  Cuantización <br></th><th>  Granne (solo RAM) <br></th><th>  Granne (RAM + SSD) <br></th></tr><tr><td>  <b>El recuerdo</b> <br></td><td>  3000 + 240 GB <br></td><td>  750 + 240 GB <br></td><td>  80 + 240 GB <br></td><td>  80-150 GB * <br></td></tr><tr><td>  <b>SSD</b> <br></td><td>  - </td><td>  - </td><td>  - </td><td>  240 GB <br></td></tr><tr><td>  <b>Retraso</b> <br></td><td>  1 ms <br></td><td>  1 ms <br></td><td>  5 ms <br></td><td>  10-50 ms <br></td></tr></tbody></table></div><br>  <i>* La asignación de un índice de memoria mayor que la cantidad requerida condujo al almacenamiento en caché de algunos nodos (visitados con frecuencia), lo que redujo el retraso en la búsqueda.</i>  <i>No se usó caché interno para esto, solo herramientas internas del sistema operativo (kernel de Linux).</i> <br><br>  Cabe señalar que algunas de las optimizaciones mencionadas en el artículo no son aplicables para resolver el problema general de encontrar vecinos más cercanos con vectores descomponibles.  Sin embargo, son aplicables en cualquier situación en la que los elementos pueden generarse a partir de menos partes (como es el caso de las palabras y las consultas).  De lo contrario, aún puede usar Granne con los vectores de origen, solo requiere más memoria, como con otras bibliotecas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/479692/">https://habr.com/ru/post/479692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479682/index.html">Informe de uso de contenedores Sysdig 2019: nuevos Kubernetes y detalles de seguridad</a></li>
<li><a href="../479684/index.html">Cómo recopilar claves de baja frecuencia para SEO: 4 formas no triviales</a></li>
<li><a href="../479686/index.html">Tendencias clave en la externalización de TI después de 2020</a></li>
<li><a href="../479688/index.html">¿En qué países y ciudades ganan más los desarrolladores cuando se consideran los impuestos y el costo de vida?</a></li>
<li><a href="../479690/index.html">Zork y Z-Machine: cómo los desarrolladores transfirieron el juego de mainframes a computadoras hogareñas de 8 bits</a></li>
<li><a href="../479696/index.html">Algunas palabras sobre Alter Table, o cómo no hacerlo</a></li>
<li><a href="../479700/index.html">CIMON-2: (un) Doomsday, o cómo IBM Watson subió por encima de las nubes</a></li>
<li><a href="../479702/index.html">Tostadora, Mi círculo y Freelansim se convierten en parte de Habr</a></li>
<li><a href="../479704/index.html">Escalada de privilegios en el cliente EA Origin Windows (CVE-2019-19247 y CVE-2019-19248)</a></li>
<li><a href="../479708/index.html">Publicación no oficial sobre el cambio de marca de Habr + Competition</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>