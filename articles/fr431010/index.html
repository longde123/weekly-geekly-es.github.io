<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèΩ‚Äçü§ù‚Äçüßëüèª üë©üèΩ‚ÄçüöÄ üëèüèª La m√©moire de votre ordinateur est en retard toutes les 7,8 Œºs üïé ü§òüèª üíò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SDRAM DDR3 moderne. Source: BY-SA / 4.0 par Kjerish 

 Lors d'une r√©cente visite au Computer History Museum de Mountain View, un ancien √©chantillon de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La m√©moire de votre ordinateur est en retard toutes les 7,8 Œºs</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431010/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc7/f53/c6e/dc7f53c6eb17bfa58db7c138915bce84.jpg"></div><br>  <i><font color="gray">SDRAM DDR3 moderne.</font></i>  <i><font color="gray">Source: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BY-SA / 4.0 par Kjerish</a></font></i> <br><br>  Lors d'une r√©cente visite au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Computer History Museum</a> de Mountain View, un ancien √©chantillon de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">m√©moire en ferrite a</a> attir√© mon attention. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b2/d31/5c6/2b2d315c67b80adcd5f0b5bf4dd23e7a.jpg"></div><br>  <i><font color="gray">Source: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BY-SA / 3.0 par Konstantin Lanzet</a></font></i> <br><a name="habracut"></a><br>  Je suis rapidement arriv√© √† la conclusion que je n'ai aucune id√©e de la fa√ßon dont ces choses fonctionnent.  Les anneaux tournent-ils (non) et pourquoi trois fils passent-ils dans chaque anneau (je ne comprends toujours pas comment ils fonctionnent).  Plus important encore, j'ai r√©alis√© que j'avais tr√®s peu d'id√©e du fonctionnement de la RAM dynamique moderne! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fc/cb6/f41/7fccb6f418a426c7829b7e9bb1b5d3c3.png"></div><br>  <i><font color="gray">Source: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cycle de m√©moire d'Ulrich Drapper</a></font></i> <br><br>  J'√©tais particuli√®rement int√©ress√© par l'une des cons√©quences du fonctionnement de la RAM dynamique.  Il s'av√®re que chaque bit de donn√©es est stock√© par une charge (ou son absence) sur un minuscule condensateur dans la puce RAM.  Mais ces condensateurs perdent progressivement leur charge au fil du temps.  Pour √©viter la perte de donn√©es stock√©es, celles-ci doivent √™tre mises √† jour r√©guli√®rement pour restaurer la charge (le cas √©ch√©ant) √† son niveau d'origine.  Ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">processus de mise √† jour</a> implique la lecture de chaque bit, puis sa r√©√©criture.  Pendant cette ¬´mise √† jour¬ª, la m√©moire est occup√©e et ne peut pas effectuer d'op√©rations normales, telles que l'√©criture ou le stockage de bits. <br><br>  Cela m'a longtemps d√©rang√©, et je me suis demand√© ... est-il possible de constater un retard dans la mise √† jour au niveau du programme? <br><br><h1>  Base de formation pour la mise √† niveau de la RAM dynamique </h1><br>  Chaque module DIMM se compose de ¬´cellules¬ª et de ¬´lignes¬ª, de ¬´colonnes¬ª, de ¬´c√¥t√©s¬ª et / ou de ¬´rangs¬ª.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cette pr√©sentation</a> de l'Universit√© de l'Utah explique la nomenclature.  La configuration de la m√©moire de l'ordinateur peut √™tre v√©rifi√©e avec la <code>decode-dimms</code> .  Voici un exemple: <br><br><pre>  $ decode-dimms
 Taille 4096 MB
 Banques x rang√©es x colonnes x bits 8 x 15 x 10 x 64
 Rangs 2 </pre><br>  Nous n'avons pas besoin de comprendre l'ensemble du sch√©ma DDR DIMM, nous voulons comprendre le fonctionnement d'une seule cellule qui stocke un bit d'information.  Plus pr√©cis√©ment, nous ne sommes int√©ress√©s que par le processus de mise √† jour. <br><br>  Consid√©rez deux sources: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tutoriel de mise √† jour DRAM</a> de l'Universit√© de l'Utah </li><li>  Et l'excellente documentation de la puce gigabit de Micron: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Conception du TN-46-09 pour 1 Go DDR SDRAM¬ª</a> </li></ul><br>  Chaque bit de la m√©moire dynamique doit √™tre mis √† jour: cela se produit g√©n√©ralement toutes les 64 ms (la mise √† jour dite statique).  C'est une op√©ration assez co√ªteuse.  Pour √©viter un arr√™t majeur toutes les 64 ms, le processus est divis√© en 8192 op√©rations de mise √† jour plus petites.  Dans chacun d'eux, le contr√¥leur de m√©moire de l'ordinateur envoie des commandes de mise √† jour aux puces DRAM.  Apr√®s avoir re√ßu les instructions, la puce mettra √† jour 1/8192 cellules.  Si vous comptez, alors 64 ms / 8192 = 7812,5 ns ou 7,81 Œºs.  Cela signifie ce qui suit: <br><br><ul><li>  Une commande de mise √† jour est ex√©cut√©e toutes les 7812,5 ns.  Il s'appelle tREFI. </li><li>  Le processus de mise √† jour et de r√©cup√©ration prend un certain temps, de sorte que la puce peut √† nouveau effectuer des op√©rations de lecture et d'√©criture normales.  Le soi-disant tRFC est √©gal √† 75 ns ou 120 ns (comme dans la documentation Micron mentionn√©e). </li></ul><br>  Si la m√©moire est chaude (plus de 85 ¬∞ C), le temps de stockage des donn√©es en m√©moire diminue et le temps de mise √† jour statique est r√©duit de moiti√© √† 32 ms.  En cons√©quence, le tREFI chute √† 3906,25 ns. <br><br>  Une puce de m√©moire typique est occup√©e √† se mettre √† jour pendant une partie importante de sa dur√©e de vie: de 0,4% √† 5%.  De plus, les puces m√©moire sont responsables de la part non n√©gligeable de la consommation d'√©nergie d'un ordinateur typique, et la majeure partie de cette √©nergie est consacr√©e aux mises √† niveau. <br><br>  La puce m√©moire enti√®re est bloqu√©e lors de la mise √† jour.  C'est-√†-dire que chaque bit en m√©moire est verrouill√© pendant plus de 75 ns toutes les 7812 ns.  Mesurons-le. <br><br><h1>  Pr√©paration √† l'exp√©rience </h1><br>  Pour mesurer des op√©rations avec une pr√©cision en nanosecondes, vous avez besoin d'un cycle tr√®s serr√©, peut-√™tre en C. Cela ressemble √† ceci: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ...; i++) { <span class="hljs-comment"><span class="hljs-comment">//   . *(volatile int *) one_global_var; //   CPU.    _mm_clflush(one_global_var); //   ,     //    (25    160). // , - . asm volatile("mfence"); //     clock_gettime(CLOCK_MONOTONIC, &amp;ts); }</span></span></code> </pre> <br>  <a href="">Le code complet est disponible sur GitHub.</a> <br><br>  Le code est tr√®s simple.  Effectuez la lecture de la m√©moire.  Nous vidons les donn√©es du cache CPU.  Nous mesurons le temps. <br><br>  (Remarque: dans la <a href="">deuxi√®me exp√©rience,</a> j'ai essay√© d'utiliser MOVNTDQA pour charger des donn√©es, mais cela n√©cessite une page m√©moire sp√©ciale non-cache et des droits root). <br><br>  Sur mon ordinateur, le programme affiche les donn√©es suivantes: <br><br><pre>  # horodatage, dur√©e du cycle
 3101895733, 134
 3101895865, 132
 3101896002, 137
 3101896134, 132
 3101896268, 134
 3101896403, 135
 3101896762, 359
 3101896901, 139
 3101897038, 137 </pre><br>  Habituellement, un cycle d'une dur√©e d'environ 140 ns est obtenu, p√©riodiquement le temps passe √† environ 360 ns.  Parfois, des r√©sultats √©tranges apparaissent plus de 3200 ns. <br><br>  Malheureusement, les donn√©es sont trop bruyantes.  Il est tr√®s difficile de voir s'il y a un retard notable associ√© aux cycles de mise √† jour. <br><br><h1>  Transformation de Fourier rapide </h1><br>  √Ä un moment donn√©, il m'est apparu.  Puisque nous voulons trouver un √©v√©nement avec un intervalle fixe, nous pouvons soumettre des donn√©es √† l'algorithme FFT (transform√©e de Fourier rapide), qui d√©crypte les fr√©quences principales. <br><br>  Je ne suis pas le premier √† y penser: Mark Seaborn avec la fameuse vuln√©rabilit√© <a href="">Rowhammer a</a> mis en ≈ìuvre cette technique m√™me en 2015.  M√™me apr√®s avoir regard√© le code de Mark, mettre la FFT au travail √©tait plus difficile que ce √† quoi je m'attendais.  Mais √† la fin, j'ai rassembl√© toutes les pi√®ces. <br><br>  Vous devez d'abord pr√©parer les donn√©es.  La FFT n√©cessite une entr√©e avec un intervalle d'√©chantillonnage constant.  Nous voulons √©galement rogner les donn√©es pour r√©duire le bruit.  Par essais et erreurs, j'ai constat√© que le meilleur r√©sultat est obtenu apr√®s un traitement pr√©liminaire des donn√©es: <br><br><ul><li>  Les petites valeurs (moins de 1,8 en moyenne) d'it√©rations de boucle sont coup√©es, ignor√©es et remplac√©es par des z√©ros.  Nous ne voulons vraiment pas faire de bruit. </li><li>  Toutes les autres lectures sont remplac√©es par des unit√©s, car l'amplitude du retard caus√© par un certain bruit n'est vraiment pas importante pour nous. </li><li>  J'ai choisi un intervalle d'√©chantillonnage de 100 ns, mais n'importe quel nombre jusqu'√† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la fr√©quence de Nyquist (double fr√©quence attendue) fera l'affaire</a> . </li><li>  Les donn√©es doivent √™tre √©chantillonn√©es √† un moment fixe avant d'√™tre soumises √† la FFT.  Toutes les m√©thodes d'√©chantillonnage raisonnables fonctionnent bien, j'ai opt√© pour une interpolation lin√©aire de base. </li></ul><br>  L'algorithme est quelque chose comme ceci: <br><br><pre> <code class="cpp hljs">UNIT=<span class="hljs-number"><span class="hljs-number">100</span></span>ns A = [(timestamp, loop_duration),...] p = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> curr_ts in frange(fist_ts, last_ts, UNIT): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>(A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].timestamp &lt;= curr_ts &lt; A[p].timestamp): p += <span class="hljs-number"><span class="hljs-number">1</span></span> v1 = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> avg*<span class="hljs-number"><span class="hljs-number">1.8</span></span> &lt;= A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].duration &lt;= avg*<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> v2 = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> avg*<span class="hljs-number"><span class="hljs-number">1.8</span></span> &lt;= A[p].duration &lt;= avg*<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> v = estimate_linear(v1, v2, A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].timestamp, curr_ts, A[p].timestamp) B.append( v )</code> </pre> <br>  Lequel sur mes donn√©es produit un vecteur plut√¥t ennuyeux comme celui-ci: <br><br><pre>  [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...] </pre><br>  Cependant, le vecteur est assez grand, g√©n√©ralement environ 200 000 points de donn√©es.  Avec de telles donn√©es, vous pouvez utiliser FFT! <br><br><pre> <code class="cpp hljs">C = numpy.fft.fft(B) C = numpy.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(C) F = numpy.fft.fftfreq(len(B)) * (<span class="hljs-number"><span class="hljs-number">1000000000</span></span>/UNIT)</code> </pre> <br>  Assez simple, non?  Cela produit deux vecteurs: <br><br><ul><li>  C contient un nombre complexe de composantes de fr√©quence.  Nous ne nous int√©ressons pas aux nombres complexes, et vous pouvez les lisser avec la commande <code>abs()</code> . </li><li>  F contient des √©tiquettes, dont l'√©tendue de fr√©quence se situe √† quelle place du vecteur C. Nous normalisons l'exposant en hertz en multipliant par la fr√©quence d'√©chantillonnage du vecteur d'entr√©e. </li></ul><br>  Le r√©sultat peut √™tre trac√© sur un graphique: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/580/d99/6ad/580d996adeb168c27821b2efb11bac2c.png"><br><br>  Axe Y sans unit√©s, car nous avons normalis√© le temps de retard.  Malgr√© cela, les salves sont clairement visibles dans certaines gammes de fr√©quences fixes.  Examinons-les de plus pr√®s: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf2/d37/2ed/bf2d372ed5483d677e1d775b863c6b76.png"><br><br>  Nous voyons clairement les trois premiers pics.  Apr√®s un peu d'arithm√©tique inexpressive, incluant un filtrage de lecture au moins dix fois la moyenne, vous pouvez extraire les fr√©quences de base: <br><br><pre>  127850.0
 127900.0
 127950.0
 255700.0
 255750.0
 255800.0
 255850.0
 255900.0
 255950.0
 383600.0
 383650.0 </pre><br>  On consid√®re: 1000000000 (ns / s) / 127900 (Hz) = 7818,6 ns <br><br>  Hourra!  Le premier saut de fr√©quence est vraiment ce que nous recherchions, et il est vraiment en corr√©lation avec le temps de mise √† jour. <br><br>  Les pics restants √† 256 kHz, 384 kHz, 512 kHz sont les soi-disant harmoniques qui sont des multiples de notre fr√©quence de base de 128 kHz.  C'est l'effet secondaire pleinement attendu de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">application de la FFT √† quelque chose comme une onde carr√©e</a> . <br><br>  Pour faciliter les exp√©riences, nous avons fait une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version pour la ligne de commande</a> .  Vous pouvez ex√©cuter le code vous-m√™me.  Voici un exemple de lancement sur mon serveur: <br><br><pre>  ~ / 2018-11-memory-refresh $ make
 gcc -msse4.1 -ggdb -O3 -Mur -Wextra mesure-dram.c -o mesure-dram
 ./measure-dram |  python3 ./analyze-dram.py
 [*] V√©rification de l'ASLR: main = 0x555555554890 stack = 0x7fffffefe2ec
 [] Fait amusant.  J'ai fait 40663553 clock_gettime () par seconde
 [*] Mesure du temps MOVQ + CLFLUSH.  Ex√©cution d'it√©rations 131072.
 [*] √âcriture des donn√©es
 [*] Donn√©es d'entr√©e: min = 117 moyenne = 176 moyenne = 167 max = 8172 √©l√©ments = 131072
 [*] Plage de coupure 212-inf
 [] 127849 √©l√©ments en dessous du seuil, 0 √©l√©ments au-dessus du seuil, 3223 √©l√©ments non nuls
 [*] Ex√©cution de FFT
 [*] La fr√©quence maximale au-dessus de 2 kHz en dessous de 250 kHz a une magnitude de 7716
 [+] Les pics de fr√©quence sup√©rieurs √† 2 kHz sont √†:
 127906Hz 7716
 255813Hz 7947
 383720Hz 7460
 511626Hz 7141 </pre><br>  Je dois admettre que le code n'est pas compl√®tement stable.  En cas de probl√®me, il est recommand√© de d√©sactiver Turbo Boost, la mise √† l'√©chelle de la fr√©quence du processeur et l'optimisation pour les performances. <br><br><h1>  Conclusion </h1><br>  Il y a deux conclusions principales de ce travail. <br><br>  Nous avons vu que les donn√©es de bas niveau sont assez difficiles √† analyser et qu'elles semblent plut√¥t bruyantes.  Au lieu d'√©valuer √† l'≈ìil nu, vous pouvez toujours utiliser la bonne vieille FFT.  Dans la pr√©paration des donn√©es, il est n√©cessaire, en un sens, de faire des voeux pieux. <br><br>  Plus important encore, nous avons montr√© qu'il est souvent possible de mesurer le comportement mat√©riel subtil √† partir d'un processus simple dans l'espace utilisateur.  Ce type de r√©flexion a conduit √† la d√©couverte de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vuln√©rabilit√© originale de Rowhammer</a> , elle a √©t√© impl√©ment√©e dans les attaques Meltdown / Spectre et a de nouveau √©t√© montr√©e dans la r√©cente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©incarnation de Rowhammer pour la m√©moire ECC</a> . <br><br>  Beaucoup reste au-del√† de la port√©e de cet article.  Nous avons √† peine abord√© le fonctionnement interne du sous-syst√®me m√©moire.  Pour plus de lecture, je recommande: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mappage du cache L3 sur les processeurs Sandy Bridge</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment une adresse physique est mapp√©e aux lignes et aux banques dans la DRAM</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hannu Hartikainen a pirat√© la SO-DIMM DDR3 et l'a fait fonctionner ... plus lentement</a> </li></ul><br>  Enfin, voici une bonne description de l'ancienne m√©moire ferrite: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Explication de la m√©moire de ferrite PDP-11 de l'Universit√© de Sydney</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431010/">https://habr.com/ru/post/fr431010/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430996/index.html">Le bug insaisissable LittleBigPlanet</a></li>
<li><a href="../fr430998/index.html">Version XMPP (Jabber) du serveur Prosody 0.11.0</a></li>
<li><a href="../fr431000/index.html">Syndrome de plomberie: r√®gles de code h√©rit√©es pour les tests</a></li>
<li><a href="../fr431004/index.html">Le syst√®me chinois de reconnaissance faciale a consid√©r√© l'image d'une personne dans un bus comme un contrevenant</a></li>
<li><a href="../fr431006/index.html">InSight se pr√©pare √† atterrir sur Mars</a></li>
<li><a href="../fr431012/index.html">Cr√©er un lecteur de livre √©lectronique √† l'aide de PDFKit sur Swift</a></li>
<li><a href="../fr431014/index.html">Flexbox Infographie de la technologie</a></li>
<li><a href="../fr431016/index.html">Les √âtats-Unis demandent √† leurs partenaires d'abandonner l'utilisation de l'√©quipement Huawei</a></li>
<li><a href="../fr431018/index.html">Mettre en place un syst√®me CRM? Enlevez les lunettes roses</a></li>
<li><a href="../fr431020/index.html">Rapport du Club de Rome 2018, chapitre 1.7 ¬´Croissance d√©mographique et urbanisation non durables¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>