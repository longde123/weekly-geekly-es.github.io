<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏽‍🤝‍🧑🏻 👩🏽‍🚀 👏🏻 La mémoire de votre ordinateur est en retard toutes les 7,8 μs 🕎 🤘🏻 💘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SDRAM DDR3 moderne. Source: BY-SA / 4.0 par Kjerish 

 Lors d'une récente visite au Computer History Museum de Mountain View, un ancien échantillon de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La mémoire de votre ordinateur est en retard toutes les 7,8 μs</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431010/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc7/f53/c6e/dc7f53c6eb17bfa58db7c138915bce84.jpg"></div><br>  <i><font color="gray">SDRAM DDR3 moderne.</font></i>  <i><font color="gray">Source: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BY-SA / 4.0 par Kjerish</a></font></i> <br><br>  Lors d'une récente visite au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Computer History Museum</a> de Mountain View, un ancien échantillon de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mémoire en ferrite a</a> attiré mon attention. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b2/d31/5c6/2b2d315c67b80adcd5f0b5bf4dd23e7a.jpg"></div><br>  <i><font color="gray">Source: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BY-SA / 3.0 par Konstantin Lanzet</a></font></i> <br><a name="habracut"></a><br>  Je suis rapidement arrivé à la conclusion que je n'ai aucune idée de la façon dont ces choses fonctionnent.  Les anneaux tournent-ils (non) et pourquoi trois fils passent-ils dans chaque anneau (je ne comprends toujours pas comment ils fonctionnent).  Plus important encore, j'ai réalisé que j'avais très peu d'idée du fonctionnement de la RAM dynamique moderne! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fc/cb6/f41/7fccb6f418a426c7829b7e9bb1b5d3c3.png"></div><br>  <i><font color="gray">Source: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cycle de mémoire d'Ulrich Drapper</a></font></i> <br><br>  J'étais particulièrement intéressé par l'une des conséquences du fonctionnement de la RAM dynamique.  Il s'avère que chaque bit de données est stocké par une charge (ou son absence) sur un minuscule condensateur dans la puce RAM.  Mais ces condensateurs perdent progressivement leur charge au fil du temps.  Pour éviter la perte de données stockées, celles-ci doivent être mises à jour régulièrement pour restaurer la charge (le cas échéant) à son niveau d'origine.  Ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">processus de mise à jour</a> implique la lecture de chaque bit, puis sa réécriture.  Pendant cette «mise à jour», la mémoire est occupée et ne peut pas effectuer d'opérations normales, telles que l'écriture ou le stockage de bits. <br><br>  Cela m'a longtemps dérangé, et je me suis demandé ... est-il possible de constater un retard dans la mise à jour au niveau du programme? <br><br><h1>  Base de formation pour la mise à niveau de la RAM dynamique </h1><br>  Chaque module DIMM se compose de «cellules» et de «lignes», de «colonnes», de «côtés» et / ou de «rangs».  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cette présentation</a> de l'Université de l'Utah explique la nomenclature.  La configuration de la mémoire de l'ordinateur peut être vérifiée avec la <code>decode-dimms</code> .  Voici un exemple: <br><br><pre>  $ decode-dimms
 Taille 4096 MB
 Banques x rangées x colonnes x bits 8 x 15 x 10 x 64
 Rangs 2 </pre><br>  Nous n'avons pas besoin de comprendre l'ensemble du schéma DDR DIMM, nous voulons comprendre le fonctionnement d'une seule cellule qui stocke un bit d'information.  Plus précisément, nous ne sommes intéressés que par le processus de mise à jour. <br><br>  Considérez deux sources: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tutoriel de mise à jour DRAM</a> de l'Université de l'Utah </li><li>  Et l'excellente documentation de la puce gigabit de Micron: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Conception du TN-46-09 pour 1 Go DDR SDRAM»</a> </li></ul><br>  Chaque bit de la mémoire dynamique doit être mis à jour: cela se produit généralement toutes les 64 ms (la mise à jour dite statique).  C'est une opération assez coûteuse.  Pour éviter un arrêt majeur toutes les 64 ms, le processus est divisé en 8192 opérations de mise à jour plus petites.  Dans chacun d'eux, le contrôleur de mémoire de l'ordinateur envoie des commandes de mise à jour aux puces DRAM.  Après avoir reçu les instructions, la puce mettra à jour 1/8192 cellules.  Si vous comptez, alors 64 ms / 8192 = 7812,5 ns ou 7,81 μs.  Cela signifie ce qui suit: <br><br><ul><li>  Une commande de mise à jour est exécutée toutes les 7812,5 ns.  Il s'appelle tREFI. </li><li>  Le processus de mise à jour et de récupération prend un certain temps, de sorte que la puce peut à nouveau effectuer des opérations de lecture et d'écriture normales.  Le soi-disant tRFC est égal à 75 ns ou 120 ns (comme dans la documentation Micron mentionnée). </li></ul><br>  Si la mémoire est chaude (plus de 85 ° C), le temps de stockage des données en mémoire diminue et le temps de mise à jour statique est réduit de moitié à 32 ms.  En conséquence, le tREFI chute à 3906,25 ns. <br><br>  Une puce de mémoire typique est occupée à se mettre à jour pendant une partie importante de sa durée de vie: de 0,4% à 5%.  De plus, les puces mémoire sont responsables de la part non négligeable de la consommation d'énergie d'un ordinateur typique, et la majeure partie de cette énergie est consacrée aux mises à niveau. <br><br>  La puce mémoire entière est bloquée lors de la mise à jour.  C'est-à-dire que chaque bit en mémoire est verrouillé pendant plus de 75 ns toutes les 7812 ns.  Mesurons-le. <br><br><h1>  Préparation à l'expérience </h1><br>  Pour mesurer des opérations avec une précision en nanosecondes, vous avez besoin d'un cycle très serré, peut-être en C. Cela ressemble à ceci: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ...; i++) { <span class="hljs-comment"><span class="hljs-comment">//   . *(volatile int *) one_global_var; //   CPU.    _mm_clflush(one_global_var); //   ,     //    (25    160). // , - . asm volatile("mfence"); //     clock_gettime(CLOCK_MONOTONIC, &amp;ts); }</span></span></code> </pre> <br>  <a href="">Le code complet est disponible sur GitHub.</a> <br><br>  Le code est très simple.  Effectuez la lecture de la mémoire.  Nous vidons les données du cache CPU.  Nous mesurons le temps. <br><br>  (Remarque: dans la <a href="">deuxième expérience,</a> j'ai essayé d'utiliser MOVNTDQA pour charger des données, mais cela nécessite une page mémoire spéciale non-cache et des droits root). <br><br>  Sur mon ordinateur, le programme affiche les données suivantes: <br><br><pre>  # horodatage, durée du cycle
 3101895733, 134
 3101895865, 132
 3101896002, 137
 3101896134, 132
 3101896268, 134
 3101896403, 135
 3101896762, 359
 3101896901, 139
 3101897038, 137 </pre><br>  Habituellement, un cycle d'une durée d'environ 140 ns est obtenu, périodiquement le temps passe à environ 360 ns.  Parfois, des résultats étranges apparaissent plus de 3200 ns. <br><br>  Malheureusement, les données sont trop bruyantes.  Il est très difficile de voir s'il y a un retard notable associé aux cycles de mise à jour. <br><br><h1>  Transformation de Fourier rapide </h1><br>  À un moment donné, il m'est apparu.  Puisque nous voulons trouver un événement avec un intervalle fixe, nous pouvons soumettre des données à l'algorithme FFT (transformée de Fourier rapide), qui décrypte les fréquences principales. <br><br>  Je ne suis pas le premier à y penser: Mark Seaborn avec la fameuse vulnérabilité <a href="">Rowhammer a</a> mis en œuvre cette technique même en 2015.  Même après avoir regardé le code de Mark, mettre la FFT au travail était plus difficile que ce à quoi je m'attendais.  Mais à la fin, j'ai rassemblé toutes les pièces. <br><br>  Vous devez d'abord préparer les données.  La FFT nécessite une entrée avec un intervalle d'échantillonnage constant.  Nous voulons également rogner les données pour réduire le bruit.  Par essais et erreurs, j'ai constaté que le meilleur résultat est obtenu après un traitement préliminaire des données: <br><br><ul><li>  Les petites valeurs (moins de 1,8 en moyenne) d'itérations de boucle sont coupées, ignorées et remplacées par des zéros.  Nous ne voulons vraiment pas faire de bruit. </li><li>  Toutes les autres lectures sont remplacées par des unités, car l'amplitude du retard causé par un certain bruit n'est vraiment pas importante pour nous. </li><li>  J'ai choisi un intervalle d'échantillonnage de 100 ns, mais n'importe quel nombre jusqu'à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la fréquence de Nyquist (double fréquence attendue) fera l'affaire</a> . </li><li>  Les données doivent être échantillonnées à un moment fixe avant d'être soumises à la FFT.  Toutes les méthodes d'échantillonnage raisonnables fonctionnent bien, j'ai opté pour une interpolation linéaire de base. </li></ul><br>  L'algorithme est quelque chose comme ceci: <br><br><pre> <code class="cpp hljs">UNIT=<span class="hljs-number"><span class="hljs-number">100</span></span>ns A = [(timestamp, loop_duration),...] p = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> curr_ts in frange(fist_ts, last_ts, UNIT): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>(A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].timestamp &lt;= curr_ts &lt; A[p].timestamp): p += <span class="hljs-number"><span class="hljs-number">1</span></span> v1 = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> avg*<span class="hljs-number"><span class="hljs-number">1.8</span></span> &lt;= A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].duration &lt;= avg*<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> v2 = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> avg*<span class="hljs-number"><span class="hljs-number">1.8</span></span> &lt;= A[p].duration &lt;= avg*<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> v = estimate_linear(v1, v2, A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].timestamp, curr_ts, A[p].timestamp) B.append( v )</code> </pre> <br>  Lequel sur mes données produit un vecteur plutôt ennuyeux comme celui-ci: <br><br><pre>  [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...] </pre><br>  Cependant, le vecteur est assez grand, généralement environ 200 000 points de données.  Avec de telles données, vous pouvez utiliser FFT! <br><br><pre> <code class="cpp hljs">C = numpy.fft.fft(B) C = numpy.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(C) F = numpy.fft.fftfreq(len(B)) * (<span class="hljs-number"><span class="hljs-number">1000000000</span></span>/UNIT)</code> </pre> <br>  Assez simple, non?  Cela produit deux vecteurs: <br><br><ul><li>  C contient un nombre complexe de composantes de fréquence.  Nous ne nous intéressons pas aux nombres complexes, et vous pouvez les lisser avec la commande <code>abs()</code> . </li><li>  F contient des étiquettes, dont l'étendue de fréquence se situe à quelle place du vecteur C. Nous normalisons l'exposant en hertz en multipliant par la fréquence d'échantillonnage du vecteur d'entrée. </li></ul><br>  Le résultat peut être tracé sur un graphique: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/580/d99/6ad/580d996adeb168c27821b2efb11bac2c.png"><br><br>  Axe Y sans unités, car nous avons normalisé le temps de retard.  Malgré cela, les salves sont clairement visibles dans certaines gammes de fréquences fixes.  Examinons-les de plus près: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf2/d37/2ed/bf2d372ed5483d677e1d775b863c6b76.png"><br><br>  Nous voyons clairement les trois premiers pics.  Après un peu d'arithmétique inexpressive, incluant un filtrage de lecture au moins dix fois la moyenne, vous pouvez extraire les fréquences de base: <br><br><pre>  127850.0
 127900.0
 127950.0
 255700.0
 255750.0
 255800.0
 255850.0
 255900.0
 255950.0
 383600.0
 383650.0 </pre><br>  On considère: 1000000000 (ns / s) / 127900 (Hz) = 7818,6 ns <br><br>  Hourra!  Le premier saut de fréquence est vraiment ce que nous recherchions, et il est vraiment en corrélation avec le temps de mise à jour. <br><br>  Les pics restants à 256 kHz, 384 kHz, 512 kHz sont les soi-disant harmoniques qui sont des multiples de notre fréquence de base de 128 kHz.  C'est l'effet secondaire pleinement attendu de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">application de la FFT à quelque chose comme une onde carrée</a> . <br><br>  Pour faciliter les expériences, nous avons fait une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version pour la ligne de commande</a> .  Vous pouvez exécuter le code vous-même.  Voici un exemple de lancement sur mon serveur: <br><br><pre>  ~ / 2018-11-memory-refresh $ make
 gcc -msse4.1 -ggdb -O3 -Mur -Wextra mesure-dram.c -o mesure-dram
 ./measure-dram |  python3 ./analyze-dram.py
 [*] Vérification de l'ASLR: main = 0x555555554890 stack = 0x7fffffefe2ec
 [] Fait amusant.  J'ai fait 40663553 clock_gettime () par seconde
 [*] Mesure du temps MOVQ + CLFLUSH.  Exécution d'itérations 131072.
 [*] Écriture des données
 [*] Données d'entrée: min = 117 moyenne = 176 moyenne = 167 max = 8172 éléments = 131072
 [*] Plage de coupure 212-inf
 [] 127849 éléments en dessous du seuil, 0 éléments au-dessus du seuil, 3223 éléments non nuls
 [*] Exécution de FFT
 [*] La fréquence maximale au-dessus de 2 kHz en dessous de 250 kHz a une magnitude de 7716
 [+] Les pics de fréquence supérieurs à 2 kHz sont à:
 127906Hz 7716
 255813Hz 7947
 383720Hz 7460
 511626Hz 7141 </pre><br>  Je dois admettre que le code n'est pas complètement stable.  En cas de problème, il est recommandé de désactiver Turbo Boost, la mise à l'échelle de la fréquence du processeur et l'optimisation pour les performances. <br><br><h1>  Conclusion </h1><br>  Il y a deux conclusions principales de ce travail. <br><br>  Nous avons vu que les données de bas niveau sont assez difficiles à analyser et qu'elles semblent plutôt bruyantes.  Au lieu d'évaluer à l'œil nu, vous pouvez toujours utiliser la bonne vieille FFT.  Dans la préparation des données, il est nécessaire, en un sens, de faire des voeux pieux. <br><br>  Plus important encore, nous avons montré qu'il est souvent possible de mesurer le comportement matériel subtil à partir d'un processus simple dans l'espace utilisateur.  Ce type de réflexion a conduit à la découverte de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vulnérabilité originale de Rowhammer</a> , elle a été implémentée dans les attaques Meltdown / Spectre et a de nouveau été montrée dans la récente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réincarnation de Rowhammer pour la mémoire ECC</a> . <br><br>  Beaucoup reste au-delà de la portée de cet article.  Nous avons à peine abordé le fonctionnement interne du sous-système mémoire.  Pour plus de lecture, je recommande: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mappage du cache L3 sur les processeurs Sandy Bridge</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment une adresse physique est mappée aux lignes et aux banques dans la DRAM</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hannu Hartikainen a piraté la SO-DIMM DDR3 et l'a fait fonctionner ... plus lentement</a> </li></ul><br>  Enfin, voici une bonne description de l'ancienne mémoire ferrite: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Explication de la mémoire de ferrite PDP-11 de l'Université de Sydney</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431010/">https://habr.com/ru/post/fr431010/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430996/index.html">Le bug insaisissable LittleBigPlanet</a></li>
<li><a href="../fr430998/index.html">Version XMPP (Jabber) du serveur Prosody 0.11.0</a></li>
<li><a href="../fr431000/index.html">Syndrome de plomberie: règles de code héritées pour les tests</a></li>
<li><a href="../fr431004/index.html">Le système chinois de reconnaissance faciale a considéré l'image d'une personne dans un bus comme un contrevenant</a></li>
<li><a href="../fr431006/index.html">InSight se prépare à atterrir sur Mars</a></li>
<li><a href="../fr431012/index.html">Créer un lecteur de livre électronique à l'aide de PDFKit sur Swift</a></li>
<li><a href="../fr431014/index.html">Flexbox Infographie de la technologie</a></li>
<li><a href="../fr431016/index.html">Les États-Unis demandent à leurs partenaires d'abandonner l'utilisation de l'équipement Huawei</a></li>
<li><a href="../fr431018/index.html">Mettre en place un système CRM? Enlevez les lunettes roses</a></li>
<li><a href="../fr431020/index.html">Rapport du Club de Rome 2018, chapitre 1.7 «Croissance démographique et urbanisation non durables»</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>