<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚ÄçüöÄ üîî üìú Problemas de patr√≥n de coordinador y qu√© tiene que ver RouteComposer con √©l üë©üèª‚ÄçüöÄ üíè üñ≤Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Contin√∫o la serie de art√≠culos sobre la biblioteca RouteComposer que utilizamos, y hoy quiero hablar sobre el patr√≥n Coordinador. Me pidieron que escr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Problemas de patr√≥n de coordinador y qu√© tiene que ver RouteComposer con √©l</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446550/"><p>  Contin√∫o la serie de art√≠culos sobre la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RouteComposer</a> que utilizamos, y hoy quiero hablar sobre el patr√≥n Coordinador.  Me pidieron que escribiera este art√≠culo en una discusi√≥n de uno de los art√≠culos sobre el patr√≥n: el coordinador aqu√≠ en Habr√©. </p><br><p>  El patr√≥n Coordinator, introducido hace poco, est√° ganando cada vez m√°s popularidad entre los desarrolladores de iOS y, en general, est√° claro por qu√©.  Porque las herramientas <strong>listas</strong> para <strong>usar</strong> que <strong>UIKit</strong> proporciona no son un desastre universal. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/304/47d/bd8/30447dbd8d2a0a39a34f7f6946a02383.png" alt="imagen"></p><a name="habracut"></a><br><p>  Ya he planteado la cuesti√≥n de la fragmentaci√≥n de la forma en que compongo la vista de los controladores en la pila, y para evitar la repetici√≥n, puede leer sobre esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><p> Seamos honestos.  En alg√∫n momento, Epole se dio cuenta de que al colocar los controladores en el centro de desarrollo de aplicaciones, no ofrec√≠a ninguna forma sensata de crear o transferir datos entre ellos y, habiendo confiado la soluci√≥n a este problema a los desarrolladores, se completaba autom√°ticamente desde Xcode, y quiz√°s a los desarrolladores de UISearchConnroller en alg√∫n momento nos present√≥ storyboards y segues.  Luego, Epolus se dio cuenta de que ella escribi√≥ aplicaciones que constaban de 2 pantallas solo para ella, y en la siguiente iteraci√≥n ofreci√≥ la oportunidad de dividir los guiones gr√°ficos en varios componentes, ya que Xcode comenz√≥ a fallar cuando el gui√≥n gr√°fico alcanz√≥ cierto tama√±o.  Los segmentos han cambiado junto con este concepto, en varias iteraciones que no son muy compatibles entre s√≠.  Su soporte est√° estrechamente <code>UIViewController</code> clase masiva <code>UIViewController</code> y, al final, obtuvimos lo que obtuvimos.  Aqu√≠ esta: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> segue.identifier == <span class="hljs-string"><span class="hljs-string">"showDetail"</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> indexPath = tableView.indexPathForSelectedRow { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> object = objects[indexPath.row] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSDate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> controller = (segue.destination <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>).topViewController <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">DetailViewController</span></span> controller.detailItem = object controller.navigationItem.leftBarButtonItem = splitViewController?.displayModeButtonItem controller.navigationItem.leftItemsSupplementBackButton = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } }</code> </pre> <br><p>  La cantidad de Tycastcasts forzados en este bloque de c√≥digo es sorprendente, al igual que las constantes de cadena en los propios guiones gr√°ficos, para rastrear qu√© Xcode no ofrece ning√∫n medio.  Y el m√°s m√≠nimo deseo de cambiar algo en el proceso de navegaci√≥n le permitir√° compilar el proyecto sin ning√∫n esfuerzo y se bloquear√° con una explosi√≥n en tiempo de ejecuci√≥n sin la m√°s m√≠nima advertencia de Xcode.  Aqu√≠ hay un WYSIWYG al final que result√≥.  Lo que ves es lo que obtienes. </p><br><p>  Puede discutir durante mucho tiempo sobre los encantos de estas flechas grises en los guiones gr√°ficos que supuestamente muestran a alguien las conexiones entre las pantallas, pero, como lo ha demostrado mi pr√°ctica, entrevist√© intencionalmente a varios desarrolladores familiares de diferentes compa√±√≠as, tan pronto como el proyecto creci√≥ m√°s all√° de 5-6 pantallas, la gente intent√≥ encontr√© una soluci√≥n m√°s confiable y finalmente comenc√© a mantener la estructura de la pila de controladores de vista en mi cabeza.  Y si se agreg√≥ soporte para iPad y otros modelos de navegaci√≥n o soporte para empujes, entonces todo fue triste all√≠. </p><br><p>  Desde entonces, se han realizado varios intentos para resolver este problema, algunos de los cuales resultaron en marcos separados, algunos en patrones arquitect√≥nicos separados, ya que la creaci√≥n de controladores de vista dentro del controlador de vista hizo que este c√≥digo masivo y torpe fuera a√∫n m√°s. </p><br><p>  Volvamos al patr√≥n Coordinador.  Por razones obvias, no encontrar√° su descripci√≥n en Wikipedia porque no es un patr√≥n de programaci√≥n / dise√±o est√°ndar.  M√°s bien, es una especie de abstracci√≥n, que sugiere esconder bajo el cap√≥ todo este c√≥digo "feo" para crear e insertar un nuevo giro de controlador en la pila, guardar enlaces en el contenedor de controladores y enviar datos entre controladores.  El art√≠culo m√°s adecuado que describe este proceso llamar√≠a un art√≠culo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">raywenderlich.com</a> .  Comienza a hacerse popular despu√©s de la conferencia NSSpain de 2015, cuando se le inform√≥ al p√∫blico en general.  Con m√°s detalle, lo que se dijo se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><p>  Describir√© brevemente en qu√© consiste antes de continuar. </p><br><p>  El patr√≥n Coordinador en todas las interpretaciones se ajusta aproximadamente a esta imagen: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/554/4bb/f95/5544bbf95415d233060a7e4d515ff58d.png"></p><br><p>  Es decir, el coordinador es un protocolo </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> }</code> </pre> <br><p>  Y se supone que todo el c√≥digo feo est√° oculto en la funci√≥n de <code>start</code> .  El coordinador, adem√°s, puede tener enlaces con coordinadores secundarios, es decir, tienen cierta capacidad de composici√≥n y, por ejemplo, puede reemplazar una implementaci√≥n por otra.  Es decir, suena bastante elegante. </p><br><p>  Sin embargo, las locuras comienzan bastante pronto: </p><br><ol><li>  Algunas implementaciones proponen convertir el Coordinador de un cierto patr√≥n generador en algo m√°s razonable, observar la pila de controladores y <em>convertirlo en un delegado del contenedor</em> , por ejemplo, <code>UINavigationController</code> , para procesar haciendo clic en el bot√≥n Atr√°s o deslizar hacia atr√°s y eliminar el coordinador secundario.  Por razones naturales, solo un objeto puede ser un delegado, lo que limita el control del contenedor en s√≠ y conduce al hecho de que esta l√≥gica recae en el coordinador o crea la necesidad de delegar esta l√≥gica a alguien m√°s abajo en la lista. </li><li>  A menudo, la l√≥gica para crear el siguiente controlador <em>depende de la l√≥gica empresarial</em> .  Por ejemplo, para ir a la siguiente pantalla, el usuario debe iniciar sesi√≥n en el sistema.  Claramente, este es un proceso asincr√≥nico, que incluye generar una pantalla intermedia con el formulario de inicio de sesi√≥n, el proceso de inicio de sesi√≥n en s√≠ puede finalizar con √©xito o no.  Para evitar transformar el Coordinador en un Coordinador masivo (similar al Controlador de vista masiva), necesitamos descomposici√≥n.  Es decir, de hecho, necesita crear un Coordinador Coordinador. </li><li>  Otro problema que enfrentan los coordinadores es que son esencialmente envoltorios para controladores de vista de contenedor como <code>UINavigationController</code> , <code>UITabBarController</code> etc.  Y alguien deber√≠a proporcionar <em>enlaces a estos controladores</em> .  Si con los coordinadores secundarios todo es a√∫n menos claro, entonces con los coordinadores iniciales de la cadena, no todo es tan simple.  Adem√°s, al cambiar la navegaci√≥n, por ejemplo para la prueba A / B, la refactorizaci√≥n y la adaptaci√≥n de dichos coordinadores resultan en un dolor de cabeza por separado.  Especialmente si el tipo de contenedor cambia. </li><li>  Todo esto se vuelve a√∫n m√°s complicado cuando la aplicaci√≥n comienza a admitir <em>eventos externos</em> que generan controladores de vista.  Como notificaciones push o enlaces universales (el usuario hace clic en el enlace de la carta y contin√∫a en la pantalla de la aplicaci√≥n correspondiente).  Aqu√≠ surgen otras incertidumbres para las cuales el patr√≥n Coordinador no tiene una respuesta exacta.  Debe saber exactamente en qu√© pantalla se encuentra actualmente el usuario para mostrarle la siguiente pantalla solicitada por un evento externo. <br>  El ejemplo m√°s simple es una aplicaci√≥n de chat que consta de 3 pantallas: una lista de chat, el chat en s√≠ que se introduce en la navegaci√≥n del controlador de la lista de chat y la pantalla de configuraci√≥n que se muestra modalmente.  El usuario puede estar en una de estas pantallas cuando recibe una notificaci√≥n push y toca en ella.  Y aqu√≠ comienza la incertidumbre, si √©l est√° en la lista de chat, debe iniciar un chat con este usuario espec√≠fico, si ya est√° en el chat, entonces debe cambiarlo, y si ya est√° en el chat con este usuario, no haga nada y actualice, si el usuario est√° activado pantalla de configuraci√≥n: aparentemente necesita cerrar y seguir los pasos anteriores.  ¬øO tal vez no cerrar y simplemente mostrar el chat modalmente en la configuraci√≥n?  ¬øY si la configuraci√≥n est√° en otra pesta√±a, y no modal?  Estos <code>if/else</code> comienzan se extienden sobre los coordinadores o van a otro Mega-Coordinador en forma de un espagueti.  Adem√°s, se trata de iteraciones activas en la pila de vistas de los controladores y un intento de determinar d√≥nde est√° el usuario en este momento, o un intento de construir alg√∫n tipo de aplicaci√≥n que monitoree su estado, pero esta no es una tarea f√°cil, solo en funci√≥n de la naturaleza de la pila de controladores de vista. </li><li>  Y la guinda del pastel son <em>las fallas de UIKit</em> .  Un ejemplo trivial: un <code>UITabBarController</code> con un <code>UINavigationController</code> en la segunda pesta√±a con alg√∫n otro <code>UIViewController</code> .  El usuario en la primera pesta√±a causa un determinado evento que requiere cambiar la pesta√±a y <code>UINavigationController</code> otro controlador de vista a su <code>UINavigationController</code> .  Todo esto debe hacerse exactamente en esa secuencia.  Si el usuario nunca abri√≥ una segunda pesta√±a antes de esto y no se llam√≥ a <code>viewDidLoad</code> en el <code>viewDidLoad</code> el m√©todo <code>push</code> no funcionar√°, dejando solo un mensaje indistinto en la consola.  Es decir, los coordinadores no pueden simplemente convertirse en oyentes de eventos en este ejemplo, sino que deben trabajar en una secuencia determinada.  Entonces deben tener conocimiento el uno del otro.  Y esto ya contradice la primera declaraci√≥n del patr√≥n Coordinador, que los coordinadores no saben nada sobre los coordinadores generadores y est√°n conectados solo con los hijos.  Y tambi√©n limita su intercambiabilidad. </li></ol><br><p>  Esta lista puede continuar, pero en general est√° claro que el patr√≥n Coordinador es una soluci√≥n bastante limitada y poco escalable.  Si lo miras sin gafas de color rosa, entonces es una forma de descomponer parte de la l√≥gica, que generalmente se escribe dentro de los <code>UIViewController</code> masivos, en otra clase.  Todos los intentos de hacerlo m√°s que una f√°brica generativa e introducir otra l√≥gica all√≠ no terminan bien. </p><br><p>  Vale la pena se√±alar que hay bibliotecas basadas en este patr√≥n, que, de una forma u otra, permiten mitigar parcialmente las desventajas anteriores.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mencionar√≠a XCoordinator</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RxFlow</a> . </p><br><h2 id="chto-sdelali-my">  Que hemos hecho </h2><br><p>  Despu√©s de haber jugado en el proyecto que obtuvimos de otro equipo de apoyo y desarrollo, con los coordinadores y su <em>enrutador</em> simplificado de "bisabuela" en el enfoque arquitect√≥nico <em>VIPER</em> , volvimos al enfoque que funcion√≥ bien en el gran proyecto anterior de nuestra empresa.  Este enfoque no tiene nombre.  Se encuentra en la superficie.  Cuando ten√≠amos tiempo libre, se compil√≥ en una biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RouteComposer</a> separada que reemplaz√≥ por completo a los coordinadores y demostr√≥ ser m√°s flexible. </p><br><p>  ¬øCu√°l es este enfoque?  En eso, para confiar en la pila (√°rbol), giro los controladores tal como est√°n.  Para no crear entidades innecesarias que necesitan ser monitoreadas.  No guarde ni rastree las condiciones. </p><br><p>  Echemos un vistazo <em>m√°s de</em> cerca a las entidades <em>UIKit</em> e intentemos averiguar qu√© tenemos en el resultado final y con qu√© podemos trabajar: </p><br><ol><li>  <strong>La pila del controlador</strong> es un √°rbol.  Hay un controlador de vista ra√≠z que tiene controladores de vista secundarios.  Los controladores de vista presentados modalmente son un caso especial de los controladores de vista secundarios, ya que tambi√©n tienen un enlace con el controlador de vista generado.  Todo est√° disponible fuera de la caja. </li><li>  Necesito crear entidades de controladores.  Todos tienen constructores diferentes; se pueden crear usando archivos Xib o Storyboards.  Tienen diferentes par√°metros de entrada.  Pero est√°n unidos porque necesitan ser creados.  Entonces, aqu√≠ podemos usar el patr√≥n <strong>Factory</strong> , que sabe c√≥mo crear el controlador de vista deseado.  Cada f√°brica es f√°cil de cubrir con exhaustivas pruebas unitarias y es independiente de otras. </li><li>  Dividimos los controladores de vista en 2 clases: 1. Simplemente vea los controladores, 2. <strong>Controladores de vista de contenedor (Controlador de vista de contenedor)</strong> .  Los controladores de vista de contenedor difieren de los ordinarios en que pueden contener controladores de vista secundarios, tambi√©n contenedores o simples.  Dichos controladores de vista est√°n disponibles de <code>UINavigationController</code> : <code>UINavigationController</code> , <code>UINavigationController</code> , etc., pero tambi√©n pueden ser creados por el usuario.  Si lo ignoramos, podemos encontrar las siguientes propiedades en todos los contenedores: 1. Tienen una lista de todos los controladores que contienen.  2. Uno o m√°s controladores est√°n actualmente visibles.  3. Se les puede pedir que hagan visible uno de estos controladores.  Esto es todo lo que pueden <em>hacer los</em> controladores <em>UIKit</em> .  Simplemente tienen diferentes m√©todos para esto.  Pero solo hay 3 tareas. </li><li>  Para incrustar un controlador de vista creado de f√°brica, el m√©todo de vista principal del controlador es <code>UINavigationController.pushViewController(...)</code> , <code>UITabBarController.selectedViewController = ...</code> , <code>UIViewController.present(...)</code> y as√≠ sucesivamente.  Puede observar que siempre se requieren 2 controladores de vista, uno que ya est√° en la pila y otro que debe incrustarse en la pila.  Envuelva esto en un contenedor y ll√°melo <strong>Acci√≥n (Acci√≥n)</strong> .  Cada acci√≥n es f√°cil de cubrir con pruebas unitarias completas y cada una es independiente de las dem√°s. </li><li>  De lo anterior, resulta que usando entidades preparadas, puede construir la cadena de configuraci√≥n <em>F√°brica -&gt; Acci√≥n -&gt; F√°brica -&gt; Acci√≥n -&gt; F√°brica</em> y, despu√©s de completarla, puede construir un √°rbol de vista de controladores de cualquier complejidad.  Solo necesita especificar el punto de entrada.  Estos puntos de entrada suelen ser el <em>rootViewController</em> propiedad de <em>UIWindow</em> o el controlador de vista actual, que es la rama m√°s extrema del √°rbol.  Es decir, dicha configuraci√≥n se escribe correctamente como: <strong>Inicio de ViewController -&gt; Acci√≥n -&gt; F√°brica -&gt; ... -&gt; F√°brica</strong> . </li><li>  Adem√°s de la configuraci√≥n, necesitar√° alguna entidad que sepa c√≥mo iniciar y construir la configuraci√≥n proporcionada.  Lo llamaremos <strong>enrutador</strong> .  No tiene un estado, no contiene ning√∫n enlace.  Tiene un m√©todo al que se pasa la configuraci√≥n y realiza secuencialmente los pasos de configuraci√≥n. </li><li>  Agregue responsabilidad al enrutador agregando clases de <strong>interceptores</strong> a la cadena de configuraci√≥n.  Los interceptores son posibles de 3 tipos: 1. Lanzado antes de comenzar la navegaci√≥n.  Eliminamos las tareas de autenticaci√≥n de usuarios en el sistema y otras tareas asincr√≥nicas en ellos.  2. Ejecute en el momento de la creaci√≥n del controlador de vista para establecer los valores.  3. Realizado despu√©s de la navegaci√≥n y realizando diversas tareas anal√≠ticas.  Cada entidad se cubre f√°cilmente mediante pruebas unitarias y no sabe c√≥mo se utilizar√° en la configuraci√≥n.  Ella tiene una sola responsabilidad y la cumple.  Es decir, la configuraci√≥n para la navegaci√≥n compleja puede verse como <strong>[Tarea previa a la navegaci√≥n ...] -&gt; Iniciar ViewController -&gt; Acci√≥n -&gt; (Factory + [ContextTask ...]) -&gt; ... -&gt; (Factory + [ContextTask ...]) -&gt; [Post NavigationTask ...]</strong>  Es decir, todas las tareas ser√°n realizadas por el enrutador secuencialmente, realizando a su vez entidades at√≥micas peque√±as y f√°cilmente legibles. </li><li>  La √∫ltima tarea que la configuraci√≥n no puede resolver permanece: este es el estado de la aplicaci√≥n en este momento.  ¬øQu√© sucede si necesitamos construir no toda la cadena de configuraci√≥n, sino solo una parte, porque el usuario la pas√≥ parcialmente?  Esta pregunta siempre puede ser respondida inequ√≠vocamente por los controladores del √°rbol de visi√≥n.  Porque si parte de la cadena ya est√° construida, ya est√° en el √°rbol.  Esto significa que si cada f√°brica de la cadena puede responder a la pregunta de si est√° construida o no, entonces el enrutador podr√° comprender qu√© parte de la cadena debe completarse.  Por supuesto, esta no es la tarea de la f√°brica, por lo que se introduce otra entidad at√≥mica: el <strong>Finder,</strong> y cualquier configuraci√≥n se ve as√≠: <strong>[Tarea previa a la navegaci√≥n ...] -&gt; Iniciar ViewController -&gt; Acci√≥n -&gt; (Finder / Factory + [ContextTask ...]) -&gt; ... -&gt; (Finder / Factory + [ContextTask ...]) -&gt; [Publicar tarea de navegaci√≥n ...]</strong> .  Si el enrutador comienza a leerlo desde el final, entonces uno de los buscadores le dir√° que ya est√° construido, y el enrutador a partir de este punto comenzar√° a construir la cadena de nuevo.  Si ninguno de ellos se encuentra en el √°rbol, debe construir toda la cadena desde el controlador inicial. <br><img src="https://habrastorage.org/getpro/habr/post_images/f50/a64/213/f50a64213fa1654fbde33e53b31f4e43.gif" alt="imagen"></li><li>  La configuraci√≥n debe estar fuertemente tipada.  Por lo tanto, cada entidad trabaja con un solo tipo de vista de controlador; un tipo de datos y configuraci√≥n se basa completamente en la capacidad de swift para trabajar con los tipos <strong>asociados</strong> .  Queremos confiar en el compilador, no en el tiempo de ejecuci√≥n.  Un desarrollador puede debilitar la escritura intencionalmente, pero no al rev√©s. </li></ol><br><p>  Un ejemplo de tal configuraci√≥n: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> productScreen = <span class="hljs-type"><span class="hljs-type">StepAssembly</span></span>(finder: <span class="hljs-type"><span class="hljs-type">ProductViewControllerFinder</span></span>(), factory: <span class="hljs-type"><span class="hljs-type">ProductViewControllerFactory</span></span>()) .add(<span class="hljs-type"><span class="hljs-type">LoginInterceptor</span></span>&lt;<span class="hljs-type"><span class="hljs-type">UUID</span></span>&gt;()) <span class="hljs-comment"><span class="hljs-comment">// Have to specify the context type till https://bugs.swift.org/browse/SR-8719 is fixed .add(ProductViewControllerContextTask()) .add(ProductViewControllerPostTask(analyticsManager: AnalyticsManager.sharedInstance)) .using(UINavigationController.push()) .from(NavigationControllerStep()) .using(GeneralActions.presentModally()) .from(GeneralStep.current()) .assemble()</span></span></code> </pre> <br><p>  Los elementos descritos anteriormente cubren toda la biblioteca y describen el enfoque.  Todo lo que nos queda es proporcionar las configuraciones de cadena que el enrutador ejecutar√° cuando el usuario haga clic en un bot√≥n o se produzca un evento externo.  Si se trata de diferentes tipos de dispositivos, por ejemplo, iPhone o iPad, proporcionaremos diferentes configuraciones de transici√≥n utilizando polimorfismo.  Si tenemos pruebas A / B, lo mismo.  No necesitamos pensar en el estado de la aplicaci√≥n al momento de iniciar la navegaci√≥n, debemos asegurarnos de que la configuraci√≥n est√© escrita correctamente inicialmente, y estamos seguros de que el enrutador la construir√° de alguna manera. </p><br><p>  El enfoque descrito es m√°s complicado que una cierta abstracci√≥n o patr√≥n, pero a√∫n no hemos enfrentado el problema donde no ser√≠a suficiente.  Por supuesto, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RouteComposer</a> requiere un poco de estudio y comprensi√≥n de c√≥mo funciona.  Sin embargo, esto es mucho m√°s f√°cil que aprender los conceptos b√°sicos de AutoLayout o RunLoop.  No m√°s matem√°ticas. </p><br><p>  La biblioteca, as√≠ como la implementaci√≥n del enrutador que se le proporciona, no utiliza ning√∫n truco objetivo con el tiempo de ejecuci√≥n y sigue completamente todos los conceptos de Cocoa Touch, solo ayuda a dividir el proceso de composici√≥n en pasos y ejecutarlos en la secuencia dada.  La biblioteca se prueba con las versiones de iOS 9 a 12. </p><br><p>  Se pueden encontrar m√°s detalles en art√≠culos anteriores: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Composici√≥n de UIViewControllers y navegaci√≥n entre ellos (y no solo) / revista geek</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejemplos de configuraci√≥n de UIViewControllers usando RouteComposer / geek magazine</a> </p><br><p>  Gracias por su atencion  Estar√© encantado de responder preguntas en los comentarios. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446550/">https://habr.com/ru/post/446550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446534/index.html">Visual Studio 2019 lanzado</a></li>
<li><a href="../446536/index.html">Colas y JMeter: Intercambio con editor y suscriptor</a></li>
<li><a href="../446538/index.html">PhotoGuru cambi√≥ al "lado oscuro" y al "m√°s sabio"</a></li>
<li><a href="../446546/index.html">Microsoft extiende la ventaja de Azure IP con nuevos beneficios de IP para los innovadores y nuevas empresas de Azure IoT</a></li>
<li><a href="../446548/index.html">An√°lisis de estad√≠sticas en campa√±as publicitarias: cree una nueva m√©trica en el DataFrame (python)</a></li>
<li><a href="../446552/index.html">Trabajar con comandos APDU utilizando el ejemplo EToken</a></li>
<li><a href="../446554/index.html">Programa para residentes de Yandex, o C√≥mo convertirse en un ingeniero de ML para un back-end experimentado</a></li>
<li><a href="../446558/index.html">Estructuras de datos ex√≥ticos: Merkle Patricia Trie modificada</a></li>
<li><a href="../446560/index.html">"Intercambio de cortes√≠a": la esencia del conflicto entre las dos compa√±√≠as de transmisi√≥n m√°s famosas</a></li>
<li><a href="../446562/index.html">Asincron√≠a en programaci√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>