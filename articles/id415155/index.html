<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛍️ 🕵🏻 👮 Performa di iOS atau cara membongkar utas utama. Bagian 1 😛 ⛰️ 👼🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada berbagai trik dan trik yang membantu mengoptimalkan kerja aplikasi iOS, ketika satu tugas harus diselesaikan dalam 16,67 milidetik. Kami memberi t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Performa di iOS atau cara membongkar utas utama. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/415155/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/cl/ww/k-/clwwk-yxw7f1pbfvtly5lytqnac.png"></a> <br><br>  Ada berbagai trik dan trik yang membantu mengoptimalkan kerja aplikasi iOS, ketika satu tugas harus diselesaikan dalam 16,67 milidetik.  Kami memberi tahu Anda cara membongkar utas utama dan alat apa yang lebih cocok untuk melacak tumpukan panggilan di dalamnya. </p><br><blockquote> “Guys, mari kita bayangkan bahwa Anda dapat mengurangi waktu startup hingga 10 detik.  Mengalikan ini dengan 5 juta pengguna, kita akan memiliki 50 juta detik setiap hari.  Dalam setahun ini akan berjumlah sekitar sepuluh kehidupan manusia.  Karena itu, jika Anda membuat unduhan awal 10 detik lebih cepat, Anda akan menghemat beberapa puluh nyawa.  Benar-benar layak, bukan? ” </blockquote><p>  <i>Steve Jobs pada kinerja (waktu startup komputer Apple II).</i> </p><br><p>  Artikel ini didasarkan pada laporan oleh pengembang iOS Fyusion Luc Parham, yang berbicara di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MBLT DEV</a> International Mobile Developers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Conference</a> tahun lalu. <a name="habracut"></a></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MBLT DEV 2018</a> akan diadakan di Moskow pada 28 September.  Tiket adalah yang termurah saat ini.  Menurut tradisi, sementara Komite Program memilih laporan, Anda dapat membeli tiket early bird untuk konf.  Ambil kesempatan ini sekarang.  Mulai 29 Juni, tiket akan lebih mahal. </p><br><h2>  Kerugian bingkai </h2><br><p>  Utas utama mengeksekusi kode yang bertanggung jawab untuk peristiwa jenis sentuh dan bekerja dengan UI.  Dia membuat layar.  Sebagian besar smartphone modern menghasilkan 60 frame per detik.  Ini berarti bahwa tugas harus diselesaikan dalam 16,67 milidetik (1000 milidetik / 60 frame).  Karena itu, akselerasi di Main Thread penting. </p><br><p>  Jika beberapa operasi membutuhkan lebih dari 16,67 milidetik, frame loss terjadi secara otomatis, dan pengguna aplikasi akan memperhatikan ini ketika memainkan animasi.  Pada beberapa perangkat, rendering bahkan lebih cepat, misalnya, pada iPad Pro 2017, kecepatan refresh layar adalah 120 Hz, sehingga hanya ada 8 milidetik untuk menyelesaikan operasi dalam satu frame. </p><br><p>  <b>Aturan # 1</b> </p><br><p> <code>CADisplayLink</code> adalah penghitung waktu khusus yang dimulai selama sinkronisasi vertikal (Vsync).  Sinkronisasi vertikal memastikan bahwa tidak lebih dari 16,67 milidetik dialokasikan untuk merender bingkai.  Sebagai tanda centang di AppDelegate, Anda dapat mendaftarkan <code>CADisplayLink</code> di loop run utama, dan kemudian Anda akan memiliki fungsi tambahan yang akan melakukan perhitungan.  Anda dapat melacak durasi aplikasi dan mencari tahu berapa banyak waktu telah berlalu sejak peluncuran terakhir fungsi ini. </p><br><p><img src="https://habrastorage.org/webt/bz/gp/2z/bzgp2zgpxfjsvfby44zjp1sq9m0.png?utm_source=Lu_1_rus">  . </p><br><p>  Permulaan terjadi ketika kebutuhan untuk rendering muncul.  Jika banyak operasi berbeda dilakukan yang membebani utas utama, maka fungsi ini dimulai dengan penundaan 100 milidetik.  Ini berarti bahwa terlalu banyak pekerjaan yang dilakukan, dan pada saat itu ada kehilangan personel. </p><br><p>  Ini adalah aplikasi Catstagram.  Saat mengunduh gambar, aplikasi mulai melambat.  Kami melihat bahwa laju bingkai menurun pada titik tertentu, dan waktu pemuatan berlangsung sekitar 200 milidetik.  Sepertinya ada sesuatu yang menghabiskan terlalu banyak waktu. </p><br><p><img src="https://habrastorage.org/webt/dh/h6/n0/dhh6n062kqjt3kpicxjfxn25rjm.gif?utm_source=Lu_1_rus">  . </p><br><p>  Pengguna tidak akan senang dengan ini, terutama jika aplikasi berjalan pada perangkat yang lebih tua, seperti iPhone 5 atau model iPod yang lebih tua, dll. </p><br><h4>  Profiler waktu </h4><br><p>  Alat yang berguna untuk melacak masalah tersebut adalah Time Profiler.  Alat lain juga berguna, tetapi pada akhirnya di Fyusion 90% dari waktu kami menggunakan Time Profiler.  Biasanya, masalah dalam aplikasi terkait dengan ScrollView, area dengan teks dan gambar. </p><br><p>  Gambar itu penting.  Kami mendekode format JPEG menggunakan <code>UIImage</code> .  Mereka melakukannya dengan lambat, dan kami tidak dapat melacak kinerja mereka secara langsung.  Ini tidak terjadi segera setelah mengatur gambar di <code>UIImageView</code> , tetapi Anda dapat melihat momen ini melalui pelacakan di Time Profiler. </p><br><p>  Pemformatan teks adalah poin penting lainnya.  Itu penting ketika aplikasi memiliki sejumlah besar teks "kompleks", misalnya, dalam bahasa Jepang atau Cina.  Mungkin perlu waktu lama untuk menghitung ukuran yang benar untuk baris dengan teks. </p><br><p>  Markup antarmuka juga memperlambat rendering dalam aplikasi.  Ini terutama berlaku untuk alat AutoLayout.  AutoLayout nyaman digunakan, tetapi sangat memperlambat aplikasi dibandingkan dengan markup manual.  Kita harus membuat konsesi.  Jika AutoLayout memperlambat aplikasi, mungkin sudah saatnya untuk mengabaikannya dan mencoba jenis markup lainnya. </p><br><h4>  Pola jejak </h4><br><img src="https://habrastorage.org/webt/uo/tx/im/uotxim2vokml0btwxujwj0medee.png?utm_source=Lu_1_rus"><br><p><br>  Dalam pohon contoh panggilan ini, Anda dapat melihat jenis pekerjaan apa yang dilakukan CPU.  Anda dapat mengubah jenis jejak, melihatnya dari sudut pandang utas, prosesor.  Biasanya hal yang paling menarik adalah membagi jejak menjadi utas dan memonitor utas. </p><br><p>  Analisis jejak awal mungkin tampak rumit.  Tidak selalu mungkin untuk segera mengetahui apa arti <code>FRunLoopDoSource0</code> . </p><br><p>  Mengaduk-aduk jejak, Anda dapat memahami bagaimana sistem bekerja, dan kemudian semuanya masuk akal.  Anda dapat melacak jejak tumpukan dan melihat semua elemen sistem yang tidak Anda tulis.  Tetapi di bagian paling bawah adalah kode sumber Anda. </p><br><h4>  Panggil pohon </h4><br><p>  Misalkan kita memiliki aplikasi yang sangat sederhana.  Ini berisi fungsi utama yang memanggil beberapa fungsi lainnya.  Inti dari karya Time Profiler adalah ia mengambil snapshot dari kondisi jejak stack saat ini dengan frekuensi satu milidetik (secara default).  Setelah satu milidetik lagi, ia mengambil snapshot dari jejak itu.  Ini memanggil fungsi utama, yang memanggil fungsi " <code>foo</code> ", yang disebut fungsi " <code>bar</code> ".  Jejak tumpukan awal ditunjukkan pada tangkapan layar di bawah ini.  Data-data ini dikumpulkan bersama.  Berlawanan dengan masing-masing fungsi, angka ditunjukkan: 1, 1, 1. </p><br><img src="https://habrastorage.org/webt/rv/ul/dj/rvuldjhbvj1ozyqdmtnz_td_jqq.png?utm_source=Lu_1_rus"><br><p><br>  Ini berarti bahwa masing-masing fungsi ini dipanggil satu kali.  Kemudian, setelah satu milidetik, kita mendapatkan suntikan tumpukan lagi.  Kali ini tampilannya persis sama, jadi semua angka bertambah 1, dan kita mendapat 2, 2, 2. </p><br><img src="https://habrastorage.org/webt/j8/lb/or/j8lborsmlr8jmobnhy45pewatpa.jpeg?utm_source=Lu_1_rus"><br><p><br>  Selama milidetik ketiga, tumpukan panggilan kami terlihat sedikit berbeda.  Fungsi utama memanggil <code>bar</code> secara langsung.  Oleh karena itu, satu unit lagi ditambahkan ke fungsi utama dan fungsi " <code>bar</code> ", dan nilainya menjadi 3. Selanjutnya, pemisahan terjadi.  Terkadang fungsi utama memanggil " <code>foo</code> " secara langsung, kadang-kadang " <code>bar</code> " dipanggil langsung.  Ini pernah terjadi sekali.  Satu fungsi dipanggil melalui yang lain. </p><br><p>  Selanjutnya, satu fungsi disebut yang lain, yang disebut fungsi ketiga.  Kita melihat bahwa fungsi " <code>baz</code> " dipanggil dua kali.  Tetapi fungsi ini sangat tidak penting sehingga disebut lebih cepat dari satu milidetik. </p><br><p>  Saat menggunakan Time Profiler, penting untuk diingat bahwa itu tidak menunjukkan interval waktu tertentu.  Itu tidak menampilkan waktu eksekusi yang tepat dari suatu fungsi.  Dia hanya melaporkan seberapa sering itu muncul dalam gambar, yang hanya memberikan nilai perkiraan durasi setiap fungsi.  Karena beberapa proses cukup cepat, mereka tidak pernah ditampilkan pada gambar. </p><br><img src="https://habrastorage.org/webt/3j/gq/z_/3jgqz_k0xujveqvpmihkhahm4t0.jpeg?utm_source=Lu_1_rus"><br><p><br>  Saat mengalihkan panggilan ke mode konsol, Anda dapat melihat dan membandingkan semua momen penurunan frame rate.  Dalam contohnya, kehilangan bingkai terjadi beberapa kali dan berbagai proses dilakukan. </p><br><img src="https://habrastorage.org/webt/gp/kn/tn/gpkntnmjfflan7e9ptbvdmaxujq.jpeg?utm_source=Lu_1_rus"><br><p><br>  Mengklik alt-klik pada macOS akan memperluas bagian dan sub-bagian, bukan hanya yang dipilih.  Mereka akan diurutkan berdasarkan jumlah pekerjaan yang dilakukan.  Dalam 90% kasus, <code>CFRunLoopRun</code> , diikuti oleh panggilan balik. </p><br><p>  Aplikasi ini didasarkan sepenuhnya pada satu siklus pelaksanaan tugas Run Loop.  Ada siklus berulang tanpa akhir, dan pada setiap iterasi, callback diluncurkan.  Jika Anda melihat callback ini, Anda dapat menyorot kemacetan teratas. </p><br><p>  Setelah melihat tantangan-tantangan ini secara lebih rinci, kemungkinan besar Anda tidak akan mengerti apa yang mereka lakukan.  Ini dapat berupa renders, penyedia gambar, IO. </p><br><img src="https://habrastorage.org/webt/re/t2/x2/ret2x23t8dvlqxrekef0ahis3n0.jpeg?utm_source=Lu_1_rus"><br><p><br>  Ada opsi yang memungkinkan Anda untuk menyembunyikan pustaka sistem.  Mereka sebenarnya adalah area masalah aplikasi. </p><br><p>  Ada meter yang dalam persentase menunjukkan seberapa banyak pekerjaan yang dilakukan fungsi atau operasi tertentu.  Jika kita melihat contoh ini, kita akan melihat nilainya - 34%.  Ini adalah proses Apple <code>jpeg_decode_image_all</code> .  Setelah mempelajarinya menjadi jelas bahwa decoding gambar JPEG terjadi di utas utama, dan dalam kebanyakan kasus ini adalah penyebab hilangnya bingkai. </p><br><img src="https://habrastorage.org/webt/sa/tw/ug/satwugwrhvrrzogck8tetwxmfz4.png?utm_source=Lu_1_rus"><br><p><br>  <b>Aturan # 2</b> </p><br><p>  Secara umum, decoding gambar jpeg harus dilakukan di latar belakang.  Sebagian besar pustaka pihak ketiga (AsyncDisplayKit, SDWebImage, dll.) Dapat melakukan ini secara default.  Jika Anda tidak ingin menggunakan framework, Anda bisa melakukan decoding secara manual.  Untuk melakukan ini, Anda dapat menulis ekstensi di atas <code>UIImage</code> di mana Anda membuat konteks dan menggambar secara manual. </p><br><img src="https://habrastorage.org/webt/eu/sx/t6/eusxt6il6-o4bdc-fkmj4j46yf4.jpeg?utm_source=Lu_1_rus"><br><p><br>  Saat melakukan operasi ini, Anda dapat memanggil fungsi <code>decodeImage</code> bukan dari utas utama.  Itu akan selalu mengembalikan gambar yang diterjemahkan.  Tidak ada cara untuk memeriksa apakah gambar UIImage tertentu telah melewati pengodean ulang, jadi Anda harus selalu melewati mereka melalui metode ini.  Tetapi jika Anda menyimpan data dengan benar, tidak akan ada proses yang tidak perlu dalam sistem. </p><br><p>  Dari sudut pandang teknis, ini kurang efektif.  Menggunakan kelas <code>UIImageView</code> tampaknya dioptimalkan dan efisien.  Tetapi juga melakukan decoding perangkat keras, sehingga juga memiliki kekurangannya.  Dengan metode ini, gambar Anda akan diterjemahkan lebih lambat.  Tetapi ada kabar baik - Anda dapat mendekode gambar dengan cara di atas, bukan pada utas utama, dan kemudian kembali ke utas utama dan mengonfigurasi antarmuka. </p><br><img src="https://habrastorage.org/webt/q_/dv/zy/q_dvzybezi7knldcsw-pqbwjcla.png?utm_source=Lu_1_rus"><br><p><br>  Terlepas dari kenyataan bahwa operasi ini membutuhkan lebih banyak waktu, itu mungkin tidak dilakukan pada utas utama, yang berarti tidak mengganggu aktivitas pengguna dalam aplikasi, karena itu tidak memperlambat pengguliran rekaman.  Solusi yang menguntungkan. </p><br><h4>  Peringatan kehabisan memori </h4><br><p>  Dengan sinyal memori rendah, saya ingin menghapus semua data yang tidak digunakan yang mungkin.  Tetapi jika berbagai proses dilakukan pada aliran pihak ketiga, maka penempatan gambar JPEG yang didekodekan volumetrik pada mereka akan memakan sebagian besar ruang kosong. </p><br><p>  Masalah seperti itu terjadi pada aplikasi Fyuse.  Jika saya telah mendekodekan semua gambar JPEG saya pada aliran pihak ketiga, maka dalam beberapa kasus, misalnya, pada model ponsel lama, sistem ini akan langsung memecah aplikasi.  Ini karena fakta bahwa aliran tugas pihak ketiga tidak menanggapi peringatan tentang memori yang tidak mencukupi dari sistem, seperti "Hei, hapus data yang tidak perlu!".  Situasi berikut terjadi: pertama Anda menempatkan semua gambar ini pada aliran pihak ketiga, dan kemudian aplikasi terus-menerus macet.  Jika utas pihak ketiga mengirim sinyal ke utas utama tentang apa yang terjadi dalam sistem, maka masalah seperti itu tidak akan terjadi. </p><br><h4>  Bekerja tanpa kegagalan </h4><br><img src="https://habrastorage.org/webt/g4/dz/1k/g4dz1k3gxvfrhg4snitoijtavfm.png?utm_source=Lu_1_rus"><br><p><br>  Intinya, utas utama adalah antrian yang terdiri dari proses.  Saat bekerja dengan utas pihak ketiga, Anda dapat menulis perintah <code>performSelectorOnMainThread:withObject:waitUntilDone:</code> di Objective-C.  Berkat dia, tugas akan diletakkan di akhir antrian di utas utama.  Karena itu, jika utas utama sibuk memproses pemberitahuan kehabisan memori, memanggil perintah ini akan memungkinkan Anda untuk menunggu sampai semua pemberitahuan diproses, dan baru kemudian memulai proses rumit memuat dan menempatkan data.  Di Swift, ini terlihat sedikit lebih sederhana.  <code>DispatchQueue.main.sync</code> membebaskan ruang pada utas utama. </p><br><p>  Ini adalah contoh lain.  Kami telah membebaskan memori dan mendekode gambar pada aliran pihak ketiga.  Menggulir rekaman secara visual menjadi lebih baik.  Kami masih kehilangan bingkai karena fakta bahwa kami sedang menguji iPod 5g.  Ini adalah salah satu model pengujian terburuk yang masih mendukung versi iOS 10 dan 11. </p><br><img src="https://habrastorage.org/webt/bw/fa/og/bwfaog8aavwenf4h1lkqipapnds.gif?utm_source=Lu_1_rus"><br><p><br>  Jika Anda mengalami kehilangan bingkai seperti ini, Anda masih dapat melihat rekaman itu.  Namun, masih ada proses yang terus membuat personil kehilangan.  Ada cara lain untuk membuat aplikasi berjalan lebih cepat. </p><br><p>  Tentu saja, tidak selalu mudah untuk mengoptimalkan aplikasi.  Tetapi jika Anda memiliki tugas yang membutuhkan waktu relatif lama untuk diselesaikan, Anda harus meletakkannya di utas latar belakang.  Pastikan bahwa tugas-tugas ini tidak terkait dengan UI, karena banyak kelas UIKit tidak aman, yaitu, Anda tidak dapat membuatnya di backend. </p><br><p>  Gunakan Core Graphics jika Anda perlu memproses gambar pada aliran pihak ketiga.  Jangan menyembunyikan tampilan pustaka sistem.  Ingat peringatan kehabisan memori. </p><br><h4>  Selamat datang di MBLT DEV 2018 </h4><br><p>  Datang tanggal 28 September hingga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konferensi</a> Pengembang Seluler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MBLT DEV 2018</a> Internasional ke-5 di Moskow.  Pembicara pertama sudah ada di situs, dan early bird terbaru masih dijual.  Harga tiket akan naik pada tanggal 29 Juni.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Beli tiket</a> sekarang dengan harga terendah. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/yr/u2/x0/yru2x0-bqpghfoa6zqfrkyluuhq.jpeg"></a> </p><br><p>  Baca tentang implementasi antarmuka pengguna di iOS, penggunaan kurva Bezier dan alat lain yang bermanfaat di bagian kedua artikel, yang akan kami terbitkan pada 28 Juni. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415155/">https://habr.com/ru/post/id415155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415085/index.html">Apa itu CISSP, bagaimana cara mendapatkannya, tidak kehilangan itu dan mengapa itu tidak diperlukan</a></li>
<li><a href="../id415087/index.html">[KASUS] Pencetakan 3D SLA di pabrik elektronik kapal</a></li>
<li><a href="../id415091/index.html">Rust 1.27 Release</a></li>
<li><a href="../id415093/index.html">PVT: mengapa menyuntikkan lem secara intravena</a></li>
<li><a href="../id415153/index.html">Persyaratan ideal akan datang kembali</a></li>
<li><a href="../id415159/index.html">Pengumuman DevOps-conference DevOops 2018</a></li>
<li><a href="../id415163/index.html">Jaringan nirkabel di pabrik farmasi yang dijaga khusus dan terlindung secara khusus di beberapa tempat di Rusia</a></li>
<li><a href="../id415165/index.html">Rilis Node.js 10.5: multithreading di luar kotak</a></li>
<li><a href="../id415167/index.html">Buka pelajaran “Multithreading di Jawa. Primitif sinkronisasi dasar »</a></li>
<li><a href="../id415169/index.html">Kompresi dan deduplikasi: Mengurangi ukuran arsip email dan cadangan menggunakan musim dingin ZxPowerstore</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>