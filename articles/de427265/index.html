<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÖ üïî üï¥üèæ Protobuffer sind falsch üîù üöû üßöüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="F√ºr den gr√∂√üten Teil meines Berufslebens bin ich gegen die Verwendung von Protokollpuffern. Sie sind klar geschrieben von Amateuren, unglaublich hoch ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protobuffer sind falsch</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427265/"> F√ºr den gr√∂√üten Teil meines Berufslebens bin ich gegen die Verwendung von Protokollpuffern.  Sie sind klar geschrieben von Amateuren, unglaublich hoch spezialisiert, leiden unter vielen Fallstricken, sind schwer zu kompilieren und l√∂sen ein Problem, das niemand au√üer Google tats√§chlich hat.  Wenn diese Probleme der Protopuffer in der Quarant√§ne von Serialisierungsabstraktionen verbleiben w√ºrden, w√ºrden meine Behauptungen dort enden.  Leider ist das schlechte Design von Protobuffern so aufdringlich, dass diese Probleme in Ihren Code eindringen k√∂nnen. <br><br>  <b>Enge Spezialisierung und Entwicklung durch Amateure</b> <br><br>  H√∂r auf.  Schlie√üen Sie Ihren E-Mail-Client, in dem Sie mir bereits einen Brief geschrieben haben, in dem es hei√üt: "Die besten Ingenieure der Welt arbeiten bei Google", "ihre Entw√ºrfe k√∂nnen per Definition nicht von Amateuren erstellt werden."  Das will ich nicht h√∂ren. <br><br>  Lassen Sie uns dieses Thema einfach nicht diskutieren.  Vollst√§ndige Offenlegung: Ich habe fr√ºher bei Google gearbeitet.  Dies war der erste (aber leider nicht der letzte) Ort, an dem ich Protobuffer verwendet habe.  Alle Probleme, √ºber die ich sprechen m√∂chte, sind in der Google-Codebasis vorhanden.  Es ist nicht nur "Missbrauch von Protobuffern" und dergleichen. <br><a name="habracut"></a><br>  Das mit Abstand gr√∂√üte Problem bei Protobuffern ist das schreckliche Typsystem.  Java-Fans sollten sich hier wie zu Hause f√ºhlen, aber leider h√§lt buchst√§blich niemand Java f√ºr ein gut gestaltetes Typsystem.  Die Leute vom dynamischen Schreibcamp beschweren sich √ºber unn√∂tige Einschr√§nkungen, w√§hrend sich die Vertreter des statischen Schreibcamps wie ich √ºber unn√∂tige Einschr√§nkungen und das Fehlen von allem beschweren, was Sie wirklich vom Typensystem wollen.  In beiden F√§llen verlieren. <br><br>  Enge Spezialisierung und Entwicklung durch Amateure gehen Hand in Hand.  Ein Gro√üteil der Spezifikationen schien im letzten Moment verschraubt zu sein - und es war offensichtlich im letzten Moment verschraubt.  Einige Einschr√§nkungen zwingen Sie anzuhalten, sich am Kopf zu kratzen und zu fragen: "Was zur H√∂lle?"  Dies sind jedoch nur Symptome eines tieferen Problems: <br><br>  Offensichtlich werden Protobuffer von Amateuren erstellt, weil sie schlechte L√∂sungen f√ºr bekannte und bereits gel√∂ste Probleme bieten. <br><br><h1>  Mangel an Zusammensetzung </h1><br>  Protobuffer bieten mehrere Funktionen, die nicht miteinander funktionieren.  Schauen Sie sich zum Beispiel die Liste der orthogonalen, aber gleichzeitig eingeschr√§nkten Eingabefunktionen an, die ich in der Dokumentation gefunden habe. <br><br><ul><li> <code>oneof</code> Felder kann nicht <code>repeated</code> . </li><li>  Die Felder <code>map&lt;k,v&gt;</code> haben eine spezielle Syntax f√ºr Schl√ºssel und Werte, werden jedoch in keinem anderen Typ verwendet. </li><li>  Obwohl <code>map</code> parametriert werden k√∂nnen, ist kein benutzerdefinierter Typ mehr zul√§ssig.  Dies bedeutet, dass Sie nicht mehr in der Lage sind, Ihre eigenen Spezialisierungen in allgemeinen Datenstrukturen manuell anzugeben. </li><li>  <code>map</code> k√∂nnen nicht <code>repeated</code> . </li><li>  <code>map</code> <i>k√∂nnen</i> <code>string</code> , jedoch <i>keine</i> <code>bytes</code> .  Enum ist ebenfalls verboten, obwohl letztere in allen anderen Teilen der Protobuffers-Spezifikation als Ganzzahlen gleichwertig angesehen werden. </li><li>  <code>map</code> k√∂nnen keine anderen <code>map</code> . </li></ul><br>  Diese verr√ºckte Liste von Einschr√§nkungen ist das Ergebnis einer prinzipienlosen Auswahl an Design- und Schraubenfunktionen im letzten Moment.  Beispielsweise kann <code>oneof</code> Felder nicht <code>repeated</code> , da der Codegenerator anstelle eines <code>oneof</code> gegenseitig ausschlie√üende optionale Felder erzeugt.  Eine solche Transformation gilt nur f√ºr ein einzelnes Feld (und wie wir sp√§ter sehen werden, funktioniert sie nicht einmal f√ºr dieses Feld). <br><br>  Die Einschr√§nkung von <code>map</code> , die nicht <code>repeated</code> , stammt ungef√§hr aus derselben Oper, zeigt jedoch eine andere Einschr√§nkung des Typsystems.  Hinter den Kulissen verwandelt sich die <code>map&lt;k,v&gt;</code> in etwas √Ñhnliches wie das <code>repeated Pair&lt;k,v&gt;</code> .  Und da <code>repeated</code> das magische Schl√ºsselwort der Sprache ist und nicht der normale Typ, verbindet es sich nicht mit sich selbst. <br><br>  Ihre Vermutungen √ºber das Problem mit <code>enum</code> sind genauso wahr wie meine. <br><br>  Was an all dem so frustrierend ist, ist ein schlechtes Verst√§ndnis der Funktionsweise moderner Typsysteme.  Dieses Verst√§ndnis w√ºrde die Protobuffer-Spezifikation <i>dramatisch vereinfachen</i> und gleichzeitig <i>alle willk√ºrlichen Einschr√§nkungen aufheben</i> . <br><br>  Die L√∂sung lautet wie folgt: <br><br><ul><li>  Machen Sie alle Felder in der <code>required</code> Nachricht.  Dies macht jede Nachricht zu <i>einem</i> Produkttyp. </li><li>  <code>oneof</code> Sie den Wert des <code>oneof</code> auf eigenst√§ndige Datentypen.  Dies wird ein Nebenprodukttyp sein. </li><li>  Erm√∂glichen der Parametrisierung von Produkttypen und Nebenprodukten anderer Typen. </li></ul><br>  Das ist alles!  Diese drei √Ñnderungen sind alles, was Sie ben√∂tigen, um m√∂gliche Daten zu ermitteln.  Mit diesem einfachen System k√∂nnen Sie alle anderen Protobuffer-Spezifikationen wiederholen. <br><br>  Sie k√∂nnen beispielsweise die <code>optional</code> Felder wiederholen: <br><br><pre> <code class="hljs pgsql">product Unit { // <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> fields } coproduct Optional&lt;t&gt; { t <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; Unit unset = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Das Erstellen <code>repeated</code> Felder ist ebenfalls einfach: <br><br><pre> <code class="hljs php">coproduct <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;t&gt; { Unit <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; Pair&lt;t, <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;t&gt;&gt; cons = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Die eigentliche Logik der Serialisierung erm√∂glicht es Ihnen nat√ºrlich, etwas Kl√ºgeres zu tun, als verkn√ºpfte Listen √ºber das Netzwerk zu √ºbertragen - schlie√ülich m√ºssen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung und Semantik nicht miteinander korrespondieren</a> . <br><br><h1>  Zweifelhafte Wahl </h1><br>  Protobuffer im Java-Stil unterscheiden zwischen <i>Skalar-</i> und <i>Nachrichtentypen</i> .  Skalare entsprechen mehr oder weniger Maschinenprimitiven - Dinge wie <code>int32</code> , <code>bool</code> und <code>string</code> .  Nachrichtentypen sind dagegen der Rest.  Alle Bibliotheks- und Benutzertypen sind Nachrichten. <br><br>  Nat√ºrlich haben die beiden Arten von Typen eine v√∂llig unterschiedliche Semantik. <br><br>  Felder mit Skalartypen sind immer vorhanden.  Auch wenn Sie sie nicht installiert haben.  Das habe ich schon gesagt (zumindest in proto3 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><sup>1</sup></a> <a name="1_1"></a>  ) Werden alle Protopuffer auf Nullen initialisiert, auch wenn sie absolut keine Daten haben?  Skalarfelder erhalten gef√§lschte Werte: Beispielsweise wird <code>uint32</code> auf <code>0</code> und <code>string</code> auf <code>""</code> initialisiert. <br><br>  Es ist nicht m√∂glich, ein Feld, das sich nicht im Protopuffer befand, von einem Feld zu unterscheiden, dem ein Standardwert zugewiesen wurde.  Vermutlich wurde diese Entscheidung zur Optimierung getroffen, um keine skalaren Standardeinstellungen weiterzuleiten.  Dies ist nur eine Annahme, da in der Dokumentation diese Optimierung nicht erw√§hnt wird und Ihre Annahme daher nicht schlechter ist als meine. <br><br>  Wenn wir Protobuffers Behauptungen einer idealen L√∂sung f√ºr die Abw√§rts- und zuk√ºnftige API-Kompatibilit√§t diskutieren, werden wir sehen, dass diese Unf√§higkeit, zwischen undefinierten und Standardwerten zu unterscheiden, ein wahrer Albtraum ist.  Besonders wenn es wirklich eine bewusste Entscheidung ist, ein Bit (gesetzt oder nicht) f√ºr das Feld zu speichern. <br><br>  Vergleichen Sie dieses Verhalten mit Nachrichtentypen.  W√§hrend Skalarfelder ‚Äûdumm‚Äú sind, ist das Verhalten von Nachrichtenfeldern v√∂llig <i>verr√ºckt</i> .  Intern sind die Nachrichtenfelder entweder vorhanden oder nicht, aber das Verhalten ist verr√ºckt.  Ein kleiner Pseudocode f√ºr ihren Accessor sagt mehr als tausend Worte.  Stellen Sie sich das in Java oder anderswo vor: <br><br><pre> <code class="hljs pgsql">private Foo m_foo; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Foo foo { // <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> `foo` <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> used <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> an expression <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_foo != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_foo; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Foo(); } // <span class="hljs-keyword"><span class="hljs-keyword">instead</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> `foo` <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> used <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> an lvalue mutable <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_foo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) m_foo = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Foo(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_foo; } }</code> </pre> <br>  Wenn das Feld <code>foo</code> nicht festgelegt ist, wird theoretisch eine standardm√§√üig initialisierte Kopie angezeigt, unabh√§ngig davon, ob Sie danach fragen oder nicht. Sie k√∂nnen den Container jedoch nicht √§ndern.  Wenn Sie jedoch <code>foo</code> √§ndern, √§ndert sich auch das √ºbergeordnete Element!  All dies dient nur dazu, die Verwendung des Typs " <code>Maybe Foo</code> " und der damit verbundenen "Kopfschmerzen" zu vermeiden, um herauszufinden, was ein undefinierter Wert bedeuten sollte. <br><br>  Ein solches Verhalten ist besonders ungeheuerlich, weil es gegen das Gesetz verst√∂√üt!  Wir erwarten den Job <code>msg.foo = msg.foo;</code>  wird nicht funktionieren.  Stattdessen √§ndert die Implementierung <code>msg</code> stillschweigend in eine Kopie von <code>foo</code> mit Null-Initialisierung, wenn sie vorher nicht vorhanden war. <br><br>  Im Gegensatz zu Skalarfeldern k√∂nnen Sie zumindest feststellen, dass das Nachrichtenfeld nicht festgelegt ist.  Sprachbindungen f√ºr Protobuffer bieten so etwas wie die generierte Methode <code>bool has_foo()</code> .  Wenn es vorhanden ist, m√ºssen Sie beim h√§ufigen Kopieren des Nachrichtenfelds von einem Protobuffer in einen anderen den folgenden Code schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (src.has_foo(src)) { dst.set_foo(src.foo()); }</code> </pre> <br>  Bitte beachten Sie, dass diese Vorlage zumindest in Sprachen mit statischer Typisierung aufgrund der nominalen Beziehung zwischen den <code>has_foo()</code> <code>foo()</code> , <code>set_foo()</code> und <code>has_foo()</code> <i>nicht abstrahiert</i> werden <code>has_foo()</code> .  Da alle diese Funktionen ihre eigenen <i>Bezeichner sind</i> , haben wir nicht die M√∂glichkeit, sie programmgesteuert zu generieren, mit Ausnahme des Pr√§prozessor-Makros: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COPY_IFF_SET(src, dst, field) \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (src.has_##field(src)) { \ dst.set_##field(src.field()); \ }</span></span></code> </pre> <br>  (Pr√§prozessor-Makros sind jedoch im Google Style Guide verboten). <br><br>  Wenn stattdessen alle zus√§tzlichen Felder als <code>Maybe</code> implementiert w√§ren, k√∂nnten Sie die abstrahierten Dial-Peers sicher festlegen. <br><br>  Um das Thema zu wechseln, sprechen wir √ºber eine weitere zweifelhafte Entscheidung.  Obwohl Sie eines der Felder in <code>oneof</code> definieren k√∂nnen, stimmt ihre Semantik <i>nicht mit der</i> Art des Nebenprodukts <i>√ºberein</i> !  Newbie Fehler Jungs!  Stattdessen erhalten Sie ein optionales Feld f√ºr jeden Fall und jeden magischen Code in den Setzern, wodurch jedes andere Feld einfach r√ºckg√§ngig gemacht wird, wenn es gesetzt ist. <br><br>  Auf den ersten Blick scheint dies semantisch der richtigen Art der Vereinigung zu entsprechen.  Aber stattdessen bekommen wir eine widerliche, unbeschreibliche Fehlerquelle!  Wenn dieses Verhalten mit einer unzul√§ssigen Implementierung kombiniert wird <code>msg.foo = msg.foo;</code>  Eine solche scheinbar normale Zuordnung l√∂scht stillschweigend beliebige Datenmengen! <br><br>  Infolgedessen bedeutet dies, dass <code>oneof</code> Felder kein gesetzestreues <code>Prism</code> bildet und Nachrichten keine gesetzestreue <code>Lens</code> .  Also viel Gl√ºck bei Ihren Versuchen, nichttriviale Protobuffer-Manipulationen ohne Fehler zu schreiben.  <i>Es ist buchst√§blich unm√∂glich, einen universellen, fehlerfreien, polymorphen Code auf Protobuffer zu schreiben</i> . <br><br>  Dies ist nicht sehr angenehm zu h√∂ren, besonders f√ºr diejenigen von uns, die parametrischen Polymorphismus lieben, der <i>genau das Gegenteil verspricht</i> . <br><br><h1>  R√ºckw√§rts- und Zukunftskompatibilit√§t liegt </h1><br>  Eine der oft erw√§hnten "Killer-Funktionen" von Protobuffers ist ihre "problemlose F√§higkeit, r√ºckw√§rts- und vorw√§rtskompatible APIs zu schreiben".  Diese Aussage wurde vor Ihren Augen aufgeh√§ngt, um die Wahrheit zu verschleiern. <br><br>  Diese Protobuffer sind freiz√ºgig.  Sie schaffen es, mit Nachrichten aus der Vergangenheit oder Zukunft umzugehen, weil sie absolut keine Zusagen dar√ºber machen, wie Ihre Daten aussehen werden.  Alles ist optional!  Aber wenn Sie es brauchen, bereitet Protobuffers Ihnen gerne etwas mit Typpr√ºfung vor und gibt Ihnen etwas, unabh√§ngig davon, ob es sinnvoll ist. <br><br>  Dies bedeutet, dass Protobuffer die versprochene "Zeitreise" ausf√ºhren und <i>dabei standardm√§√üig leise das Falsche tun</i> .  Nat√ºrlich kann (und sollte) ein vorsichtiger Programmierer Code schreiben, der die Richtigkeit der empfangenen Protobuffer √ºberpr√ºft.  Wenn Sie jedoch an jeder Site Schutzkorrektheitspr√ºfungen durchf√ºhren, bedeutet dies m√∂glicherweise nur, dass der Deserialisierungsschritt zu zul√§ssig war.  Sie haben lediglich die Validierungslogik von einer genau definierten Grenze aus dezentralisiert und in der gesamten Codebasis verwischt. <br><br>  Eines der m√∂glichen Argumente ist, dass Protobuffer alle Informationen speichern, die sie in der Nachricht nicht verstehen.  Im Prinzip bedeutet dies eine zerst√∂rungsfreie √úbertragung der Nachricht durch einen Vermittler, der diese Version des Schemas nicht versteht.  Das ist ein klarer Sieg, nicht wahr? <br><br>  Auf dem Papier ist dies nat√ºrlich eine coole Funktion.  Aber ich habe noch nie eine Anwendung gesehen, in der diese Eigenschaft wirklich gespeichert ist.  Mit Ausnahme der Routing-Software m√∂chte kein Programm nur bestimmte Teile einer Nachricht pr√ºfen und dann unver√§ndert weiterleiten.  Die √ºberwiegende Mehrheit der Programme auf Protobuffern entschl√ºsselt die Nachricht, wandelt sie in eine andere um und sendet sie an einen anderen Ort.  Leider werden diese Konvertierungen auf Bestellung durchgef√ºhrt und manuell codiert.  Bei manuellen Konvertierungen von einem Protobuffer in einen anderen bleiben unbekannte Felder nicht erhalten, da dies buchst√§blich sinnlos ist. <br><br>  Diese allgegenw√§rtige Haltung gegen√ºber Protobuffern als universell kompatibel manifestiert sich auch auf andere h√§ssliche Weise.  Styleguides f√ºr Protobuffer lehnen DRY aktiv ab und schlagen vor, Definitionen nach M√∂glichkeit in Code einzubetten.  Sie argumentieren, dass dies in Zukunft die Verwendung separater Nachrichten erm√∂glichen wird, wenn die Definitionen voneinander abweichen.  Ich betone, dass sie anbieten, die 60-j√§hrige Praxis des guten Programmierens aufzugeben, <i>nur f√ºr den Fall</i> , dass Sie pl√∂tzlich irgendwann in der Zukunft etwas √§ndern m√ºssen. <br><br>  Die Wurzel des Problems liegt darin, dass Google die Bedeutung von Daten mit seiner physischen Darstellung kombiniert.  Wenn Sie auf einer Google-Skala arbeiten, ist dies sinnvoll.  Am Ende haben sie ein internes Tool, das den Stundenlohn des Programmierers √ºber das Netzwerk, die Kosten f√ºr das Speichern von X-Bytes und andere Dinge vergleicht.  Im Gegensatz zu den meisten Technologieunternehmen ist das Gehalt von Programmierern eine der geringsten Ausgaben von Google.  Finanziell ist es f√ºr sie sinnvoll, die Zeit der Programmierer damit zu verbringen, ein paar Bytes zu sparen. <br><br>  Neben den f√ºnf f√ºhrenden Technologieunternehmen liegt niemand innerhalb der f√ºnf Gr√∂√üenordnungen von Google.  Ihr Startup <i>kann es sich nicht leisten</i> , Engineering-Stunden damit <i>zu</i> verbringen, Bytes zu sparen.  Das Einsparen von Bytes und die Verschwendung von Programmierzeit ist genau das, wof√ºr Protobuffer optimiert sind. <br><br>  Seien wir ehrlich.  Sie passen nicht in die Skala von Google und werden auch nie passen.  Verwenden Sie den Frachtkult der Technologie nicht mehr, nur weil "Google ihn nutzt" und weil "dies Best Practices der Branche sind". <br><br><h1>  Protobuffer verschmutzen Codebasen </h1><br>  Wenn es m√∂glich w√§re, die Verwendung von Protobuffern nur auf das Netzwerk zu beschr√§nken, w√ºrde ich nicht so hart √ºber diese Technologie sprechen.  Obwohl es im Prinzip mehrere L√∂sungen gibt, ist leider keine davon gut genug, um tats√§chlich in echter Software verwendet zu werden. <br><br>  Protobuffer entsprechen den Daten, die Sie √ºber den Kommunikationskanal senden m√∂chten.  Sie sind h√§ufig <i>konsistent</i> , aber nicht <i>identisch</i> mit den tats√§chlichen Daten, mit denen die Anwendung arbeiten m√∂chte.  Dies bringt uns in eine unangenehme Lage. Sie m√ºssen zwischen drei schlechten Optionen w√§hlen: <br><br><ol><li>  Pflegen Sie einen separaten Typ, der die Daten beschreibt, die Sie wirklich ben√∂tigen, und stellen Sie sicher, dass beide Typen gleichzeitig unterst√ºtzt werden. </li><li>  Packen Sie die vollst√§ndigen Daten in ein Format zur √úbertragung und Verwendung durch die Anwendung. </li><li>  Rufen Sie jedes Mal vollst√§ndige Daten aus dem Kurzformat f√ºr die √úbertragung ab. </li></ol><br>  Option 1 ist eindeutig die ‚Äûrichtige‚Äú L√∂sung, f√ºr Protobuffer jedoch ungeeignet.  Die Sprache ist nicht leistungsf√§hig genug, um Typen zu codieren, die doppelte Arbeit in zwei Formaten leisten k√∂nnen.  Dies bedeutet, dass Sie einen vollst√§ndig separaten Datentyp schreiben, synchron mit Protobuffers entwickeln und <i>speziell Serialisierungscode f√ºr diese schreiben m√ºssen</i> .  Da die meisten Leute Protobuffer verwenden, um keinen Serialisierungscode zu schreiben, wird diese Option offensichtlich nie implementiert. <br><br>  Stattdessen k√∂nnen sie mithilfe von Protobuffern in der gesamten Codebasis verteilt werden.  Es ist eine Realit√§t.  Mein Hauptprojekt bei Google war ein Compiler, der ein in einer Variante von Protobuffers geschriebenes ‚ÄûProgramm‚Äú nahm und in einem anderen ein gleichwertiges ‚ÄûProgramm‚Äú produzierte.  Die Eingabe- und Ausgabeformate waren sehr unterschiedlich, so dass ihre korrekten parallelen Versionen von C ++ nie funktionierten.  Infolgedessen konnte mein Code keine der umfangreichen Compiler-Schreibtechniken verwenden, da die Protobuffer-Daten (und der generierte Code) zu schwierig waren, um mit ihnen etwas Interessantes zu tun. <br><br>  Infolgedessen wurden anstelle von 50 Zeilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rekursionsschemata</a> 10.000 Zeilen spezielles Puffermischen verwendet.  Der Code, den ich schreiben wollte, war mit Protopuffern buchst√§blich unm√∂glich. <br><br>  Obwohl dies ein Fall ist, ist es nicht eindeutig.  Aufgrund der harten Natur der Codegenerierung werden die Manifestationen von Protopuffern in Sprachen niemals idiomatisch sein und k√∂nnen nicht erstellt werden - es sei denn, Sie schreiben den Codegenerator neu. <br><br>  Aber selbst dann haben Sie immer noch ein Problem beim Einbetten eines beschissenen Typsystems in Ihre Zielsprache.  Da die meisten Funktionen von Protobuffern schlecht durchdacht sind, gelangen diese zweifelhaften Eigenschaften in unsere Codebasen.  Dies bedeutet, dass wir gezwungen sind, diese schlechten Ideen nicht nur umzusetzen, sondern auch in jedem Projekt zu verwenden, das mit Protobuffers interagieren m√∂chte. <br><br>  Auf einer soliden Basis ist es leicht, bedeutungslose Dinge zu erkennen, aber wenn Sie in eine andere Richtung gehen, werden Sie bestenfalls auf Schwierigkeiten sto√üen, und im schlimmsten Fall mit echtem uraltem Entsetzen. <br><br>  Geben Sie im Allgemeinen die Hoffnung an alle weiter, die Protobuffer in ihren Projekten implementieren. <br><br><hr><br><a name="1"></a>  1. Bis heute gibt es bei Google eine hitzige Diskussion √ºber proto2 und dar√ºber, ob die Felder jemals als <code>required</code> markiert <code>required</code> .  Die Manifeste " <code>optional</code> gilt als sch√§dlich" <i>und</i> " <code>required</code> als sch√§dlich" werden gleichzeitig verteilt.  Viel Gl√ºck, Jungs.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚Üë</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427265/">https://habr.com/ru/post/de427265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427253/index.html">Art von Alles und Enten Missverst√§ndnissen</a></li>
<li><a href="../de427255/index.html">Cowon D2: Musikalische Langleber</a></li>
<li><a href="../de427257/index.html">Cameron Craig: Sieben Lektionen aus 10 Jahren PR-Management von Apple</a></li>
<li><a href="../de427259/index.html">Was der Turing-Test wirklich √ºberpr√ºft</a></li>
<li><a href="../de427263/index.html">Seien Sie ein Sicherheits-Ninja: Webinar-Aufzeichnung und Bonuslevel</a></li>
<li><a href="../de427267/index.html">SNMP + Java - pers√∂nliche Erfahrung. Schreiben eines Parsers f√ºr MIB-Dateien</a></li>
<li><a href="../de427269/index.html">Google OKR-Video f√ºnf Jahre sp√§ter - Ein √úberblick √ºber die Erfahrungen von Google Ventures bei der Implementierung von OKR (2012-2017)</a></li>
<li><a href="../de427271/index.html">Geschichte und Erfahrung mit maschineller √úbersetzung. Yandex Vortrag</a></li>
<li><a href="../de427273/index.html">Kann k√ºnstliche Intelligenz Buchmacher ohne Arbeit lassen?</a></li>
<li><a href="../de427275/index.html">Internetinformationsarchitektur Teil 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>