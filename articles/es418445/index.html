<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💉 🌸 🥛 Canales de Django: la respuesta a la web moderna 📼 🐄 🦕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el mundo de Django, el complemento Django Channels está ganando popularidad. Esta biblioteca debería traer a Django la programación de red asincrón...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Canales de Django: la respuesta a la web moderna</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/418445/">  En el mundo de Django, el complemento Django Channels está ganando popularidad.  Esta biblioteca debería traer a Django la programación de red asincrónica que hemos estado esperando.  <strong>Artyom Malyshev</strong> en Moscow Python Conf 2017 explicó cómo lo hace la primera versión de la biblioteca (ahora el autor ya ha comprimido los canales2), por qué lo hace y lo hace en absoluto. <br><br>  En primer lugar, Zen Zen dice que cualquier solución debería ser la única.  Por lo tanto, <strong>en Python hay al menos tres cada uno</strong> .  Ya hay muchos marcos asincrónicos de red: <br><br><ul><li>  Torcido <br></li><li>  Eventlet <br></li><li>  Gevent <br></li><li>  Tornado; <br></li><li>  Asyncio <br></li></ul><br>  Parecería, por qué escribir otra biblioteca y si es necesario en absoluto. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ij0PiSlYBu0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong><em>Sobre el orador:</em></strong> Artyom Malyshev es un desarrollador independiente de Python.  Se dedica al desarrollo de sistemas distribuidos, habla en conferencias sobre Python.  Artyom se puede encontrar con el apodo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">PROOFIT404</a> en Github y en las redes sociales. <br><a name="habracut"></a><br>  <strong>Django es sincrónico por definición</strong> .  Si estamos hablando de ORM, acceder sincrónicamente a la base de datos durante el acceso al atributo, cuando escribimos, por ejemplo, post.author.username, no cuesta nada. <br><br>  Además, Django es un marco WSGI. <br><br><h2>  WSGI <br></h2><br>  WSGI es una interfaz síncrona para trabajar con servidores web. <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">app</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(environ, callback)</span></span></span><span class="hljs-function"> :</span></span> status, headers = <span class="hljs-string"><span class="hljs-string">'200 OK'</span></span>, [] callback (status, headers) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'Hello world!\n'</span></span>]</code> </pre> <br>  Su característica principal es que tenemos una función que toma un argumento e inmediatamente devuelve un valor.  Eso es todo lo que el servidor web puede esperar de nosotros.  <strong>No asíncrono y no huele</strong> . <br><br>  Esto se hizo hace mucho tiempo, en 2003, cuando la web era simple, los usuarios leían todo tipo de noticias en Internet y entraban en los libros de visitas.  Bastaba con aceptar la solicitud y procesarla.  Responde y olvida que este usuario era en absoluto. <br><img src="https://habrastorage.org/webt/-a/3e/ly/-a3elynsjri1d0qbc73yl256qbo.jpeg"><br><br>  Pero, por un segundo, ahora no es el año 2003, por lo que los usuarios quieren mucho más de nosotros. <br><img src="https://habrastorage.org/webt/-j/fp/nz/-jfpnzpcfn0w2hpbvmcejswxnaw.jpeg"><br>  Quieren una aplicación web enriquecida, contenido en vivo, quieren que la aplicación funcione bien en el escritorio, en la computadora portátil, en otras partes superiores, en el reloj.  Lo más importante, los <strong>usuarios no quieren presionar F5</strong> , porque, por ejemplo, las tabletas no tienen dicho botón. <br><br><img src="https://habrastorage.org/webt/bq/gi/ql/bqgiql6zzob87g74yngfmwvkehs.jpeg"><br><br>  Los navegadores web, naturalmente, vienen a conocernos: agregan nuevos protocolos y nuevas funciones.  Si usted y yo solo desarrollamos la interfaz, entonces simplemente tomaríamos el navegador como plataforma y usaríamos sus funciones principales, ya que está listo para proporcionarnos. <br><br>  <strong>Pero, para los programadores de back-end, todo ha cambiado mucho</strong> .  Los sockets web, HTTP2 y similares son un gran problema en términos de arquitectura, porque son conexiones duraderas con sus estados que deben manejarse de alguna manera. <br><img src="https://habrastorage.org/webt/g1/pn/gi/g1pngi6z8op3aesfec2rtiodv4q.jpeg"><br><br>  Este es el problema que Django Channels for Django está tratando de resolver.  Esta biblioteca está diseñada para darle la capacidad de manejar conexiones, dejando el Django Core al que estamos acostumbrados sin cambios. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>Andrew Godwin</strong></a> lo convirtió en una persona maravillosa, el dueño de un terrible acento inglés que habla muy rápido.  Debe saberlo por cosas como las olvidadas migraciones de Django South y Django, que nos llegaron de la versión 1.7.  Desde que arregló las migraciones para Django, comenzó a reparar los sockets web y HTTP2. <br><br>  ¿Cómo lo hizo?  Había una vez una imagen de ese tipo en Internet: cuadrados vacíos, flechas, la inscripción "Buena arquitectura": ingresas tus tecnologías favoritas en estos pequeños cuadrados, obtienes un sitio web que escala bien. <br><br><img src="https://habrastorage.org/webt/r1/rz/z9/r1rzz99ck74ggy5uy8vnn7kebks.jpeg"><br><br>  Andrew Godwin ingresó a un servidor en estos cuadros, que se encuentra al frente y acepta cualquier solicitud, ya sea asíncrona, sincrónica, de correo electrónico, lo que sea.  Entre ellos se encuentra la llamada capa de canal, que almacena los mensajes recibidos en un formato accesible para el grupo de trabajadores sincrónicos.  Tan pronto como la conexión asíncrona nos envió algo, lo registramos en la capa de canal, y luego el trabajador sincrónico puede recogerlo desde allí y procesarlo de la misma manera que cualquier vista de Django o cualquier otra cosa, sincrónicamente.  Tan pronto como el código sincrónico envíe una respuesta a Channel Layer, el servidor asincrónico lo dará, transmitirá, hará lo que sea necesario.  Por lo tanto, se realiza la abstracción. <br><br>  Esto implica varias implementaciones, y en producción se propone utilizar <strong>Twisted como un servidor asíncrono</strong> que implementa la interfaz para Django y <strong>Redis</strong> , que será el mismo canal de comunicación entre Django síncrono y Twisted asíncrono. <br><br><blockquote>  La buena noticia: para utilizar los canales de Django, no es necesario que conozca Twisted o Redis, estos son todos detalles de implementación.  Sus DevOps lo sabrán o se encontrarán cuando reparen una producción caída a las tres de la mañana. </blockquote><br><h2>  ASGI </h2><br>  La abstracción es un protocolo llamado ASGI.  Esta es la interfaz estándar que se encuentra entre cualquier interfaz de red, servidor, ya sea un protocolo síncrono o asíncrono y su aplicación.  Su concepto principal es el canal. <br><br><h3>  Canal </h3><br>  Un canal es una cola de mensajes primero en entrar, primero en salir que tienen una vida útil.  Estos mensajes se pueden entregar cero o una vez, y solo pueden ser recibidos por un Consumidor. <br><br><h3>  Los consumidores </h3><br>  En Consumer, solo está escribiendo su código. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ws_message</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function"> :</span></span> message.reply_channel.send ( { <span class="hljs-string"><span class="hljs-string">'text'</span></span>: message.content [<span class="hljs-string"><span class="hljs-string">'text'</span></span>], } )</code> </pre><br>  Una función que acepta un mensaje puede enviar varias respuestas, o puede no enviar una respuesta en absoluto.  Muy similar a la vista, la única diferencia es que no hay una función de retorno, por lo que podemos hablar sobre cuántas respuestas devolvemos de la función. <br><br>  Agregamos esta función al enrutamiento, por ejemplo, colgarlo para recibir un mensaje en un socket web. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.routing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> route <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> myapp.consumers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ws_message channel_routing = [ route (<span class="hljs-string"><span class="hljs-string">'websocket.receive'</span></span> ws_message), }</code> </pre><br>  Escribimos esto en la configuración de Django, tal como se prescribirá la base de datos. <br><br><pre> <code class="python hljs">CHANNEL_LAYERS = { <span class="hljs-string"><span class="hljs-string">'default'</span></span>: { <span class="hljs-string"><span class="hljs-string">'BACKEND'</span></span>: <span class="hljs-string"><span class="hljs-string">'asgiref.inmemory'</span></span>, <span class="hljs-string"><span class="hljs-string">'ROUTING'</span></span>: <span class="hljs-string"><span class="hljs-string">'myproject.routing'</span></span>, }, }</code> </pre><br>  Un proyecto puede tener múltiples capas de canal, al igual que puede haber múltiples bases de datos.  Esto es muy similar al enrutador db si alguien lo usó. <br><br>  A continuación, definimos nuestra aplicación ASGI.  Sincroniza cómo comienza Twisted y cómo comienzan los trabajadores sincronizados: todos necesitan esta aplicación. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.asgi <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> get_channel_layer os.environ.setdefault( <span class="hljs-string"><span class="hljs-string">'DJANGO_SETTINGS_MODULE'</span></span>, <span class="hljs-string"><span class="hljs-string">'myproject.settings'</span></span>, ) channel_layer = get_channel_layer()</code> </pre><br>  Después de eso, implemente el código: ejecute gunicorn, envíe de manera estándar una solicitud HTTP, sincrónicamente, con la vista, como está acostumbrado.  Iniciamos el servidor asincrónico, que estará al frente de nuestro Django sincrónico, y los trabajadores que procesarán los mensajes. <br><br><pre> <code class="python hljs">$ gunicorn myproject.wsgi $ daphne myproject.asgi:channel_layer $ django-admin runworker</code> </pre><br><h3>  Canal de respuesta </h3><br>  Como hemos visto, el mensaje tiene un concepto como Canal de respuesta.  ¿Por qué se necesita esto? <br><br>  Canal unidireccional, respectivamente recepción de WebSocket, conexión de WebSocket, desconexión de WebSocket: este es un canal común al sistema para los mensajes entrantes.  Un canal de respuesta es un canal que está estrictamente vinculado a la conexión del usuario.  En consecuencia, el mensaje tiene un canal de entrada y salida.  Este par le permite identificar de quién proviene este mensaje. <br><img src="https://habrastorage.org/webt/rp/_k/wm/rp_kwmeuccjs2bunsar-hoei9au.jpeg"><br><br><h3>  Grupos </h3><br>  Un grupo es una colección de canales.  Si enviamos un mensaje a un grupo, se envía automáticamente a todos los canales de este grupo.  Esto es conveniente porque a nadie le gusta escribir para bucles.  Además, la implementación de grupos generalmente se realiza utilizando las funciones nativas de la capa del canal, por lo que es más rápido que enviar mensajes uno por uno. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Group <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ws_connect</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function">:</span></span> Group (<span class="hljs-string"><span class="hljs-string">'chat'</span></span>).add (message.reply_channel) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ws_disconnect</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function">:</span></span> Group (<span class="hljs-string"><span class="hljs-string">'chat'</span></span>).discard(message.reply_channel) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ws_message</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function">:</span></span> Group (<span class="hljs-string"><span class="hljs-string">'chat'</span></span>). Send ({ <span class="hljs-string"><span class="hljs-string">'text'</span></span>: message.content [<span class="hljs-string"><span class="hljs-string">'text'</span></span>], })</code> </pre><br>  Los grupos también se agregan al enrutamiento de la misma manera. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.routing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> route <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> myapp.consumers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * channel_routing = [ route (<span class="hljs-string"><span class="hljs-string">'websocket.connect'</span></span> , ws_connect), route (<span class="hljs-string"><span class="hljs-string">'websocket.disconnect'</span></span> , ws_disconnect), route (<span class="hljs-string"><span class="hljs-string">'websocket.receive'</span></span> , ws_message), ]</code> </pre><br>  Y tan pronto como se agregue el canal al grupo, la respuesta se enviará a todos los usuarios que estén conectados a nuestro sitio, y no solo a la respuesta de eco para nosotros. <br><br><h3>  Consumidores genéricos </h3><br>  Lo que amo a Django es declarativo.  Del mismo modo, hay consumidores declarativos. <br><br>  Base Consumer es básico, solo puede asignar el canal que definió en algún método y llamarlo. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.generic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> BaseConsumer <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComsumer</span></span></span><span class="hljs-class"> </span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseConsumer)</span></span></span><span class="hljs-class"> :</span></span> method_mapping = { <span class="hljs-string"><span class="hljs-string">'channel.name.here'</span></span>: <span class="hljs-string"><span class="hljs-string">'method_name'</span></span>, } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method_name</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, message, **kwargs)</span></span></span><span class="hljs-function"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  Hay una gran cantidad de consumidores predefinidos con un comportamiento deliberadamente aumentado, como WebSocket Consumer, que determina de antemano que manejará la conexión WebSocket, la recepción WebSocket y la desconexión WebSocket.  Puede indicar inmediatamente en qué grupos agregar un canal de respuesta, y tan pronto como use self.send, él comprenderá si debe enviar esto a un grupo oa un usuario. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.generic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> WebsocketConsumer <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyConsumer</span></span></span><span class="hljs-class"> </span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(WebsocketConsumer)</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connection_groups</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'chat'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, message)</span></span></span><span class="hljs-function"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, text=None, bytes=None)</span></span></span><span class="hljs-function"> :</span></span> self.send (text=text, bytes=bytes)</code> </pre><br>  También hay una opción de consumidor de WebSocket con JSON, es decir, no texto, no bytes, pero JSON ya se analizará, lo cual es conveniente. <br><br>  En el enrutamiento, se agrega de la misma manera a través de route_class.  Myapp se toma en route_class, que se determina desde el consumidor, todos los canales se toman desde allí y todos los canales especificados en myapp se enrutan.  Escribe menos de esta manera. <br><br><h2>  Enrutamiento </h2><br>  Hablemos en detalle sobre el enrutamiento y lo que nos proporciona. <br><br>  En primer lugar, estos son filtros. <br><br><pre> <code class="python hljs">// app.js S = new WebSocket (<span class="hljs-string"><span class="hljs-string">'ws://localhost:8000/chat/'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># routing.py route('websocket.connect', ws_connect, path=r'^/chat/$')</span></span></code> </pre><br>  Esta puede ser la ruta que nos llegó desde el URI de conexión de socket web, o el método de solicitud http.  Puede ser cualquier campo de mensaje del canal, por ejemplo, para correo electrónico: texto, cuerpo, copia al carbón, lo que sea.  El número de argumentos de palabras clave para la ruta es arbitrario. <br><br>  El enrutamiento le permite hacer rutas anidadas.  Si varios consumidores están determinados por algunas características comunes, es conveniente agruparlos y agregar a todos a la ruta a la vez. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> route, include blog_routes = [ route ( <span class="hljs-string"><span class="hljs-string">'websocket.connect'</span></span>, blog, path = <span class="hljs-string"><span class="hljs-string">r'^/stream/'</span></span>) , ] routing = [ include (blog_routes, path= <span class="hljs-string"><span class="hljs-string">r'^/blog'</span></span> ), ]</code> </pre><br><h2>  Multiplexación </h2><br>  Si abrimos varios sockets web, cada uno tiene un URI diferente y podemos colgar varios manejadores en ellos.  Pero para ser honesto, abrir varias conexiones solo para hacer algo hermoso en el backend no parece un enfoque de ingeniería. <br><br>  Por lo tanto, es posible llamar a varios controladores en un socket web.  Definimos un WebsocketDemultiplexer que funciona con el concepto de transmisión dentro de un único socket web.  A través de esta transmisión, redirigirá su mensaje a otro canal. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> WebsocketDemultiplexer <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demultiplexer</span></span></span><span class="hljs-class"> </span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(WebsocketDemultiplexer)</span></span></span><span class="hljs-class"> :</span></span> mapping = { <span class="hljs-string"><span class="hljs-string">'intval'</span></span>: <span class="hljs-string"><span class="hljs-string">'binding.intval'</span></span>, }</code> </pre><br>  En el enrutamiento, el multiplexor se agrega de la misma manera que en cualquier otro consumidor declarativo route_class. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> route_class, route <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> .consumers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Demultiplexer, ws_message channel_routing = [ route_class (Demultiplexer, path=<span class="hljs-string"><span class="hljs-string">'^/binding/'</span></span>) , route (<span class="hljs-string"><span class="hljs-string">'binding.intval'</span></span>, ws_message ) , ]</code> </pre><br>  El argumento de flujo se agrega al mensaje para que el multiplexor pueda determinar dónde colocar el mensaje dado.  El argumento de la carga útil contiene todo lo que entra en el canal después de que el multiplexor lo procesa. <br><br>  Es muy importante tener en cuenta que en Channel Layer, el mensaje se obtendrá <strong>dos veces</strong> : antes del multiplexor y después del multiplexor.  Por lo tanto, tan pronto como comience a usar el multiplexor, automáticamente agregará latencia a sus solicitudes. <br><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">"stream"</span></span> : <span class="hljs-string"><span class="hljs-string">"intval"</span></span>, <span class="hljs-string"><span class="hljs-string">"payload"</span></span> : { … } }</code> </pre><br><h2>  Sesiones </h2><br>  Cada canal tiene sus propias sesiones.  Esto es algo muy conveniente, por ejemplo, para almacenar el estado entre llamadas a manejadores.  Puede agruparlos por canal de respuesta, ya que este es un identificador que pertenece al usuario.  La sesión se almacena en el mismo motor que la sesión http normal.  Por razones obvias, las cookies firmadas no son compatibles, simplemente no están en el socket web. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.sessions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> channel_session @channel_session <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ws_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function"> :</span></span> room=message.content [<span class="hljs-string"><span class="hljs-string">'path'</span></span>] message.channel_session [<span class="hljs-string"><span class="hljs-string">'room'</span></span>] = room Croup (<span class="hljs-string"><span class="hljs-string">'chat-%s'</span></span> % room).add ( message.reply_channel )</code> </pre><br>  Durante la conexión, puede obtener una sesión http y usarla en su consumidor.  Como parte del proceso de negociación, al configurar una conexión de socket web, se envían cookies al usuario.  En consecuencia, por lo tanto, puede obtener una sesión de usuario, obtener el objeto de usuario que solía usar en Django antes, como si estuviera trabajando con view. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.sessions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> http_session_user @http_session_user <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ws_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function"> :</span></span> message.http_session [<span class="hljs-string"><span class="hljs-string">'room'</span></span>] = room <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> message.user.username : …</code> </pre><br><h2>  Orden del mensaje </h2><br>  Los canales pueden resolver un problema muy importante.  Si establecemos una conexión a un socket web y enviamos de inmediato, esto lleva al hecho de que los dos eventos, WebSocket connect y WebSocket reciben, están muy cerca en el tiempo.  Es muy probable que el consumidor de estos sockets web se ejecute en paralelo.  Depurar esto será muy divertido. <br><br>  Los canales de Django le permiten ingresar el bloqueo de dos tipos: <br><br><ol><li>  <strong>Cerradura</strong> <strong>fácil</strong> .  Usando el mecanismo de sesión, garantizamos que hasta que el consumidor sea procesado para recibir un mensaje, no procesaremos ningún mensaje en los sockets web.  Una vez establecida la conexión, el orden es arbitrario, es posible la ejecución paralela. </li><li>  <strong>Bloqueo</strong> <strong>duro</strong> : solo se ejecuta un consumidor de un usuario en particular a la vez.  Esto es una sobrecarga para la sincronización, ya que utiliza un motor de sesión lenta.  Sin embargo, existe tal oportunidad. </li></ol><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.generic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> WebsocketConsumer <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyConsumer</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(WebsocketConsumer)</span></span></span><span class="hljs-class"> :</span></span> http_user = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> slight_ordering = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> strict_ordering = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connection_groups</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, **kwargs)</span></span></span><span class="hljs-function"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'chat'</span></span>]</code> </pre><br>  Para escribir esto, hay los mismos decoradores que vimos anteriormente en la sesión http, sesión de canal.  En el consumidor declarativo, simplemente puede escribir atributos, tan pronto como los escriba, esto se aplicará automáticamente a todos los métodos de este consumidor. <br><br><h2>  Enlace de datos </h2><br>  En un momento, Meteor se hizo famoso por el enlace de datos. <br><br>  Abrimos dos navegadores, vamos a la misma página y en uno de ellos hacemos clic en la barra de desplazamiento.  Al mismo tiempo, en el segundo navegador, en esta página, la barra de desplazamiento cambia su valor.  Esto es genial <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntegerValueBinding</span></span></span><span class="hljs-class"> </span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(WebsocketBinding)</span></span></span><span class="hljs-class"> :</span></span> model = IntegerValue stream = intval<span class="hljs-string"><span class="hljs-string">' fields= ['</span></span>name<span class="hljs-string"><span class="hljs-string">', '</span></span>value<span class="hljs-string"><span class="hljs-string">'] def group_names (self, instance, action ) : return ['</span></span>intval-updates<span class="hljs-string"><span class="hljs-string">'] def has_permission (self, user, action, pk) : return True</span></span></code> </pre><br>  Django ahora hace lo mismo. <br><br>  Esto se implementa utilizando los ganchos proporcionados por <strong>Django Signals</strong> .  Si se define el enlace para el modelo, todas las conexiones que están en el grupo para esta instancia del modelo serán notificadas de cada evento.  Creamos un modelo, cambiamos el modelo, lo eliminamos; todo esto será una advertencia.  La notificación se produce en los campos indicados: el valor de este campo ha cambiado; se está formando una carga útil que se envía a través del socket web.  Esto es conveniente <br><br>  Es importante comprender que si en nuestro ejemplo hacemos clic constantemente en la barra de desplazamiento, los mensajes irán constantemente y el modelo se guardará.  Esto funcionará hasta una cierta carga, entonces todo descansa contra la base. <br><br><h2>  Capa Redis </h2><br>  Hablemos un poco más sobre cómo se organiza el Channel Layer más popular para la producción: Redis. <br><br>  Está bien organizado: <br><br><ul><li>  trabaja con conexiones sincrónicas a nivel de trabajadores; </li><li>  muy amigable con Twisted, no se ralentiza, donde es especialmente necesario, es decir, en su servidor front-end; </li><li>  MSGPACK se usa para serializar mensajes dentro de Redis, lo que reduce la huella en cada mensaje; </li><li>  puede distribuir la carga a varias instancias de Redis, se barajará automáticamente usando el algoritmo hash consistente.  Por lo tanto, un solo punto de falla desaparece. </li></ul><br>  Un canal es solo una lista de identificación de Redis.  Por id es el valor de un mensaje en particular.  Esto se hace para que pueda controlar la vida de cada mensaje y canal por separado.  En principio, esto es lógico. <br><br><pre> <code class="python hljs">&gt;&gt; SET <span class="hljs-string"><span class="hljs-string">"b6dc0dfce"</span></span> <span class="hljs-string"><span class="hljs-string">" \x81\xa4text\xachello"</span></span> &gt;&gt; RPUSH <span class="hljs-string"><span class="hljs-string">"websocket.send!sGOpfny"</span></span> <span class="hljs-string"><span class="hljs-string">"b6dc0dfce"</span></span> &gt;&gt; EXPIRE <span class="hljs-string"><span class="hljs-string">"b6dc0dfce"</span></span> <span class="hljs-string"><span class="hljs-string">"60"</span></span> &gt;&gt; EXPIRE <span class="hljs-string"><span class="hljs-string">"websocket.send!sGOpfny"</span></span> <span class="hljs-string"><span class="hljs-string">"61"</span></span></code> </pre><br>  Los grupos se implementan por conjuntos ordenados.  La distribución a grupos se realiza dentro del script Lua, esto es muy rápido. <br><br><pre> <code class="python hljs">&gt;&gt; type group:chat zset &gt;&gt; ZRANGE group:chat <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> WITHSCORES <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"websocket.send!sGOpfny"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"1476199781.8159261"</span></span></code> </pre><br><h2>  Problemas </h2><br>  Veamos qué problemas tiene este enfoque. <br><br><h3>  Callback hell </h3><br>  El primer problema es el infierno de devolución de llamadas recién inventado.  Es muy importante comprender que la mayoría de los problemas con los canales con los que se encontrará serán de estilo: llegaron al consumidor argumentos que no esperaba.  De dónde vinieron, quién los puso en Redis: todo esto es una dudosa tarea de investigación.  Depuración de sistemas distribuidos en general para los de carácter fuerte.  AsyncIO resuelve este problema. <br><br><h3>  Apio </h3><br>  En Internet, escriben que Django Channels es un reemplazo para Celery. <br><img src="https://habrastorage.org/webt/x9/be/j8/x9bej8oul6vevk2r8e12q9-i_ia.jpeg"><br>  Tengo malas noticias para ti, no, no es eso. <br><br>  En canales: <br><br><ul><li>  no vuelva a intentarlo, no puede retrasar la ejecución de un controlador; <br></li><li>  sin lienzo, solo una devolución de llamada.  El apio también proporciona grupos, cadenas, mi acorde favorito, que, después de ejecutar grupos en paralelo, provoca otra devolución de llamada con sincronización.  Todo esto no está en canales; </li><li>  no hay una configuración de la hora de llegada de los mensajes, algunos sistemas sin esto son simplemente imposibles de diseñar. </li></ul><br><blockquote>  Veo el futuro como un soporte oficial para usar canales y apio juntos, con un costo mínimo y un esfuerzo mínimo.  Pero Django Channels no es un reemplazo para el apio. <br></blockquote><br><h2>  Django para web moderna </h2><br>  Django Channels es Django para la web moderna.  Este es el mismo Django que todos estamos acostumbrados a usar: sincrónico, declarativo, con muchas baterías.  Django Channels es solo más una batería.  Siempre debe comprender dónde usarlo y si vale la pena hacerlo.  Si no se necesita Django en el proyecto, tampoco se necesitan canales allí.  Son útiles solo en aquellos proyectos en los que Django está justificado. <br><br><blockquote>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Moscow Python Conf ++</a></strong> <br><br>  Una conferencia profesional para desarrolladores de Python llega a un nuevo nivel: los <strong>días 22 y 23 de octubre de</strong> 2018 reuniremos a los 600 mejores programadores de Python en Rusia, presentaremos los informes más interesantes y, por supuesto, crearemos un entorno para establecer contactos en las mejores tradiciones de la comunidad de Python de Moscú con el apoyo del equipo de Ontiko. <br><br>  Invitamos a expertos a hacer un informe.  El comité del programa ya está trabajando y acepta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solicitudes</a> hasta el 7 de septiembre. <br><br>  Para los participantes, se está llevando a cabo un programa de lluvia de ideas en línea.  Puede agregar temas faltantes a este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documento</a> u oradores de inmediato cuyos discursos le interesen.  El documento se actualizará, de hecho, todo el tiempo que pueda seguir la formación del programa. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418445/">https://habr.com/ru/post/es418445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418433/index.html">4 de agosto Peter La primera búsqueda de bicicletas para programadores</a></li>
<li><a href="../es418437/index.html">Oc equipo al rescate</a></li>
<li><a href="../es418439/index.html">Conceptos básicos de aplicaciones web progresivas</a></li>
<li><a href="../es418441/index.html">Conceptos básicos de escalada de privilegios de Windows</a></li>
<li><a href="../es418443/index.html">GObject: encapsulación, instanciación, introspección</a></li>
<li><a href="../es418447/index.html">Por qué Moscú Python Conf es ahora ++</a></li>
<li><a href="../es418449/index.html">Módulos binarios para Python</a></li>
<li><a href="../es418451/index.html">Lecciones de impresión 3D. Soporte efectivo y cambio de altura de capa en la práctica desde 3Dtool</a></li>
<li><a href="../es418453/index.html">Las observaciones de GRAVEDAD validan aún más la relatividad general</a></li>
<li><a href="../es418455/index.html">Webinar abierto "Especialista en el timón: primera experiencia y errores"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>