<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèº üë©üèª‚Äç‚öñÔ∏è ü•ò Perspective: MultiClet S1 ü•å üè™ üßíüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il est donc temps de parler de la prochaine g√©n√©ration de processeurs multicellulaires: MultiClet S1. Si c'est la premi√®re fois que vous en entendez p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perspective: MultiClet S1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434982/"><img src="https://habrastorage.org/webt/fx/3k/yv/fx3kyvqsb8hquivzhowomntx-xe.jpeg"><br><br>  Il est donc temps de parler de la prochaine g√©n√©ration de processeurs multicellulaires: MultiClet S1.  Si c'est la premi√®re fois que vous en entendez parler, assurez-vous de consulter l'histoire et l'id√©ologie de l'architecture dans ces articles: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Un processeur multicellulaire, c'est quoi?"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Multiclet R1 - les premiers tests"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Compilateur C / C ++ bas√© sur LLVM pour processeurs multicellulaires: √™tre ou ne pas √™tre?"</a> </li></ul><br>  Pour le moment, le nouveau processeur est en cours de d√©veloppement, mais les premiers r√©sultats sont d√©j√† apparus et vous pouvez √©valuer de quoi il sera capable. <br><a name="habracut"></a><br>  Commen√ßons par les plus grands changements: les fonctionnalit√©s de base. <br><br><h2>  CARACT√âRISTIQUES </h2><br>  Il est pr√©vu d'atteindre les indicateurs suivants: <br><br><ol><li>  Nombre d'alv√©oles: 64 </li><li>  Processus technique: 28 nm </li><li>  Fr√©quence d'horloge: 1,6 GHz </li><li>  La taille de la m√©moire sur la puce: 8 Mo </li><li>  Surface cristalline: 40 mm <sup>2</sup> </li><li>  Consommation √©lectrique: 6 W </li></ol><br>  Les chiffres r√©els seront annonc√©s sur la base des r√©sultats des tests des √©chantillons fabriqu√©s en 2019.  En plus des caract√©ristiques de la puce elle-m√™me, le processeur prendra en charge jusqu'√† 16 Go de RAM standard DDR4 3200 MHz, bus PCI Express et PLL. <br><br>  Il convient de noter que le processus de fabrication √† 28 nm est la gamme la plus basse des m√©nages qui ne n√©cessite pas d'autorisations sp√©ciales pour l'utilisation, c'est donc lui qui a √©t√© choisi.  Par le nombre de cellules, diff√©rentes options ont √©t√© envisag√©es: 128 et 256, mais avec une augmentation de la surface du cristal, le pourcentage de rejets augmente.  Nous nous sommes install√©s sur 64 cellules et, par cons√©quent, une zone relativement petite, ce qui donnera un plus grand rendement de cristaux appropri√©s sur la plaque.  D'autres d√©veloppements sont possibles dans le cadre de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ICS (syst√®me dans le cas)</a> , o√π il sera possible de combiner plusieurs cristaux √† 64 cellules dans un cas. <br><br>  Il faut dire que le but et l'utilisation du processeur changent radicalement.  S1 ne sera pas un microprocesseur con√ßu pour l'int√©gration, comme l'ont √©t√© P1 et R1, mais un acc√©l√©rateur de calculs.  Tout comme GPGPU, une carte bas√©e sur S1 peut √™tre ins√©r√©e dans la carte m√®re PCI Express d'un PC ordinaire et utilis√©e pour le traitement des donn√©es. <br><br><h2>  L'architecture </h2><br>  En S1, le ¬´multicellule¬ª est d√©sormais l'unit√© de calcul minimale: un ensemble de 4 cellules ex√©cutant une certaine s√©quence de commandes.  Au d√©but, il √©tait pr√©vu de combiner des multicellules en groupes appel√©s un cluster pour l'ex√©cution conjointe de commandes: un cluster devait contenir 4 multicellules, au total il y avait 4 clusters s√©par√©s sur un cristal.  Cependant, chaque cellule a une connexion compl√®te avec toutes les autres cellules du cluster, et avec une augmentation du groupe de liaisons, elle devient trop importante, ce qui complique consid√©rablement la conception topologique du microcircuit et r√©duit ses caract√©ristiques.  Par cons√©quent, ils ont d√©cid√© d'abandonner la division en grappes, car la complication ne justifie pas les r√©sultats.  De plus, pour des performances maximales, il est plus avantageux d'ex√©cuter du code en parall√®le sur chaque multicellule.  Total, maintenant le processeur contient 16 multicellules distinctes. <br><br>  Une multicellule, bien qu'elle se compose de 4 cellules, diff√®re d'une R1 √† 4 cellules, dans laquelle chaque cellule a sa propre m√©moire, son propre bloc de commandes d'√©chantillons, sa propre ALU.  S1 est arrang√© un peu diff√©remment.  ALU comprend 2 parties: un bloc arithm√©tique √† virgule flottante et un bloc arithm√©tique entier.  Chaque cellule a un bloc entier s√©par√©, mais il n'y a que deux blocs √† virgule flottante dans une multicellule, et donc deux paires de cellules les divisent entre elles.  Cela a √©t√© fait principalement pour r√©duire la surface du cristal: l'arithm√©tique √† virgule flottante 64 bits, contrairement √† l'arithm√©tique enti√®re, prend beaucoup de place.  Avoir une telle ALU sur chaque cellule s'est av√©r√© √™tre redondant: la r√©cup√©ration des commandes ne fournit pas de chargement ALU et elles sont inactives.  Tout en r√©duisant le nombre de blocs ALU et en maintenant le rythme des exemples de commandes et de donn√©es, comme le montre la pratique, le temps total pour r√©soudre les probl√®mes ne change pratiquement pas ou change l√©g√®rement, et les blocs ALU sont enti√®rement charg√©s.  De plus, l'arithm√©tique √† virgule flottante n'est pas utilis√©e aussi souvent qu'avec l'entier. <br><br>  Une vue sch√©matique des blocs de processeurs R1 et S1 est pr√©sent√©e dans le sch√©ma ci-dessous.  Ici: <br><br><ul><li>  CU (Control Unit) - unit√© de r√©cup√©ration d'instructions </li><li>  ALU <sub>FX</sub> - unit√© arithm√©tique et logique d'arithm√©tique enti√®re </li><li>  ALU <sub>FP</sub> - Unit√© logique arithm√©tique d'arithm√©tique √† virgule flottante </li><li>  DMS (Data Memory Scheduler) - unit√© de commande de m√©moire de donn√©es </li><li>  DM - m√©moire de donn√©es </li><li>  PMS (Program Memory Scheduler) - unit√© de commande de m√©moire de programme </li><li>  PM - m√©moire de programme </li></ul><br><img src="https://habrastorage.org/webt/6t/4n/dp/6t4ndpu7d_koh8rpn8dmx0-b7ho.png"><br><br>  Diff√©rences architecturales S1: <br><br><ol><li>  Les √©quipes peuvent d√©sormais acc√©der aux r√©sultats des √©quipes des paragraphes pr√©c√©dents.  Il s'agit d'un changement tr√®s important qui vous permet d'acc√©l√©rer consid√©rablement les transitions lors de la branche du code.  Les processeurs P1 et R1 n'avaient d'autre choix que d'√©crire les r√©sultats souhait√©s dans la m√©moire et de les relire imm√©diatement avec les toutes premi√®res commandes du nouveau paragraphe.  M√™me lors de l'utilisation de la m√©moire sur une puce, les op√©rations d'√©criture et de lecture prennent de 2 √† 5 cycles chacune, ce qui peut √™tre enregistr√© en se r√©f√©rant simplement au r√©sultat de la commande du paragraphe pr√©c√©dent </li><li>  L'√©criture dans la m√©moire et les registres se produit d√©sormais imm√©diatement, et non √† la fin d'un paragraphe, ce qui vous permet de commencer √† √©crire des commandes avant la fin du paragraphe.  Par cons√©quent, les temps d'arr√™t potentiels entre les paragraphes sont r√©duits. </li><li>  Le syst√®me de commande a √©t√© optimis√©, √† savoir: <br><ul><li>  Ajout de l'arithm√©tique enti√®re 64 bits: addition, soustraction, multiplication de nombres 32 bits, qui renvoie un r√©sultat 64 bits. </li><li>  La m√©thode de lecture √† partir de la m√©moire a √©t√© modifi√©e: d√©sormais, pour <b>toute</b> commande, vous pouvez simplement sp√©cifier l'adresse √† partir de laquelle vous souhaitez lire les donn√©es comme argument, tandis que la s√©quence de commandes de lecture et d'√©criture est pr√©serv√©e. <br><br>  Il a √©galement rendu obsol√®te une commande de lecture de m√©moire distincte.  Au lieu de cela, la commande de valeur de chargement est utilis√©e dans le commutateur de <b>chargement</b> (pr√©c√©demment, <b>get</b> ), en sp√©cifiant l'adresse en m√©moire comme argument: <br><br><pre><code class="plaintext hljs">.data foo: .long 0x1234 .text habr: load_l foo ;      foo load_l [foo] ;    0x1234 add_l [foo], 0xABCD ;       ;   complete</code> </pre> <br></li><li>  Un format de commande a √©t√© ajout√© qui permet l'utilisation de 2 arguments constants. <br>  Auparavant, vous ne pouviez sp√©cifier une constante que comme deuxi√®me argument, le premier argument devrait toujours √™tre un lien vers le r√©sultat dans le commutateur.  La modification s'applique √† toutes les √©quipes √† deux arguments.  Le champ constant est toujours 32 bits, donc ce format permet, par exemple, de g√©n√©rer des constantes 64 bits avec une seule commande. <br><br>  C'√©tait: <br><br><pre> <code class="plaintext hljs">load_l 0x12345678 patch_q @1, 0xDEADBEEF</code> </pre><br>  C'est devenu: <br><br><pre> <code class="plaintext hljs">patch_q 0x12345678, 0xDEADBEEF</code> </pre> <br></li><li>  Types de donn√©es vectorielles modifi√©es et compl√©t√©es. <br>  Ce que l'on appelait autrefois les types de donn√©es ¬´compact√©s¬ª peut d√©sormais √™tre appel√© en toute s√©curit√© vectoriel.  En P1 et R1, les op√©rations sur les nombres emball√©s ne prenaient qu'une constante comme deuxi√®me argument, c'est-√†-dire, par exemple, lors de l'ajout, chaque √©l√©ment du vecteur √©tait ajout√© avec le m√™me nombre, et cela ne pouvait pas √™tre appliqu√© intelligemment.  Maintenant, des op√©rations similaires peuvent √™tre appliqu√©es √† deux vecteurs complets.  De plus, cette fa√ßon de travailler avec des vecteurs est parfaitement coh√©rente avec le m√©canisme des vecteurs dans LLVM, qui permet d√©sormais au compilateur de g√©n√©rer du code √† l'aide de types vectoriels. <br><br><pre> <code class="plaintext hljs">patch_q 0x00010002, 0x00030004 patch_q 0x00020003, 0x00040005 mul_ps @1, @2 ;  - 00020006000C0014</code> </pre><br></li></ul><br></li><li>  Suppression des drapeaux du processeur. <br><br>  En cons√©quence, environ 40 √©quipes bas√©es uniquement sur les valeurs des drapeaux ont √©t√© supprim√©es.  Cela a consid√©rablement r√©duit le nombre d'√©quipes et, par cons√©quent, la surface du cristal.  Et toutes les informations n√©cessaires sont d√©sormais stock√©es directement dans la cellule de commutation. <br><br><ul><li>  Lors de la comparaison avec z√©ro, au lieu du drapeau z√©ro, maintenant seule la valeur dans le commutateur est utilis√©e </li><li>  Au lieu de l'indicateur de signe, un bit correspondant au type de commande est d√©sormais utilis√©: 7e pour l'octet, 15e pour le court, 31e pour le long, 63e pour le quad.  √âtant donn√© que le caract√®re se multiplie jusqu'au 63e bit, quel que soit le type, vous pouvez comparer des nombres de types diff√©rents: <br><br><pre> <code class="plaintext hljs">.data long: .long -0x1000 byte: .byte -0x10 .text habr: a := load_b [byte] ;     0xFFFFFFFFFFFFFFF0, ;   byte 7    63. b := loadu_b [byte] ;     0x00000000000000F0, ; ..  loadu_b    c := load_l [long] ;     0xFFFFFFFFFFFFF000. ge_l @a, @c ;   "  "  1: ;   31 ,   . lt_s @a, @b ; 1, .. b     complete</code> </pre><br></li><li>  L'indicateur de portage n'est plus n√©cessaire, car il existe une arithm√©tique 64 bits </li></ul><br></li><li>  Le temps de transition d'un paragraphe √† l'autre a √©t√© r√©duit √† 1 mesure (au lieu de 2-3 dans R1) </li></ol><br><h2>  Compilateur bas√© sur LLVM </h2><br>  Le compilateur de langage C pour S1 est similaire √† R1, et comme l'architecture n'a pas fondamentalement chang√©, les probl√®mes d√©crits dans l'article pr√©c√©dent n'ont malheureusement pas disparu. <br><br>  Cependant, dans le processus de mise en ≈ìuvre du nouveau syst√®me de commande, la quantit√© de code de sortie a diminu√© d'elle-m√™me, simplement en raison de la mise √† jour du syst√®me de commande.  En outre, il existe de nombreuses autres optimisations mineures qui r√©duiront le nombre d'instructions dans le code, dont certaines ont d√©j√† √©t√© effectu√©es (par exemple, la g√©n√©ration de constantes 64 bits avec une seule instruction).  Mais il y a des optimisations encore plus s√©rieuses qui doivent √™tre faites, et elles peuvent √™tre construites par ordre croissant d'efficacit√© et de complexit√© de mise en ≈ìuvre: <br><br><ol><li>  La possibilit√© de g√©n√©rer toutes les commandes √† deux arguments avec deux constantes. <br><br>  La g√©n√©ration d'une constante 64 bits via patch_q n'est qu'un cas sp√©cial, mais nous en avons besoin d'un g√©n√©ral.  En fait, le but de cette optimisation est de permettre aux √©quipes de remplacer uniquement le premier argument par une constante, car le deuxi√®me argument pourrait toujours √™tre une constante, et cela a longtemps √©t√© impl√©ment√©.  Ce n'est pas un cas tr√®s fr√©quent, mais, par exemple, lorsque vous devez appeler une fonction et en √©crire l'adresse de retour en haut de la pile, vous pouvez <br><br><pre> <code class="plaintext hljs">load_l func wr_l @1, #SP</code> </pre><br>  optimiser pour <br><br><pre> <code class="plaintext hljs">wr_l func, #SP</code> </pre><br></li><li>  La possibilit√© de remplacer l'acc√®s √† la m√©moire via un argument dans n'importe quelle commande. <br>  Par exemple, si vous devez ajouter deux nombres de la m√©moire, vous pouvez <br><br><pre> <code class="plaintext hljs">load_l [foo] load_l [bar] add_l @1, @2</code> </pre><br>  optimiser pour <br><br><pre> <code class="plaintext hljs">add_l [foo], [bar]</code> </pre><br>  Cette optimisation est une extension de la pr√©c√©dente, cependant, une analyse est d√©j√† n√©cessaire ici: un tel remplacement ne peut √™tre effectu√© que si les valeurs charg√©es ne sont utilis√©es qu'une seule fois dans cette commande d'addition et nulle part ailleurs.  Si le r√©sultat de la lecture est utilis√© m√™me dans seulement deux commandes, il est plus avantageux de lire une fois dans la m√©moire en tant que commande distincte, et dans les deux autres de s'y r√©f√©rer via le commutateur. <br></li><li>  Optimisation du transfert des registres virtuels entre les unit√©s de base. <br>  Pour R1, le transfert de tous les registres virtuels se faisait par la m√©moire, ce qui donne lieu √† un tr√®s grand nombre de lectures et d'√©critures en m√©moire, mais il n'y avait tout simplement pas d'autre moyen de transf√©rer des donn√©es entre les paragraphes.  S1 vous permet d'acc√©der aux r√©sultats des commandes des paragraphes pr√©c√©dents, par cons√©quent, th√©oriquement, de nombreuses op√©rations de m√©moire peuvent √™tre supprim√©es, ce qui donnerait le plus grand effet parmi toutes les optimisations.  Cependant, cette approche est encore limit√©e par le switch: pas plus de 63 r√©sultats pr√©c√©dents, si loin de chaque transfert du registre virtuel, peuvent √™tre impl√©ment√©s comme √ßa.  Comment proc√©der n'est pas une t√¢che triviale, et une analyse des possibilit√©s de r√©solution reste √† faire.  Les sources du compilateur peuvent appara√Ætre dans le domaine public, donc si quelqu'un a des id√©es et que vous souhaitez rejoindre le d√©veloppement, vous pouvez le faire. <br></li></ol><br><h2>  Rep√®res </h2><br>  Le processeur n'√©tant pas encore sorti sur la puce, il est difficile d'√©valuer ses performances r√©elles.  Cependant, le code du noyau RTL est d√©j√† pr√™t, ce qui signifie que vous pouvez effectuer une √©valuation √† l'aide de la simulation ou du FPGA.  Pour ex√©cuter les benchmarks suivants, nous avons utilis√© une simulation √† l'aide du programme ModelSim pour calculer le temps d'ex√©cution exact (en mesures).  Puisqu'il est difficile de simuler le cristal entier et que cela prend tr√®s longtemps, une multicellule a donc √©t√© simul√©e et le r√©sultat a √©t√© multipli√© par 16 (si la t√¢che est con√ßue pour le multithreading), car chaque multicellule peut fonctionner de mani√®re compl√®tement ind√©pendante des autres. <br><br>  Dans le m√™me temps, une mod√©lisation multicellulaire a √©t√© effectu√©e sur Xilinx Virtex-6 pour tester les performances du code processeur sur du mat√©riel r√©el. <br><br><h4>  Coremark </h4><br>  CoreMark - un ensemble de tests pour une √©valuation compl√®te des performances des microcontr√¥leurs et des processeurs centraux, ainsi que de leurs compilateurs C.  Comme vous pouvez le voir, le processeur S1 n'est ni l'un ni l'autre.  Cependant, il est destin√© √† ex√©cuter un code d'arbitrage absolu, c'est-√†-dire  toute personne pouvant s'ex√©cuter sur le processeur central.  CoreMark convient donc pour √©valuer les performances de S1 pas pire. <br><br>  CoreMark contient du travail avec des listes li√©es, des matrices, une machine d'√©tat et un calcul de somme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CRC</a> .  En g√©n√©ral, la plupart du code se r√©v√®le √™tre strictement s√©quentiel (qui teste le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parall√©lisme mat√©riel</a> multicellulaire pour la force) et avec de nombreuses branches, c'est pourquoi les capacit√©s du compilateur jouent un r√¥le important dans les performances finales.  Le code compil√© contient pas mal de courts paragraphes et malgr√© le fait que la vitesse de transition entre eux ait augment√©, la ramification inclut le travail avec la m√©moire, ce que nous aimerions √©viter au maximum. <br><br>  Carte de performance CoreMark: <br><table><tbody><tr><th></th><th>  Multiclet R1 (compilateur llvm) </th><th>  <b>Multiclet S1 (compilateur llvm)</b> </th><th>  Elbrus-4C (R500 / E) </th><th>  Texas Inst.  AM5728 ARM Cortex-A15 </th><th>  Baikal-t1 </th><th>  Intel Core i7 7700K </th></tr><tr><td>  Ann√©e de fabrication </td><td>  2015 </td><td>  <b>2019</b> </td><td>  2014 </td><td>  2018 </td><td>  2016 </td><td>  2017 </td></tr><tr><td>  Fr√©quence d'horloge, MHz </td><td>  100 </td><td>  <b>1600</b> </td><td>  700 </td><td>  1500 </td><td>  1200 </td><td>  4500 </td></tr><tr><td>  Score global CoreMark </td><td>  59 </td><td>  <b>18356</b> </td><td>  1214 </td><td>  15789 </td><td>  13142 </td><td>  182128 </td></tr><tr><td>  Coremark / MHz </td><td>  0,59 </td><td>  <b>11,47</b> </td><td>  5,05 </td><td>  10,53 </td><td>  10,95 </td><td>  40,47 </td></tr></tbody></table><br>  Le r√©sultat d'une multicellule est 1147, ou 0,72 / MHz, ce qui est sup√©rieur √† celui de R1.  Cela parle des avantages du d√©veloppement d'une architecture multicellulaire dans le nouveau processeur. <br><br><h4>  Wheatstone </h4><br>  Whetstone - un ensemble de tests pour mesurer les performances du processeur lorsque vous travaillez avec des nombres √† virgule flottante.  Ici, la situation est bien meilleure: le code est √©galement s√©quentiel, mais sans grand nombre de branches et avec une bonne concurrence interne. <br><br>  Whetstone se compose de nombreux modules, ce qui vous permet de mesurer non seulement le r√©sultat global, mais √©galement les performances de chaque module sp√©cifique: <br><br><ol><li>  √âl√©ments du tableau </li><li>  Tableau comme param√®tre </li><li>  Sauts conditionnels </li><li>  Arithm√©tique enti√®re </li><li>  Fonctions trigonom√©triques (tan, sin, cos) </li><li>  Appels de proc√©dure </li><li>  R√©f√©rences de tableau </li><li>  Fonctions standard (sqrt, exp, log) </li></ol><br>  Ils sont divis√©s en cat√©gories: les modules 1, 2 et 6 mesurent les performances des op√©rations en virgule flottante (lignes MFLOPS1-3);  modules 5 et 8 - fonctions math√©matiques (COS MOPS, EXP MOPS);  modules 4 et 7 - arithm√©tique enti√®re (FIXPT MOPS, EQUAL MOPS);  module 3 - sauts conditionnels (IF MOPS).  Dans le tableau ci-dessous, la deuxi√®me ligne de MWIPS est un indicateur g√©n√©ral. <br><br>  Contrairement √† CoreMark, Whetstone sera compar√© sur un c≈ìur ou, comme dans notre cas, sur une multicellule.  √âtant donn√© que le nombre de c≈ìurs est tr√®s diff√©rent dans les diff√©rents processeurs, alors, pour la puret√© de l'exp√©rience, nous consid√©rons les indicateurs par m√©gahertz. <br><br>  Tableau de bord Whetstone: <br><table><tbody><tr><th>  CPU </th><th>  MultiClet R1 </th><th>  <b>MultiClet S1</b> </th><th>  Core i7 4820K </th><th>  ARM v8-A53 </th></tr><tr><td>  Fr√©quence, MHz </td><td>  100 </td><td>  <b>1600</b> </td><td>  3900 </td><td>  1300 </td></tr><tr><td>  MWIPS / MHz </td><td>  0,311 </td><td>  <b>0,343</b> </td><td>  0,887 </td><td>  0,642 </td></tr><tr><td>  MFLOPS1 / MHz </td><td>  0,157 </td><td>  <b>0,156</b> </td><td>  0,341 </td><td>  0,268 </td></tr><tr><td>  MFLOPS2 / MHz </td><td>  0,153 </td><td>  <b>0,111</b> </td><td>  0,308 </td><td>  0,241 </td></tr><tr><td>  MFLOPS3 / MHz </td><td>  0,029 </td><td>  <b>0,124</b> </td><td>  0,167 </td><td>  0,239 </td></tr><tr><td>  COS MOPS / MHz </td><td>  0,018 </td><td>  <b>0,008</b> </td><td>  0,023 </td><td>  0,028 </td></tr><tr><td>  EXP MOPS / MHz </td><td>  0,008 </td><td>  <b>0,005</b> </td><td>  0,014 </td><td>  0,004 </td></tr><tr><td>  FIXPT MOPS / MHz </td><td>  0,714 </td><td>  <b>0,116</b> </td><td>  0,998 </td><td>  1,197 </td></tr><tr><td>  SI MOPS / MHz </td><td>  0,081 </td><td>  <b>0,196</b> </td><td>  1,504 </td><td>  1,436 </td></tr><tr><td>  EGAL MOPS / MHz </td><td>  0,143 </td><td>  <b>0,149</b> </td><td>  0,251 </td><td>  0,439 </td></tr></tbody></table><br>  Whetstone contient des op√©rations de calcul beaucoup plus directement que CoreMark (ce qui est tr√®s visible en regardant le code ci-dessous), il est donc important de se rappeler ici: le nombre d'ALU √† virgule flottante est divis√© par deux.  Cependant, la vitesse de calcul n'a presque pas √©t√© affect√©e, par rapport √† R1. <br><br>  Certains modules s'int√®grent tr√®s bien sur une architecture multicellulaire.  Par exemple, le module 2 compte beaucoup de valeurs dans un cycle, et gr√¢ce √† la prise en charge compl√®te des nombres √† virgule flottante double pr√©cision par le processeur et le compilateur, apr√®s la compilation, nous obtenons de grands et beaux paragraphes qui r√©v√®lent vraiment les capacit√©s de calcul d'une architecture multicellulaire: <br><br><div class="spoiler">  <b class="spoiler_title">Grand et beau paragraphe pour 120 √©quipes</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pa: SR4 := loadu_q [#SP + 16] SR5 := loadu_q [#SP + 8] SR6 := loadu_l [#SP + 4] SR7 := loadu_l [#SP] setjf_l @0, @SR7 SR8 := add_l @SR6, 0x8 SR9 := add_l @SR6, 0x10 SR10 := add_l @SR6, 0x18 SR11 := loadu_q [@SR6] SR12 := loadu_q [@SR8] SR13 := loadu_q [@SR9] SR14 := loadu_q [@SR10] SR15 := add_d @SR11, @SR12 SR11 := add_d @SR15, @SR13 SR15 := sub_d @SR11, @SR14 SR11 := mul_d @SR15, @SR5 SR15 := add_d @SR12, @SR11 SR12 := sub_d @SR15, @SR13 SR15 := add_d @SR14, @SR12 SR12 := mul_d @SR15, @SR5 SR15 := sub_d @SR11, @SR12 SR16 := sub_d @SR12, @SR11 SR17 := add_d @SR11, @SR12 SR11 := add_d @SR13, @SR15 SR13 := add_d @SR14, @SR11 SR11 := mul_d @SR13, @SR5 SR13 := add_d @SR16, @SR11 SR15 := add_d @SR17, @SR11 SR16 := add_d @SR14, @SR13 SR13 := div_d @SR16, @SR4 SR14 := sub_d @SR15, @SR13 SR15 := mul_d @SR14, @SR5 SR14 := add_d @SR12, @SR15 SR12 := sub_d @SR14, @SR11 SR14 := add_d @SR13, @SR12 SR12 := mul_d @SR14, @SR5 SR14 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR15, @SR12 SR15 := add_d @SR11, @SR14 SR11 := add_d @SR13, @SR15 SR14 := mul_d @SR11, @SR5 SR11 := add_d @SR16, @SR14 SR15 := add_d @SR17, @SR14 SR16 := add_d @SR13, @SR11 SR11 := div_d @SR16, @SR4 SR13 := sub_d @SR15, @SR11 SR15 := mul_d @SR13, @SR5 SR13 := add_d @SR12, @SR15 SR12 := sub_d @SR13, @SR14 SR13 := add_d @SR11, @SR12 SR12 := mul_d @SR13, @SR5 SR13 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR15, @SR12 SR15 := add_d @SR14, @SR13 SR13 := add_d @SR11, @SR15 SR14 := mul_d @SR13, @SR5 SR13 := add_d @SR16, @SR14 SR15 := add_d @SR17, @SR14 SR16 := add_d @SR11, @SR13 SR11 := div_d @SR16, @SR4 SR13 := sub_d @SR15, @SR11 SR4 := loadu_q @SR4 SR5 := loadu_q @SR5 SR6 := loadu_q @SR6 SR7 := loadu_q @SR7 SR15 := mul_d @SR13, @SR5 SR8 := loadu_q @SR8 SR9 := loadu_q @SR9 SR10 := loadu_q @SR10 SR13 := add_d @SR12, @SR15 SR12 := sub_d @SR13, @SR14 SR13 := add_d @SR11, @SR12 SR12 := mul_d @SR13, @SR5 SR13 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR15, @SR12 SR15 := add_d @SR14, @SR13 SR13 := add_d @SR11, @SR15 SR14 := mul_d @SR13, @SR5 SR13 := add_d @SR16, @SR14 SR15 := add_d @SR17, @SR14 SR16 := add_d @SR11, @SR13 SR11 := div_d @SR16, @SR4 SR13 := sub_d @SR15, @SR11 SR15 := mul_d @SR13, @SR5 SR13 := add_d @SR12, @SR15 SR12 := sub_d @SR13, @SR14 SR13 := add_d @SR11, @SR12 SR12 := mul_d @SR13, @SR5 SR13 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR15, @SR12 SR15 := add_d @SR14, @SR13 SR13 := add_d @SR11, @SR15 SR14 := mul_d @SR13, @SR5 SR13 := add_d @SR16, @SR14 SR15 := add_d @SR17, @SR14 SR16 := add_d @SR11, @SR13 SR11 := div_d @SR16, @SR4 SR13 := sub_d @SR15, @SR11 SR15 := mul_d @SR13, @SR5 SR13 := add_d @SR12, @SR15 SR12 := sub_d @SR13, @SR14 SR13 := add_d @SR11, @SR12 SR12 := mul_d @SR13, @SR5 SR13 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR14, @SR13 SR13 := add_d @SR11, @SR17 SR14 := mul_d @SR13, @SR5 SR5 := add_d @SR16, @SR14 SR13 := add_d @SR11, @SR5 SR5 := div_d @SR13, @SR4 wr_q @SR15, @SR6 wr_q @SR12, @SR8 wr_q @SR14, @SR9 wr_q @SR5, @SR10 complete</code> </pre><br></div></div><br><h4>  popcnt </h4><br>  Pour refl√©ter les caract√©ristiques de l'architecture elle-m√™me (quel que soit le compilateur), nous mesurerons quelque chose √©crit en assembleur en tenant compte de toutes les caract√©ristiques de l'architecture.  Par exemple, compter des bits unitaires dans un nombre de 512 bits (popcnt).  Pour des raisons d'√©vidence, nous prendrons les r√©sultats d'une multicellule, afin qu'ils puissent √™tre compar√©s √† R1. <br><br>  Tableau de comparaison, le nombre de cycles d'horloge par cycle de calcul 32 bits: <br><table><tbody><tr><th>  Algorithme </th><th>  Multiclet r1 </th><th>  Multiclet S1 (une multicellule) </th></tr><tr><td>  Bithacks </td><td>  5,0 </td><td>  2,625 </td></tr></tbody></table><br>  De nouvelles instructions vectorielles mises √† jour ont √©t√© utilis√©es ici, ce qui nous a permis de r√©duire de moiti√© le nombre d'instructions par rapport au m√™me algorithme impl√©ment√© dans l'assembleur R1.  La vitesse de travail, respectivement, a augment√© de pr√®s de 2 fois. <br><br><div class="spoiler">  <b class="spoiler_title">popcnt</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">bithacks: b0 := patch_q 0x1, 0x1 v0 := loadu_q [v] v1 := loadu_q [v+8] v2 := loadu_q [v+16] v3 := loadu_q [v+24] v4 := loadu_q [v+32] v5 := loadu_q [v+40] v6 := loadu_q [v+48] v7 := loadu_q [v+56] b1 := patch_q 0x55555555, 0x55555555 i00 := slr_pl @v0, @b0 i01 := slr_pl @v1, @b0 i02 := slr_pl @v2, @b0 i03 := slr_pl @v3, @b0 i04 := slr_pl @v4, @b0 i05 := slr_pl @v5, @b0 i06 := slr_pl @v6, @b0 i07 := slr_pl @v7, @b0 b2 := patch_q 0x33333333, 0x33333333 i10 := and_q @i00, @b1 i11 := and_q @i01, @b1 i12 := and_q @i02, @b1 i13 := and_q @i03, @b1 i14 := and_q @i04, @b1 i15 := and_q @i05, @b1 i16 := and_q @i06, @b1 i17 := and_q @i07, @b1 b3 := patch_q 0x2, 0x2 i20 := sub_pl @v0, @i10 i21 := sub_pl @v1, @i11 i22 := sub_pl @v2, @i12 i23 := sub_pl @v3, @i13 i24 := sub_pl @v4, @i14 i25 := sub_pl @v5, @i15 i26 := sub_pl @v6, @i16 i27 := sub_pl @v7, @i17 i30 := and_q @i20, @b2 i31 := and_q @i21, @b2 i32 := and_q @i22, @b2 i33 := and_q @i23, @b2 i34 := and_q @i24, @b2 i35 := and_q @i25, @b2 i36 := and_q @i26, @b2 i37 := and_q @i27, @b2 i40 := slr_pl @i20, @b3 i41 := slr_pl @i21, @b3 i42 := slr_pl @i22, @b3 i43 := slr_pl @i23, @b3 i44 := slr_pl @i24, @b3 i45 := slr_pl @i25, @b3 i46 := slr_pl @i26, @b3 i47 := slr_pl @i27, @b3 b4 := patch_q 0x4, 0x4 i50 := and_q @i40, @b2 i51 := and_q @i41, @b2 i52 := and_q @i42, @b2 i53 := and_q @i43, @b2 i54 := and_q @i44, @b2 i55 := and_q @i45, @b2 i56 := and_q @i46, @b2 i57 := and_q @i47, @b2 i60 := add_pl @i50, @i30 i61 := add_pl @i51, @i31 i62 := add_pl @i52, @i32 i63 := add_pl @i53, @i33 i64 := add_pl @i54, @i34 i65 := add_pl @i55, @i35 i66 := add_pl @i56, @i36 i67 := add_pl @i57, @i37 b5 := patch_q 0xf0f0f0f, 0xf0f0f0f i70 := slr_pl @i60, @b4 i71 := slr_pl @i61, @b4 i72 := slr_pl @i62, @b4 i73 := slr_pl @i63, @b4 i74 := slr_pl @i64, @b4 i75 := slr_pl @i65, @b4 i76 := slr_pl @i66, @b4 i77 := slr_pl @i67, @b4 b6 := patch_q 0x1010101, 0x1010101 i80 := add_pl @i70, @i60 i81 := add_pl @i71, @i61 i82 := add_pl @i72, @i62 i83 := add_pl @i73, @i63 i84 := add_pl @i74, @i64 i85 := add_pl @i75, @i65 i86 := add_pl @i76, @i66 i87 := add_pl @i77, @i67 b7 := patch_q 0x18, 0x18 i90 := and_q @i80, @b5 i91 := and_q @i81, @b5 i92 := and_q @i82, @b5 i93 := and_q @i83, @b5 i94 := and_q @i84, @b5 i95 := and_q @i85, @b5 i96 := and_q @i86, @b5 i97 := and_q @i87, @b5 iA0 := mul_pl @i90, @b6 iA1 := mul_pl @i91, @b6 iA2 := mul_pl @i92, @b6 iA3 := mul_pl @i93, @b6 iA4 := mul_pl @i94, @b6 iA5 := mul_pl @i95, @b6 iA6 := mul_pl @i96, @b6 iA7 := mul_pl @i97, @b6 iB0 := slr_pl @iA0, @b7 iB1 := slr_pl @iA1, @b7 iB2 := slr_pl @iA2, @b7 iB3 := slr_pl @iA3, @b7 iB4 := slr_pl @iA4, @b7 iB5 := slr_pl @iA5, @b7 iB6 := slr_pl @iA6, @b7 iB7 := slr_pl @iA7, @b7 wr_q @iB0, c wr_q @iB1, c+8 wr_q @iB2, c+16 wr_q @iB3, c+24 wr_q @iB4, c+32 wr_q @iB5, c+40 wr_q @iB6, c+48 wr_q @iB7, c+56 complete</code> </pre><br></div></div><br><h4>  Ethereum </h4><br>  Les rep√®res sont, bien s√ªr, bons, mais nous avons une t√¢che sp√©cifique: cr√©er un acc√©l√©rateur de calcul, et ce serait bien de savoir comment il g√®re les t√¢ches du monde r√©el.  Les crypto-monnaies modernes sont les mieux adapt√©es pour une telle v√©rification, car les algorithmes d'exploration de donn√©es fonctionnent sur de nombreux appareils diff√©rents et peuvent donc servir de r√©f√©rence pour la comparaison.  Nous avons commenc√© avec Ethereum et l'algorithme Ethash, qui s'ex√©cute directement sur le p√©riph√©rique d'exploration de donn√©es. <br><br>  Le choix d'Ethereum √©tait d√ª aux consid√©rations suivantes.  Comme vous le savez, des algorithmes tels que Bitcoin sont tr√®s efficacement mis en ≈ìuvre par des puces ASIC sp√©cialis√©es, de sorte que l'utilisation de processeurs ou de cartes vid√©o pour extraire Bitcoin et ses clones devient √©conomiquement d√©savantageuse en raison de faibles performances et d'une consommation d'√©nergie √©lev√©e.  La communaut√© des mineurs, pour tenter de sortir de cette situation, d√©veloppe des crypto-monnaies sur d'autres principes algorithmiques, en se concentrant sur le d√©veloppement d'algorithmes qui utilisent des processeurs √† usage g√©n√©ral ou des cartes vid√©o pour l'exploitation mini√®re.  Cette tendance devrait se poursuivre √† l'avenir.  Ethereum est la crypto-monnaie la plus c√©l√®bre bas√©e sur cette approche.  Le principal outil d'extraction d'Ethereum sont les cartes vid√©o, qui en termes d'efficacit√© (hashrate / TDP) sont nettement (plusieurs fois) en avance sur les processeurs √† usage g√©n√©ral. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ethash</a> est un soi-disant algorithme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">li√© √† la m√©moire</a> , c'est-√†-dire  son temps de calcul est principalement limit√© par la quantit√© et la vitesse de la m√©moire, et non par la vitesse des calculs eux-m√™mes.  Maintenant, pour l'exploitation mini√®re Ethereum, les cartes vid√©o sont les mieux adapt√©es, mais leur capacit√© √† effectuer simultan√©ment de nombreuses op√©rations n'aide pas beaucoup, et elles reposent toujours sur la vitesse de la RAM, ce qui est clairement d√©montr√© dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> .  De l√†, vous pouvez prendre une photo illustrant le fonctionnement de l'algorithme pour expliquer pourquoi cela se produit. <br><br><img src="https://habrastorage.org/webt/y-/gg/t5/y-ggt5p2hd3w2vn1hzddmhwmq3u.png"><br><br>  L'article d√©compose l'algorithme en 6 points, mais 3 √©tapes peuvent √™tre distingu√©es pour encore plus d'√©vidence: <br><br><ol><li>  D√©but: SHA-3 (512) pour calculer le Mix 0 original de 128 octets (point 1) </li><li>  Recalcul de 64 fois la matrice de mixage en lisant les 128 octets suivants et en les m√©langeant avec les pr√©c√©dents via la fonction de m√©lange, pour un total de 8 kilo-octets (paragraphes 2 √† 4) </li><li>  Finalisation et v√©rification du r√©sultat </li></ol><br>  La lecture de 128 octets al√©atoires √† partir de la RAM prend beaucoup plus de temps qu'il n'y para√Æt.  Si vous prenez la carte graphique MSI RX 470, qui a 2048 appareils informatiques et une bande passante m√©moire maximale de 211,2 Go / s, alors pour √©quiper chaque appareil, vous avez besoin de 1 / (211,2 Go / (128 b * 2048)) = 1241 ns, soit environ 1496 cycles √† une fr√©quence donn√©e.  Compte tenu de la taille de la fonction de mixage, on peut supposer qu'il faut plusieurs fois plus de temps pour lire la m√©moire d'une carte vid√©o que pour recalculer les informations re√ßues.  En cons√©quence, l'√©tape 2 de l'algorithme prend beaucoup de temps, beaucoup plus longtemps que les √©tapes 1 et 3, qui au final ont peu d'effet sur les performances, malgr√© le fait qu'elles contiennent plus de calculs (principalement dans SHA-3).  Vous pouvez simplement regarder le hashrate de cette carte vid√©o: 26,375 m√©ga-shashs / ‚Äã‚Äãs th√©orique (limit√© uniquement par la bande passante m√©moire) contre 24 m√©gachehes / s r√©els, c'est-√†-dire que les √©tapes 1 et 3 ne prennent que 10% du temps. <br><br>  Sur S1, les 16 multicellules peuvent fonctionner en parall√®le et sur un code diff√©rent.  De plus, une RAM double canal sera install√©e, le long d'un canal pour 8 multicellules.  √Ä l'√©tape 2 de l'algorithme Ethash, notre plan est le suivant: une multicellule lit 128 octets dans la m√©moire et commence √† les recompter, puis la suivante lit la m√©moire et les recomptes, et ainsi de suite jusqu'au 8, c'est-√†-dire  une multicellule, apr√®s avoir lu 128 octets de m√©moire, dispose de 7 * [temps de lecture de 128 octets] pour recalculer le tableau.  On suppose qu'une telle lecture prendra 16 cycles, c'est-√†-dire  112 mesures sont donn√©es pour le recomptage.  Le calcul de la fonction de mixage prend environ le m√™me cycle d'horloge, donc S1 est proche du rapport id√©al de la bande passante m√©moire aux performances du processeur.  √âtant donn√© que le temps n'est pas perdu dans la deuxi√®me √©tape, les parties restantes de l'algorithme doivent √™tre optimis√©es autant que possible, car elles affectent vraiment les performances. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour √©valuer la vitesse de calcul SHA-3 (Keccak), un programme C a √©t√© d√©velopp√© et test√©, sur la base duquel sa version optimale en assembleur est en cours de cr√©ation. </font><font style="vertical-align: inherit;">La programmation d'√©valuation montre qu'une multicellule effectue le calcul SHA-3 (Keccak) en 1550 cycles d'horloge. </font><font style="vertical-align: inherit;">Par cons√©quent, le temps total pour calculer un hachage par multicellule sera de 1550 + 64 * (16 + 112) = 9742 cycles. </font><font style="vertical-align: inherit;">Avec une fr√©quence de 1,6 GHz et 16 multicellules parall√®les, le taux de hachage du processeur sera de 2,6 MHash / s.</font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acc√©l√©rateur </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MultiClet S1 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NVIDIA GeForce GTX 980 Ti </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Radeon RX 470 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Radeon RX Vega 64 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NVIDIA GeForce GTX 1060 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NVIDIA GeForce GTX 1080 Ti </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prix </font></font></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 650 $ </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 180 $ </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 500 $ </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 300 $ </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 700 $ </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Taux de hachage </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2,6 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21,6 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 25.8 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 43,5 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 25 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 55 MHash / s </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TDP </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6 W </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 250 W </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 120 W </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 295 W </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 120 W </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 250 W </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hashrate / TDP </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,43 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,09 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,22 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,15 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,22 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,21 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Technologie de processus </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 28 nm </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 28 nm </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14 nm </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14 nm </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16 nm </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16 nm </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous utilisez MultiClet S1 comme outil d'exploration de donn√©es, 20 processeurs ou plus peuvent en fait √™tre install√©s sur les cartes. </font><font style="vertical-align: inherit;">Dans ce cas, le hashrate d'une telle carte sera √©gal ou sup√©rieur aux hashrates des cartes vid√©o existantes, tandis que la consommation √©lectrique d'une carte avec S1 sera moiti√© moins √©lev√©e, m√™me que celle des cartes vid√©o avec des normes topographiques de 16 et 14 nm. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En conclusion, je dois dire que la t√¢che principale est maintenant la fabrication d'une carte multiprocesseur pour un mineur de crypto-monnaie multicellulaire et un mineur de supercalculateur. </font><font style="vertical-align: inherit;">La comp√©titivit√© devrait √™tre atteinte en raison de la faible consommation d'√©nergie et de l'architecture, qui conviennent bien √† l'informatique arbitraire.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le processeur est toujours en d√©veloppement, mais vous pouvez d√©j√† commencer √† programmer en langage assembleur, ainsi qu'√©valuer la version actuelle du compilateur. </font><font style="vertical-align: inherit;">Il existe d√©j√† un SDK minimal contenant un assembleur, un √©diteur de liens, un compilateur et un mod√®le fonctionnel, sur lequel vous pouvez d√©marrer et tester vos programmes.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434982/">https://habr.com/ru/post/fr434982/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434970/index.html">√Ä propos de l'informatique et plus</a></li>
<li><a href="../fr434972/index.html">Comment √©crire des tests unitaires si vous n'en avez pas envie du tout</a></li>
<li><a href="../fr434974/index.html">Travailler avec un format de configurations 1C: Enterprise</a></li>
<li><a href="../fr434976/index.html">ITAB University Fablab: DIY-coworking pour les cr√©atifs - montrer ce qu'il y a √† l'int√©rieur</a></li>
<li><a href="../fr434978/index.html">Pr√©sentation de HealthKit</a></li>
<li><a href="../fr434984/index.html">Pourquoi je d√©teste Eloquent ORM</a></li>
<li><a href="../fr434986/index.html">Concepts de base de la biblioth√®que C ++ standard</a></li>
<li><a href="../fr434992/index.html">Mise √† niveau d'IDA Pro. D√©bogueur pour Sega Mega Drive (partie 1)</a></li>
<li><a href="../fr434994/index.html">Android: cr√©ation de saveurs de produits dynamiques et signature de configurations</a></li>
<li><a href="../fr434996/index.html">Comment je partage l'emplacement via l'API VK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>