<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•— ğŸ‘¨ğŸ»â€ğŸ­ âœ”ï¸ MAM: perakitan frontend tanpa rasa sakit ğŸ™ğŸ¿ ğŸ‘² â›¹ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, nama saya Dmitry Karlovsky, dan saya ... suka MAM. M AM mengatur modul M Gnostik, menyelamatkan saya bagian terbesar dari rutinitas. 





 Modu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MAM: perakitan frontend tanpa rasa sakit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456288/"><p>  Halo, nama saya Dmitry Karlovsky, dan saya ... suka MAM.  <strong>M</strong> AM mengatur modul <strong>M</strong> Gnostik, menyelamatkan saya bagian terbesar dari rutinitas. </p><br><p><img src="https://habrastorage.org/webt/m2/5h/ps/m25hpsfevki-o6lwx4v_ukfxvtu.png" alt="Modul Agnostik Khas"></p><br><p> <strong>Modul agnostik</strong> , tidak seperti yang tradisional, bukan file sumber, tetapi direktori di dalamnya ada kode sumber dalam berbagai bahasa: logika program pada <code>JS</code> / <code>TS</code> , tes untuk itu pada <code>TS</code> / <code>JS</code> , komposisi komponen pada <code>view.tree</code> , styles di <code>CSS</code> , lokalisasi di <code>locale=*.json</code> , gambar, dll., dll.  Jika diinginkan, tidak sulit untuk mempercepat dukungan untuk bahasa lain.  Misalnya, Stylus untuk gaya penulisan, atau HTML untuk menjelaskan template. </p><br><p>  Ketergantungan antar modul dilacak secara otomatis dengan menganalisis sumbernya.  Jika modul dihidupkan, ia dihidupkan secara keseluruhan - setiap kode sumber modul ditransformasikan dan jatuh ke dalam bundel yang sesuai: skrip - secara terpisah, gaya - secara terpisah, tes - secara terpisah.  Untuk platform yang berbeda - bundel mereka: untuk simpul - milik mereka sendiri, untuk browser - milik mereka sendiri. </p><br><p>  Otomatisasi penuh, kurangnya konfigurasi dan pelat ketel, ukuran bundel minimal, pemompaan dependensi otomatis, pengembangan ratusan perpustakaan yang teralienasi dan aplikasi dalam satu basis kode tanpa rasa sakit dan penderitaan.  <strong>Wah, itu kecanduan!</strong>  Singkirkan anak-anak yang hamil, gugup, dari monitor dan selamat datang di kapal selam! </p><a name="habracut"></a><br><h1 id="filosofiya">  Filsafat </h1><br><p>  MAM adalah percobaan berani untuk secara radikal mengubah cara kode diatur dan proses bekerja dengannya.  Inilah prinsip-prinsip dasar: </p><br><p>  <strong>Konvensi bukan konfigurasi.</strong>  Kesepakatan yang masuk akal, sederhana dan universal memungkinkan Anda untuk mengotomatiskan seluruh rutinitas, sambil menjaga kenyamanan dan keseragaman antara berbagai proyek. </p><br><p>  <strong>Infrastrukturnya terpisah, kodenya terpisah.</strong>  Situasi tidak jarang ketika Anda perlu mengembangkan lusinan, atau bahkan ratusan perpustakaan dan aplikasi.  Jangan menggunakan infrastruktur perakitan, pengembangan, penyebaran, dll. Untuk masing-masing.  Cukup bertanya sekali dan kemudian memukau aplikasi seperti pai. </p><br><p>  <strong>Jangan membayar untuk apa yang tidak Anda gunakan.</strong>  Anda menggunakan semacam modul - modul ini disertakan dalam bundel dengan semua dependensinya.  Jangan gunakan - tidak menyala.  Semakin kecil modul, semakin besar rinciannya dan semakin sedikit kode yang tidak perlu dalam bundel. </p><br><p>  <strong>Kode redundan minimum.</strong>  Memecah kode menjadi modul harus sesederhana menulis semua kode dalam satu file.  Jika tidak, pengembang akan malas memecah modul besar menjadi kecil. </p><br><p>  <strong>Tidak ada konflik versi.</strong>  Hanya ada satu versi - versi saat ini.  Tidak perlu menghabiskan sumber daya untuk mendukung versi lama, jika Anda dapat menghabiskannya untuk memperbarui yang terakhir. </p><br><p>  <strong>Jaga jari pada denyut nadi.</strong>  Umpan balik tercepat mengenai ketidakcocokan tidak akan membiarkan kode menjadi buruk. </p><br><p>  <strong>Cara termudah adalah yang paling pasti.</strong>  Jika jalan yang benar membutuhkan upaya tambahan, maka pastikan tidak ada yang akan pergi ke sana. </p><br><h1 id="importyeksporty">  Impor / Ekspor </h1><br><p>  Kami membuka proyek pertama yang menggunakan sistem modul modern: <a href="">Sebuah modul kurang dari 300 baris, 30 di antaranya adalah impor.</a> </p><br><p>  Tapi ini masih bunga: <a href="">Untuk fungsi 9 baris, diperlukan 8 impor.</a> </p><br><p>  Dan favorit saya: <a href="">Bukan satu baris kode yang berguna.</a>  20 baris nilai pergeseran dari tumpukan modul menjadi satu, sehingga nanti Anda dapat mengimpor dari satu modul, dan bukan dari dua puluh. </p><br><p>  Semua ini adalah boilerplate, yang mengarah pada fakta bahwa pengembang terlalu malas untuk mengalokasikan potongan kecil kode ke dalam modul terpisah, lebih memilih modul besar daripada yang kecil.  Dan bahkan jika mereka tidak malas, ternyata banyak kode untuk mengimpor modul kecil, atau modul khusus yang mengimpor banyak modul ke dalam diri mereka sendiri dan mengekspor semuanya dalam jumlah besar. </p><br><p>  Semua ini mengarah pada granularitas rendah dari kode dan menggembungkan ukuran bundel dengan kode yang tidak digunakan, yang cukup beruntung untuk menjadi dekat dengan yang digunakan.  Untuk JS, mereka mencoba menyelesaikan masalah ini dengan menyulitkan jalur perakitan, dengan menambahkan apa yang disebut â€œpengocokan pohonâ€, yang memotong kelebihan dari apa yang Anda impor.  Ini memperlambat perakitan, tetapi tidak semuanya terpotong. </p><br><p>  Gagasan: <strong>Bagaimana jika kita tidak mengimpor, tetapi hanya mengambil dan menggunakan, dan pengumpul sendiri akan mencari tahu apa yang perlu diimpor?</strong> </p><br><p>  IDE modern dapat secara otomatis menghasilkan impor untuk entitas yang Anda gunakan.  Jika IDE dapat melakukan ini, lalu apa yang mencegah kolektor melakukan ini?  Cukup memiliki konvensi sederhana tentang penamaan dan lokasi file, yang akan nyaman bagi pengguna dan dapat dimengerti oleh mesin.  PHP telah lama memiliki konvensi standar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PSR-4</a> .  MAM memperkenalkan hal yang sama untuk <em>file .ts dan</em> .jam.js: nama yang dimulai dengan $ adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nama yang Sepenuhnya Memenuhi Kualifikasi dari</a> beberapa entitas global, yang kodenya dimuat di sepanjang jalur yang diperoleh dari FQN dengan mengganti pembatas dengan garis miring.  Contoh sederhana dari dua modul: </p><br><p>  <strong>/ alert / alert.ts saya</strong> </p><br><pre> <code class="plaintext hljs">const $my_alert = alert // FQN   </code> </pre> <br><p>  <strong>/ app / app.ts saya</strong> </p><br><pre> <code class="plaintext hljs">$my_alert( 'Hello!' ) // ,   /my/alert/</code> </pre> <br><p>  Seluruh modul dari satu baris - apa yang bisa lebih sederhana?  Hasilnya tidak lama datang: kesederhanaan membuat dan menggunakan modul mengarah pada meminimalkan ukurannya.  Hasilnya, memaksimalkan granularity.  Dan seperti ceri - meminimalkan ukuran bundel tanpa pohon bergetar. </p><br><p>  Contoh yang baik adalah keluarga JSON <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">/ mol / data</a> keluarga modul validasi.  Jika Anda menggunakan fungsi <code>$mol_data_integer</code> di suatu tempat dalam kode Anda, maka modul <code>/mol/data/integer</code> dan <code>/mol/data/number</code> , yang bergantung pada <code>$mol_data_integer</code> , akan dimasukkan dalam bundel.  Tetapi, misalnya, kolektor <code>/mol/data/email</code> bahkan tidak akan membaca dari disk, karena tidak ada yang bergantung padanya. </p><br><h1 id="razgrebaya-bardak">  Membuat berantakan </h1><br><p>  Sejak kami mulai menendang Angular, kami tidak akan berhenti.  Di mana menurut Anda untuk mencari <code>applyStyles</code> fungsi <code>applyStyles</code> ?  Anda tidak akan menebak di <a href=""><code>/packages/core/src/render3/styling_next/bindings.ts</code></a> .  Kemampuan untuk menempatkan apa pun di mana saja mengarah pada fakta bahwa dalam setiap proyek kami mengamati sistem lokasi file yang unik, sering tidak setuju dengan logika apa pun.  Dan jika IDE sering disimpan oleh "lompat ke definisi", maka melihat kode pada github atau meninjau permintaan tarik akan kehilangan kesempatan ini. </p><br><p>  Ide: <strong>Bagaimana jika nama entitas benar-benar sesuai dengan lokasi mereka?</strong> </p><br><p>  Untuk menempatkan kode dalam file <code>/angular/packages/core/src/render3/stylingNext/bindings.ts</code> , dalam arsitektur MAM Anda harus memberi nama entitas <code>$angular_packages_core_src_render3_stylingNext_applyStyles</code> , tapi tentu saja, tidak ada yang akan bertindak, karena ada begitu banyak nama tambahan.  Tetapi nama-nama dalam kode yang ingin saya lihat singkat dan ringkas, sehingga pengembang akan mencoba untuk mengecualikan semua yang tidak perlu dari nama, hanya menyisakan yang penting: <code>$angular_render3_applyStyles</code> .  Dan itu akan ditempatkan sesuai di <code>/angular/render3/applyStyles/applyStyles.ts</code> . </p><br><p>  Perhatikan bagaimana MAM menggunakan kelemahan pengembang untuk mencapai hasil yang diinginkan: setiap entitas mendapatkan nama pendek global unik yang dapat digunakan dalam konteks apa pun.  Misalnya, dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pesan komit,</a> nama-nama ini memungkinkan Anda menangkap dengan cepat dan akurat apa yang mereka bicarakan: </p><br><pre> <code class="plaintext hljs">73ebc45e517ffcc3dcce53f5b39b6d06fc95cae1 $mol_vector: range expanding support 3a843b2cb77be19688324eeb72bd090d350a6cc3 $mol_data: allowed transformations 24576f087133a18e0c9f31e0d61052265fd8a31a $mol_data_record: support recursion</code> </pre> <br><p>  Atau, katakanlah Anda ingin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menemukan semua sebutan modul $ mol_fiber di Internet</a> - membuatnya lebih mudah dari sebelumnya berkat FQN. </p><br><h1 id="ciklicheskie-zavisimosti">  Ketergantungan siklik </h1><br><p>  Mari kita menulis 7 baris kode sederhana dalam satu file: </p><br><pre> <code class="plaintext hljs">export class Foo { get bar() { return new Bar(); } } export class Bar extends Foo {} console.log(new Foo().bar);</code> </pre> <br><p>  Meskipun ada ketergantungan siklik, ia bekerja dengan benar.  Kami memecahnya menjadi 3 file: </p><br><p>  <strong>/ foo.js saya</strong> </p><br><pre> <code class="plaintext hljs">import { Bar } from './bar.js'; export class Foo { get bar() { return new Bar(); } }</code> </pre> <br><p>  <strong>/ bar.js saya</strong> </p><br><pre> <code class="plaintext hljs">import { Foo } from './foo.js'; export class Bar extends Foo {}</code> </pre> <br><p>  <strong>/ app.js saya</strong> </p><br><pre> <code class="plaintext hljs">import { Foo } from './foo.js'; console.log(new Foo().bar);</code> </pre> <br><p>  Ups, <code>ReferenceError: Cannot access 'Foo' before initialization</code> .  Omong kosong macam apa?  Untuk memperbaikinya, <code>app.js</code> kami perlu tahu bahwa <code>foo.js</code> bergantung pada <code>bar.js</code>  Karena itu, pertama-tama kita perlu mengimpor <code>bar.js</code> , yang mengimpor <code>foo.js</code>  Setelah itu kita sudah bisa mengimpor <code>foo.js</code> tanpa kesalahan: </p><br><p>  <strong>/ app.js saya</strong> </p><br><pre> <code class="plaintext hljs">import './bar.js'; import { Foo } from './foo.js'; console.log(new Foo().bar);</code> </pre> <br><p>  Browser itu, NodeJS itu, Webpack itu, Parcel itu - semuanya bekerja bengkok dengan dependensi melingkar.  Dan yah, mereka hanya akan melarang mereka - orang bisa segera menyulitkan kode sehingga tidak ada loop.  Tapi mereka bisa bekerja dengan baik, dan kemudian bam, dan memberikan kesalahan yang tidak bisa dimengerti. </p><br><p>  Ide: <strong>Bagaimana jika selama perakitan kita hanya merekatkan file dalam urutan yang benar, seolah-olah semua kode awalnya ditulis dalam satu file?</strong> </p><br><p>  Mari kita membagi kode menggunakan prinsip-prinsip MAM: </p><br><p>  <strong>/ foo / foo.ts saya</strong> </p><br><pre> <code class="plaintext hljs">class $my_foo { get bar() { return new $my_bar(); } }</code> </pre> <br><p>  <strong>/ bar / bar.ts saya</strong> </p><br><pre> <code class="plaintext hljs">class $my_bar extends $my_foo {}</code> </pre> <br><p>  <strong>/ app / app.ts saya</strong> </p><br><pre> <code class="plaintext hljs">console.log(new $my_foo().bar);</code> </pre> <br><p>  Semua 7 baris kode yang sama yang awalnya.  Dan mereka hanya bekerja tanpa perdukunan tambahan.  Masalahnya adalah bahwa kolektor memahami bahwa ketergantungan <code>my/bar</code> <code>my/foo</code> pada <code>my/foo</code> lebih ketat daripada <code>my/foo</code> pada <code>my/bar</code> .  Ini berarti Anda harus menyertakan modul-modul ini dalam bundel dalam urutan ini: <code>my/foo</code> , <code>my/bar</code> , <code>my/app</code> . </p><br><p>  Bagaimana kolektor memahami ini?  Sekarang heuristik sederhana - dengan jumlah lekukan di baris di mana ketergantungan terdeteksi.  Harap perhatikan bahwa ketergantungan yang lebih kuat pada contoh kami memiliki indentasi nol, dan yang lemah memiliki indentasi ganda. </p><br><h1 id="raznye-yazyki">  Bahasa yang berbeda </h1><br><p>  Kebetulan bahwa untuk hal-hal yang berbeda kami memiliki bahasa yang berbeda untuk hal-hal yang berbeda juga dipertajam.  Yang paling umum adalah: JS, TS, CSS, HTML, SVG, SCSS, Less, Stylus.  Masing-masing memiliki sistem modul sendiri, yang tidak berinteraksi dengan bahasa lain dengan cara apa pun.  Tak perlu dikatakan, sekitar 100500 jenis bahasa yang lebih spesifik.  Akibatnya, untuk menghubungkan komponen, Anda harus menghubungkan skrip, gaya terpisah, mendaftarkan templat secara terpisah, secara terpisah mengkonfigurasi penyebaran file statis yang diperlukan, dll., Dll. </p><br><p>  Terima kasih kepada loader, Webpack berusaha menyelesaikan masalah ini.  Tapi dia memiliki entry point yaitu skrip yang sudah menghubungkan file dalam bahasa lain.  Dan jika kita tidak membutuhkan skrip?  Sebagai contoh, kami memiliki modul dengan gaya yang indah untuk piring dan kami ingin mereka memiliki warna yang sama dalam tema terang dan yang lain dalam gelap: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.dark-theme</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">table</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: black; } <span class="hljs-selector-class"><span class="hljs-selector-class">.light-theme</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">table</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: white; }</code> </pre> <br><p>  Selain itu, jika kita bergantung pada topik, maka skrip harus dimuat yang akan menginstal topik yang diinginkan tergantung pada waktu hari.  Artinya, CSS sebenarnya tergantung pada JS. </p><br><p>  Ide: <strong>Bagaimana jika sistem modular tidak bergantung pada bahasa?</strong> </p><br><p>  Karena dalam MAM sistem modular dipisahkan dari bahasa, dependensinya dapat lintas-bahasa.  CSS mungkin tergantung pada JS, yang mungkin tergantung pada TS, yang mungkin tergantung pada JS lain.  Ini dicapai karena fakta bahwa dependensi sumber terdeteksi pada modul, dan modul terhubung seluruhnya dan dapat berisi kode sumber dalam bahasa apa pun.  Dalam contoh contoh tema, tampilannya seperti ini: </p><br><p>  <strong>/my/table/table.css</strong> </p><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* ,   /my/theme */</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[my_theme="dark"]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">table</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: black; } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[my_theme="light"]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">table</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: white; }</code> </pre> <br><p>  <strong>/my/theme/theme.js</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.documentElement.setAttribute( <span class="hljs-string"><span class="hljs-string">'my_theme'</span></span> , ( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getHours() + <span class="hljs-number"><span class="hljs-number">15</span></span> ) % <span class="hljs-number"><span class="hljs-number">24</span></span> &lt; <span class="hljs-number"><span class="hljs-number">12</span></span> ? <span class="hljs-string"><span class="hljs-string">'light'</span></span> : <span class="hljs-string"><span class="hljs-string">'dark'</span></span> , )</code> </pre> <br><p>  Dengan menggunakan teknik ini, Anda dapat mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Modernizr</a> Anda, tetapi tanpa 300 pemeriksaan yang tidak Anda perlukan, karena hanya pemeriksaan yang bergantung pada CSS Anda yang akan dimasukkan dalam bundel. </p><br><h1 id="mnogo-bibliotek">  Banyak perpustakaan </h1><br><p>  Biasanya, titik masuk untuk membangun bundel adalah beberapa jenis file.  Dalam hal Webpack, ini adalah JS.  Jika Anda mengembangkan banyak perpustakaan dan aplikasi yang dapat dialienasi, maka Anda memerlukan banyak bundel.  Dan untuk setiap bundel Anda perlu membuat titik masuk yang terpisah.  Dalam kasus Parcel, titik masuknya adalah HTML, yang untuk aplikasi harus dibuat.  Tetapi untuk perpustakaan, ini entah bagaimana sangat tidak cocok. </p><br><p>  Ide: <strong>Bagaimana jika ada modul yang dapat dirangkai menjadi bundel independen tanpa persiapan awal?</strong> </p><br><p>  Mari kita kumpulkan versi terbaru dari pembuat proyek MAM $ mol_build: </p><br><pre> <code class="plaintext hljs">mam mol/build</code> </pre> <br><p>  Sekarang jalankan kolektor ini dan biarkan dia merakit dirinya sendiri lagi untuk memastikan bahwa dia masih bisa merakit dirinya sendiri: </p><br><pre> <code class="plaintext hljs">node mol/build/-/node.js mol/build</code> </pre> <br><p>  Meskipun, tidak, mari kita memintanya untuk melakukan tes bersama dengan majelis: </p><br><pre> <code class="plaintext hljs">node mol/build/-/node.test.js mol/build</code> </pre> <br><p>  Dan jika semuanya berjalan dengan baik, publikasikan hasilnya di NPM: </p><br><pre> <code class="plaintext hljs">npm publish mol/build/-</code> </pre> <br><p>  Seperti yang Anda lihat, saat merakit modul, subdirektori dibuat dengan nama <code>-</code> dan semua artefak rakitan ditempatkan di sana.  Mari kita telusuri file yang dapat Anda temukan di sana: </p><br><ul><li>  <code>web.dep.json</code> - semua informasi tentang grafik ketergantungan </li><li>  <code>web.js</code> - bundel skrip browser </li><li>  <code>web.js.map</code> - sorsmaps untuknya </li><li>  <code>web.esm.js</code> - itu dalam bentuk modul-es </li><li>  <code>web.esm.js.map</code> - dan sorsmaps untuk itu </li><li>  <code>web.test.js</code> - bundel uji </li><li>  <code>web.test.js.map</code> - dan untuk tes sorsmap </li><li>  <code>web.d.ts</code> - bundel dengan jenis segala sesuatu yang ada dalam bundel skrip </li><li>  <code>web.css</code> - bundel dengan gaya </li><li>  <code>web.css.map</code> - dan sortmaps untuk itu </li><li>  <code>web.test.html</code> - titik masuk untuk menjalankan tes kinerja di browser </li><li>  <code>web.view.tree</code> - deklarasi semua komponen yang termasuk dalam bundel view.tree </li><li>  <code>web.locale=*.json</code> - bundel dengan teks terlokalisasi, masing-masing bundel memiliki bundel sendiri </li><li>  <code>package.json</code> - memungkinkan Anda untuk segera menerbitkan modul rakitan di NPM </li><li>  <code>node.dep.json</code> - semua informasi tentang grafik ketergantungan </li><li>  <code>node.js</code> - bundel skrip simpul </li><li>  <code>node.js.map</code> - sorsmaps untuk itu </li><li>  <code>node.esm.js</code> - itu dalam bentuk modul-es </li><li>  <code>node.esm.js.map</code> - dan sorsmaps untuk itu </li><li>  <code>node.test.js</code> - bundel yang sama, tetapi juga dengan tes </li><li>  <code>node.test.js.map</code> - dan sorsmaps untuk itu </li><li>  <code>node.d.ts</code> - bundel dengan jenis segala sesuatu yang ada dalam bundel skrip </li><li>  <code>node.view.tree</code> - deklarasi semua komponen yang termasuk dalam bundel view.tree </li><li>  <code>node.locale=*.json</code> - bundel dengan teks yang dilokalkan, masing-masing bundel memiliki bundel sendiri </li></ul><br><p>  Statika disalin bersama jalurnya.  Sebagai contoh, ambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi yang menampilkan kode sumbernya sendiri</a> .  Sumbernya ada di sini: </p><br><ul><li> <code>/mol/app/quine/quine.view.tree</code> </li> <li> <code>/mol/app/quine/quine.view.ts</code> </li> <li> <code>/mol/app/quine/index.html</code> </li> <li> <code>/mol/app/quine/quine.locale=ru.json</code> </li> </ul><br><p>  Sayangnya, dalam kasus umum, kolektor tidak dapat mengetahui bahwa kami akan memerlukan file-file ini dalam runtime.  Tapi kita bisa memberitahunya ini dengan meletakkan file khusus di dekatnya: </p><br><p>  <strong>/mol/app/quine/quine.meta.tree</strong> </p><br><pre> <code class="plaintext hljs">deploy \/mol/app/quine/quine.view.tree deploy \/mol/app/quine/quine.view.ts deploy \/mol/app/quine/index.html deploy \/mol/app/quine/quine.locale=ru.json</code> </pre> <br><p>  Sebagai hasil dari perakitan <code>/mol/app/quine</code> , mereka akan disalin dengan cara berikut: </p><br><ul><li> <code>/mol/app/quine/-/mol/app/quine/quine.view.tree</code> </li> <li> <code>/mol/app/quine/-/mol/app/quine/quine.view.ts</code> </li> <li> <code>/mol/app/quine/-/mol/app/quine/index.html</code> </li> <li> <code>/mol/app/quine/-/mol/app/quine/quine.locale=ru.json</code> </li> </ul><br><p>  Sekarang direktori <code>/mol/app/quine/-</code> dapat diletakkan di sembarang hosting statis dan aplikasi akan berfungsi penuh. </p><br><h1 id="celevye-platformy">  Platform target </h1><br><p>  JS dapat dieksekusi baik di klien maupun di server.  Dan betapa kerennya ketika Anda dapat menulis satu kode dan itu akan bekerja di mana-mana.  Namun, terkadang implementasi hal yang sama pada klien dan server pada dasarnya berbeda.  Dan saya ingin, misalnya, satu implementasi digunakan untuk node, dan yang lain untuk browser. </p><br><p>  Ide: <strong>Bagaimana jika tujuan file tercermin dalam namanya?</strong> </p><br><p>  MAM menggunakan sistem tag dalam nama file.  Sebagai contoh, modul <code>$mol_state_arg</code> menyediakan akses ke parameter aplikasi yang ditentukan pengguna.  Di browser, parameter ini ditetapkan melalui bilah alamat.  Dan di simpul, melalui argumen baris perintah.  <code>$mol_sate_arg</code> mengabstraksi sisa aplikasi dari nuansa ini dengan mengimplementasikan kedua opsi dengan antarmuka tunggal, menempatkannya dalam file: </p><br><ul><li>  / mol / state / arg / arg.  <strong>web</strong> .ts - implementasi untuk browser </li><li>  / mol / state / arg / arg.  <strong>simpul</strong> .ts - implementasi untuk suatu simpul </li></ul><br><p>  Sumber yang tidak ditandai dengan tag ini disertakan terlepas dari platform target. </p><br><p>  Situasi serupa diamati dengan tes - mereka ingin disimpan di sebelah sumber lain, tetapi mereka tidak ingin dimasukkan dalam bundel yang masuk ke pengguna akhir.  Karenanya, pengujian juga ditandai dengan tag terpisah: </p><br><ul><li>  / mol / state / arg / arg.  <strong>test</strong> .ts - tes modul, mereka akan jatuh ke dalam bundel tes </li></ul><br><p>  Tag bisa parametrik.  Misalnya, dengan setiap modul teks dalam berbagai bahasa dapat datang dan harus dimasukkan dalam bundel bahasa yang sesuai.  File teks adalah kamus JSON biasa yang diberi nama lokal dalam namanya: </p><br><ul><li>  / mol / app / hidup / kehidupan.  <strong>locale = ru</strong> .json - teks untuk bahasa Rusia </li><li>  / mol / app / hidup / kehidupan.  <strong>locale = jp</strong> .json - teks untuk bahasa Jepang </li></ul><br><p>  Akhirnya, bagaimana jika kita ingin meletakkan file di dekatnya, tetapi ingin kolektor mengabaikannya dan tidak secara otomatis memasukkannya ke dalam bundel?  Cukup menambahkan di awal nama mereka karakter non-alfanumerik.  Sebagai contoh: </p><br><ul><li>  / hyoo / mainan / <strong>.</strong>  git - dimulai dengan tanda titik, sehingga kolektor akan mengabaikan direktori ini </li></ul><br><h1 id="versionirovanie">  Versi </h1><br><p>  Google pertama kali merilis AngularJS dan menerbitkannya dalam NPM sebagai <code>angular</code> .  Kemudian ia menciptakan kerangka kerja yang sama sekali baru dengan nama yang mirip - Angular dan menerbitkannya dengan nama yang sama, tetapi sudah versi 2. Sekarang kedua kembang api ini berkembang secara mandiri.  Hanya satu perubahan pemecah API yang terjadi antara versi utama.  Dan yang lainnya - <a href="">antara anak di bawah umur</a> .  Dan karena tidak mungkin untuk menempatkan dua versi dari ketergantungan yang sama pada tingkat yang sama, tidak ada pembicaraan tentang transisi yang mulus, ketika dua versi perpustakaan secara bersamaan hidup berdampingan untuk beberapa waktu dalam aplikasi. </p><br><p>  Tampaknya tim Angular telah menginjak semua kemungkinan garu.  Dan satu hal lagi: kode kerangka kerja dibagi menjadi beberapa modul besar.  Pada awalnya mereka memvariasikannya secara independen, tetapi sangat cepat bahkan mereka sendiri mulai bingung dengan versi modul mana yang kompatibel satu sama lain, apalagi pengembang biasa.  Oleh karena itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Angular beralih ke versi end-to-end</a> , di mana versi utama modul dapat berubah bahkan tanpa ada perubahan dalam kode.  Dukungan untuk beberapa versi dari banyak modul merupakan masalah besar baik bagi pengelola sendiri maupun bagi ekosistem secara keseluruhan.  Lagi pula, banyak sumber daya dari semua anggota masyarakat dihabiskan untuk memastikan kompatibilitas dengan modul yang sudah usang. </p><br><p>  Ide indah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semantic Versioning</a> terurai menjadi kenyataan pahit - Anda tidak pernah tahu apakah ada sesuatu yang pecah ketika Anda mengubah versi minor <a href="">atau bahkan versi tambalan</a> .  Oleh karena itu, dalam banyak proyek, versi tertentu dari ketergantungan diperbaiki.  Namun, perbaikan semacam itu tidak memengaruhi dependensi transitif, yang dapat ditarik ke versi terbaru saat menginstal dari awal, tetapi mungkin tetap sama jika sudah diinstal.  Kekacauan ini mengarah pada fakta bahwa Anda tidak pernah bisa bergantung pada versi yang telah diperbaiki dan Anda perlu memeriksa kompatibilitas dengan versi terkini dari dependensi (setidaknya transitif). </p><br><p>  Tapi bagaimana dengan <a href="">file kunci</a> ?  Jika Anda sedang mengembangkan perpustakaan yang diinstal melalui dependensi, file kunci tidak akan membantu Anda, karena akan diabaikan oleh manajer paket.  Untuk aplikasi terakhir, file kunci akan memberi Anda apa yang disebut "reproducibility of assemblies."  Tapi mari kita jujur.  Berapa kali Anda perlu membangun aplikasi final dari sumber yang sama?  Tepat sekali.  Menerima output, terlepas dari NPM, artefak perakitan: biner yang dapat dieksekusi, wadah buruh pelabuhan atau hanya arsip dengan semua kode yang diperlukan untuk menjalankannya.  Saya harap Anda tidak melakukan <code>npm install</code> di prod? </p><br><p>  Beberapa menemukan penggunaan file kunci untuk memiliki server CI merakit persis apa yang telah dilakukan pengembang.  Tapi tunggu, pengembang sendiri dapat dengan mudah merakitnya di komputer lokalnya.  ,    ,  ,    . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Continuous Integration</a>       ,     ,    ,  ,   - .  CI        ,            . </p><br><p>        ,     ,  . ,            Angular@4 (  3).  ,     ,  "     "  "     ".      Angular@4     ,      Angular@5.      Angular@6,         .  Angular   TypeScript    .     .  ,   2  ,  â€¦      ,   business value    ,     ,  ,  ,  . </p><br><p>                   ,    ,       ,   ,       2 .    :      ,  â€” ,  â€” .       3 React, 5 jQuery, 7 lodash. </p><br><p> : <strong>         â€” ?</strong> </p><br><p>         .     -   .     ,       .     ,     .  ,    .  ,       .        ,    .   ,        ,            .      :  issue,    ,  workaround,  pull request,    ,      .          ,    ,    .        .            . </p><br><p>               ,        . ,        ,       .        .        .  :  ,       ,     -.     -      â€”       .  ,            ,    -  .         , ,  ,   NPM <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>     .  ,      .       . </p><br><p>         ,      ?   â€”   .  <code>mobx</code> ,  <code>mobx2</code>     API  .   â€”    ,    :     ,       .     <code>mobx</code>        <code>mobx2</code> ,      API.         API,     . </p><br><p>        .           â€” .  ,      : </p><br><pre> <code class="plaintext hljs">var pages_count = $mol_atom2_sync( ()=&gt; $lib_pdfjs.getDocument( uri ).promise ).document().numPages</code> </pre> <br><p>  <strong> </strong>   <code>mol_atom2_sync</code>  <code>lib_pdfjs</code> ,      : </p><br><pre> <code class="plaintext hljs">npm install mol_atom2_sync@2.1 lib_pdfjs@5.6</code> </pre> <br><p> ,   , â€”   ,       .        ?    â€”    ,    <code>*.meta.tree</code> ,          : </p><br><p> <strong>/.meta.tree</strong> </p><br><pre> <code class="plaintext hljs">pack node git \https://github.com/nin-jin/pms-node.git pack mol git \https://github.com/eigenmethod/mol.git pack lib git \https://github.com/eigenmethod/mam-lib.git</code> </pre> <br><p>    .             . </p><br><h1 id="integraciya-s-npm">   NPM </h1><br><p> MAM â€”    NPM . ,         â€” . ,    ,     NPM      . </p><br><p>          NPM ,     $node. ,   -        -: </p><br><p> <strong>/my/app/app.ts</strong> </p><br><pre> <code class="plaintext hljs">$node.portastic.find({ min : 8080 , max : 8100 , retrieve : 1 }).then( ( ports : number[] ) =&gt; { $node.express().listen( ports[0] ) })</code> </pre> <br><p>       ,     . -    <code>lib</code>      NPM . ,     NPM- <code>pdfjs-dist</code> : </p><br><p> <strong>/lib/pdfjs/pdfjs.ts</strong> </p><br><pre> <code class="plaintext hljs">namespace $ { export let $lib_pdfjs : typeof import( 'pdfjs-dist' ) = require( 'pdfjs-dist/build/pdf.min.js' ) $lib_pdfjs.disableRange = true $lib_pdfjs.GlobalWorkerOptions.workerSrc = '-/node_modules/pdfjs-dist/build/pdf.worker.min.js' }</code> </pre> <br><p> <strong>/lib/pdfjs/pdfjs.meta.tree</strong> </p><br><pre> <code class="plaintext hljs">deploy \/node_modules/pdfjs-dist/build/pdf.worker.min.js</code> </pre> <br><p>        ,    . </p><br><h1 id="okruzhenie-razrabotchika">   </h1><br><p>          .     <code>create-react-app</code>  <code>angular-cli</code> ,       . , ,   <code>eject</code>       .          .       ,         ,       . </p><br><p> : <strong>      ?</strong> </p><br><p>    MAM      .          . </p><br><p>      MAM  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   MAM </a> ,    : </p><br><pre> <code class="plaintext hljs">git clone https://github.com/eigenmethod/mam.git ./mam &amp;&amp; cd mam npm install npm start</code> </pre> <br><p>   8080   . ,    â€”        MAM. </p><br><p>     (  â€” <code>acme</code> )         (  â€” <code>hello</code>  <code>home</code> ): </p><br><p> <strong>/acme/acme.meta.tree</strong> </p><br><pre> <code class="plaintext hljs">pack hello git \https://github.com/acme/hello.git pack home git \https://github.com/acme/home.git</code> </pre> <br><p>           <code>npm start</code> : </p><br><pre> <code class="plaintext hljs">npm start acme/hello acme/home</code> </pre> <br><p>         .     â€”  . ,  ,   .     â€”   : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://t.me/mam_mol</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456288/">https://habr.com/ru/post/id456288/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456272/index.html">Apa itu Android Lint dan bagaimana ini membantu Anda menulis kode yang didukung</a></li>
<li><a href="../id456274/index.html">Psikolog: robot seks akan menyebabkan peningkatan jumlah orang tanpa pasangan yang tidak membutuhkan hubungan dengan orang lain</a></li>
<li><a href="../id456276/index.html">Apa itu informasi?</a></li>
<li><a href="../id456280/index.html">Memulai dengan stm32 atau jangan ulangi kesalahan saya</a></li>
<li><a href="../id456282/index.html">Grafik multidimensi dalam Python - dari tiga dimensi hingga enam dimensi</a></li>
<li><a href="../id456290/index.html">Telegram Drive jaringan tidak terbatas. Gratis</a></li>
<li><a href="../id456294/index.html">Perbedaan antara LabelEncoder dan OneHotEncoder di SciKit Learn</a></li>
<li><a href="../id456296/index.html">Dunia hipersphere tiga dimensi. Penelusuran sinar geodesik di alam semesta tertutup dengan geometri bola</a></li>
<li><a href="../id456298/index.html">Teknologi mikroelektronika di jari: Hukum Moore, gerakan pemasaran, dan mengapa nanometer tidak sama sekarang. Bagian 2</a></li>
<li><a href="../id456300/index.html">Menemukan zina</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>