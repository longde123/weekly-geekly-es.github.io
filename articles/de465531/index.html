<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏾 🏡 🤴🏿 Entpacken verschachtelter Listen mit unbestimmter Tiefe 🤟 🤳🏿 ⬛️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute möchte ich über das Auspacken verschachtelter Listen mit unbestimmter Tiefe sprechen. Dies ist eine ziemlich nicht triviale Aufgabe, daher möcht...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entpacken verschachtelter Listen mit unbestimmter Tiefe</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465531/"><p>  Heute möchte ich über das Auspacken verschachtelter Listen mit unbestimmter Tiefe sprechen.  Dies ist eine ziemlich nicht triviale Aufgabe, daher möchte ich hier etwas über die Implementierungen, ihre Vor- und Nachteile und einen Vergleich ihrer Leistung erzählen. </p><br><p>  Der Artikel wird aus mehreren Abschnitten bestehen: </p><br><ul><li>  Funktionen </li><li>  Daten </li><li>  Ergebnisse </li><li>  Schlussfolgerungen </li></ul><a name="habracut"></a><br><h1 id="chast-1-funkcii">  Teil 1. Funktionen </h1><br><h2 id="zaimstvovannye-realizacii">  Geliehene Implementierungen </h2><br><h3 id="outer_flatten_1">  Outer_flatten_1 </h3><br><div class="spoiler">  <b class="spoiler_title">Implementierung</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outer_flatten_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" Based on C realization of this solution More on: https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html https://github.com/MSeifert04/iteration_utilities/blob/384948b4e82e41de47fa79fb73efc56c08549b01/src/deepflatten.c """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deepflatten(array)</code> </pre> </div></div><br><p>  Ich habe diese Funktion zum Parsen aus einem externen Paket, iteration_utilities, verwendet. </p><br><p>  Die Implementierung wurde in C durchgeführt, wobei für Python eine übergeordnete Funktionsaufrufschnittstelle übrig blieb. <br>  Die Implementierung der Funktion in C ist ziemlich umständlich. Sie können sie sehen, indem Sie auf den Link im Spoiler klicken.  Die Funktion ist ein Iterator. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Iterator, Generator &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> iteration_utilities <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deepflatten &gt;&gt;&gt; isinstance(deepflatten(a), Iterator) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; isinstance(deepflatten(a), Generator) <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Es ist schwierig, über die Komplexität des hier implementierten Algorithmus zu sagen, daher überlasse ich dieses Interesse den Habr-Benutzern. </p><br><p>  Generell möchte ich auch darauf hinweisen, dass alle anderen Funktionen aus dieser Bibliothek recht schnell sind und auch in C implementiert sind. </p><br><h3 id="outer_flatten_2">  Outer_flatten_2 </h3><br><div class="spoiler">  <b class="spoiler_title">Implementierung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outer_flatten_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" recursive algorithm, vaguely reminiscent of recursion_flatten. Based on next pattern: .. code:: python try: tree = iter(node) except TypeError: yield node more on: https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.collapse """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collapse(array)</code> </pre> </div></div><br><p>  Die Implementierung dieser Methode zum Entpacken verschachtelter Listen erfolgt ebenfalls im externen Paket, nämlich more_itertools. <br>  Die Funktion wird auf reinem Python ausgeführt, ist aber meiner Meinung nach nicht optimal.  Eine detaillierte Implementierung finden Sie im Dokumentationslink. <br>  Die Komplexität dieses Algorithmus ist O (n * m). </p><br><h2 id="sobstvennye-realizacii">  Eigene Implementierungen </h2><br><h3 id="niccolum_flatten">  niccolum_flatten </h3><br><div class="spoiler">  <b class="spoiler_title">Implementierung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">niccolum_flatten</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" Non recursive algorithm Based on pop/insert elements in current list """</span></span> new_array = array[:] ind = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> isinstance(new_array[ind], list): item = new_array.pop(ind) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> inner_item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reversed(item): new_array.insert(ind, inner_item) ind += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> IndexError: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new_array</code> </pre> </div></div><br><p>  Als ich irgendwie über Telegramme mit der Öffentlichkeit @ru_python_beginners über die Implementierung des Entpackens verschachtelter Listen mit unbestimmter Verschachtelung sprach, schlug ich meine eigene Version vor. </p><br><p>  Es besteht darin, dass wir die ursprüngliche Liste kopieren (um sie nicht zu ändern) und dann in der while True-Schleife prüfen, ob das Element eine Liste ist - wir gehen sie durch und fügen das Ergebnis ganz am Anfang ein. </p><br><p>  Ja, jetzt verstehe ich, dass es nicht optimal und schwierig aussieht, weil  Die Neuindizierung erfolgt jedes Mal (weil wir sie oben in der Liste hinzufügen und entfernen). Diese Option hat jedoch auch das Recht auf Leben und wir werden ihre Implementierung zusammen mit dem Rest überprüfen. </p><br><p>  Die Komplexität dieses Algorithmus beträgt O (n ^ 3 * m), da die Liste für jede übergebene Iteration zweimal neu erstellt wird </p><br><h3 id="tishka_flatten">  tishka_flatten </h3><br><div class="spoiler">  <b class="spoiler_title">Implementierung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tishka_flatten</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" Non recursive algorithm Based on append/extend elements to new list """</span></span> nested = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> nested: new = [] nested = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(i, list): new.extend(i) nested = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: new.append(i) data = new <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> </div></div><br><p>  Einer der ersten zeigte auch die Implementierung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Tishka17</a> .  Es besteht in der Tatsache, dass innerhalb der while-verschachtelten Schleife die vorhandene Liste mit dem Schlüssel nested = False durchlaufen wird. Wenn mindestens einmal ein Blatt vorhanden ist, wird das Flag nested = True verlassen und dieses Blatt auf die Liste erweitert.  Dementsprechend stellt sich heraus, dass für jeden Lauf eine Verschachtelungsebene festgelegt wird, wie viele Verschachtelungsebenen es geben wird - es wird so viele Durchgänge durch den Zyklus geben.  Wie aus der Beschreibung hervorgeht, ist dies nicht der optimalste Algorithmus, unterscheidet sich jedoch von den anderen. <br>  Die Komplexität dieses Algorithmus ist O (n * m). </p><br><h3 id="zart_flatten">  zart_flatten </h3><br><div class="spoiler">  <b class="spoiler_title">Implementierung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zart_flatten</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" Non recursive algorithm Based on pop from old and append elements to new list """</span></span> queue, out = [a], [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> queue: elem = queue.pop(<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(elem, list): queue.extend(elem) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: out.append(elem) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out[::<span class="hljs-number"><span class="hljs-number">-1</span></span>]</code> </pre> </div></div><br><p>  Ein Algorithmus, der auch von einem der erfahrenen Chat-Teilnehmer vorgeschlagen wurde.  Meiner Meinung nach ist es ganz einfach und sauber.  Wenn das Element eine Liste ist, fügen wir das Ergebnis am Ende der ursprünglichen Liste hinzu. Wenn nicht, fügen wir es der Ausgabe hinzu.  Ich werde es unter dem Extend / Append-Mechanismus nennen.  Als Ergebnis zeigen wir die invertierte resultierende resultierende flache Liste an, um die ursprüngliche Reihenfolge der Elemente beizubehalten. </p><br><p>  Die Komplexität dieses Algorithmus ist O (n * m). </p><br><h3 id="recursive_flatten_iterator">  recursive_flatten_iterator </h3><br><div class="spoiler">  <b class="spoiler_title">Implementierung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recursive_flatten_iterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arr: Iterable)</span></span></span><span class="hljs-function"> -&gt; Iterator:</span></span> <span class="hljs-string"><span class="hljs-string">""" Recursive algorithm based on iterator Usual solution to this problem """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arr: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(i, list): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> recursion_flatten(i) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> i</code> </pre> </div></div><br><p>  Die wahrscheinlich häufigste Lösung für dieses Problem ist die Rekursion und Ausbeute aus.  Es kann wenig gesagt werden - der Algorithmus scheint recht einfach und effizient zu sein, abgesehen von der Tatsache, dass er durch Rekursion erfolgt und bei großen Gehäusen ein ziemlich großer Stapel von Anrufen vorhanden sein kann. </p><br><p>  Die Komplexität dieses Algorithmus ist O (n * m). </p><br><h3 id="recursive_flatten_generator">  recursive_flatten_generator </h3><br><div class="spoiler">  <b class="spoiler_title">Implementierung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recursive_flatten_generator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" Recursive algorithm Looks like recursive_flatten_iterator, but with extend/append """</span></span> lst = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> array: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(i, list): lst.extend(recursive_flatten_list(i)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: lst.append(i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lst</code> </pre> </div></div><br><p>  Diese Funktion ist der vorhergehenden ziemlich ähnlich, sie wird nur nicht über einen Iterator ausgeführt, sondern über einen rekursiven Extend / Append-Mechanismus. </p><br><p>  Die Komplexität dieses Algorithmus ist O (n * m). </p><br><h3 id="tishka_flatten_with_stack">  tishka_flatten_with_stack </h3><br><div class="spoiler">  <b class="spoiler_title">Implementierung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tishka_flatten_with_stack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(seq: Iterable)</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" Non recursive algorithm Based on zart_flatten, but build on try/except pattern """</span></span> stack = [iter(seq)] new = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> stack: i = stack.pop() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: data = next(i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(data, list): stack.append(i) i = iter(data) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: new.append(data) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> StopIteration: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new</code> </pre> </div></div><br><p>  Ein weiterer von Tishka bereitgestellter Algorithmus, der zart_flatten tatsächlich sehr ähnlich ist, wurde dort jedoch durch einen einfachen Extend / Append-Mechanismus und dann durch Iteration in einer Endlosschleife implementiert, in der dieser Mechanismus verwendet wird.  So stellte sich heraus, dass es ähnlich wie zart_flatten war, aber durch Iteration und während True. </p><br><p>  Die Komplexität dieses Algorithmus ist O (n * m). </p><br><h1 id="chast-2-dannye">  Teil 2. Daten </h1><br><p>  Um die Wirksamkeit dieser Algorithmen zu testen, müssen wir Funktionen für die automatische Generierung von Listen einer bestimmten Verschachtelung erstellen, mit denen ich mich erfolgreich befasst habe und die Ihnen das folgende Ergebnis zeigen: </p><br><h3 id="create_data_decreasing_depth">  create_data_decreasing_depth </h3><br><div class="spoiler">  <b class="spoiler_title">Implementierung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_data_decreasing_depth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( data: Union[List, Iterator], length: int, max_depth: int, _current_depth: int = None, _result: List = None )</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" creates data in depth on decreasing. Examples: &gt;&gt;&gt; data = create_data_decreasing_depth(list(range(1, 11)), length=5, max_depth=3) &gt;&gt;&gt; assert data == [[[1, 2, 3, 4, 5], 6, 7, 8, 9, 10]] &gt;&gt;&gt; data = create_data_decreasing_depth(list(range(1, 11)), length=2, max_depth=3) &gt;&gt;&gt; assert data == [[[1, 2], 3, 4], 5, 6], [[7, 8,] 9, 10]] """</span></span> _result = _result <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> [] _current_depth = _current_depth <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> max_depth data = iter(data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _current_depth - <span class="hljs-number"><span class="hljs-number">1</span></span>: _result.append(create_data_decreasing_depth( data=data, length=length, max_depth=max_depth, _current_depth=_current_depth - <span class="hljs-number"><span class="hljs-number">1</span></span>, _result=_result)) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: _current_length = length <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> _current_length: item = next(data) _result.append(item) _current_length -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> max_depth == _current_depth: _result += create_data_decreasing_depth( data=data, length=length, max_depth=max_depth) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _result <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> StopIteration: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _result</code> </pre> </div></div><br><p>  Diese Funktion erstellt verschachtelte Listen mit abnehmender Verschachtelung. </p><br><pre> <code class="python hljs"> &gt;&gt;&gt; data = create_data_decreasing_depth(list(range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>)), length=<span class="hljs-number"><span class="hljs-number">5</span></span>, max_depth=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> data == [[[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>], <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]] &gt;&gt;&gt; data = create_data_decreasing_depth(list(range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>)), length=<span class="hljs-number"><span class="hljs-number">2</span></span>, max_depth=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> data == [[[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>], [[<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>,] <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]]</code> </pre> <br><h3 id="create_data_increasing_depth">  create_data_increasing_depth </h3><br><div class="spoiler">  <b class="spoiler_title">Implementierung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_data_increasing_depth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( data: Union[List, Iterator], length: int, max_depth: int, _current_depth: int = None, _result: List = None )</span></span></span><span class="hljs-function"> -&gt; List:</span></span> <span class="hljs-string"><span class="hljs-string">""" creates data in depth to increase. Examples: &gt;&gt;&gt; data = create_data_increasing_depth(list(range(1, 11)), length=5, max_depth=3) &gt;&gt;&gt; assert data == [1, 2, 3, 4, 5, [6, 7, 8, 9, 10]] &gt;&gt;&gt; data = create_data_increasing_depth(list(range(1, 11)), length=2, max_depth=3) &gt;&gt;&gt; assert data == [1, 2, [3, 4, [5, 6]]], 7, 8, [9, 10]] """</span></span> _result = _result <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> [] _current_depth = _current_depth <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> max_depth data = iter(data) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: _current_length = length <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> _current_length: item = next(data) _result.append(item) _current_length -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> StopIteration: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _result <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _current_depth - <span class="hljs-number"><span class="hljs-number">1</span></span>: tmp_res = create_data_increasing_depth( data=data, length=length, max_depth=max_depth, _current_depth=_current_depth - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tmp_res: _result.append(tmp_res) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> max_depth == _current_depth: tmp_res = create_data_increasing_depth( data=data, length=length, max_depth=max_depth) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tmp_res: _result += tmp_res <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _result</code> </pre> </div></div><br><p>  Diese Funktion erstellt verschachtelte Listen mit zunehmender Verschachtelung. </p><br><pre> <code class="python hljs"> &gt;&gt;&gt; data = create_data_increasing_depth(list(range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>)), length=<span class="hljs-number"><span class="hljs-number">5</span></span>, max_depth=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> data == [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, [<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]] &gt;&gt;&gt; data = create_data_increasing_depth(list(range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>)), length=<span class="hljs-number"><span class="hljs-number">2</span></span>, max_depth=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> data == [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]]], <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, [<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]]</code> </pre> <br><h3 id="generate_data">  generate_data </h3><br><div class="spoiler">  <b class="spoiler_title">Implementierung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt; List[Tuple[str, Dict[str, Union[range, Num]]]]:</span></span> <span class="hljs-string"><span class="hljs-string">""" Generated collections of Data by pattern {amount_item}_amount_{length}_length_{max_depth}_max_depth where: .. py:attribute:: amount_item: len of flatten elements .. py:attribute:: length: len of elements at the same level of nesting .. py:attribute:: max_depth: highest possible level of nesting """</span></span> data = [] amount_of_elements = [<span class="hljs-number"><span class="hljs-number">10</span></span> ** i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>)] data_template = <span class="hljs-string"><span class="hljs-string">'{amount_item}_amount_{length}_length_{max_depth}_max_depth'</span></span> <span class="hljs-comment"><span class="hljs-comment"># amount_item doesn't need to be [1] for amount_item in amount_of_elements[1:]: for max_depth in amount_of_elements: # for exclude flatten list after generate data by create_data_increasing_depth if amount_item &gt; max_depth: # generate four types of length for length in range(0, max_depth + 1, math.ceil(max_depth / 4)): # min length must be 1 length = length or 1 data_name = data_template.format( amount_item=amount_item, length=length, max_depth=max_depth ) data_value = { 'data': range(amount_item), 'length': length, 'max_depth': max_depth } data.append((data_name, data_value)) # for not to produce more than 1 flat entity if max_depth == 1: break # this order is convenient for me data = sorted(data, key=lambda x: [x[1]['data'][-1], x[1]['max_depth'], x[1]['length']]) return data</span></span></code> </pre> </div></div><br><p>  Diese Funktion erstellt direkt Muster für Testdaten.  Zu diesem Zweck werden von der Vorlage erstellte Header generiert. </p><br><pre> <code class="python hljs">data_template = <span class="hljs-string"><span class="hljs-string">'{amount_item}_amount_{length}_length_{max_depth}_max_depth'</span></span></code> </pre> <br><p>  Wo: </p><br><ul><li>  Betrag - die Gesamtzahl der Elemente in der Liste </li><li>  Länge - Die Anzahl der Elemente auf einer Verschachtelungsebene </li><li>  max_depth - maximale Anzahl von Verschachtelungsebenen </li></ul><br><p>  Die Daten selbst werden an die obigen Funktionen übertragen, um die erforderlichen Daten zu generieren.  Dementsprechend werden wir bei der Ausgabe, wie wir später sehen werden, die folgenden Daten (Header) haben: </p><br><pre> <code class="plaintext hljs">10_amount_1_length_1_max_depth 100_amount_1_length_1_max_depth 100_amount_1_length_10_max_depth 100_amount_3_length_10_max_depth 100_amount_6_length_10_max_depth 100_amount_9_length_10_max_depth 1000_amount_1_length_1_max_depth 1000_amount_1_length_10_max_depth 1000_amount_3_length_10_max_depth 1000_amount_6_length_10_max_depth 1000_amount_9_length_10_max_depth 1000_amount_1_length_100_max_depth 1000_amount_25_length_100_max_depth 1000_amount_50_length_100_max_depth 1000_amount_75_length_100_max_depth 1000_amount_100_length_100_max_depth 10000_amount_1_length_1_max_depth 10000_amount_1_length_10_max_depth 10000_amount_3_length_10_max_depth 10000_amount_6_length_10_max_depth 10000_amount_9_length_10_max_depth 10000_amount_1_length_100_max_depth 10000_amount_25_length_100_max_depth 10000_amount_50_length_100_max_depth 10000_amount_75_length_100_max_depth 10000_amount_100_length_100_max_depth 10000_amount_1_length_1000_max_depth 10000_amount_250_length_1000_max_depth 10000_amount_500_length_1000_max_depth 10000_amount_750_length_1000_max_depth 10000_amount_1000_length_1000_max_depth</code> </pre> <br><h1 id="chast-3-rezultaty">  Teil 3. Ergebnisse </h1><br><p>  Um die CPU zu profilieren, habe ich line_profiler verwendet <br>  Zum Zeichnen - timeit + matplotlib </p><br><h4 id="cpu-profayler">  CPU Profiler </h4><br><div class="spoiler">  <b class="spoiler_title">Fazit</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ kernprof -l funcs.py $ python -m line_profiler funcs.py.lprof Timer unit: 1e-06 s Total time: 1.7e-05 s File: funcs.py Function: outer_flatten_1 at line 11 Line # Hits Time Per Hit % Time Line Contents ============================================================== 11 @profile 12 def outer_flatten_1(array: Iterable) -&gt; List: 13 """ 14 Based on C realization of this solution 15 More on: 16 17 https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html 18 19 https://github.com/MSeifert04/iteration_utilities/blob/384948b4e82e41de47fa79fb73efc56c08549b01/src/deepflatten.c 20 """ 21 2 17.0 8.5 100.0 return deepflatten(array) Total time: 3.3e-05 s File: funcs.py Function: outer_flatten_2 at line 24 Line # Hits Time Per Hit % Time Line Contents ============================================================== 24 @profile 25 def outer_flatten_2(array: Iterable) -&gt; List: 26 """ 27 recursive algorithm, vaguely reminiscent of recursion_flatten. Based on next pattern: 28 29 .. code:: python 30 31 try: 32 tree = iter(node) 33 except TypeError: 34 yield node 35 36 more on: 37 https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.collapse 38 """ 39 2 33.0 16.5 100.0 return collapse(array) Total time: 0.105099 s File: funcs.py Function: niccolum_flatten at line 42 Line # Hits Time Per Hit % Time Line Contents ============================================================== 42 @profile 43 def niccolum_flatten(array: Iterable) -&gt; List: 44 """ 45 Non recursive algorithm 46 Based on pop/insert elements in current list 47 """ 48 49 2 39.0 19.5 0.0 new_array = array[:] 50 2 6.0 3.0 0.0 ind = 0 51 2 2.0 1.0 0.0 while True: 52 20002 7778.0 0.4 7.4 try: 53 21010 13528.0 0.6 12.9 while isinstance(new_array[ind], list): 54 1008 1520.0 1.5 1.4 item = new_array.pop(ind) 55 21014 13423.0 0.6 12.8 for inner_item in reversed(item): 56 20006 59375.0 3.0 56.5 new_array.insert(ind, inner_item) 57 20000 9423.0 0.5 9.0 ind += 1 58 2 2.0 1.0 0.0 except IndexError: 59 2 2.0 1.0 0.0 break 60 2 1.0 0.5 0.0 return new_array Total time: 0.137481 s File: funcs.py Function: tishka_flatten at line 63 Line # Hits Time Per Hit % Time Line Contents ============================================================== 63 @profile 64 def tishka_flatten(data: Iterable) -&gt; List: 65 """ 66 Non recursive algorithm 67 Based on append/extend elements to new list 68 69 """ 70 2 17.0 8.5 0.0 nested = True 71 1012 1044.0 1.0 0.8 while nested: 72 1010 1063.0 1.1 0.8 new = [] 73 1010 992.0 1.0 0.7 nested = False 74 112018 38090.0 0.3 27.7 for i in data: 75 111008 50247.0 0.5 36.5 if isinstance(i, list): 76 1008 1431.0 1.4 1.0 new.extend(i) 77 1008 1138.0 1.1 0.8 nested = True 78 else: 79 110000 42052.0 0.4 30.6 new.append(i) 80 1010 1406.0 1.4 1.0 data = new 81 2 1.0 0.5 0.0 return data Total time: 0.062931 s File: funcs.py Function: zart_flatten at line 84 Line # Hits Time Per Hit % Time Line Contents ============================================================== 84 @profile 85 def zart_flatten(a: Iterable) -&gt; List: 86 """ 87 Non recursive algorithm 88 Based on pop from old and append elements to new list 89 """ 90 2 20.0 10.0 0.0 queue, out = [a], [] 91 21012 12866.0 0.6 20.4 while queue: 92 21010 16849.0 0.8 26.8 elem = queue.pop(-1) 93 21010 17768.0 0.8 28.2 if isinstance(elem, list): 94 1010 1562.0 1.5 2.5 queue.extend(elem) 95 else: 96 20000 13813.0 0.7 21.9 out.append(elem) 97 2 53.0 26.5 0.1 return out[::-1] Total time: 0.052754 s File: funcs.py Function: recursive_flatten_generator at line 100 Line # Hits Time Per Hit % Time Line Contents ============================================================== 100 @profile 101 def recursive_flatten_generator(array: Iterable) -&gt; List: 102 """ 103 Recursive algorithm 104 Looks like recursive_flatten_iterator, but with extend/append 105 106 """ 107 1010 1569.0 1.6 3.0 lst = [] 108 22018 13565.0 0.6 25.7 for i in array: 109 21008 17060.0 0.8 32.3 if isinstance(i, list): 110 1008 6624.0 6.6 12.6 lst.extend(recursive_flatten_generator(i)) 111 else: 112 20000 13622.0 0.7 25.8 lst.append(i) 113 1010 314.0 0.3 0.6 return lst Total time: 0.054103 s File: funcs.py Function: recursive_flatten_iterator at line 116 Line # Hits Time Per Hit % Time Line Contents ============================================================== 116 @profile 117 def recursive_flatten_iterator(arr: Iterable) -&gt; Iterator: 118 """ 119 Recursive algorithm based on iterator 120 Usual solution to this problem 121 122 """ 123 124 22018 20200.0 0.9 37.3 for i in arr: 125 21008 19363.0 0.9 35.8 if isinstance(i, list): 126 1008 6856.0 6.8 12.7 yield from recursive_flatten_iterator(i) 127 else: 128 20000 7684.0 0.4 14.2 yield i Total time: 0.056111 s File: funcs.py Function: tishka_flatten_with_stack at line 131 Line # Hits Time Per Hit % Time Line Contents ============================================================== 131 @profile 132 def tishka_flatten_with_stack(seq: Iterable) -&gt; List: 133 """ 134 Non recursive algorithm 135 Based on zart_flatten, but build on try/except pattern 136 """ 137 2 24.0 12.0 0.0 stack = [iter(seq)] 138 2 5.0 2.5 0.0 new = [] 139 1012 357.0 0.4 0.6 while stack: 140 1010 435.0 0.4 0.8 i = stack.pop() 141 1010 328.0 0.3 0.6 try: 142 1010 330.0 0.3 0.6 while True: 143 22018 17272.0 0.8 30.8 data = next(i) 144 21008 18951.0 0.9 33.8 if isinstance(data, list): 145 1008 997.0 1.0 1.8 stack.append(i) 146 1008 1205.0 1.2 2.1 i = iter(data) 147 else: 148 20000 15413.0 0.8 27.5 new.append(data) 149 1010 425.0 0.4 0.8 except StopIteration: 150 1010 368.0 0.4 0.7 pass 151 2 1.0 0.5 0.0 return new</code> </pre> </div></div><br><h4 id="grafiki">  Grafiken </h4><br><p>  Gesamtergebnis: </p><br><p><img src="https://habrastorage.org/webt/mv/hn/er/mvhner8sf4u_w9alvn647vudda0.png"></p><br><p>  Mit Ausnahme der langsamsten Funktionen erhalten wir: </p><br><p><img src="https://habrastorage.org/webt/gs/nm/pg/gsnmpgozl3yv02xdzllnuqvlif0.png"></p><br><h1 id="chast-4-vyvody">  Teil 4. Schlussfolgerungen </h1><br><p>  Vielleicht werde ich das Offensichtliche sagen, aber trotz der bekannten Komplexität der Algorithmen ist das Ergebnis möglicherweise nicht offensichtlich.  Die Funktion niccolum_flatten, deren Komplexität am höchsten war, trat in die Endphase ein und war weit vom letzten Platz entfernt.  Und der rekursive_flatten_generator erwies sich als viel schneller als der rekursive_flatten_iterator. </p><br><p>  Zusammenfassend möchte ich zunächst sagen, dass dies eher eine Studie als eine Anleitung zum Schreiben effektiver Algorithmen zum Entpacken von Listen war.  Normalerweise können Sie die einfachste Implementierung schreiben, ohne zu überlegen, ob sie die schnellste ist, weil  wenig Einsparungen. </p><br><h3 id="poleznye-ssylki">  Nützliche Links </h3><br><p>  Vollständigere Ergebnisse finden Sie <a href="">hier.</a> <br>  Repository mit Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> <br>  Dokumentation über Sphinx <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> </p><br><p>  Wenn Sie Fehler finden, schreiben Sie an das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Niccolum-</a> Telegramm oder an lastsal@mail.ru. <br>  Ich werde mich über konstruktive Kritik freuen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465531/">https://habr.com/ru/post/de465531/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465521/index.html">Fly-Fly-Petal ... oder eine Geschichte darüber, wie der UX-Designer sein Produkt auf Instagram beworben hat</a></li>
<li><a href="../de465523/index.html">Noch eine Android-Schlange mit Kivy, Python</a></li>
<li><a href="../de465525/index.html">Mobile Berichte zu Oracle BI EE 12c - eins, zwei, drei. Methodik aus dem Oracle BI EE 12c CAD-Kurs</a></li>
<li><a href="../de465527/index.html">Die lange Reise von RFC 4357 zu RFC 8645 oder die Verwaltung von Verschlüsselungsschlüsseln</a></li>
<li><a href="../de465529/index.html">Federung über Blockierung</a></li>
<li><a href="../de465535/index.html">Wer implementiert IPv6 und was behindert seine Entwicklung?</a></li>
<li><a href="../de465537/index.html">Yandex: ein Smart Home für Erwachsene</a></li>
<li><a href="../de465539/index.html">766 km - ein neuer Reichweitenrekord für LoRaWAN</a></li>
<li><a href="../de465541/index.html">Vom Unternehmen zum KMU: Wir teilen unsere Erfahrung bei der Anpassung von Unternehmenslösungen für kleine und mittlere Unternehmen mit Monetarisierung mithilfe des SaaS-Modells</a></li>
<li><a href="../de465545/index.html">Auf verschiedenen Seiten des Staates: Wie Facebook im US-Kongress gebraten wurde, während Telegram mit dem FSB kämpfte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>