<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧕🏻 🤹🏾 🛌🏾 Generasi sinyal PWM multifase pada TMS320F28027 👳 ⏮️ 🕙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sekali waktu  di galaksi yang jauh  Saya menulis artikel pendek tentang pengontrol Piccolo khusus dari Texas Instruments, yang dirancang untuk mengont...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generasi sinyal PWM multifase pada TMS320F28027</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457548/"><p>  Sekali waktu <del>  di galaksi yang jauh </del>  Saya menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pendek</a> tentang pengontrol Piccolo khusus dari Texas Instruments, yang dirancang untuk mengontrol konverter daya dan drive listrik.  Pengontrol ini adalah alat pengembangan yang sangat kuat dalam banyak tugas dan saya ingin menulis hal lain tentang mereka ... sederhana dan bermanfaat. </p><br><p>  Baru-baru ini, saya bingung untuk mengembangkan pengontrol untuk kontrol motor dan, dengan demikian, topik untuk artikel dibentuk - hari ini saya akan berbicara tentang proses pembentukan PWM tiga fase untuk kontrol motor, serta menjelaskan perbedaan yang menguntungkan antara TMS320F28 dan pengontrol lainnya seperti STM32F334, STM32G484, XMC4200 dan lainnya. </p><br><p>  Sebagai dudukan, saya akan menggunakan pengontrol yang sedang dikembangkan, sayangnya, saya tidak bisa membicarakan bagian besi secara detail.  Namun, jika saya mengatakan bahwa controller dibangun berdasarkan bundel TMS320F28027 + DRV8353RSRGZT, maka Anda dapat melihat lembar data driver dan melihat konsep sirkuit umum + ada debugging pada batu ini dan desain referensi terbuka di atasnya. </p><br><p><img src="https://habrastorage.org/webt/bu/ps/ur/bupsur6y9nfobnpa53zqjrfodmo.jpeg" alt="Driver BLDC"></p><br><p>  Pada prinsipnya, pada jenis sirkuit yang sama dimungkinkan untuk mengendalikan motor BLDC yang "mengonsumsi" level tegangan dan tiga fase biasa, yang sudah menginginkan keluaran sinusoidal.  Saya akan menunjukkan kedua opsi, sebagai  jalur ke sinus terletak melalui pembentukan level tegangan. </p><br><p><img src="https://habrastorage.org/webt/qf/rd/ck/qfrdck6y4rcvirbws9o6zbzrfea.png" alt="Nomor osilogram 1"></p><a name="habracut"></a><br><h1 id="nemnogo-o-zheleze">  Sedikit tentang besi </h1><br><p>  Bagian daya dari driver secara ideologis terdiri dari 3 konverter setengah jembatan, mungkin semua chastotnik dan pengontrol untuk mengendalikan mesin BLDC di semua copters dibuat dengan cara yang sama: </p><br><p><img src="https://habrastorage.org/webt/fm/kd/3t/fmkd3tequjgg3gapytg5bvupwfw.png" alt="Jembatan tiga fase"></p><br><p>  Satu perbedaan - saya tidak memiliki penyearah input, karena  controller pada awalnya ditenagai oleh tegangan konstan.  Sumber daya dalam kasus saya adalah rakitan baterai li-ion dalam bentuk sel 18650. Pengemudi DRV8353RSRGZT yang digunakan dapat mengontrol hanya 3 daya setengah jembatan, juga dalam versi batu yang digunakan juga ada op-amp built-in untuk bekerja dengan shunt seperti sensor saat ini, built-in dc / dc, yang dapat mencerna hingga 70 ... 80V dan semua ini sangat fleksibel dikonfigurasi melalui SPI.  Sebagai contoh, sangat nyaman untuk dapat menyesuaikan arus pulsa maksimum dari kontrol transistor. </p><br><p>  Juga dalam seri ini ada driver dengan serangkaian fungsi yang berbeda, misalnya, ada dengan kontrol analog, bukan SPI atau tanpa built-in dc / dc dan tanpa op-amp.  Untuk harga mereka tidak jauh berbeda dan saya mengambil yang paling "berani" karena Anda mungkin sudah mengerti.  Semua ini terlihat sangat indah, tapi saya agak sembrono mendekati desain pengikat yang mengikat dan saya keluar 2 masalah signifikan.  Faktanya, hanya ada satu masalah - ini adalah overheating yang kuat: </p><br><p><img src="https://habrastorage.org/webt/hh/ud/hh/hhudhh5jk3tpwowsivbvjjar66e.jpeg" alt="Imager termal"></p><br><p>  Namun masalah ini disebabkan oleh 2 alasan.  Sebenarnya inti dari masalah adalah overheating dari pengemudi itu sendiri.  Pada termogram, pengemudi dimuat dengan arus 5A (baginya hampir menganggur) dan hanya pengemudi dan MK sendiri yang sedikit panas.  Transistor bahkan tidak terlihat, mereka memiliki suhu PCB, pada 5A ada sedikit kehilangan panas. </p><br><ul><li>  <strong>Kesalahan No. 1</strong> <br>  Saya diminta oleh seorang teman saya, jujur, saya akan menganggap ini sebagai hal terakhir - pengemudi memiliki built-in dc / dc, yang menerima 15 ... 50V input dan output 3.3V untuk menyalakan MK, logika, pembanding dan penguat operasional.  Tampaknya proyek saya memiliki microchip LM5008 dan LM5017 dalam bentuk microchip terpisah dan saya dengan tenang mengurangi 60V menjadi 3.3V tanpa pemanasan yang nyata pada arus 100-150 mA, tetapi semuanya ternyata lebih rumit - efisiensi keseluruhan konverter ternyata sekitar 65-70% pada arus 300 mA!  Faktanya adalah bahwa konverter itu sendiri dapat memberikan 3.3V, tetapi efisiensinya akan sedikit, optimal untuk mengatur tegangan keluaran 10-12-15V.  Ketika outputnya adalah 12V 100 mA, pengemudi saya berhenti melakukan pemanasan secara praktis, dan efisiensinya mencapai 88% yang menyenangkan.  <strong>Solusi untuk masalah</strong> ini adalah dengan menurunkan input 15 ... 50V ke 12V dengan built-in dc / dc, dan kemudian turunkan dari 12V ke 3.3V dengan dc / dc eksternal yang sudah murah. </li></ul><br><br><ul><li>  <strong>Kesalahan No. 2</strong> <br>  Kesalahan kedua lebih jelas dan hal pertama yang saya lakukan adalah berbuat dosa semampu saya.  Faktanya adalah bahwa untuk chip dalam paket QFN panas utama dihilangkan melalui "perut", biasanya duduk di GND dan, melalui beberapa vias (via), menempel ke tanah dan semua panas masuk ke sana dengan tenang.  Awalnya, saya tidak memperhitungkan efisiensi sedikit dari built-in dc / dc dengan perbedaan tegangan yang besar, jadi itu tidak mengganggu saya bahwa penurunan termal ("perut") menempel pada poligon GND solid pada lapisan dalam, pada lapisan luar saya tidak memiliki tembaga di bawah perut sebagai poligon GND  Akibatnya, ternyata ~ 0,5 W panas dilepaskan pada chip, dan menghilang di lapisan internal papan, yaitu, efisiensinya sangat buruk.  <strong>Solusi untuk masalah</strong> ini adalah Anda perlu membuat ground uji bumi pada lapisan luar (Lapisan Bawah) dan tidak melakukan ini: </li></ul><br><p><img src="https://habrastorage.org/webt/xj/hr/0g/xjhr0galowhdsrtub50fwouwj_s.png" alt="Papan sirkuit"></p><br><p>  Sebagai hasilnya, pada revisi kedua besi, kesalahan ini diperbaiki: konverter dc / dc eksternal 12-3.3V ditambahkan dan poligon GND juga diisi pada lapisan bawah dan bantalan chip ditanam di atasnya + poligon tanah solid internal dipertahankan.  Setelah perbaikan seperti itu, suhu dalam operasi berkelanjutan menurun dari +82 ke +43 <sup>o</sup> C: </p><br><p><img src="https://habrastorage.org/webt/_p/t9/qf/_pt9qfhtiicqqdj-kuo_ssg2zsm.png" alt="Termogram"></p><br><p>  Seperti yang Anda lihat, karena pengurangan kerugian, suhu telah menurun secara signifikan dalam kondisi yang sama, serta panas sekarang lebih merata di area papan dan tidak terlalu panas secara lokal baik driver atau mikrokontroler.  Pada prinsipnya, semuanya besi, tidak ada yang lebih menarik terjadi dan bekerja dengan stabil.  Akibatnya, mereka dapat merekomendasikan menggunakan driver <strong>DRV8353</strong> . </p><br><h1 id="realizaciya-apparatnogo-sdviga-faz-na-120suposup">  Implementasi pergeseran fase perangkat keras 120 <sup>o</sup> </h1><br><p>  Fitur dari jaringan tiga fase adalah bahwa arus dalam fase tidak sinkron, tetapi digeser oleh <sup>120o</sup> relatif terhadap yang tetangga.  Apa ini pergeseran fase 120 <sup>o</sup> secara umum?  Secara sederhana, ini adalah pergeseran titik awal generasi dengan 1/3 periode.  Dari sudut pandang matematika, periode sinyal adalah <em>2π</em> , yang berarti bahwa sinyal kedua harus digerakkan 2π / 3, dan yang ketiga dengan 4π / 3.  Dari sudut pandang elektronik, periode diatur oleh periode hitung mundur dari timer kami.  Misalnya, ketika clocking pada 60 MHz, kami ingin mendapatkan PWM dengan frekuensi 50 kHz, yang berarti bahwa periode penghitung waktu timer akan dari 0 hingga 1200 (60 000 Hz Hz / 50 Hz Hz = 1200).  Sekarang, untuk mendapatkan 3 fase dengan pergeseran <sup>120o,</sup> kita tidak perlu menyentuh fase 1, tambahkan +400 ke nilai saat ini untuk fase 2, tambahkan +800 ke fase saat ini. </p><br><p>  Jika kita menggunakan mikrokontroler pada inti korteks, maka kita dapat mengimplementasikan perubahan itu dengan menulis rumus matematika atau dengan menggunakan sinkronisasi acara.  Itu selalu luar biasa bagi saya mengapa ST, NXP dan yang lainnya tidak hanya mendaftar di mana nilai shift akan ditulis.  Untungnya, TI melakukan ini di TMS320F28xxx mereka, untuk mengatur perubahan, cukup tulis satu register!  Saya tidak akan memberi tahu Anda mengapa solusi perangkat lunak tidak optimal, saya hanya akan mengatakan bahwa itu menganggap formula MK tidak terlalu cepat.  Pro dengan sinkronisasi dari peristiwa sudah lebih memadai dan pada stm saya akan melakukan hal itu, tetapi opsi ini tidak memungkinkan mengubah nilai fase dengan cepat, yaitu, untuk beberapa jembatan yang dipindahkan fasa lagi hanya versi perangkat lunak yang tersisa.  Apakah keuntungan dari kemampuan untuk mengendalikan fase perangkat keras?  Terserah Anda untuk memutuskan, tugas saya adalah memberi tahu Anda bahwa itu mungkin.  Bagi saya, ini merupakan nilai tambah yang jelas ketika kita berbicara tentang mengendalikan drive listrik atau inverter tegangan dengan output tiga fase. </p><br><p>  Sekarang mari kita mengkonfigurasi generasi sinyal PWM dalam bentuk 3 pasangan komplementer dengan waktu mati dan pergeseran fase.  Sejauh ini tanpa sinus.  Saya akan menggunakan pasangan berikut: EPWM1A + EPWM1B, EPWM2A + EPWM2B dan EPWM4A + EPWM4B.  Ini adalah sinyal yang masuk dari mikrokontroler ke driver. </p><br><ul><li>  <strong>Langkah 1</strong> <br>  Kita perlu mengkonfigurasi multiplexer GPIO menggunakan register <em>GPAMUX</em> untuk bekerja dengan PWM dan mematikan <em>pull-up</em> output ke catu daya, sehingga ketika Anda menyalakannya, tidak ada log.1 pada semua kaki dan kunci tidak terbuka.  Perlindungan saat ini tentu saja akan menghemat, tetapi lebih baik tidak melakukannya.  Perlu juga diingat bahwa untuk mengakses register pengaturan, Anda harus mendapatkannya dengan perintah <em>EALLOW</em> dan kemudian kembali pada proteksi timpa dengan perintah <em>EDIS</em> . </li></ul><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitGPIOforPWM</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPAPUD.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Disable pull-up on GPIO0 (EPWM1A) GpioCtrlRegs.GPAPUD.bit.GPIO1 = 1; // Disable pull-up on GPIO1 (EPWM1B) GpioCtrlRegs.GPAMUX1.bit.GPIO0 = 1; // Configure GPIO0 as EPWM1A GpioCtrlRegs.GPAMUX1.bit.GPIO1 = 1; // Configure GPIO1 as EPWM1B GpioCtrlRegs.GPAPUD.bit.GPIO2 = 1; // Disable pull-up on GPIO2 (EPWM2A) GpioCtrlRegs.GPAPUD.bit.GPIO3 = 1; // Disable pull-up on GPIO3 (EPWM2B) GpioCtrlRegs.GPAMUX1.bit.GPIO2 = 1; // Configure GPIO2 as EPWM2A GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 1; // Configure GPIO3 as EPWM2B GpioCtrlRegs.GPAPUD.bit.GPIO6 = 1; // Disable pull-up on GPIO6 (EPWM4A) GpioCtrlRegs.GPAPUD.bit.GPIO7 = 1; // Disable pull-up on GPIO7 (EPWM4B) GpioCtrlRegs.GPAMUX1.bit.GPIO6 = 1; // Configure GPIO6 as EPWM4A GpioCtrlRegs.GPAMUX1.bit.GPIO7 = 1; // Configure GPIO7 as EPWM4B EDIS; }</span></span></code> </pre> <br><ul><li>  <strong>Langkah 2</strong> <br>  Atur generasi sinyal PWM.  Hal ini diperlukan untuk mendapatkan frekuensi 50 kHz dan pergeseran fasa 120o.  Dalam hal ini, saya menggunakan PWM biasa, karena dalam kontroler ini ada juga HRPWM, penting untuk diingat ini.  Modul PWM clock pada frekuensi inti, yaitu, 60 MHz, saya menunjukkan cara mengatur frekuensi PLL dalam artikel pertama pada TMS320, saya tidak akan mengulanginya, tetapi pada akhir artikel akan ada arsip dengan kode dan akan mungkin untuk mengintip di sana. </li></ul><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitPWM</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// EPWM Module 1 config EPwm1Regs.TBPRD = 600; // Set priod EPwm1Regs.TBPHS.half.TBPHS = 0; // Set phase EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; // Symmetrical mode EPwm1Regs.TBCTL.bit.PHSEN = TB_DISABLE; // Master enable EPwm1Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm1Regs.TBCTL.bit.SYNCOSEL = TB_CTR_ZERO; // Sync down-stream module EPwm1Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm1Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm1Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm1Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm1Regs.AQCTLA.bit.CAU = AQ_SET; EPwm1Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm1Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // enable dead-time module EPwm1Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // Active Hi complementary EPwm1Regs.DBFED = 20; // dead-time on 20 tick EPwm1Regs.DBRED = 20; // dead-time off 20 tick // EPWM Module 2 config EPwm2Regs.TBPRD = 600; EPwm2Regs.TBPHS.half.TBPHS = 400; // Set phase = 400/1200 * 360 = 120 deg EPwm2Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; EPwm2Regs.TBCTL.bit.PHSEN = TB_ENABLE; // Slave enable EPwm2Regs.TBCTL.bit.PHSDIR = TB_DOWN; // Count DOWN on sync (=120 deg) EPwm2Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm2Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; // sync flow-through EPwm2Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm2Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm2Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm2Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm2Regs.AQCTLA.bit.CAU = AQ_SET; EPwm2Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm2Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; EPwm2Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; EPwm2Regs.DBFED = 20; EPwm2Regs.DBRED = 20; // EPWM Module 4 config EPwm4Regs.TBPRD = 600; EPwm4Regs.TBPHS.half.TBPHS = 400; EPwm4Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; EPwm4Regs.TBCTL.bit.PHSEN = TB_ENABLE; EPwm4Regs.TBCTL.bit.PHSDIR = TB_UP; EPwm4Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm4Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; EPwm4Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm4Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm4Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm4Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm4Regs.AQCTLA.bit.CAU = AQ_SET; EPwm4Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm4Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; EPwm4Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; EPwm4Regs.DBFED = 20; EPwm4Regs.DBRED = 20; }</span></span></code> </pre> <br><p>  Sekarang, sedikit lebih detail ... di register <em>TBPRD kita</em> menulis periode, atau lebih tepatnya "periode / 2", karena  kami menganggap timer di kedua arah, ternyata periode 600 sesuai dengan frekuensi sinyal PWM output 50 kHz dalam mode pasangan komplementer.  Dalam register <em>TBPHS kita</em> menulis nilai fase dimana kita perlu menggeser, dalam hal ini 400 dari 600, yang sesuai dengan 2π / 3.  Perlu dicatat bahwa kita tidak memindahkan fase 1, jadi untuk itu shift adalah 0, untuk fase 2 shift adalah 400, masing-masing, tetapi untuk fase 3 akan tampak logis untuk menulis 800, tetapi 800 dari 600 entah bagaimana tidak benar-benar ... karena itu mereka menulis pergeseran tidak relatif ke fase 1, tetapi relatif ke yang sebelumnya, yaitu ke-2.  Hasilnya, kita mendapatkan bahwa pada fase ke-3 kita menulis 400 dan ini sesuai dengan 2π / 3 antara fase 2 dan 3, dan karena fase ke-2 sudah bergeser, maka antara fase 1 dan 3 akan ada "2π / 3 + 2π / 3 = 4π / 3 "dan dari sudut pandang elektronik semuanya terlihat logis. </p><br><p>  Agar fase memahami siapa yang bergerak relatif terhadap siapa, diperlukan bos, jadi EPWM1 ​​diatur menggunakan bit <em>PHSEN</em> ke mode master, dan EPWM2 dan EPWM4, masing-masing, sebagai budak.  Menggunakan bit <em>SYNCOSEL</em> , "titik" <em>sinkronisasi juga</em> diatur, yaitu, dari mana membaca pergeseran dari.  EPWM1 ​​disinkronkan dengan dimulainya timer, mis. Dengan periode nol, dan EPWM2 dan EPWM4 sudah disinkronkan relatif terhadap tepi sinyal dari saluran sebelumnya: saluran sebelumnya untuk EPWM2 adalah EPWM1, dan untuk EPWM4 itu adalah EPWM2. </p><br><p>  Sekarang tinggal menyalakan pasangan pelengkap dan mengatur durasi waktu mati.  Menggunakan bit <em>POLSEL</em> , <em>kami</em> menetapkan PWM non-invers, yaitu, setelah mencapai nilai yang ditetapkan komparator (referensi), log dihasilkan pada output.  1. Dalam <em>OUT_MODE kami</em> menetapkan generasi waktu mati di tepi dan pada jatuhnya sinyal.  Dengan demikian, dalam register <em>DBFED</em> dan <em>DBRED</em> tulis durasi waktu mati dalam kutu. </p><br><ul><li>  <strong>Langkah 3</strong> <br>  Sekarang tinggal menulis nilai faktor tugas dalam register <em>CMPA yang</em> sesuai untuk setiap saluran dan Anda dapat mengamati hasilnya. </li></ul><br><pre> <code class="cpp hljs"> EPwm1Regs.CMPA.half.CMPA = <span class="hljs-number"><span class="hljs-number">300</span></span>; <span class="hljs-comment"><span class="hljs-comment">// duty for output EPWM1A EPwm2Regs.CMPA.half.CMPA = 300; // duty for output EPWM2A EPwm4Regs.CMPA.half.CMPA = 300; // duty for output EPWM4A</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/sl/wy/6b/slwy6b5zoivfrdpbzlf9vpbsmms.png" alt="Tiga fase PWM"></p><br><p>  Voila!  Probe osiloskop terhubung ke output driver.  Saluran kuning adalah EPWM1 ​​kami, yaitu master.  Saluran biru adalah EPWM2 dan bergeser 2π / 3 (atau 400 sampel) relatif terhadap saluran kuning, dan saluran hijau digeser 400 sampel lainnya.  Jadi kita mendapatkan 3 fase, di mana setiap fase digeser oleh <sup>120o</sup> . </p><br><p>  Sekarang mari kita transfer probe osiloskop dari output dari jembatan daya ke sinyal kontrol yang keluar dari mikrokontroler dan periksa waktu mati di dalam pasangan pelengkap: </p><br><p><img src="https://habrastorage.org/webt/cd/aj/k7/cdajk7vfo9vs5d1yzvbuvtggy00.png" alt="Nomor osilogram 2"></p><br><p>  Seperti yang Anda lihat, waktu mati yang ditetapkan sesuai dengan yang asli.  Durasi satu sampel adalah <em>1 / 60.000.000 Hz = 16,6 ns</em> dan kami mendapatkan 20 sampel, yang setara dengan waktu mati 20,6 <em>16</em> ns = 332 ns, * yang kira-kira sama dengan yang diamati pada osilogram. </p><br><p>  Sebenarnya tempat ini bisa berguna, dalam bentuk yang sekarang.  Opsi yang paling jelas adalah multi-konverter dc / dc, bagi mereka yang tertarik untuk google <strong>konverter dc / dc interleaved</strong> .  Ini adalah solusi teknis yang sangat menarik yang dapat secara signifikan mengurangi ukuran induktansi daya, mengurangi kapasitansi keluaran kapasitor, dan juga meningkatkan efisiensi.  Pada TMS320F28027 sederhana, Anda dapat menerapkan konverter 4 fase dan semua ini akan sangat sederhana diimplementasikan dalam kode dan hanya di perangkat keras. </p><br><h1 id="generiruem-trehfaznoe-peremennoe-napryazhenie">  Kami menghasilkan tegangan bolak-balik tiga fase </h1><br><p>  Dalam banyak masalah, tidak akan cukup untuk mendapatkan nilai diskrit 0 atau VCC pada output, diperlukan gelombang sinus.  Saya punya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> yang membahas tentang pembentukan tegangan bolak-fase tunggal dan metode "tabular" digunakan di sana, yaitu nilai-nilai untuk gelombang sinus awalnya dihitung.  Pada prinsipnya, ini juga bisa dilakukan untuk tiga fase, tetapi saya ingin menunjukkan opsi alternatif, yaitu perhitungan nilai tugas secara real time atau on the fly. </p><br><p>  Ada satu fitur.  Frekuensi PWM dalam hal ini juga 50 kHz dan pergeseran fase diatur antara periode sinyal ini.  Oleh karena itu, ketika kita memodulasi sinusoid dengan frekuensi 50 Hz, pergeseran fase perangkat keras akan "hilang", masih akan ada di antara PWM, tetapi tidak di dalam sinusoid, sehingga harus dilakukan perangkat lunak.  Trigonometri adalah hal yang berat untuk TMS320F28027, tetapi ini tidak terlalu sibuk dengan saya, jadi biarlah itu diperhitungkan.  Jika Anda memiliki tugas yang membutuhkan banyak perhitungan, maka Anda memerlukan pengontrol dengan TMU dan FPU, misalnya, TMS320F280049, yang dapat mengubah matematika lebih cepat. </p><br><p>  Untuk memuat nilai tugas ke dalam PWM, kita memerlukan timer, periode yang akan mengatur frekuensi sampling.  Saya memerlukan periode 20 ms (1 / 50Hz = 20 ms) dan saya akan mengambil jumlah langkah dalam sinusoid, katakanlah 20, sebagai hasilnya, interupsi harus dihasilkan dengan frekuensi 0,02 s / 20 = 0,001 ms = 1 kHz dan dalam interupsi ini saya akan menulis nilai ke PWM .  Untuk kesederhanaan, saya akan mengambil timer <em>CPU0</em> biasa dan mengkonfigurasinya: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitTimer0ForGenerator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; PieVectTable.TINT0 = &amp;cpu_timer0_isr; EDIS; InitCpuTimers(); ConfigCpuTimer(&amp;CpuTimer0, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>); CpuTimer0Regs.TCR.bit.TIE = <span class="hljs-number"><span class="hljs-number">1</span></span>; CpuTimer0Regs.TCR.bit.TSS = <span class="hljs-number"><span class="hljs-number">0</span></span>; IER |= M_INT1; PieCtrlRegs.PIEIER1.bit.INTx7 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Enable TINT0 in the PIE: Group 1 interrupt 7 EINT; // Enable Global interrupt INTM ERTM; // Enable Global real-time interrupt DBGM } __interrupt void cpu_timer0_isr (void) { CpuTimer0.InterruptCount++; /* *   -  . ... */ PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; // Acknowledge this interrupt to receive more interrupts from group 1 }</span></span></code> </pre> <br><p>  Fungsi <em>InitCpuTimers</em> dan <em>ConfigCpuTimer adalah</em> standar, semua pengaturan ada di dalamnya, kita hanya perlu mentransfer frekuensi inti (60 MHz) dan periode penghitungan dalam mikrodetik (1000 μs = 1 ms), yang setara dengan 1 kHz, dan kami membutuhkannya.  Jadi di mana dalam fungsi konfigurasi kita mengaktifkan interupsi dan meneruskan alamat penangan interupsi kita, di mana semuanya akan terjadi. </p><br><p>  Sekarang perlu untuk "menciptakan" formula sinus lagi, untuk ini Anda perlu pengetahuan tentang trigonometri sekolah dan itu semua.  Jadi ... kita memiliki fungsi <strong><em>y = sin (x)</em></strong> mari kita plot fungsi ini: </p><br><p><img src="https://habrastorage.org/webt/hi/bx/ey/hibxeyajv_h7l7t-mqkbkfrq6-s.png" alt="y = sin (x)"></p><br><p>  Seperti yang dapat Anda lihat pada grafik, amplitudo y bervariasi dari -1 hingga 1, tetapi kami ingin dari 0 hingga 1, karena  dengan amplitudo minimum kami memiliki 0V, dan dengan maksimum (setara dengan 1) kami memiliki + VCC.  Untuk "menggambar" -1 ... + 1 kita membutuhkan nutrisi bipolar, tetapi tidak.  Anda perlu menggeser grafik ke arah yang positif.  Jika kita hanya mengangkatnya, maka akan menjadi dari 0 hingga +2, dan kita hanya bisa sampai +1.  Jadi, Anda perlu membagi dengan 2 dan hanya sesuatu!  Mari kita mulai dengan membagi dan merencanakan untuk <strong><em>y = (sin (x) / 2):</em></strong> </p><br><p><img src="https://habrastorage.org/webt/t_/n0/iw/t_n0iw1fym8aboggaxk1my7r4um.png" alt="y = (sin (x) / 2)"></p><br><p>  Ya!  Sekarang grafik memiliki rentang dari -0,5 ke +0,5, yaitu, amplitudo adalah 1. Ini sudah lebih baik, tetapi kami belum menyingkirkan nilai-nilai negatif, jadi mari kita geser grafik hingga 0,5, untuk ini kita hanya perlu menambahkan nilai ini ke hasil dan mendapatkan formula <strong><em>y = 0,5 + (sin (x) / 2)</em></strong> dan plot grafik untuk fungsi ini: </p><br><p><img src="https://habrastorage.org/webt/df/vu/ez/dfvuez1lks2uhg0cp3tkhie9cdq.png" alt="y = 0,5 + (sin (x) / 2)"></p><br><p>  Sekarang semuanya telah menjadi sangat sempurna: sinusoid memiliki amplitudo 0 hingga 1, tidak ada nilai negatif.  Rumus <strong><em>y = 0,5 + (sin (x) / 2)</em></strong> menggambarkan fase 1, sekarang perlu menambahkan pergeseran fase untuk mendapatkan fase 2 dan 3. Untuk melakukan ini, kurangi 2π / 3 dan 4π / 3 dari <em>x,</em> masing-masing, dan dapatkan formula untuk sisanya fase <strong><em>y = 0,5 + (sin (x-2π / 3) / 2)</em></strong> dan <strong><em>y = 0,5 + (sin (x-4π / 3) / 2).</em></strong>  Kami membuat 3 grafik dan melihat apakah itu terlihat benar: </p><br><p><img src="https://habrastorage.org/webt/hj/kp/n9/hjkpn93-37r_rclbrevchhdzf_m.png" alt="3 fase"></p><br><p>  Tidak buruk!  Gambar ini mirip dengan apa yang biasanya dilukis dalam buku teks teknik elektro ketika mereka berbicara tentang jaringan tiga fase atau motor asinkron.  Omong-omong, 2.0943 adalah 2π / 3, dan 4.1866 masing-masing adalah 4π / 3, saya langsung menghitungnya dan muncul di kode saya.  Total kami memiliki 3 persamaan: </p><br><ul><li>  Fase A - <strong><em>y = 0,5 + (sin (x) / 2)</em></strong> </li><li>  Fase B - <strong><em>y = 0,5 + (sin (x-2π / 3) / 2)</em></strong> </li><li>  Fase C - <strong><em>y = 0,5 + (sin (x-4π / 3) / 2)</em></strong> </li></ul><br><p>  Dari sisi matematika semuanya tampak sederhana dan jelas, tetapi sekarang Anda perlu menyesuaikannya dengan realitas mikrokontroler.  Gelombang sinus kami bukan analog, tetapi memiliki "langkah", yaitu diskrit, karena kami hanya dapat mengatur tegangan atau 0V atau + 15V (VCC) dalam kasus saya.  Sebelumnya, saya menulis bahwa saya akan memiliki 20 langkah, jadi untuk 1 periode saya akan memiliki 20 perhitungan. </p><br><p>  Pertama, mari kita putuskan apa yang harus diganti dengan <em>x</em> .  Periode sinusoid kita adalah <em>2π</em> , yang berarti bahwa langkah pengambilan sampelnya adalah <em>2π / 20</em> .  Oleh karena itu, sinusoid akan terdiri dari 20 titik, seolah-olah kita sedang membuat grafik pada titik-titik tersebut, dan perkiraan di antaranya.  Akibatnya, nilai pada langkah pertama adalah <strong><em>dosa (2π * (1/20),</em></strong> pada langkah kedua <strong><em>dosa (2π * (2/20)),</em></strong> pada langkah ketiga * <strong>dosa (2π <em>(3/20))</em></strong> dan seterusnya, ketika kita Jika mencapai <em>20/20</em> , ini berarti akhir periode dan akan perlu untuk mulai menghitung lagi. Berdasarkan data yang diterima, mari kita perbaiki rumus: </p><br><ul><li>  Fase A - <strong><em>y = 0,5 + (sin (2π * (n / N)) / 2)</em></strong> </li><li>  Fase B - <strong><em>y = 0,5 + (sin (2π * (n / N) -2π / 3) / 2)</em></strong> </li><li>  Fase C - <strong><em>y = 0,5 + (sin (2π * (n / N) -4π / 3) / 2)</em></strong> </li></ul><br><p>  Sekarang, kami sekarang mempertimbangkan nilai sinus pada setiap titik spesifik pada grafik.  Dengan demikian, <strong>n</strong> adalah langkah saat ini, <strong>N</strong> adalah langkah total (20).  Setelah rumus ini, kami mendapatkan nilai dari 0 hingga 1, tetapi dalam kenyataannya kami tidak beroperasi dengan amplitudo abstrak.  Amplitudo dalam kasus kami tergantung pada siklus tugas, karena  perubahan tugas dari 0 hingga 600 (dari pengaturan PWM), maka 0 adalah 0, dan 1 setara dengan 600. Berdasarkan hal ini, mari kita hitung kembali menjadi rumus nyata untuk mendapatkan nilai yang akan dimuat ke dalam <em>register</em> CMPA <em>PWM</em> : </p><br><ul><li>  Fase A - <strong><em>duty1 = A <em>(0,5 + (sin (2π</em> (n / N)) / 2))</em></strong> </li><li>  Fase B - <strong><em>duty2 = A <em>(0,5 + (sin (2π</em> (n / N) -2π / 3) / 2))</em></strong> </li><li>  Fase C - <strong><em>duty4 = A <em>(0,5 + (sin (2π</em> (n / N) -4π / 3) / 2))</em></strong> </li></ul><br><p>  Dengan demikian, <strong>A</strong> adalah nilai maksimum amplitudo, yaitu 600, <strong>n</strong> adalah langkah saat ini, <strong>N</strong> adalah jumlah langkah total (20).  Nilai-nilai <strong><em>duty1, duty2, duty4</em></strong> adalah nilai riil yang dikonversi dari faktor tugas, yang dimuat ke dalam <em>CMPA.</em>  Sekarang mari kita menulis kode untuk pengendali interupsi yang diperbarui dan mendeklarasikan semua variabel yang diperlukan: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> activeStep = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> amplitude = <span class="hljs-number"><span class="hljs-number">600.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> allStep = <span class="hljs-number"><span class="hljs-number">20.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pi = <span class="hljs-number"><span class="hljs-number">3.1415</span></span>; <span class="hljs-comment"><span class="hljs-comment">// π const float piTwo = 6.2831; // 2π const float phaseShifted120deg = 2.0943; // 2π/3 const float phaseShifted240deg = 4.1866; // 4π/3 __interrupt void cpu_timer0_isr (void) { if (activeStep &gt;= allStep) {activeStep = 0;} activeStep++; EPwm1Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep)) / 2)))); EPwm2Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep) - phaseShifted120deg) / 2)))); EPwm4Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep) - phaseShifted240deg) / 2)))); PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; // Acknowledge this interrupt to receive more interrupts from group 1 }</span></span></code> </pre><br><p>  Kode, seperti yang Anda lihat, adalah yang paling sederhana, jika Anda memahami apa yang harus dilakukan dan matematika sederhana dalam masalah yang harus dipecahkan.  Setiap kali interupsi dipanggil, kami menambah variabel <em>activeStep</em> , yang berisi nomor langkah, itu berubah dari 0 hingga 20 dan kemudian diatur ulang.  Ternyata dalam satu periode kami melakukan 20 langkah dan 20 perhitungan untuk setiap fase.  Agar tidak menghitung <em>2π / 3</em> dan <em>4π / 3</em> dalam rumus setiap saat, saya segera menghitungnya untuk digunakan sebagai konstanta. </p><br><p>  Perhitungannya ternyata minimum, untuk MK ini sama sekali bukan apa-apa.  Jika diinginkan, jumlah poin dapat ditingkatkan secara signifikan, misalnya hingga 200. Itu semua tergantung pada tugas.  Mengubah frekuensi PWM terjadi dengan mengubah frekuensi panggilan interupsi dan jumlah langkah.  Anda juga dapat mengubah <em>amplitudo</em> variabel dan mengubah tegangan pada output konverter daya. </p><br><p>  Setelah mengunduh kode ke mikrokontroler, Anda akan mendapatkan gambar yang sesuai: </p><br><p><img src="https://habrastorage.org/webt/qf/rd/ck/qfrdck6y4rcvirbws9o6zbzrfea.png" alt="Nomor osilogram 1"></p><br><p>  Jika Anda meregangkan grafik di sepanjang <em>Y</em> , maka menjadi lebih baik untuk melihat cacat sinyal.  Ini adalah konsekuensi dari sejumlah kecil langkah pengambilan sampel, aturan bersyarat berlaku: <strong>semakin banyak poin, semakin indah sinyal.</strong> </p><br><p><img src="https://habrastorage.org/webt/wh/4d/du/wh4dduwnbyshscey7rlmzs6s1mw.png" alt="Nomor osilogram 3"></p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Hari ini saya berbicara tentang proses pembentukan pergeseran fase dalam sistem multifase, pada prinsipnya, tidak ada yang rumit, terutama ketika menggunakan TMS320F28.  Sisanya terserah algoritma, pada prinsipnya, di Internet, ada banyak artikel di mana mengunyah kontrol dan motor brushless, dan asinkron dan segala macam yang lain, Anda hanya dapat menggeser logika. </p><br><p>  Semoga materi ini bermanfaat dan tidak terlalu membosankan untuk dibaca.  Seperti biasa, sumber terlampir: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsipkan dengan proyek untuk Code Composer Studio</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457548/">https://habr.com/ru/post/id457548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457534/index.html">Versi bersertifikat - penggaruk yang kita pilih</a></li>
<li><a href="../id457538/index.html">Bagaimana saya bisa menggunakan mesin virtual Yandex.Cloud yang terputus dan menghemat penyelesaian masalah skala besar</a></li>
<li><a href="../id457540/index.html">Memori Tetap Intel Optane DC, setahun kemudian</a></li>
<li><a href="../id457542/index.html">Meretas dan melindungi drive enkripsi LUKS</a></li>
<li><a href="../id457546/index.html">Demo Day: mengapa semuanya dan bagaimana melakukannya UPD + Broadcast</a></li>
<li><a href="../id457550/index.html">Apa yang harus dilindungi oleh industri digital</a></li>
<li><a href="../id457552/index.html">Pendaki di Zafasadia. Bagaimana promalps di menara Lakhta Center bekerja</a></li>
<li><a href="../id457558/index.html">Analisis Kerentanan EvilParcel</a></li>
<li><a href="../id457560/index.html">Saham Tokenized: Cara Menjadi Investor Gett Sebelum Pergi IPO</a></li>
<li><a href="../id457562/index.html">Ivideon Counter 3D: siapa, bagaimana dan mengapa menghitung pengunjung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>