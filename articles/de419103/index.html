<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õµÔ∏è üë£ üíû Schreiben eines einfachen √úbersetzers in Lisp - I. üë©üèª‚Äçüè´ üßôüèº üî™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Versuchen wir, in Lisp zu schreiben ... einem √úbersetzer einer einfachen imperativen Sprache. Nein, nein, ich habe mich nicht geirrt - es ist der √úber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schreiben eines einfachen √úbersetzers in Lisp - I.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419103/"><p>  Versuchen wir, in Lisp zu schreiben ... einem √úbersetzer einer einfachen imperativen Sprache.  Nein, nein, ich habe mich nicht geirrt - es ist der √úbersetzer.  Es wird im Lisp-Code ausgestrahlt.  Und dann kann dieser Code vom Lisp-System ausgef√ºhrt werden. </p><br><p>  Ein unsch√§tzbarer Service ist hier die Tatsache, dass es in Lisp keine Barriere zwischen Code und Daten gibt (dies ist eine seltene Eigenschaft einiger Programmiersprachen, die als ‚ÄûHomo-Identit√§t‚Äú bezeichnet werden).  Aber auch die visuellen F√§higkeiten von Lisp werden eine wichtige Rolle spielen. </p><br><p>  Als Implementierung werde ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HomeLisp verwenden</a> .  Interessenten k√∂nnen dieses Projekt an Common Lisp anpassen.  Ich werde gleich sagen - in Bezug auf das betrachtete Problem besteht der signifikante Unterschied zwischen Common Lisp und HomeLisp nur in der Verarbeitung von Zeilen und Dateien. </p><br><p>  Laden Sie hier eine tragbare Version von HomeLisp herunter.  Die Dokumentation befindet sich ebenfalls auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">derselben</a> Site.  Wer m√∂chte, kann den Code aus dem Artikel kopieren und sofort die Leistung √ºberpr√ºfen. </p><br><p> Das Thema, auf das Sie aufmerksam gemacht wurden, diente als Grundlage f√ºr meinen Workshop <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im ber√ºhmten Nowosibirsk LSHUP-2018</a> .  Die Ergebnisse des Workshops finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Und dann habe ich meinen Ansatz dargelegt.  Ich nehme an, der Leser ist mit der Lisp-Sprache vertraut. </p><br><h4 id="pristupaem">  Runter </h4><br><p>  Beginnen wir mit der ‚Äûeinfachen imperativen Sprache‚Äú, die wir in Lisp ausstrahlen werden. <br>  Die Sprache verarbeitet nur numerische Daten.  Code in dieser Sprache besteht aus Funktionen (Prozeduren, die Werte zur√ºckgeben).  Unter diesen Funktionen sollte man main nennen.  Mit dieser Funktion beginnt die Codeausf√ºhrung.  Obwohl, warum binden Sie sich so?  Wir schreiben Funktionen in einer imperativen Sprache, sie werden in Lisp ausgestrahlt und k√∂nnen zusammen mit Lisp-Funktionen verwendet werden.  Aber lasst uns nicht weiterkommen ... </p><a name="habracut"></a><br><p>  Die Menge der Sprachoperatoren ist √ºblich: Zuweisung, Verzweigung, Rechenzyklus, vorzeitiges Verlassen des Zyklus, Eingabe, Ausgabe und Funktionsaufruf.  Syntaktisch wird ein Funktionsaufruf jedoch als Zuordnung ausgef√ºhrt (Ergebnis eines Aufrufs).  Lassen Sie die Kommentare an der ersten Stelle der Zeile ein Sternchen enthalten.  Die Sprache sollte nat√ºrlich die M√∂glichkeit bieten, rekursive Funktionen zu erstellen.  Um es klarer zu machen, werde ich Beispiele f√ºr Code geben - aufeinanderfolgende ungerade Zahlen drucken und ihre Summe berechnen: </p><br><pre><code class="hljs lua">proc main() <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> s,n,k <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span> to n k=<span class="hljs-number"><span class="hljs-number">2</span></span>*i<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> k s=s+k end_for <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> s end_proc</code> </pre> <br><p>  In seinem Geist ist es eine grundlegende Sprache.  Ich werde es "Mini-Basic" nennen.  Unser √úbersetzer sollte den angegebenen Code in die folgende Lisp-Funktion konvertieren: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> main <span class="hljs-literal"><span class="hljs-literal">nil</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">s</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">n</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">k</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> n (<span class="hljs-name"><span class="hljs-name">read</span></span>)) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> i from <span class="hljs-number"><span class="hljs-number">1</span></span> to n) (<span class="hljs-name"><span class="hljs-name">setq</span></span> k (<span class="hljs-name"><span class="hljs-name">-</span></span> (<span class="hljs-name"><span class="hljs-name">*</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> i) <span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-name"><span class="hljs-name">printline</span></span> k) (<span class="hljs-name"><span class="hljs-name">setq</span></span> s (<span class="hljs-name"><span class="hljs-name">+</span></span> sk))) (<span class="hljs-name"><span class="hljs-name">printline</span></span> s)))</code> </pre> <br><p>  Ich mag das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">iterate-</a> Paket, das als Makro in professionellen Common Lisp-Paketen implementiert ist.  In HomeLisp ist die Iter-Funktion (die einen gro√üen Teil der Funktionen der Makro-Iteration implementiert) in der Kernsprache enthalten.  Es war meine Sucht nach Iter, die dazu f√ºhrte, dass die Zyklen unseres ‚ÄûMini-Basic‚Äú in Iter-Aufrufe √ºbersetzt wurden. </p><br><p>  Wo soll mit der Implementierung begonnen werden?  Beginnen wir mit der Auswahl der zu sendenden Datei und dem zeilenweisen Lesen und Drucken dieser Datei.  Wir m√ºssen den √úbersetzer viele Male starten, also lassen Sie dies von Anfang an bequem sein.  So k√∂nnte diese Funktion aussehen: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> fname) (<span class="hljs-name"><span class="hljs-name">setq</span></span> fname (<span class="hljs-name"><span class="hljs-name">sysGetOpenName</span></span> (<span class="hljs-name"><span class="hljs-name">sysHome</span></span>) <span class="hljs-string"><span class="hljs-string">"-|*.mbs"</span></span>))) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">fi</span></span> (<span class="hljs-name"><span class="hljs-name">gensym</span></span> 'fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> fname (<span class="hljs-name"><span class="hljs-name">filOpen</span></span> fi fname _INPUT) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">filEOF</span></span> fi)) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>))) (<span class="hljs-name"><span class="hljs-name">filClose</span></span> fi) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****   "</span></span>)))) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*numline*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*flagerr*))</code> </pre> <br><p>  Die Funktion verf√ºgt √ºber einen optionalen Parameter <strong>fname</strong> - den Namen der Datei, deren Inhalt gesendet wird.  Bei der Eingabe der Funktion werden zwei globale Variablen erstellt: <strong><em>numLine,</em></strong> Zeilennummer der Quelldatei und <strong><em>flagerr</em></strong> , das Fehlerstatus-Flag.  Bevor die Funktion beendet wird, werden diese Variablen zerst√∂rt (die nicht gesetzte HomeLisp-Funktion zerst√∂rt die globalen Variablen). </p><br><p>  Wenn der Name der Eingabedatei weggelassen wird, wird der Standarddialog zur Auswahl von Windows-Dateien <strong>(sysGetOpenName)</strong> aufgerufen.  Das aktuelle Verzeichnis <strong>(sysHome) wird</strong> als Startverzeichnis verwendet.  Als n√§chstes wird ein eindeutiges Zeichen f√ºr den Dateimanipulator erstellt und die Datei zum Lesen von Text ge√∂ffnet.  In einer Endlosschleife wird die Datei dann Zeile f√ºr Zeile gelesen (Funktion <strong>getLine</strong> ).  Nach jedem Vorgang wird gepr√ºft, ob ein Fehler aufgetreten ist und ob das Ende der Datei erreicht ist.  Wenn ein Fehler auftritt oder das Ende der Datei behoben ist, wird der Zyklus unterbrochen, die Datei wird geschlossen, und wenn Fehler aufgetreten sind, wird eine endg√ºltige Meldung angezeigt. <br>  Das eigentliche Lesen aus der Datei wird von der Funktion <strong>getLine ausgef√ºhrt</strong> : </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> getLine (<span class="hljs-name"><span class="hljs-name">fil</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stri</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">filEof</span></span> fil) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* (<span class="hljs-name"><span class="hljs-name">add1</span></span> *numline*)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> stri (<span class="hljs-name"><span class="hljs-name">filGetline</span></span> fil)) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> (<span class="hljs-name"><span class="hljs-name">format</span></span> *numline* <span class="hljs-string"><span class="hljs-string">"0000"</span></span>) <span class="hljs-string"><span class="hljs-string">" "</span></span> (<span class="hljs-name"><span class="hljs-name">strRTrim</span></span> stri))) (<span class="hljs-name"><span class="hljs-name">setq</span></span> stri (<span class="hljs-name"><span class="hljs-name">strATrim</span></span> stri)) (<span class="hljs-name"><span class="hljs-name">unless</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> stri) (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> stri <span class="hljs-number"><span class="hljs-number">1</span></span>))) (<span class="hljs-name"><span class="hljs-name">return</span></span> stri)))))</code> </pre> <br><p>  Diese Funktion akzeptiert die Kennung einer ge√∂ffneten Datei und f√ºhrt in einer Endlosschleife die folgenden Aktionen aus: </p><br><ul><li>  √úberpr√ºft den Status des Dateiende.  In diesem Fall wird die Schleife unterbrochen und die Funktion gibt eine leere Zeichenfolge zur√ºck. </li><li>  der Z√§hler der gelesenen Zeilen erh√∂ht sich um eins; </li><li>  Die n√§chste Zeile der Datei wird gelesen. </li><li>  Die gelesene Zeile wird gedruckt, wobei m√∂gliche Leerzeichen rechts entfernt werden. </li><li>  Wenn die Lesezeile nicht leer ist und an der ersten Stelle kein Sternchen enth√§lt, ist dies der Fall <br>  kehrt von der Funktion zur√ºck; </li></ul><br><p>  Somit fallen alle Zeilen der Datei in ihrer urspr√ºnglichen Form in die Ausgabeliste. </p><br><h4 id="razbivaem-na-procedury">  Wir brechen in Verfahren ein </h4><br><p>  Lassen Sie uns nun unseren Code lehren, den Eingabestream in separate Prozeduren aufzuteilen.  Zun√§chst muss die eingegebene Zeichenfolge in Token (unteilbare lexikalische Eingabeeinheiten) unterteilt werden.  Dieser Vorgang wird als Parsing bezeichnet.  Wir m√ºssen einen Parser erstellen.  Das Schreiben von Parsern ist ein klassisches Thema. Es gibt Bibliotheken mit vorgefertigten Parsern und Spezialwerkzeugen, mit denen Sie den erforderlichen Parser generieren k√∂nnen ... Wir werden unseren eigenen Weg gehen. </p><br><p>  Bevor wir den Parser-Algorithmus beschreiben, achten wir darauf, dass alle Zeichen der Eingabezeichenfolge in zwei Klassen unterteilt werden k√∂nnen: </p><br><ul><li>  Gew√∂hnliche Zeichen; </li><li>  Trennzeichen. </li></ul><br><p>  Im Zuweisungsoperator <strong>"x = 15 + y ^ 2" sind die</strong> Zeichen <strong>x, 1,5, y</strong> und <strong>2</strong> gew√∂hnliche Zeichen, und die Zeichen <strong>"Leerzeichen"</strong> , <strong>+</strong> , <strong>^</strong> sind Begrenzer.  Wie unterscheidet sich ein normales Zeichen von einem Trennzeichen?  Trennzeichen - trennt immer einen Token von einem anderen.  Unser Zuweisungsoperator, der in Token unterteilt ist, sieht folgenderma√üen aus: <strong>"x", "=", "15", "y", "^", "2"</strong> . </p><br><p>  Wie Sie sehen k√∂nnen, fallen nicht alle Trennzeichen in das Ergebnis der Analyse (insbesondere Leerzeichen fallen nicht).  Wir werden Trennzeichen, die nicht in das Ergebnis fallen, als Trennzeichen des ersten Typs bezeichnen.  Andere Trennzeichen werden als Trennzeichen des zweiten Typs bezeichnet. </p><br><p>  Die Eingabe des Parsers ist eine Zeichenfolge, die Ausgabe ist eine Liste von Zeichenfolgentoken.  Als Laufwerk wird eine lokale Variable verwendet - die Batterie.  Die Batterie enth√§lt zun√§chst eine leere Zeichenfolge. </p><br><p>  Der Parsing-Algorithmus kann wie folgt aussehen: Wir lesen die Eingabezeile Zeichen f√ºr Zeichen.  Wenn Sie einen normalen Charakter treffen, verketten Sie ihn mit der Batterie.  Wenn ein Trennzeichen gefunden wird, gilt Folgendes: </p><br><ul><li>  F√ºr das Trennzeichen des ersten Typs setzen wir den Batteriewert (falls er nicht leer ist) auf die Ausgabeliste zur√ºck, l√∂schen die Batterie und lesen das n√§chste Zeichen. </li><li>  F√ºr das Trennzeichen des zweiten Typs geben wir auch den Wert einer nicht leeren Batterie in die Ausgabeliste ein. Danach geben wir das akzeptierte Trennzeichen des zweiten Typs (als unabh√§ngiges Token) in die Ausgabeliste ein, l√∂schen die Batterie und lesen das n√§chste Zeichen. </li></ul><br><p>  Hier ist der Parser-Code: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> parser (<span class="hljs-name"><span class="hljs-name">txt</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">d1</span></span> <span class="hljs-string"><span class="hljs-string">" ,"</span></span>) (<span class="hljs-name"><span class="hljs-name">d2</span></span> <span class="hljs-string"><span class="hljs-string">"()+-*/\^=&lt;&gt;%"</span></span>)) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">res</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">lex</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>) ) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> s in-string (<span class="hljs-name"><span class="hljs-name">strCat</span></span> txt (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> d1 <span class="hljs-number"><span class="hljs-number">1</span></span>))) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">plusp</span></span> (<span class="hljs-name"><span class="hljs-name">strInd</span></span> d1 s)) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> lex) <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> lex into res)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> lex <span class="hljs-string"><span class="hljs-string">""</span></span>)) ((<span class="hljs-name"><span class="hljs-name">plusp</span></span> (<span class="hljs-name"><span class="hljs-name">strInd</span></span> d2 s)) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> lex) <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> lex into res)) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> s into res) (<span class="hljs-name"><span class="hljs-name">setq</span></span> lex <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> lex (<span class="hljs-name"><span class="hljs-name">strCat</span></span> lex s))))) res))</code> </pre> <br><p>  Zus√§tzlich zu dem erforderlichen Parameter verf√ºgt die Funktion √ºber zwei optionale Parameter: <strong>d1</strong> enth√§lt eine Zeichenfolge, von der jedes Zeichen ein Trennzeichen des ersten Typs enth√§lt, und Zeile <strong>d2</strong> enth√§lt Trennzeichen des zweiten Typs. </p><br><p>  Die Programmlogik der <strong>Parserfunktion</strong> ist oben beschrieben.  Es ist nur zu beachten, dass vor Arbeitsbeginn ein Trennzeichen an das Ende der Eingabezeile angeh√§ngt wird.  Dies geschieht so, dass der zuletzt verarbeitete Token in der Batterie ‚Äûh√§ngt‚Äú (die lokale Variable <strong>lex</strong> spielt die Rolle der Batterie). </p><br><p>  Lassen Sie uns unseren Parser "in Aktion" √ºberpr√ºfen: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">parser</span></span> <span class="hljs-string"><span class="hljs-string">"x = 15 + y^2"</span></span>) ==&gt; (<span class="hljs-string"><span class="hljs-string">"x"</span></span> <span class="hljs-string"><span class="hljs-string">"="</span></span> <span class="hljs-string"><span class="hljs-string">"15"</span></span> <span class="hljs-string"><span class="hljs-string">"+"</span></span> <span class="hljs-string"><span class="hljs-string">"y"</span></span> <span class="hljs-string"><span class="hljs-string">"^"</span></span> <span class="hljs-string"><span class="hljs-string">"2"</span></span>)</code> </pre> <br><p>  Das stimmt, nicht wahr?  Das Arbeiten mit Listen von Zeichenfolgen ist jedoch nicht ganz Lisp.  Gehen wir von der Liste der Strings zur Liste der Atome.  Dazu ben√∂tigen wir eine Funktion, die ... alle Token erneut in eine lange Zeile klebt (aber ein Leerzeichen zwischen den Token einf√ºgt), dann die √∂ffnende Klammer an den Anfang dieser Zeile einf√ºgt, die schlie√üende Klammer bis zum Ende schlie√üt ... und dann Lisp zwingt, die Liste zu lesen: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> mk-intf (<span class="hljs-name"><span class="hljs-name">txt</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">lex</span></span> (<span class="hljs-name"><span class="hljs-name">parser</span></span> txt <span class="hljs-string"><span class="hljs-string">" ,"</span></span> <span class="hljs-string"><span class="hljs-string">"()+-*/\^=&lt;&gt;%"</span></span>)) (<span class="hljs-name"><span class="hljs-name">intf</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in lex) (<span class="hljs-name"><span class="hljs-name">setq</span></span> intf (<span class="hljs-name"><span class="hljs-name">strCat</span></span> intf a <span class="hljs-string"><span class="hljs-string">" "</span></span>))) (<span class="hljs-name"><span class="hljs-name">input</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> intf <span class="hljs-string"><span class="hljs-string">")"</span></span>))))</code> </pre> <br><p>  Wenn wir nun den Zuweisungsoperator an die Eingabe der Funktion mk-intf senden, erhalten wir: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> <span class="hljs-string"><span class="hljs-string">"x = 15 + y^2"</span></span>) ==&gt; (<span class="hljs-name"><span class="hljs-name">X</span></span> = <span class="hljs-number"><span class="hljs-number">15</span></span> + Y ^ <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  Was viel sch√∂ner ist. </p><br><p>  Lassen Sie uns nun die Startfunktion ein wenig √§ndern: Diese Funktion muss ganze Prozeduren lesen und verarbeiten: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> fname) (<span class="hljs-name"><span class="hljs-name">setq</span></span> fname (<span class="hljs-name"><span class="hljs-name">sysGetOpenName</span></span> (<span class="hljs-name"><span class="hljs-name">sysHome</span></span>) <span class="hljs-string"><span class="hljs-string">"-|*.mbs"</span></span>))) (<span class="hljs-name"><span class="hljs-name">when</span></span> fname (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">fi</span></span> (<span class="hljs-name"><span class="hljs-name">gensym</span></span> 'fi))) (<span class="hljs-name"><span class="hljs-name">filOpen</span></span> fi fname _INPUT) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">curr-proc</span></span> (<span class="hljs-name"><span class="hljs-name">action-proc</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">filEOF</span></span> fi)) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">eval</span></span> curr-proc))) (<span class="hljs-name"><span class="hljs-name">filClose</span></span> fi)) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*numline*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*flagerr*))</code> </pre> <br><p>  Im Hauptteil der Schleife wird die <strong>action-proc-</strong> Funktion aufgerufen (um die Prozedur zu verarbeiten), die den Hauptteil der bereits auf Lisp akzeptierten Prozedur bildet.  Der Hauptteil der Prozedur, der als S-Ausdruck in der Variablen <strong>curr-proc</strong> gespeichert ist, wird dann an die Eingabe von <strong>eval √ºbergeben</strong> .  Und die akzeptierte Funktion wird in der Lisp-Umgebung ‚Äûwiedergeboren‚Äú! </p><br><p>  Was soll <strong>action-proc</strong> tun?  Diese Funktion erh√§lt die Kennung der ge√∂ffneten Datei als Parameter.  Die Funktion liest die Datei zeilenweise aus der Datei, √ºberspringt leere Zeilen und Kommentare, analysiert den Rest der Zeilen, √ºbersetzt sie in eine Listenform und generiert den Hauptteil der Prozedur. </p><br><p>  Wir werden nach und nach die <strong>Action-Proc-</strong> Generierung ‚Äûlernen‚Äú.  Beginnen wir damit, unserer Funktion beizubringen, den Beginn und das Ende eines Vorgangs zu erkennen.  In einem Mini-Basic ist der Beginn des Verfahrens: </p><br><pre> <code class="hljs lisp">proc name(<span class="hljs-name"><span class="hljs-name">p1</span></span>,p2,p3)</code> </pre> <br><p>  Versuchen Sie, eine Zeile wie folgt zu analysieren: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> <span class="hljs-string"><span class="hljs-string">"proc name(p1,p2,p3)"</span></span>) ==&gt; (<span class="hljs-name"><span class="hljs-name">PROC</span></span> NAME (<span class="hljs-name"><span class="hljs-name">P1</span></span> P2 P3))</code> </pre> <br><p>  Wie soll die <strong>action-proc-</strong> Funktion auf diese Eingabe reagieren?  Um sicherzustellen, dass der Kopf der Liste ein <strong>PROC-</strong> Atom ist, m√ºssen Sie nat√ºrlich das zweite Element der Liste als Namen der Funktion und das dritte Element als Liste der Parameter verwenden.  Der Name und die Liste der Parameter sollten in lokalen Variablen gespeichert werden.  Wenn der Operator <strong>end_proc gelesen wird</strong> , m√ºssen Sie aus dem Namen der Funktion und der Parameterliste ein <strong>defun-</strong> Formular mit einem leeren K√∂rper (soweit) bilden und dieses Formular als Ergebnis zur√ºckgeben.  So sieht es aus: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> action-proc (<span class="hljs-name"><span class="hljs-name">fi</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-name</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-parm</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> stmt (<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'proc) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-parm (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> stmt))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'end_proc) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> (<span class="hljs-name"><span class="hljs-name">output</span></span> stmt) <span class="hljs-string"><span class="hljs-string">"  "</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) `(defun ,proc-name ,proc-parm (quote OK))))</code> </pre> <br><p>  F√ºr die endg√ºltige Bildung der <strong>Defun-</strong> Klausel wird eine R√ºckw√§rtssperre verwendet.  Beachten Sie, dass die generierte Prozedur als Ergebnis ein <strong>OK-</strong> Atom zur√ºckgibt. </p><br><p>  Jetzt k√∂nnen wir unseren Code in Aktion √ºberpr√ºfen.  F√ºgen Sie den folgenden Code in die Datei 0000.mbs ein: </p><br><pre> <code class="hljs lisp">proc f1(<span class="hljs-name"><span class="hljs-name">x</span></span>,y) end_proc proc f2(<span class="hljs-name"><span class="hljs-name">x</span></span>) end_proc</code> </pre> <br><p>  F√ºhren Sie die <strong>Startprozedur aus</strong> , w√§hlen Sie 0000.mbs aus und sehen Sie auf der Konsole: </p><br><pre> <code class="hljs lisp"><span class="hljs-number"><span class="hljs-number">0001</span></span> proc f1(<span class="hljs-name"><span class="hljs-name">x</span></span>,y) <span class="hljs-number"><span class="hljs-number">0002</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0003</span></span> proc f2(<span class="hljs-name"><span class="hljs-name">x</span></span>) <span class="hljs-number"><span class="hljs-number">0004</span></span> end_proc</code> </pre> <br><p>  Wenn Sie m√∂chten, k√∂nnen Sie sicherstellen, dass die Lisp-Maschine jetzt zwei (bisher unbrauchbare) Funktionen <strong>f1</strong> und <strong>f2 hat</strong> : </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">getd</span></span> 'f1) ==&gt; (<span class="hljs-name"><span class="hljs-name">EXPR</span></span> (<span class="hljs-name"><span class="hljs-name">XY</span></span>) (<span class="hljs-name"><span class="hljs-name">QUOTE</span></span> OK)) (<span class="hljs-name"><span class="hljs-name">getd</span></span> 'f2) ==&gt; (<span class="hljs-name"><span class="hljs-name">EXPR</span></span> (<span class="hljs-name"><span class="hljs-name">X</span></span>) (<span class="hljs-name"><span class="hljs-name">QUOTE</span></span> OK))</code> </pre> <br><p>  Au√üerdem!  Sie k√∂nnen bereits gestartet werden: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">f1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) ==&gt; OK (<span class="hljs-name"><span class="hljs-name">f2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) ==&gt; OK</code> </pre> <br><p>  Unser √úbersetzer holte tief Luft ... </p><br><h4 id="vvod-vyvod-i-lokalnye-peremennye">  Eingabe-, Ausgabe- und lokale Variablen </h4><br><p>  Jetzt ist es an der Zeit, unserem neugeborenen √úbersetzer den Umgang mit <strong>Eingabe-</strong> , <strong>Druck-</strong> und <strong>lokalen</strong> Bedienern beizubringen. </p><br><p>  Der einfachste Weg, um Eingabe und Druck zu handhaben.  Beide Operatoren haben dieselbe Syntaxstruktur: Schl√ºsselwort und Variable.  Die Bedienereingabe <strong>x</strong> sollte sich in eine solche Lisp-Form <strong>verwandeln (setq x (read))</strong> .  Dementsprechend verwandelt sich der Operator <strong>print x</strong> in ein Formular <strong>(printline x)</strong> .  Um diese Formulare zu speichern, m√ºssen Sie den lokalen Variablenk√∂rper in der <strong>action-proc-</strong> Funktion <strong>angeben</strong> .  Diese Variable akkumuliert Formulare, die Berechnungen der zuk√ºnftigen Funktion durchf√ºhren.  Dann ist alles ziemlich einfach: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> action-proc (<span class="hljs-name"><span class="hljs-name">fi</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-name</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-parm</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">loc-var</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">body</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> stmt (<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'proc) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-parm (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> stmt))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'end_proc) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'print) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> 'printline (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'input) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> 'setq (<span class="hljs-name"><span class="hljs-name">cadr</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">list</span></span> 'read) ))))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> (<span class="hljs-name"><span class="hljs-name">output</span></span> stmt) <span class="hljs-string"><span class="hljs-string">"  "</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) `(defun ,proc-name ,proc-parm ,@body)))</code> </pre> <br><p>  Nun bereiten wir diesen Quellcode auf einer Mini-Basis vor: </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">proc</span></span> f1(x,y) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> y end_proc <span class="hljs-keyword"><span class="hljs-keyword">proc</span></span> f2(x) input x <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> x end_proc</code> </pre> <br><p>  und versuchen Sie es zu √ºbersetzen ... Wir werden zwei Lisp-Funktionen <strong>f1</strong> und <strong>f2 haben</strong> .  Schauen wir uns ihre definierenden Ausdr√ºcke an und stellen Sie sicher, dass sie korrekt generiert werden: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">getd</span></span> 'f1) ==&gt; (<span class="hljs-name"><span class="hljs-name">EXPR</span></span> (<span class="hljs-name"><span class="hljs-name">XY</span></span>) (<span class="hljs-name"><span class="hljs-name">PRINTLINE</span></span> X) (<span class="hljs-name"><span class="hljs-name">PRINTLINE</span></span> Y)) (<span class="hljs-name"><span class="hljs-name">getd</span></span> 'f2) ==&gt; (<span class="hljs-name"><span class="hljs-name">EXPR</span></span> (<span class="hljs-name"><span class="hljs-name">X</span></span>) (<span class="hljs-name"><span class="hljs-name">SETQ</span></span> X (<span class="hljs-name"><span class="hljs-name">READ</span></span>)) (<span class="hljs-name"><span class="hljs-name">PRINTLINE</span></span> X))</code> </pre> <br><p>  Sie k√∂nnen diese Funktionen aufrufen und sicherstellen, dass sie genau wie vorgesehen funktionieren.  Lassen Sie sich nicht st√∂ren, dass wir den Wert in die Parametervariable eingeben - wir haben nur noch keine lokalen Variablen ... F√ºgen wir sie hinzu. </p><br><p>  Der <strong>lokale</strong> Bediener kann sich an einer beliebigen Stelle in der Prozedur befinden und mehrmals auftreten.  Wenn der <strong>lokale</strong> Operator w√§hrend der Verarbeitung einer Prozedur auftritt, m√ºssen Sie eine Liste von Variablen erstellen und in einer lokalen Variablen speichern.  Nachdem die <strong>end_proc-</strong> Anweisung <strong>erf√ºllt ist, m√ºssen</strong> Sie das <strong>let-</strong> Formular generieren und alle ausf√ºhrbaren Anweisungen darin "einschlie√üen" ( <strong>derzeit</strong> nur <strong>Eingabe</strong> und <strong>Druck</strong> ).  So wird <strong>Action-Proc</strong> jetzt aussehen: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> action-proc (<span class="hljs-name"><span class="hljs-name">fi</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-name</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-parm</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">loc-var</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">lv</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">body</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> stmt (<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'proc) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-parm (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> stmt))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'end_proc) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'print) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> 'printline (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'input) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> 'setq (<span class="hljs-name"><span class="hljs-name">cadr</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">list</span></span> 'read) ))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'local) (<span class="hljs-name"><span class="hljs-name">setq</span></span> loc-var (<span class="hljs-name"><span class="hljs-name">append</span></span> loc-var (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> (<span class="hljs-name"><span class="hljs-name">output</span></span> stmt) <span class="hljs-string"><span class="hljs-string">"  "</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in (<span class="hljs-name"><span class="hljs-name">setof</span></span> loc-var)) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> a <span class="hljs-number"><span class="hljs-number">0</span></span>) into lv)) `(defun ,proc-name ,proc-parm (let ,lv ,@body))))</code> </pre> <br><p>  Die Liste der lokalen Variablen wird in der Variablen <strong>loc-var</strong> akkumuliert.  Nach Abschluss der Verarbeitung der Prozedur wird aus dieser Liste eine Liste von Paaren des Formulars <strong>(Name 0) erstellt</strong> .  Gleichzeitig ist die Vervielf√§ltigung identischer Namen unerw√ºnscht ... Wie kann dies verhindert werden?  Nat√ºrlich ist es m√∂glich, bei jeder Verarbeitung des <strong>lokalen</strong> Operators zu √ºberpr√ºfen, ob doppelte Namen vorhanden sind (ggf. eine Fehlermeldung ausgeben).  Aber es scheint mir, dass es besser ist, nur die Wiederholungen zu eliminieren, was der <strong>Setof-</strong> Aufruf <strong>tut</strong> .  Lassen Sie uns nun dieses Programm √ºbersetzen und ausf√ºhren: </p><br><pre> <code class="hljs lua">proc f1(x,y) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> a,b,c <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> x <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> y <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> a <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> a end_proc</code> </pre> <br><p>  Wir stellen sicher, dass es genau so funktioniert, wie es der Algorithmus vorschl√§gt.  Aber das Interessanteste liegt vor uns! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Von hier</a> aus k√∂nnen Sie die endg√ºltige Version von dem herunterladen, worauf wir gerade sind <del>  w </del>  codiert ... </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt!</a> <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419103/">https://habr.com/ru/post/de419103/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419091/index.html">Radioaktive Objekte unter uns</a></li>
<li><a href="../de419095/index.html">Wir schreiben CSS besser und sch√∂ner</a></li>
<li><a href="../de419097/index.html">Mambot - ein Bot im Telegramm f√ºr schwangere Frauen</a></li>
<li><a href="../de419099/index.html">WebSockets in Angular. Teil 2. Produktl√∂sungen</a></li>
<li><a href="../de419101/index.html">Erstelle ein Spiel bei Nacht Hackathon</a></li>
<li><a href="../de419105/index.html">Link zur Slurm-Sendung (Kubernetes Intensive)</a></li>
<li><a href="../de419107/index.html">Beispiele f√ºr die √úbersicht und Konfiguration von Dell EMC Unity-Dateien</a></li>
<li><a href="../de419109/index.html">Erkl√§ren Sie die Pony in Android P. Was tun mit Android Cutout?</a></li>
<li><a href="../de419111/index.html">Food Design Digest Juli 2018</a></li>
<li><a href="../de419115/index.html">Bootf√§hige CD und Retro-Spiel in einem Tweet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>