<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽🏻 🧐 🤨 Desarrollo de clases de interfaz en C ++ 🙉 🚗 📰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las clases de interfaz son muy utilizadas en programas C ++. Pero, desafortunadamente, a menudo se cometen errores al implementar soluciones basadas e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo de clases de interfaz en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427281/"><hr><p>  <i>Las clases de interfaz son muy utilizadas en programas C ++.</i>  <i>Pero, desafortunadamente, a menudo se cometen errores al implementar soluciones basadas en clases de interfaz.</i>  <i>El artículo describe cómo diseñar correctamente las clases de interfaz; se consideran varias opciones.</i>  <i>El uso de punteros inteligentes se describe en detalle.</i>  <i>Se proporciona un ejemplo de la implementación de una clase de excepción y una plantilla de clase de colección basada en clases de interfaz.</i> </p><hr><br><a name="habracut"></a><br><h1>  Tabla de contenidos </h1><br><div class="spoiler">  <b class="spoiler_title">Tabla de contenidos</b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introduccion</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1. Funciones especiales para miembros, creación y eliminación de objetos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones especiales para miembros</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Crear y eliminar objetos: detalles básicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nivel de acceso al destructor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Crear y eliminar en un módulo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Deleción polimórfica</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Eliminar cuando la declaración de clase está incompleta</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2. Funciones puramente virtuales y clases abstractas.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones virtuales puras</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clases abstractas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Destructor virtual puro</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3. Clases de interfaz</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementaciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Creación de objetos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Eliminar objeto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.3.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Usar el operador de eliminación</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Usando una función virtual especial</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.3.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Usar una función externa</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.3.4</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Eliminación automática mediante puntero inteligente</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otras opciones para administrar la vida útil de una instancia de una clase de implementación</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copiar semántica</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Constructor de clase de interfaz</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interacción bidireccional</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Punteros inteligentes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones miembro constantes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interfaces COM</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clases de interfaz y bibliotecas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4. Un ejemplo de una clase de interfaz y su implementación.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clase de interfaz</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clase de implementación</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Punteros inteligentes estándar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Creación del lado del cliente</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementación Creación lateral</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementación alternativa de clase base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5. Excepciones y colecciones implementadas usando clases de interfaz</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5.1 Excepciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5.2 Colecciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6. Clases de interfaz y clases de envoltura</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7. Resumen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Referencias</a> <br></div></div><br><a name="id-introdaction"></a><br><h1>  Introduccion </h1><br><p>  Una clase de interfaz es una clase que no tiene datos y se compone principalmente de funciones puramente virtuales.  Esta solución le permite separar completamente la implementación de la interfaz (el cliente usa la clase de interfaz) en otro lugar, se crea una clase derivada en la que se redefinen funciones puramente virtuales y se define la función de fábrica.  Los detalles de implementación están completamente ocultos para el cliente.  De esta forma, se implementa la verdadera encapsulación, que es imposible con la clase habitual.  Puede leer sobre las clases de interfaz de Scott Meyers [Meyers2].  Las clases de interfaz también se denominan clases de protocolo. </p><br><p>  El uso de clases de interfaz le permite debilitar las dependencias entre diferentes partes del proyecto, lo que simplifica el desarrollo del equipo y reduce el tiempo de compilación / ensamblaje.  Las clases de interfaz facilitan la implementación de soluciones flexibles y dinámicas cuando los módulos se cargan selectivamente en tiempo de ejecución.  El uso de las clases de interfaz como una biblioteca de interfaz (API) (SDK) simplifica la solución de problemas de compatibilidad binaria. </p><br><p>  Las clases de interfaz se usan ampliamente, con su ayuda implementan la interfaz (API) de bibliotecas (SDK), la interfaz de complementos (complementos) y mucho más.  Muchos patrones de Gang of Four [GoF] se implementan naturalmente usando clases de interfaz.  Las clases de interfaz incluyen interfaces COM.  Pero, desafortunadamente, a menudo se cometen errores al implementar soluciones basadas en clases de interfaz.  Intentemos aclarar este problema. </p><br><a name="id-1"></a><br><h1>  1. Funciones especiales para miembros, creación y eliminación de objetos. </h1><br><p>  Esta sección describe brevemente una serie de características de C ++ que necesita conocer para comprender completamente las soluciones ofrecidas para las clases de interfaz. </p><br><a name="id-1-1"></a><br><h2>  1.1.  Funciones especiales para miembros </h2><br><p>  Si el programador no ha definido las funciones miembro de la clase de la siguiente lista (el constructor predeterminado, el constructor de copia, el operador de asignación de copia, el destructor), entonces el compilador puede hacer esto por él.  C ++ 11 agregó un constructor de movimientos y un operador de asignación de movimientos a esta lista.  Estas funciones miembro se denominan funciones miembro especiales.  Se generan solo si se usan y se cumplen condiciones adicionales específicas para cada función.  Llamamos la atención sobre el hecho de que este uso puede resultar bastante oculto (por ejemplo, al implementar la herencia).  Si no se puede generar la función requerida, se genera un error.  (Con la excepción de las operaciones de reubicación, se reemplazan por operaciones de copia). Las funciones miembro generadas por el compilador son públicas e integrables. </p><br><p>  Las funciones miembro especiales no se heredan, si se requiere una función miembro especial en la clase derivada, el compilador siempre intentará generarla; la presencia de la función miembro correspondiente definida en la clase base por el programador no afecta esto. </p><br><p> El programador puede prohibir la generación de funciones miembro especiales, en C ++ 11 es necesario usar la construcción <code>"=delete"</code> al declarar, en C ++ 98 declara la función miembro correspondiente privada y no define.  En la herencia de clases, la prohibición de generar una función miembro especial realizada en la clase base se aplica a todas las clases derivadas. </p><br><p>  Si el programador se siente cómodo con las funciones miembro generadas por el compilador, entonces en C ++ 11 puede indicar esto explícitamente, y no simplemente descartar la declaración.  Para hacer esto, debe usar la construcción <code>"=default"</code> al declarar, mientras que el código se lee mejor y aparecen características adicionales relacionadas con la administración del nivel de acceso. </p><br><p>  Los detalles sobre funciones especiales para miembros se pueden encontrar en [Meyers3]. </p><br><a name="id-1-2"></a><br><h2>  1.2.  Crear y eliminar objetos: detalles básicos </h2><br><p>  Crear y eliminar objetos utilizando los operadores <code>new/delete</code> es una operación típica de dos en uno.  Al llamar a <code>new</code> , la memoria se asigna primero para el objeto.  Si la selección es exitosa, se llama al constructor.  Si el constructor produce una excepción, la memoria asignada se libera.  Cuando se llama al operador de <code>delete</code> , todo sucede en el orden inverso: primero, se llama al destructor, luego se libera la memoria.  El destructor no debe lanzar excepciones. </p><br><p>  Si el <code>new</code> operador se usa para crear una matriz de objetos, la memoria se asigna primero a toda la matriz.  Si la selección es exitosa, se llama al constructor predeterminado para cada elemento de la matriz comenzando desde cero.  Si algún constructor arroja una excepción, entonces, para todos los elementos creados de la matriz, se llama al destructor en el orden inverso de la llamada del constructor, luego se libera la memoria asignada.  Para eliminar una matriz, debe llamar al operador <code>delete[]</code> (llamado operador de <code>delete</code> para las matrices), y para todos los elementos de la matriz, se llama al destructor en el orden inverso del constructor, luego se libera la memoria asignada. </p><br><p>  Atencion  Debe llamar a la forma correcta del operador de <code>delete</code> , dependiendo de si se elimina un solo objeto o matriz.  Esta regla debe observarse estrictamente, de lo contrario, puede obtener un comportamiento indefinido, es decir, puede suceder cualquier cosa: pérdidas de memoria, bloqueo, etc.  Ver [Meyers2] para más detalles. </p><br><p>  Las funciones de asignación de memoria estándar <code>std::bad_alloc</code> satisfacen la solicitud y <code>std::bad_alloc</code> una excepción de tipo <code>std::bad_alloc</code> . </p><br><p>  Es seguro aplicar cualquier forma del operador de <code>delete</code> a un puntero nulo. </p><br><p>  En la descripción anterior, es necesaria una aclaración.  Para los llamados tipos triviales (tipos incorporados, estructuras de estilo C), el constructor no puede ser llamado, y el destructor no hace nada en ningún caso.  Ver también la sección 1.6. </p><br><a name="id-1-3"></a><br><h2>  1.3.  Nivel de acceso al destructor </h2><br><p>  Cuando el operador de <code>delete</code> se aplica a un puntero a una clase, el destructor de esa clase debe estar disponible en el punto de llamada de <code>delete</code> .  (Hay una excepción a esta regla, discutida en la Sección 1.6.) Por lo tanto, al hacer que el destructor sea seguro o cerrado, el programador prohíbe el uso del operador de <code>delete</code> cuando el destructor no está disponible.  Recuerde que si no se define un destructor en la clase, el compilador lo hará solo, y este destructor estará abierto (consulte la sección 1.1). </p><br><a name="id-1-4"></a><br><h2>  1.4.  Crear y eliminar en un módulo </h2><br><p>  Si el <code>new</code> operador creó un objeto, entonces el operador de <code>delete</code> debe estar en el mismo módulo para <code>delete</code> .  Hablando en sentido figurado, "ponlo donde lo llevaste".  Esta regla es bien conocida; ver, por ejemplo, [Sutter / Alexandrescu].  Si se viola esta regla, puede producirse un "desajuste" de las funciones de asignación y liberación de memoria, lo que, por regla general, conduce a una finalización anormal del programa. </p><br><a name="id-1-5"></a><br><h2>  1.5.  Deleción polimórfica </h2><br><p>  Si está diseñando una jerarquía polimórfica de clases cuyas instancias se eliminan utilizando el operador de <code>delete</code> , entonces debe haber un destructor virtual abierto en la clase base, esto asegura que se llama al destructor del tipo real del objeto cuando el operador de <code>delete</code> se aplica al puntero a la clase base.  Si se viola esta regla, puede ocurrir una llamada al destructor de la clase base, lo que puede conducir a una pérdida de recursos. </p><br><a name="id-1-6"></a><br><h2>  1.6.  Eliminar cuando la declaración de clase está incompleta </h2><br><p>  La omnivorosidad del operador de <code>delete</code> puede crear ciertos problemas; se puede aplicar a un puntero de tipo <code>void*</code> o a un puntero a una clase que tiene una declaración incompleta (preventiva).  En este caso, no se produce un error, solo se omite la llamada al destructor, solo se llama a la función para liberar la memoria.  Considere un ejemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   X* CreateX(); void Foo() {    X* p = CreateX();    delete p; }</span></span></code> </pre> <br><p>  Este código se compila incluso si una declaración de clase <code>X</code> completa no está disponible en el dial dial de <code>delete</code> .  Es cierto que al compilar (Visual Studio) se emite una advertencia: </p><br><p> <code>warning C4150: deletion of pointer to incomplete type 'X'; no destructor called</code> </p> <br><p>  Si hay una implementación de <code>X</code> y <code>CreateX()</code> , entonces el código se <code>CreateX()</code> , si <code>CreateX()</code> devuelve un puntero al objeto creado por el <code>new</code> operador, entonces la llamada <code>Foo()</code> ejecuta con éxito, no se llama al destructor.  Está claro que esto puede conducir a una fuga de recursos, por lo que una vez más sobre la necesidad de tener cuidado con las advertencias. </p><br><p>  Esta situación no es descabellada, puede surgir fácilmente cuando se utilizan clases como punteros inteligentes o clases de descriptores.  Scott Meyers trata este problema en [Meyers3]. </p><br><a name="id-2"></a><br><h1>  2. Funciones puramente virtuales y clases abstractas. </h1><br><p>  El concepto de clases de interfaz se basa en conceptos de C ++ como funciones virtuales puras y clases abstractas. </p><br><a name="id-2-1"></a><br><h2>  2.1.  Funciones virtuales puras </h2><br><p>  Una función virtual declarada usando la construcción <code>"=0"</code> se llama virtual pura. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...    virtual void Foo() = 0; };</span></span></code> </pre> <br><p>  A diferencia de una función virtual normal, no se puede definir una función puramente virtual (con la excepción del destructor, consulte la sección 2.3), pero debe redefinirse en una de las clases derivadas. </p><br><p>  Se pueden definir funciones puramente virtuales.  Emblem Sutter ofrece varios usos útiles para esta función [Obturador]. </p><br><a name="id-2-2"></a><br><h2>  2.2.  Clases abstractas </h2><br><p>  Una clase abstracta es una clase que tiene al menos una función puramente virtual.  Una clase que se deriva de una clase abstracta y no anula al menos una función puramente virtual también será abstracta.  El estándar C ++ prohíbe crear instancias de una clase abstracta; solo puede crear instancias de derivados de clases no abstractas.  Por lo tanto, se crea una clase abstracta para ser utilizada como una clase base.  En consecuencia, si un constructor se define en una clase abstracta, entonces no tiene sentido hacerlo abierto, debe protegerse. </p><br><a name="id-2-3"></a><br><h2>  2.3.  Destructor virtual puro </h2><br><p>  En algunos casos, es aconsejable hacer un destructor virtual puro.  Pero esta solución tiene dos características. </p><br><ol><li>  Se debe definir un destructor puramente virtual.  (La definición predeterminada generalmente se usa, es decir, usando la construcción <code>"=default"</code> ). El destructor de clase derivado llama a los destructores de clase base a lo largo de toda la cadena de herencia y, por lo tanto, se garantiza que la cola llegue a la raíz, un destructor puramente virtual. </li><li>  Si el programador no ha redefinido un destructor virtual puro en la clase derivada, el compilador lo hará por él (consulte la sección 1.1).  Por lo tanto, una clase derivada de una clase abstracta con un destructor puramente virtual puede perder su abstracción sin anular explícitamente el destructor. </li></ol><br><p>  Un ejemplo del uso de un destructor virtual puro se puede encontrar en la sección 4.4. </p><br><a name="id-3"></a><br><h1>  3. Clases de interfaz </h1><br><p>  Una clase de interfaz es una clase abstracta que no tiene datos y se compone principalmente de funciones puramente virtuales.  Dicha clase puede tener funciones virtuales ordinarias (no puramente virtuales), por ejemplo, un destructor.  También puede haber funciones miembro estáticas, como las funciones de fábrica. </p><br><a name="id-3-1"></a><br><h2>  3.1.  Implementaciones </h2><br><p>  Una implementación de una clase de interfaz se llamará una clase derivada en la que se redefinen funciones puramente virtuales.  Puede haber varias implementaciones de la misma clase de interfaz, y son posibles dos esquemas: horizontal, cuando varias clases diferentes heredan la misma clase de interfaz, y vertical, cuando la clase de interfaz es la raíz de la jerarquía polimórfica.  Por supuesto, puede haber híbridos. </p><br><p>  El punto clave del concepto de clases de interfaz es la separación completa de la interfaz de la implementación: el cliente solo trabaja con la clase de interfaz, la implementación no está disponible. </p><br><a name="id-3-2"></a><br><h2>  3.2.  Creación de objetos </h2><br><p>  La inaccesibilidad de la clase de implementación causa ciertos problemas al crear objetos.  El cliente debe crear una instancia de la clase de implementación y obtener un puntero a la clase de interfaz a través de la cual se accederá al objeto.  Como la clase de implementación no está disponible, no puede usar el constructor, por lo que se usa la función de fábrica, que se define en el lado de la implementación.  Esta función generalmente crea un objeto usando el <code>new</code> operador y devuelve un puntero al objeto creado, convertido en un puntero a una clase de interfaz.  Una función de fábrica puede ser un miembro estático de una clase de interfaz, pero no es necesario, por ejemplo, puede ser miembro de una clase de fábrica especial (que, a su vez, puede ser una clase de interfaz) o una función libre.  Una función de fábrica puede devolver no un puntero sin formato a una clase de interfaz, sino uno inteligente.  Esta opción se discute en las secciones 3.3.4 y 4.3.2. </p><br><a name="id-3-3"></a><br><h2>  3.3.  Eliminar objeto </h2><br><p>  Eliminar un objeto es una operación extremadamente crítica.  Un error da como resultado una pérdida de memoria o una eliminación doble, que generalmente conduce a un bloqueo del programa.  A continuación, este problema se considera lo más detallado posible, y se presta mucha atención a la prevención de acciones erróneas de los clientes. </p><br><p>  Hay cuatro opciones principales: </p><br><ol><li>  Usando el operador de <code>delete</code> . </li><li>  Usando una función virtual especial. </li><li>  Usando una función externa. </li><li>  Eliminación automática mediante puntero inteligente. </li></ol><br><a name="id-3-3-1"></a><br><h3>  3.3.1  Usar el operador de <code>delete</code> <br></h3><br><p>  Para hacer esto, debe tener un destructor virtual abierto en la clase de interfaz.  En este caso, el operador de <code>delete</code> , que solicita un puntero a una clase de interfaz en el lado del cliente, proporciona una llamada al destructor de la clase de implementación.  Esta opción puede funcionar, pero es difícil reconocerla como exitosa.  Recibimos llamadas de los operadores <code>new</code> y <code>delete</code> en diferentes lados de la "barrera", <code>new</code> en el lado de implementación, <code>delete</code> en el lado del cliente.  Y si la implementación de la clase de interfaz se realiza en un módulo separado (que es algo bastante común), obtenemos una violación de la regla de la sección 1.4. </p><br><a name="id-3-3-2"></a><br><h3>  3.3.2.  Usando una función virtual especial </h3><br><p>  Más progresiva es otra opción: la clase de interfaz debe tener una función virtual especial que elimine el objeto.  Dicha función, al final, se reduce a llamar a <code>delete this</code> , pero esto ya está sucediendo en el lado de la implementación.  Dicha función se puede invocar de diferentes maneras, por ejemplo <code>Delete()</code> , pero también se usan otras opciones: <code>Release()</code> , <code>Destroy()</code> , <code>Dispose()</code> , <code>Free()</code> , <code>Close()</code> , etc.  Además de seguir la regla en la sección 1.4, esta opción tiene varias ventajas adicionales. </p><br><ol><li>  Le permite utilizar funciones personalizadas de asignación / desasignación de memoria para la clase de implementación. </li><li>  Le permite implementar un esquema más complejo para controlar la vida útil del objeto de implementación, por ejemplo, utilizando un contador de referencia. </li></ol><br><p>  En esta realización, se puede compilar e incluso realizar un intento de eliminar un objeto utilizando el operador de <code>delete</code> , pero esto es un error.  Para evitarlo en la clase de interfaz, es suficiente tener un destructor protegido vacío o puramente virtual (ver sección 1.3).  Tenga en cuenta que el uso del operador de <code>delete</code> puede estar bastante enmascarado, por ejemplo, los punteros inteligentes estándar utilizan el operador de eliminación para eliminar un objeto de forma predeterminada y el código correspondiente está profundamente oculto en su implementación.  Un destructor protegido le permite detectar todos esos intentos en la etapa de compilación. </p><br><a name="id-3-3-3"></a><br><h3>  3.3.3  Usar una función externa </h3><br><p>  Esta opción puede atraer una cierta simetría de procedimientos para crear y eliminar un objeto, pero en realidad no tiene ventajas sobre la versión anterior, pero hay muchos problemas adicionales.  Esta opción no se recomienda para su uso y no se considera en el futuro. </p><br><a name="id-3-3-4"></a><br><h3>  3.3.4  Eliminación automática mediante puntero inteligente </h3><br><p>  En este caso, la función de fábrica no devuelve un puntero sin formato a una clase de interfaz, sino un puntero inteligente correspondiente.  Este puntero inteligente se crea en el lado de implementación y encapsula el objeto de eliminación, que elimina automáticamente el objeto de implementación cuando el puntero inteligente (o su última copia) queda fuera del alcance en el lado del cliente.  En este caso, es posible que no se requiera una función virtual especial para eliminar el objeto de implementación, pero aún se necesita un destructor protegido, es necesario para evitar el uso erróneo del operador de <code>delete</code> .  (Es cierto que debe tenerse en cuenta que la probabilidad de tal error se reduce notablemente). Esta opción se analiza con más detalle en la Sección 4.3.2. </p><br><a name="id-3-4"></a><br><h2>  3.4.  Otras opciones para administrar la vida útil de una instancia de una clase de implementación </h2><br><p>  En algunos casos, el cliente puede recibir un puntero a la clase de interfaz, pero no ser el propietario.  La gestión de la vida útil del objeto de implementación está completamente del lado de la implementación.  Por ejemplo, un objeto puede ser un objeto singleton estático (esta solución es típica para las fábricas).  Otro ejemplo está relacionado con la interacción bidireccional, ver sección 3.7.  El cliente no debe eliminar dicho objeto, pero se necesita un destructor protegido para dicha clase de interfaz, es necesario evitar el uso erróneo del operador de <code>delete</code> . </p><br><a name="id-3-5"></a><br><h2>  3.5.  Copiar semántica </h2><br><p>  Para una clase de interfaz, no es posible crear una copia del objeto de implementación utilizando el constructor de copia, por lo que si se requiere copiar, la clase debe tener una función virtual que cree una copia del objeto de implementación y devuelva un puntero a la clase de interfaz.  Dicha función a menudo se denomina constructor virtual, y su nombre tradicional es <code>Clone()</code> o <code>Duplicate()</code> . </p><br><p>  El uso del operador de asignación de copias no está prohibido, pero no puede considerarse una buena idea.  El operador de asignación de copia siempre está emparejado; debe estar emparejado con el constructor de copia.  El operador generado por el compilador predeterminado no tiene sentido; no hace nada.  Teóricamente, puede declarar un operador de asignación puramente virtual, seguido de anulación, pero la asignación virtual no es una práctica recomendada; los detalles se pueden encontrar en [Meyers1].  Además, la asignación parece poco natural: el acceso a los objetos de la clase de implementación generalmente se realiza a través de un puntero a la clase de interfaz, por lo que la asignación se verá así: </p><br><pre> <code class="cpp hljs">* = *;</code> </pre> <br><p>  El operador de asignación está mejor prohibido, y si es necesario, dicha semántica tiene en la clase de interfaz la función virtual correspondiente. </p><br><p>  Hay dos formas de prohibir la asignación. </p><br><ol><li>  Declare el operador de asignación eliminado ( <code>=delete</code> ).  Si las clases de interfaz forman una jerarquía, esto es suficiente para hacerlo en la clase base.  La desventaja de este método es que afecta la clase de implementación, la prohibición también se aplica a ella. </li><li>  Declare una declaración de asignación protegida con una definición predeterminada ( <code>=default</code> ).  Esto no afecta a la clase de implementación, pero en el caso de una jerarquía de clases de interfaz, dicho anuncio debe hacerse en cada clase. </li></ol><br><a name="id-3-6"></a><br><h2>  3.6.  Constructor de clase de interfaz </h2><br><p>  A menudo, el constructor de una clase de interfaz no se declara.  En este caso, el compilador genera el constructor predeterminado necesario para implementar la herencia (ver sección 1.1).  Este constructor está abierto, aunque lo suficiente como para ser seguro.  Si en la clase de interfaz el constructor de copia se declara eliminado ( <code>=delete</code> ), la generación por el compilador del constructor se suprime por defecto, y dicho constructor debe declararse explícitamente.  Es natural hacerlo seguro con una definición predeterminada ( <code>=default</code> ).  En principio, la declaración de tal constructor protegido siempre se puede hacer.  Un ejemplo está en la sección 4.4. </p><br><a name="id-3-7"></a><br><h2>  3.7.  Interacción bidireccional </h2><br><p>  Las clases de interfaz son convenientes para usar la comunicación bidireccional.  Si se puede acceder a algún módulo a través de las clases de interfaz, el cliente también puede crear implementaciones de algunas clases de interfaz y pasarles punteros en el módulo.  A través de estos punteros, el módulo puede recibir servicios del cliente y también transmitir datos o notificaciones al cliente. </p><br><a name="id-3-8"></a><br><h2>  3.8.  Punteros inteligentes </h2><br><p>  Dado que el acceso a los objetos de la clase de implementación generalmente se realiza a través de un puntero, es natural utilizar punteros inteligentes para controlar su vida útil.  Pero debe tenerse en cuenta que si se usa la segunda opción para eliminar objetos, entonces con el puntero inteligente estándar es necesario transferir un eliminador de usuario (tipo) o una instancia de este tipo.  Si esto no se hace, el puntero inteligente utilizará el operador de eliminación para eliminar el objeto, y el código simplemente no se compilará (gracias al destructor protegido).  Los punteros inteligentes estándar (incluido el uso de removedores personalizados) se analizan en detalle en [Josuttis], [Meyers3].  Un ejemplo de uso de un removedor personalizado se puede encontrar en la sección 4.3.1. </p><br><p>      ,       ,      ,    . </p><br><a name="id-3-9"></a><br><h2>  3.9.  - </h2><br><p>     -    const.              ,  ,    -,       . </p><br><a name="id-3-10"></a><br><h2>  3.10. COM- </h2><br><p> COM-    ,     ,  COM —      ,  COM-     ,   C,    ,   .  COM-  C++      ,   COM. </p><br><a name="id-3-11"></a><br><h2>  3.11.     </h2><br><p>         (API)    (SDK).       .    -,      -,           .     ,     (Windows DLL),     :  -.          .        ,  ,       .     <code>LoadLibrary()</code>      ,    -,       . </p><br><a name="id-4"></a><br><h1> 4.       </h1><br><a name="id-4-1"></a><br><h2>  4.1.   </h2><br><p>       ,      . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   public:    virtual void Delete() = 0; //      IBase&amp; operator=(const IBase&amp;) = delete; //   };</span></span></code> </pre> <br><p>    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IActivatable</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBase { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    ~IActivatable() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   public:    virtual void Activate(bool activate) = 0;    static IActivatable* CreateInstance(); // - };</span></span></code> </pre> <br><p> ,         ,     .     ,           <code>IBase</code> .     ,            (.  1.3).       ,       . </p><br><a name="id-4-2"></a><br><h2>  4.2.   </h2><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IActivatable { <span class="hljs-comment"><span class="hljs-comment">// ... private:    Activator(); protected:    ~Activator(); public:    void Delete() override;    void Activate(bool activate) override;    friend IActivatable* IActivatable::CreateInstance(); }; Activator::Activator() {/* ... */} Activator::~Activator() {/* ... */} void Activator::Delete() { delete this; } void Activator::Activate(bool activate) {/* ... */} IActivatable* IActivatable::CreateInstance() {    return static_cast&lt;IActivatable*&gt;(new Activator()); }</span></span></code> </pre> <br><p>      , ,        ,  -  ,         . </p><br><a name="id-4-3"></a><br><h2>  4.3.    </h2><br><a name="id-4-3-1"></a><br><h3> 4.3.1.     </h3><br><p>           . -   (     <code>IBase</code> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseDeleter</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IBase* p)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ p-&gt;Delete(); } };</code> </pre> <br><p>  <code>std::unique_ptr&lt;&gt;</code> -   : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> —  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;I, BaseDeleter&gt;;</code> </pre> <br><p> ,   ,  -   ,  <code>UniquePtr</code>    . </p><br><p>   -: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> —  - </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateInstance</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class">&lt;I&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateInstance</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UniquePtr&lt;I&gt;(I::CreateInstance()); }</code> </pre> <br><p>        : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> —  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class">&lt;I&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToPtr</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UniquePtr&lt;I&gt;(p); }</code> </pre> <br><p>  <code>std::shared_ptr&lt;&gt;</code>    <code>std::unique_ptr&lt;&gt;</code> ,   ,  <code>std::shared_ptr&lt;&gt;</code>   .      <code>Activator</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> un1 = CreateInstance&lt;IActivatable&gt;(); un1-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> un2 = ToPtr(IActivatable::CreateInstance()); un2-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IActivatable&gt; sh = CreateInstance&lt;IActivatable&gt;(); sh-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br><p>          (     — -): </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IActivatable&gt; sh2(IActivatable::CreateInstance());</code> </pre> <br><p>     <code>std::make_shared&lt;&gt;()</code> ,      (    ). </p><br><p>    :          ,     .     :     ,  - .     4.4. </p><br><a name="id-4-3-2"></a><br><h3> 4.3.2.     </h3><br><p>       .           -.   <code>std::shared_ptr&lt;&gt;</code>         ,    ,      (         ).     <code>std::shared_ptr&lt;&gt;</code> (  )  -  ,           <code>delete</code>     .  <code>std::shared_ptr&lt;&gt;</code> -       (   )   -      .        . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class IActivatable; using ActPtr = std::shared_ptr&lt;IActivatable&gt;; //   class IActivatable { protected:    virtual ~IActivatable() = default; //      IActivatable&amp; operator=(const IActivatable&amp;) = default; //   public:    virtual void Activate(bool activate) = 0;    static ActPtr CreateInstance(); // - }; //   class Activator : public IActivatable { // ... public:    Activator();  //      ~Activator(); //      void Activate(bool activate) override; }; Activator::Activator() {/* ... */} Activator::~Activator() {/* ... */} void Activator::Activate(bool activate) {/* ... */} ActPtr IActivatable::CreateInstance() {    return ActPtr(new Activator()); }</span></span></span></span></code> </pre> <br><p>  -        <code>std::make_shared&lt;&gt;()</code> : </p><br><pre> <code class="cpp hljs">ActPtr IActivatable::CreateInstance() {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;Activator&gt;(); }</code> </pre> <br><p>      <code>std::unique_ptr&lt;&gt;</code> ,        , -   ,        . </p><br><a name="id-4-4"></a><br><h2>  4.4.     </h2><br><p>    C#  Java  C++    «»,       .        .      <code>IBase</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IBase() = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,       virtual void Delete(); //   public:    IBase(const IBase&amp;) = delete;            //      IBase&amp; operator=(const IBase&amp;) = delete; //      struct Deleter        // -    {        void operator()(IBase* p) const { p-&gt;Delete(); }    };    friend struct IBase::Deleter; };</span></span></code> </pre> <br><p>     , <code>Delete()</code>    ,     . </p><br><pre> <code class="cpp hljs">IBase::~IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IBase::Delete() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>      <code>IBase</code> .         <code>Delete()</code> ,              . -      <code>IBase</code> . <code>Delete()</code>  , - .     <code>Delete()</code>         ,    .       ,    4.3.1. </p><br><a name="id-5"></a><br><h1> 5.   ,      </h1><br><a name="id-5-1"></a><br><h2> 5.1  </h2><br><p>  ,    ,   ,      ,        . </p><br><p>   ,  ,    <code>IException</code>    <code>Exception</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IException</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">;</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IException() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">What</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    IException&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IException&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> {</span></span>    IException* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m_Ptr; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code);    Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Exception&amp; src) : m_Ptr(src.m_Ptr-&gt;Clone()) {}    ~Exception() { m_Ptr-&gt;Delete(); }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Ptr; } };</code> </pre> <br><p>         <code>Exception</code> ,            <code>IException</code> .       ,    <code>throw</code> ,   .    <code>Exception</code>      ,      .  -      ,   . </p><br><p>  <code>Exception</code> , ,  . </p><br><p>   <code>IException</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExcImpl</span></span></span><span class="hljs-class"> :</span></span> IException {    <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">;</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_What;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_Code;    ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code);    ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ExcImpl&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    <span class="hljs-function"><span class="hljs-function">IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    ~ExcImpl() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">What</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; }; ExcImpl::ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code)    : m_What(what), m_Code(code) {} IException* ExcImpl::Clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExcImpl(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ExcImpl::Delete() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ExcImpl::What() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_What.c_str(); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ExcImpl::Code() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Code; }</code> </pre> <br><p>   <code>Exception</code> : </p><br><pre> <code class="cpp hljs">Exception::Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code)    : m_Ptr(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExcImpl(what, code)) {}</code> </pre> <br><p>    ,       — .NET —  , —          ,     C++/CLI.  ,        ,     ,   C++/CLI. </p><br><a name="id-5-2"></a><br><h2> 5.2  </h2><br><p>   -    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICollect</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ICollect() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ICollect&lt;T&gt;* Clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ind)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ind)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    ICollect&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ICollect&lt;T&gt;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>        ,             -,        . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICollect</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Contain</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ICollect&lt;T&gt; CollType;    CollType* m_Coll; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T value_type;    Contain(CollType* coll);    ~Contain(); <span class="hljs-comment"><span class="hljs-comment">//     Contain(const Contain&amp; src);    Contain&amp; operator=(const Contain&amp; src); //     Contain(Contain&amp;&amp; src);    Contain&amp; operator=(Contain&amp;&amp; src);    bool mpty() const;    int size() const;    T&amp; operator[](int ind);    const T&amp; operator[](int ind) const;    Iterator&lt;T&gt; begin();    Iterator&lt;T&gt; end(); };</span></span></code> </pre> <br><p>      .   ,       . ,      ,    ,     ,    - <code>begin()</code>  <code>end()</code> ,   .           (. [Josuttis]),         <code>for</code>   .                .            , ,      . </p><br><a name="id-6"></a><br><h1> 6.    - </h1><br><p>       .         -,      .          .   ,         ++.              ,   .NET, Java  Pyton.              .      ,  ,         .   .NET Framework     C++/CLI          C++.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </p><br><a name="id-conclusion"></a><br><h1> 7.  </h1><br><p>      -,         . </p><br><p>         . </p><br><ol><li>   <code>delete</code> . </li><li>    . </li><li>      . </li></ol><br><p>          . </p><br><p>         ,       <code>delete</code> .                ,      . </p><br><p>    -   ,           .             ,    ,      <code>delete</code> . </p><br><p>             . </p><br><p>      ,          ,     ,  ,       . </p><br><br><a name="id-refs"></a><br><h1>   </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[GoF] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gamma E., Helm R., Johnson R., Vlissides J. Métodos de diseño orientado a objetos. </font><font style="vertical-align: inherit;">Patrones de diseño.: Por.</font></font> del ingles<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - San Petersburgo: Peter, 2001. </font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Josuttis] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josattis, Nikolai M. Biblioteca estándar de C ++: Guía de referencia, 2ª ed .: Per.</font></font> del ingles<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- M .: LLC "I.D. </font><font style="vertical-align: inherit;">Williams, 2014.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Dewhurst] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dewhurst, Stefan K. Lugares resbaladizos C ++. </font><font style="vertical-align: inherit;">Cómo evitar problemas al diseñar y compilar sus programas.: Per.</font></font> del ingles<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - M .: DMK Press, 2012. </font></font></p><br><p> [Meyers1] <br> , .    C++. 35        .: .  del ingles — .:  , 2000. </p><br><p> [Meyers2] <br> , .   C++. 55        .: .  del ingles — .:  , 2014. </p><br><p> [Meyers3] <br> , .    C++: 42    C++11  C++14.: .  del ingles — .:  «.. », 2016. </p><br><p> [Sutter] <br> , .     C++.: .  del ingles — :  «.. », 2015. </p><br><p> [Sutter/Alexandrescu] <br> , . , .    ++.: .  del ingles — .:  «.. », 2015. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427281/">https://habr.com/ru/post/es427281/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427271/index.html">Historia y experiencia en el uso de la traducción automática. Conferencia de Yandex</a></li>
<li><a href="../es427273/index.html">¿Puede la inteligencia artificial dejar a los corredores de apuestas sin trabajo?</a></li>
<li><a href="../es427275/index.html">Arquitectura de la información de Internet Parte 3</a></li>
<li><a href="../es427277/index.html">Se encontró un patrón de difracción en la distribución de primos, similar al de los cuasicristales.</a></li>
<li><a href="../es427279/index.html">CoLaboratory: Android Night #Apple</a></li>
<li><a href="../es427283/index.html">Cómo se garantiza la alta disponibilidad en Kubernetes</a></li>
<li><a href="../es427285/index.html">Escuela sobre los fundamentos de los circuitos digitales: Novosibirsk - Ok, Krasnoyarsk - prepárate</a></li>
<li><a href="../es427289/index.html">Modelado geológico 3D, registro y tecnología de Aramco Innovations</a></li>
<li><a href="../es427291/index.html">Minimice el tráfico en los formularios web ASP.NET, div cliqueable y sondeo periódico del servidor</a></li>
<li><a href="../es427293/index.html">Patrones de diseño de JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>