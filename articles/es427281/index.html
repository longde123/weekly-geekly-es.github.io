<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèª üßê ü§® Desarrollo de clases de interfaz en C ++ üôâ üöó üì∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las clases de interfaz son muy utilizadas en programas C ++. Pero, desafortunadamente, a menudo se cometen errores al implementar soluciones basadas e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo de clases de interfaz en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427281/"><hr><p>  <i>Las clases de interfaz son muy utilizadas en programas C ++.</i>  <i>Pero, desafortunadamente, a menudo se cometen errores al implementar soluciones basadas en clases de interfaz.</i>  <i>El art√≠culo describe c√≥mo dise√±ar correctamente las clases de interfaz; se consideran varias opciones.</i>  <i>El uso de punteros inteligentes se describe en detalle.</i>  <i>Se proporciona un ejemplo de la implementaci√≥n de una clase de excepci√≥n y una plantilla de clase de colecci√≥n basada en clases de interfaz.</i> </p><hr><br><a name="habracut"></a><br><h1>  Tabla de contenidos </h1><br><div class="spoiler">  <b class="spoiler_title">Tabla de contenidos</b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introduccion</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1. Funciones especiales para miembros, creaci√≥n y eliminaci√≥n de objetos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones especiales para miembros</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Crear y eliminar objetos: detalles b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nivel de acceso al destructor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Crear y eliminar en un m√≥dulo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Deleci√≥n polim√≥rfica</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Eliminar cuando la declaraci√≥n de clase est√° incompleta</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2. Funciones puramente virtuales y clases abstractas.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones virtuales puras</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clases abstractas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Destructor virtual puro</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3. Clases de interfaz</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementaciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Creaci√≥n de objetos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Eliminar objeto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.3.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Usar el operador de eliminaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Usando una funci√≥n virtual especial</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.3.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Usar una funci√≥n externa</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.3.4</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Eliminaci√≥n autom√°tica mediante puntero inteligente</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otras opciones para administrar la vida √∫til de una instancia de una clase de implementaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copiar sem√°ntica</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Constructor de clase de interfaz</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interacci√≥n bidireccional</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Punteros inteligentes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones miembro constantes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interfaces COM</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clases de interfaz y bibliotecas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4. Un ejemplo de una clase de interfaz y su implementaci√≥n.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clase de interfaz</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clase de implementaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Punteros inteligentes est√°ndar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Creaci√≥n del lado del cliente</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementaci√≥n Creaci√≥n lateral</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementaci√≥n alternativa de clase base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5. Excepciones y colecciones implementadas usando clases de interfaz</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5.1 Excepciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5.2 Colecciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6. Clases de interfaz y clases de envoltura</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7. Resumen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Referencias</a> <br></div></div><br><a name="id-introdaction"></a><br><h1>  Introduccion </h1><br><p>  Una clase de interfaz es una clase que no tiene datos y se compone principalmente de funciones puramente virtuales.  Esta soluci√≥n le permite separar completamente la implementaci√≥n de la interfaz (el cliente usa la clase de interfaz) en otro lugar, se crea una clase derivada en la que se redefinen funciones puramente virtuales y se define la funci√≥n de f√°brica.  Los detalles de implementaci√≥n est√°n completamente ocultos para el cliente.  De esta forma, se implementa la verdadera encapsulaci√≥n, que es imposible con la clase habitual.  Puede leer sobre las clases de interfaz de Scott Meyers [Meyers2].  Las clases de interfaz tambi√©n se denominan clases de protocolo. </p><br><p>  El uso de clases de interfaz le permite debilitar las dependencias entre diferentes partes del proyecto, lo que simplifica el desarrollo del equipo y reduce el tiempo de compilaci√≥n / ensamblaje.  Las clases de interfaz facilitan la implementaci√≥n de soluciones flexibles y din√°micas cuando los m√≥dulos se cargan selectivamente en tiempo de ejecuci√≥n.  El uso de las clases de interfaz como una biblioteca de interfaz (API) (SDK) simplifica la soluci√≥n de problemas de compatibilidad binaria. </p><br><p>  Las clases de interfaz se usan ampliamente, con su ayuda implementan la interfaz (API) de bibliotecas (SDK), la interfaz de complementos (complementos) y mucho m√°s.  Muchos patrones de Gang of Four [GoF] se implementan naturalmente usando clases de interfaz.  Las clases de interfaz incluyen interfaces COM.  Pero, desafortunadamente, a menudo se cometen errores al implementar soluciones basadas en clases de interfaz.  Intentemos aclarar este problema. </p><br><a name="id-1"></a><br><h1>  1. Funciones especiales para miembros, creaci√≥n y eliminaci√≥n de objetos. </h1><br><p>  Esta secci√≥n describe brevemente una serie de caracter√≠sticas de C ++ que necesita conocer para comprender completamente las soluciones ofrecidas para las clases de interfaz. </p><br><a name="id-1-1"></a><br><h2>  1.1.  Funciones especiales para miembros </h2><br><p>  Si el programador no ha definido las funciones miembro de la clase de la siguiente lista (el constructor predeterminado, el constructor de copia, el operador de asignaci√≥n de copia, el destructor), entonces el compilador puede hacer esto por √©l.  C ++ 11 agreg√≥ un constructor de movimientos y un operador de asignaci√≥n de movimientos a esta lista.  Estas funciones miembro se denominan funciones miembro especiales.  Se generan solo si se usan y se cumplen condiciones adicionales espec√≠ficas para cada funci√≥n.  Llamamos la atenci√≥n sobre el hecho de que este uso puede resultar bastante oculto (por ejemplo, al implementar la herencia).  Si no se puede generar la funci√≥n requerida, se genera un error.  (Con la excepci√≥n de las operaciones de reubicaci√≥n, se reemplazan por operaciones de copia). Las funciones miembro generadas por el compilador son p√∫blicas e integrables. </p><br><p>  Las funciones miembro especiales no se heredan, si se requiere una funci√≥n miembro especial en la clase derivada, el compilador siempre intentar√° generarla; la presencia de la funci√≥n miembro correspondiente definida en la clase base por el programador no afecta esto. </p><br><p> El programador puede prohibir la generaci√≥n de funciones miembro especiales, en C ++ 11 es necesario usar la construcci√≥n <code>"=delete"</code> al declarar, en C ++ 98 declara la funci√≥n miembro correspondiente privada y no define.  En la herencia de clases, la prohibici√≥n de generar una funci√≥n miembro especial realizada en la clase base se aplica a todas las clases derivadas. </p><br><p>  Si el programador se siente c√≥modo con las funciones miembro generadas por el compilador, entonces en C ++ 11 puede indicar esto expl√≠citamente, y no simplemente descartar la declaraci√≥n.  Para hacer esto, debe usar la construcci√≥n <code>"=default"</code> al declarar, mientras que el c√≥digo se lee mejor y aparecen caracter√≠sticas adicionales relacionadas con la administraci√≥n del nivel de acceso. </p><br><p>  Los detalles sobre funciones especiales para miembros se pueden encontrar en [Meyers3]. </p><br><a name="id-1-2"></a><br><h2>  1.2.  Crear y eliminar objetos: detalles b√°sicos </h2><br><p>  Crear y eliminar objetos utilizando los operadores <code>new/delete</code> es una operaci√≥n t√≠pica de dos en uno.  Al llamar a <code>new</code> , la memoria se asigna primero para el objeto.  Si la selecci√≥n es exitosa, se llama al constructor.  Si el constructor produce una excepci√≥n, la memoria asignada se libera.  Cuando se llama al operador de <code>delete</code> , todo sucede en el orden inverso: primero, se llama al destructor, luego se libera la memoria.  El destructor no debe lanzar excepciones. </p><br><p>  Si el <code>new</code> operador se usa para crear una matriz de objetos, la memoria se asigna primero a toda la matriz.  Si la selecci√≥n es exitosa, se llama al constructor predeterminado para cada elemento de la matriz comenzando desde cero.  Si alg√∫n constructor arroja una excepci√≥n, entonces, para todos los elementos creados de la matriz, se llama al destructor en el orden inverso de la llamada del constructor, luego se libera la memoria asignada.  Para eliminar una matriz, debe llamar al operador <code>delete[]</code> (llamado operador de <code>delete</code> para las matrices), y para todos los elementos de la matriz, se llama al destructor en el orden inverso del constructor, luego se libera la memoria asignada. </p><br><p>  Atencion  Debe llamar a la forma correcta del operador de <code>delete</code> , dependiendo de si se elimina un solo objeto o matriz.  Esta regla debe observarse estrictamente, de lo contrario, puede obtener un comportamiento indefinido, es decir, puede suceder cualquier cosa: p√©rdidas de memoria, bloqueo, etc.  Ver [Meyers2] para m√°s detalles. </p><br><p>  Las funciones de asignaci√≥n de memoria est√°ndar <code>std::bad_alloc</code> satisfacen la solicitud y <code>std::bad_alloc</code> una excepci√≥n de tipo <code>std::bad_alloc</code> . </p><br><p>  Es seguro aplicar cualquier forma del operador de <code>delete</code> a un puntero nulo. </p><br><p>  En la descripci√≥n anterior, es necesaria una aclaraci√≥n.  Para los llamados tipos triviales (tipos incorporados, estructuras de estilo C), el constructor no puede ser llamado, y el destructor no hace nada en ning√∫n caso.  Ver tambi√©n la secci√≥n 1.6. </p><br><a name="id-1-3"></a><br><h2>  1.3.  Nivel de acceso al destructor </h2><br><p>  Cuando el operador de <code>delete</code> se aplica a un puntero a una clase, el destructor de esa clase debe estar disponible en el punto de llamada de <code>delete</code> .  (Hay una excepci√≥n a esta regla, discutida en la Secci√≥n 1.6.) Por lo tanto, al hacer que el destructor sea seguro o cerrado, el programador proh√≠be el uso del operador de <code>delete</code> cuando el destructor no est√° disponible.  Recuerde que si no se define un destructor en la clase, el compilador lo har√° solo, y este destructor estar√° abierto (consulte la secci√≥n 1.1). </p><br><a name="id-1-4"></a><br><h2>  1.4.  Crear y eliminar en un m√≥dulo </h2><br><p>  Si el <code>new</code> operador cre√≥ un objeto, entonces el operador de <code>delete</code> debe estar en el mismo m√≥dulo para <code>delete</code> .  Hablando en sentido figurado, "ponlo donde lo llevaste".  Esta regla es bien conocida; ver, por ejemplo, [Sutter / Alexandrescu].  Si se viola esta regla, puede producirse un "desajuste" de las funciones de asignaci√≥n y liberaci√≥n de memoria, lo que, por regla general, conduce a una finalizaci√≥n anormal del programa. </p><br><a name="id-1-5"></a><br><h2>  1.5.  Deleci√≥n polim√≥rfica </h2><br><p>  Si est√° dise√±ando una jerarqu√≠a polim√≥rfica de clases cuyas instancias se eliminan utilizando el operador de <code>delete</code> , entonces debe haber un destructor virtual abierto en la clase base, esto asegura que se llama al destructor del tipo real del objeto cuando el operador de <code>delete</code> se aplica al puntero a la clase base.  Si se viola esta regla, puede ocurrir una llamada al destructor de la clase base, lo que puede conducir a una p√©rdida de recursos. </p><br><a name="id-1-6"></a><br><h2>  1.6.  Eliminar cuando la declaraci√≥n de clase est√° incompleta </h2><br><p>  La omnivorosidad del operador de <code>delete</code> puede crear ciertos problemas; se puede aplicar a un puntero de tipo <code>void*</code> o a un puntero a una clase que tiene una declaraci√≥n incompleta (preventiva).  En este caso, no se produce un error, solo se omite la llamada al destructor, solo se llama a la funci√≥n para liberar la memoria.  Considere un ejemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   X* CreateX(); void Foo() {    X* p = CreateX();    delete p; }</span></span></code> </pre> <br><p>  Este c√≥digo se compila incluso si una declaraci√≥n de clase <code>X</code> completa no est√° disponible en el dial dial de <code>delete</code> .  Es cierto que al compilar (Visual Studio) se emite una advertencia: </p><br><p> <code>warning C4150: deletion of pointer to incomplete type 'X'; no destructor called</code> </p> <br><p>  Si hay una implementaci√≥n de <code>X</code> y <code>CreateX()</code> , entonces el c√≥digo se <code>CreateX()</code> , si <code>CreateX()</code> devuelve un puntero al objeto creado por el <code>new</code> operador, entonces la llamada <code>Foo()</code> ejecuta con √©xito, no se llama al destructor.  Est√° claro que esto puede conducir a una fuga de recursos, por lo que una vez m√°s sobre la necesidad de tener cuidado con las advertencias. </p><br><p>  Esta situaci√≥n no es descabellada, puede surgir f√°cilmente cuando se utilizan clases como punteros inteligentes o clases de descriptores.  Scott Meyers trata este problema en [Meyers3]. </p><br><a name="id-2"></a><br><h1>  2. Funciones puramente virtuales y clases abstractas. </h1><br><p>  El concepto de clases de interfaz se basa en conceptos de C ++ como funciones virtuales puras y clases abstractas. </p><br><a name="id-2-1"></a><br><h2>  2.1.  Funciones virtuales puras </h2><br><p>  Una funci√≥n virtual declarada usando la construcci√≥n <code>"=0"</code> se llama virtual pura. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...    virtual void Foo() = 0; };</span></span></code> </pre> <br><p>  A diferencia de una funci√≥n virtual normal, no se puede definir una funci√≥n puramente virtual (con la excepci√≥n del destructor, consulte la secci√≥n 2.3), pero debe redefinirse en una de las clases derivadas. </p><br><p>  Se pueden definir funciones puramente virtuales.  Emblem Sutter ofrece varios usos √∫tiles para esta funci√≥n [Obturador]. </p><br><a name="id-2-2"></a><br><h2>  2.2.  Clases abstractas </h2><br><p>  Una clase abstracta es una clase que tiene al menos una funci√≥n puramente virtual.  Una clase que se deriva de una clase abstracta y no anula al menos una funci√≥n puramente virtual tambi√©n ser√° abstracta.  El est√°ndar C ++ proh√≠be crear instancias de una clase abstracta; solo puede crear instancias de derivados de clases no abstractas.  Por lo tanto, se crea una clase abstracta para ser utilizada como una clase base.  En consecuencia, si un constructor se define en una clase abstracta, entonces no tiene sentido hacerlo abierto, debe protegerse. </p><br><a name="id-2-3"></a><br><h2>  2.3.  Destructor virtual puro </h2><br><p>  En algunos casos, es aconsejable hacer un destructor virtual puro.  Pero esta soluci√≥n tiene dos caracter√≠sticas. </p><br><ol><li>  Se debe definir un destructor puramente virtual.  (La definici√≥n predeterminada generalmente se usa, es decir, usando la construcci√≥n <code>"=default"</code> ). El destructor de clase derivado llama a los destructores de clase base a lo largo de toda la cadena de herencia y, por lo tanto, se garantiza que la cola llegue a la ra√≠z, un destructor puramente virtual. </li><li>  Si el programador no ha redefinido un destructor virtual puro en la clase derivada, el compilador lo har√° por √©l (consulte la secci√≥n 1.1).  Por lo tanto, una clase derivada de una clase abstracta con un destructor puramente virtual puede perder su abstracci√≥n sin anular expl√≠citamente el destructor. </li></ol><br><p>  Un ejemplo del uso de un destructor virtual puro se puede encontrar en la secci√≥n 4.4. </p><br><a name="id-3"></a><br><h1>  3. Clases de interfaz </h1><br><p>  Una clase de interfaz es una clase abstracta que no tiene datos y se compone principalmente de funciones puramente virtuales.  Dicha clase puede tener funciones virtuales ordinarias (no puramente virtuales), por ejemplo, un destructor.  Tambi√©n puede haber funciones miembro est√°ticas, como las funciones de f√°brica. </p><br><a name="id-3-1"></a><br><h2>  3.1.  Implementaciones </h2><br><p>  Una implementaci√≥n de una clase de interfaz se llamar√° una clase derivada en la que se redefinen funciones puramente virtuales.  Puede haber varias implementaciones de la misma clase de interfaz, y son posibles dos esquemas: horizontal, cuando varias clases diferentes heredan la misma clase de interfaz, y vertical, cuando la clase de interfaz es la ra√≠z de la jerarqu√≠a polim√≥rfica.  Por supuesto, puede haber h√≠bridos. </p><br><p>  El punto clave del concepto de clases de interfaz es la separaci√≥n completa de la interfaz de la implementaci√≥n: el cliente solo trabaja con la clase de interfaz, la implementaci√≥n no est√° disponible. </p><br><a name="id-3-2"></a><br><h2>  3.2.  Creaci√≥n de objetos </h2><br><p>  La inaccesibilidad de la clase de implementaci√≥n causa ciertos problemas al crear objetos.  El cliente debe crear una instancia de la clase de implementaci√≥n y obtener un puntero a la clase de interfaz a trav√©s de la cual se acceder√° al objeto.  Como la clase de implementaci√≥n no est√° disponible, no puede usar el constructor, por lo que se usa la funci√≥n de f√°brica, que se define en el lado de la implementaci√≥n.  Esta funci√≥n generalmente crea un objeto usando el <code>new</code> operador y devuelve un puntero al objeto creado, convertido en un puntero a una clase de interfaz.  Una funci√≥n de f√°brica puede ser un miembro est√°tico de una clase de interfaz, pero no es necesario, por ejemplo, puede ser miembro de una clase de f√°brica especial (que, a su vez, puede ser una clase de interfaz) o una funci√≥n libre.  Una funci√≥n de f√°brica puede devolver no un puntero sin formato a una clase de interfaz, sino uno inteligente.  Esta opci√≥n se discute en las secciones 3.3.4 y 4.3.2. </p><br><a name="id-3-3"></a><br><h2>  3.3.  Eliminar objeto </h2><br><p>  Eliminar un objeto es una operaci√≥n extremadamente cr√≠tica.  Un error da como resultado una p√©rdida de memoria o una eliminaci√≥n doble, que generalmente conduce a un bloqueo del programa.  A continuaci√≥n, este problema se considera lo m√°s detallado posible, y se presta mucha atenci√≥n a la prevenci√≥n de acciones err√≥neas de los clientes. </p><br><p>  Hay cuatro opciones principales: </p><br><ol><li>  Usando el operador de <code>delete</code> . </li><li>  Usando una funci√≥n virtual especial. </li><li>  Usando una funci√≥n externa. </li><li>  Eliminaci√≥n autom√°tica mediante puntero inteligente. </li></ol><br><a name="id-3-3-1"></a><br><h3>  3.3.1  Usar el operador de <code>delete</code> <br></h3><br><p>  Para hacer esto, debe tener un destructor virtual abierto en la clase de interfaz.  En este caso, el operador de <code>delete</code> , que solicita un puntero a una clase de interfaz en el lado del cliente, proporciona una llamada al destructor de la clase de implementaci√≥n.  Esta opci√≥n puede funcionar, pero es dif√≠cil reconocerla como exitosa.  Recibimos llamadas de los operadores <code>new</code> y <code>delete</code> en diferentes lados de la "barrera", <code>new</code> en el lado de implementaci√≥n, <code>delete</code> en el lado del cliente.  Y si la implementaci√≥n de la clase de interfaz se realiza en un m√≥dulo separado (que es algo bastante com√∫n), obtenemos una violaci√≥n de la regla de la secci√≥n 1.4. </p><br><a name="id-3-3-2"></a><br><h3>  3.3.2.  Usando una funci√≥n virtual especial </h3><br><p>  M√°s progresiva es otra opci√≥n: la clase de interfaz debe tener una funci√≥n virtual especial que elimine el objeto.  Dicha funci√≥n, al final, se reduce a llamar a <code>delete this</code> , pero esto ya est√° sucediendo en el lado de la implementaci√≥n.  Dicha funci√≥n se puede invocar de diferentes maneras, por ejemplo <code>Delete()</code> , pero tambi√©n se usan otras opciones: <code>Release()</code> , <code>Destroy()</code> , <code>Dispose()</code> , <code>Free()</code> , <code>Close()</code> , etc.  Adem√°s de seguir la regla en la secci√≥n 1.4, esta opci√≥n tiene varias ventajas adicionales. </p><br><ol><li>  Le permite utilizar funciones personalizadas de asignaci√≥n / desasignaci√≥n de memoria para la clase de implementaci√≥n. </li><li>  Le permite implementar un esquema m√°s complejo para controlar la vida √∫til del objeto de implementaci√≥n, por ejemplo, utilizando un contador de referencia. </li></ol><br><p>  En esta realizaci√≥n, se puede compilar e incluso realizar un intento de eliminar un objeto utilizando el operador de <code>delete</code> , pero esto es un error.  Para evitarlo en la clase de interfaz, es suficiente tener un destructor protegido vac√≠o o puramente virtual (ver secci√≥n 1.3).  Tenga en cuenta que el uso del operador de <code>delete</code> puede estar bastante enmascarado, por ejemplo, los punteros inteligentes est√°ndar utilizan el operador de eliminaci√≥n para eliminar un objeto de forma predeterminada y el c√≥digo correspondiente est√° profundamente oculto en su implementaci√≥n.  Un destructor protegido le permite detectar todos esos intentos en la etapa de compilaci√≥n. </p><br><a name="id-3-3-3"></a><br><h3>  3.3.3  Usar una funci√≥n externa </h3><br><p>  Esta opci√≥n puede atraer una cierta simetr√≠a de procedimientos para crear y eliminar un objeto, pero en realidad no tiene ventajas sobre la versi√≥n anterior, pero hay muchos problemas adicionales.  Esta opci√≥n no se recomienda para su uso y no se considera en el futuro. </p><br><a name="id-3-3-4"></a><br><h3>  3.3.4  Eliminaci√≥n autom√°tica mediante puntero inteligente </h3><br><p>  En este caso, la funci√≥n de f√°brica no devuelve un puntero sin formato a una clase de interfaz, sino un puntero inteligente correspondiente.  Este puntero inteligente se crea en el lado de implementaci√≥n y encapsula el objeto de eliminaci√≥n, que elimina autom√°ticamente el objeto de implementaci√≥n cuando el puntero inteligente (o su √∫ltima copia) queda fuera del alcance en el lado del cliente.  En este caso, es posible que no se requiera una funci√≥n virtual especial para eliminar el objeto de implementaci√≥n, pero a√∫n se necesita un destructor protegido, es necesario para evitar el uso err√≥neo del operador de <code>delete</code> .  (Es cierto que debe tenerse en cuenta que la probabilidad de tal error se reduce notablemente). Esta opci√≥n se analiza con m√°s detalle en la Secci√≥n 4.3.2. </p><br><a name="id-3-4"></a><br><h2>  3.4.  Otras opciones para administrar la vida √∫til de una instancia de una clase de implementaci√≥n </h2><br><p>  En algunos casos, el cliente puede recibir un puntero a la clase de interfaz, pero no ser el propietario.  La gesti√≥n de la vida √∫til del objeto de implementaci√≥n est√° completamente del lado de la implementaci√≥n.  Por ejemplo, un objeto puede ser un objeto singleton est√°tico (esta soluci√≥n es t√≠pica para las f√°bricas).  Otro ejemplo est√° relacionado con la interacci√≥n bidireccional, ver secci√≥n 3.7.  El cliente no debe eliminar dicho objeto, pero se necesita un destructor protegido para dicha clase de interfaz, es necesario evitar el uso err√≥neo del operador de <code>delete</code> . </p><br><a name="id-3-5"></a><br><h2>  3.5.  Copiar sem√°ntica </h2><br><p>  Para una clase de interfaz, no es posible crear una copia del objeto de implementaci√≥n utilizando el constructor de copia, por lo que si se requiere copiar, la clase debe tener una funci√≥n virtual que cree una copia del objeto de implementaci√≥n y devuelva un puntero a la clase de interfaz.  Dicha funci√≥n a menudo se denomina constructor virtual, y su nombre tradicional es <code>Clone()</code> o <code>Duplicate()</code> . </p><br><p>  El uso del operador de asignaci√≥n de copias no est√° prohibido, pero no puede considerarse una buena idea.  El operador de asignaci√≥n de copia siempre est√° emparejado; debe estar emparejado con el constructor de copia.  El operador generado por el compilador predeterminado no tiene sentido; no hace nada.  Te√≥ricamente, puede declarar un operador de asignaci√≥n puramente virtual, seguido de anulaci√≥n, pero la asignaci√≥n virtual no es una pr√°ctica recomendada; los detalles se pueden encontrar en [Meyers1].  Adem√°s, la asignaci√≥n parece poco natural: el acceso a los objetos de la clase de implementaci√≥n generalmente se realiza a trav√©s de un puntero a la clase de interfaz, por lo que la asignaci√≥n se ver√° as√≠: </p><br><pre> <code class="cpp hljs">* = *;</code> </pre> <br><p>  El operador de asignaci√≥n est√° mejor prohibido, y si es necesario, dicha sem√°ntica tiene en la clase de interfaz la funci√≥n virtual correspondiente. </p><br><p>  Hay dos formas de prohibir la asignaci√≥n. </p><br><ol><li>  Declare el operador de asignaci√≥n eliminado ( <code>=delete</code> ).  Si las clases de interfaz forman una jerarqu√≠a, esto es suficiente para hacerlo en la clase base.  La desventaja de este m√©todo es que afecta la clase de implementaci√≥n, la prohibici√≥n tambi√©n se aplica a ella. </li><li>  Declare una declaraci√≥n de asignaci√≥n protegida con una definici√≥n predeterminada ( <code>=default</code> ).  Esto no afecta a la clase de implementaci√≥n, pero en el caso de una jerarqu√≠a de clases de interfaz, dicho anuncio debe hacerse en cada clase. </li></ol><br><a name="id-3-6"></a><br><h2>  3.6.  Constructor de clase de interfaz </h2><br><p>  A menudo, el constructor de una clase de interfaz no se declara.  En este caso, el compilador genera el constructor predeterminado necesario para implementar la herencia (ver secci√≥n 1.1).  Este constructor est√° abierto, aunque lo suficiente como para ser seguro.  Si en la clase de interfaz el constructor de copia se declara eliminado ( <code>=delete</code> ), la generaci√≥n por el compilador del constructor se suprime por defecto, y dicho constructor debe declararse expl√≠citamente.  Es natural hacerlo seguro con una definici√≥n predeterminada ( <code>=default</code> ).  En principio, la declaraci√≥n de tal constructor protegido siempre se puede hacer.  Un ejemplo est√° en la secci√≥n 4.4. </p><br><a name="id-3-7"></a><br><h2>  3.7.  Interacci√≥n bidireccional </h2><br><p>  Las clases de interfaz son convenientes para usar la comunicaci√≥n bidireccional.  Si se puede acceder a alg√∫n m√≥dulo a trav√©s de las clases de interfaz, el cliente tambi√©n puede crear implementaciones de algunas clases de interfaz y pasarles punteros en el m√≥dulo.  A trav√©s de estos punteros, el m√≥dulo puede recibir servicios del cliente y tambi√©n transmitir datos o notificaciones al cliente. </p><br><a name="id-3-8"></a><br><h2>  3.8.  Punteros inteligentes </h2><br><p>  Dado que el acceso a los objetos de la clase de implementaci√≥n generalmente se realiza a trav√©s de un puntero, es natural utilizar punteros inteligentes para controlar su vida √∫til.  Pero debe tenerse en cuenta que si se usa la segunda opci√≥n para eliminar objetos, entonces con el puntero inteligente est√°ndar es necesario transferir un eliminador de usuario (tipo) o una instancia de este tipo.  Si esto no se hace, el puntero inteligente utilizar√° el operador de eliminaci√≥n para eliminar el objeto, y el c√≥digo simplemente no se compilar√° (gracias al destructor protegido).  Los punteros inteligentes est√°ndar (incluido el uso de removedores personalizados) se analizan en detalle en [Josuttis], [Meyers3].  Un ejemplo de uso de un removedor personalizado se puede encontrar en la secci√≥n 4.3.1. </p><br><p>      ,       ,      ,    . </p><br><a name="id-3-9"></a><br><h2>  3.9.  - </h2><br><p>     -    const.              ,  ,    -,       . </p><br><a name="id-3-10"></a><br><h2>  3.10. COM- </h2><br><p> COM-    ,     ,  COM ‚Äî      ,  COM-     ,   C,    ,   .  COM-  C++      ,   COM. </p><br><a name="id-3-11"></a><br><h2>  3.11.     </h2><br><p>         (API)    (SDK).       .    -,      -,           .     ,     (Windows DLL),     :  -.          .        ,  ,       .     <code>LoadLibrary()</code>      ,    -,       . </p><br><a name="id-4"></a><br><h1> 4.       </h1><br><a name="id-4-1"></a><br><h2>  4.1.   </h2><br><p>       ,      . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   public:    virtual void Delete() = 0; //      IBase&amp; operator=(const IBase&amp;) = delete; //   };</span></span></code> </pre> <br><p>    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IActivatable</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBase { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    ~IActivatable() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   public:    virtual void Activate(bool activate) = 0;    static IActivatable* CreateInstance(); // - };</span></span></code> </pre> <br><p> ,         ,     .     ,           <code>IBase</code> .     ,            (.  1.3).       ,       . </p><br><a name="id-4-2"></a><br><h2>  4.2.   </h2><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IActivatable { <span class="hljs-comment"><span class="hljs-comment">// ... private:    Activator(); protected:    ~Activator(); public:    void Delete() override;    void Activate(bool activate) override;    friend IActivatable* IActivatable::CreateInstance(); }; Activator::Activator() {/* ... */} Activator::~Activator() {/* ... */} void Activator::Delete() { delete this; } void Activator::Activate(bool activate) {/* ... */} IActivatable* IActivatable::CreateInstance() {    return static_cast&lt;IActivatable*&gt;(new Activator()); }</span></span></code> </pre> <br><p>      , ,        ,  -  ,         . </p><br><a name="id-4-3"></a><br><h2>  4.3.    </h2><br><a name="id-4-3-1"></a><br><h3> 4.3.1.     </h3><br><p>           . -   (     <code>IBase</code> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseDeleter</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IBase* p)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ p-&gt;Delete(); } };</code> </pre> <br><p>  <code>std::unique_ptr&lt;&gt;</code> -   : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> ‚Äî  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;I, BaseDeleter&gt;;</code> </pre> <br><p> ,   ,  -   ,  <code>UniquePtr</code>    . </p><br><p>   -: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> ‚Äî  - </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateInstance</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class">&lt;I&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateInstance</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UniquePtr&lt;I&gt;(I::CreateInstance()); }</code> </pre> <br><p>        : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> ‚Äî  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class">&lt;I&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToPtr</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UniquePtr&lt;I&gt;(p); }</code> </pre> <br><p>  <code>std::shared_ptr&lt;&gt;</code>    <code>std::unique_ptr&lt;&gt;</code> ,   ,  <code>std::shared_ptr&lt;&gt;</code>   .      <code>Activator</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> un1 = CreateInstance&lt;IActivatable&gt;(); un1-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> un2 = ToPtr(IActivatable::CreateInstance()); un2-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IActivatable&gt; sh = CreateInstance&lt;IActivatable&gt;(); sh-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br><p>          (     ‚Äî -): </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IActivatable&gt; sh2(IActivatable::CreateInstance());</code> </pre> <br><p>     <code>std::make_shared&lt;&gt;()</code> ,      (    ). </p><br><p>    :          ,     .     :     ,  - .     4.4. </p><br><a name="id-4-3-2"></a><br><h3> 4.3.2.     </h3><br><p>       .           -.   <code>std::shared_ptr&lt;&gt;</code>         ,    ,      (         ).     <code>std::shared_ptr&lt;&gt;</code> (  )  -  ,           <code>delete</code>     .  <code>std::shared_ptr&lt;&gt;</code> -       (   )   -      .        . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class IActivatable; using ActPtr = std::shared_ptr&lt;IActivatable&gt;; //   class IActivatable { protected:    virtual ~IActivatable() = default; //      IActivatable&amp; operator=(const IActivatable&amp;) = default; //   public:    virtual void Activate(bool activate) = 0;    static ActPtr CreateInstance(); // - }; //   class Activator : public IActivatable { // ... public:    Activator();  //      ~Activator(); //      void Activate(bool activate) override; }; Activator::Activator() {/* ... */} Activator::~Activator() {/* ... */} void Activator::Activate(bool activate) {/* ... */} ActPtr IActivatable::CreateInstance() {    return ActPtr(new Activator()); }</span></span></span></span></code> </pre> <br><p>  -        <code>std::make_shared&lt;&gt;()</code> : </p><br><pre> <code class="cpp hljs">ActPtr IActivatable::CreateInstance() {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;Activator&gt;(); }</code> </pre> <br><p>      <code>std::unique_ptr&lt;&gt;</code> ,        , -   ,        . </p><br><a name="id-4-4"></a><br><h2>  4.4.     </h2><br><p>    C#  Java  C++    ¬´¬ª,       .        .      <code>IBase</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IBase() = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,       virtual void Delete(); //   public:    IBase(const IBase&amp;) = delete;            //      IBase&amp; operator=(const IBase&amp;) = delete; //      struct Deleter        // -    {        void operator()(IBase* p) const { p-&gt;Delete(); }    };    friend struct IBase::Deleter; };</span></span></code> </pre> <br><p>     , <code>Delete()</code>    ,     . </p><br><pre> <code class="cpp hljs">IBase::~IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IBase::Delete() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>      <code>IBase</code> .         <code>Delete()</code> ,              . -      <code>IBase</code> . <code>Delete()</code>  , - .     <code>Delete()</code>         ,    .       ,    4.3.1. </p><br><a name="id-5"></a><br><h1> 5.   ,      </h1><br><a name="id-5-1"></a><br><h2> 5.1  </h2><br><p>  ,    ,   ,      ,        . </p><br><p>   ,  ,    <code>IException</code>    <code>Exception</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IException</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">;</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IException() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">What</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    IException&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IException&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> {</span></span>    IException* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m_Ptr; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code);    Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Exception&amp; src) : m_Ptr(src.m_Ptr-&gt;Clone()) {}    ~Exception() { m_Ptr-&gt;Delete(); }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Ptr; } };</code> </pre> <br><p>         <code>Exception</code> ,            <code>IException</code> .       ,    <code>throw</code> ,   .    <code>Exception</code>      ,      .  -      ,   . </p><br><p>  <code>Exception</code> , ,  . </p><br><p>   <code>IException</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExcImpl</span></span></span><span class="hljs-class"> :</span></span> IException {    <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">;</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_What;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_Code;    ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code);    ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ExcImpl&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    <span class="hljs-function"><span class="hljs-function">IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    ~ExcImpl() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">What</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; }; ExcImpl::ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code)    : m_What(what), m_Code(code) {} IException* ExcImpl::Clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExcImpl(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ExcImpl::Delete() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ExcImpl::What() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_What.c_str(); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ExcImpl::Code() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Code; }</code> </pre> <br><p>   <code>Exception</code> : </p><br><pre> <code class="cpp hljs">Exception::Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code)    : m_Ptr(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExcImpl(what, code)) {}</code> </pre> <br><p>    ,       ‚Äî .NET ‚Äî  , ‚Äî          ,     C++/CLI.  ,        ,     ,   C++/CLI. </p><br><a name="id-5-2"></a><br><h2> 5.2  </h2><br><p>   -    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICollect</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ICollect() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ICollect&lt;T&gt;* Clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ind)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ind)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    ICollect&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ICollect&lt;T&gt;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>        ,             -,        . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICollect</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Contain</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ICollect&lt;T&gt; CollType;    CollType* m_Coll; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T value_type;    Contain(CollType* coll);    ~Contain(); <span class="hljs-comment"><span class="hljs-comment">//     Contain(const Contain&amp; src);    Contain&amp; operator=(const Contain&amp; src); //     Contain(Contain&amp;&amp; src);    Contain&amp; operator=(Contain&amp;&amp; src);    bool mpty() const;    int size() const;    T&amp; operator[](int ind);    const T&amp; operator[](int ind) const;    Iterator&lt;T&gt; begin();    Iterator&lt;T&gt; end(); };</span></span></code> </pre> <br><p>      .   ,       . ,      ,    ,     ,    - <code>begin()</code>  <code>end()</code> ,   .           (. [Josuttis]),         <code>for</code>   .                .            , ,      . </p><br><a name="id-6"></a><br><h1> 6.    - </h1><br><p>       .         -,      .          .   ,         ++.              ,   .NET, Java  Pyton.              .      ,  ,         .   .NET Framework     C++/CLI          C++.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </p><br><a name="id-conclusion"></a><br><h1> 7.  </h1><br><p>      -,         . </p><br><p>         . </p><br><ol><li>   <code>delete</code> . </li><li>    . </li><li>      . </li></ol><br><p>          . </p><br><p>         ,       <code>delete</code> .                ,      . </p><br><p>    -   ,           .             ,    ,      <code>delete</code> . </p><br><p>             . </p><br><p>      ,          ,     ,  ,       . </p><br><br><a name="id-refs"></a><br><h1>   </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[GoF] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gamma E., Helm R., Johnson R., Vlissides J. M√©todos de dise√±o orientado a objetos. </font><font style="vertical-align: inherit;">Patrones de dise√±o.: Por.</font></font> del ingles<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - San Petersburgo: Peter, 2001. </font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Josuttis] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josattis, Nikolai M. Biblioteca est√°ndar de C ++: Gu√≠a de referencia, 2¬™ ed .: Per.</font></font> del ingles<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- M .: LLC "I.D. </font><font style="vertical-align: inherit;">Williams, 2014.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Dewhurst] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dewhurst, Stefan K. Lugares resbaladizos C ++. </font><font style="vertical-align: inherit;">C√≥mo evitar problemas al dise√±ar y compilar sus programas.: Per.</font></font> del ingles<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - M .: DMK Press, 2012. </font></font></p><br><p> [Meyers1] <br> , .    C++. 35        .: .  del ingles ‚Äî .:  , 2000. </p><br><p> [Meyers2] <br> , .   C++. 55        .: .  del ingles ‚Äî .:  , 2014. </p><br><p> [Meyers3] <br> , .    C++: 42    C++11  C++14.: .  del ingles ‚Äî .:  ¬´.. ¬ª, 2016. </p><br><p> [Sutter] <br> , .     C++.: .  del ingles ‚Äî :  ¬´.. ¬ª, 2015. </p><br><p> [Sutter/Alexandrescu] <br> , . , .    ++.: .  del ingles ‚Äî .:  ¬´.. ¬ª, 2015. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427281/">https://habr.com/ru/post/es427281/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427271/index.html">Historia y experiencia en el uso de la traducci√≥n autom√°tica. Conferencia de Yandex</a></li>
<li><a href="../es427273/index.html">¬øPuede la inteligencia artificial dejar a los corredores de apuestas sin trabajo?</a></li>
<li><a href="../es427275/index.html">Arquitectura de la informaci√≥n de Internet Parte 3</a></li>
<li><a href="../es427277/index.html">Se encontr√≥ un patr√≥n de difracci√≥n en la distribuci√≥n de primos, similar al de los cuasicristales.</a></li>
<li><a href="../es427279/index.html">CoLaboratory: Android Night #Apple</a></li>
<li><a href="../es427283/index.html">C√≥mo se garantiza la alta disponibilidad en Kubernetes</a></li>
<li><a href="../es427285/index.html">Escuela sobre los fundamentos de los circuitos digitales: Novosibirsk - Ok, Krasnoyarsk - prep√°rate</a></li>
<li><a href="../es427289/index.html">Modelado geol√≥gico 3D, registro y tecnolog√≠a de Aramco Innovations</a></li>
<li><a href="../es427291/index.html">Minimice el tr√°fico en los formularios web ASP.NET, div cliqueable y sondeo peri√≥dico del servidor</a></li>
<li><a href="../es427293/index.html">Patrones de dise√±o de JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>