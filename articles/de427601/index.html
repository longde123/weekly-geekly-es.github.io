<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¶ üë©üèª‚Äçüéì üôáüèΩ 5 + 1 Fall, in dem die REST-API-Spezifikation eine gro√üe Rolle spielt üçÄ üö£üèº üîî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel konzentriert sich auf das Schreiben und Unterst√ºtzen einer n√ºtzlichen und relevanten Spezifikation f√ºr ein REST-API-Projekt, wodurch vi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 + 1 Fall, in dem die REST-API-Spezifikation eine gro√üe Rolle spielt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427601/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/b1/dg/ob/b1dgobh5dxfw3q-firfz-77qu-0.png"></div><br><p> Dieser Artikel konzentriert sich auf das Schreiben und Unterst√ºtzen einer n√ºtzlichen und relevanten Spezifikation f√ºr ein REST-API-Projekt, wodurch viel zus√§tzlicher Code eingespart und die Integrit√§t, Zuverl√§ssigkeit und Transparenz des gesamten Projekts erheblich verbessert wird. </p><br><h3 id="chto-takoe-restful-api">  Was ist eine RESTful-API? </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dde/ee8/857/ddeee88570832b82d7a7ff7231255c3f.png"></div><br><p>  Das ist ein Mythos. </p><br><p>  Im Ernst, wenn Sie glauben, dass Ihr Projekt eine RESTful-API hat, irren Sie sich mit ziemlicher Sicherheit.  Die Idee von RESTful ist es, eine API zu erstellen, die in jeder Hinsicht den vom REST-Stil beschriebenen Architekturregeln und -beschr√§nkungen entspricht. Unter realen Bedingungen ist dies jedoch <em>fast unm√∂glich</em> . </p><a name="habracut"></a><br><p>  Einerseits enth√§lt REST zu viele vage und mehrdeutige Definitionen.  Beispielsweise werden einige Begriffe aus W√∂rterb√ºchern von HTTP-Methoden und Statuscodes in der Praxis nicht f√ºr den vorgesehenen Zweck verwendet, w√§hrend viele von ihnen √ºberhaupt nicht verwendet werden. </p><br><p>  Andererseits schafft REST zu viele Einschr√§nkungen.  Beispielsweise ist die atomare Nutzung von Ressourcen in der realen Welt f√ºr die von mobilen Anwendungen verwendeten APIs nicht rational.  Eine vollst√§ndige Weigerung, den Status zwischen Anforderungen zu speichern, ist im Wesentlichen ein Verbot des Mechanismus von Benutzersitzungen, die in vielen APIs verwendet werden. </p><br><p>  <strong>Aber warte, nicht alles ist so schlimm!</strong> </p><br><h3 id="zachem-nuzhna-specifikaciya-rest-api">  Warum ben√∂tigen wir die REST-API-Spezifikation? </h3><br><p>  Trotz dieser M√§ngel bleibt REST mit einem vern√ºnftigen Ansatz eine hervorragende Grundlage f√ºr das Entwerfen wirklich cooler APIs.  Eine solche API sollte interne Einheitlichkeit, eine klare Struktur, eine bequeme Dokumentation und eine gute Abdeckung durch Unit-Tests aufweisen.  All dies kann erreicht werden, indem eine Qualit√§tsspezifikation f√ºr Ihre API entwickelt wird. </p><br><p>  Am h√§ufigsten wird <em>die</em> REST-API- <em>Spezifikation</em> mit ihrer <em>Dokumentation</em> verkn√ºpft.  Im Gegensatz zur ersten (eine formale Beschreibung Ihrer API) soll die Dokumentation von Personen gelesen werden, z. B. von Entwicklern einer Mobil- oder Webanwendung, die Ihre API verwenden. </p><br><p>  Zus√§tzlich zur eigentlichen Erstellung der Dokumentation kann eine ordnungsgem√§√üe API-Beschreibung jedoch noch viele Vorteile bringen.  In dem Artikel m√∂chte ich Beispiele daf√ºr nennen, wie Sie unter Verwendung der kompetenten Verwendung der Spezifikation: </p><br><ul><li>  Vereinfachung und Zuverl√§ssigkeit von Unit-Tests; </li><li>  Vorverarbeitung und Validierung von Eingabedaten konfigurieren; </li><li>  Automatisierung der Serialisierung und Gew√§hrleistung der Integrit√§t der Antworten; </li><li>  und nutzen Sie sogar die statische Typisierung. </li></ul><br><h3 id="openapi">  Openapi </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/222/aae/af9/222aaeaf95adf9cb50af1ed7702d4c9b.png" width="500"></div><br><p>  Das heute allgemein akzeptierte Format zur Beschreibung der REST-API ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>OpenAPI</strong></a> , das auch als <em>Swagger bezeichnet wird</em> .  Diese Spezifikation ist eine einzelne Datei im JSON- oder YAML-Format, die aus drei Abschnitten besteht: </p><br><ul><li>  einen Header, der den Namen, die Beschreibung und die Version der API sowie zus√§tzliche Informationen enth√§lt; </li><li>  eine Beschreibung aller Ressourcen, einschlie√ülich ihrer Kennungen, HTTP-Methoden, aller Eingabeparameter sowie Codes und Formate des Antwortk√∂rpers mit Links zu Definitionen; </li><li>  Alle Definitionen von Objekten im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JSON-Schema-</strong></a> Format, die sowohl in Eingabeparametern als auch in Antworten verwendet werden k√∂nnen. </li></ul><br><p>  OpenAPI hat einen schwerwiegenden Nachteil - die <em>Komplexit√§t der Struktur und h√§ufig die Redundanz</em> .  Bei einem kleinen Projekt kann der Inhalt der JSON-Spezifikationsdatei schnell auf mehrere tausend Zeilen anwachsen.  Es ist nicht m√∂glich, diese Datei manuell in diesem Formular zu verwalten.  Dies ist eine ernsthafte Bedrohung f√ºr die Idee, eine aktuelle Spezifikation beizubehalten, wenn sich die API weiterentwickelt. </p><br><p>  Es gibt viele visuelle Editoren, mit denen Sie die API beschreiben und die resultierende OpenAPI-Spezifikation erstellen k√∂nnen.  Auf diesen basieren wiederum zus√§tzliche Dienste und Cloud-L√∂sungen, z. B. <em>Swagger</em> , <em>Apiary</em> , <em>Stoplight</em> , <em>Restlet</em> und andere. </p><br><p>  F√ºr mich waren solche Dienste jedoch nicht sehr praktisch, da es schwierig war, die Spezifikation schnell zu bearbeiten und mit dem Code-Schreibprozess zu kombinieren.  Ein weiteres Minus ist die Abh√§ngigkeit von der Menge der Funktionen jedes einzelnen Dienstes.  Beispielsweise ist es praktisch unm√∂glich, vollwertige Unit-Tests nur √ºber einen Cloud-Service durchzuf√ºhren.  Die Codegenerierung und sogar die Erstellung von "Steckern" f√ºr Endpunkte sind in der Praxis praktisch nutzlos, obwohl dies sehr gut m√∂glich erscheint. </p><br><h3 id="tinyspec">  Tinyspec </h3><br><p>  In diesem Artikel werde ich Beispiele verwenden, die auf dem nativen REST-API-Beschreibungsformat - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>tinyspec</strong></a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>basieren</strong></a> .  Das Format besteht aus kleinen Dateien, die die im Projekt verwendeten Endpunkte und Datenmodelle mit einer intuitiven Syntax beschreiben.  Dateien werden neben dem Code gespeichert, sodass Sie sie direkt beim Schreiben √ºberpr√ºfen und bearbeiten k√∂nnen.  In diesem Fall wird tinyspec automatisch zu einer vollwertigen OpenAPI kompiliert, die sofort im Projekt verwendet werden kann.  Es ist Zeit, Ihnen genau zu sagen, wie. </p><br><p>  In diesem Artikel werde ich Beispiele aus Node.js (koa, express) und Ruby on Rails geben, obwohl diese Praktiken f√ºr die meisten Technologien gelten, einschlie√ülich Python, PHP und Java. </p><br><h2 id="kogda-eschyo-specifikaciya-okazyvaetsya-neveroyatno-poleznoy">  Wenn die Spezifikation unglaublich n√ºtzlich ist </h2><br><h3 id="1-unit-testy-endpointov">  1. Unit-Tests von Endpunkten </h3><br><p>  <em>Die verhaltensgesteuerte Entwicklung (BDD) ist</em> ideal f√ºr die Entwicklung einer REST-API.  Der bequemste Weg, Unit-Tests zu schreiben, ist nicht f√ºr einzelne Klassen, Modelle und Controller, sondern f√ºr bestimmte Endpunkte.  In jedem Test emulieren Sie eine echte HTTP-Anforderung und √ºberpr√ºfen die Serverantwort.  In Node.js gibt es zum Emulieren von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testanforderungen Supertest</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://www.chaijs.com/plugins/chai-">Chai-http</a> in Ruby on Rails - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Airborne</a> . </p><br><p> Angenommen, wir haben ein <code>User</code> und einen <code>GET /users</code> Endpunkt, der alle Benutzer zur√ºckgibt.  Hier ist die Tinyspec-Syntax, die dies beschreibt: </p><br><ol><li>  <em>User.models.tinyspec-</em> Datei: </li></ol><br><pre> <code class="python hljs">User {name, isAdmin: b, age?: i}</code> </pre> <br><ol><li>  Datei <em>users.endpoints.tinyspec</em> : </li></ol><br><pre> <code class="python hljs">GET /users =&gt; {users: User[]}</code> </pre> <br><p>  So wird unser Test aussehen: </p><br><h4 id="nodejs">  Node.js </h4><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'List all users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { status, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { users } } = request.get(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>); expect(status).to.equal(<span class="hljs-number"><span class="hljs-number">200</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].name).to.be(<span class="hljs-string"><span class="hljs-string">'string'</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].isAdmin).to.be(<span class="hljs-string"><span class="hljs-string">'boolean'</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].age).to.be.oneOf([<span class="hljs-string"><span class="hljs-string">'boolean'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>]); }); });</code> </pre> <br><h4 id="ruby-on-rails">  Ruby on Rails </h4><br><pre> <code class="ruby hljs">describe <span class="hljs-string"><span class="hljs-string">'GET /users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it <span class="hljs-string"><span class="hljs-string">'List all users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get <span class="hljs-string"><span class="hljs-string">'/users'</span></span> expect_status(<span class="hljs-number"><span class="hljs-number">200</span></span>) expect_json_types(<span class="hljs-string"><span class="hljs-string">'users.*'</span></span>, { <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:string</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">isAdmin:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:boolean</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">age:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:integer_or_null</span></span>, }) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Wenn wir eine Spezifikation haben, die Serverantwortformate beschreibt, k√∂nnen wir den Test vereinfachen und <em>die Antwort</em> einfach <em>anhand dieser Spezifikation √ºberpr√ºfen</em> .  Dazu nutzen wir die Tatsache, dass unsere Tinyspec-Modelle in OpenAPI-Definitionen umgewandelt werden, die wiederum dem JSON-Schema-Format entsprechen. </p><br><p>  Jedes <em>Literalobjekt</em> in JS (oder <code>Hash</code> in Ruby, ein <code>dict</code> in Python, <em>ein assoziatives Array</em> in PHP und sogar eine <code>Map</code> in Java) kann auf Konformit√§t mit einem JSON-Schema getestet werden.  Und es gibt sogar geeignete Plugins zum Testen von Frameworks, zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jest-ajv</a> (npm), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">chai-ajv-json-schema</a> (npm) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">json_matchers</a> (rubygem) f√ºr RSpec. </p><br><p>  Bevor Sie die Schemata verwenden, m√ºssen Sie sie mit dem Projekt verbinden.  Zuerst generieren wir die openapi.json-Spezifikationsdatei basierend auf tinyspec (diese Aktion kann vor jedem Testlauf automatisch ausgef√ºhrt werden): </p><br><pre> <code class="bash hljs">tinyspec -j -o openapi.json</code> </pre> <br><h4 id="nodejs-1">  Node.js </h4><br><p>  Jetzt k√∂nnen wir den empfangenen JSON im Projekt verwenden und den <code>definitions</code> entnehmen, der alle JSON-Schemata enth√§lt.  Schemata k√∂nnen Querverweise ( <code>$ref</code> ) enthalten. Wenn wir also verschachtelte Schemata haben (z. B. <code>Blog {posts: Post[]}</code> ), m√ºssen wir sie "erweitern", um sie f√ºr Validierungen zu verwenden.  Dazu verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">json-schema-deref-sync</a> (npm). </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deref <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'json-schema-deref-sync'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spec = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./openapi.json'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> schemas = deref(spec).definitions; describe(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'List all users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { status, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { users } } = request.get(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>); expect(status).to.equal(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Chai expect(users[0]).to.be.validWithSchema(schemas.User); // Jest expect(users[0]).toMatchSchema(schemas.User); }); });</span></span></code> </pre> <br><h4 id="ruby-on-rails-1">  Ruby on Rails </h4><br><p>  <code>json_matchers</code> kann mit <code>$ref</code> Links umgehen, erfordert jedoch auf bestimmte Weise separate Dateien mit Schemata im Dateisystem. <code>swagger.json</code> m√ºssen Sie <code>swagger.json</code> in viele kleine Dateien <code>swagger.json</code> (mehr dazu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ): </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># ./spec/support/json_schemas.rb require 'json' require 'json_matchers/rspec' JsonMatchers.schema_root = 'spec/schemas' # Fix for json_matchers single-file restriction file = File.read 'spec/schemas/openapi.json' swagger = JSON.parse(file, symbolize_names: true) swagger[:definitions].keys.each do |key| File.open("spec/schemas/#{key}.json", 'w') do |f| f.write(JSON.pretty_generate({ '$ref': "swagger.json#/definitions/#{key}" })) end end</span></span></code> </pre> <br><p>  Danach k√∂nnen wir unseren Test folgenderma√üen schreiben: </p><br><pre> <code class="ruby hljs">describe <span class="hljs-string"><span class="hljs-string">'GET /users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it <span class="hljs-string"><span class="hljs-string">'List all users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get <span class="hljs-string"><span class="hljs-string">'/users'</span></span> expect_status(<span class="hljs-number"><span class="hljs-number">200</span></span>) expect(result[<span class="hljs-symbol"><span class="hljs-symbol">:users</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]).to match_json_schema(<span class="hljs-string"><span class="hljs-string">'User'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Hinweis: Das Schreiben von Tests auf diese Weise ist unglaublich praktisch.  Insbesondere, wenn Ihre IDE das Ausf√ºhren von Tests und das Debuggen unterst√ºtzt (z. B. WebStorm, RubyMine und Visual Studio).  Sie k√∂nnen also √ºberhaupt keine andere Software verwenden, und der gesamte Entwicklungszyklus der API wird auf drei aufeinanderfolgende Schritte reduziert: </p><br><ol><li>  Spezifikationsdesign (z. B. in Tinyspec); </li><li>  Schreiben eines vollst√§ndigen Satzes von Tests f√ºr hinzugef√ºgte / ge√§nderte Endpunkte; </li><li>  Entwicklung von Code, der alle Tests erf√ºllt. </li></ol><br><h3 id="2-validaciya-vhodnyh-dannyh">  2. Validierung der Eingabe </h3><br><p>  OpenAPI beschreibt das Format nicht nur von Antworten, sondern auch von Eingabedaten.  Dies erm√∂glicht es uns, <em>die</em> vom Benutzer direkt w√§hrend der Anfrage erhaltenen <em>Daten</em> zu <em>validieren</em> . </p><br><p>  Angenommen, wir haben die folgende Spezifikation, die das Aktualisieren von Benutzerdaten sowie alle Felder beschreibt, die ge√§ndert werden k√∂nnen: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># user.models.tinyspec UserUpdate !{name?, age?: i} # users.endpoints.tinyspec PATCH /users/:id {user: UserUpdate} =&gt; {success: b}</span></span></code> </pre> <br><p>  Fr√ºher haben wir uns Plugins zur Validierung in Tests angesehen. In allgemeineren F√§llen gibt es jedoch Validierungsmodule f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ajv</a> (npm) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSON-Schema</a> (Rubygem). Verwenden Sie diese und schreiben Sie einen Controller mit Validierung. </p><br><h4 id="nodejs-koa">  Node.js (Koa) </h4><br><p>  Dies ist ein Beispiel f√ºr <strong>Koa</strong> , den Nachfolger von Express, aber f√ºr Express sieht der Code √§hnlich aus. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Router <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'koa-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ajv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ajv'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { schemas } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schemas'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); <span class="hljs-comment"><span class="hljs-comment">// Standard resource update action in Koa. router.patch('/:id', async (ctx) =&gt; { const updateData = ctx.body.user; // Validation using JSON schema from API specification. await validate(schemas.UserUpdate, updateData); const user = await User.findById(ctx.params.id); await user.update(updateData); ctx.body = { success: true }; }); async function validate(schema, data) { const ajv = new Ajv(); if (!ajv.validate(schema, data)) { const err = new Error(); err.errors = ajv.errors; throw err; } }</span></span></code> </pre> <br><p>  Wenn in diesem Beispiel die Eingabedaten nicht der Spezifikation entsprechen, gibt der Server eine <code>500 Internal Server Error</code> Antwort an den Client zur√ºck.  Um dies zu verhindern, k√∂nnen wir den Validierungsfehler abfangen und eine eigene Antwort erstellen, die detailliertere Informationen zu bestimmten Feldern enth√§lt, die den Test nicht bestanden haben, und auch <em>der Spezifikation entspricht</em> . </p><br><p>  F√ºgen <code>FieldsValidationError</code> Datei <code>FieldsValidationError</code> eine Beschreibung des <code>FieldsValidationError</code> Modells <code>FieldsValidationError</code> : </p><br><pre> <code class="python hljs">Error {error: b, message} InvalidField {name, message} FieldsValidationError &lt; Error {fields: InvalidField[]}</code> </pre> <br><p>  Und jetzt geben wir es als eine der m√∂glichen Antworten unseres Endpunkts an: </p><br><pre> <code class="python hljs">PATCH /users/:id {user: UserUpdate} =&gt; <span class="hljs-number"><span class="hljs-number">200</span></span> {success: b} =&gt; <span class="hljs-number"><span class="hljs-number">422</span></span> FieldsValidationError</code> </pre> <br><p>  Mit diesem Ansatz k√∂nnen Sie Komponententests schreiben, die die Richtigkeit der Fehlerbildung mit falschen Daten √ºberpr√ºfen, die vom Client empfangen wurden. </p><br><h3 id="3-serializaciya-modeley">  3. Serialisierung von Modellen </h3><br><p>  Fast alle modernen Server-Frameworks verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ORM auf die eine</a> oder andere Weise.  Dies bedeutet, dass die meisten in der API im System verwendeten Ressourcen in Form von Modellen, deren Instanzen und Sammlungen dargestellt werden. </p><br><p>  Das Generieren einer JSON-Darstellung dieser Entit√§ten zur √úbertragung in der API-Antwort wird als <em>Serialisierung bezeichnet</em> .  Es gibt eine Reihe von Plugins f√ºr verschiedene Frameworks, die Serialisierungsfunktionen ausf√ºhren, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sequelize-to-Json</a> (npm), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Acts_as_api</a> (Rubygem), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jsonapi-Rails</a> (Rubygem).  Tats√§chlich erm√∂glichen diese Plugins einem bestimmten Modell, eine Liste von Feldern anzugeben, die im JSON-Objekt enthalten sein m√ºssen, sowie zus√§tzliche Regeln, um sie beispielsweise umzubenennen oder Werte dynamisch zu berechnen. </p><br><p>  Schwierigkeiten beginnen, wenn wir mehrere verschiedene JSON-Darstellungen desselben Modells ben√∂tigen oder wenn ein Objekt verschachtelte Entit√§ten enth√§lt - Assoziationen.  <em>Vererbung, Wiederverwendung und Verkn√ºpfung von Serialisierern sind</em> erforderlich. </p><br><p>  Verschiedene Module l√∂sen diese Probleme auf unterschiedliche Weise, aber denken wir mal, kann uns die Spezifikation wieder helfen?  Tats√§chlich sind bereits alle Informationen zu den Anforderungen f√ºr JSON-Darstellungen, alle m√∂glichen Kombinationen von Feldern, einschlie√ülich verschachtelter Entit√§ten, enthalten.  So k√∂nnen wir einen automatischen Serializer schreiben. </p><br><p>  Ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mache</a> Sie auf ein kleines Modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sequelize-Serialize</a> (npm) aufmerksam, mit dem Sie dies f√ºr Sequelize-Modelle tun k√∂nnen.  Es verwendet eine Instanz des Modells oder eines Arrays sowie die erforderliche Schaltung und erstellt iterativ ein serialisiertes Objekt, wobei alle erforderlichen Felder ber√ºcksichtigt werden und verschachtelte Schaltungen f√ºr die zugeordneten Entit√§ten verwendet werden. </p><br><p>  Angenommen, wir m√ºssen alle Benutzer, die Blog-Beitr√§ge haben, einschlie√ülich der Kommentare zu diesen Beitr√§gen, von der API zur√ºckgeben.  Wir beschreiben dies anhand der folgenden Spezifikation: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># models.tinyspec Comment {authorId: i, message} Post {topic, message, comments?: Comment[]} User {name, isAdmin: b, age?: i} UserWithPosts &lt; User {posts: Post[]} # blogUsers.endpoints.tinyspec GET /blog/users =&gt; {users: UserWithPosts[]}</span></span></code> </pre> <br><p>  Jetzt k√∂nnen wir die Abfrage mit Sequelize erstellen und ein serialisiertes Objekt zur√ºckgeben, das genau der oben beschriebenen Spezifikation entspricht: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Router <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'koa-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> serialize <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'sequelize-serialize'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { schemas } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schemas'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); router.get(<span class="hljs-string"><span class="hljs-string">'/blog/users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (ctx) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> User.findAll({ <span class="hljs-attr"><span class="hljs-attr">include</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">association</span></span>: User.posts, <span class="hljs-attr"><span class="hljs-attr">required</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">include</span></span>: [Post.comments] }] }); ctx.body = serialize(users, schemas.UserWithPosts); });</code> </pre> <br><p>  Es ist fast magisch, oder? </p><br><h3 id="4-staticheskaya-tipizaciya">  4. Statische Eingabe </h3><br><p>  Wenn Sie so cool sind, dass Sie TypeScript oder Flow verwenden, haben Sie sich vielleicht schon gefragt: <em>"Was ist mit meinen lieben statischen Typen ?!"</em>  .  Mit den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Modulen sw2dts</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">swagger-to-flowtype k√∂nnen</a> Sie alle erforderlichen Definitionen basierend auf JSON-Schemata generieren und f√ºr die statische Typisierung von Tests, Eingabedaten und Serialisierern verwenden. </p><br><pre> <code class="bash hljs">tinyspec -j sw2dts ./swagger.json -o Api.d.ts --namespace Api</code> </pre> <br><p>  Jetzt k√∂nnen wir Typen in Controllern verwenden: </p><br><pre> <code class="hljs pgsql">router.patch(<span class="hljs-string"><span class="hljs-string">'/users/:id'</span></span>, async (ctx) =&gt; { // Specify <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> request data <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> const userData: Api.UserUpdate = ctx.request.body.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>; // Run spec validation await <span class="hljs-keyword"><span class="hljs-keyword">validate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.UserUpdate, userData); // Query the <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = await <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.findById(ctx.params.id); await <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(userData); // <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span> serialized result const serialized: Api.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> = serialize(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>); ctx.body = { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: serialized }; });</code> </pre> <br><p>  Und in den Tests: </p><br><pre> <code class="hljs pgsql">it(<span class="hljs-string"><span class="hljs-string">'Update user'</span></span>, async () =&gt; { // Static <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> test <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> data. const updateData: Api.UserUpdate = { <span class="hljs-type"><span class="hljs-type">name</span></span>: MODIFIED }; const res = await request.patch(<span class="hljs-string"><span class="hljs-string">'/users/1'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: updateData }); // <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> helper <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> request response: const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: Api.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> = res.body.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>; expect(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.be.validWithSchema(<span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>); expect(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.containSubset(updateData); });</code> </pre> <br><p>  Beachten Sie, dass die generierten Typdefinitionen nicht nur im API-Projekt selbst, sondern auch in Clientanwendungsprojekten verwendet werden k√∂nnen, um die Arten von Funktionen zu beschreiben, in denen die API funktioniert.  Angular Kundenentwickler werden mit diesem Geschenk besonders zufrieden sein. </p><br><h3 id="5-privedenie-tipov-query-string">  5. Geben Sie die Konvertierung der Abfragezeichenfolge ein </h3><br><p>  Wenn Ihre API aus irgendeinem Grund Anforderungen mit dem MIME-Typ <code>application/x-www-form-urlencoded</code> und nicht <code>application/json</code> akzeptiert, <code>application/x-www-form-urlencoded</code> der Anforderungshauptteil folgenderma√üen aus: </p><br><pre> <code class="python hljs">param1=value&amp;param2=<span class="hljs-number"><span class="hljs-number">777</span></span>&amp;param3=false</code> </pre> <br><p>  Gleiches gilt f√ºr Abfrageparameter (z. B. in GET-Anfragen).  In diesem Fall kann der Webserver die Typen nicht automatisch erkennen. Alle Daten liegen in Form von Zeichenfolgen vor ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier finden Sie eine Erl√§uterung</a> im Repository des Moduls qpm npm). Nach dem Parsen erhalten Sie das folgende Objekt: </p><br><pre> <code class="python hljs">{ param1: <span class="hljs-string"><span class="hljs-string">'value'</span></span>, param2: <span class="hljs-string"><span class="hljs-string">'777'</span></span>, param3: <span class="hljs-string"><span class="hljs-string">'false'</span></span> }</code> </pre> <br><p>  In diesem Fall wird die Anforderung nicht gem√§√ü dem Schema validiert. Dies bedeutet, dass manuell √ºberpr√ºft werden muss, ob jeder Parameter das richtige Format hat, und auf den erforderlichen Typ gebracht werden muss. </p><br><p>  Wie Sie vielleicht erraten haben, kann dies mit denselben Schemata aus unserer Spezifikation erfolgen.  Stellen Sie sich vor, wir haben einen solchen Endpunkt und ein solches Schema: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># posts.endpoints.tinyspec GET /posts?PostsQuery # post.models.tinyspec PostsQuery { search, limit: i, offset: i, filter: { isRead: b } }</span></span></code> </pre> <br><p>  Hier ist ein Beispiel f√ºr eine Anforderung an einen solchen Endpunkt </p><br><pre> <code class="python hljs">GET /posts?search=needle&amp;offset=<span class="hljs-number"><span class="hljs-number">10</span></span>&amp;limit=<span class="hljs-number"><span class="hljs-number">1</span></span>&amp;filter[isRead]=true</code> </pre> <br><p>  Schreiben wir eine <code>castQuery</code> Funktion, die alle Parameter in die f√ºr uns erforderlichen Typen <code>castQuery</code> .  Es wird ungef√§hr so ‚Äã‚Äãaussehen: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">castQuery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">query, schema</span></span></span><span class="hljs-function">) </span></span>{ _.mapValues(query, (value, key) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { type } = schema.properties[key] || {}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value || !type) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'integer'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(value, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'number'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">parseFloat</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'boolean'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value !== <span class="hljs-string"><span class="hljs-string">'false'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } }); }</code> </pre> <br><p>  Die vollst√§ndigere Implementierung mit Unterst√ºtzung f√ºr verschachtelte Schemata, Arrays und <code>null</code> ist in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cast-with-Schema</a> (npm) verf√ºgbar.  Jetzt k√∂nnen wir es in unserem Code verwenden: </p><br><pre> <code class="javascript hljs">router.get(<span class="hljs-string"><span class="hljs-string">'/posts'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (ctx) =&gt; { <span class="hljs-comment"><span class="hljs-comment">// Cast parameters to expected types const query = castQuery(ctx.query, schemas.PostsQuery); // Run spec validation await validate(schemas.PostsQuery, query); // Query the database const posts = await Post.search(query); // Return serialized result ctx.body = { posts: serialize(posts, schemas.Post) }; });</span></span></code> </pre> <br><p>  Beachten Sie, wie von den vier Zeilen des Endpunktcodes die drei Verwendungsschemata aus der Spezifikation stammen. </p><br><h2 id="luchshie-praktiki">  Best Practices </h2><br><h3 id="otdelnye-shemy-dlya-sozdaniya-i-izmeneniya">  Separate Schemata zum Erstellen und √Ñndern </h3><br><p>  In der Regel unterscheiden sich die Schemata, die die Serverantwort beschreiben, von denen, die die Eingabe zum Erstellen und √Ñndern von Modellen beschreiben.  Beispielsweise sollte die Liste der verf√ºgbaren Felder f√ºr <code>PATCH</code> und <code>PATCH</code> Anforderungen streng begrenzt sein, w√§hrend bei <code>PATCH</code> Anforderungen normalerweise alle Felder des Schemas optional sind.  Die Schemata, die die Antwort bestimmen, sind m√∂glicherweise freier. </p><br><p>  Die automatische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Generierung von tinyspec CRUDL-</a> Endpunkten verwendet die Postfixes <code>New</code> und <code>Update</code> .  <code>User*</code> k√∂nnen wie folgt definiert werden: </p><br><pre> <code class="python hljs">User {id, email, name, isAdmin: b} UserNew !{email, name} UserUpdate !{email?, name?}</code> </pre> <br><p>  Versuchen Sie, nicht dieselben Schemata f√ºr verschiedene Arten von Aktionen zu verwenden, um versehentliche Sicherheitsprobleme aufgrund der Wiederverwendung oder Vererbung alter Schemata zu vermeiden. </p><br><h3 id="semantika-v-nazvaniyah-shem">  Semantik in Schemanamen </h3><br><p>  Der Inhalt derselben Modelle kann an verschiedenen Endpunkten variieren.  Verwenden Sie die Postfixes <code>With*</code> und <code>For*</code> in Schemanamen, um zu zeigen, wie sie sich unterscheiden und wof√ºr sie bestimmt sind.  In tinyspec k√∂nnen Modelle auch voneinander vererbt werden.  Zum Beispiel: </p><br><pre> <code class="python hljs">User {name, surname} UserWithPhotos &lt; User {photos: Photo[]} UserForAdmin &lt; User {id, email, lastLoginAt: d}</code> </pre> <br><p>  Postfixes k√∂nnen variiert und kombiniert werden.  Die Hauptsache ist, dass ihr Name das Wesentliche widerspiegelt und die Vertrautheit mit der Dokumentation vereinfacht. </p><br><h3 id="razdelenie-endpointov-po-tipu-klienta">  Trennung der Endpunkte nach Clienttyp </h3><br><p>  H√§ufig geben dieselben Endpunkte je nach Clienttyp oder Rolle des Benutzers, der auf den Endpunkt zugreift, unterschiedliche Daten zur√ºck.  Beispielsweise k√∂nnen die Endpunkte von <code>GET /users</code> und <code>GET /messages</code> f√ºr Benutzer Ihrer mobilen Anwendung und f√ºr Backoffice-Manager sehr unterschiedlich sein.  Gleichzeitig kann das √Ñndern des Namens des Endpunkts selbst zu kompliziert sein. </p><br><p>  Um denselben Endpunkt mehrmals zu beschreiben, k√∂nnen Sie seinen Typ in Klammern nach dem Pfad einf√ºgen.  Dar√ºber hinaus ist es n√ºtzlich, Tags zu verwenden: Dies hilft dabei, die Dokumentation Ihrer Endpunkte in Gruppen zu unterteilen, von denen jede f√ºr eine bestimmte Gruppe von Clients Ihrer API konzipiert ist.  Zum Beispiel: </p><br><pre> <code class="python hljs">Mobile app: GET /users (mobile) =&gt; UserForMobile[] CRM admin panel: GET /users (admin) =&gt; UserForAdmin[]</code> </pre> <br><h2 id="dokumentaciya-rest-api">  REST-API-Dokumentation </h2><br><p>  Sobald Sie eine Spezifikation im Tinyspec- oder OpenAPI-Format haben, k√∂nnen Sie eine sch√∂ne Dokumentation in HTML erstellen und zur Freude der Entwickler ver√∂ffentlichen, die Ihre API verwenden. </p><br><p>  Zus√§tzlich zu den zuvor erw√§hnten Cloud-Diensten gibt es CLI-Tools, die OpenAPI 2.0 in HTML und PDF konvertieren. Anschlie√üend k√∂nnen Sie es auf jedes statische Hosting herunterladen.  Beispiele: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bootprint-openapi</a> (npm, standardm√§√üig in tinyspec verwendet) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">swagger2markup-cli</a> (jar, es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Anwendungsbeispiel</a> , es wird in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tinyspec Cloud verwendet</a> ) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">redoc-cli</a> (npm) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Widdershins</a> (npm) </li></ul><br><p>  <em>Kennen Sie weitere Beispiele?</em>  <em>Teile sie in den Kommentaren.</em> </p><br><p>  Leider wird OpenAPI 3.0, das vor einem Jahr ver√∂ffentlicht wurde, immer noch schlecht unterst√ºtzt, und ich konnte keine w√ºrdigen Beispiele f√ºr eine darauf basierende Dokumentation finden: weder unter Cloud-L√∂sungen noch unter CLI-Tools.  Aus dem gleichen Grund wird OpenAPI 3.0 in tinyspec noch nicht unterst√ºtzt. </p><br><h3 id="publikaciya-v-github">  Auf GitHub ver√∂ffentlichen </h3><br><p>  Eine der einfachsten M√∂glichkeiten, Dokumentation zu ver√∂ffentlichen, sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub-Seiten</a> .  Aktivieren Sie einfach die statische Seitenunterst√ºtzung f√ºr das Verzeichnis <code>/docs</code> in Ihren Repository-Einstellungen und speichern Sie die HTML-Dokumentation in diesem Ordner. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/09b/5ad/775/09b5ad7757239f4405cb370cb59c6a7b.png"></p><br><p>  Sie k√∂nnen einen Befehl zum Generieren von Dokumentation √ºber tinyspec oder ein anderes CLI-Tool in den <code>scripts</code> in <code>package.json</code> und die Dokumentation bei jedem Commit aktualisieren: </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-string"><span class="hljs-string">"docs"</span></span>: <span class="hljs-string"><span class="hljs-string">"tinyspec -h -o docs/"</span></span>, <span class="hljs-string"><span class="hljs-string">"precommit"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run docs"</span></span> }</code> </pre> <br><h3 id="continuous-integration">  Kontinuierliche Integration </h3><br><p>  Sie k√∂nnen die Dokumentationsgenerierung in den CI-Zyklus aufnehmen und sie beispielsweise in Amazon S3 unter verschiedenen Adressen ver√∂ffentlichen, abh√§ngig von der Umgebung oder Version Ihrer API, z. B. <code>/docs/2.0</code> , <code>/docs/stable</code> , <code>/docs/staging</code> . </p><br><h3 id="tinyspec-cloud">  Tinyspec Wolke </h3><br><p>  Wenn Ihnen die Tinyspec-Syntax gefallen hat, k√∂nnen Sie sich unter tinyspec.cloud als Early Adopter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">registrieren</a> .  Wir werden auf dieser Basis einen Cloud-Service und eine CLI f√ºr die automatische Ver√∂ffentlichung von Dokumentationen mit einer gro√üen Auswahl an Vorlagen und der M√∂glichkeit zur Entwicklung eigener Vorlagen erstellen. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Die Entwicklung einer REST-API ist vielleicht die unterhaltsamste Aktivit√§t von allen, die bei der Arbeit an modernen Web- und Mobilfunkdiensten vorhanden sind.  Es gibt keinen Zoo mit Browsern, Betriebssystemen und Bildschirmgr√∂√üen, alles unterliegt unserer Kontrolle - ‚Äûan Ihren Fingerspitzen‚Äú. </p><br><p>  Die Beibehaltung der aktuellen Spezifikation und der Boni in Form verschiedener Automatisierungen, die gleichzeitig bereitgestellt werden, machen diesen Prozess noch angenehmer.  Eine solche API wird strukturiert, transparent und zuverl√§ssig. </p><br><p>  <em>In der Tat, selbst wenn wir uns mit der Erschaffung eines Mythos besch√§ftigen, warum machen wir ihn dann nicht sch√∂n?</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427601/">https://habr.com/ru/post/de427601/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427587/index.html">Konzentriertes Java f√ºr eineinhalbtausend Menschen. Wie war Joker 2018?</a></li>
<li><a href="../de427589/index.html">Wir schreiben einen Online-Chat auf Websockets mit Swoole</a></li>
<li><a href="../de427591/index.html">Architektur als Belastung</a></li>
<li><a href="../de427593/index.html">Schnellbefehlsmagie in Vivaldi 2.1</a></li>
<li><a href="../de427595/index.html">Versuchen Sie Micronaut oder Darling, ich habe das Framework reduziert</a></li>
<li><a href="../de427603/index.html">Wie man endlich anf√§ngt, Tests zu schreiben und es nicht bereut</a></li>
<li><a href="../de427605/index.html">Wie die Crowdsourcing-Plattform von Yandex Drohnen trainiert und die Servicequalit√§t bewertet</a></li>
<li><a href="../de427607/index.html">Rechenzentrum in der Schweiz: wie am Schn√ºrchen arbeiten</a></li>
<li><a href="../de427609/index.html">L√∂sen der Gleichung mit ganzzahliger Division ohne rohe Gewalt</a></li>
<li><a href="../de427611/index.html">Die Geschichte, wie ich Yandex MapKit auf iOS oder Karten aktualisiert habe, Geld, 2 Mappits</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>