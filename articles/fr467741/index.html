<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏾 📝 🔞 Introduction aux assemblages déterministes en C / C ++. partie 1 👷🏼 👆🏾 ⛱️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La traduction de l'article a été préparée spécialement pour les étudiants du cours "Développeur C ++" . 



 Qu'est-ce qu'un assemblage déterministe? ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introduction aux assemblages déterministes en C / C ++. partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/467741/">  <i>La traduction de l'article a été préparée spécialement pour les étudiants du cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Développeur C ++"</a> .</i> <br><br><img src="https://habrastorage.org/webt/pe/j0/5e/pej05eo-w-5tdwrp0yrlv7lbedy.png"><br><hr><br><h3>  Qu'est-ce qu'un assemblage déterministe? </h3><br>  Un assemblage déterministe est le processus d'assemblage du même code source avec le même environnement et les mêmes instructions d'assemblage, dans lequel les mêmes fichiers binaires sont créés dans tous les cas, même s'ils sont créés sur différentes machines, dans différents répertoires et avec des noms différents .  De tels assemblys sont parfois appelés assemblages jouables ou scellés, s'il est garanti qu'ils créeront les mêmes fichiers binaires même lors de la compilation à partir de différents dossiers. <a name="habracut"></a><br><br>  Les assemblages déterministes ne se produisent pas par eux-mêmes.  Ils ne sont pas créés dans des projets ordinaires et les raisons pour lesquelles cela ne se produit pas peuvent être différentes pour chaque système d'exploitation ou compilateur. <br><br>  Les assemblages déterministes doivent être garantis pour un <i>environnement d'assemblage</i> donné.  Cela signifie que certaines variables, telles que le <i>système d'exploitation, les versions du système de construction et l'architecture cible</i> , restent probablement les mêmes dans différents assemblys. <br><br>  Ces dernières années, diverses organisations, telles que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chromium</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Reproductible builds</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Yocto</a> , ont déployé de grands efforts pour réaliser des assemblages déterministes. <br><br><h3>  L'importance des assemblages déterministes </h3><br>  Il y a deux raisons principales pour lesquelles les assemblages déterministes sont si importants: <br><br><ul><li>  <b>La sécurité</b>  Changer les binaires au lieu du code source peut rendre les modifications invisibles pour les auteurs originaux.  Cela peut être fatal dans des environnements critiques pour la sécurité tels que la médecine, l'aviation et l'espace.  Des résultats potentiellement identiques pour ces matériaux permettent à des tiers de parvenir à un consensus sur le bon résultat. </li><li>  <b>Traçabilité et contrôle binaire</b> .  Si vous souhaitez disposer d'un référentiel pour stocker vos fichiers binaires, il est fort probable que vous ne souhaitiez pas créer de fichiers binaires avec des sommes de contrôle aléatoires à partir de sources dans la même révision.  Cela peut amener le système de référentiel à stocker différents fichiers binaires sous différentes versions alors qu'ils devraient être identiques.  Par exemple, si vous travaillez sous Windows ou MacOS, la bibliothèque possède des champs avec l'heure de création / modification des fichiers objets qui y sont inclus, ce qui entraînera des différences dans les fichiers binaires. </li></ul><br><h3>  Fichiers binaires impliqués dans le processus de construction en C / C ++ </h3><br>  Il existe différents types de binaires créés pendant le processus de génération en C / C ++, selon le système d'exploitation. <br><br>  <b>Microsoft Windows</b>  Les plus importants sont les fichiers avec les extensions <code>.obj</code> , <code>.lib</code>  <code>dll</code> et <code>.exe</code> .  Ils sont tous conformes à la spécification du format exécutable portable (PE).  Ces fichiers peuvent être analysés avec des outils comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dumpbin</a> . <br>  <b>Linux</b>  Les fichiers avec les extensions <code>.o</code> , <code>.a</code> , <code>.so</code> et sans extensions (pour les fichiers binaires exécutables) correspondent au format des fichiers exécutables et liables (ELF).  Le contenu des fichiers ELF peut être analysé à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">readelf</a> . <br>  <b>Mac OS</b>  Les fichiers avec les extensions <code>.o</code> , <code>.a</code> , <code>.dylib</code> et sans extensions (pour les fichiers binaires exécutables) sont conformes à la spécification du format Mach-O.  Ces fichiers peuvent être vérifiés à l'aide de l'application <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">otool</a> , qui fait partie de la boîte à outils <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Xcode</a> sur MacOS. <br><br><h3>  Sources de variations </h3><br>  De nombreux facteurs différents peuvent rendre vos assemblages <i>non déterministes</i> .  Les facteurs varient pour différents systèmes d'exploitation et compilateurs.  Chaque compilateur possède certains paramètres pour corriger les sources de variation.  À ce jour, <code>gcc</code> et <code>clang</code> sont les compilateurs qui contiennent plus d'options de correction.  Il existe des options non documentées pour <code>msvc</code> que vous pouvez essayer, mais à la fin, vous devrez probablement corriger les binaires pour obtenir des assemblys déterministes. <br><br><h4>  Horodatages ajoutés par le compilateur / l'éditeur de liens </h4><br>  Il existe deux raisons principales pour lesquelles nos binaires peuvent contenir des informations temporelles qui les rendent illisibles: <br><br><ul><li>  Utilisation des <code>__TIME__</code> <code>__DATE__</code> ou <code>__TIME__</code> dans la source. </li><li>  Lorsqu'un format de fichier vous oblige à stocker des informations temporelles dans des fichiers objets.  C'est le cas du format Portable Executable sous Windows et Mach-O sous MacOS.  Sous Linux, les fichiers ELF ne codent aucun horodatage. </li></ul><br>  Regardons un exemple où ces informations se terminent par la compilation d'une bibliothèque statique du projet de base hello world sur MacOS. <br><br><pre> <code class="cpp hljs">. ├── CMakeLists.txt ├── hello_world.cpp ├── hello_world.hpp ├── main.cpp └── run_build.sh</code> </pre> <br>  La bibliothèque affiche un message dans le terminal: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"hello_world.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; void HelloWorld::PrintMessage(const std::string &amp; message) { std::cout &lt;&lt; message &lt;&lt; std::endl; }</span></span></span></span></code> </pre> <br>  Et l'application s'en servira pour afficher le message «Bonjour tout le monde!»: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "hello_world.hpp" int main(int argc, char** argv) { HelloWorld hello; hello.PrintMessage("Hello World!"); return 0; }</span></span></span></span></code> </pre> <br>  Nous utiliserons CMake pour construire le projet: <br><br><pre> <code class="cpp hljs">cmake_minimum_required(VERSION <span class="hljs-number"><span class="hljs-number">3.0</span></span>) project(HelloWorld) <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(CMAKE_CXX_STANDARD <span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(CMAKE_CXX_STANDARD_REQUIRED ON) add_library(HelloLibA hello_world.cpp) add_library(HelloLibB hello_world.cpp) add_executable(helloA main.cpp) add_executable(helloB main.cpp) target_link_libraries(helloA HelloLibA) target_link_libraries(helloB HelloLibB)</code> </pre> <br>  Nous allons créer deux bibliothèques différentes avec le même code source, ainsi que deux fichiers binaires avec les mêmes sources.  Générez le projet et exécutez <code>md5sum</code> pour voir les sommes de contrôle de tous les fichiers binaires: <br><br><pre> <code class="cpp hljs">mkdir build &amp;&amp; cd build cmake .. make md5sum helloA md5sum helloB md5sum CMakeFiles/HelloLibA.dir/hello_world.cpp.o md5sum CMakeFiles/HelloLibB.dir/hello_world.cpp.o md5sum libHelloLibA.a md5sum libHelloLibB.a</code> </pre> <br>  Nous obtenons une conclusion comme celle-ci: <br><br><pre> <code class="cpp hljs">b5dce09c593658ee348fd0f7fae22c94 helloA b5dce09c593658ee348fd0f7fae22c94 helloB <span class="hljs-number"><span class="hljs-number">0</span></span>a4a0de3df8cc7f053f2fcb6d8b75e6d CMakeFiles/HelloLibA.dir/hello_world.cpp.o <span class="hljs-number"><span class="hljs-number">0</span></span>a4a0de3df8cc7f053f2fcb6d8b75e6d CMakeFiles/HelloLibB.dir/hello_world.cpp.o adb80234a61bb66bdc5a3b4b7191eac7 libHelloLibA.a <span class="hljs-number"><span class="hljs-number">5</span></span>ac3c70d28d9fdd9c6571e077131545e libHelloLibB.a</code> </pre> <br>  Ceci est intéressant car les <code>helloB</code> <code>helloA</code> et <code>helloB</code> ont les mêmes sommes de contrôle, ainsi que les fichiers objets intermédiaires Mach-O <code>hello_world.cpp.o</code> , mais cela ne peut pas être dit pour les fichiers avec l'extension <code>.a</code> .  En effet, ils stockent des informations sur les fichiers d'objet intermédiaires dans un format d'archive.  L'en-tête de ce format comprend un champ appelé <code>st_time</code> défini par l'appel système <code>stat</code> .  Vérifiez <code>libHelloLibA.a</code> et <code>libHelloLibB.a</code> utilisant <code>otool</code> pour afficher les en-têtes: <br><br><pre> <code class="cpp hljs">&gt; otool -a libHelloLibA.a Archive : libHelloLibA.a <span class="hljs-number"><span class="hljs-number">0100644</span></span> <span class="hljs-number"><span class="hljs-number">503</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">612</span></span> <span class="hljs-number"><span class="hljs-number">1566927276</span></span> #<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">0100644</span></span> <span class="hljs-number"><span class="hljs-number">503</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">13036</span></span> <span class="hljs-number"><span class="hljs-number">1566927271</span></span> #<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">28</span></span> &gt; otool -a libHelloLibB.a Archive : libHelloLibB.a <span class="hljs-number"><span class="hljs-number">0100644</span></span> <span class="hljs-number"><span class="hljs-number">503</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">612</span></span> <span class="hljs-number"><span class="hljs-number">1566927277</span></span> #<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">0100644</span></span> <span class="hljs-number"><span class="hljs-number">503</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">13036</span></span> <span class="hljs-number"><span class="hljs-number">1566927272</span></span> #<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">28</span></span></code> </pre> <br>  Nous voyons que le fichier contient plusieurs champs temporaires qui rendent notre assemblage non déterministe.  Notez que ces champs ne s'appliquent pas au fichier exécutable final car ils ont la même somme de contrôle.  Ce problème peut également se produire lors de la génération sous Windows avec Visual Studio, mais avec un fichier PE au lieu de Mach-O. <br><br>  À ce stade, nous pouvons essayer d'aggraver les choses et de rendre nos binaires également non déterministes.  Modifiez le fichier <code>main.cpp</code> pour qu'il inclue la macro <code>__TIME__</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "hello_world.hpp" int main(int argc, char** argv) { HelloWorld hello; hello.PrintMessage("Hello World!"); std::cout &lt;&lt; "At time: " &lt;&lt; __TIME__ &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre> <br>  Vérifiez à nouveau les sommes de contrôle des fichiers: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">625</span></span>ecc7296e15d41e292f67b57b04f15 helloA <span class="hljs-number"><span class="hljs-number">20f</span></span>92d2771a7d2f9866c002de918c4da helloB <span class="hljs-number"><span class="hljs-number">0</span></span>a4a0de3df8cc7f053f2fcb6d8b75e6d CMakeFiles/HelloLibA.dir/hello_world.cpp.o <span class="hljs-number"><span class="hljs-number">0</span></span>a4a0de3df8cc7f053f2fcb6d8b75e6d CMakeFiles/HelloLibB.dir/hello_world.cpp.o b7801c60d3bc4f83640cadc1183f43b3 libHelloLibA.a <span class="hljs-number"><span class="hljs-number">4</span></span>ef6cae3657f2a13ed77830953b0aee8 libHelloLibB.a</code> </pre> <br>  Nous voyons que maintenant nous avons différents binaires.  Nous pourrions analyser l'exécutable avec un outil comme un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">diffoscope</a> , qui montre la différence entre deux fichiers binaires: <br><br><pre> <code class="cpp hljs">&gt; diffoscope helloA helloB --- helloA +++ helloB ├── otool -arch x86_64 -tdvV {} │┄ Code <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> architecture x86_64 │ @@ <span class="hljs-number"><span class="hljs-number">-16</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span> +<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span> @@ │ <span class="hljs-number"><span class="hljs-number">00000001000018</span></span>da jmp <span class="hljs-number"><span class="hljs-number">0x1000018df</span></span> │ <span class="hljs-number"><span class="hljs-number">00000001000018</span></span>df leaq <span class="hljs-number"><span class="hljs-number">-0x30</span></span>(%rbp), %rdi │ <span class="hljs-number"><span class="hljs-number">00000001000018e3</span></span> callq <span class="hljs-number"><span class="hljs-number">0x100002d54</span></span> #<span class="hljs-meta"><span class="hljs-meta"># symbol stub for: __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED1Ev │ 00000001000018e8 movq 0x1721(%rip), %rdi ## literal pool symbol address: __ZNSt3__14coutE │ 00000001000018ef leaq 0x162f(%rip), %rsi ## literal pool for: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"At time: "</span></span></span><span class="hljs-meta"> │ 00000001000018f6 callq 0x100002d8a ## symbol stub for: __ZNSt3__1lsINS_11char_traitsIcEEEERNS_13basic_ostreamIcT_EES6_PKc │ 00000001000018fb movq %rax, %rdi │ -00000001000018fe leaq 0x162a(%rip), %rsi ## literal pool for: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"19:40:47"</span></span></span><span class="hljs-meta"> │ +00000001000018fe leaq 0x162a(%rip), %rsi ## literal pool for: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"19:40:48"</span></span></span><span class="hljs-meta"> │ 0000000100001905 callq 0x100002d8a ## symbol stub for: __ZNSt3__1lsINS_11char_traitsIcEEEERNS_13basic_ostreamIcT_EES6_PKc │ 000000010000190a movq %rax, %rdi │ 000000010000190d leaq __ZNSt3__1L4endlIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_(%rip), %rsi #</span></span></code> </pre> <br>  Il montre que les informations <code>__TIME__</code> été collées dans le binaire, ce qui les rend non déterministes.  Voyons ce qui peut être fait pour éviter cela. <br><br><h4>  Solutions possibles pour Microsoft Visual Studio </h4><br>  Microsoft Visual Studio a un indicateur d'éditeur de liens / Brepro qui n'est pas documenté par Microsoft.  Cet indicateur définit les horodatages du format exécutable portable sur -1, comme illustré dans la figure ci-dessous. <br><br><img src="https://habrastorage.org/webt/oh/ds/ca/ohdsca2wvgdmv_j4zdfgbyc5xmq.png"><br><br>  Pour activer cet indicateur avec CMake, nous devons ajouter les lignes suivantes lors de la création du <code>.exe</code> : <br><br><pre> <code class="cpp hljs">add_link_options(<span class="hljs-string"><span class="hljs-string">"/Brepro"</span></span>)</code> </pre> <br>  ou ces lignes pour <code>.lib</code> <br><br><pre> <code class="cpp hljs">set_target_properties( TARGET PROPERTIES STATIC_LIBRARY_OPTIONS <span class="hljs-string"><span class="hljs-string">"/Brepro"</span></span> )</code> </pre> <br>  Le problème est que cet indicateur rend les binaires jouables (par rapport aux horodatages au format de fichier) dans notre fichier binaire final .exe, mais ne supprime pas tous les horodatages du .lib (le même problème qu'avec les fichiers objets Mach-O, dont nous avons parlé plus haut).  Le champ TimeDateStamp du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichier d'en-tête COFF</a> pour les fichiers <code>.lib</code> restera.  La seule façon de supprimer ces informations du fichier binaire <code>.lib</code> est de corriger le <code>.lib</code> en remplaçant les octets correspondant au champ TimeDateStamp par toute valeur connue. <br><br><h4>  Solutions possibles pour GCC et CLANG </h4><br><ul><li>  gcc détecte l'existence de la variable d'environnement SOURCE_DATE_EPOCH.  Si cette variable est définie, sa valeur indique l'horodatage UNIX qui sera utilisé pour remplacer la date et l'heure actuelles dans les macros <code>__DATE__</code> et <code>__TIME__</code> afin que les horodatages intégrés deviennent reproductibles.  La valeur peut être définie sur un horodatage connu, tel que l'heure de la dernière modification des fichiers source ou du package. </li><li>  clang utilise <code>ZERO_AR_DATE</code> , qui, s'il est défini, réinitialise l' <code>ZERO_AR_DATE</code> fourni dans les fichiers d'archive, en le définissant sur 0. Notez que cela ne <code>__DATE__</code> <code>__TIME__</code> <code>__DATE__</code> ou <code>__TIME__</code> .  Si nous voulons corriger l'effet de cette macro, nous devons soit corriger les binaires, soit simuler l'heure système. </li></ul><br>  Continuons avec notre exemple de projet pour MacOS et voyons quels seront les résultats lors de la <code>ZERO_AR_DATE</code> la <code>ZERO_AR_DATE</code> environnement <code>ZERO_AR_DATE</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> ZERO_AR_DATE=<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Maintenant, si nous compilons notre fichier exécutable et nos bibliothèques (en supprimant la macro <code>__DATE__</code> dans les sources), nous obtenons: <br><br><pre> <code class="cpp hljs">b5dce09c593658ee348fd0f7fae22c94 helloA b5dce09c593658ee348fd0f7fae22c94 helloB <span class="hljs-number"><span class="hljs-number">0</span></span>a4a0de3df8cc7f053f2fcb6d8b75e6d CMakeFiles/HelloLibA.dir/hello_world.cpp.o <span class="hljs-number"><span class="hljs-number">0</span></span>a4a0de3df8cc7f053f2fcb6d8b75e6d CMakeFiles/HelloLibB.dir/hello_world.cpp.o <span class="hljs-number"><span class="hljs-number">9f</span></span>9a9af4bb3e220e7a22fb58d708e1e5 libHelloLibA.a <span class="hljs-number"><span class="hljs-number">9f</span></span>9a9af4bb3e220e7a22fb58d708e1e5 libHelloLibB.a</code> </pre> <br>  Toutes les sommes de contrôle sont désormais identiques.  Analysons les en-têtes de fichiers avec l'extension <code>.a</code> : <br><br><pre> <code class="cpp hljs">&gt; otool -a libHelloLibA.a Archive : libHelloLibA.a <span class="hljs-number"><span class="hljs-number">0100644</span></span> <span class="hljs-number"><span class="hljs-number">503</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">612</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> #<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">0100644</span></span> <span class="hljs-number"><span class="hljs-number">503</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">13036</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> #<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">28</span></span> &gt; otool -a libHelloLibB.a Archive : libHelloLibB.a <span class="hljs-number"><span class="hljs-number">0100644</span></span> <span class="hljs-number"><span class="hljs-number">503</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">612</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> #<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">0100644</span></span> <span class="hljs-number"><span class="hljs-number">503</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">13036</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> #<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">28</span></span></code> </pre> <br>  Nous pouvons voir que le champ d' <code>timestamp</code> de l'en-tête de bibliothèque a été mis à zéro. <br><br>  <i>Nous sommes arrivés en douceur à la fin de la première partie de l'article.</i>  <i>La suite du matériel peut être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lue ici</a> .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467741/">https://habr.com/ru/post/fr467741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467729/index.html">Chips ou ride? Petites choses uniques dans les smartphones</a></li>
<li><a href="../fr467733/index.html">En tant que développeur, je ne connais jamais ma propre valeur, car il n'y en a pas. Mais tout le système est construit comme s'il était</a></li>
<li><a href="../fr467735/index.html">Défis posés par les adultes</a></li>
<li><a href="../fr467737/index.html">Applications Bot VS: avantages et inconvénients. Cas du bot comptable</a></li>
<li><a href="../fr467739/index.html">Une entreprise sans technologie. L'argent qui t'a perdu</a></li>
<li><a href="../fr467743/index.html">SamsPcbGuide, partie 11: Technologie - Boîtiers de type BGA, plastique et espace</a></li>
<li><a href="../fr467745/index.html">Cluster mieux que la «méthode du coude»</a></li>
<li><a href="../fr467747/index.html">Test psychologique: comment passer d'un psychologue certifié à un testeur</a></li>
<li><a href="../fr467749/index.html">GCP: analyse de la pile informatique de Google Cloud Platform</a></li>
<li><a href="../fr467751/index.html">Comment fonctionne un messager décentralisé sur la blockchain</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>