<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦗 🎍 👇🏻 Troisième test Qt 5 avec PVS-Studio 🧝🏿 🐾 😝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De temps en temps, notre équipe revérifie les projets sur lesquels nous avons déjà écrit des articles. Un autre projet revérifié était Qt. La dernière...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Troisième test Qt 5 avec PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/426485/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd9/87d/907/dd987d90784865f850555bc198a97b81.png" alt="PVS-Studio &amp; Qt"></div><br>  De temps en temps, notre équipe revérifie les projets sur lesquels nous avons déjà écrit des articles.  Un autre projet revérifié était Qt.  La dernière fois que nous l'avons testé avec PVS-Studio en 2014.  Depuis 2014, le projet a commencé à être régulièrement contrôlé avec l'aide de Coverity.  C'est intéressant.  Voyons si nous pouvons maintenant trouver des erreurs intéressantes en utilisant PVS-Studio. <br><a name="habracut"></a><br><h2>  Qt </h2><br>  Articles précédents: <br><br><ul><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment réduire la probabilité d'erreurs au stade de l'écriture du code</a> », juillet 2011. </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qt 5 framework check</a> », avril 2014. </li></ul><br>  Cette fois, <a href="">Qt Base</a> (Core, Gui, Widgets, Network, ...) et le <a href="">super module Qt5 ont été testés</a> .  À propos de Qt Creator, nous prévoyons d'écrire un article séparé plus tard.  Pour vérification, nous avons utilisé l'analyseur statique PVS-Studio, dont vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">télécharger</a> une version d'essai sur le site. <br><br>  À mon avis, le code Qt est devenu meilleur.  Au fil des ans depuis le dernier test, de nombreux nouveaux diagnostics sont apparus dans l'analyseur PVS-Studio.  Malgré cela, lors de l'examen des avertissements, je n'ai pas trouvé autant d'erreurs pour un projet de cette taille.  Je répète encore une fois que c'est mon impression individuelle.  Je n'ai pas fait de recherche spéciale sur la densité des erreurs à ce moment-là ou maintenant. <br><br>  Très probablement, des vérifications régulières à l'aide de l'analyseur statique Coverity ont très probablement affecté la qualité du code.  En 2014, avec l'aide de Coverity, le projet Qt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qt-project</a> ) a commencé à être vérifié, et en 2016, le Qt Creator ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qt-creator</a> ).  Mon avis: si vous développez un projet ouvert, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Coverity Scan</a> peut être une bonne solution gratuite qui améliorera considérablement la qualité et la fiabilité de vos projets. <br><br>  Cependant, comme le lecteur peut le deviner, si je n'avais rien remarqué d'intéressant dans le rapport PVS-Studio, il n'y aurait pas eu d'article :).  Et puisqu'il y a un article, c'est-à-dire des défauts.  Regardons-les.  Au total, j'ai écrit 96 erreurs. <br><br><h2>  Copier-coller et Typos infructueux </h2><br>  Commençons par les classiques du genre, lorsque la cause de l'erreur est l'inattention.  Ces erreurs sont sous-estimées par les programmeurs.  Pour ceux qui ne l'ont pas encore lu, je vous recommande de lire ces deux articles: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Effet de dernière ligne</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le mal vit dans les fonctions de comparaison</a> </li></ul><br>  Ces erreurs sont interlangues.  Par exemple, le deuxième article donne de nombreux exemples d'erreurs dans les fonctions de comparaison écrites en C, C ++ et C #.  Maintenant, lors de l'implémentation de la prise en charge du langage Java dans PVS-Studio, nous rencontrons les mêmes modèles d'erreur.  Voici, par exemple, un bug que nous avons récemment trouvé dans la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hibernate</a> : <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other instanceof Id) { Id that = (Id) other; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> purchaseSequence.equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseSequence) &amp;&amp; that.purchaseNumber == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseNumber; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Si vous regardez attentivement, il s'avère que le champ <i>PurchaseSequence</i> est comparé à lui-même.  L'option correcte: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> that.purchaseSequence.equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseSequence) &amp;&amp; that.purchaseNumber == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseNumber;</code> </pre> <br>  En général, tout est comme toujours, et l'analyseur PVS-Studio devra "ratisser les écuries Augean" dans les projets Java.  Soit dit en passant, nous invitons tout le monde à prendre part aux tests de la version bêta de PVS-Studio pour Java, qui devrait apparaître prochainement.  Pour ce faire, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">écrivez-nous</a> (sélectionnez "Je veux l'analyseur pour Java"). <br><br>  Revenons maintenant aux erreurs du projet Qt. <br><br>  <b>Défaut N1</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">windowDpiAwareness</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND hwnd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QWindowsContext::user32dll.getWindowDpiAwarenessContext &amp;&amp; QWindowsContext::user32dll.getWindowDpiAwarenessContext ? QWindowsContext::user32dll.getAwarenessFromDpiAwarenessContext( QWindowsContext::user32dll.getWindowDpiAwarenessContext(hwnd)) : <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br>  Avertissement PVS-Studio: V501 CWE-571 Il existe des sous-expressions identiques «QWindowsContext :: user32dll.getWindowDpiAwarenessContext» à gauche et à droite de l'opérateur «&amp;&amp;».  qwindowscontext.cpp 150 <br><br>  Aucune explication particulière en plus du message de l'analyseur n'est requise ici.  Il me semble que l'expression aurait dû être comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QWindowsContext::user32dll.getAwarenessFromDpiAwarenessContext &amp;&amp; QWindowsContext::user32dll.getWindowDpiAwarenessContext ? QWindowsContext::user32dll.getAwarenessFromDpiAwarenessContext( QWindowsContext::user32dll.getWindowDpiAwarenessContext(hwnd)) : <span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre> <br>  <b>Défaut N2, N3</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QReadWriteLockPrivate::release() { Q_ASSERT(!recursive); Q_ASSERT(!waitingReaders &amp;&amp; !waitingReaders &amp;&amp; !readerCount &amp;&amp; !writerCount); freelist-&gt;release(id); }</code> </pre> <br>  Avertissement PVS-Studio: V501 CWE-571 Il existe des sous-expressions identiques à gauche et à droite de l'opérateur '&amp;&amp;':! WaitingReaders &amp;&amp;! WaitingReaders qreadwritelock.cpp 632 <br><br>  L'erreur se trouve dans la <i>condition de</i> macro <i>Q_ASSERT</i> , elle n'est donc pas significative.  Mais encore, c'est une erreur.  La variable <i>waitReaders</i> est vérifiée deux fois.  Et apparemment, ils ont oublié de vérifier une autre variable. <br><br>  Une erreur identique se trouve dans la ligne 625 du fichier qreadwritelock.cpp.  Vive le copier-coller!  :) <br><br>  <b>Défaut N4</b> <br><br><pre> <code class="cpp hljs">QString QGraphicsSceneBspTree::debug(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;type == Node::Horizontal) { tmp += debug(firstChildIndex(index)); tmp += debug(firstChildIndex(index) + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tmp += debug(firstChildIndex(index)); tmp += debug(firstChildIndex(index) + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  PVS-Studio Warning: V523 CWE-691 L'instruction 'then' est équivalente à l'instruction 'else'.  qgraphicsscene_bsp.cpp 179 <br><br>  Très probablement, le bloc de texte a été copié, mais ils ont oublié de le corriger. <br><br>  <b>Défaut N5</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> FillRule { OddEvenFill, WindingFill }; QDataStream &amp;<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;&gt;(QDataStream &amp;s, QPainterPath &amp;p) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fillRule; s &gt;&gt; fillRule; Q_ASSERT(fillRule == Qt::OddEvenFill || Qt::WindingFill); .... }</code> </pre> <br>  Avertissement PVS-Studio: V768 CWE-571 La constante d'énumération 'WindingFill' est utilisée comme variable de type booléen.  qpainterpath.cpp 2479 <br><br>  D'accord, c'est un beau bêtisier!  <i>Q_ASSERT</i> ne vérifie rien, car la condition est toujours vraie.  La condition est vraie car la constante nommée <i>Qt :: WindingFill</i> est 1. <br><br>  <b>Défaut N6</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QVariant::canConvert(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetTypeId) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == QMetaType::SChar || currentType == QMetaType::Char) currentType = QMetaType::UInt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targetTypeId == QMetaType::SChar || currentType == QMetaType::Char) targetTypeId = QMetaType::UInt; .... }</code> </pre> <br>  Avant de lire l'avertissement, essayez de repérer une faute de frappe vous-même.  En ajoutant une image, je vous aiderai à ne pas lire immédiatement le message de l'analyseur :). <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86f/f1d/7c5/86ff1d7c55cdc0fb71cbce45f2f84f05.png" alt="Il est temps de réfléchir"></div><br><br>  Avertissement PVS-Studio: V560 CWE-570 Une partie de l'expression conditionnelle est toujours fausse: currentType == QMetaType :: Char.  qvariant.cpp 3529 <br><br>  La condition "currentType == QMetaType :: Char" est vérifiée dans le premier <i>if</i> .  Si la condition est remplie, la variable <i>currentType</i> reçoit la valeur <i>QMetaType :: UInt</i> .  Par conséquent, la variable <i>currentType</i> ne peut plus être égale à <i>QMetaType :: Char</i> .  Par conséquent, l'analyseur signale que dans le second <i>if, la</i> sous <i>-</i> expression "currentType == QMetaType :: Char" est toujours fausse. <br><br>  En fait, le deuxième <i>if</i> devrait être comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targetTypeId == QMetaType::SChar || targetTypeId == QMetaType::Char) targetTypeId = QMetaType::UInt;</code> </pre> <br><br>  <b>Note de diagnostic V560</b> <br><br>  Le rapport a trouvé de nombreux avertissements V560.  Cependant, je ne les ai plus regardés dès que j'ai trouvé un cas intéressant pour l'article, qui était considéré ci-dessus comme un défaut N6. <br><br>  La grande majorité des messages V560 ne peuvent pas être appelés faux, mais ils ne servent à rien.  En d'autres termes, les décrire dans un article n'est pas intéressant.  Pour bien comprendre ce que je veux dire exactement, considérons un de ces cas. <br><br><pre> <code class="cpp hljs">QString QTextHtmlExporter::findUrlForImage(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QTextDocument *doc, ....) { QString url; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!doc) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> url; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (QTextDocument *parent = qobject_cast&lt;QTextDocument *&gt;(doc-&gt;parent())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> findUrlForImage(parent, cacheKey, isPixmap); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doc &amp;&amp; doc-&gt;docHandle()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Avertissement PVS-Stuidio: V560 CWE-571 Une partie de l'expression conditionnelle est toujours vraie: doc.  qtextdocument.cpp 2992 <br><br>  L'analyseur est absolument correct que le pointeur de <i>doc</i> n'est pas toujours <i>nullptr</i> quand il est revérifié.  Mais ce n'est pas une erreur, juste le programmeur était en sécurité.  Vous pouvez simplifier le code en écrivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doc-&gt;docHandle()) {</code> </pre> <br>  <b>Défaut N7</b> <br><br>  Et le dernier cas, qui peut être classé comme une faute de frappe.  L'erreur se produit en raison d'une confusion dans les noms des constantes, qui ne diffèrent que dans le cas de la première lettre. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QWindowsCursor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QPlatformCursor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CursorState { CursorShowing, CursorHidden, CursorSuppressed }; .... } QWindowsCursor::CursorState QWindowsCursor::cursorState() { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { cursorShowing = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, cursorSuppressed = <span class="hljs-number"><span class="hljs-number">0x2</span></span> }; CURSORINFO cursorInfo; cursorInfo.cbSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(CURSORINFO); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetCursorInfo(&amp;cursorInfo)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cursorInfo.flags &amp; CursorShowing) .... }</code> </pre> <br>  Avertissement PVS-Studio: V616 CWE-480 La constante nommée 'CursorShowing' avec la valeur 0 est utilisée dans l'opération au niveau du bit.  qwindowscursor.cpp 669 <br><br>  Plus en détail, j'ai déjà analysé cette erreur dans une petite note séparée: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Encore une fois, l'analyseur PVS-Studio s'est avéré être plus attentif</a> qu'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">personne</a> ." <br><br><h2>  Failles de sécurité </h2><br>  En fait, toutes les erreurs discutées dans cet article peuvent être appelées défauts de sécurité.  Tous sont classés selon l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">énumération commune des faiblesses</a> (voir CWE ID dans les messages de l'analyseur).  Si les erreurs sont classées comme CWE, elles constituent potentiellement un risque pour la sécurité.  Ceci est expliqué plus en détail sur la page <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PVS-Studio SAST</a> . <br><br>  Cependant, je voudrais signaler un certain nombre d'erreurs dans un groupe distinct.  Jetons-y un œil. <br><br>  <b>Défaut N8, N9</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QLocalServerPrivate::addListener() { .... SetSecurityDescriptorOwner(pSD.data(), pTokenUser-&gt;User.Sid, FALSE); SetSecurityDescriptorGroup(pSD.data(), pTokenGroup-&gt;PrimaryGroup, FALSE); .... }</code> </pre> <br>  Avertissements de PVS-Studio: <br><br><ul><li>  V530 CWE-252 La valeur de retour de la fonction 'SetSecurityDescriptorOwner' doit être utilisée.  qlocalserver_win.cpp 167 </li><li>  V530 CWE-252 La valeur de retour de la fonction 'SetSecurityDescriptorGroup' doit être utilisée.  qlocalserver_win.cpp 168 </li></ul><br>  Il existe différentes fonctions liées au contrôle d'accès.  Les fonctions <i>SetSecurityDescriptorOwner</i> et <i>SetSecurityDescriptorGroup en</i> font partie. <br><br>  Avec de telles fonctions, vous devez travailler très soigneusement.  Par exemple, vous devez vérifier le statut qu'ils renvoient.  Que se passe-t-il si l'appel à ces fonctions échoue?  Deviner n'est pas nécessaire, il est nécessaire d'écrire du code pour gérer un tel cas. <br><br>  Il n'est pas nécessaire de tirer parti du manque de vérification et de transformer ces erreurs en vulnérabilités.  Cependant, ce n'est en aucun cas un lieu de risque, et vous devez écrire du code plus sécurisé. <br><br>  <b>Défaut N10</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QLocalServerPrivate::addListener() { .... InitializeAcl(acl, aclSize, ACL_REVISION_DS); .... }</code> </pre> <br>  PVS-Studio Warning: V530 CWE-252 La valeur de retour de la fonction 'InitializeAcl' doit être utilisée.  qlocalserver_win.cpp 144 <br><br>  La situation est similaire à celle évoquée ci-dessus. <br><br>  <b>Défaut N11, N12</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha1ProcessChunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... quint8 chunkBuffer[<span class="hljs-number"><span class="hljs-number">64</span></span>]; .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SHA1_WIPE_VARIABLES .... memset(chunkBuffer, 0, 64); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br>  Avertissement PVS-Studio: V597 CWE-14 Le compilateur peut supprimer l'appel de fonction 'memset', qui est utilisé pour vider le tampon 'chunkBuffer'.  La fonction RtlSecureZeroMemory () doit être utilisée pour effacer les données privées.  sha1.cpp 189 <br><br>  Le compilateur supprimera l'appel de fonction <i>memset</i> .  Déjà plusieurs fois dans des articles, j'ai analysé cette situation.  Je n'ai pas envie de me répéter.  Je me réfère à l'article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nettoyage sécurisé des données privées</a> ". <br><br>  Et une autre erreur se trouve dans le même fichier sha1.cpp, à la ligne 247. <br><br><h2>  Pointeurs nuls </h2><br>  Il est temps de parler de pointeurs.  Il y a eu beaucoup d'erreurs sur ce sujet. <br><br>  <b>Défaut N13</b> <br><br><pre> <code class="cpp hljs">QByteArray &amp;QByteArray::append(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) len = qstrlen(str); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str &amp;&amp; len) { .... }</code> </pre> <br>  Avertissement PVS-Studio: V595 CWE-476 Le pointeur 'str' a été utilisé avant d'être vérifié par rapport à nullptr.  Vérifiez les lignes: 2118, 2119. qbytearray.cpp 2118 <br><br>  La situation classique est lorsqu'un pointeur est utilisé au début, puis vérifié l'égalité <i>nullptr</i> .  Il s'agit d'un modèle d'erreur très courant, et nous le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">constatons</a> régulièrement dans presque tous les projets. <br><br>  <b>Défaut N14, N15</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> QMetaObjectPrivate *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">priv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint* data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QMetaObjectPrivate*&gt;(data); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QMetaEnum::isFlag() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = priv(mobj-&gt;d.data)-&gt;revision &gt;= <span class="hljs-number"><span class="hljs-number">8</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mobj &amp;&amp; mobj-&gt;d.data[handle + offset] &amp; EnumIsFlag; }</code> </pre> <br>  Avertissement PVS-Studio: V595 CWE-476 Le pointeur 'mobj' a été utilisé avant d'être vérifié par rapport à nullptr.  Vérifiez les lignes: 2671, 2672. qmetaobject.cpp 2671 <br><br>  Au cas où, j'apporte le corps de la fonction <i>privée</i> .  Pour une raison quelconque, les lecteurs commencent parfois à trouver des situations dans lesquelles le code fonctionnera.  Je ne comprends pas d'où vient cette méfiance et le désir de voir une fonctionnalité délicate par erreur :).  Par exemple, quelqu'un peut suggérer dans les commentaires que <i>priv</i> est une macro du formulaire: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> priv(A) foo(sizeof(A))</span></span></code> </pre> <br>  Ensuite, tout fonctionnera. <br><br>  Afin d'éviter de telles discussions, j'essaie de citer des fragments de code où toutes les informations confirmant l'existence d'une erreur sont fournies. <br><br>  Ainsi, le pointeur <i>modj est</i> déréférencé puis vérifié. <br><br>  Plus loin sur la scène vient le copier-coller «puissant et terrible».  En raison de la détection exacte de la même erreur dans la fonction <i>isScoped</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QMetaEnum::isScoped() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = priv(mobj-&gt;d.data)-&gt;revision &gt;= <span class="hljs-number"><span class="hljs-number">8</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mobj &amp;&amp; mobj-&gt;d.data[handle + offset] &amp; EnumIsScoped; }</code> </pre> <br>  Avertissement PVS-Studio: V595 CWE-476 Le pointeur 'mobj' a été utilisé avant d'être vérifié par rapport à nullptr.  Vérifiez les lignes: 2683, 2684. qmetaobject.cpp 2683 <br><br>  <b>Défaut N16-N21</b> <br><br>  Prenons un autre exemple et, je pense, assez. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QTextCursor::insertFragment(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QTextDocumentFragment &amp;fragment) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!d || !d-&gt;priv || fragment.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; d-&gt;priv-&gt;beginEditBlock(); d-&gt;remove(); fragment.d-&gt;insert(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); d-&gt;priv-&gt;endEditBlock(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fragment.d &amp;&amp; fragment.d-&gt;doc) d-&gt;priv-&gt;mergeCachedResources(fragment.d-&gt;doc-&gt;docHandle()); }</code> </pre> <br>  Avertissement PVS-Studio: V595 CWE-476 Le pointeur 'fragment.d' a été utilisé avant d'être vérifié par rapport à nullptr.  Vérifiez les lignes: 2238, 2241. qtextcursor.cpp 2238 <br><br>  Tout de même.  Faites attention à la séquence de travail avec le pointeur stocké dans la variable <i>fragment.d</i> . <br><br>  Autres erreurs de ce type: <br><br><ul><li>  V595 CWE-476 Le pointeur "fenêtre" a été utilisé avant d'être vérifié par rapport à nullptr.  Vérifiez les lignes: 1846, 1848. qapplication.cpp 1846 </li><li>  V595 CWE-476 Le pointeur "fenêtre" a été utilisé avant d'être vérifié par rapport à nullptr.  Vérifiez les lignes: 1858, 1860. qapplication.cpp 1858 </li><li>  V595 CWE-476 Le pointeur de «réponse» a été utilisé avant d'être vérifié par rapport à nullptr.  Vérifiez les lignes: 492, 502. qhttpnetworkconnectionchannel.cpp 492 </li><li>  V595 CWE-476 Le pointeur 'newHandle' a été utilisé avant d'être vérifié par rapport à nullptr.  Vérifiez les lignes: 877, 883. qsplitter.cpp 877 </li><li>  V595 CWE-476 Le pointeur "widget" a été utilisé avant d'être vérifié par rapport à nullptr.  Vérifiez les lignes: 2320, 2322. qwindowsvistastyle.cpp 2320 </li><li>  En fait, il y a plus d'erreurs.  Je me suis rapidement fatigué d'apprendre les avertissements de la V595, et pour l'article, j'ai déjà écrit suffisamment de fragments de code. </li></ul><br>  <b>Défaut N22-N33</b> <br><br>  Il y a du code où un pointeur est vérifié que le <i>nouvel</i> opérateur retourne.  C'est particulièrement drôle au milieu du fait qu'il y a beaucoup d'endroits où le résultat de la fonction <i>malloc</i> n'est pas vérifié (voir le groupe d'erreurs suivant). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QTranslatorPrivate::do_load(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;realname, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;directory) { .... d-&gt;unmapPointer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[d-&gt;unmapLength]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d-&gt;unmapPointer) { file.seek(<span class="hljs-number"><span class="hljs-number">0</span></span>); qint64 readResult = file.read(d-&gt;unmapPointer, d-&gt;unmapLength); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readResult == qint64(unmapLength)) ok = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } .... }</code> </pre> <br>  PVS-Studio Warning: V668 CWE-571 Il est inutile de tester le pointeur 'd-&gt; unmap Pointer' contre null, car la mémoire a été allouée à l'aide de l'opérateur 'new'.  L'exception sera générée en cas d'erreur d'allocation de mémoire.  qtranslator.cpp 596 <br><br>  Vérifier le pointeur n'a pas de sens, car en cas d'erreur d'allocation de mémoire, une exception <i>std :: bad_alloc</i> sera <i>levée</i> .  Si vous voulez que le <i>nouvel</i> opérateur retourne <i>nullptr</i> quand il n'y a pas assez de mémoire, alors vous devez écrire: <br><br><pre> <code class="cpp hljs">d-&gt;unmapPointer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nothrow) <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[d-&gt;unmapLength];</code> </pre> <br>  L'analyseur connaît cette utilisation du <i>nouvel</i> opérateur et ne donnerait pas d'avertissement dans ce cas. <br><br>  Autres erreurs: je leur donnerai le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichier qt-V668.txt</a> . <br><br>  <b>Défaut N34-N70</b> <br><br>  Comme promis, c'est maintenant le tour des erreurs quand ils ne vérifient pas le résultat de l'appel des fonctions <i>malloc</i> , <i>calloc</i> , <i>strdup</i> , etc.  Ces erreurs sont plus graves qu'il n'y paraît à première vue.  Plus de détails: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pourquoi est-il important de vérifier ce que la fonction malloc a renvoyé</a> ." <br><br><pre> <code class="cpp hljs">SourceFiles::SourceFiles() { nodes = (SourceFileNode**)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SourceFileNode*)*(num_nodes=<span class="hljs-number"><span class="hljs-number">3037</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; num_nodes; n++) nodes[n] = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }</code> </pre> <br>  Avertissement PVS-Studio: V522 CWE-690 Il peut y avoir un déréférencement d'un "noeud" de pointeur nul potentiel.  Vérifiez les lignes: 138, 136. makefiledeps.cpp 138 <br><br>  Le pointeur est utilisé sans vérification préalable. <br><br>  Toutes ces erreurs sont du même type, je ne m'étendrai donc pas sur elles plus en détail.  Je donnerai le reste de la liste d'avertissement: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qt-V522-V575.txt</a> . <br><br><h2>  Erreurs logiques dans les conditions </h2><br>  <b>Défaut N71</b> <br><br><pre> <code class="cpp hljs">QString QEdidParser::parseEdidString(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quint8 *data) { <span class="hljs-function"><span class="hljs-function">QByteArray </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">reinterpret_cast</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *&gt;(data), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">13</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Erase carriage return and line feed buffer = buffer.replace('\r', '\0').replace('\n', '\0'); // Replace non-printable characters with dash for (int i = 0; i &lt; buffer.count(); ++i) { if (buffer[i] &lt; '\040' &amp;&amp; buffer[i] &gt; '\176') buffer[i] = '-'; } return QString::fromLatin1(buffer.trimmed()); }</span></span></code> </pre> <br>  Avertissement PVS-Studio: V547 CWE-570 Expression 'buffer [i] &lt;' \ 040 '&amp;&amp; buffer [i]&gt;' \ 176 '' est toujours false.  qedidparser.cpp 169 <br><br>  La fonction doit effectuer l'action suivante «Remplacer les caractères non imprimables par un tiret».  Mais ce n'est pas le cas.  Examinons de plus près cette condition: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[i] &lt; <span class="hljs-string"><span class="hljs-string">'\040'</span></span> &amp;&amp; buffer[i] &gt; <span class="hljs-string"><span class="hljs-string">'\176'</span></span>)</code> </pre> <br>  Cela n'a aucun sens.  Un caractère ne peut pas être inférieur à '\ 040' et supérieur à '\ 176' en même temps.  Dans la condition, vous devez utiliser l'opérateur '||'.  Le bon code est: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[i] &lt; <span class="hljs-string"><span class="hljs-string">'\040'</span></span> || buffer[i] &gt; <span class="hljs-string"><span class="hljs-string">'\176'</span></span>)</code> </pre> <br>  <b>Défaut N72</b> <br><br>  Une erreur similaire, à cause de laquelle les utilisateurs de Windows n'ont pas de chance. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(Q_OS_WIN) static QString driveSpec(const QString &amp;path) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (path.size() </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 2) return QString(); char c = path.at(0).toLatin1(); if (c &lt; 'a' &amp;&amp; c &gt; 'z' &amp;&amp; c &lt; 'A' &amp;&amp; c &gt; 'Z') return QString(); if (path.at(1).toLatin1() != ':') return QString(); return path.mid(0, 2); } #endif</span></span></span></span></code> </pre> <br>  L'analyseur génère deux avertissements à la fois: <br><br><ul><li>  V590 CWE-571 Envisagez d'inspecter l'expression 'c &lt;' a '&amp;&amp; c&gt;' z '&amp;&amp; c &lt;' A '&amp;&amp; c&gt;' Z ''.  L'expression est excessive ou contient une erreur d'impression.  qdir.cpp 77 </li><li>  V560 CWE-570 Une partie de l'expression conditionnelle est toujours fausse: c&gt; 'z'.  qdir.cpp 77 </li></ul><br>  Une erreur logique est dans la condition: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &lt; <span class="hljs-string"><span class="hljs-string">'a'</span></span> &amp;&amp; c &gt; <span class="hljs-string"><span class="hljs-string">'z'</span></span> &amp;&amp; c &lt; <span class="hljs-string"><span class="hljs-string">'A'</span></span> &amp;&amp; c &gt; <span class="hljs-string"><span class="hljs-string">'Z'</span></span>)</code> </pre> <br>  Si je comprends bien, le programmeur voulait trouver un caractère qui n'est pas une lettre de l'alphabet latin.  Dans ce cas, la condition doit être la suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((c &lt; <span class="hljs-string"><span class="hljs-string">'a'</span></span> || c &gt; <span class="hljs-string"><span class="hljs-string">'z'</span></span>) &amp;&amp; (c &lt; <span class="hljs-string"><span class="hljs-string">'A'</span></span> || c &gt; <span class="hljs-string"><span class="hljs-string">'Z'</span></span>))</code> </pre> <br>  <b>Défaut N73</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> SelectionMode { NoSelection, SingleSelection, MultiSelection, ExtendedSelection, ContiguousSelection }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QAccessibleTableCell::unselectCell() { QAbstractItemView::SelectionMode selectionMode = view-&gt;selectionMode(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_index.isValid() || (selectionMode &amp; QAbstractItemView::NoSelection)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; .... }</code> </pre> <br>  Avertissement PVS-Studio: V616 CWE-480 La constante nommée 'QAbstractItemView :: NoSelection' avec la valeur 0 est utilisée dans l'opération au niveau du bit.  itemviews.cpp 976 <br><br>  La constante nommée <i>QAbstractItemView :: NoSelection</i> est nulle.  Par conséquent, la sous-expression <i>(selectionMode &amp; QAbstractItemView :: NoSelection)</i> n'a pas de sens.  Ce sera toujours 0. <br><br>  Je pense que cela devrait être écrit ici: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_index.isValid() || (selectionMode == QAbstractItemView::NoSelection))</code> </pre> <br>  <b>Défaut N74</b> <br><br>  Le code suivant est difficile à comprendre pour moi.  Il a tort, mais je ne sais pas ce qu'il devrait être.  Commenter une fonction ne m'aide pas non plus. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Re-engineered from the inline function _com_error::ErrorMessage(). // We cannot use it directly since it uses swprintf_s(), which is not // present in the MSVCRT.DLL found on Windows XP (QTBUG-35617). static inline QString errorMessageFromComError(const _com_error &amp;comError) { TCHAR *message = nullptr; FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, DWORD(comError.Error()), MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT), message, 0, NULL); if (message) { const QString result = QString::fromWCharArray(message).trimmed(); LocalFree(static_cast&lt;HLOCAL&gt;(message)); return result; } if (const WORD wCode = comError.WCode()) return QString::asprintf("IDispatch error #%u", uint(wCode)); return QString::asprintf("Unknown error 0x0%x", uint(comError.Error())); }</span></span></code> </pre> <br>  PVS-Studio Warning: V547 CWE-570 Expression 'message' is always false.  qwindowscontext.cpp 802 <br><br>  Le programmeur suppose probablement que la fonction <i>FormatMessage</i> modifiera la valeur du pointeur de <i>message</i> .  Mais ce n'est pas le cas.  La <i>fonction FormatMessage ne</i> peut pas modifier la valeur d'un pointeur, car elle est transmise à la fonction par valeur.  Voici un prototype de cette fonction: <br><br><pre> <code class="cpp hljs">DWORD __<span class="hljs-function"><span class="hljs-function">stdcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormatMessageW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments )</span></span></span></span>;</code> </pre> <br><br><h2>  Fuites potentielles de mémoire </h2><br>  <b>Défaut N75-N92</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SourceDependChildren</span></span></span><span class="hljs-class"> {</span></span> SourceFile **children; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num_nodes, used_nodes; SourceDependChildren() : children(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>), num_nodes(<span class="hljs-number"><span class="hljs-number">0</span></span>), used_nodes(<span class="hljs-number"><span class="hljs-number">0</span></span>) { } ~SourceDependChildren() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (children) <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(children); children = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SourceFile *s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num_nodes &lt;= used_nodes) { num_nodes += <span class="hljs-number"><span class="hljs-number">200</span></span>; children = (SourceFile**)<span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(children, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SourceFile*)*(num_nodes)); } children[used_nodes++] = s; } };</code> </pre> <br>  Avertissement PVS-Studio: V701 CWE-401 possible fuite de realloc (): lorsque realloc () échoue dans l'allocation de mémoire, le pointeur d'origine «enfants» est perdu.  Pensez à affecter realloc () à un pointeur temporaire.  makefiledeps.cpp 103 <br><br>  L'expansion du tampon est implémentée de manière dangereuse.  Si la fonction <i>realloc</i> ne peut pas allouer de mémoire, elle renverra <i>NULL</i> .  Ce <i>NULL</i> sera immédiatement placé dans la variable <i>enfants</i> et il n'y aura aucune possibilité de libérer le tampon alloué plus tôt.  Une fuite de mémoire se produira. <br><br>  Erreurs similaires: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qt-701.txt</a> . <br><br><h2>  Divers </h2><br>  <b>Défaut N93</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GradientBase</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlendType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inline</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlendType</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QT_FASTCALL</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">qt_fetch_linear_gradient_template</span></span></span><span class="hljs-class">(....) {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t+inc*length &lt; qreal(INT_MAX &gt;&gt; (FIXPT_BITS + <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp;&amp; t+inc*length &gt; qreal(INT_MIN &gt;&gt; (FIXPT_BITS + <span class="hljs-number"><span class="hljs-number">1</span></span>))) { .... }</code> </pre> <br>  Avertissement PVS-Studio: V610 CWE-758 Comportement non spécifié.  Vérifiez l'opérateur de décalage '&gt;&gt;'.  L'opérande gauche «(- 2147483647 - 1)» est négatif.  qdrawhelper.cpp 4015 <br><br>  La valeur négative de <i>INT_MIN</i> ne peut pas être décalée.  Il s'agit d'un comportement non spécifié et vous ne pouvez pas vous fier au résultat d'une telle opération.  Les bits les plus significatifs peuvent être égaux à 0 ou 1. <br><br>  <b>Défaut N94</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QObjectPrivate::addConnection(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> signal, Connection *c) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (signal &gt;= connectionLists-&gt;count()) connectionLists-&gt;resize(signal + <span class="hljs-number"><span class="hljs-number">1</span></span>); ConnectionList &amp;connectionList = (*connectionLists)[signal]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (signal &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... }</code> </pre> <br>  PVS-Studio Warning: V781 CWE-129 La valeur de la variable 'signal' est vérifiée après son utilisation.  Il y a peut-être une erreur dans la logique du programme.  Vérifiez les lignes: 397, 413. qobject.cpp 397 <br><br>  Une vérification <i>(signal &lt;0)</i> indique que la valeur de l'argument <i>signal</i> peut être négative.  Cependant, cet argument était précédemment utilisé pour indexer le tableau.  Il s'avère que la vérification est effectuée trop tard.  Le programme sera déjà interrompu. <br><br>  <b>Défaut N95</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QXmlStreamWriterPrivate::finishStartElement(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> contents) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inEmptyElement) { write(<span class="hljs-string"><span class="hljs-string">"/&gt;"</span></span>); QXmlStreamWriterPrivate::Tag &amp;tag = tagStack_pop(); lastNamespaceDeclaration = tag.namespaceDeclarationsSize; lastWasStartElement = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { write(<span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>); } inStartElement = inEmptyElement = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; lastNamespaceDeclaration = namespaceDeclarations.size(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hadSomethingWritten; }</code> </pre> <br>  Avertissement PVS-Studio: V519 CWE-563 La variable 'lastNamespaceDeclaration' reçoit des valeurs successives deux fois.  C'est peut-être une erreur.  Vérifiez les lignes: 3188, 3194. qxmlstream.cpp 3194 <br><br>  Je vais souligner l'essence de l'erreur: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inEmptyElement) { lastNamespaceDeclaration = tag.namespaceDeclarationsSize; } lastNamespaceDeclaration = namespaceDeclarations.size();</code> </pre> <br>  <b>Défaut N96</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QRollEffect::scroll() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentHeight != totalHeight) { currentHeight = totalHeight * (elapsed/duration) + (<span class="hljs-number"><span class="hljs-number">2</span></span> * totalHeight * (elapsed%duration) + duration) / (<span class="hljs-number"><span class="hljs-number">2</span></span> * duration); <span class="hljs-comment"><span class="hljs-comment">// equiv. to int((totalHeight*elapsed) / duration + 0.5) done = (currentHeight &gt;= totalHeight); } done = (currentHeight &gt;= totalHeight) &amp;&amp; (currentWidth &gt;= totalWidth); .... }</span></span></code> </pre> <br>  V519 CWE-563 La variable 'done' reçoit des valeurs successives deux fois.  C'est peut-être une erreur.  Vérifiez les lignes: 509, 511. qeffects.cpp 511 <br><br>  Tout est le même que dans le cas précédent.  Notez la variable <i>done</i> . <br><br><h2>  Conclusion </h2><br>  Même en regardant superficiellement le rapport, j'ai écrit près de 100 erreurs.  Je suis satisfait des résultats de PVS-Studio. <br><br>  Bien sûr, ces vérifications de code rares n'ont rien à voir avec l'amélioration de la qualité et de la fiabilité du code.  Ils ne montrent que les capacités de l'analyseur de code.  Des outils d'analyse statique doivent être appliqués régulièrement.  Dans ce cas, ils réduisent le coût de la correction des bogues et protègent les applications de nombreuses vulnérabilités potentielles. <br><br>  Merci de votre attention.  Pour être au courant de nos nouvelles publications, je vous invite à vous abonner à l'une de nos chaînes: <ol><li>  VK.com: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pvsstudio_rus</a> </li><li>  «Old school» RSS: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">viva64-blog-ru</a> </li><li>  Twitter: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@pvsstudio_rus</a> </li><li>  Instagram: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@pvsstudio_rus</a> </li><li>  Télégramme: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@pvsstudio_rus</a> </li></ol><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Une troisième vérification de Qt 5 avec PVS-Studio</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426485/">https://habr.com/ru/post/fr426485/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426475/index.html">Miya - assistant depuis le smartphone</a></li>
<li><a href="../fr426477/index.html">Toute la vérité sur RTOS. Article # 15. Partitions de mémoire: services et structures de données</a></li>
<li><a href="../fr426479/index.html">Banc de test maison pour cartes mères</a></li>
<li><a href="../fr426481/index.html">Cartes hexagonales dans Unity: Path Finder, Player Squads, Animations</a></li>
<li><a href="../fr426483/index.html">Celui qui dépasse Tesla. Pour plus rentable</a></li>
<li><a href="../fr426487/index.html">Testez l'automatisation à partir de zéro. Partie 1</a></li>
<li><a href="../fr426489/index.html">Sur la relation des nombres premiers et irrationnels</a></li>
<li><a href="../fr426491/index.html">Semaine de la sécurité 39: à la mort de Google+</a></li>
<li><a href="../fr426493/index.html">Remises constantes des hébergeurs pour VPS et VPS.today Rechercher des visiteurs</a></li>
<li><a href="../fr426495/index.html">Designer solo. Comment bâtir une carrière quand on travaille seul</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>