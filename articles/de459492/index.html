<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👧🏻 🥕 👩‍❤️‍👩 Industrielles Reverse Engineering 👨🏼‍🎨 ☝🏾 👩🏾‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Geschichte des Ausleihprozesses bei der Entwicklung der Elektronik an einem guten Beispiel. 



 Aufzeichnung des Aufzugsprotokolls des hausgemach...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Industrielles Reverse Engineering</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459492/"><p>  Die Geschichte des Ausleihprozesses bei der Entwicklung der Elektronik an einem guten Beispiel. </p><br><p><img src="https://habrastorage.org/webt/r4/4r/gn/r44rgn9ckwjsxn3aqhznjl6yopg.png"><br>  <em>Aufzeichnung des Aufzugsprotokolls des hausgemachten Schnüfflers</em> </p><a name="habracut"></a><br><p>  Einmal musste ich ein ziemlich einfaches Gerät kopieren.  Das produzierende Unternehmen hörte auf zu existieren, aber im ganzen Land bestand immer noch eine Nachfrage nach dem Ersatz defekter oder gebrauchter Geräte. </p><br><p>  Das Gerät selbst ist die Aufzugstaste auf dem Foto links.  Für Experimente gaben sie mir zwei Exemplare, von denen eines vollständig zerlegt werden konnte. </p><br><p>  Der Gesamtarbeitsplan sah ungefähr so ​​aus: </p><br><ol><li>  Studieren der Leiterplatte; </li><li>  Untersuchung der Elementbasis der Platine selbst; </li><li>  Skizzieren ihres Stromkreises; </li><li>  Versuchen Sie, die Firmware-Datei vom Mikrocontroller zu lesen. </li><li>  Firmware zerlegen; </li><li>  Extrahieren des Operationsalgorithmus; </li><li>  Entwicklung eines neuen Boards; </li><li>  Neue Firmware schreiben. </li></ol><br><p>  Wenn Absatz 4 fehlschlägt, wäre der weitere Plan komplizierter gewesen, aber ich hatte Glück. </p><br><h3 id="izuchaem-podopytnogo">  Wir studieren das Experiment </h3><br><p><img src="https://habrastorage.org/webt/_i/ys/gk/_iysgkygkocn9mdncbzolz0u9q4.jpeg"><br>  <em>Hauptmikrocontroller</em> </p><br><p><img src="https://habrastorage.org/webt/cn/eh/fj/cnehfjp5bvviohtimlndliklm9i.png"><br>  <em>Ein Teil des Stromkreises des Aufzugs, auf dem unsere Bretter rot eingekreist sind</em> </p><br><p>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Karte</a> ist auf einem 1997er Mikrocontroller, dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AT89C2051</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">montiert</a> , der auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel MCS-51-</a> Architektur basiert.  Im Jahr 2020 feiert sie ihr 40-jähriges Bestehen auf dem Markt für eingebettete Systeme. </p><br><blockquote>  Eine kleine Erklärung: Ein Mikrocontroller ist eine solche Mikroschaltung, die einen Computerkern und einen Satz Peripheriegeräte zur Steuerung externer Geräte enthält.  In einer modernen Waschmaschine fragt der Mikrocontroller beispielsweise die Steuertasten und Sensoren ab, zeigt Informationen auf dem Bildschirm an und steuert die Pumpen, die Heizung, die Ventile und den Trommelantrieb.  Für die meisten dieser Funktionen sind keine Zwischengeräte erforderlich, sondern nur ein Satz passiver elektronischer Komponenten. </blockquote><p><img src="https://habrastorage.org/webt/rk/o2/uf/rko2ufxrcsmtjghptrilwcpx3fq.jpeg"><br>  <em>Wir zerlegen die Leiterplatte</em> <em><br></em> <br>  Wenn Sie in Zukunft den ursprünglichen Schaltplan der Karte skizzieren, können Sie den Zweck der Pins des Mikrocontrollers ermitteln, der zum Parsen des Firmware-Codes erforderlich ist. </p><br><p>  Das ursprüngliche Gerät wurde von einer chinesischen Firma entwickelt, und daher ist seine Schaltung äußerst verwirrt und mit vielen unnötigen Komponenten.  Beispielsweise wurde das Relais durch eine Dreifachkaskade aus Bipolartransistor, Optokoppler und Feldregler (in dieser Reihenfolge) eingeschaltet. </p><br><p>  Ein Bekannter, der mit chinesischen Herstellern zusammenarbeitet, sagte mir, dass die Chinesen ähnliche Komplikationen bei Programmen zur Erhöhung der Entwicklungs- und Produktionskosten haben, wenn nur eine Person dies tut.  Danach neige ich dazu, ihm zu glauben: </p><br><p><img src="https://habrastorage.org/webt/fs/ku/lh/fskulhqa3cjeb4v9ilr7bncg9y8.png"><br>  <em>Die gleiche Stelle auf dem chinesischen Zweischichtbrett auf beiden Seiten.</em>  <em>Drei riesige Widerstände sind an nichts angeschlossen.</em>  <em>Ich habe sogar das Board mit einer leistungsstarken Taschenlampe beleuchtet, um sicherzugehen.</em> </p><br><p>  Das Schema wird kopiert, mysteriöse Orte werden in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multisim</a> modelliert, wir greifen die Firmware auf. </p><br><h3 id="pytaemsya-schitat-proshivku">  Ich versuche die Firmware zu lesen </h3><br><p>  Ich hatte großes Glück, dass der Leseschutz nicht auf beiden Karten der Controller aktiviert war, und habe die beiden Firmware-Optionen erfolgreich mit ähnlicher Pornografie zusammengeführt: </p><br><p><img src="https://habrastorage.org/webt/re/9i/ep/re9iepb510h1ylxdfsc29sfre80.jpeg"><br>  <em>Foto aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">persönlichen Blog</a> eines amerikanischen Enthusiasten</em> </p><br><h3 id="dizassemblirovanie-proshivki">  Firmware zerlegen </h3><br><p>  Im nächsten Schritt müssen wir diesen Maschinencode in etwas Lesbareres konvertieren: </p><br><p><img src="https://habrastorage.org/webt/kp/te/gn/kptegnvznij68y49jd7y15vpwsi.png"></p><br><p>  Wir nehmen das bekannte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IDA Pro-</a> Tool, das bereits über unseren Controller mit allen Peripherieregistern verfügt, und öffnen die HEX-Firmware-Datei: </p><br><p><img src="https://habrastorage.org/webt/yx/g_/zj/yxg_zjqxt1nqg3f_jkvuwhhknqy.png"><br>  <em>Verarbeitung der vom Board empfangenen Daten in Assemblersprache</em> </p><br><p>  Danach ist es ein ziemlich langwieriger Prozess, den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Befehlssatz</a> unseres Rechenkerns zu studieren, den Assembler-Code zu kommentieren und zu decodieren. </p><br><p>  Interrupt-Handler selbst wurden an den Adressen der Interrupt-Vektortabelle gefunden, Einträge in den Peripherieregistern gaben Auskunft über die Konfiguration der Kommunikationsschnittstelle.  Schritt für Schritt hat sich der unbenannte Assembler-Code in etwas verwandelt, das gelesen werden kann. </p><br><h3 id="izvlechenie-algoritma-raboty">  Extraktion des Arbeitsalgorithmus </h3><br><p>  Da ich ein neues Gerät auf einer anderen Elementbasis entwickeln musste, musste ein Algorithmus aus dem Code extrahiert werden.  Einige Zeit später wurde ein solcher Pseudocode geboren: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UartISR</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ counter500ms = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//ClearFlag(isrFlags, ISR_FLAG_3); ProcessUart(recievedByte); } void ProcessUart(uint8_t recievedData) { static uint8_t uartPacketsToRxLeft, uartRecievedCmd, uartCurrPacketCRC; static uint8_t i, carryFlag; static uint16_t uartIsrPointer; static uint8_t uartBuffer1[8], uartBuffer2[6]; static uint8_t uartBuffer1Pos, uartBuffer2Pos; // 0 - // 1 - // 2 - // 3 - led state, 0x0F // 4 - // 5 - // 6 - // 7 - // 8 - buttons time static uint8_t dataRegisters[9]; // RAM:0050 uint8_t tmpVal, i; uint8_t dataToSend; if (GetFlag(UartISRFlags, UART_RECIEVED_FLAG)) { ClearFlag(UartISRFlags, UART_RECIEVED_FLAG); if (recieved9thBit) { switch (recievedData) { case 0xC1: uartPacketsToRxLeft = 8; uartRecievedCmd = 1; uartBuffer1Pos = 0; uartBuffer1[uartBuffer1Pos] = recievedData; //uartIsrPointer = 0x0037; //tmpVal_0037 = recievedData; uartCurrPacketCRC = recievedData; UartRxOn(); return; break; case 0xC2: uartPacketsToRxLeft = 3; uartRecievedCmd = 2;</span></span></code> </pre> <br><p>  Die gleiche Verarbeitung der empfangenen Daten in C. </p><br><p>  Wen interessiert das Übertragungsprotokoll: </p><br><blockquote>  Die Aufzugskontrollstation kommunizierte mit den Ruftasten über eine 24-Volt-Vollduplex-Schnittstelle.  Im normalen Modus lauschten die Tastenkarten der Leitung und warteten auf ein 9-Bit-Datenpaket.  Wenn die Adresse unserer Karte in diesem Paket enthalten war (sie wurde durch den DIP-Schalter auf der Karte festgelegt), wurde die Karte in den 8-Bit-Empfangsmodus geschaltet, und alle nachfolgenden Pakete wurden von den übrigen Karten in der Hardware ignoriert. <br><br>  Das erste nach der Adresse war ein Paket mit einem Steuerbefehlscode.  Insbesondere nahm dieses Board nur 3 Teams: <br><ol><li>  Schreiben in Datenregister.  Zum Beispiel die Häufigkeit und Dauer der blinkenden Taste bei einem Anruf; </li><li>  Einschalten der Hintergrundbeleuchtung der Taste; </li><li>  Fragen Sie den Status der Tasten ab (gedrückt oder nicht). </li></ol><br><br>  Das letzte Byte war die Prüfsumme, die ein einfaches XOR aller Bytes nach der Adresse ist. <br>  Nach der Prüfsumme ging die Karte für ihre Adresse erneut in den Standby-Modus. </blockquote><br><h3 id="razrabotka-novoy-platy">  Neue Board-Entwicklung </h3><br><p>  Für die Entwicklung eines neuen Schaltplans und einer Leiterplatte habe ich keine Bilder, aber es war ungefähr so: <br><img src="https://habrastorage.org/webt/qo/o1/ib/qoo1ib5i-46roxxqoea1tw9sshq.jpeg"></p><br><p>  Die Verkabelung und Verkabelung erfolgte in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Altium Designer</a> .  Die Herstellung der Leiterplatte wurde in Zelenograd „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Resonite</a> “ bestellt. </p><br><h3 id="napisanie-novoy-proshivki">  Neue Firmware schreiben </h3><br><p>  Während unser neues Board in Produktion ist, gehen wir zu dem Objekt, in dem solche Ruftasten installiert sind, und überprüfen die Richtigkeit des zerlegten Übertragungsprotokolls mit dem auf dem Arduino montierten Sniffer: <br><img src="https://habrastorage.org/webt/aa/wl/0e/aawl0ep77fnv2gz_txeorxjzkls.png"><br>  Eine Senderschaltung, die dem Original elektrisch entspricht.  Der Empfänger ist nur ein Optokoppler. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//UART1 initialize // desired baud rate:19200 // actual baud rate:19231 (0,2%) // char size: 9 bit // parity: Disabled void uart1_init(void) { UCSR1B = 0x00; //disable while setting baud rate UCSR1A = 0x00; UCSR1C = 0x06; UBRR1L = 0x33; //set baud rate lo UBRR1H = 0x00; //set baud rate hi UCSR1B = 0x94; } #pragma interrupt_handler uart1_rx_isr:iv_USART1_RXC void uart1_rx_isr(void) { unsigned char tmp; unsigned int rcv = 0; if (UCSR1B &amp; 0x02) { rcv = 0x100; } rcv |= UDR1; tmp = (rcv &gt;&gt; 4) &amp; 0x0F; if (rcv &amp; 0x100) { tmp |= 0xC0; } else { tmp |= 0x80; } txBuf12 = (rcv &amp; 0x0F); txBuf11 = tmp; txState1 = 0; TX_ON(); msCounter0 = 5000; }</span></span></code> </pre> <br><p>  Sprechen Sie über unseren Schnüffler in ICC AVR </p><br><p>  Als nächstes musste äußerst vorsichtig vorgegangen werden, um nichts im Aufzug zu verbrennen und ein Anhalten zu verhindern. </p><br><p><img src="https://habrastorage.org/webt/ji/fm/g3/jifmg3osv9g5dxwr_4sq90ela6g.jpeg"><br>  Wir klettern in die Ruftaste.  Dicke gelbe Drähte - Stromversorgungs- und Übertragungsschnittstelle der Platine.  Weiß am 4-poligen Stecker - verbindet den Knopf und seine Hintergrundbeleuchtung. </p><br><p>  Wir überprüfen, ob alles ordnungsgemäß funktioniert, beheben die Pfosten und schreiben eine neue Firmware für unser Gerät: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//ICC-AVR application builder : 11.02.2015 12:25:51 // Target : M328p // Crystal: 16.000Mhz #include &lt;macros.h&gt; #include &lt;iccioavr.h&gt; #include &lt;avrdef.h&gt; #include "types.h" #include "gpio.h" #define TX_OFF() UCSR0B &amp;= 0b11011111; #define TX_ON() UCSR0B |= 0b00100000; #define TX_STATE() (UCSR0B &amp; 0b00100000) #define MAX_TIMEOUT 3000 //#define SNIFFER_MODE 1 //#define MASTER_MODE 1 // #pragma avr_fuse (fuses0, fuses1, fuses2, fuses3, fuses4, fuses5) #pragma avr_fuse (0xFF, 0xD1, 0xFC) #pragma avr_lockbits (0xFC) // AVR signature is always three bytes. Signature0 is always the Atmel // manufacturer code of 0x1E. The other two bytes are device dependent. #pragma avr_signature (0x1E, 0x95, 0x0F) // atmega32 static GPIOx errorLed, rcvLed, butUp, butDn, ledUp, ledDn, butLedUp, butLedDn, ledButUp, ledButDn; static uint8_t msFlag = 0; static uint8_t ledState = 0, buttonsState = 0; static uint16_t rcvLedLitTime = 0, butMaskCalcTime = 0, timeoutTimer = 0; typedef struct { uint16_t buffer[10]; uint8_t dataLength; } UartPacket; static UartPacket txPacket, rxPacket; #ifdef SNIFFER_MODE static uint8_t txBuffer[64], txBufferLength = 0, bufferMutex = 0; #endif static uint8_t GetPacketCRC(UartPacket* packet); static void SendLedState(void); uint8_t GetAddress(void) { return (PINC &amp; 0x3F); }</span></span></code> </pre> <br><p>  C-Code für die neue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Karte</a> basierend auf dem AVR <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ATmega328P-</a> Mikrocontroller </p><br><p>  Die Einfachheit des Geräts und der Firmware lässt sich anhand der Codemenge abschätzen. Sie enthält nur etwa 600 Zeilen in C-Sprache. </p><br><p>  Der Erstellungsprozess sah folgendermaßen aus: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/UIF7QEQrbh8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Die Gebühr ist unterschiedlich, aber das Prinzip ist das gleiche </p><br><p>  Ich kann kein Foto des fertigen Geräts anhängen, glaube nur, dass es noch produziert und verkauft wird. </p><br><h3 id="liricheskoe-zaklyuchenie">  Lyrische Schlussfolgerung </h3><br><p>  In Bezug auf die Aufzugsknöpfe "hoch" und "runter" auf dem Boden.  Mir ist aufgefallen, dass viele Menschen ihren Zweck überhaupt nicht verstehen und beide gleichzeitig schütteln. </p><br><p><img src="https://habrastorage.org/webt/r2/6r/e7/r26re7kjkj8dhppaxmbkdcedvt8.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Von hier aus</a> </p><br><p>  Der Aufzug verfügt über zwei Tastensätze: In der Kabine befindet sich eine Bestelltafel und auf der Etage eine Ruftafel.  Sie können bereits anhand des Namens erraten, dass das Bestellfeld eine höhere Kontrollpriorität hat. </p><br><p>  Alle Aufzüge mit Ruftafeln mit Auf- und Ab-Tasten arbeiten mit einer Art Reiseoptimierungsalgorithmus, dessen Zweck darin besteht, die maximale Anzahl von Passagieren in der minimalen Zeit und eine separate Bedingung für die maximale Wartezeit auf dem Boden (gemäß staatlichem Standard) zu transportieren. </p><br><p>  Ein solcher Algorithmus beinhaltet normalerweise die Auswahl von Passagieren auf Etagen, wenn sie in die gleiche Richtung fahren, wie durch Drücken der Ruftaste „nach oben“ oder „nach unten“ angezeigt. </p><br><p>  Stellen Sie sich eine Situation vor, in der ein Aufzug mit Passagieren nach unten fährt und von einem Stockwerk darunter einen Anruf nach unten erhält.  Der Aufzug hält an, um den Passagier abzuholen (ja, die Beladung der Kabine durch den Gewichtssensor wird noch berücksichtigt, aber wir werden sie senken). </p><br><p>  Der Aufzug fährt weiter und erhält einen Anruf von der unteren Etage.  Es ist logisch, dass der Aufzug nicht anhält, um einen Passagier aufzunehmen, da er die Fahrtrichtung nicht ändert (dies ist auch in der Norm geregelt), und einen Passagier aufnimmt, um hinunter und dann hinauf zu fahren - nutzloser Energie- und Platzverbrauch im Aufzug. </p><br><p>  Der Aufzug fährt weiter und erhält zwei Anrufe „auf und ab“ aus dem unteren Stockwerk, die von einem ungeduldigen Passagier gedrückt wurden, der aufsteigen muss.  Es ist logisch, dass der Aufzug auf dieser Etage anhält, der Passagier ihn jedoch nicht betritt. Es dauert jedoch einige Zeit, bis die Personen in der Kabine den Aufzug verlangsamen und anhalten, die Türen öffnen, warten, die Türen schließen und auf die Nenngeschwindigkeit beschleunigen. </p><br><p>  Wenn der Aufzug nur einen Knopf auf dem Boden hat, funktioniert er in 99% der Fälle nach dem Algorithmus „Kollektives Herunterfahren“. Wenn sich Befehle in der Kabine befinden, stoppt er nur beim Herunterfahren. </p><br><p>  Wenn Sie Programmierkenntnisse in JS haben, können Sie versuchen, einen ähnlichen Steuerungsalgorithmus im Online-Spiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elevator Saga</a> zu implementieren.  Es bietet alle Aspekte der Optimierung von Fahrten, ohne sich eingehend mit dem Betrieb von Aufzugssicherheitskreisen zu befassen. </p><br><p><img src="https://habrastorage.org/webt/pi/kj/ig/pikjigdf2mqsd2ptmjbtot-yd34.png"></p><br><p>  In meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegrammkanal poste</a> ich ähnliche Materialien.  Dort können Sie jetzt die Entwicklung des nächsten Geräts verfolgen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459492/">https://habr.com/ru/post/de459492/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459480/index.html">Vivaldi: Wie verdient der Browser Geld?</a></li>
<li><a href="../de459482/index.html">Wie wir den Kategoriebaum besiegt haben</a></li>
<li><a href="../de459484/index.html">Generation Arduino. Was moderne Studenten erfinden</a></li>
<li><a href="../de459488/index.html">Spezielle Spielmodi im Kontext von Roguelike</a></li>
<li><a href="../de459490/index.html">Schmutzige Tricks von CRM-Anbietern: Würden Sie ein Auto ohne Räder kaufen?</a></li>
<li><a href="../de459494/index.html">Wie man nach einem Hackathon ein wachsendes B2C-Startup startet</a></li>
<li><a href="../de459498/index.html">Slurm - Ein einfacher Weg, um in ein Kubernetes-Thema einzudringen</a></li>
<li><a href="../de459500/index.html">HTML ist das Web</a></li>
<li><a href="../de459502/index.html">Wir entwickeln weiterhin eine Abenteuerplattform für Russen: Schnittstellenfunktionen und Sommerpräferenzen</a></li>
<li><a href="../de459504/index.html">Young Game Designer Course: Wie man das Gleichgewicht von Charakteren und Ausrüstung ohne Mathematik zählt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>