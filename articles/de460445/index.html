<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÇ üë©üèΩ‚Äçüéì üå§Ô∏è Vorlesung "Grundlagen der digitalen Signalverarbeitung" üëÉüèª üçæ üõ¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 

 Oft wenden sich Leute mit Fragen zu Aufgaben aus dem Bereich der digitalen Signalverarbeitung (DSP) an mich. Ich erz√§hle im Detai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vorlesung "Grundlagen der digitalen Signalverarbeitung"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460445/">  Hallo allerseits! <br><br>  Oft wenden sich Leute mit Fragen zu Aufgaben aus dem Bereich der digitalen Signalverarbeitung (DSP) an mich.  Ich erz√§hle im Detail die Nuancen, schlage die notwendigen Informationsquellen vor.  Aber allen Zuh√∂rern fehlen, wie die Zeit gezeigt hat, praktische Aufgaben und Beispiele beim Erlernen dieses Bereichs.  In diesem Zusammenhang habe ich beschlossen, einen kurzen interaktiven Kurs √ºber die digitale Signalverarbeitung zu schreiben und ihn <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√∂ffentlich zug√§nglich zu machen</a> . <br><br>  Der gr√∂√üte Teil des Schulungsmaterials f√ºr visuelle und interaktive Pr√§sentationen wird mit dem <i>Jupyter-Notizbuch</i> implementiert.  Es wird davon ausgegangen, dass der Leser Grundkenntnisse auf dem Gebiet der h√∂heren Mathematik sowie ein wenig Beherrschung der Programmiersprache Python besitzt. <br><br><img src="https://habrastorage.org/webt/vh/4z/ci/vh4zciifrdxclttqfvmpul0zv5a.png"><br><a name="habracut"></a><br><h2>  Vorlesungsliste </h2><br>  Dieser Kurs enth√§lt Materialien in Form von fertigen Vorlesungen zu verschiedenen Themen aus dem Bereich der digitalen Signalverarbeitung.  Die Materialien werden mithilfe von Python-Bibliotheken (numpy, scipy, matplotlib-Pakete usw.) pr√§sentiert.  Die grundlegenden Informationen f√ºr diesen Kurs stammen aus meinen Vorlesungen, die ich als Doktorand an Studenten des Moskauer Energieinstituts (NRU MEI) gegeben habe.  Ein Teil der Informationen aus diesen Vorlesungen wurde bei Schulungsseminaren im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zentrum f√ºr zeitgen√∂ssische Elektronik verwendet</a> , wo ich als Dozent t√§tig war.  Dar√ºber hinaus umfasst dieses Material die √úbersetzung verschiedener wissenschaftlicher Artikel, die Zusammenstellung von Informationen aus zuverl√§ssigen Quellen und Literatur zur digitalen Signalverarbeitung sowie die offizielle Dokumentation zu Anwendungspaketen und integrierten Funktionen der Scipy- und Numpy-Bibliotheken von Python. <br><br>  F√ºr Benutzer von MATLAB (GNU Octave) ist es nicht schwierig, das Material unter dem Gesichtspunkt des Programmcodes zu beherrschen, da die Hauptfunktionen und ihre Attribute weitgehend identisch und den Methoden aus den Python-Bibliotheken √§hnlich sind. <br><br>  Alle Materialien sind nach den Hauptthemen der digitalen Signalverarbeitung gruppiert: <br><br><ol><li>  Signale: analog, diskret, digital.  Z-Umwandlung </li><li>  Fourier-Transformation: Amplituden- und Phasensignal, DFT und FFT, </li><li>  Faltung und Korrelation.  Lineare und zyklische Faltung.  Schnelle Faltung </li><li>  Zuf√§llige Prozesse.  Wei√ües Rauschen.  Wahrscheinlichkeitsdichtefunktion </li><li>  Deterministische Signale.  Modulation: AM, FM, FM, LFM.  Manipulation </li><li>  Signalfilterung: IIR-, FIR-Filter </li><li>  Fensterfunktionen beim Filtern von Aufgaben.  Erkennung schwacher Signale. </li><li>  Resampling: Dezimierung und Interpolation.  CIC-Filter, gleitende Durchschnittsfilter </li></ol><br><br>  Die Liste der Vorlesungen ist ausreichend, <s>aber nat√ºrlich unvollst√§ndig</s> f√ºr eine einf√ºhrende Einf√ºhrung in das Gebiet der DSP.  In meiner Freizeit plane ich, dieses Projekt zu unterst√ºtzen und weiterzuentwickeln. <br><br><h3>  Wo zu finden? </h3><br>  Alle Materialien sind <b>absolut kostenlos</b> und als offenes Repository auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinem Github als OpenSource-Projekt</a> verf√ºgbar.  Die Materialien werden in zwei Formaten pr√§sentiert - in Form von Jupyter-Notizb√ºchern zum interaktiven Arbeiten, Lernen und Bearbeiten sowie in Form von HTML-Dateien, die aus diesen Notizb√ºchern zusammengestellt wurden (nach dem Herunterladen vom Github haben sie ein durchaus geeignetes Format zum Lesen und Drucken). <br><br>  Das Folgende ist eine sehr <u>kurze</u> Beschreibung der Abschnitte des Kurses mit kurzen Erkl√§rungen, Begriffen und Definitionen.  Grundlegende Informationen finden Sie in den ersten Vorlesungen, hier nur eine kurze √úbersicht! <br><br><h3>  Signale.  Z-Umwandlung </h3><br>  Einf√ºhrungsabschnitt, der grundlegende Informationen zu den Signaltypen enth√§lt.  Das Konzept einer diskreten Sequenz, einer Delta-Funktion und einer Heaviside-Funktion (Einheitssprung) wird vorgestellt. <br><br>  Alle Signale gem√§√ü der Darstellungsmethode am Set k√∂nnen in vier Gruppen unterteilt werden: <br><ul><li>  analog - werden durch zeitkontinuierliche Funktionen beschrieben, </li><li>  diskret - werden zeitlich mit einem durch Abtastung festgelegten Schritt unterbrochen, </li><li>  quantisiert - haben eine Reihe von endlichen Pegeln (normalerweise in der Amplitude), </li><li>  digital - eine Kombination der Eigenschaften diskreter und quantisierter Signale. </li></ul><br><br><img src="https://habrastorage.org/webt/1f/l4/te/1fl4te_9ataaovtla-4morc9uwa.png" alt="Signale"><br><br>  F√ºr die korrekte Rekonstruktion eines analogen Signals aus einem digitalen Signal ohne Verzerrung und Verlust wird der als <b>Kotelnikov (Nyquist-Shannon)</b> -Satz bekannte <b>Abtastsatz</b> verwendet. <br><blockquote>  Jedes kontinuierliche Signal mit einem begrenzten Spektrum kann eindeutig und ohne Verlust aus seinen diskreten Abtastwerten wiederhergestellt werden, die mit einer Frequenz entnommen wurden, die streng gr√∂√üer als das Doppelte der oberen Frequenz des Spektrums eines kontinuierlichen Signals ist. </blockquote><br>  Eine solche Interpretation ist g√ºltig, sofern die kontinuierliche Funktion der Zeit ein Frequenzband von 0 bis zum Wert der oberen Frequenz einnimmt.  Wenn die Quantisierungs- und Diskretisierungsschritte falsch gew√§hlt werden, wird das Signal von analog zu diskret verzerrt. <br><br>  Auch in diesem Abschnitt werden die <b>Z-Transformation</b> und ihre Eigenschaften beschrieben und die Darstellung diskreter Sequenzen in der Z-Form gezeigt. <br><br>  Beispiel einer endlichen diskreten Folge: <br><pre><code class="python hljs">x(nT) = {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}</code> </pre>  . <br>  Ein Beispiel f√ºr dieselbe Sequenz in Z-Form: <br><br>  X (z) = 2 + z <sup>-1</sup> - 2z <sup>-2</sup> + 2z <sup>-4</sup> + 3z <sup>-5</sup> + 1z <sup>-6</sup> <br><br><h3>  Fourier-Transformation.  Eigenschaften  DFT und FFT </h3><br>  Dieser Abschnitt beschreibt das Konzept des Zeit- und Frequenzbereichs eines Signals.  Die Definition der diskreten Fourier-Transformation (DFT) wird eingef√ºhrt.  Die direkten und inversen DFTs und ihre Haupteigenschaften werden ber√ºcksichtigt.  Dargestellt ist der √úbergang von der DFT zum FFT-Algorithmus (Fast Fourier Transform) in Basis 2 (Dezimierungsalgorithmen in Frequenz und Zeit).  Reflektierte die Wirksamkeit von FFT im Vergleich zu DFT. <br><br>  In diesem Abschnitt wird insbesondere das Python-Paket scipy.ffpack zur Berechnung verschiedener Fourier-Transformationen (Sinus, Cosinus, direkt, invers, mehrdimensional, real) beschrieben. <br><br>  Mit der Fourier-Transformation k√∂nnen Sie jede Funktion als Satz harmonischer Signale darstellen!  Die Fourier-Transformation ist die Grundlage f√ºr Faltungsmethoden und das Design digitaler Korrelatoren, wird aktiv in der Spektralanalyse verwendet und wird bei der Arbeit mit langen Zahlen verwendet. <br><br>  Merkmale der Spektren diskreter Signale: <br>  1. Die spektrale Dichte eines diskreten Signals ist eine periodische Funktion mit einer Periode gleich der Abtastfrequenz. <br>  2. Wenn die diskrete Sequenz <i>real ist</i> , ist der Spektraldichtemodul einer solchen Sequenz eine <i>gerade</i> Funktion, und das Argument ist <i>eine ungerade</i> Frequenzfunktion. <br><br>  Harmonisches Signalspektrum: <br><br><img src="https://habrastorage.org/webt/if/gy/k4/ifgyk4dlgjakj-zrkd3vpzq8c24.png" alt="FFT f√ºr Cosinus"><br><br><h4>  Vergleich der Wirksamkeit von DFT und FFT </h4><br>  Die Effizienz des FFT-Algorithmus und die Anzahl der linear ausgef√ºhrten Operationen h√§ngen von der Sequenzl√§nge N ab: <br><br><div class="scrollable-table"><table><thead><tr><th rowspan="2">  N. </th><th colspan="2">  DFT </th><th colspan="2">  FFT </th><th rowspan="2">  Das Verh√§ltnis der Anzahl komplexer Additionen </th><th rowspan="2">  Das Verh√§ltnis der Anzahl komplexer Multiplikationen </th></tr><tr><th>  Die Anzahl der Multiplikationsoperationen </th><th>  Anzahl der Additionsoperationen </th><th>  Die Anzahl der Multiplikationsoperationen </th><th>  Anzahl der Additionsoperationen </th></tr></thead><tbody><tr><td>  2 </td><td>  4 </td><td>  2 </td><td>  1 </td><td>  2 </td><td>  4 </td><td>  1 </td></tr><tr><td>  4 </td><td>  16 </td><td>  12 </td><td>  4 </td><td>  8 </td><td>  4 </td><td>  1.5 </td></tr><tr><td>  8 </td><td>  64 </td><td>  56 </td><td>  12 </td><td>  24 </td><td>  5.3 </td><td>  2.3 </td></tr><tr><td>  16 </td><td>  256 </td><td>  240 </td><td>  32 </td><td>  64 </td><td>  8 </td><td>  3,75 </td></tr><tr><td>  32 </td><td>  1024 </td><td>  992 </td><td>  80 </td><td>  160 </td><td>  12.8 </td><td>  6.2 </td></tr><tr><td>  64 </td><td>  4096 </td><td>  4032 </td><td>  192 </td><td>  384 </td><td>  21.3 </td><td>  10.5 </td></tr><tr><td>  128 </td><td>  16384 </td><td>  16256 </td><td>  448 </td><td>  896 </td><td>  36.6 </td><td>  18.1 </td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td>  4096 </td><td>  16777216 </td><td>  16773120 </td><td>  24576 </td><td>  49152 </td><td>  683 </td><td>  341 </td></tr><tr><td>  8192 </td><td>  67108864 </td><td>  67100672 </td><td>  53248 </td><td>  106496 </td><td>  <b>1260</b> </td><td>  <b>630</b> </td></tr></tbody></table></div><br>  Wie Sie sehen, sind die Einsparungen bei den Rechenressourcen (in Bezug auf die Verarbeitungsgeschwindigkeit oder die Anzahl der Hardwareeinheiten) umso gr√∂√üer, je l√§nger die Konvertierungsl√§nge ist! <br><br>  Jede beliebige Wellenform kann als Satz von harmonischen Signalen mit unterschiedlichen Frequenzen dargestellt werden.  Mit anderen Worten, ein Signal mit komplexer Form im Zeitbereich weist eine Reihe komplexer Abtastwerte im Frequenzbereich auf, die als * Harmonische * bezeichnet werden.  Diese Abtastwerte dr√ºcken die Amplitude und Phase des harmonischen Effekts bei einer bestimmten Frequenz aus.  Je gr√∂√üer der Satz von Harmonischen im Frequenzbereich ist, desto genauer erscheint die komplexe Wellenform. <br><br><img src="https://habrastorage.org/webt/vj/i1/dg/vji1dgvf4ak0dsvjhlmx7mmhj6q.png" alt="FFT Gibbs"><br><br><h3>  Faltung und Korrelation </h3><br>  In diesem Abschnitt wird das Konzept der Korrelation und Faltung f√ºr diskrete zuf√§llige und deterministische Sequenzen vorgestellt.  Die Beziehung zwischen Autokorrelations- und Kreuzkorrelationsfunktionen mit der Faltung wird gezeigt.  Die Eigenschaften der Faltung werden beschrieben, insbesondere werden die Verfahren der linearen und zyklischen Faltung eines diskreten Signals mit detaillierter Analyse am Beispiel einer diskreten Sequenz betrachtet.  Zus√§tzlich wird ein Verfahren zur Berechnung der "schnellen" Faltung unter Verwendung von FFT-Algorithmen gezeigt. <br><br>  Bei realen Problemen wird h√§ufig die Frage nach dem Grad der √Ñhnlichkeit eines Prozesses mit einem anderen oder nach der Unabh√§ngigkeit eines Prozesses von einem anderen aufgeworfen.  Mit anderen Worten ist es erforderlich, die Beziehung zwischen den Signalen zu bestimmen, dh eine <i>Korrelation</i> zu finden.  Korrelationsmethoden werden in einer Vielzahl von Aufgaben eingesetzt: Signalsuche, Bildverarbeitung und Bildverarbeitung, bei Radarproblemen zur Bestimmung der Eigenschaften von Zielen und zur Bestimmung der Entfernung zu einem Objekt.  Zus√§tzlich wird die Korrelation verwendet, um nach schwachen Signalen im Rauschen zu suchen. <br><br>  <b>Die Faltung</b> beschreibt die Wechselwirkung von Signalen miteinander.  Wenn eines der Signale die Impulsantwort des Filters ist, ist die Faltung der Eingangssequenz mit der Impulsantwort nichts anderes als eine Reaktion der Schaltung auf die Eingangsaktion.  Mit anderen Worten spiegelt das resultierende Signal den Durchgang des Signals durch das Filter wider. <br><br>  <i>Die Autokorrelationsfunktion</i> (ACF) wird zum Codieren von Informationen verwendet.  Die Wahl der Codierungssequenz gem√§√ü den Parametern L√§nge, Frequenz und Form ist weitgehend auf die Korrelationseigenschaften dieser Sequenz zur√ºckzuf√ºhren.  Die beste Codesequenz weist die geringste Wahrscheinlichkeit einer falschen Erkennung oder Operation (zum Erkennen von Signalen, f√ºr Schwellenwertger√§te) oder einer falschen Synchronisation (zum Senden und Empfangen von Codesequenzen) auf. <br><br>  Dieser Abschnitt enth√§lt eine Tabelle zum Vergleich der Wirksamkeit der schnellen Faltung und der Faltung, berechnet nach der direkten Formel (anhand der Anzahl der reellen Multiplikationen). <br><br>  Wie Sie sehen k√∂nnen, <u>verliert</u> die schnelle Faltung bei FFT-L√§ngen bis zu 64 an die direkte Methode.  Mit zunehmender FFT-L√§nge √§ndern sich die Ergebnisse jedoch in die entgegengesetzte Richtung - eine schnelle Faltung beginnt, die direkte Methode zu √ºbertreffen.  Je l√§nger die FFT ist, desto besser ist nat√ºrlich die Verst√§rkung bei der Frequenzmethode. <br><br><div class="scrollable-table"><table><thead><tr><th>  N. </th><th>  Faltung </th><th>  Schnelle Faltung </th><th>  Haltung </th></tr></thead><tbody><tr><td>  8 </td><td>  64 </td><td>  448 </td><td>  0,14 </td></tr><tr><td>  16 </td><td>  256 </td><td>  1088 </td><td>  0,24 </td></tr><tr><td>  32 </td><td>  1024 </td><td>  2560 </td><td>  0,4 </td></tr><tr><td>  64 </td><td>  4096 </td><td>  5888 </td><td>  0,7 </td></tr><tr><td>  128 </td><td>  16K </td><td>  13312 </td><td>  1.23 </td></tr><tr><td>  ... </td><td>  ... </td><td>  .. </td><td>  ... </td></tr><tr><td>  2048 </td><td>  4M </td><td>  311296 </td><td>  <b>13.5</b> </td></tr></tbody></table></div><br><h3>  Zuf√§llige Signale und Rauschen </h3><br>  In diesem Abschnitt wird das Konzept der Zufallssignale, der Wahrscheinlichkeitsdichte und des Zufallsverteilungsgesetzes vorgestellt.  Mathematische Momente werden ber√ºcksichtigt - Mittelwert (mathematische Erwartung) und Varianz (oder die Wurzel dieser Gr√∂√üe ist die Standardabweichung).  Auch in diesem Abschnitt werden die Normalverteilung und das damit verbundene Konzept des <i>wei√üen Rauschens</i> als Hauptquelle f√ºr Rauschen (Interferenz) w√§hrend der Signalverarbeitung betrachtet. <br><br>  <i>Ein Zufallssignal</i> ist eine Funktion der Zeit, deren Werte nicht im Voraus bekannt sind und nur mit einer gewissen <i>Wahrscheinlichkeit</i> vorhergesagt <i>werden k√∂nnen</i> .  Die Hauptmerkmale von Zufallssignalen umfassen: <br><br><ul><li>  Verteilungsgesetz (relative Verweilzeit eines Signalwerts in einem bestimmten Intervall), </li><li>  spektrale Verteilung der Signalleistung. </li></ul><br><br><img src="https://habrastorage.org/webt/sh/02/ft/sh02ftx_0_ynupvdlzo7uvgmeds.png" alt="Noise AWGN"><br><br>  Bei DSP-Aufgaben werden zuf√§llige Signale in zwei Klassen unterteilt: <br><br><ul><li>  Rauschen - zuf√§llige Schwankungen, die aus einer Reihe unterschiedlicher Frequenzen und Amplituden bestehen, </li><li>  Signale, die Informationen tragen, f√ºr deren Verarbeitung auf probabilistische Methoden zur√ºckgegriffen werden muss. </li></ul><br><br>  Mithilfe von Zufallsvariablen k√∂nnen wir die Auswirkung eines realen Mediums auf den Durchgang eines Signals von einer Quelle zu einem Datenempf√§nger simulieren.  Wenn ein Signal eine verrauschte Verbindung durchl√§uft, wird dem Signal das sogenannte wei√üe Rauschen hinzugef√ºgt.  In der Regel ist die spektrale Dichte eines solchen Rauschens bei allen Frequenzen gleichm√§√üig (gleichm√§√üig) verteilt, und die Rauschwerte im Zeitbereich sind normalverteilt (Gau√üsches Verteilungsgesetz).  Da den Signalamplituden in den ausgew√§hlten Zeitabtastwerten physikalisch wei√ües Rauschen hinzugef√ºgt wird, wird es als additives wei√ües Gau√üsches Rauschen (AWGN) bezeichnet. <br><br><h3>  Signale, Modulation und Manipulation </h3><br>  Dieser Abschnitt zeigt die grundlegenden Methoden zum √Ñndern eines oder mehrerer Parameter eines harmonischen Signals.  Die Konzepte der Amplituden-, Frequenz- und Phasenmodulation werden vorgestellt.  Insbesondere wird die bei Radarproblemen verwendete lineare Frequenzmodulation hervorgehoben.  Dargestellt sind die Hauptmerkmale der Signale, die Spektren der modulierten Signale in Abh√§ngigkeit von den Modulationsparametern. <br><br><img src="https://habrastorage.org/webt/b9/sw/c6/b9swc66eoj37yobhgypvjmwizni.png" alt="Frequenzmodulation"><br><br>  Der Einfachheit halber wurde in Python eine Reihe von Funktionen erstellt, die die oben genannten Modulationstypen implementieren.  Beispiel f√ºr die Implementierung eines Chirpsignals: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signal_chirp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(amp=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, freq=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, beta=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.25</span></span></span></span><span class="hljs-function"><span class="hljs-params">, period=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span><span class="hljs-function"><span class="hljs-params">, **kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Create Chirp signal Parameters ---------- amp : float Signal magnitude beta : float Modulation bandwidth: beta &lt; N for complex, beta &lt; 0.5N for real freq : float or int Linear frequency of signal period : integer Number of points for signal (same as period) kwargs : bool Complex signal if is_complex = True Modulated by half-sine wave if is_modsine = True """</span></span> is_complex = kwargs.get(<span class="hljs-string"><span class="hljs-string">'is_complex'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) is_modsine = kwargs.get(<span class="hljs-string"><span class="hljs-string">'is_modsine'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) t = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, period) tt = np.pi * (freq * t + beta * t ** <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_complex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: res = amp * (np.cos(tt) + <span class="hljs-number"><span class="hljs-number">1j</span></span> * np.sin(tt)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = amp * np.cos(tt) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_modsine <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res * np.sin(np.pi * t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res</code> </pre><br><img src="https://habrastorage.org/webt/ug/ad/85/ugad85xkc0ml7p2e4kgv5niqnbs.png" alt="Chirp-Modulation"><br><br>  Auch in diesem Abschnitt aus der Theorie der √úbertragung diskreter Nachrichten werden Arten der digitalen Modulation - Manipulationen beschrieben.  Wie bei analogen Signalen k√∂nnen digitale harmonische Sequenzen in Amplitude, Phase und Frequenz (oder mehreren Parametern gleichzeitig) manipuliert werden. <br><br><img src="https://habrastorage.org/webt/yl/w9/8q/ylw98qsdcnn3kaivfz2cdasrxry.png" alt="Frequenzmanipulation"><br><br><h3>  Digitale Filter - IIR und FIR </h3><br>  Ein ausreichend gro√üer Abschnitt, der der digitalen Filterung diskreter Sequenzen gewidmet ist.  Bei digitalen Signalverarbeitungsaufgaben flie√üen Daten durch Schaltkreise, die als <b>Filter bezeichnet werden</b> .  Digitale Filter haben wie analoge unterschiedliche Eigenschaften - Frequenz: Frequenzgang, Phasengang, Zeit: Impulsgang sowie die √úbertragungscharakteristik des Filters.  Digitale Filter werden haupts√§chlich verwendet, um die Signalqualit√§t zu verbessern - um ein Signal von einer Datensequenz zu isolieren oder um unerw√ºnschte Signale zu verschlechtern - um bestimmte Signale in eingehenden Abtastsequenzen zu unterdr√ºcken. <br><br><img src="https://habrastorage.org/webt/mp/2m/oy/mp2moyuibf5qgzlb19d8ne_gw-q.png" alt="IIR FIR-Signale"><br><br>  In diesem Abschnitt werden die wichtigsten Vor- und Nachteile digitaler Filter (im Vergleich zu analogen) aufgef√ºhrt.  Das Konzept der Impuls- und √úbertragungseigenschaften des Filters wird vorgestellt.  Es werden zwei Klassen von Filtern betrachtet - mit einer unendlichen Impulsantwort (IIR) und einer endlichen Impulsantwort (FIR).  Es wird eine Methode zum Entwerfen von Filtern in <b>kanonischer</b> und <b>direkter</b> Form gezeigt.  Bei FIR-Filtern wird die Frage ber√ºcksichtigt, wie zu einer rekursiven Form gewechselt werden kann. <br><br><img src="https://habrastorage.org/webt/qn/m5/x5/qnm5x5wguwanmzjfst2erf0orsa.png" alt="IIR FIR-Schema"><br><br>  Bei FIR-Filtern wird der Filterentwurfsprozess von der Entwicklung der technischen Spezifikationen (mit den angegebenen Hauptparametern) bis zur Software- und Hardwareimplementierung - Suche nach Filterkoeffizienten (unter Ber√ºcksichtigung der Darstellungsform von Anzahl, Bittiefe usw.) gezeigt.  Die Definitionen von symmetrischen FIR-Filtern, die lineare Phasenantwort und ihre Beziehung zum Konzept der Gruppenverz√∂gerung werden vorgestellt. <br><br><img src="https://habrastorage.org/webt/7d/ng/vy/7dngvygzcdsyc4dacklcae2ddsa.png" alt="FIR voller Weg"><br><br><h3>  Fensterfunktionen beim Filtern von Aufgaben </h3><br>  Bei den Aufgaben der digitalen Signalverarbeitung werden Fensterfunktionen verschiedener Formen verwendet, die, wenn sie einem Signal im Zeitbereich √ºberlagert werden, dessen spektrale Eigenschaften qualitativ verbessern k√∂nnen.  Eine gro√üe Anzahl verschiedener Fenster ist haupts√§chlich auf eines der Hauptmerkmale einer Fenster√ºberlagerung zur√ºckzuf√ºhren.  Dieses Merkmal dr√ºckt sich in der Beziehung zwischen der H√∂he der Nebenkeulen und der Breite der Mittellappen aus.  Regel: <br><blockquote>  Je st√§rker die Unterdr√ºckung der Nebenkeulen des Spektrums ist, desto breiter ist die Hauptkeule des Spektrums und umgekehrt. </blockquote><br><img src="https://habrastorage.org/webt/lc/mx/em/lcmxemylmukc0mf5xtbwrudsbrm.png" alt="Siege (Zeit)"><br><br>  Eine der Anwendungen von Fensterfunktionen: Erkennung schwacher Signale vor dem Hintergrund st√§rkerer Signale durch Unterdr√ºckung des Niveaus von Nebenkeulen.  Die Hauptfensterfunktionen in DSP-Aufgaben sind ** dreieckig, sinusf√∂rmig, Lanczos, Hann, Hamming, Blackman, Harris, Blackman-Harris-Fenster, Flat-Top-Fenster, Natall, Gauss, Kaiser-Fenster ** und viele andere.  Die meisten von ihnen werden durch eine endliche Reihe ausgedr√ºckt, indem harmonische Signale mit bestimmten Gewichten summiert werden.  Solche Signale sind in der Praxis auf allen Hardwareger√§ten (programmierbaren Logikschaltungen oder Signalprozessoren) perfekt implementiert. <br><br><img src="https://habrastorage.org/webt/qo/vo/qg/qovoqg__dcfm--hjd0ibos_m-fm.png" alt="Siege (freq)"><br><br><h3>  Resampling.  Dezimierung und Interpolation </h3><br>  In diesem Abschnitt werden die Probleme der Signalverarbeitung mit mehreren Geschwindigkeiten erl√§utert - √Ñnderungen der Abtastfrequenz.  Die Mehrgeschwindigkeitsverarbeitung von Signalen (Mehrratenverarbeitung) legt nahe, dass es bei der linearen Umwandlung digitaler Signale m√∂glich ist, die Abtastfrequenz in Richtung abnehmend oder ansteigend oder in Bruchteilen von Malen zu √§ndern.  Dies f√ºhrt zu einer effizienteren Signalverarbeitung, da die M√∂glichkeit er√∂ffnet wird, die minimal zul√§ssigen Abtastfrequenzen zu verwenden, und infolgedessen die erforderliche Rechenleistung des entworfenen digitalen Systems erheblich verringert wird. <br><br>  <i>Dezimierung</i> (Dezimierung) - Downsampling.  <i>Interpolation</i> - Erh√∂hung der Abtastrate. <br><br>  In diesem Abschnitt wird auch die Klasse der homogenen FIR-Filter betrachtet, die als Integralkammfilter (CIC, Cascaded Integrator - Comb) bezeichnet werden.  Die Implementierung, die grundlegenden Eigenschaften und Funktionen von CIC-Filtern werden gezeigt.  Aufgrund der Linearit√§t der mathematischen Operationen, die im CIC-Filter auftreten, ist es m√∂glich, mehrere Filter hintereinander zu kaskadieren, was zu einer proportionalen Abnahme des Niveaus der Nebenkeulen f√ºhrt, aber auch die "Blockierung" der Hauptkeule der Amplituden-Frequenz-Charakteristik erh√∂ht. <br><br><img src="https://habrastorage.org/webt/qg/ef/ye/qgefyerrdczmun9os1vetvxxdsy.png" alt="Cascade Cic Filter"><br><br>  Diagramm des Frequenzgangs des Filters in Abh√§ngigkeit vom Dezimierungskoeffizienten: <br><br><img src="https://habrastorage.org/webt/b8/lh/qz/b8lhqzdsk-tcnqxkq9pimvteq4g.png" alt="CIC Freq Responce"><br><br>  In diesem Abschnitt wird auch das Problem der Erh√∂hung der Bittiefe der Daten am Ausgang des CIC-Filters in Abh√§ngigkeit von seinen Parametern er√∂rtert.  Dies ist besonders wichtig bei Software-Implementierungsaufgaben, insbesondere bei FPGAs. <br><br>  F√ºr die praktische Implementierung von CIC-Filtern in Python wurde ein separater <b>CicFilter der</b> Klasse <b>entwickelt</b> , der Dezimierungs- und Interpolationsmethoden implementiert.  Au√üerdem werden √Ñnderungen der Abtastrate mithilfe der integrierten Methoden aus dem scipy Python-Paket angezeigt. <br><br><div class="spoiler">  <b class="spoiler_title">Python CicFilter-Klasse f√ºr die digitale Signalverarbeitung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CicFilter</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Cascaded Integrator-Comb (CIC) filter is an optimized class of finite impulse response (FIR) filter. CIC filter combines an interpolator or decimator, so it has some parameters: R - decimation or interpolation ratio, N - number of stages in filter (or filter order) M - number of samples per stage (1 or 2)* * for this realisation of CIC filter just leave M = 1. CIC filter is used in multi-rate processing. In hardware applications CIC filter doesn't need multipliers, just only adders / subtractors and delay lines. Equation for 1st order CIC filter: y[n] = x[n] - x[n-RM] + y[n-1]. Parameters ---------- x : np.array input signal """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x)</span></span></span><span class="hljs-function">:</span></span> self.x = x <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decimator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, r, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" CIC decimator: Integrator + Decimator + Comb Parameters ---------- r : int decimation rate n : int filter order """</span></span> <span class="hljs-comment"><span class="hljs-comment"># integrator y = self.x[:] for i in range(n): y = np.cumsum(y) # decimator y = y[::r] # comb stage return np.diff(y, n=n, prepend=np.zeros(n)) def interpolator(self, r, n, mode=False): """ CIC inteprolator: Comb + Decimator + Integrator Parameters ---------- r : int interpolation rate n : int filter order mode : bool False - zero padding, True - value padding. """ # comb stage y = np.diff(self.x, n=n, prepend=np.zeros(n), append=np.zeros(n)) # interpolation if mode: y = np.repeat(y, r) else: y = np.array([i if j == 0 else 0 for i in y for j in range(r)]) # integrator for i in range(n): y = np.cumsum(y) if mode: return y[1:1 - n * r] else: return y[r - 1:-n * r + r - 1]</span></span></code> </pre><br></div></div><br><br><img src="https://habrastorage.org/webt/mt/ri/b5/mtrib5pqroyzezup5m9ulqsklzg.png" alt="CIC-Dezimierung / Interpolation"><br><br>  Schlie√ülich enth√§lt dieser Abschnitt eine spezielle Klasse von Filtern - den gleitenden Durchschnitt.  Es werden drei Implementierungsmethoden gezeigt: durch Faltung von Signalen unter Verwendung eines FIR-Filters und eines IIR-Filters. <br><br><img src="https://habrastorage.org/webt/0m/b7/rf/0mb7rfvv_e6vuzt9xqsumvgs7eq.png" alt="MAF, Moving Average Filter"><br><br><h3>  Fazit </h3><br>  Ich hoffe, dass dieser Vorlesungskurs in Verbindung mit meinen vorherigen Artikeln zur digitalen FPGA-Signalverarbeitung praktische Vorteile bringt und dem Leser hilft, die Grundlagen der digitalen Signalverarbeitung besser zu verstehen.  Dieses Projekt wird verbessert und durch neues n√ºtzliches und nicht weniger interessantes Material erg√§nzt.  Verfolgen Sie die Entwicklung! <br><br>  Zus√§tzlich zu diesem Material unterst√ºtze und entwickle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich mein Projekt</a> auf den wichtigsten DSP-Modulen (in Python).  Es enth√§lt ein Paket zum Erzeugen verschiedener Signale, eine Klasse von CIC-Filtern f√ºr Dezimierungs- und Interpolationsprobleme, einen Algorithmus zum Berechnen der Koeffizienten eines korrigierenden FIR-Filters, einen Filter f√ºr den gleitenden Durchschnitt und einen Algorithmus zum Berechnen einer ultralangen FFT durch zweidimensionale Konvertierungsmethoden (letzteres war sehr n√ºtzlich bei der Arbeit mit der Hardware-Implementierung auf FPGAs). . <br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460445/">https://habr.com/ru/post/de460445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460435/index.html">Kleine Freude # 8: kleine Freuden f√ºr die Arbeit mit der Datenbank</a></li>
<li><a href="../de460437/index.html">Wie wir ein technisches Support-Fahrrad herausbringen</a></li>
<li><a href="../de460439/index.html">Programmiersprache P4</a></li>
<li><a href="../de460441/index.html">Gleb Nitzman: ‚ÄûIch fand das Ende einer √Ñra, in der die Menschen das in Radioelementen enthaltene Gold noch nicht gejagt hatten.‚Äú</a></li>
<li><a href="../de460443/index.html">Designer gegen Entwickler: √úber die Entstehungsgeschichte der Anwendung ‚ÄûMy Smart City‚Äú</a></li>
<li><a href="../de460451/index.html">Der Mensch hat sein drittes Ohr f√ºr die ganze Welt gemacht - um der Kunst willen</a></li>
<li><a href="../de460453/index.html">Intelligenter Drucker. Octoprint verbessern</a></li>
<li><a href="../de460457/index.html">DIY Solarkraftwerk 200 m2</a></li>
<li><a href="../de460459/index.html">Konfigurationsdatei htaccess</a></li>
<li><a href="../de460461/index.html">Simulation gezielter Angriffe als Sicherheitsbewertung. Rote Teaming Cyber-Anweisungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>