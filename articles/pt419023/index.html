<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öïÔ∏è üôÖüèΩ ü§±üèª Como escalamos o Nginx e salvamos o mundo 54 anos de espera todos os dias üîß üïµÔ∏è üçõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúA equipe do @Cloudflare acabou de fazer altera√ß√µes que melhoraram significativamente o desempenho da nossa rede, especialmente para as solicita√ß√µes m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como escalamos o Nginx e salvamos o mundo 54 anos de espera todos os dias</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419023/"> <i>‚ÄúA equipe do @Cloudflare acabou de fazer altera√ß√µes que melhoraram significativamente o desempenho da nossa rede, especialmente para as solicita√ß√µes mais lentas.</i>  <i>Quanto mais r√°pido?</i>  <i>Estimamos que estamos economizando na Internet cerca de 54 anos <b>por dia</b> que seriam gastos esperando os sites serem carregados</i> . <i>‚Äù</i>  - Matthew Prince <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tweet</a> , 28 de junho de 2018 <br><br>  10 milh√µes de sites, aplicativos e APIs usam o Cloudflare para acelerar o download de conte√∫do para os usu√°rios.  No pico, processamos mais de 10 milh√µes de solicita√ß√µes por segundo em 151 data centers.  Ao longo dos anos, fizemos muitas altera√ß√µes em nossa vers√£o do Nginx para lidar com o crescimento.  Este artigo √© sobre uma dessas altera√ß√µes. <br><a name="habracut"></a><br><h1>  Como o Nginx funciona </h1><br>  O Nginx √© um dos programas que usa loops de processamento de eventos para resolver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o</a> problema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do C10K</a> .  Cada vez que um evento de rede chega (uma nova conex√£o, solicita√ß√£o ou notifica√ß√£o para enviar uma quantidade maior de dados etc.), o Nginx acorda, processa o evento e retorna para outro trabalho (isso pode estar processando outros eventos).  Quando um evento chega, os dados est√£o prontos, o que permite processar com efici√™ncia muitas solicita√ß√µes simult√¢neas sem tempo de inatividade. <br><br><pre><code class="hljs pgsql">num_events = epoll_wait(epfd, <span class="hljs-comment"><span class="hljs-comment">/*returned=*/</span></span>events, events_len, <span class="hljs-comment"><span class="hljs-comment">/*timeout=*/</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>); // events <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> list <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> active events // handle event[<span class="hljs-number"><span class="hljs-number">0</span></span>]: incoming request <span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> http://example.com/ // handle event[<span class="hljs-number"><span class="hljs-number">1</span></span>]: send <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> response <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> http://cloudflare.com/</code> </pre> <br>  Por exemplo, aqui est√° a apar√™ncia de um peda√ßo de c√≥digo para ler dados de um descritor de arquivo: <br><br><pre> <code class="hljs pgsql">// we got a <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> event <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> fd <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (buf_len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ssize_t n = <span class="hljs-keyword"><span class="hljs-keyword">read</span></span>(fd, buf, buf_len); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno == EWOULDBLOCK || errno == EAGAIN) { // try later <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> we <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> event again } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno == EINTR) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } buf_len -= n; buf += n; total += n; }</code> </pre> <br>  Se fd for um soquete de rede, os bytes j√° recebidos ser√£o retornados.  A √∫ltima chamada retornar√° <code>EWOULDBLOCK</code> .  Isso significa que o buffer de leitura local terminou e voc√™ n√£o deve mais ler neste soquete at√© que os dados apare√ßam. <br><br><h1>  E / S de disco √© diferente da rede </h1><br>  Se fd for um arquivo regular no Linux, <code>EWOULDBLOCK</code> e <code>EWOULDBLOCK</code> nunca aparecer√£o e a opera√ß√£o de leitura sempre aguardar√° a leitura de todo o buffer, mesmo que o arquivo seja aberto usando <code>O_NONBLOCK</code> .  Conforme escrito no manual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aberto (2)</a> : <br><br><blockquote>  Observe que esse sinalizador n√£o √© v√°lido para arquivos regulares e dispositivos de bloqueio. </blockquote><br>  Em outras palavras, o c√≥digo acima √© essencialmente reduzido a isso: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>(fd, buf, buf_len) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buf_len; }</code> </pre> <br>  Se o manipulador precisar ler do disco, ele bloquear√° o loop de eventos at√© que a leitura seja conclu√≠da e os manipuladores de eventos subsequentes aguardem. <br><br>  Isso √© normal para a maioria das tarefas, pois a leitura de um disco geralmente √© muito r√°pida e muito mais previs√≠vel do que esperar por um pacote da rede.  Especialmente agora que todo mundo tem um SSD e todos os nossos caches est√£o em SSDs.  Nos SSDs modernos, um atraso muito pequeno, geralmente em dezenas de microssegundos.  Al√©m disso, voc√™ pode executar o Nginx com v√°rios fluxos de trabalho para que um manipulador de eventos lento n√£o bloqueie solicita√ß√µes em outros processos.  Na maioria das vezes, voc√™ pode confiar no Nginx para processar solicita√ß√µes de forma r√°pida e eficiente. <br><br><h1>  Desempenho do SSD: nem sempre como prometido </h1><br>  Como voc√™ deve ter adivinhado, essas suposi√ß√µes nem sempre s√£o verdadeiras.  Se cada leitura sempre leva 50 Œºs, a leitura de 0,19 MB em blocos de 4 KB (e lemos em blocos ainda maiores) levar√° apenas 2 ms.  Mas os testes mostraram que o tempo at√© o primeiro byte √†s vezes √© muito pior, especialmente nos percentis 99 e 999.  Em outras palavras, a leitura mais lenta de cada 100 (ou 1000) leituras geralmente leva muito mais tempo. <br><br>  As unidades de estado s√≥lido s√£o muito r√°pidas, mas conhecidas por sua complexidade.  Eles possuem computadores nessa fila e reordenam a E / S e tamb√©m executam v√°rias tarefas em segundo plano, como coleta de lixo e desfragmenta√ß√£o.  De tempos em tempos, as solicita√ß√µes diminuem visivelmente.  Meu colega <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ivan Bobrov</a> lan√ßou v√°rios benchmarks de E / S e registrou atrasos de leitura de at√© 1 segundo.  Al√©m disso, alguns de nossos SSDs apresentam mais picos de desempenho do que outros.  No futuro, levaremos esse indicador em considera√ß√£o ao comprar um SSD, mas agora precisamos desenvolver uma solu√ß√£o para o equipamento existente. <br><br><h1>  Distribui√ß√£o uniforme de carga com <code>SO_REUSEPORT</code> </h1><br>  √â dif√≠cil evitar uma resposta lenta a cada 1000 solicita√ß√µes, mas o que realmente n√£o queremos √© bloquear as 1000 solicita√ß√µes restantes por um segundo inteiro.  Conceitualmente, o Nginx √© capaz de processar muitas solicita√ß√µes em paralelo, mas inicia apenas um manipulador de eventos por vez.  Ent√£o, adicionei uma m√©trica especial: <br><br><pre> <code class="hljs pgsql">gettimeofday(&amp;<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); num_events = epoll_wait(epfd, <span class="hljs-comment"><span class="hljs-comment">/*returned=*/</span></span>events, events_len, <span class="hljs-comment"><span class="hljs-comment">/*timeout=*/</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>); // events <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> list <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> active events // handle event[<span class="hljs-number"><span class="hljs-number">0</span></span>]: incoming request <span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> http://example.com/ gettimeofday(&amp;event_start_handle, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); // handle event[<span class="hljs-number"><span class="hljs-number">1</span></span>]: send <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> response <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> http://cloudflare.com/ timersub(&amp;event_start_handle, &amp;<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>, &amp;event_loop_blocked);</code> </pre> <br>  O 99¬∫ percentil (p99) <code>event_loop_blocked</code> excedeu 50% do nosso TTFB.  Em outras palavras, metade do tempo ao atender a uma solicita√ß√£o √© o resultado do bloqueio do ciclo de processamento de eventos por outras solicita√ß√µes.  <code>event_loop_blocked</code> mede apenas metade do bloqueio (porque as chamadas pendentes para <code>epoll_wait()</code> n√£o <code>epoll_wait()</code> medidas), portanto, a propor√ß√£o real do tempo bloqueado √© muito maior. <br><br>  Cada uma de nossas m√°quinas executa o Nginx com 15 fluxos de trabalho, ou seja, uma E / S lenta bloquear√° no m√°ximo 6% das solicita√ß√µes.  Mas os eventos n√£o s√£o distribu√≠dos igualmente: o trabalhador principal recebe 11% das solicita√ß√µes. <br><br>  <code>SO_REUSEPORT</code> pode resolver o problema de distribui√ß√£o desigual.  Marek Maikovsky escreveu anteriormente sobre a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">desvantagem</a> dessa abordagem no contexto de outras inst√¢ncias do Nginx, mas aqui voc√™ pode ignor√°-la principalmente: as conex√µes upstream no cache s√£o dur√°veis, para que voc√™ possa negligenciar um ligeiro aumento no atraso ao abrir a conex√£o.  Essa altera√ß√£o de configura√ß√£o sozinha com a ativa√ß√£o do <code>SO_REUSEPORT</code> melhorou o pico de p99 em 33%. <br><br><h1>  Movendo read () para um pool de threads: n√£o √© um marcador de prata </h1><br>  A solu√ß√£o √© tornar o read () sem bloqueio.  Na verdade, essa fun√ß√£o √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implementada no Nginx normal</a> !  Usando a seguinte configura√ß√£o, read () e write () s√£o executados no conjunto de encadeamentos e n√£o bloqueiam o loop de eventos: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">aio</span></span> threads; <span class="hljs-attribute"><span class="hljs-attribute">aio_write</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>;</code> </pre> <br>  Mas testamos essa configura√ß√£o e, em vez de melhorar o tempo de resposta em 33 vezes, notamos apenas uma pequena altera√ß√£o na p99, a diferen√ßa est√° dentro da margem de erro.  O resultado foi muito desanimador, ent√£o adiamos temporariamente essa op√ß√£o. <br><br>  Existem v√°rias raz√µes pelas quais n√£o tivemos melhorias significativas, como os desenvolvedores do Nginx.  No teste, eles usaram 200 conex√µes simult√¢neas para solicitar arquivos de 4 MB ao disco r√≠gido.  Os Winchesters t√™m muito mais lat√™ncia de E / S; portanto, a otimiza√ß√£o tem um efeito maior. <br><br>  Al√©m disso, estamos preocupados principalmente com o desempenho do p99 (e p999).  A otimiza√ß√£o do atraso m√©dio n√£o resolve necessariamente o problema de pico de emiss√£o. <br><br>  Finalmente, em nosso ambiente, os tamanhos de arquivo t√≠picos s√£o muito menores.  90% de nossos acertos no cache s√£o menores que 60 KB.  Quanto menores os arquivos, menos casos de bloqueio (geralmente lemos o arquivo inteiro em duas leituras). <br><br>  Vamos examinar a E / S do disco quando atingida no cache: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/     https:/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/example.com    0xCAFEBEEF fd = open("/cache</span></span><span class="hljs-regexp"><span class="hljs-regexp">/prefix/dir</span></span><span class="hljs-regexp"><span class="hljs-regexp">/EF/</span></span>BE/CAFEBEEF<span class="hljs-string"><span class="hljs-string">", O_RDONLY); //    32    //    ,  "</span></span>aio threads<span class="hljs-string"><span class="hljs-string">"  read(fd, buf, 32*1024);</span></span></code> </pre> <br>  32K nem sempre s√£o lidos.  Se os cabe√ßalhos forem pequenos, voc√™ precisar√° ler apenas 4 KB (n√£o usamos E / S diretamente, portanto o kernel arredondar√° para 4 KB).  <code>open()</code> parece inofensivo, mas na verdade consome recursos.  No m√≠nimo, o kernel deve verificar se o arquivo existe e se o processo de chamada tem permiss√£o para abri-lo.  Ele precisa encontrar o inode para <code>/cache/prefix/dir/EF/BE/CAFEBEEF</code> , e para isso ele ter√° que procurar <code>CAFEBEEF</code> em <code>/cache/prefix/dir/EF/BE/</code> .  Em suma, no pior dos casos, o kernel realiza esta pesquisa: <br><br><pre> <code class="hljs pgsql">/<span class="hljs-keyword"><span class="hljs-keyword">cache</span></span> /<span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>/prefix /<span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>/prefix/dir /<span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>/prefix/dir/EF /<span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>/prefix/dir/EF/BE /<span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>/prefix/dir/EF/BE/CAFEBEEF</code> </pre> <br>  S√£o 6 leituras separadas que o <code>open()</code> produz, em compara√ß√£o com 1 <code>read()</code> !  Felizmente, na maioria dos casos, a pesquisa cai no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cache</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dentry</a> e n√£o atinge o SSD.  Mas √© claro que o processamento de <code>read()</code> em um pool de threads √© apenas metade da imagem. <br><br><h1>  Acorde final: aberto sem bloqueio () em conjuntos de encadeamentos </h1><br>  Portanto, fizemos uma altera√ß√£o no Nginx para que <code>open()</code> seja executado principalmente dentro do pool de threads e n√£o bloqueie o loop de eventos.  E aqui est√° o resultado de abrir () e ler () sem bloqueio ao mesmo tempo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d70/b1a/84b/d70b1a84b46934921ffd5a1fd7e7182a.png"><br><br>  Em 26 de junho, lan√ßamos as altera√ß√µes nos 5 data centers mais movimentados e no dia seguinte - em todos os outros 146 data centers do mundo.  O pico total de TT99 p99 diminuiu 6 vezes.  De fato, se resumirmos o tempo todo o processamento de 8 milh√µes de solicita√ß√µes por segundo, pouparemos √† Internet 54 anos de espera todos os dias. <br><br>  Nossa s√©rie de eventos ainda n√£o se livrou completamente dos bloqueios.  Em particular, o bloqueio ainda ocorre na primeira vez em que o arquivo √© armazenado em cache ( <code>open(O_CREAT)</code> e <code>rename()</code> ) ou ao atualizar a revalida√ß√£o.  Mas esses casos s√£o raros se comparados aos acessos ao cache.  No futuro, consideraremos a possibilidade de mover esses elementos para fora do loop de processamento de eventos para melhorar ainda mais o fator de atraso p99. <br><br><h1>  Conclus√£o </h1><br>  O Nginx √© uma plataforma poderosa, mas escalar cargas extremamente altas de E / S do Linux pode ser uma tarefa assustadora.  O Nginx padr√£o transfere a leitura em threads separados, mas em nossa escala, geralmente precisamos dar um passo adiante. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt419023/">https://habr.com/ru/post/pt419023/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt419011/index.html">Jinja2 no mundo C ++, parte dois. Renderiza√ß√£o</a></li>
<li><a href="../pt419013/index.html">Atribui√ß√£o baseada em funil para empresas B2B SaaS - considerando o valor de todos os esfor√ßos de marketing</a></li>
<li><a href="../pt419017/index.html">O que h√° de novo no ConstraintLayout 1.1</a></li>
<li><a href="../pt419019/index.html">AlterEgo: um dispositivo que pode ler (alguns) pensamentos</a></li>
<li><a href="../pt419021/index.html">Os principais tipos de impress√£o e seus recursos</a></li>
<li><a href="../pt419025/index.html">@Pythonetc compilation, julho de 2018</a></li>
<li><a href="../pt419027/index.html">Seguran√ßa da informa√ß√£o de pagamentos banc√°rios sem dinheiro. Parte 6 - An√°lise do Crime Banc√°rio</a></li>
<li><a href="../pt419029/index.html">Fortnite se tornou um fen√¥meno social. Os pais est√£o cada vez mais contratando treinadores para seus filhos e brincando com eles</a></li>
<li><a href="../pt419033/index.html">Uma pequena observa√ß√£o sobre o t√≥pico de execu√ß√£o do vue.js no cluster kubernetes</a></li>
<li><a href="../pt419035/index.html">Livro ‚ÄúHead First Agile. Gerenciamento flex√≠vel de projetos ‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>