<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏻 🔚 👨‍👧‍👧 大灾变：黑暗的未来：静态分析和类Rogue游戏 🚧 ⬜️ 👨🏽‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您一定已经从标题中猜测到，今天的文章将重点关注软件源代码中的错误。 但不仅如此。 如果您不仅对C ++感兴趣，并且对阅读其他开发人员代码中的错误感兴趣，还对不寻常的视频游戏感兴趣，并且想知道什么是“ roguelikes”以及如何玩这些游戏，那么欢迎您继续阅读！ 

 在寻找不寻常的游戏时，我偶然发...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>大灾变：黑暗的未来：静态分析和类Rogue游戏</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/449488/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f8/70b/ef1/2f870bef158597577eac654a524b00ac.png" alt="图片5"></div><br> 您一定已经从标题中猜测到，今天的文章将重点关注软件源代码中的错误。 但不仅如此。 如果您不仅对C ++感兴趣，并且对阅读其他开发人员代码中的错误感兴趣，还对不寻常的视频游戏感兴趣，并且想知道什么是“ roguelikes”以及如何玩这些游戏，那么欢迎您继续阅读！ <br><a name="habracut"></a><br> 在寻找不寻常的游戏时，我偶然发现了《大<i>灾变：黑暗的未来》</i> ，该游戏在其他游戏中脱颖而出，这要归功于其图形基于黑色背景上排列的各种颜色的ASCII字符。 <br><br> 令这款游戏和其他类似游戏惊讶的一件事是它们内置了多少功能。 例如，特别是在《 <i>大地的裂变》中</i> ，由于有数十种参数，特征和初始场景可供使用，因此您甚至无法创建一个不带Google指导的冲动的角色，更不用说整个游戏中发生的事件的多种变化。 <br><br> 由于这是一款带有开源代码的游戏，并且是用C ++编写的，因此，如果没有积极参与开发的静态代码分析器PVS-Studio的检查，我们将无可奈何。 该项目的代码出奇的高品质，但是它仍然存在一些小缺陷，我将在本文中讨论其中一些缺陷。 <br><br>  PVS-Studio已经检查了很多游戏。 您可以在我们的文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">视频游戏开发中的静态分析：十大软件错误</a> ”中找到一些示例。 <br><br><h2> 逻辑学 </h2><br>  <b>范例1：</b> <br><br> 本示例显示了经典的复制粘贴错误。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V501</a>在'||'的左侧和右侧有相同的子表达式 运算符：rng（2，7）&lt;abs（z）||  rng（2，7）&lt;abs（z）overmap.cpp 1503 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> overmap::generate_sub( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z ) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( rng( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( z ) || rng( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( z ) ) { .... } .... }</code> </pre> <br> 两次检查相同的条件。 程序员复制了表达式，但忘记修改副本。 我不确定这是否是一个严重的错误，但事实是该检查无法按预期进行。 <br><br> 另一个类似的错误： <br><br><ul><li>  V501在'&amp;&amp;'运算符的左侧和右侧有相同的子表达式'one_in（100000 / to_turns &lt;int&gt;（dur））。  player_hardcoded_effects.cpp 547 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d92/a93/7ac/d92a937ac860e5f2fb5ded04b8e05683.png" alt="图片11"></div><br>  <b>范例2：</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V728</a>过度检查可以简化。  '（A &amp;&amp; B）||  （！A &amp;&amp;！B）'表达式等同于'bool（A）== bool（B）'表达式。  stock_ui.cpp 199 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inventory_selector_preset::sort_compare( .... ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> left_fav = g-&gt;u.inv.assigned.count( lhs.location-&gt;invlet ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> right_fav = g-&gt;u.inv.assigned.count( rhs.location-&gt;invlet ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( left_fav &amp;&amp; right_fav ) || ( !left_fav &amp;&amp; !right_fav ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .... } .... }</code> </pre> <br> 从逻辑上讲，这种情况是正确的，但它过于复杂。 编写此代码的人都应该怜悯将要维护它的程序员。 可以用更简单的形式重写它： <i>if（left_fav == right_fav）</i> 。 <br><br> 另一个类似的错误： <br><br><ul><li>  V728过度检查可以简化。  '（（A &amp;&amp;！B）||  （！A &amp;&amp; B）'表达式等同于'bool（A）！= Bool（B）'表达式。  iuse_actor.cpp 2653 </li></ul><br><h2> 离题我 </h2><br> 我很惊讶地发现，如今以“ roguelikes”之名进行的游戏只是老派流氓游戏中较为温和的代表。 一切始于1980年的<i>Rogue</i>游戏，该游戏启发了许多学生和程序员来创建自己的具有相似元素的游戏。 我想很多影响也来自桌面游戏<i>DnD</i>及其变体的社区。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4dc/d85/de3/4dcd85de3509609962cab730653f7ed1.png" alt="图片8"></div><br><h2> 微观优化 </h2><br>  <b>范例3：</b> <br><br> 该组的警告指向可能被优化而不是错误的斑点。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V801</a>性能<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下降</a> 。 最好将第二个函数参数重新定义为引用。 考虑用“ const ...＆type”替换“ const ... type”。  map.cpp 4644 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Stack&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;item&gt; use_amount_stack( Stack <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itype_id type ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;item&gt; ret; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.begin(); a != <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.end() &amp;&amp; quantity &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a-&gt;use_amount( type, ret ) ) { a = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.erase( a ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++a; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br> 在此代码中， <i>itype_id</i>实际上是伪装的<i>std :: string</i> 。 由于参数无论如何都是作为常量传递的，这意味着它是不可变的，因此简单地传递对变量的引用将有助于避免复制操作，从而提高性能并节省计算资源。 即使该字符串不太可能是一个长字符串，但每次都没有充分理由就将其复制是一个坏主意-尤其如此，因为此函数由各种调用程序调用，而这些调用程序又从外部获取<i>类型</i>并具有复制它。 <br><br> 类似问题： <br><br><ul><li>  V801性能下降。 最好重新定义第三个函数参数作为参考。 考虑用“ const ...＆evt_filter”替换“ const ... evt_filter”。 输入.cpp 691 </li><li>  V801性能下降。 最好将第五个函数参数重新定义为参考。 考虑用“ const ...＆color”替换“ const ... color”。 输出207 </li><li> 分析仪总共发出32种此类警告。 </li></ul><br>  <b>范例4：</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V813</a>性能<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下降</a> 。  'str'参数可能应该呈现为常量引用。  catacharset.cpp 256 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base64_encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( str.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; str[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'#'</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> input_length = str.length(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encoded_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( output_length, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'\0'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; input_length; ) { .... } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mod_table[input_length % <span class="hljs-number"><span class="hljs-number">3</span></span>]; i++ ) { encoded_data[output_length - <span class="hljs-number"><span class="hljs-number">1</span></span> - i] = <span class="hljs-string"><span class="hljs-string">'='</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"#"</span></span> + encoded_data; }</code> </pre> <br> 尽管参数是非常量的，但它在函数体内没有任何变化。 因此，为了优化起见，更好的解决方案是通过常量引用传递它，而不是强制编译器创建本地副本。 <br><br> 这个警告也不是一个人来的。 此类型的警告总数为26。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ff/557/9b3/4ff5579b36733a7bd46f4c3df6f30d90.png" alt="图片7"></div><br> 类似问题： <br><br><ul><li>  V813性能下降。  'message'参数可能应该呈现为常量引用。  json.cpp 1452 </li><li>  V813性能下降。  “ s”自变量可能应呈现为常量引用。  catacharset.cpp 218 </li><li> 依此类推... </li></ul><br><h2> 离题二 </h2><br> 一些经典的类似roguelike的游戏仍在积极开发中。 如果您查看<i>Cataclysm DDA</i>或<i>NetHack</i>的GitHub存储库，则会看到每天都提交更改。  <i>NetHack</i>实际上是仍在开发中的最古老的游戏：它于1987年7月发布，最新版本可追溯到2018年。 <br><br>  <i>矮人要塞</i> （ <i>Dwarf Fortress）</i>是最流行（尽管较年轻）的游戏类型之一。 开发工作始于2002年，第一个版本于2006年发布。其座右铭“输得很开心”反映了这一游戏不可能取胜的事实。 在2007年， <i>矮人要塞</i> （ <i>Dwarf Fortress</i> ）每年在ASCII GAMES网站上举行的投票中被评为“年度最佳Roguelike游戏”。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e39/7fb/efa/e397fbefa4204777cc74d97e2b8e52e9.png" alt="图片6"></div><br> 顺便说一下，粉丝们可能会很高兴知道<i>矮人要塞</i>即将由两个有经验的改装人员添加的增强型32位图形加入Steam。 高级版本还将获得其他音乐曲目和Steam Workshop支持。 付费副本的所有者可以根据需要切换到旧的ASCII图形。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更多</a> <br><br><h2> 覆盖赋值运算符 </h2><br>  <b>示例5、6：</b> <br><br> 这里有几个有趣的警告。 <br><br>  V690'JsonObject'类实现了副本构造函数，但缺少'='运算符。 使用这样的类是危险的。  json.h 647 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonObject</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: .... JsonIn *jsin; .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: JsonObject( JsonIn &amp;jsin ); JsonObject( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> JsonObject &amp;jsobj ); JsonObject() : positions(), start( <span class="hljs-number"><span class="hljs-number">0</span></span> ), end( <span class="hljs-number"><span class="hljs-number">0</span></span> ), jsin( <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) {} ~JsonObject() { finish(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// moves the stream to the end of the object .... void JsonObject::finish() { .... } .... }</span></span></code> </pre> <br> 此类具有复制构造函数和析构函数，但不覆盖赋值运算符。 问题在于，自动生成的赋值运算符只能将指针分配给<i>JsonIn</i> 。 结果，类<i>JsonObject的</i>两个对象都将指向相同的<i>JsonIn</i> 。 我不能肯定地说这种情况在当前版本中是否会发生，但是肯定有一天会有人陷入这种陷阱。 <br><br> 下一个类也有类似的问题。 <br><br>  V690'JsonArray'类实现了复制构造函数，但缺少'='运算符。 使用这样的类是危险的。  json.h 820 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonArray</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: .... JsonIn *jsin; .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: JsonArray( JsonIn &amp;jsin ); JsonArray( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> JsonArray &amp;jsarr ); JsonArray() : positions(), ...., jsin( <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) {}; ~JsonArray() { finish(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// move the stream position to the end of the array void JsonArray::finish() { .... } }</span></span></code> </pre> <br> 在文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">两大法则</a> ”中详细说明了不覆盖复杂类中的赋值运算符的危险。 <br><br>  <b>示例7、8：</b> <br><br> 这两个还处理赋值运算符重载，但是这次是它的特定实现。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V794</a>应该保护赋值运算符免受'this ==＆other'的影响。  mattack_common.h 49 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringRef</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringRefTestAccess</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* m_start; size_type m_size; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* m_data = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = ( StringRef <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;other ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> -&gt; StringRef&amp; { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] m_data; m_data = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; m_start = other.m_start; m_size = other.m_size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br> 此实现无法防止潜在的自我分配，这是不安全的做法。 也就是说，将<i>*此</i>引用传递给此运算符可能会导致内存泄漏。 <br><br> 这是一个具有异常副作用的不正确覆盖的赋值运算符的类似示例： <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V794</a>应该保护赋值运算符免受'this ==＆rhs'的影响。  player_activity.cpp 38 <br><br><pre> <code class="cpp hljs">player_activity &amp;player_activity::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> player_activity &amp;rhs ) { type = rhs.type; .... targets.clear(); targets.reserve( rhs.targets.size() ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform( rhs.targets.begin(), rhs.targets.end(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter( targets ), []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> item_location &amp; e ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.clone(); } ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br> 该代码也没有检查自我分配，此外，它还有一个要填充的向量。 使用赋值运算符的这种实现，向其自身分配对象将导致<i>目标</i>字段中的向量加倍，并且其中某些元素会损坏。 但是，在<i>transform</i>之前先加上<i>clear</i> ，这将清除对象的向量，从而导致数据丢失。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/618/b4e/dd8/618b4edd868317d8e9e6a0e5d82cb5d0.png" alt="图片3"></div><br><h2> 第三题 </h2><br>  2008年，流氓分子甚至以史诗般的标题“柏林解释”获得了正式的定义。 据此，所有此类游戏都具有以下要素： <br><br><ul><li> 随机生成的世界，提高了可重玩性； </li><li>  Permadeath：如果你的角色去世，他们就永远死了，所有的物品都会丢失； </li><li> 回合制游戏：任何变化仅与玩家的动作一起发生； 时间流暂停，直到玩家执行动作为止； </li><li> 生存：资源匮乏。 </li></ul><br> 最后，roguelike的最重要特征主要集中在探索世界，寻找物品的新用途以及地下城爬行。 <br><br> 在《 <i>大地</i>的<i>裂变》 DDA中</i> ，您的角色经常结冰，挨饿，口渴，最重要的是，用两只触手代替两只脚，这是很常见的情况。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fe/f8e/b69/8fef8eb69a48050011726fe47ec1da35.png" alt="图片15"></div><br><h2> 细节很重要 </h2><br>  <b>范例9：</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V1028</a>可能的溢出。 考虑将“开始+较大”运算符的操作数强制转换为“ size_t”类型，而不是结果。  worldfactory.cpp 638 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> worldfactory::draw_mod_list( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;start, .... ) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> larger = ....; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iNum = ....; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( .... ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( iNum &gt;= <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;( start ) &amp;&amp; iNum &lt; <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;( start + larger ) ) { .... } .... } .... }</code> </pre> <br> 程序员似乎想采取预防措施以防溢出。 但是，提高总和的类型不会有任何区别，因为在此之前，溢出会在加值的步骤中发生，并且升值将在毫无意义的值上进行。 为避免这种情况，应仅将其中一个参数<i>强制</i>转换为更广泛的类型： <i>（static_cast &lt;size_t&gt;（start）+ large）</i> 。 <br><br>  <b>范例10：</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V530</a>需要使用功能“尺寸”的返回值。  worldfactory.cpp 1340 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> worldfactory::world_need_lua_build( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> world_name ) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> LUA .... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Prevent unused var error when LUA and RELEASE enabled. world_name.size(); return false; }</span></span></span></span></code> </pre> <br> 对于这种情况，有一个技巧。 如果最后得到一个未使用的变量，并且想取消编译器警告，则只需编写<i>（void）world_name，</i>而不是对该变量调用方法。 <br><br>  <b>示例11：</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V812</a>性能<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下降</a> 。 无效使用“计数”功能。 可以通过调用“ find”函数代替它。 播放器.cpp 9600 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> player::read( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> inventory_position, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> continuous ) { .... player_activity activity; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !continuous || !<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::all_of( learners.begin(), learners.end(), [&amp;]( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;npc *, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; elem ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::count( activity.values.begin(), activity.values.end(), elem.first-&gt;getID() ) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } ) { .... } .... }</code> </pre> <br> 将<i>count</i>与零进行比较的事实表明，程序员希望找出<i>活动是否</i>包含至少一个必需的元素。 但是<i>count</i>必须遍历整个容器，因为它对元素的所有出现进行计数。 使用<i>find</i>可以更快地完成工作，一旦<i>找到</i>第一个事件，它将停止。 <br><br>  <b>示例12：</b> <br><br> 如果您知道有关<i>char</i>类型的一个棘手的细节，就很容易找到此错误。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V739</a> EOF不应与“ char”类型的值进行比较。  “ ch”应为“ int”类型。  json.cpp 762 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> JsonIn::skip_separator() { <span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch == <span class="hljs-string"><span class="hljs-string">','</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ate_separator ) { .... } .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch == EOF) { .... }</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76e/830/467/76e830467157aab1aad9e710c195b03d.png" alt="图片13"></div><br> 除非您知道<i>EOF</i>定义为-1，否则这是您不容易发现的错误之一。 因此，将其与<i>signed char</i>类型的变量进行比较时，在几乎每种情况下，条件的评估结果均为<i>false</i> 。 唯一的例外是代码为0xFF（255）的字符。 在比较中使用时，它将变为-1，从而使条件成立。 <br><br>  <b>示例13：</b> <br><br> 这个小错误可能有一天会变得至关重要。 毕竟，有充分的理由在CWE列表中找到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-834</a> 。 请注意，该项目已触发此警告五次。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V663</a>可能出现无限循环。  'cin.eof（）'条件不足以使它脱离循环。 考虑将'cin.fail（）'函数调用添加到条件表达式中。 动作.cpp 46 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_keymap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp;keymap_txt, .... )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !keymap_txt.eof() ) { .... } }</code> </pre> <br> 如警告所述，仅从文件读取时检查EOF是不够的-您还必须通过调用<i>cin.fail（）</i>来检查输入失败。 让我们修复代码以使其更安全： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !keymap_txt.eof() ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(keymap_txt.fail()) { keymap_txt.clear(); keymap_txt.ignore(numeric_limits&lt;streamsize&gt;::max(),<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... }</code> </pre> <br>  <i>keymap_txt.clear（）</i>的目的是在发生读取错误后清除流上的错误状态（标志），以便您可以读取其余文本。 使用参数<i>numeric_limits &lt;</i> <i>streamsize</i> <i>&gt; :: max（）</i>和换行符调用<i>keymap_txt.ignore</i>可以跳过字符串的其余部分。 <br><br> 有一种更简单的方法来停止读取： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !keymap_txt ) { .... }</code> </pre> <br> 当置于逻辑上下文中时，流将自身转换为等于<i>true</i>的值，直到达到<i>EOF</i> 。 <br><br><h2> 第四题 </h2><br> 我们时代最流行的与roguelike相关的游戏结合了原始roguelike和其他类型的元素，例如平台游戏，策略等。 这样的游戏已被称为“类rogue”或“ roguelite”。 其中包括著名的标题，如《 <i>不要挨饿》</i> ， <i>《以撒的结合》</i> ，《 <i>FTL：比光明快》</i> ，《 <i>黑暗地牢》</i>甚至《 <i>暗黑破坏神》</i> 。 <br><br> 但是，roguelike和roguelite之间的区别有时可能很小，以至于您无法确定游戏所属的类别。 有些人认为<i>矮人要塞</i>从严格意义上讲不是类盗贼，而另一些人则认为<i>暗黑破坏神</i>是一款经典的类盗贼游戏。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/330/a83/895/330a838954a71a90e8bd65764a9169a8.png" alt="图片1"></div><br><h2> 结论 </h2><br> 即使该项目被证明总体上是高质量的，只有很少的严重缺陷，但这并不意味着它不能进行静态分析。 静态分析的功能是常规使用，而不是像我们为普及所做的一次性检查。 如果定期使用静态分析器，则可以在开发的最早阶段帮助您检测错误，从而使它们的修复成本更低。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计算示例</a> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18d/90c/4b5/18d90c4b57268f6f55e2721a68fc017c.png" alt="图片2"></div><br> 该游戏仍在不断开发中，活跃的modder社区正在为此进行开发。 顺便说一句，它已被移植到多个平台，包括iOS和Android。 因此，如果您有兴趣，请尝试一下！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN449488/">https://habr.com/ru/post/zh-CN449488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN449476/index.html">一种新型的SSD存储将减少数据中心的功耗-工作原理</a></li>
<li><a href="../zh-CN449478/index.html">通过Xib将UICollectionViews添加到自定义UITableViewCell</a></li>
<li><a href="../zh-CN449480/index.html">选择适当的错误跟踪</a></li>
<li><a href="../zh-CN449484/index.html">我们在InfluxDB，Grafana，Docker和Raspberry Pi上创建空气质量控制传感器</a></li>
<li><a href="../zh-CN449486/index.html">浏览器游戏大量外流</a></li>
<li><a href="../zh-CN449490/index.html">Slurm：Kubernetes强烈。 计划和奖金</a></li>
<li><a href="../zh-CN449494/index.html">AI界面及其位置</a></li>
<li><a href="../zh-CN449496/index.html">Hackathon DevDays'19（第2部分）：用于IntelliJ IDEA中的电报和语法检查的声音消息解析器</a></li>
<li><a href="../zh-CN449498/index.html">分析师：微软估计将很快超过1万亿美元</a></li>
<li><a href="../zh-CN449500/index.html">如果有很多程序员来访问，该如何惊慌呢？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>