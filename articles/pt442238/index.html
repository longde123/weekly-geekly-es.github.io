<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöè ‚ò¢Ô∏è ü¶ã Usando contas inteligentes Waves: de leil√µes a programas de b√¥nus üö£üèæ üëµüèΩ üëµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Blockchain geralmente √© associado apenas a criptomoedas, mas o escopo da tecnologia DLT √© muito mais amplo. Uma das √°reas mais promissoras para o us...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usando contas inteligentes Waves: de leil√µes a programas de b√¥nus</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/442238/"><img src="https://habrastorage.org/webt/pi/sa/8g/pisa8gy_wbapc-kdf-n026wjuko.png" alt="imagem"><br><br>  <i>O Blockchain geralmente √© associado apenas a criptomoedas, mas o escopo da tecnologia DLT √© muito mais amplo.</i>  <i>Uma das √°reas mais promissoras para o uso da blockchain √© um contrato inteligente que √© executado automaticamente e n√£o requer confian√ßa entre as partes que o conclu√≠ram.</i> <i><br></i> <br>  <b>RIDE - linguagem para contratos inteligentes</b> <br><br>  A Waves desenvolveu uma linguagem especial para contratos inteligentes - RIDE.  Sua documenta√ß√£o completa est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  E aqui - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo sobre este assunto</a> em Habr√©. <br><br>  O contrato no RIDE √© um predicado e retorna "verdadeiro" ou "falso" na sa√≠da.  Por conseguinte, uma transa√ß√£o √© gravada na blockchain ou rejeitada.  Um contrato inteligente garante totalmente o cumprimento de condi√ß√µes especificadas.  Atualmente, a gera√ß√£o de transa√ß√µes a partir de um contrato no RIDE n√£o √© poss√≠vel. <br><a name="habracut"></a><br>  Hoje, existem dois tipos de contratos inteligentes da Waves: contas inteligentes e ativos inteligentes.  Uma conta inteligente √© uma conta de usu√°rio comum, mas √© definido um script que controla todas as transa√ß√µes.  Um script de conta inteligente pode ser assim: <br><br><pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> | <span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  tx √© uma transa√ß√£o processada que permitimos usar o mecanismo de correspond√™ncia de padr√µes apenas se n√£o for uma transa√ß√£o de transfer√™ncia.  A correspond√™ncia de padr√µes RIDE √© usada para verificar o tipo de transa√ß√£o.  No script de conta inteligente, todos os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tipos de transa√ß√£o</a> existentes podem ser processados. <br><br>  Al√©m disso, vari√°veis ‚Äã‚Äãpodem ser declaradas no script, constru√ß√µes "if-then-else" e outros m√©todos para a verifica√ß√£o completa das condi√ß√µes podem ser usados.  Para que os contratos tenham conclus√£o e complexidade (custo) comprov√°veis, f√°ceis de prever antes do in√≠cio do contrato, o RIDE n√£o cont√©m loops e operadores como jump. <br><br>  Entre outros recursos das contas Waves est√° a presen√ßa de um "estado", isto √©, o estado da conta.  Um n√∫mero infinito de pares (chave, valor) pode ser gravado no estado da conta usando transa√ß√µes de dados (DataTransaction).  Al√©m disso, essas informa√ß√µes podem ser processadas por meio da API REST e diretamente no contrato inteligente. <br><br>  Cada transa√ß√£o pode conter uma s√©rie de provas, nas quais voc√™ pode inserir a assinatura do participante, o ID da transa√ß√£o necess√°ria etc. <br><br>  Trabalhar com o RIDE por meio do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IDE</a> permite visualizar a forma compilada do contrato (se ele for compilado), criar novas contas e definir scripts para ele, al√©m de enviar transa√ß√µes pela linha de comando. <br><br>  Por um ciclo completo, incluindo a cria√ß√£o de uma conta, a instala√ß√£o de um contrato inteligente e o envio de transa√ß√µes, voc√™ tamb√©m pode usar a biblioteca para interagir com a API REST (por exemplo, C #, C, Java, JavaScript, Python, Rust, Elixir).  Para come√ßar a trabalhar com o IDE, basta clicar no bot√£o NOVO. <br><br>  As possibilidades de uso de contratos inteligentes s√£o amplas: da proibi√ß√£o de transa√ß√µes a determinados endere√ßos (a "lista negra") aos dApps complexos. <br><br>  <i>Agora, vamos examinar exemplos espec√≠ficos do uso de contratos inteligentes nos neg√≥cios: durante leil√µes, seguros e cria√ß√£o de programas de fidelidade.</i> <i><br></i> <br>  <b>Leil√µes</b> <br><br>  Uma das condi√ß√µes para um leil√£o bem-sucedido √© a transpar√™ncia: os concorrentes devem ter certeza de que √© imposs√≠vel manipular os lances.  Isso pode ser alcan√ßado gra√ßas ao blockchain, onde os dados inalterados de todas as apostas e o hor√°rio em que foram feitas estar√£o dispon√≠veis para todos os participantes. <br><br>  Na blockchain Waves, os lances podem ser registrados no estado da conta do leil√£o via DataTransaction. <br><br>  Voc√™ tamb√©m pode definir o hor√°rio de in√≠cio e t√©rmino do leil√£o usando n√∫meros de bloco: a frequ√™ncia de gera√ß√£o de bloco no blockchain Waves √© de aproximadamente <b>60</b> segundos. <br><br>  <i><b>1. Leil√£o ingl√™s de aumento de pre√ßos</b></i> <br><br>  Participantes no leil√£o em ingl√™s, concorrendo entre si.  Cada nova aposta deve exceder a anterior.  O leil√£o termina quando n√£o houver mais disposi√ß√£o para exceder o √∫ltimo lance.  Nesse caso, o maior lance deve fornecer o valor declarado. <br><br>  H√° tamb√©m uma op√ß√£o de leil√£o na qual o vendedor define o pre√ßo m√≠nimo para o lote e o pre√ßo final deve exceder.  Caso contr√°rio, o lote n√£o ser√° vendido. <br><br>  Neste exemplo, estamos trabalhando com uma conta criada especialmente para o leil√£o.  A dura√ß√£o do leil√£o √© de 3000 blocos e o pre√ßo inicial do lote √© de 0,001 WAVES.  Um participante pode fazer uma aposta enviando uma DataTransaction com a chave "price" e o valor de sua oferta; nas provas de transa√ß√£o, voc√™ precisa adicionar a chave p√∫blica e a assinatura do remetente. <br><br>  O pre√ßo da nova aposta deve ser maior que o pre√ßo atual dessa chave, e o participante deve ter pelo menos [novo_estado + comiss√£o] tokens na conta.  O endere√ßo do licitante deve ser inserido no campo "remetente" no DataTransaction, e a altura atual do bloco de lances deve estar dentro do per√≠odo do leil√£o. <br><br>  Se, no final do leil√£o, o licitante tiver definido o pre√ßo mais alto, ele poder√° enviar ExchangeTransaction para pagar o lote correspondente no pre√ßo indicado e no par de moedas. <br><br><pre> <code class="scala hljs">let startHeight = <span class="hljs-number"><span class="hljs-number">384120</span></span> let finishHeight = startHeight + <span class="hljs-number"><span class="hljs-number">3000</span></span> let startPrice = <span class="hljs-number"><span class="hljs-number">100000</span></span> #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let token = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; #,      let currentPrice = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #    then extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> startPrice #    let newPrice = extract(getInteger(d.data, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #       let pk = d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) let priceIsBigger = newPrice &gt; currentPrice let fee = <span class="hljs-number"><span class="hljs-number">700000</span></span> let hasMoney = wavesBalance(address) + fee &gt;= newPrice let correctFields = size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; extract(getString(d.data, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>)) == toBase58String(address.bytes) startHeight &lt;= height &amp;&amp; height &lt;= finishHeight &amp;&amp; priceIsBigger &amp;&amp; hasMoney &amp;&amp; correctFields &amp;&amp; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o : <span class="hljs-type"><span class="hljs-type">Order</span></span> =&gt; #       let pk = o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) let senderIsWinner = address == addressFromString(extract(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>))) #,    ,    let correctAssetPair = o.assetPair.amountAsset == token &amp;&amp; ! isDefined(o.assetPair.priceAsset) let correctAmount = o.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> let correctPrice = o.price == extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) height &gt; finishHeight &amp;&amp; senderIsWinner &amp;&amp; correctAssetPair &amp;&amp; correctAmount &amp;&amp; correctPrice &amp;&amp; sigVerify(o.bodyBytes, o.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <i><b>2. Leil√£o holand√™s de queda de pre√ßos</b></i> <br><br>  Em um leil√£o holand√™s, inicialmente, muito √© oferecido a um pre√ßo superior ao que o comprador est√° disposto a pagar.  O pre√ßo √© reduzido passo a passo at√© que um dos participantes concorde em comprar o lote pelo pre√ßo atual. <br><br>  Neste exemplo, usamos as mesmas constantes que a anterior, bem como a etapa de pre√ßo ao diminuir o delta.  O script da conta verifica se o participante √© realmente o primeiro a apostar.  Nas provas de transa√ß√£o, voc√™ precisa adicionar a chave p√∫blica e a assinatura do remetente, caso contr√°rio, DataTransaction n√£o ser√° aceito pelo blockchain. <br><br><pre> <code class="scala hljs">let startHeight = <span class="hljs-number"><span class="hljs-number">384120</span></span> let finishHeight = startHeight + <span class="hljs-number"><span class="hljs-number">3000</span></span> let startPrice = <span class="hljs-number"><span class="hljs-number">100000000</span></span> let delta = <span class="hljs-number"><span class="hljs-number">100</span></span> #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let token = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; let currentPrice = startPrice - delta * (height - startHeight) #   -  <span class="hljs-string"><span class="hljs-string">"price"</span></span> let newPrice = extract(getInteger(d.data, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #       let pk = d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) let correctFields = extract(getString(d.data, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>)) == toBase58String(address.bytes) &amp;&amp; size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; newPrice == currentPrice #,         <span class="hljs-string"><span class="hljs-string">"sender"</span></span> let noBetsBefore = !isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>)) let fee = <span class="hljs-number"><span class="hljs-number">700000</span></span> let hasMoney = wavesBalance(address) - fee &gt;= newPrice startHeight &lt;= height &amp;&amp; height &lt;= finishHeight &amp;&amp; noBetsBefore &amp;&amp; hasMoney &amp;&amp; correctFields &amp;&amp; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o : <span class="hljs-type"><span class="hljs-type">Order</span></span> =&gt; #       let pk = o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) #,           sender let senderIsWinner = address == addressFromString(extract(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>))) #,  mount   ,   - - waves let correctAssetPair = o.assetPair.amountAsset == token &amp;&amp; ! isDefined(o.assetPair.priceAsset) let correctAmount = o.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> let correctPrice = o.price == extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) height &gt; finishHeight &amp;&amp; senderIsWinner &amp;&amp; correctAssetPair &amp;&amp; correctAmount &amp;&amp; correctPrice &amp;&amp; sigVerify(o.bodyBytes, o.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br>  <i><b>3. Leil√£o pago</b></i> <br><br>  "Tudo pago" - um leil√£o, cujos participantes pagam a oferta, pagam, independentemente de quem ganha o lote.  Cada novo participante paga a aposta e o participante que fez a aposta m√°xima ganha o lote. <br><br>  No nosso exemplo, cada participante do leil√£o faz um lance por meio de uma DataTransaction com (chave, valor) * = ("vencedor", endere√ßo), ("pre√ßo", pre√ßo).  Essa DataTransaction √© aprovada apenas se, para esse participante, j√° houver uma TransferTransaction com sua assinatura e sua taxa for maior que todas as anteriores.  O leil√£o continua at√© o fim da altura. <br><br><pre> <code class="scala hljs">let startHeight = <span class="hljs-number"><span class="hljs-number">1000</span></span> let endHeight = <span class="hljs-number"><span class="hljs-number">2000</span></span> let token = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d: <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; #   -  <span class="hljs-string"><span class="hljs-string">"price"</span></span> let newPrice = extract(getInteger(d.data, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #       let pk = d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) #        let proofTx = extract(transactionById(d.proofs[<span class="hljs-number"><span class="hljs-number">2</span></span>])) height &gt; startHeight &amp;&amp; height &lt; endHeight &amp;&amp; size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> #,   ,    ,   ,    &amp;&amp; extract(getString(d.data, <span class="hljs-string"><span class="hljs-string">"winner"</span></span>)) == toBase58String(address.bytes) &amp;&amp; newPrice &gt; extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #,    &amp;&amp; sigVerify(d.bodyBytes, d.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) #  ,    &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> proofTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> tr : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; tr.sender == address &amp;&amp; tr.amount == newPrice <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) || ( height &gt; endHeight &amp;&amp; extract(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"winner"</span></span>)) == toBase58String((addressFromRecipient(t.recipient)).bytes) &amp;&amp; t.assetId == token &amp;&amp; t.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre> <br>  <b>Seguros / Crowdfunding</b> <br><br>  Considere uma situa√ß√£o em que voc√™ precisa garantir ativos do usu√°rio contra perdas financeiras.  Por exemplo, o usu√°rio deseja obter uma garantia de que, se o token se depreciar, ele poder√° devolver o valor total pago por esses tokens e estar√° pronto para pagar uma quantidade razo√°vel de seguro. <br><br>  Para implementar isso, voc√™ precisa emitir "tokens de seguro".  Em seguida, um script √© instalado na conta do tomador do seguro que permite executar apenas as ExchangeTransactions que atendem a determinadas condi√ß√µes. <br><br>  Para evitar gastos duplos, voc√™ precisa solicitar que o usu√°rio envie DataTransaction antecipadamente para a conta do segurado com (chave, valor) = (purchaseTransactionId, sellOrderId) e pro√≠ba o envio de DataTransactions com a chave j√° usada. <br><br>  Portanto, as provas do usu√°rio devem conter o ID da transa√ß√£o da compra do token de seguro.  O par de moedas deve ser o mesmo que na transa√ß√£o de compra.  O custo tamb√©m deve ser igual ao registrado no momento da compra, menos o pre√ßo do seguro. <br><br>  Entende-se que subsequentemente a conta de seguro resgata os tokens de seguro do usu√°rio a um pre√ßo n√£o inferior ao pre√ßo pelo qual ele os comprou: a conta de seguro cria ExchangeTransaction, o usu√°rio assina o pedido (se a transa√ß√£o for conclu√≠da corretamente), a conta de seguro assina o segundo pedido e a transa√ß√£o inteira e o envia para a blockchain . <br><br>  Se a compra n√£o ocorrer, o usu√°rio poder√° criar um Pedido de acordo com as regras descritas no script e enviar a transa√ß√£o para a blockchain.  Assim, o usu√°rio pode devolver o dinheiro gasto na compra de tokens segurados. <br><br><pre> <code class="scala hljs">let insuranceToken = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let freezePeriod = <span class="hljs-number"><span class="hljs-number">150000</span></span> let insurancePrice = <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { #, ,   -,              <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; size(d.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !isDefined(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o : <span class="hljs-type"><span class="hljs-type">Order</span></span> =&gt; #     ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isDefined(o.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) then sigVerify(o.bodyBytes, o.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], o.senderPublicKey) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #     ,         let purchaseTx = transactionById(o.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) let purchaseTxHeight = extract(transactionHeightById(o.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>])) #    <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> purchaseTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> purchase : <span class="hljs-type"><span class="hljs-type">ExchangeTransaction</span></span> =&gt; let correctSender = purchase.sender == o.sender let correctAssetPair = o.assetPair.amountAsset == insuranceToken &amp;&amp; purchase.sellOrder.assetPair.amountAsset == insuranceToken &amp;&amp; o.assetPair.priceAsset == purchase.sellOrder.assetPair.priceAsset let correctPrice = o.price == purchase.price - insurancePrice &amp;&amp; o.amount == purchase.amount let correctHeight = height &gt; purchaseTxHeight + freezePeriod #,   -   <span class="hljs-type"><span class="hljs-type">ID</span></span>   let correctProof = extract(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(purchase.id))) == o.id correctSender &amp;&amp; correctAssetPair &amp;&amp; correctPrice &amp;&amp; correctHeight &amp;&amp; correctProof <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre><br>  Um token de seguro pode ser um ativo inteligente, por exemplo, para proibir sua transfer√™ncia para terceiros. <br><br>  Esse esquema tamb√©m pode ser implementado para tokens de crowdfunding, que s√£o devolvidos aos propriet√°rios se a quantia necess√°ria n√£o tiver sido coletada. <br><br>  <b>Impostos sobre transa√ß√µes</b> <br><br>  Os contratos inteligentes tamb√©m s√£o aplic√°veis ‚Äã‚Äãnos casos em que √© necess√°rio cobrar impostos de cada transa√ß√£o com v√°rios tipos de ativos.  Isso pode ser feito por meio de um novo ativo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">patrocinado</a> para transa√ß√µes com ativos inteligentes: <br><br>  1. Lan√ßamos o FeeCoin, que ser√° enviado aos usu√°rios por um pre√ßo fixo: 0,01 WAVES = 0,001 FeeCoin. <br><br>  2. Estabelecemos patroc√≠nio para FeeCoin e taxa de c√¢mbio: 0,001 WAVES = 0,001 FeeCoin. <br><br>  3. Definimos o seguinte script para o ativo inteligente: <br><br><pre> <code class="scala hljs">let feeAssetId = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' let taxDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; t.feeAssetId == feeAssetId &amp;&amp; t.fee == t.amount / taxDivisor <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e: <span class="hljs-type"><span class="hljs-type">ExchangeTransaction</span></span>| <span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  Agora, toda vez que algu√©m transferir N ativos inteligentes, ele fornecer√° o FeeCoin no valor de N / taxDivisor (que pode ser comprado por 10 * N / taxDivisor WAVES) e o mineiro N / taxDivisor WAVES.  Como resultado, seu lucro (imposto) ser√° 9 * N / taxDivisor WAVES. <br><br>  Voc√™ tamb√©m pode tributar usando um script de ativo inteligente e MassTransferTransaction: <br><br><pre> <code class="scala hljs">let taxDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t : <span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; let twoTransfers = size(t.transfers) == <span class="hljs-number"><span class="hljs-number">2</span></span> let issuerIsRecipient = t.transfers[<span class="hljs-number"><span class="hljs-number">0</span></span>].recipient == addressFromString(<span class="hljs-string"><span class="hljs-string">"3MgkTXzD72BTfYpd9UW42wdqTVg8HqnXEfc"</span></span>) let taxesPaid = t.transfers[<span class="hljs-number"><span class="hljs-number">0</span></span>].amount &gt;= t.transfers[<span class="hljs-number"><span class="hljs-number">1</span></span>].amount / taxDivisor twoTransfers &amp;&amp; issuerIsRecipient &amp;&amp; taxesPaid <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br>  <b>Programas de Cashback e Fidelidade</b> <br><br>  O reembolso √© um tipo de programa de fidelidade no qual uma parte do valor gasto em um produto ou servi√ßo √© devolvida ao comprador. <br><br>  Ao implementar este caso usando uma conta inteligente, devemos verificar as provas da mesma maneira que fizemos no caso do seguro.  Para evitar gastos duplos, antes de receber um reembolso, o usu√°rio deve enviar uma DataTransaction com (chave, valor) = (purchaseTransactionId, cashbackTransactionId). <br><br>  Tamb√©m devemos proibir chaves existentes usando uma DataTransaction.  cashbackDivisor - uma unidade dividida pela a√ß√£o do cashback.  I.e.  se o compartilhamento de reembolso for de 0,1, cashbackDivisor 1 / 0,1 = 10. <br><br><pre> <code class="scala hljs">let cashbackToken = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let cashbackDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { #, ,   -,              <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; size(d.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !isDefined(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; #     ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isDefined(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) then sigVerify(e.bodyBytes, e.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], e.senderPublicKey) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #     ,         let purchaseTx = transactionById(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) let purchaseTxHeight = extract(transactionHeightById(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>])) #    <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> purchaseTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> purchase : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; let correctSender = purchase.sender == e.sender let correctAsset = e.assetId == cashbackToken let correctPrice = e.amount == purchase.amount / cashbackDivisor #,   -   <span class="hljs-type"><span class="hljs-type">ID</span></span>   let correctProof = extract(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(purchase.id))) == e.id correctSender &amp;&amp; correctAsset &amp;&amp; correctPrice &amp;&amp; correctProof <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre> <br>  <b>Troca at√¥mica</b> <br><br>  A troca at√¥mica permite que os usu√°rios troquem ativos sem a ajuda de uma troca.  Em uma troca at√¥mica, os dois participantes da transa√ß√£o devem confirmar dentro de um determinado per√≠odo de tempo. <br><br>  Se pelo menos um dos participantes n√£o fornecer a confirma√ß√£o correta da transa√ß√£o dentro do tempo alocado para a transa√ß√£o, a transa√ß√£o ser√° cancelada e nenhuma troca ocorrer√°. <br><br>  Em nosso exemplo, usaremos o seguinte script de conta inteligente: <br><br><pre> <code class="scala hljs">let <span class="hljs-type"><span class="hljs-type">Bob</span></span> = <span class="hljs-type"><span class="hljs-type">Address</span></span>(base58<span class="hljs-symbol"><span class="hljs-symbol">'3NBVqYXrapgJP9atQccdBPAgJPwHDKkh6A</span></span>8') let <span class="hljs-type"><span class="hljs-type">Alice</span></span> = <span class="hljs-type"><span class="hljs-type">Address</span></span>(base58<span class="hljs-symbol"><span class="hljs-symbol">'3PNX6XwMeEXaaP1rf5MCk8weYeF7z2vJZB</span></span>g') let beforeHeight = <span class="hljs-number"><span class="hljs-number">100000</span></span> let secret = base58<span class="hljs-symbol"><span class="hljs-symbol">'BN6RTYGWcwektQfSFzH8raYo9awaLgQ7pLyWLQY4S4F</span></span>5' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; let txToBob = t.recipient == <span class="hljs-type"><span class="hljs-type">Bob</span></span> &amp;&amp; sha256(t.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>]) == secret &amp;&amp; <span class="hljs-number"><span class="hljs-number">20</span></span> + beforeHeight &gt;= height let backToAliceAfterHeight = height &gt;= <span class="hljs-number"><span class="hljs-number">21</span></span> + beforeHeight &amp;&amp; t.recipient == <span class="hljs-type"><span class="hljs-type">Alice</span></span> txToBob || backToAliceAfterHeight <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <i>No pr√≥ximo artigo, consideraremos o uso de contas inteligentes em instrumentos financeiros - como op√ß√µes, futuros e faturas.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt442238/">https://habr.com/ru/post/pt442238/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt442226/index.html">Este conte√∫do n√£o est√° dispon√≠vel no seu pa√≠s: not√≠cias que voc√™ n√£o pode aprender com a R√∫ssia</a></li>
<li><a href="../pt442230/index.html">Qual dos desenvolvedores que vivem na mesma cidade ganha mais: trabalhando remotamente ou no escrit√≥rio?</a></li>
<li><a href="../pt442232/index.html">Registrador de bobina Slf4j alternativo</a></li>
<li><a href="../pt442234/index.html">Col√¥nia. Ep√≠logo</a></li>
<li><a href="../pt442236/index.html">Por que o Dodo Pizza precisa de 250 desenvolvedores?</a></li>
<li><a href="../pt442242/index.html">Not√≠cias recentes: Lan√ßada a maior planta de c√©lulas solares do Hemisf√©rio Ocidental</a></li>
<li><a href="../pt442244/index.html">Rust 1.33 Release</a></li>
<li><a href="../pt442248/index.html">NASA aprovou o lan√ßamento de teste n√£o tripulado do Dragon-2</a></li>
<li><a href="../pt442250/index.html">Reagir e Vue: Pontos fortes</a></li>
<li><a href="../pt442252/index.html">Ciclo de vida do c√≥digo Python - CPython Runtime Model</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>