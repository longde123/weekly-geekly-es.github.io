<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüè≠ üëÇ üèöÔ∏è Crear nebulosa de p√≠xeles con ruido y corte medio üë®üèª‚Äçüé® üßùüèº ü§±üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quer√≠a una nebulosa en mi juego The Last Boundary . Se ven incre√≠bles y el espacio sin ellos no es espacio, sino simplemente p√≠xeles blancos dispersos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crear nebulosa de p√≠xeles con ruido y corte medio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464203/">  Quer√≠a una nebulosa en mi juego <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Last Boundary</a> .  Se ven incre√≠bles y el espacio sin ellos no es espacio, sino simplemente p√≠xeles blancos dispersos por el fondo.  Pero desde que hice el juego al estilo de "pixel art", necesitaba hacer que mi biblioteca de ruido generara im√°genes pixeladas de alguna manera. <br><br>  Aqu√≠ hay algunos ejemplos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2e/65f/7fd/f2e65f7fd23c0fe2fcfafcc0fcf62a3e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/665/358/ef9/665358ef9f488bb63d7ced8ea7dfd45d.png"></div><br><div class="spoiler">  <b class="spoiler_title">M√°s ejemplos</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/d6e/4ab/b88d6e4ab783d2d67f0f0f6e7e38536f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/705/d13/40b/705d1340be1c918a6a6e9b22d3ae416f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/daa/1c7/1ba/daa1c71bade101b11ec6025a87ca30a4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00b/d8c/5f9/00bd8c5f9fa01ef5a90282a2d2897de3.png"></div><br></div></div><br>  En ejemplos de un solo color, se usan 8 colores y en otros, 16 colores.  En este art√≠culo, hablar√© sobre c√≥mo cre√© una nebulosa pixelada para The Last Boundary. <br><a name="habracut"></a><br>  Cuando trabajamos con una biblioteca de ruido, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LibNoise</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">importa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">qu√©</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motor</a> use (o escriba el suyo), los valores generalmente se distribuyen en el rango de <code>-1</code> a <code>1</code> .  Te√≥ricamente es m√°s probable que el ruido 2D est√© en el rango de <code>-0.7</code> a <code>0.7</code> , pero algunas implementaciones escalan el resultado, traduci√©ndolo en el intervalo de <code>-1</code> a <code>1</code> .  Para trabajar con texturas 2D, generalmente se convierte en un intervalo de <code>0</code> a <code>1</code> , y luego <code>RGB(255,255,255)</code> dentro del rango de <code>RGB(0,0,0)</code> a <code>RGB(255,255,255)</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/df6/434/cacdf6434a755a3ae5dd27afbffc8ce2.png"></div><br>  <i>Ruido de Perlin generado a partir de la coordenada <code>x,y</code> de cada p√≠xel escalado a <code>0.3f</code></i> <br><br>  Luego puede usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el movimiento browniano fraccional</a> para darle a la imagen una sensaci√≥n de esplendor de las nubes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aed/910/a74/aed910a745d77af8d1cfa816990276a5.png"></div><br>  <i>El ruido de Perlin se someti√≥ a un movimiento browniano fraccional con <code>8</code> octavas, frecuencia <code>0.01</code> , regularidad <code>0.5</code> y lacunaridad <code>2.0</code> .</i> <br><br><blockquote>  Not√© que hay muchas implementaciones incorrectas de ruido Perlin, ruido simplex y movimiento browniano fraccional (fBm) en Internet.  Parece haber mucha confusi√≥n sobre qu√© es qu√©.  Aseg√∫rese de utilizar la implementaci√≥n correcta, porque si desea crear la cadena descrita anteriormente, en caso de una implementaci√≥n incorrecta, es posible que no obtenga los resultados requeridos. </blockquote><br>  Imaginemos que queremos crear un efecto de humo, es decir, tal soluci√≥n nos conviene.  Pero nuestro juego de pixel art se ver√≠a extra√±o si aparecieran <code>RGB(255,255,255)</code> colores nuevos, desde <code>RGB(0,0,0)</code> hasta <code>RGB(255,255,255)</code> .  De repente, aparecer√≠an 255 nuevos grados de gris en el juego. <br><br>  Necesitamos convertirlos a un n√∫mero limitado de colores.  Eso es lo que haremos m√°s tarde.  Mientras tanto ... <br><br><h2>  Generar nebulosa aleatoria </h2><br>  Repet√≠ para tutoriales ya preparados sobre la generaci√≥n de nebulosas aleatorias, pero agregu√© algunos de mis pasos y apliqu√© mi propia biblioteca de ruido.  Lo escrib√≠ hace unos a√±os porque quer√≠a comprender bien el ruido de Perlin y c√≥mo puedes usarlo junto con otros conceptos para crear texturas y similares. <br><br>  Quiz√°s pueda repetirme paso a paso o tendr√° que hacer adiciones al c√≥digo que afectar√° su ruido.  Explicar√© todo excepto la generaci√≥n de ruido inicial y fBm para que pueda escribir el c√≥digo usted mismo;  Creo que se puede suponer que ya tienes la capacidad de generar ruido y fBm. <br><br>  Para comenzar, mostrar√© el resultado de generar la nebulosa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>Resultado terminado</i> <br><br>  Es importante tener en cuenta que a√∫n no est√° pixelado.  Tiene una gama completa de colores con un cielo estrellado pixelado.  La nebulosa que pixelaremos m√°s tarde. <br><br>  Lo primero que debe hacer es generar cinco texturas diferentes: rojo, verde, azul, alfa y m√°scara.  Las texturas roja, verde y azul son necesarias para los canales de color finales correspondientes.  De hecho, solo genero uno o dos canales de color, porque result√≥ que usar los tres produce una nebulosa incre√≠blemente colorida que se ve fea.  Cualquier color individual o una combinaci√≥n de dos colores funcionar√° bien. <br><br>  El canal alfa es importante porque depende de si las estrellas inferiores brillar√°n a trav√©s de la nebulosa.  Ilustrar√© esto mostrando el canal alfa del ejemplo que se muestra arriba. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>Listo canal alfa de nuestro ejemplo</i> <br><br>  Cuanto m√°s blanca es el √°rea, m√°s cercano est√° el valor a <code>1.0</code> , lo que nos da un valor alfa de <code>255</code> .  Cuanto m√°s negra es la zona, m√°s transparente es.  Si observa un ejemplo, puede ver que las √°reas negras corresponden a √°reas en las que el cielo estrellado es visible. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de9/7d2/7ad/de97d27adeaaebdbfc8a5b5857bab02f.png"></div><br>  <i>Ejemplo de cielo estrellado</i> <br><br>  Estas no son las mismas estrellas que en el ejemplo, porque se generan aleatoriamente en cada captura de pantalla.  Espero que esto no te impida entender c√≥mo se genera la nebulosa. <br><br>  Mi biblioteca de ruido consta de m√≥dulos, siguiendo el ejemplo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lib Noise</a> .  Todo en esta biblioteca son "m√≥dulos" que se pueden encadenar juntos.  Algunos m√≥dulos generan nuevos valores (M√≥dulo Perlin, Valor constante), otros los conectan (Multiplicar, Agregar), y algunos simplemente realizan operaciones sobre el valor (Lerp, Clamp). <br><br><h3>  Canales de color </h3><br>  No importa si trabajamos con uno, dos o tres colores: los canales rojo, verde y azul se generan de la misma manera;  Solo uso un valor semilla diferente para ellos.  Mis valores iniciales dependen de la hora actual del sistema. <br><br>  A continuaci√≥n se presentan todos en escala de grises, pero en teor√≠a son simplemente valores para uno de los tres canales.  La escala de grises est√° aqu√≠ solo para ilustrar los resultados. <br><br><h4>  1. ruido de Perlin </h4><br>  Como arriba, el ruido de Perlin ser√° el punto de partida.  Si lo desea, puede usar ruido simplex, parece que su implementaci√≥n 2D no pertenece a Ken Perlin, pero podr√≠a estar equivocado.  Desde un punto de vista matem√°tico, el ruido simple utiliza menos instrucciones, por lo que la generaci√≥n de una nebulosa similar ser√° m√°s r√°pida.  Dado que usa s√≠mplex en lugar de una cuadr√≠cula, crea un ruido un poco m√°s hermoso, pero no trabajaremos mucho con √©l, por lo que esto no es particularmente importante. <br><br>  El c√≥digo real no se muestra a continuaci√≥n, porque en fuentes reales los valores <code>x,y</code> fueron cambiados por fBm en el paso 3. Esta es solo la coordenada <code>x,y</code> de la imagen, multiplicada por el factor de escala est√°tico. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/df6/434/cacdf6434a755a3ae5dd27afbffc8ce2.png"></div><br>  <i>Ruido de Perlin generado a partir de la coordenada <code>x,y</code> de cada p√≠xel escalado a <code>0.3f</code> .</i>  <i>Es decir</i> <i><code>PixelValue = PerlinNoise(x * 0.3f, y * 0.3f)</code></i> <br><br>  Los valores creados por el ruido de Perlin est√°n aproximadamente en el rango de <code>-1</code> a <code>1</code> , por lo que para crear la imagen de escala de grises habitual que se muestra arriba, los convertimos al intervalo de <code>0</code> a <code>1</code> .  Prob√© el alcance de los valores para que la conversi√≥n produzca el mayor contraste (el valor m√°s bajo corresponde a <code>0</code> , el m√°s grande - <code>1</code> ). <br><br><h4>  2. Multiplicaci√≥n </h4><br>  El siguiente m√≥dulo utilizado multiplica el ruido generado por <code>5</code> .  Esto puede considerarse un ajuste de contraste.  Los valores negativos son m√°s oscuros, los valores positivos son m√°s claros. <br><br>  No tengo nada que mostrar aqu√≠, porque en el proceso de convertir valores del intervalo de <code>-5</code> a <code>5</code> al intervalo de <code>0</code> a <code>1</code> resultado no cambia. <br><br><h4>  3. Movimiento browniano fraccional (fBM) </h4><br>  Esta etapa convierte el ruido en lo que muchas personas consideran un verdadero "efecto de ruido".  Aqu√≠ ejecutamos octavas de muestras cada vez m√°s peque√±as a partir de la funci√≥n de ruido (en nuestro caso, la funci√≥n es <code>perlin(x,y)</code> ) para agregar esponjosidad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/388/634/15b/38863415ba86694f3acc86618e7173d2.png"></div><br>  <i>El movimiento browniano fraccionado del ruido de Perlin se muestra arriba.</i>  <i><code>8</code> octavas, frecuencia <code>.01f</code> , regularidad <code>.5f</code> y <code>2.5f</code></i> <br><br>  Ya puedes ver el origen de algo interesante.  La imagen que se muestra arriba no se genera al escalar las coordenadas <code>x,y</code> de los p√≠xeles, fBM hace esto.  Nuevamente, estos valores se convierten inversamente a un intervalo de <code>0</code> a <code>1</code> a un posible intervalo de <code>-5</code> a <code>5</code> . <br><br><h4>  4. Restricci√≥n (abrazadera) </h4><br>  Ahora limitar√© los valores a un rango de <code>-1</code> a <code>1</code> .  Cualquier cosa fuera de este intervalo se descartar√° por completo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/623/f7a/b80/623f7ab80bc886e62d416726bcb63a09.png"></div><br>  <i>El mismo fBm, limitado a <code>-1</code> a <code>1</code></i> <br><br>  La tarea de esta operaci√≥n es convertir los valores a un intervalo m√°s corto mientras crea gradientes m√°s n√≠tidos y aumenta el √°rea en blanco o negro.  Estas √°reas muertas o vac√≠as son importantes para el efecto de nebulosa, que abordaremos m√°s adelante.  Si no hubi√©ramos multiplicado por <code>5</code> al principio, entonces la abrazadera no habr√≠a cambiado nada. <br><br><h4>  5. Agregar 1 </h4><br>  Ahora tomamos los valores de la abrazadera y les sumamos 1. Por lo tanto, transferimos los valores al intervalo de <code>0</code> a <code>2</code> .  Despu√©s de la conversi√≥n, los resultados se ver√°n igual que antes. <br><br><h4>  6. Divide entre 2 </h4><br>  Probablemente sepa lo que suceder√° cuando divida el resultado por <code>2</code> (multiplique por <code>.5</code> ).  En la imagen, nada volver√° a cambiar. <br><br>  Los pasos 5 y 6 convierten los valores en un rango de <code>0</code> a <code>1</code> . <br><br><h4>  7. Crea una textura de distorsi√≥n </h4><br>  El siguiente paso es crear una textura de distorsi√≥n.  Har√© esto con el ruido Perlin (con el nuevo valor de inicializaci√≥n)&gt; multiplicar por 4&gt; ejecutar fBm.  En este caso, fBm usa <code>5</code> octavas, una frecuencia de <code>0.025</code> , una regularidad de <code>0.5</code> y una lacunaridad de <code>1.5</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/937/748/b34937748b4e87736c9f09f464bc99dd.png"></div><br>  <i>Textura de distorsi√≥n</i> <br><br>  Esta textura es necesaria para crear m√°s detalles que en la textura existente de la nebulosa.  La nebulosa es una nube ondulada bastante grande, y esta textura le har√° peque√±os cambios.  A trav√©s de √©l, la naturaleza de rejilla del ruido de Perlin comenzar√° a emerger. <br><br><h4>  8. Compense la textura de color usando la textura de compensaci√≥n </h4><br>  Luego tomar√© estas dos texturas y usar√© una para compensar las coordenadas de la otra por un factor.  En nuestro caso, la combinaci√≥n se ve as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93f/44c/0ea/93f44c0ea7e040e0141925eede2673fd.png"></div><br>  <i>Resultado de sesgo</i> <br><br>  La textura de distorsi√≥n se usa para cambiar las coordenadas <code>x,y</code> que estamos buscando en los datos de ruido de origen. <br><br>  Recuerde que las im√°genes que se muestran arriba son solo para fines ilustrativos.  En cada etapa, en realidad solo tenemos una funci√≥n de ruido.  Le pasamos el valor <code>x,y</code> , y devuelve un n√∫mero.  En ciertas etapas, el intervalo de este n√∫mero puede ser diferente, pero arriba lo convertimos nuevamente en escala de grises para crear una imagen.  La imagen se crea utilizando cada coordenada <code>x,y</code> de la imagen como <code>x,y</code> , transmitida por la funci√≥n de ruido. <br><br>  Es decir, cuando decimos: <br><br><blockquote>  Dame el valor para el p√≠xel de la esquina superior izquierda con X = 0 e Y = 0 </blockquote><br>  La funci√≥n nos devuelve un n√∫mero.  Si le preguntamos a Perlin por esto, sabemos que estar√° entre <code>-1</code> y <code>1</code> , si, como arriba, aplicamos la pinza, la suma y la multiplicaci√≥n, obtenemos un valor entre <code>0</code> y <code>1</code> . <br><br>  Una vez entendido esto, aprendemos que la funci√≥n de ruido de distorsi√≥n crea valores en el rango de <code>-1</code> a <code>1</code> .  Por lo tanto, para realizar el sesgo cuando decimos: <br><br><blockquote>  Dame el valor para el p√≠xel en la esquina superior izquierda con el p√≠xel X = 0 e Y = 0 </blockquote><br>  el m√≥dulo de compensaci√≥n primero le pide a la funci√≥n de compensaci√≥n las coordenadas <code>x,y</code> .  El resultado de esto es entre <code>-1</code> y <code>1</code> (como estaba arriba).  Luego se multiplica por <code>40</code> (este es el <em>coeficiente</em> que seleccion√©).  El resultado ser√° un valor entre <code>-40</code> y <code>40</code> . <br><br>  Luego tomamos este valor y lo agregamos a las coordenadas de la <code>x,y</code> que est√°bamos buscando, y usamos este resultado para buscar la textura de color.  Cortamos los valores negativos con la abrazadera a 0, porque es imposible buscar coordenadas negativas <code>x,y</code> en las funciones de ruido (al menos en mi biblioteca de ruido). <br><br>  Es decir, en general, se ve as√≠: <br><br><pre> <code class="cpp hljs">ColourFunction(x,y) =     <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> DisplaceFunction(x,y) =     <span class="hljs-number"><span class="hljs-number">-1</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> DoDisplace(x,y) = { v = DisplaceFunction(x,y) * factor clamp(v,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>) x = x + v; y = y + v; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> then x = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> then y = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ColourFunction(x,y) }</code> </pre> <br>  Espero que entiendas esto.  De hecho, no estamos mirando la <code>x,y</code> que est√°bamos, sino el desplazamiento.  Y dado que la <em>magnitud</em> tambi√©n es un gradiente suave, cambia suavemente. <br><br>  Hay otras formas de realizar el desplazamiento.  Mi biblioteca de ruido tiene un m√≥dulo que crea un desplazamiento en espiral.  Se puede usar para dibujar textura, disminuyendo gradualmente a varios puntos.  <a href="">Aqu√≠ hay un ejemplo</a> . <br><br>  Eso es todo  Repetimos las operaciones anteriores tres veces, utilizando nuevos valores de inicializaci√≥n para cada canal de color.  Puedes crear uno o dos canales.  No creo que valga la pena crear un tercero. <br><br><h3>  Canal alfa </h3><br>  Un canal alfa se crea de manera muy similar a los canales de color: <br><br><ol><li>  Comenzamos con el ruido de Perlin </li><li>  Multiplicar por <code>5</code> </li><li>  fBM con <code>8</code> octavas, frecuencia <code>0.005</code> , regularidad <code>0.5</code> y lacunaridad <code>2.5</code> </li><li>  Limitamos los resultados usando Clamp al intervalo de <code>-1</code> a <code>1</code> , sumamos <code>1</code> , dividimos por <code>2</code> (es decir, cambiamos el intervalo de <code>-1</code> a <code>1</code> al intervalo de <code>0</code> a <code>1</code> . </li><li>  Cambiamos el resultado por una peque√±a cantidad en la direcci√≥n negativa.  Lo compens√© por <code>0.4</code> .  Gracias a esto, todo se vuelve un poco m√°s oscuro. </li><li>  Limitamos los resultados a un intervalo de <code>0</code> a <code>1</code> .  Como movimos todo, haci√©ndolo un poco m√°s oscuro, de hecho, creamos m√°s √°reas con <code>0</code> , y algunas √°reas entraron en valores negativos. </li></ol><br>  El resultado es una textura de canal alfa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>Textura alfa</i> <br><br>  Como dije, las √°reas negras ser√°n transparentes y las √°reas blancas ser√°n opacas. <br><br><h3>  M√°scaras de canal </h3><br>  Esta es la √∫ltima textura que se usa para crear sombras superpuestas sobre todo lo dem√°s.  Comienza como todas las otras texturas: <br><br><ol><li>  Ruido perlin </li><li>  Multiplicar por <code>5</code> </li><li>  Realizamos fBm, <code>5</code> octavas, frecuencia <code>0.01</code> , regularidad <code>0.1</code> , lacunaridad <code>0.1</code> .  La regularidad es peque√±a, por lo que la nube es menos densa. </li><li>  Realizar un cambio de intervalo de <code>-1</code> a <code>1</code> a un intervalo de <code>0</code> a <code>1</code> </li></ol><br>  Pero creamos dos de esas texturas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/630/11f/862/63011f8620c86a9bbf2f80d038a7c157.png"></div><br>  <i>Enmascarar un</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/ae6/62e/271ae662e2038e09afba52bb2725d8cb.png"></div><br>  <i>M√°scara B</i> <br><br>  Exponemos estas dos texturas a lo que yo llamo el m√≥dulo <em>Seleccionar</em> .  De hecho, utilizamos el valor del m√≥dulo A o del m√≥dulo B. La elecci√≥n depende del valor del m√≥dulo C. Requiere dos valores m√°s: <em>Seleccionar punto</em> y <em>Disminuci√≥n</em> . <br><br>  Si el valor en el punto <code>x,y</code> m√≥dulo C es mayor o igual que <code>SelectPoint</code> , entonces usamos el valor en el punto <code>x,y</code> m√≥dulo B. Si el valor es menor o igual que <code>SelectPoint - Falloff</code> , entonces usamos el valor en <code>x,y</code> m√≥dulo A. <br><br>  Si est√° entre <code>SelectPoint - Falloff</code> y <code>SelectPoint</code> , entonces realizamos una interpolaci√≥n lineal entre los valores <code>x,y</code> del m√≥dulo A y el m√≥dulo B. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, moduleA, moduleB, moduleC, selectPoint, falloff)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> s = moduleC(x,y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s &gt;= selectPoint) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moduleB(x,y); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s &lt;= selectPoint - falloff) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moduleA(x,y); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = moduleA(x,y); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = moduleB(x,y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lerp(a, b, (<span class="hljs-number"><span class="hljs-number">1.0</span></span> / ((selectPoint - (selectPoint-falloff)) / (selectPoint - s))); } }</code> </pre> <br>  En nuestro caso, el m√≥dulo A es un m√≥dulo <em>constante</em> con un valor de <code>0</code> .  El m√≥dulo B es la primera textura de la m√°scara A, y <em>Selector</em> (m√≥dulo C) es la segunda m√°scara de B. <code>SelectPoint</code> ser√° <code>0.4</code> , y <code>Falloff</code> ser√° <code>0.1</code> .  Como resultado, obtenemos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/46a/265/93a46a265f690650dec24eb5c56bcf32.png"></div><br>  <i>M√°scara definitiva</i> <br><br>  Al aumentar o disminuir <code>SelectPoint</code> , disminuimos o aumentamos la cantidad de negro en la m√°scara.  Al aumentar o disminuir la <code>falloff</code> , aumentamos o disminuimos los bordes suaves de las m√°scaras.  En lugar de una de las m√°scaras, podr√≠a usar el m√≥dulo <em>Constante</em> con un valor de <code>1</code> , pero quer√≠a agregar un poco de aleatoriedad a las √°reas "sin m√°scara". <br><br><h3>  Mezcle el canal de color y la m√°scara </h3><br>  Ahora necesitamos aplicar una m√°scara a cada uno de los canales de color.  Esto se hace usando el m√≥dulo de <em>fusi√≥n</em> .  Combina los porcentajes de valores de dos m√≥dulos para que la suma de los valores sea del 100%. <br><br>  Es decir, podemos tomar el 50% del valor en <code>x,y</code> m√≥dulo A y el 50% del valor en <code>x,y</code> m√≥dulo B. O el 75% y el 25%, etc.  El porcentaje que tomamos de cada m√≥dulo depende de otro m√≥dulo: el m√≥dulo C. Si el valor en <code>x,y</code> m√≥dulo C es <code>0</code> , tomaremos el 100% del m√≥dulo A y el 0% del m√≥dulo B. Si es <code>1</code> , entonces tomamos valores inversos <br><br>  Combina para cada textura de color. <br><br><ul><li>  M√≥dulo A - Valor constante 0 </li><li>  El m√≥dulo B es el canal de color que ya hemos visto. </li><li>  M√≥dulo C - resultado de la m√°scara </li></ul><br>  Esto significa que el ruido del canal de color se mostrar√° solo donde la m√°scara tenga valores superiores a <code>0</code> (√°reas m√°s cercanas al blanco), y la magnitud de su visibilidad depende del valor de la m√°scara. <br><br>  Aqu√≠ est√° el resultado de nuestro ejemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/f7e/e06/4daf7ee0635972da36bbb611250fb52d.png"></div><br>  <i>Resultado final</i> <br><br>  Compare esto con el original antes de aplicar la mezcla con una m√°scara. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93f/44c/0ea/93f44c0ea7e040e0141925eede2673fd.png"></div><br>  <i>Antes de mezclar con una mascarilla</i> <br><br>  Quiz√°s este ejemplo no sea muy obvio, pero debido a la posibilidad es dif√≠cil seleccionar espec√≠ficamente un buen ejemplo.  El efecto de la m√°scara es crear √°reas m√°s oscuras.  Por supuesto, puede personalizar la m√°scara para que sea m√°s pronunciada. <br><br>  Aqu√≠ es importante que se aplique la misma m√°scara a todo el canal de color, es decir, las mismas √°reas aparecen en la sombra. <br><br><h3>  Combinamos todo juntos </h3><br>  Nuestro ejemplo final terminado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>Ejemplo listo</i> <br><br>  Utiliza los canales rojo, verde y alfa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/f7e/e06/4daf7ee0635972da36bbb611250fb52d.png"></div><br>  <i>Canal rojo</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/001/8fb/c26/0018fbc263e0ae9983386f78428a0088.png"></div><br>  <i>Canal verde</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>Canal alfa</i> <br><br>  Y luego los colocamos sobre nuestro cielo estrellado. <br><br>  Ahora todo se ve bastante bien, pero no es muy adecuado para un juego de pixel art.  Necesitamos reducir el n√∫mero de colores ... <br><br><h2>  Corte medio </h2><br>  Esta parte del art√≠culo se puede aplicar a cualquier cosa.  Supongamos que genera una textura de m√°rmol y desea reducir la cantidad de colores.  Aqu√≠ es donde el algoritmo de corte medio resulta √∫til.  Lo usaremos para reducir la cantidad de colores en la nebulosa que se muestra arriba. <br><br>  Esto sucede <em>antes de</em> que se superponga en el cielo estrellado.  El n√∫mero de colores es completamente arbitrario. <br><br>  El algoritmo Median Cut como se describe en Wikipedia: <br><br><blockquote>  Supongamos que tenemos una imagen con un n√∫mero arbitrario de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">p√≠xeles</a> y queremos generar una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paleta</a> de 16 colores.  Ponga todos los p√≠xeles en la imagen (es decir, sus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">valores RGB</a> ) en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">papelera</a> .  Descubra qu√© canal de color (rojo, verde o azul) entre todos los p√≠xeles de la cesta tiene el mayor rango de valores, y luego ordene los p√≠xeles de acuerdo con los valores de este canal.  Por ejemplo, si el canal azul tiene el mayor rango de valores, entonces el p√≠xel con el valor RGB (32, 8, 16) es m√°s peque√±o que el p√≠xel con el valor RGB (1, 2, 24), porque 16 &lt;24. Despu√©s de ordenar la canasta, coloque la mitad superior de los p√≠xeles en una nueva canasta.  (Este paso le dio el nombre al algoritmo de corte medio; las cestas se dividen a la mitad por la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mediana de la</a> lista de p√≠xeles). Repita el proceso para ambas cestas, lo que nos dar√° 4 cestas, luego repita para las 4 cestas, obtenga 8 cestas, luego repita para 8 cestas, obtenemos 16 cestas  Hacemos un promedio de los p√≠xeles en cada una de las canastas y obtenemos una paleta de 16 colores.  Dado que el n√∫mero de cestas se duplica en cada iteraci√≥n, el algoritmo solo puede generar tales paletas, el n√∫mero de colores en el cual es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una potencia de dos</a> .  Por ejemplo, para generar una paleta de 12 colores, primero debe generar una paleta de 16 colores y luego combinar de alguna manera algunos colores. <br><br>  Fuente: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://en.wikipedia.org/wiki/Median_cut</a> </blockquote><br>  Esta explicaci√≥n me pareci√≥ bastante mala y no particularmente √∫til.  Al implementar el algoritmo, se obtienen im√°genes bastante feas de esta manera.  Lo implement√© con algunos cambios: <br><br><ol><li>  Almacenamos el contenedor de <code>boxes</code> junto con el valor que indica el intervalo (m√°s sobre esto a continuaci√≥n).  El <code>box</code> simplemente almacena un n√∫mero din√°mico de p√≠xeles de la imagen original. </li><li>  Agregue todos los p√≠xeles de la imagen original como primer <code></code> y use el intervalo <code>0</code> </li><li>  Si bien el n√∫mero total de <code></code> menor que el n√∫mero requerido de colores, continuamos los siguientes pasos. </li><li>  Si el valor del intervalo es <code>0</code> , entonces para cada cuadro actual determinamos el canal de color principal de este <code>box</code> , y luego ordenamos los p√≠xeles en este <code>box</code> por este color.   ‚Äî    Red, Green, Blue  Alpha,     . , <code>redRange = Max(Red) - Min(Red)</code> .           ,      . </li><li>           <code>box</code>   <code>boxes</code> .   ,        <code>box</code> . </li><li>  ,     4  5   <code>box</code> ,   <code>boxes</code>   .      ,         ,    ,     .     ,           ,      . </li><li>    <code>box</code> ( ==   )      <code>boxes</code> .               <code>0</code> (    ).  ,         ,       ,    ‚Äî .            . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando alcanzamos el n√∫mero de cuadros igual al n√∫mero de colores deseado, simplemente promediamos todos los p√≠xeles en cada cuadro para determinar el elemento de paleta que mejor se adapte a estos colores. </font><font style="vertical-align: inherit;">Acabo de usar la distancia euclidiana, pero hay soluciones perceptivas que pueden hacerlo mejor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ hay una imagen que explicar√° todo m√°s claramente. </font><font style="vertical-align: inherit;">Para la demostraci√≥n, uso solo RGB, porque alfa es dif√≠cil de mostrar.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3e/bb8/3fa/f3ebb83fa6aa4d15c0422ef3d66fd9ed.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apliquemos este m√©todo a nuestra imagen de ejemplo. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El original</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/617/875/453617875c9eb3c9ae389c74aaeb97da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corte medio hasta 16 colores</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Descubr√≠ que cuando se usan dos canales de color, se obtiene un buen efecto con 16 colores. Pero tenga en cuenta que aqu√≠ usamos el canal alfa, que tambi√©n est√° involucrado en el c√°lculo de la distancia entre los colores. Entonces, si no le importa la transparencia, puede usar menos colores. Dado que mi corte medio, a diferencia del ejemplo de Wikipedia, puede usar una cantidad arbitraria de colores (y no solo potencias de dos), puede personalizarlo para satisfacer sus necesidades.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70c/32e/828/70c32e82884077298e54db439472c866.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De 16 a 2 colores.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seleccionamos un color de cada uno </font></font><code>box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, simplemente promediando todos los valores. </font><font style="vertical-align: inherit;">Sin embargo, esta no es la √∫nica forma. </font><font style="vertical-align: inherit;">Es posible que haya notado que nuestro resultado en comparaci√≥n con el original no es tan brillante. </font><font style="vertical-align: inherit;">Si lo necesita, puede dar preferencia en los intervalos superiores, agregando peso a la definici√≥n de intervalos. </font><font style="vertical-align: inherit;">O puede seleccionar f√°cilmente 1, 2 o 3 de los colores m√°s brillantes de la imagen y agregarlos a la paleta. </font><font style="vertical-align: inherit;">Por lo tanto, si necesita 16 colores, genere una paleta de 13 colores y agregue manualmente sus colores brillantes.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce6/48f/382/ce648f382b0be2409b25d24d682a528b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una paleta con los tres colores m√°s brillantes</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora todo se ve bastante bien, pero la imagen es demasiado irregular. </font><font style="vertical-align: inherit;">Tiene grandes √°reas del mismo color. </font><font style="vertical-align: inherit;">Ahora necesitamos suavizarlos.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tramado </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No necesito decirte qu√© es el tramado, porque ya trabajas con pixel art. </font><font style="vertical-align: inherit;">Entonces, para obtener una imagen m√°s uniforme, utilizaremos uno de los algoritmos de interpolaci√≥n, de los cuales hay muchos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implement√© un algoritmo de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">difuminado</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simple de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Floyd-Steinberg</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">No hubo sorpresas desagradables. </font><font style="vertical-align: inherit;">Sin embargo, el efecto fue bastante fuerte. </font><font style="vertical-align: inherit;">Aqu√≠ est√° nuestro ejemplo nuevamente:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Original</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Luego cortamos la paleta a 16 colores:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/617/875/453617875c9eb3c9ae389c74aaeb97da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los valores se asignan a una paleta de 16 colores,</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y ahora el tramado seguido de la conversi√≥n a una paleta:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84f/fa0/d82/84ffa0d82eb90de9f0e59c7ef718f753.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultado terminado con tramado</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464203/">https://habr.com/ru/post/464203/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464189/index.html">C√≥mo crear un proyecto de c√≥digo abierto</a></li>
<li><a href="../464191/index.html">C√≥mo resolver problemas del sitio agregador utilizando proxies residentes</a></li>
<li><a href="../464193/index.html">Un micr√≥fono abierto de DevOps Deflope, historias sobre la infraestructura de Skyeng y Nvidia y no solo</a></li>
<li><a href="../464195/index.html">La historia de √©xito del juego Last Day on Earth del estudio de Volgogrado Kefir</a></li>
<li><a href="../464197/index.html">¬øQu√© pasar√° en TechTrain y por qu√© deber√≠a ir all√≠?</a></li>
<li><a href="../464205/index.html">C√≥mo la IA y la neurociencia avanzan mutuamente</a></li>
<li><a href="../464207/index.html">Desde el Homo sapiens sapiens hasta el Homo vulnerable a la ciencia del Homo o la Conciencia de Seguridad como adulto</a></li>
<li><a href="../464209/index.html">Gutenberg Editor, c√≥mo hacer que los editores y las m√°quinas de escribir sean convenientes</a></li>
<li><a href="../464217/index.html">C√≥mo visualizar el sonido en la web: una selecci√≥n de materiales tem√°ticos y video conferencias con teor√≠a y pr√°ctica.</a></li>
<li><a href="../464219/index.html">Timlid toolkit de correo electr√≥nico a tableros kanban</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>