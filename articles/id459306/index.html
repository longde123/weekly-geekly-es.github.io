<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¥‘ ğŸ‘©ğŸ½â€ğŸ¤ ğŸ¤µğŸ¿ Perenderan server di lingkungan tanpa server ğŸ‘ˆğŸ» ğŸ¶ â³</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penulis materi, terjemahan yang kami terbitkan , adalah salah satu pendiri proyek Webiny - CMS tanpa server berdasarkan React, GraphQL, dan Node.js. D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perenderan server di lingkungan tanpa server</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459306/">  Penulis materi, terjemahan yang kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terbitkan</a> , adalah salah satu pendiri proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Webiny</a> - CMS tanpa server berdasarkan React, GraphQL, dan Node.js.  Dia mengatakan bahwa mendukung platform cloud tanpa server multi-tenant adalah bisnis yang memiliki tugas khusus.  Banyak artikel telah ditulis di mana teknologi standar untuk mengoptimalkan proyek web dibahas.  Diantaranya adalah rendering server, penggunaan teknologi pengembangan aplikasi web canggih, berbagai cara untuk meningkatkan pembangunan aplikasi, dan banyak lagi.  Artikel ini, di satu sisi, mirip dengan yang lain, dan di sisi lain, berbeda dari mereka.  Faktanya adalah itu didedikasikan untuk mengoptimalkan proyek yang berjalan di lingkungan tanpa server. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/45/ve/ub/45veubaub6xbivpsjj3_1r7zmx0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Persiapan</font> </h2><br>  Untuk melakukan pengukuran yang akan membantu mengidentifikasi masalah proyek, kami akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">webpagetest.org</a> .  Dengan bantuan sumber daya ini, kami akan memenuhi permintaan dan mengumpulkan informasi tentang waktu pelaksanaan berbagai operasi.  Ini akan memungkinkan kami untuk lebih memahami apa yang dilihat dan dirasakan pengguna saat bekerja dengan proyek. <br><br>  Kami sangat tertarik dengan indikator "Tampilan pertama", yaitu, berapa lama waktu yang diperlukan untuk memuat situs dari pengguna yang mengunjunginya untuk pertama kalinya.  Ini adalah indikator yang sangat penting.  Faktanya adalah bahwa cache browser mampu menyembunyikan banyak kemacetan proyek web. <br><br><h2>  <font color="#3AC1EF">Indikator yang mencerminkan fitur pemuatan situs - identifikasi masalah</font> </h2><br>  Lihatlah tabel berikut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc9/8a5/669/cc98a56691adf056e19086280e24cd11.png"></div><br>  <i><font color="#999999">Analisis indikator lama dan baru dari suatu proyek web</font></i> <br><br>  Di sini, indikator paling penting dapat dikenali sebagai â€œWaktu untuk Memulai Renderâ€ - waktu sebelum dimulainya rendering.  Jika Anda melihat dengan cermat pada indikator ini, Anda dapat melihat bahwa hanya untuk mulai merender halaman, dalam versi lama proyek, butuh hampir 2 detik.  Alasan untuk ini terletak pada esensi Aplikasi Satu Halaman (SPA).  Untuk menampilkan halaman aplikasi seperti itu di layar, Anda harus memuat bundel JS yang tebal (tahap pemuatan halaman ini ditandai pada gambar berikut sebagai 1).  Maka bundel ini perlu diproses di utas utama (2).  Dan hanya setelah itu, sesuatu dapat muncul di jendela browser. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/025/675/6b2/0256756b2e402f3ffbc06a426e8e03c1.png"></div><br>  <i><font color="#999999">(1) Unduh bundel JS.</font></i>  <i><font color="#999999">(2) Menunggu pemrosesan bundel di utas utama</font></i> <br><br>  Namun, ini hanya sebagian dari gambar.  Setelah utas utama memproses bundel JS, ia membuat beberapa permintaan ke Gateway API.  Pada tahap pemrosesan halaman ini, pengguna melihat indikator pemuatan berputar.  Pemandangan itu bukan yang paling menyenangkan.  Namun, pengguna belum melihat konten halaman apa pun.  Berikut adalah storyboard dari proses pemuatan halaman. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f27/a62/b12/f27a62b12f800e4f3622583ca9f078a1.png"></div><br>  <i><font color="#999999">Pemuatan halaman</font></i> <br><br>  Semua ini menunjukkan bahwa pengguna yang mengunjungi situs semacam itu merasakan sensasi yang tidak menyenangkan dari bekerja dengannya.  Yaitu, dia dipaksa untuk melihat halaman kosong selama 2 detik, dan kemudian satu detik lagi - pada indikator unduhan.  Yang kedua ini ditambahkan ke waktu persiapan halaman karena fakta bahwa setelah memuat dan memproses permintaan API JS-bundle dieksekusi.  Pertanyaan ini diperlukan untuk memuat data dan, sebagai hasilnya, menampilkan halaman yang sudah selesai. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf6/c77/350/bf6c77350326268fbc01ff092a831549.png"></div><br>  <i><font color="#999999">Pemuatan halaman</font></i> <br><br>  Jika proyek di-host pada VPS biasa, maka waktu yang dibutuhkan untuk menyelesaikan permintaan API ini sebagian besar dapat diprediksi.  Namun, proyek yang berjalan di lingkungan tanpa server dipengaruhi oleh masalah "cold start" yang terkenal buruk.  Dalam kasus platform cloud Webiny, situasinya bahkan lebih buruk.  Fitur AWS Lambda adalah bagian dari VPC (Virtual Private Cloud).  Ini berarti bahwa untuk setiap instance baru dari fungsi tersebut, Anda perlu menginisialisasi ENI (Antarmuka Jaringan Elastis, antarmuka jaringan elastis).  Ini secara signifikan meningkatkan waktu mulai dingin fungsi. <br><br>  Berikut adalah beberapa jadwal untuk memuat fitur AWS Lambda di dalam VPC dan di luar VPC. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/642/1e5/30b/6421e530b2330c5c4bf63d473fa93cfb.png"></div><br>  <i><font color="#999999">Analisis beban fungsi AWS Lambda di dalam VPC dan di luar VPC (gambar diambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> )</font></i> <br><br>  Dari sini kita dapat menyimpulkan bahwa dalam kasus ketika fungsi diluncurkan di dalam VPC, ini memberikan peningkatan 10 kali lipat pada waktu mulai dingin. <br><br>  Selain itu, di sini satu faktor lagi harus diperhitungkan - keterlambatan pengiriman data jaringan.  Durasi mereka sudah termasuk pada waktu yang diperlukan untuk menjalankan permintaan API.  Permintaan dimulai oleh browser.  Oleh karena itu, ternyata pada saat API merespons permintaan ini, waktu yang diperlukan untuk mendapatkan permintaan dari browser ke API, dan waktu yang diperlukan untuk mendapatkan tanggapan dari API ke browser ditambahkan.  Penundaan ini terjadi selama setiap permintaan. <br><br><h2>  <font color="#3AC1EF">Tugas optimasi</font> </h2><br>  Berdasarkan analisis di atas, kami merumuskan beberapa tugas yang perlu kami selesaikan untuk mengoptimalkan proyek.  Inilah mereka: <br><br><ul><li>  Meningkatkan kecepatan mengeksekusi permintaan API atau mengurangi jumlah permintaan API yang memblokir rendering. </li><li>  Mengurangi ukuran bundel JS atau mengonversi bundel ini ke sumber daya yang tidak diperlukan untuk output halaman. </li><li>  Membuka kunci utas. </li></ul><br><h2>  <font color="#3AC1EF">Pendekatan Masalah</font> </h2><br>  Berikut adalah beberapa pendekatan untuk menyelesaikan masalah yang kami pertimbangkan: <br><br><ol><li>  Optimasi kode dengan maksud untuk mempercepat pelaksanaannya.  Pendekatan ini membutuhkan banyak usaha, ia memiliki biaya tinggi.  Manfaat yang dapat diperoleh sebagai hasil dari optimasi tersebut diragukan. </li><li>  Tingkatkan jumlah RAM yang tersedia untuk fitur AWS Lambda.  Mudah dilakukan, biaya solusi semacam itu ada di antara menengah dan tinggi.  Hanya efek positif kecil yang dapat diharapkan dari penerapan solusi ini. </li><li>  Penggunaan beberapa cara lain untuk menyelesaikan masalah.  Benar, pada saat itu kami belum tahu apa metode ini. </li></ol><br>  Pada akhirnya, kami memilih item ketiga dalam daftar ini.  Kami beralasan seperti ini: â€œBagaimana jika kami benar-benar tidak memerlukan panggilan API?  Bagaimana jika kita dapat melakukannya tanpa bundel JS sama sekali?  Ini akan memungkinkan kami untuk menyelesaikan semua masalah proyek. " <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f69/476/84a/f6947684a7a537bba4b9dfeb24f524e6.jpg"></div><br>  Gagasan pertama yang kami temukan menarik adalah membuat snapshot HTML dari halaman yang diberikan dan membagikan snapshot dengan pengguna. <br><br><h2>  <font color="#3AC1EF">Usaha yang gagal</font> </h2><br>  Webiny Cloud adalah infrastruktur tanpa server berbasis AWS Lambda yang mendukung situs Webiny.  Sistem kami dapat mendeteksi bot.  Ketika ternyata permintaan itu diselesaikan oleh bot, permintaan ini dialihkan ke instance <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Puppeteer</a> , yang menjadikan halaman menggunakan Chrome tanpa antarmuka pengguna.  Kode HTML yang sudah jadi dari halaman dikirim ke bot.  Ini dilakukan terutama karena alasan SEO, karena fakta bahwa banyak bot tidak tahu cara menjalankan JavaScript.  Kami memutuskan untuk menggunakan pendekatan yang sama untuk menyiapkan halaman yang ditujukan untuk pengguna biasa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bd/698/219/8bd698219b68cccfa5db9f9f81611111.png"></div><br>  Pendekatan ini bekerja dengan baik di lingkungan yang tidak memiliki dukungan JavaScript.  Namun, jika Anda mencoba untuk memberikan halaman yang diberikan sebelumnya kepada klien yang browsernya mendukung JS, halaman ditampilkan, tetapi kemudian, setelah mengunduh file JS, komponen Bereaksi tidak tahu di mana harus memasangnya.  Ini menghasilkan sejumlah pesan kesalahan di konsol.  Akibatnya, keputusan seperti itu tidak cocok untuk kita. <br><br><h2>  <font color="#3AC1EF">Memperkenalkan SSR</font> </h2><br>  Sisi kuat dari Server Side Rendering (SSR) adalah bahwa semua permintaan API dieksekusi dalam jaringan lokal.  Karena mereka diproses oleh sistem atau fungsi tertentu yang berjalan di dalam VPC, penundaan yang terjadi saat menjalankan permintaan dari browser ke backend sumber daya tidak seperti biasanya.  Meskipun dalam skenario ini, masalah "mulai dingin" tetap. <br><br>  Keuntungan tambahan menggunakan SSR adalah bahwa kami memberikan klien versi HTML halaman tersebut, ketika bekerja dengan itu, setelah memuat file JS, komponen Bereaksi tidak memiliki masalah dengan pemasangan. <br><br>  Dan akhirnya, kita tidak membutuhkan bundel JS yang sangat besar.  Selain itu, kita dapat melakukannya tanpa panggilan API untuk menampilkan halaman.  Bundel dapat dimuat secara tidak sinkron dan ini tidak akan memblokir utas. <br><br>  Secara umum, kita dapat mengatakan bahwa rendering server, tampaknya, seharusnya telah menyelesaikan sebagian besar masalah kita. <br><br>  Ini adalah bagaimana analisis situs terlihat setelah menerapkan rendering sisi server. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/370/5df/38e/3705df38e8b3a2c697f04bed1d0d577e.png"></div><br>  <i><font color="#999999">Metrik situs setelah menerapkan rendering server</font></i> <br><br>  Sekarang permintaan API tidak dieksekusi, dan halaman dapat dilihat sebelum bundel JS besar dimuat.  Tetapi jika Anda melihat dekat pada permintaan pertama, Anda dapat melihat bahwa dibutuhkan hampir 2 detik untuk mendapatkan dokumen dari server.  Mari kita bicarakan. <br><br><h2>  <font color="#3AC1EF">Masalah dengan TTFB</font> </h2><br>  Di sini kita membahas metrik TTFB (Time To First Byte, time to byte pertama).  Berikut ini rincian permintaan pertama. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d3/19e/9ec/8d319e9eca081b8cba644d7829ccf56e.png"></div><br>  <i><font color="#999999">Detail Permintaan Pertama</font></i> <br><br>  Untuk memproses permintaan pertama ini, kita perlu melakukan hal berikut: meluncurkan server Node.js, melakukan rendering server, membuat permintaan API dan mengeksekusi kode JS, dan kemudian mengembalikan hasil akhir ke klien.  Masalahnya di sini adalah bahwa semua ini, rata-rata, membutuhkan waktu 1-2 detik. <br><br>  Server kami, yang melakukan rendering server, perlu melakukan semua pekerjaan ini, dan hanya setelah itu ia akan dapat mengirimkan byte pertama dari respons ke klien.  Ini mengarah pada fakta bahwa browser memiliki waktu yang sangat lama untuk menunggu dimulainya respons terhadap permintaan.  Sebagai hasilnya, ternyata sekarang untuk output halaman yang Anda butuhkan untuk menghasilkan jumlah pekerjaan yang hampir sama seperti sebelumnya.  Satu-satunya perbedaan adalah bahwa pekerjaan ini dilakukan bukan pada sisi klien, tetapi pada server, dalam proses rendering server. <br><br>  Di sini Anda mungkin memiliki pertanyaan tentang kata "server".  Kami telah berbicara tentang sistem tanpa server selama ini.  Dari mana "server" ini berasal?  Kami, tentu saja, mencoba membuat rendering server dalam fungsi AWS Lambda.  Tetapi ternyata ini adalah proses yang sangat memakan sumber daya (khususnya, itu perlu untuk meningkatkan jumlah memori sangat banyak untuk mendapatkan lebih banyak sumber daya prosesor).  Selain itu, masalah "mulai dingin", yang telah kami sebutkan, juga ditambahkan di sini.  Akibatnya, maka solusi ideal adalah menggunakan server Node.js yang akan memuat materi situs dan terlibat dalam rendering sisi server dari mereka. <br><br>  Mari kita kembali ke konsekuensi menggunakan rendering sisi server.  Lihatlah storyboard berikut.  Mudah untuk melihat bahwa itu tidak jauh berbeda dari apa yang diperoleh dalam studi proyek, yang diberikan pada klien. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc5/ed3/8c4/fc5ed38c4250cfe6592af448b7f0fd30.png"></div><br>  <i><font color="#999999">Pemuatan halaman saat menggunakan rendering sisi server</font></i> <br><br>  Pengguna dipaksa untuk melihat halaman kosong selama 2,5 detik.  Ini menyedihkan. <br><br>  Walaupun melihat hasil-hasil ini, orang mungkin berpikir bahwa kita sama sekali tidak mencapai apa-apa, ini sebenarnya tidak begitu.  Kami memiliki snapshot HTML dari halaman yang berisi semua yang kami butuhkan.  Tembakan ini siap bekerja dengan Bereaksi.  Pada saat yang sama, selama pemrosesan halaman pada klien, tidak perlu melakukan permintaan API apa pun.  Semua data yang diperlukan sudah tertanam dalam HTML. <br><br>  Satu-satunya masalah adalah pembuatan snapshot HTML ini memakan waktu terlalu lama.  Pada titik ini, kami dapat menginvestasikan lebih banyak waktu untuk mengoptimalkan rendering server, atau cukup men-cache hasil-hasilnya dan memberi klien snapshot halaman dari sesuatu seperti cache Redis.  Kami melakukan hal itu. <br><br><h2>  <font color="#3AC1EF">Caching hasil rendering server</font> </h2><br>  Setelah pengguna mengunjungi situs Webiny, pertama-tama kami memeriksa cache Redis yang terpusat untuk melihat apakah ada snapshot HTML halaman tersebut.  Jika demikian, kami memberikan pengguna sebuah halaman dari cache.  Rata-rata, ini menurunkan TTFB menjadi 200-400 ms.  Itu setelah pengenalan cache bahwa kami mulai melihat peningkatan yang signifikan dalam kinerja proyek. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01e/28d/37e/01e28d37ec4b2586d8a9d8d5187716c9.png"></div><br>  <i><font color="#999999">Pemuatan halaman saat menggunakan rendering sisi server dan cache</font></i> <br><br>  Bahkan pengguna yang mengunjungi situs untuk pertama kalinya, melihat konten halaman dalam waktu kurang dari satu detik. <br><br>  Mari kita lihat bagaimana tampilan diagram air terjun. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/629/40f/f4c/62940ff4c6f1136c2534c3c299b343c9.png"></div><br>  <i><font color="#999999">Metrik situs setelah menerapkan rendering dan caching sisi server</font></i> <br><br>  Garis merah menunjukkan cap waktu 800 ms.  Di sinilah konten halaman dimuat sepenuhnya.  Selain itu, di sini Anda dapat melihat bahwa bundel JS dimuat sekitar 1,3 detik.  Tetapi ini tidak mempengaruhi waktu yang dibutuhkan pengguna untuk melihat halaman.  Pada saat yang sama, Anda tidak perlu melakukan panggilan API dan memuat utas utama untuk menampilkan halaman. <br><br>  Perhatikan fakta bahwa indikator sementara tentang memuat bundel JS, menjalankan permintaan API, dan melakukan operasi di utas utama masih memainkan peran penting dalam mempersiapkan halaman untuk bekerja.  Investasi waktu dan sumber daya ini diperlukan agar halaman menjadi "interaktif".  Tapi ini tidak memainkan peran apa pun, pertama, untuk bot mesin pencari, dan kedua, untuk menciptakan perasaan "pemuatan halaman cepat" di antara pengguna. <br><br>  Misalkan halaman adalah "dinamis".  Misalnya, ini menampilkan tautan di header untuk mengakses akun pengguna jika pengguna yang melihat halaman tersebut masuk.  Setelah rendering sisi server, halaman tujuan umum akan dikirim ke browser.  Yaitu - yang ditampilkan kepada pengguna yang tidak masuk.  Judul halaman ini akan berubah, yang mencerminkan fakta bahwa pengguna masuk, hanya setelah bundel JS dimuat dan panggilan API dilakukan.  Di sini kita berurusan dengan indikator <a href="">TTI</a> (Waktu Ke Interaktif, waktu untuk interaktivitas pertama). <br><br>  Setelah beberapa minggu, kami menemukan bahwa server proxy kami tidak menutup koneksi dengan klien jika diperlukan, jika rendering server diluncurkan sebagai proses latar belakang.  Koreksi satu baris kode menyebabkan fakta bahwa indikator TTFB berkurang hingga level 50-90 ms.  Akibatnya, situs tersebut sekarang mulai ditampilkan di browser setelah sekitar 600 ms. <br><br>  Namun, kami menghadapi masalah lain ... <br><br><h2>  <font color="#3AC1EF">Masalah pembatalan cache</font> </h2><br>  <i><font color="#999999">"Dalam ilmu komputer, hanya ada dua hal kompleks: pembatalan cache dan penamaan entitas."</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999">Phil Carleton</font></i> <br><br>  Pembatalan cache, memang, tugas yang sangat sulit.  Bagaimana cara mengatasinya?  Pertama, Anda sering dapat memperbarui cache dengan mengatur waktu penyimpanan yang sangat singkat untuk objek yang di-cache (TTL, Time To Live, Seumur Hidup).  Ini terkadang menyebabkan halaman dimuat lebih lambat dari biasanya.  Kedua, Anda dapat membuat mekanisme pembatalan cache berdasarkan peristiwa tertentu. <br><br>  Dalam kasus kami, masalah ini diselesaikan menggunakan TTL yang sangat kecil 30 detik.  Tetapi kami juga menyadari kemungkinan menyediakan data usang dari cache kepada klien.  Pada saat klien menerima data seperti itu, cache sedang diperbarui di latar belakang.  Berkat ini, kami menyingkirkan masalah, seperti penundaan dan "mulai dingin", yang khas untuk fungsi AWS Lambda. <br><br>  Begini cara kerjanya.  Seorang pengguna mengunjungi situs web Webiny.  Kami sedang memeriksa cache HTML.  Jika ada tangkapan layar halaman, kami berikan kepada pengguna.  Usia gambar bahkan bisa beberapa hari.  Dengan mengirimkan snapshot lama ini kepada pengguna dalam beberapa ratus milidetik, kami secara bersamaan meluncurkan tugas untuk membuat snapshot baru dan memperbarui cache.  Biasanya diperlukan beberapa detik untuk menyelesaikan tugas ini, karena kami menciptakan mekanisme berkat itu kami selalu memiliki sejumlah fungsi AWS Lambda yang sudah berjalan dan siap untuk bekerja.  Oleh karena itu, kita tidak harus, selama pembuatan gambar baru, menghabiskan waktu di awal dingin fungsi. <br><br>  Akibatnya, kami selalu mengembalikan halaman dari cache ke klien, dan ketika usia data yang di-cache mencapai 30 detik, konten cache diperbarui. <br><br>  Caching jelas merupakan area di mana kita masih bisa meningkatkan sesuatu.  Misalnya, kami mempertimbangkan kemungkinan memperbarui cache secara otomatis ketika pengguna menerbitkan halaman.  Namun, mekanisme pembaruan cache seperti itu juga tidak ideal. <br><br>  Misalnya, beranda beranda sumber daya menampilkan tiga posting blog terbaru.  Jika cache diperbarui ketika halaman baru diterbitkan, maka, dari sudut pandang teknis, hanya cache untuk halaman baru ini yang akan dihasilkan setelah publikasi.  Tembolok untuk halaman rumah akan kedaluwarsa. <br><br>  Kami masih mencari cara untuk meningkatkan sistem caching proyek kami.  Namun sejauh ini, fokusnya adalah memilah masalah kinerja yang ada.  Kami percaya bahwa kami telah melakukan pekerjaan yang cukup baik dalam hal menyelesaikan masalah ini. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Pada awalnya, kami menggunakan rendering sisi klien.  Kemudian, secara rata-rata, pengguna dapat melihat halaman dalam 3,3 detik.  Sekarang, angka ini telah turun menjadi sekitar 600 ms.  Penting juga bahwa kita sekarang membuang indikator pengunduhan. <br><br>  Untuk mencapai hasil ini, kami diizinkan, terutama, menggunakan rendering server.  Tetapi tanpa sistem caching yang baik, ternyata perhitungannya hanya berpindah dari klien ke server.  Dan ini mengarah pada fakta bahwa waktu yang diperlukan bagi pengguna untuk melihat halaman tidak banyak berubah. <br><br>  Penggunaan rendering server memiliki kualitas positif lain, tidak disebutkan sebelumnya.  Kita berbicara tentang fakta bahwa membuatnya lebih mudah untuk melihat halaman pada perangkat seluler yang lemah.  Kecepatan menyiapkan halaman untuk dilihat pada perangkat semacam itu tergantung pada kemampuan sederhana dari prosesor mereka.  Server rendering memungkinkan Anda untuk menghapus sebagian dari beban dari mereka.  Perlu dicatat bahwa kami tidak melakukan studi khusus tentang masalah ini, tetapi sistem yang kami miliki harus membantu meningkatkan tampilan situs di ponsel dan tablet. <br><br>  Secara umum, kita dapat mengatakan bahwa implementasi rendering server bukanlah tugas yang mudah.  Dan fakta bahwa kami menggunakan lingkungan tanpa server hanya mempersulit tugas ini.  Solusi untuk masalah kami memerlukan perubahan kode, infrastruktur tambahan.  Kami perlu membuat mekanisme caching yang dirancang dengan baik.  Tetapi sebagai gantinya, kami mendapat banyak hal baik.  Yang paling penting adalah halaman-halaman situs kami sekarang memuat dan bersiap-siap untuk bekerja lebih cepat dari sebelumnya.  Kami percaya pengguna kami akan menyukainya. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan teknologi caching dan rendering server untuk mengoptimalkan proyek Anda? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459306/">https://habr.com/ru/post/id459306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459296/index.html">Harga JavaScript 2019</a></li>
<li><a href="../id459298/index.html">Sudut: status pada 2019</a></li>
<li><a href="../id459300/index.html">Quasar 1.0: alat berguna baru untuk pengembang Vue dan tidak hanya untuk mereka</a></li>
<li><a href="../id459302/index.html">Mencoba ulang permintaan HTTP yang gagal di Angular</a></li>
<li><a href="../id459304/index.html">Bypass Pitfall Angular dan Penghematan Waktu</a></li>
<li><a href="../id459308/index.html">SEO tidak berfungsi di 2019?</a></li>
<li><a href="../id459310/index.html">Alat uji otomatisasi atau penguji steroid seluler</a></li>
<li><a href="../id459312/index.html">Dear Agile, aku muak berpura-pura</a></li>
<li><a href="../id459314/index.html">Visualisasikan dan hadapi Hash Match Join</a></li>
<li><a href="../id459316/index.html">Hydra 2019: siaran gratis aula pertama dan sedikit tentang apa yang akan ada di konferensi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>