<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🔧 🍅 ⏱️ Bildschirmübergänge in Legend of Zelda verwenden die undokumentierten Funktionen von NES 👩‍❤️‍👨 🌌 🆒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Für den Effekt des vertikalen Bildlaufs im ersten Teil von „The Legend of Zelda“ werden NES-Grafik- „Hardware“ -Manipulationen verwendet, die von den ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bildschirmübergänge in Legend of Zelda verwenden die undokumentierten Funktionen von NES</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460383/">  Für den Effekt des vertikalen Bildlaufs im ersten Teil von „The Legend of Zelda“ werden NES-Grafik- „Hardware“ -Manipulationen verwendet, die von den Konsolenentwicklern höchstwahrscheinlich nicht bereitgestellt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/466/3d0/6314663d04d4e3ed0d86c7e6d9b8611a.png" width="512"></div><br>  Ich habe keinen Zugriff auf die offizielle Dokumentation der Picture Processing Unit (PPU - Grafikchip) der NES-Konsole, daher sind meine Aussagen zu "undefiniertem Verhalten" eher Vermutungen.  Ich habe die Spezifikation der Grafikhardware aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NesDev-Wiki übernommen</a> .  Die PPU wird durch Schreiben in Register mit Speicherzuordnung gesteuert.  Wenn Sie diese Register so verwenden, wie es (wie es scheint) von den Designern konzipiert wurde, ist es unmöglich, diesen Effekt zu erzielen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/b0e/51c/8a5b0e51c195fb1e9ba9ca282f54e61a.gif" width="512"></div><br>  Wenn Sie den Bildschirm vertikal scrollen, sollte der gesamte Bildschirm auf einmal scrollen.  Das vorherige GIF zeigt ein Beispiel für teilweises vertikales Scrollen.  Ein Teil des Bildschirms bleibt stationär (Schnittstellenelemente) und der andere Teil (Spielbereich) rollt vertikal.  Ein teilweises vertikales Scrollen ist mit der "Standard" -Arbeit mit PPU nicht möglich. <br><br>  Im Gegensatz dazu ist ein teilweises <em>horizontales</em> Scrollen vollständig definiert und möglich. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae7/c29/539/ae7c295393f6706e17e788e0a1cc39e7.gif" width="512"></div><br>  Das Schreiben in ein separates PPU-Register zum Zeitpunkt des Zeichnens des Frames kann zu grafischen Artefakten führen.  Die Legende von Zelda verursacht absichtlich ein Artefakt, das sich als partielles vertikales Scrollen manifestiert.  In diesem Beitrag werde ich ein wenig über NES-Grafikhardware sprechen und erklären, wie der Trick des vertikalen Bildlaufs funktioniert. <br><a name="habracut"></a><br><h2>  Arten von Grafiken </h2><br>  Die NES-Konsole verfügt über zwei Arten von Grafiken: <br><br><ul><li>  Sprites sind Kacheln, die an beliebigen Stellen auf dem Bildschirm platziert und unabhängig voneinander verschoben werden können. </li><li>  Hintergrund - Ein Kachelraster, das problemlos als einzelnes Bild gescrollt werden kann. </li></ul><br>  Um den Unterschied zwischen den beiden zu demonstrieren, werde ich eine Szene zeigen, die aus Sprites und Hintergrund besteht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f75/f9b/138/f75f9b138db2e818cbdb9b2fb1e7b27b.gif" width="512"></div><br>  Und hier ist dieselbe Szene, in der nur Sprites sichtbar sind: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e8/26d/817/5e826d817b637fc450046aee1473abaf.gif" width="512"></div><br>  Und hier ist eine Szene, in der nur der Hintergrund sichtbar ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d81/b9c/bd7/d81b9cbd7bb5101f663d4decc5ebaef7.gif" width="512"></div><br><h2>  Scrollen </h2><br>  Der Bildprozessor (NES Picture Processor) unterstützt das Scrollen von Hintergrundbildern.  Im Grafikspeicher wird das Hintergrunddiagramm als zweidimensionales Kachelraster gespeichert, das einen Bereich abdeckt, der doppelt so breit und hoch wie der Bildschirm ist. <br><br>  In diesem Raster wird auf dem Bildschirm ein „Fenster“ in der Größe eines Bildschirms angezeigt, und die Position dieses Fensters kann präzise gesteuert werden.  Durch schrittweises Verschieben des sichtbaren Fensters entlang des Rasters wird ein sanfter Bildlaufeffekt erzeugt. <br><br>  Das ausgegebene NES-Videosignal hat eine Größe von 256 x 240 Pixel.  Das Kachelraster im Speicher wird als 512 x 480 Pixel große Fläche dargestellt und in vier bildschirmgroße Rechtecke unterteilt, die als "Namenstabellen" bezeichnet werden.  Spiele können die Picture Processing Unit (PPU) konfigurieren, indem sie die Position des sichtbaren Fensters durch Auswahl der Pixelkoordinate im Raster der Namenstabellen angeben. <br><br>  Wenn Sie die Koordinate (0, 0) auswählen, wird die gesamte obere linke Namenstabelle auf dem Bildschirm angezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d3/b5d/47f/5d3b5d47f8efdfcac271a2a7e0222e57.png"></div><br>  Wenn wir zu (125, 181) übergehen, sehen wir aus jeder Namenstabelle ein wenig: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/78f/189/91278f1891416d9f15a69238e64d1422.png"></div><br>  Das sichtbare Fenster wird auf die Rückseite des Kachelrasters im Speicher minimiert.  Wenn wir zu (342, 290) übergehen, platzieren wir die obere linke Ecke des sichtbaren Bildschirms in der unteren rechten Namenstabelle. Dank der Faltung sind Teile jeder Namenstabelle sichtbar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e6/394/c93/6e6394c9325985807a97765ebe015bcf.png"></div><br><h3>  Nicht genug Speicher! </h3><br>  Jede Namenstabelle hat eine Größe von 1 KB, aber NES weist diesen Tabellen nur 2 KB seines Videospeichers zu, sodass jeweils nur zwei Namenstabellen in den Speicher passen. <br><br>  Wie kann es vier Namenstabellen haben? <br><br><h4>  Spiegeln von Namenstabellen </h4><br>  Der Videospeicher ist so mit der PPU verbunden, dass, wenn die PPU eine Kachel einer der vier scheinbaren Namenstabellen rendert, tatsächlich eine der beiden realen Tabellen ausgewählt wird und das Lesen von dort kommt.  Im Wesentlichen bedeutet dies, dass die vier sichtbaren Namenstabellen tatsächlich aus zwei identischen Tabellenpaaren bestehen. <br><br>  Dieses Bild zeigt eine Momentaufnahme des Inhalts aller vier Tabellen.  Oben links und oben rechts sind die gleichen wie in den beiden unteren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/5b8/9b2/0515b89b2afcf122ce8df6e97e97a0a8.png" width="1024"></div><br>  Warum dann nicht einfach zwei Namenstabellen führen? <br><br>  Glücklicherweise kann die genaue Bindung zwischen der scheinbaren und der realen Tabelle zur Laufzeit konfiguriert werden.  Wenn das Spiel horizontales Scrollen ausführen möchte, wird die Grafikausrüstung so angepasst, dass die Tabellen oben links und oben rechts unterschiedlich sind und ohne merkliche Duplizierung gescrollt werden können.  In dieser Konfiguration beziehen sich die Tabellen oben links und unten links auf dieselbe Tabelle mit echten Namen.  ähnlich für die beiden rechten Tabellen.  Diese Konfiguration wird als vertikale Spiegelung bezeichnet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/d85/49d/1e3d8549d5427f7f7271595dc5c6f49b.png"></div><br>  Es gibt auch eine andere mögliche Konfiguration - "Horizontale Spiegelung", die Spiele für vertikales Scrollen verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/650/6a2/528/6506a2528cba5d758301f72c80f48e8b.png"></div><br>  In der Regel scrollen Spiele nicht diagonal, da durch die Spiegelung der Namenstabellen Artefakte an den Bildschirmrändern entstehen. <br><br><h3>  Patronen </h3><br>  Die Kassette jedes Spiels verfügt über Hardware, mit der Sie die Tabellenspiegelung konfigurieren können. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a44/8ed/3dc/a448ed3dc3849ac558d39ba0bfc5309d.jpg" width="50%"></div><br>  Einige Spiele müssen die Spiegelung überhaupt nicht wechseln, daher ist die horizontale oder vertikale Spiegelung in ihren Kassetten fest codiert.  Andere Spiele wechseln dynamisch zwischen diesen beiden Modi, sodass die Spiegelung in ihren Kassetten programmgesteuert konfiguriert wird.  Die Legende von Zelda gehört zur zweiten Kategorie.  Schließlich verfügen die Kassetten einiger wirklich komplexer Spiele über zusätzlichen Videospeicher, dh sie müssen überhaupt nicht gespiegelt werden: Sie können gleichzeitig vertikal und horizontal ohne sichtbare Duplizierungsartefakte scrollen. <br><br><h3>  Echtes Beispiel </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/d58/80e/d0ad5880e16ce58d53ee2eb922c4da04.gif" width="512"></div><br>  <i>Ein Beispiel für vertikales Scrollen, das auf dem Bildschirm angezeigt wird.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/ff0/b01/7bbff0b019dadb96e423ebc744aeb12c.gif" width="1024"></div><br>  <i>Dies zeigt eine Aufzeichnung von Namenstabellen mit horizontaler Spiegelung.</i>  <i>Das aktuell sichtbare Fenster wird hervorgehoben.</i> <br><br>  Denken Sie daran, dass das vertikalste Scrollen nicht ungewöhnlich ist - das ungewöhnliche ist das vertikale Scrollen mit <em>geteiltem Bildschirm</em> . <br><br><h2>  Geteilter Bildschirm </h2><br>  Jeder Frame des von NES erzeugten Videosignals wird von oben nach unten gerendert, jeweils eine Pixelreihe.  In jeder Zeile werden die Pixel einzeln von links nach rechts gezeichnet.  Auf halbem Weg beim Rendern des Frames kann das Spiel die PPU neu konfigurieren, was sich auf die Anzeige von Pixeln auswirkt, die noch nicht gerendert wurden.  Eine der häufigsten Änderungen in der Mitte des Rahmens ist das Aktualisieren der horizontalen Bildlaufposition. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/873/536/98f/87353698fa1a10a55f37d5f56ebfaefd.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/502/8e9/c645028e950b7e202815d7c4ad560fac.gif" width="1024"></div><br>  Wenn Sie horizontal zwischen Räumen scrollen, beginnt The Legend of Zelda immer an der Bildlaufposition (0, 0) und rendert die Oberflächenelemente am oberen Bildschirmrand.  Nach dem Zeichnen der letzten Zeile der Schnittstellenpixel auf dem Bildschirm ändert sich das horizontale Scrollen um einen Wert, der mit jedem Bild zunimmt, sodass sich die Kamera reibungslos bewegt. <br><br>  Die Animation der Anzeige der Namenstabellen zeigt, wie das Spiel vor dem Scrollen von der horizontalen zur vertikalen Spiegelung und nach Abschluss des Übergangs wieder zur horizontalen Spiegelung wechselt.  Während das Scrollen fortgesetzt wird, werden außerdem die Namenstabellen oben links (und unten links) aktualisiert und eine Kopie des Raums, den der Spieler betritt, wird darin aufgezeichnet.  Nachdem der Bildlauf abgeschlossen ist, teilt das Spiel den Bildschirm nicht mehr und wird wieder vollständig aus der oberen linken Tabelle gerendert. <br><br><h3>  Rendering-Messung </h3><br>  Um den Bildschirm in die gewünschte Position zu teilen, muss das Spiel irgendwie herausfinden, welcher Teil des aktuellen Rahmens gezeichnet wurde.  Pixelstrings werden mit einer bekannten Frequenz gerendert, sodass die Anzahl der gerenderten Pixelstrings durch Zählen der Anzahl der Prozessorzyklen bestimmt werden kann, die seit Beginn des Frames vergangen sind. <br><br>  Es gibt eine andere, genauere Technik namens Sprite Zero Hit. <br><br>  NES kann bis zu 64 Sprites gleichzeitig rendern.  Das erste Sprite im Videospeicher heißt Sprite Zero (Zero Sprite).  In jedem Frame tritt das Sprite Zero Hit-Ereignis auf, sobald ein undurchsichtiges Pixel eines Null-Sprites einem undurchsichtigen Hintergrundpixel überlagert wird.  Es setzt ein Bit in eines der PPU-Register mit Speicherzuordnung, das vom Prozessor überprüft werden kann. <br><br>  Um Sprite Zero Hit zum Teilen des Bildschirms zu verwenden, platzieren Spiele das Zero Sprite an einer vertikalen Position nahe dem geteilten Rand und überprüfen während des Renderns ständig, ob das Sprite Zero Hit-Ereignis aufgetreten ist.  In diesem Fall wechselt das Spiel vom horizontalen Scrollen, um die Trennung zu implementieren. <br><br>  Der horizontale Übergang zwischen Räumen mit und ohne Hintergrund ist unten dargestellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71b/27a/076/71b27a0768844603020981c26b3f5124.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c4/4c1/95d/2c44c195dfac0b6c2d6b10aaf11674aa.gif" width="512"></div><br><br>  Der braune Kreis, der am Anfang des Übergangs erscheint und am Ende verschwindet, ist ein Null-Sprite.  Wir werden uns die Benutzeroberfläche mit und ohne Hintergrund genauer ansehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/373/83d/39b37383d425937e8e5cdb598656bac5.png" width="322"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7d/6f9/ebe/c7d6f9ebeb7c7e066e6d349eb8c57914.png" width="322"></div><br>  Ein Zero-Sprite ist ein gebleichtes Bomben-Sprite, das perfekt zum regulären Bomben-Sprite über die Spieloberfläche passt.  Das Null-Sprite ist so konfiguriert, dass es unter dem Hintergrund angezeigt wird. Da jedoch die schwarzen Pixel der Schnittstelle als transparent betrachtet werden, wäre die Null-Sprite-Bombe sichtbar, wenn sie nicht strategisch hinter der Bombe vor der Schnittstelle verborgen worden wäre. <br><br>  Beachten Sie, dass Sprite Zero Hit einige Pixelzeilen vor der unteren Zeile der Benutzeroberfläche auftritt.  Es tritt am oberen Pixel der Bombensicherung auf, die 16 Pixel vom unteren Rand der Schnittstelle entfernt ist.  Wenn Sprite Zero Hit auftritt, beginnt das Spiel mit dem Zählen der Prozessorzyklen und nach Abschluss der erforderlichen Anzahl von Zyklen wird das horizontale Scrollen eingestellt. <br><br><h2>  Strahlausblendung </h2><br>  Meistens zeichnet die Konsolen-PPU Pixel auf den Bildschirm.  Es gibt eine kurze Ausfallzeit zwischen Frames, während der das Rendern nicht durchgeführt wird.  Dieses Phänomen wird als Austastung (Vertical Blank oder vblank) bezeichnet.  Einige Arten von Änderungen an der PPU-Konfiguration können nur während vblank vorgenommen werden. <br><br><h2>  Bildlaufregister </h2><br>  Spiele ändern die <code>PPUSCROLL</code> , indem sie in das PPU-Register <code>PPUSCROLL</code> , das der Speicheradresse <code>0x2005</code> .  Die erste Schreiboperation in <code>PPUSCROLL</code> definiert die X-Komponente der <code>PPUSCROLL</code> , und die zweite Operation setzt die Y-Komponente. In ähnlicher Weise wird eine alternative Aufzeichnung weiter durchgeführt. <br><br>  Das Folgende zeigt alle Nicht-Null-Schreibvorgänge in <code>PPUSCROLL</code> während dieser Wiedergabe (in Zeitlupe) 16 Bilder des Bildschirms mit der Handlung des Spiels.  Die Bildlaufpositionskomponente Y wird alle zwei Frames erhöht.  Alle Schreibvorgänge in <code>PPUSCROLL</code> in diesem Beispiel werden während vblank ausgeführt, wodurch der gesamte Hintergrund mitgescrollt wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cad/0d1/003/cad0d1003d55488a17d988e6607739f2.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bc/ffb/c09/1bcffbc09db9bfe792ba85981acbe4b3.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/rz/fi/kgrzfigaydwrvo3qqth5bcmkecq.png"></div><br><h3>  Scrolling Screen Split </h3><br>  Schreibvorgänge in <code>PPUSCROLL</code> während vblank werden am Anfang des unmittelbar nach vblank gezeichneten Frames wirksam.  Wenn sich die Bildlaufposition während des Renderns des Rahmens ändert (d. H. Nicht während vblank), wird diese Änderung wirksam, wenn die Zeichnung die nächste Pixelreihe erreicht.  Teilweises horizontales Scrollen wird durch Schreiben in <code>PPUSCROLL</code> implementiert, während das PPU-Gerät vor dem Scrollen die letzte <code>PPUSCROLL</code> zeichnet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddf/e12/b49/ddfe12b49ce180cb921243f32e77351a.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/38c/0bb/4be38c0bb335a414ce99a2c8d2145009.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cu/uu/1t/cuuu1twsw4wbeynzisaewszsqo8.png"></div><br>  Beim Aktualisieren der Bildlaufposition in der Bildmitte wird nur die X-Position der Bildlaufposition angewendet.  Das heißt, die Bildlaufpositionskomponente Y wird verworfen.  Wenn das Spiel den Bildschirm teilen und die Position des Bildlaufteils des Rahmens ändern möchte, kann es nur horizontal scrollen. <br><br>  Und trotzdem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/93e/4b7/1a093e4b76c8382f08d33b4202391094.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/184/2b0/7601842b02f37dc10abd97b93e0a9ec2.gif" width="1024"></div><br>  <code>PPUSCROLL</code> Sie es glauben oder nicht, der Wert des <code>PPUSCROLL</code> Registers <code>PPUSCROLL</code> sich während dieses Übergangs nicht geändert. <br><br>  Sie können ein ein Pixel hohes grafisches Artefakt unter der Benutzeroberfläche sehen.  Dies ist ein Fehler meines Emulators, der durch die fehlende Synchronisation der Prozessortaktzyklen mit der pixelweisen Wiedergabe verursacht wird. <br><br><h3>  Eingriffe in andere Register </h3><br>  Das zweite Register mit der Bezeichnung <code>PPUADDR</code> , das der Speicheradresse <code>0x2006</code> ist, wird zum Einstellen der aktuellen Videospeicheradresse verwendet.  Wenn ein Spiel beispielsweise eine der Kacheln in der Namenstabelle ändern möchte, schreibt es zuerst die Videospeicheradresse der <code>PPUADDR</code> in <code>PPUADDR</code> und dann den neuen Wert der <code>PPUDATA</code> in <code>PPUDATA</code> - dies ist das dritte Register, das der Adresse <code>0x2007</code> . <br><br>  Das Schreiben in <code>PPUADDR</code> nicht während vblank (d. H. Beim Rendern eines Frames) kann grafische Artefakte verursachen.  Dies liegt daran, dass die PPU-Kette, die vom Schreiben in <code>PPUADDR</code> betroffen ist, auch direkt vom PPU-Gerät gesteuert wird, <code>PPUADDR</code> Kacheln aus dem Videospeicher zum Zeichnen <code>PPUADDR</code> .  Da das Rendern auf dem Bildschirm von oben nach unten und von links nach rechts innerhalb der Linie ausgeführt wird, weist die PPU <code>PPUADDR</code> Wesentlichen <code>PPUADDR</code> Wert der Adresse der aktuell gezeichneten <code>PPUADDR</code> .  Wenn das Rendern von einer Kachel zur nächsten <code>PPUADDR</code> wird, wird <code>PPUADDR</code> um den aktuellen Wert erhöht. <br><br>  Somit kann das Schreiben in <code>PPUADDR</code> in der Mitte des Rahmens die von der PPU aus dem Speicher empfangenen Kacheln für die Dauer des aktuellen Rahmens ändern. <br><br>  Lassen Sie <code>PPUADDR</code> Schreiboperationen während des vertikalen Sprungs zu <code>PPUADDR</code> .  Da die Namenstabelle auch während des Übergangs aktualisiert wird, ist die Ausgabe <em>aller</em> Schreibvorgänge in <code>PPUADDR</code> zu umfangreich.  Bei einem horizontalen Übergang wird das Scrollen während des Renderns einer <code>PPUADDR</code> 63 eingestellt. Daher werden Schreibvorgänge in <code>PPUADDR</code> nur während dieser Zeile in <code>PPUADDR</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/93e/4b7/1a093e4b76c8382f08d33b4202391094.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/184/2b0/7601842b02f37dc10abd97b93e0a9ec2.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3b/w0/iw/3bw0iwoau9zl8frbuh-mgh78-ia.png"></div><br>  Das Muster ist deutlich sichtbar.  Alle zwei Frames wird die in der Pixelzeile 63 aufgezeichnete Adresse um 32 (0x20) reduziert.  Aber wie führt dies zu einer Aktualisierung der tatsächlichen Bildlaufposition? <br><br><h3>  <i>Echtes</i> Bildlaufregister </h3><br>  Innerhalb der PPU befindet sich ein 15-Bit-Register, das nicht der CPU zugeordnet ist.  Es wird sowohl als aktuelle Adresse für den Zugriff auf den Videospeicher als auch als Hintergrund-Scrolling-Konfiguration verwendet. <br><br>  Wenn Sie mit diesem Wert als Adresse arbeiten, wird Bit 14 ignoriert und die Bits 0-13 werden als Adresse im Videospeicher behandelt. <br><br>  Wenn Sie mit diesem Wert als Bildlaufkonfiguration arbeiten, haben die verschiedenen Teile unterschiedliche Bedeutungen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/ot/-q/raot-qzjvlglrxraw3kyrpskouk.png"></div><br>  <strong>Die Auswahl einer Namenstabelle</strong> ist ein Wert zwischen 0 und 3, der die aktuelle Namenstabelle bestimmt, aus der die Zeichnung erstellt wird. <br><br>  <strong>Grobes Scrollen in X</strong> und <strong>Grobes Scrollen in Y</strong> bestimmen die Koordinate der Kachel in der ausgewählten Namenstabelle.  Dies ist die aktuell zu zeichnende Kachel. <br><br>  <strong>Das genaue Scrollen entlang Y</strong> enthält einen Wert von 0 bis 7, der den aktuellen vertikalen Versatz der Pixelzeile innerhalb der aktuellen Kachel bestimmt.  Kacheln sind Quadrate mit einer Seite von 8 Pixeln. <br><br>  In diesem Register fehlt ein <strong>genaues Scrollen auf X.</strong>  Es gibt ein separates Register, das nur den horizontalen Versatz des aktuellen Pixels enthält. Es ist jedoch nicht wichtig zu erklären, wie das vertikale Scrollen in The Legend of Zelda ausgeführt wird. <br><br>  Was passiert mit diesem Register, wenn ein Spiel in <code>PPUADDR</code> schreibt?  Hier sind die ersten drei Schreibvorgänge aus der oben gezeigten Demo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nm/km/2b/nmkm2bpk5osxvd1ohc4kmne7ck4.png"></div><br>  Indem Sie die Einträge an der Adresse in Bildlaufkomponenten aufteilen, können Sie klar verstehen, was hier passiert.  Alle zwei Frames nimmt der Wert des <strong>groben Bildlaufs in Y</strong> ab, was zu einem vertikalen Bildlauf um eine Kachel oder 8 Pixel führt. <br><br>  Während jedes Rahmens beträgt der anfängliche Bildlaufversatz 0,0, wonach die Aufzeichnung auf der Pixelzeile 63 an der Adresse durchgeführt wird.  Dies bedeutet, dass die ersten 63 Pixelzeilen vom oberen Rand der ausgewählten Namenstabelle mit dem Hintergrund der Benutzeroberfläche gezeichnet werden.  Die 64. Pixelreihe wird jedoch weiter gerendert, wobei von dieser Adresse aus vertikales Scrollen angewendet wird.  Da das vertikale Scrollen alle zwei Frames abnimmt, entsteht das Gefühl des vertikalen Scrollens eines Teils des Bildschirms. <br><br><h3>  Scrollen Sie nach unten, um nach oben zu scrollen </h3><br>  Die Legende von Zelda kann diesen Trick nicht vollständig vor den Spielern verbergen.  Auf den vertikalen Übergängen des Bildschirms entsteht ein sichtbares Artefakt, das sich bei genauem Hinsehen bemerkbar macht.  Wenn Sie sich zwischen Räumen bewegen, wird der erste Frame der Bildlaufanimation nach unten gescrollt.  Hier ist die Animation in sehr Zeitlupe. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/a8c/79d/af8a8c79d1b4c50280c31fbf1540852a.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a52/e37/9a6/a52e379a6e5d6dd444fe115d484bb846.gif" width="1024"></div><br>  In der Namenstabelle können Sie sehen, was wirklich passiert.  Obwohl es den Spielern so erscheint, als würde der sichtbare Bereich reibungslos nach oben scrollen, beginnt der Bildlaufübergang damit, dass der sichtbare Bereich von der oberen linken Namenstabelle zur unteren linken Tabelle verschoben wird, die eine Kopie des Hintergrunds des Raums enthält.  Dies ist erforderlich, da die Benutzeroberfläche am oberen Bildschirmrand ebenfalls Teil der Namenstabelle ist. Wenn der sichtbare Bereich von seiner ursprünglichen Position nach oben gescrollt wird, wird die Benutzeroberfläche durchlaufen. <br><br>  Das vertikale Scrollen wird implementiert, indem in das <code>PPUADDR</code> Register in der Mitte des Rahmens geschrieben wird.  Der allererste zu schreibende Wert ist <code>0x2800</code> .  Zwei Bilder später wird <code>0x23A0</code> aufgezeichnet, und dann beginnt der Wert mit jedem zweiten Bild um 32 abzunehmen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/la/gh/pklagh4idqhd3jg_mfkojhfv0lq.png"></div><br>  Durch Schreiben des Werts <code>0x2800</code> in das <code>0x2800</code> Register wird <code>PPUADDR</code> auf 2 gesetzt, was zum Rendern der unteren linken Namenstabelle führt.  Da beide Bildlaufwerte 0 sind, beginnt sie in der oberen linken Kachel dieser Namenstabelle.  Das <strong>genaue Scrollen in Y</strong> ist jedoch 2, sodass ein vertikaler Versatz von zwei Pixeln vom oberen Rand der unteren linken Namenstabelle vorhanden ist.  Aus diesem Grund sehen wir im ersten Frame des Übergangs einen 2 Balken hohen schwarzen Balken am unteren Bildschirmrand.  Der anfängliche Bildlaufwert für die Übergangsanimation wird um 2 Pixel nach unten verschoben, um den Übergang nahtlos zu gestalten. <br><br>  Zwei Frames später wird der <code>PPUADDR</code> in <code>0x23A0</code> .  Dies bringt uns zurück zur oberen linken Namenstabelle und wir rendern aus der 29. Kachelreihe, dh der unteren.  <strong>Das genaue Scrollen in Y</strong> enthält noch 2. <br><br>  Warum muss <strong>Exact Scrolling in Y</strong> auf 2 gesetzt werden?  Warum schreibt das Spiel nicht einfach <code>0x0800</code> und <code>0x03A0</code> , um nicht unter einem Zwei-Pixel-Offset zu leiden? <br><br>  Vier Namenstabellen belegen den 4-KB-Bereich im PPU-Adressraum von <code>0x2000</code> bis <code>0x2FFF</code> .  Jede Kachel in der Tabelle belegt ein Byte Videospeicher (tatsächlich sind sie nur Indizes in einer anderen Tabelle), und die Reihenfolge der Kacheln und Namenstabellen im Videospeicher ist so, dass die <strong>Auswahl einer Tabelle mit Namen</strong> , das <strong>grobe Scrollen nach Y</strong> und das <strong>grobe Scrollen nach X</strong> den Versatz der Kachel im Inneren ausmachen Speicherbereiche mit Namenstabellen.  <code>0x2000</code> Sie also die unteren 12 Bits des internen PPU-Registers nehmen und zu <code>0x2000</code> , finden Sie die <code>0x2000</code> im Videospeicher.  Und das ist kein Zufall!  Genau so sollte das Register behandelt werden: sowohl als Adressregister als auch als Bildlaufregister. <br><br>  Aber es gibt einen Fehler. <br><br>  Bei der Verarbeitung als Adressregister werden die Bits 12 und 13 als Teil der Adresse betrachtet.  Während des Renderns überschreibt die PPU das Register ständig mit der Adresse der aktuell gerenderten Kachel.  Da sich die Kacheln in den Namenstabellen und die Tabellen im Speicherbereich von <code>0x2000</code> bis <code>0x2FFF</code> , weist die PPU dem Register Werte aus diesem Intervall zu. <br><br>  Wenn das Spiel in der Mitte des Frames in <code>PPUADDR</code> schreibt und die <code>PPUADDR</code> in der <code>PPUADDR</code> notiert, <code>PPUADDR</code> die PPU, <em>von einer anderen Stelle</em> im Videospeicher zu lesen.  Alle Bytes, die er zufällig zählt, werden als Kacheln wahrgenommen, was wahrscheinlich zu unerwünschten Ergebnissen führt.  Daher müssen alle in der Mitte des Frames in <code>PPUADDR</code> aufgezeichneten Werte im Bereich von <code>0x2000</code> bis <code>0x2FFF</code> .  Unter Berücksichtigung jeder Zahl in diesem Intervall und unter Berücksichtigung ihrer Bildlaufkomponenten sollte der <strong>exakte Bildlaufwert in Y</strong> immer gleich 2 sein. <br><br>  Diese Einschränkung bedeutet, dass wir das <strong>exakte Scrollen in Y-</strong> Richtung in der Mitte des Rahmens nicht ändern können. Wenn Sie also diesen Trick verwenden, um das vertikale Scrollen der Bildschirmtrennung zu implementieren, können Sie nur 8 Pixel gleichzeitig scrollen und haben immer einen vertikalen Versatz von zwei Pixeln vom Kachelrand.  Die Legende von Zelda verschiebt beim horizontalen Scrollen 4 Pixel pro Frame, beim vertikalen Scrollen jedoch 8 Pixel pro Frame, und jetzt wissen wir warum. <br><br>  Das Artefakt macht sich auch beim Scrollen zwischen den Räumen bemerkbar. In diesem Fall tritt es jedoch am Ende der Animation auf. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/13b/89a/77d13b89abce5200d348de0379f409e5.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/468/eb2/9c2/468eb29c2eb3a97d7e4dd2a62682f1b9.gif" width="1024"></div><br><h2>  Zusätzliche Lektüre </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das NesDev-Wiki</a> ist eine unschätzbare Ressource, um mehr über die NES-Hardware zu erfahren.  Das Thema dieses Beitrags sind insbesondere Seiten zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scrollen der PPU</a> <br>  und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PPU-Register</a> . </li><li>  Mein noch sehr unfertiger NES-Emulator ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> verfügbar. </li></ul><br><h2>  Anmerkungen </h2><br>  Bis ich etwas über das interne Register der PPU erfuhr, zeigte mein Emulator den Effekt des Löschens während vertikaler Übergänge des Bildschirms The Legend of Zelda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/932/2a0/a5a/9322a0a5a1522a0ae0f6fbd21080286e.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1a/078/755/d1a0787558999dd61ec2ba9dc9ba9026.gif" width="1024"></div><br>  Das Sprite von Link bewegte sich wie gewünscht über den Bildschirm, aber der Hintergrund rollte nicht.  Die Löschung wurde durch die Tatsache verursacht, dass das Spiel die Namenstabelle schrittweise aktualisierte, sodass sie die Grafiken des neuen Raums enthielt, das Scrollen jedoch nicht aktualisierte, um die Aktualisierungen außerhalb des Bildschirms zu halten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460383/">https://habr.com/ru/post/de460383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460367/index.html">Chaos Engineering: die Kunst der absichtlichen Zerstörung. Teil 1</a></li>
<li><a href="../de460373/index.html">Unter der Haube Turbo-Seiten: Architektur der Webseite Fast Download-Technologie</a></li>
<li><a href="../de460375/index.html">Buch "Maschinelles Lernen für Wirtschaft und Marketing"</a></li>
<li><a href="../de460377/index.html">Verwenden von Liquibase zum Verwalten der Datenbankstruktur in einer Spring Boot-Anwendung. Teil 1</a></li>
<li><a href="../de460381/index.html">Was ist Durchsetzungsvermögen und warum wird es benötigt?</a></li>
<li><a href="../de460387/index.html">SELinux Anfängerleitfaden</a></li>
<li><a href="../de460393/index.html">Hintergrund: Was erwartet Sie von Fedora Silverblue?</a></li>
<li><a href="../de460395/index.html">Analytics als Feature: Der Prozess der Arbeit mit Daten in Plesk</a></li>
<li><a href="../de460397/index.html">Schnellstart mit WebComponents</a></li>
<li><a href="../de460399/index.html">SVG-Ladeanzeige auf Vue.js.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>