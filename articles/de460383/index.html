<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüîß üçÖ ‚è±Ô∏è Bildschirm√ºberg√§nge in Legend of Zelda verwenden die undokumentierten Funktionen von NES üë©‚Äç‚ù§Ô∏è‚Äçüë® üåå üÜí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="F√ºr den Effekt des vertikalen Bildlaufs im ersten Teil von ‚ÄûThe Legend of Zelda‚Äú werden NES-Grafik- ‚ÄûHardware‚Äú -Manipulationen verwendet, die von den ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bildschirm√ºberg√§nge in Legend of Zelda verwenden die undokumentierten Funktionen von NES</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460383/">  F√ºr den Effekt des vertikalen Bildlaufs im ersten Teil von ‚ÄûThe Legend of Zelda‚Äú werden NES-Grafik- ‚ÄûHardware‚Äú -Manipulationen verwendet, die von den Konsolenentwicklern h√∂chstwahrscheinlich nicht bereitgestellt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/466/3d0/6314663d04d4e3ed0d86c7e6d9b8611a.png" width="512"></div><br>  Ich habe keinen Zugriff auf die offizielle Dokumentation der Picture Processing Unit (PPU - Grafikchip) der NES-Konsole, daher sind meine Aussagen zu "undefiniertem Verhalten" eher Vermutungen.  Ich habe die Spezifikation der Grafikhardware aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NesDev-Wiki √ºbernommen</a> .  Die PPU wird durch Schreiben in Register mit Speicherzuordnung gesteuert.  Wenn Sie diese Register so verwenden, wie es (wie es scheint) von den Designern konzipiert wurde, ist es unm√∂glich, diesen Effekt zu erzielen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/b0e/51c/8a5b0e51c195fb1e9ba9ca282f54e61a.gif" width="512"></div><br>  Wenn Sie den Bildschirm vertikal scrollen, sollte der gesamte Bildschirm auf einmal scrollen.  Das vorherige GIF zeigt ein Beispiel f√ºr teilweises vertikales Scrollen.  Ein Teil des Bildschirms bleibt station√§r (Schnittstellenelemente) und der andere Teil (Spielbereich) rollt vertikal.  Ein teilweises vertikales Scrollen ist mit der "Standard" -Arbeit mit PPU nicht m√∂glich. <br><br>  Im Gegensatz dazu ist ein teilweises <em>horizontales</em> Scrollen vollst√§ndig definiert und m√∂glich. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae7/c29/539/ae7c295393f6706e17e788e0a1cc39e7.gif" width="512"></div><br>  Das Schreiben in ein separates PPU-Register zum Zeitpunkt des Zeichnens des Frames kann zu grafischen Artefakten f√ºhren.  Die Legende von Zelda verursacht absichtlich ein Artefakt, das sich als partielles vertikales Scrollen manifestiert.  In diesem Beitrag werde ich ein wenig √ºber NES-Grafikhardware sprechen und erkl√§ren, wie der Trick des vertikalen Bildlaufs funktioniert. <br><a name="habracut"></a><br><h2>  Arten von Grafiken </h2><br>  Die NES-Konsole verf√ºgt √ºber zwei Arten von Grafiken: <br><br><ul><li>  Sprites sind Kacheln, die an beliebigen Stellen auf dem Bildschirm platziert und unabh√§ngig voneinander verschoben werden k√∂nnen. </li><li>  Hintergrund - Ein Kachelraster, das problemlos als einzelnes Bild gescrollt werden kann. </li></ul><br>  Um den Unterschied zwischen den beiden zu demonstrieren, werde ich eine Szene zeigen, die aus Sprites und Hintergrund besteht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f75/f9b/138/f75f9b138db2e818cbdb9b2fb1e7b27b.gif" width="512"></div><br>  Und hier ist dieselbe Szene, in der nur Sprites sichtbar sind: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e8/26d/817/5e826d817b637fc450046aee1473abaf.gif" width="512"></div><br>  Und hier ist eine Szene, in der nur der Hintergrund sichtbar ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d81/b9c/bd7/d81b9cbd7bb5101f663d4decc5ebaef7.gif" width="512"></div><br><h2>  Scrollen </h2><br>  Der Bildprozessor (NES Picture Processor) unterst√ºtzt das Scrollen von Hintergrundbildern.  Im Grafikspeicher wird das Hintergrunddiagramm als zweidimensionales Kachelraster gespeichert, das einen Bereich abdeckt, der doppelt so breit und hoch wie der Bildschirm ist. <br><br>  In diesem Raster wird auf dem Bildschirm ein ‚ÄûFenster‚Äú in der Gr√∂√üe eines Bildschirms angezeigt, und die Position dieses Fensters kann pr√§zise gesteuert werden.  Durch schrittweises Verschieben des sichtbaren Fensters entlang des Rasters wird ein sanfter Bildlaufeffekt erzeugt. <br><br>  Das ausgegebene NES-Videosignal hat eine Gr√∂√üe von 256 x 240 Pixel.  Das Kachelraster im Speicher wird als 512 x 480 Pixel gro√üe Fl√§che dargestellt und in vier bildschirmgro√üe Rechtecke unterteilt, die als "Namenstabellen" bezeichnet werden.  Spiele k√∂nnen die Picture Processing Unit (PPU) konfigurieren, indem sie die Position des sichtbaren Fensters durch Auswahl der Pixelkoordinate im Raster der Namenstabellen angeben. <br><br>  Wenn Sie die Koordinate (0, 0) ausw√§hlen, wird die gesamte obere linke Namenstabelle auf dem Bildschirm angezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d3/b5d/47f/5d3b5d47f8efdfcac271a2a7e0222e57.png"></div><br>  Wenn wir zu (125, 181) √ºbergehen, sehen wir aus jeder Namenstabelle ein wenig: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/78f/189/91278f1891416d9f15a69238e64d1422.png"></div><br>  Das sichtbare Fenster wird auf die R√ºckseite des Kachelrasters im Speicher minimiert.  Wenn wir zu (342, 290) √ºbergehen, platzieren wir die obere linke Ecke des sichtbaren Bildschirms in der unteren rechten Namenstabelle. Dank der Faltung sind Teile jeder Namenstabelle sichtbar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e6/394/c93/6e6394c9325985807a97765ebe015bcf.png"></div><br><h3>  Nicht genug Speicher! </h3><br>  Jede Namenstabelle hat eine Gr√∂√üe von 1 KB, aber NES weist diesen Tabellen nur 2 KB seines Videospeichers zu, sodass jeweils nur zwei Namenstabellen in den Speicher passen. <br><br>  Wie kann es vier Namenstabellen haben? <br><br><h4>  Spiegeln von Namenstabellen </h4><br>  Der Videospeicher ist so mit der PPU verbunden, dass, wenn die PPU eine Kachel einer der vier scheinbaren Namenstabellen rendert, tats√§chlich eine der beiden realen Tabellen ausgew√§hlt wird und das Lesen von dort kommt.  Im Wesentlichen bedeutet dies, dass die vier sichtbaren Namenstabellen tats√§chlich aus zwei identischen Tabellenpaaren bestehen. <br><br>  Dieses Bild zeigt eine Momentaufnahme des Inhalts aller vier Tabellen.  Oben links und oben rechts sind die gleichen wie in den beiden unteren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/5b8/9b2/0515b89b2afcf122ce8df6e97e97a0a8.png" width="1024"></div><br>  Warum dann nicht einfach zwei Namenstabellen f√ºhren? <br><br>  Gl√ºcklicherweise kann die genaue Bindung zwischen der scheinbaren und der realen Tabelle zur Laufzeit konfiguriert werden.  Wenn das Spiel horizontales Scrollen ausf√ºhren m√∂chte, wird die Grafikausr√ºstung so angepasst, dass die Tabellen oben links und oben rechts unterschiedlich sind und ohne merkliche Duplizierung gescrollt werden k√∂nnen.  In dieser Konfiguration beziehen sich die Tabellen oben links und unten links auf dieselbe Tabelle mit echten Namen.  √§hnlich f√ºr die beiden rechten Tabellen.  Diese Konfiguration wird als vertikale Spiegelung bezeichnet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/d85/49d/1e3d8549d5427f7f7271595dc5c6f49b.png"></div><br>  Es gibt auch eine andere m√∂gliche Konfiguration - "Horizontale Spiegelung", die Spiele f√ºr vertikales Scrollen verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/650/6a2/528/6506a2528cba5d758301f72c80f48e8b.png"></div><br>  In der Regel scrollen Spiele nicht diagonal, da durch die Spiegelung der Namenstabellen Artefakte an den Bildschirmr√§ndern entstehen. <br><br><h3>  Patronen </h3><br>  Die Kassette jedes Spiels verf√ºgt √ºber Hardware, mit der Sie die Tabellenspiegelung konfigurieren k√∂nnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a44/8ed/3dc/a448ed3dc3849ac558d39ba0bfc5309d.jpg" width="50%"></div><br>  Einige Spiele m√ºssen die Spiegelung √ºberhaupt nicht wechseln, daher ist die horizontale oder vertikale Spiegelung in ihren Kassetten fest codiert.  Andere Spiele wechseln dynamisch zwischen diesen beiden Modi, sodass die Spiegelung in ihren Kassetten programmgesteuert konfiguriert wird.  Die Legende von Zelda geh√∂rt zur zweiten Kategorie.  Schlie√ülich verf√ºgen die Kassetten einiger wirklich komplexer Spiele √ºber zus√§tzlichen Videospeicher, dh sie m√ºssen √ºberhaupt nicht gespiegelt werden: Sie k√∂nnen gleichzeitig vertikal und horizontal ohne sichtbare Duplizierungsartefakte scrollen. <br><br><h3>  Echtes Beispiel </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/d58/80e/d0ad5880e16ce58d53ee2eb922c4da04.gif" width="512"></div><br>  <i>Ein Beispiel f√ºr vertikales Scrollen, das auf dem Bildschirm angezeigt wird.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/ff0/b01/7bbff0b019dadb96e423ebc744aeb12c.gif" width="1024"></div><br>  <i>Dies zeigt eine Aufzeichnung von Namenstabellen mit horizontaler Spiegelung.</i>  <i>Das aktuell sichtbare Fenster wird hervorgehoben.</i> <br><br>  Denken Sie daran, dass das vertikalste Scrollen nicht ungew√∂hnlich ist - das ungew√∂hnliche ist das vertikale Scrollen mit <em>geteiltem Bildschirm</em> . <br><br><h2>  Geteilter Bildschirm </h2><br>  Jeder Frame des von NES erzeugten Videosignals wird von oben nach unten gerendert, jeweils eine Pixelreihe.  In jeder Zeile werden die Pixel einzeln von links nach rechts gezeichnet.  Auf halbem Weg beim Rendern des Frames kann das Spiel die PPU neu konfigurieren, was sich auf die Anzeige von Pixeln auswirkt, die noch nicht gerendert wurden.  Eine der h√§ufigsten √Ñnderungen in der Mitte des Rahmens ist das Aktualisieren der horizontalen Bildlaufposition. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/873/536/98f/87353698fa1a10a55f37d5f56ebfaefd.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/502/8e9/c645028e950b7e202815d7c4ad560fac.gif" width="1024"></div><br>  Wenn Sie horizontal zwischen R√§umen scrollen, beginnt The Legend of Zelda immer an der Bildlaufposition (0, 0) und rendert die Oberfl√§chenelemente am oberen Bildschirmrand.  Nach dem Zeichnen der letzten Zeile der Schnittstellenpixel auf dem Bildschirm √§ndert sich das horizontale Scrollen um einen Wert, der mit jedem Bild zunimmt, sodass sich die Kamera reibungslos bewegt. <br><br>  Die Animation der Anzeige der Namenstabellen zeigt, wie das Spiel vor dem Scrollen von der horizontalen zur vertikalen Spiegelung und nach Abschluss des √úbergangs wieder zur horizontalen Spiegelung wechselt.  W√§hrend das Scrollen fortgesetzt wird, werden au√üerdem die Namenstabellen oben links (und unten links) aktualisiert und eine Kopie des Raums, den der Spieler betritt, wird darin aufgezeichnet.  Nachdem der Bildlauf abgeschlossen ist, teilt das Spiel den Bildschirm nicht mehr und wird wieder vollst√§ndig aus der oberen linken Tabelle gerendert. <br><br><h3>  Rendering-Messung </h3><br>  Um den Bildschirm in die gew√ºnschte Position zu teilen, muss das Spiel irgendwie herausfinden, welcher Teil des aktuellen Rahmens gezeichnet wurde.  Pixelstrings werden mit einer bekannten Frequenz gerendert, sodass die Anzahl der gerenderten Pixelstrings durch Z√§hlen der Anzahl der Prozessorzyklen bestimmt werden kann, die seit Beginn des Frames vergangen sind. <br><br>  Es gibt eine andere, genauere Technik namens Sprite Zero Hit. <br><br>  NES kann bis zu 64 Sprites gleichzeitig rendern.  Das erste Sprite im Videospeicher hei√üt Sprite Zero (Zero Sprite).  In jedem Frame tritt das Sprite Zero Hit-Ereignis auf, sobald ein undurchsichtiges Pixel eines Null-Sprites einem undurchsichtigen Hintergrundpixel √ºberlagert wird.  Es setzt ein Bit in eines der PPU-Register mit Speicherzuordnung, das vom Prozessor √ºberpr√ºft werden kann. <br><br>  Um Sprite Zero Hit zum Teilen des Bildschirms zu verwenden, platzieren Spiele das Zero Sprite an einer vertikalen Position nahe dem geteilten Rand und √ºberpr√ºfen w√§hrend des Renderns st√§ndig, ob das Sprite Zero Hit-Ereignis aufgetreten ist.  In diesem Fall wechselt das Spiel vom horizontalen Scrollen, um die Trennung zu implementieren. <br><br>  Der horizontale √úbergang zwischen R√§umen mit und ohne Hintergrund ist unten dargestellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71b/27a/076/71b27a0768844603020981c26b3f5124.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c4/4c1/95d/2c44c195dfac0b6c2d6b10aaf11674aa.gif" width="512"></div><br><br>  Der braune Kreis, der am Anfang des √úbergangs erscheint und am Ende verschwindet, ist ein Null-Sprite.  Wir werden uns die Benutzeroberfl√§che mit und ohne Hintergrund genauer ansehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/373/83d/39b37383d425937e8e5cdb598656bac5.png" width="322"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7d/6f9/ebe/c7d6f9ebeb7c7e066e6d349eb8c57914.png" width="322"></div><br>  Ein Zero-Sprite ist ein gebleichtes Bomben-Sprite, das perfekt zum regul√§ren Bomben-Sprite √ºber die Spieloberfl√§che passt.  Das Null-Sprite ist so konfiguriert, dass es unter dem Hintergrund angezeigt wird. Da jedoch die schwarzen Pixel der Schnittstelle als transparent betrachtet werden, w√§re die Null-Sprite-Bombe sichtbar, wenn sie nicht strategisch hinter der Bombe vor der Schnittstelle verborgen worden w√§re. <br><br>  Beachten Sie, dass Sprite Zero Hit einige Pixelzeilen vor der unteren Zeile der Benutzeroberfl√§che auftritt.  Es tritt am oberen Pixel der Bombensicherung auf, die 16 Pixel vom unteren Rand der Schnittstelle entfernt ist.  Wenn Sprite Zero Hit auftritt, beginnt das Spiel mit dem Z√§hlen der Prozessorzyklen und nach Abschluss der erforderlichen Anzahl von Zyklen wird das horizontale Scrollen eingestellt. <br><br><h2>  Strahlausblendung </h2><br>  Meistens zeichnet die Konsolen-PPU Pixel auf den Bildschirm.  Es gibt eine kurze Ausfallzeit zwischen Frames, w√§hrend der das Rendern nicht durchgef√ºhrt wird.  Dieses Ph√§nomen wird als Austastung (Vertical Blank oder vblank) bezeichnet.  Einige Arten von √Ñnderungen an der PPU-Konfiguration k√∂nnen nur w√§hrend vblank vorgenommen werden. <br><br><h2>  Bildlaufregister </h2><br>  Spiele √§ndern die <code>PPUSCROLL</code> , indem sie in das PPU-Register <code>PPUSCROLL</code> , das der Speicheradresse <code>0x2005</code> .  Die erste Schreiboperation in <code>PPUSCROLL</code> definiert die X-Komponente der <code>PPUSCROLL</code> , und die zweite Operation setzt die Y-Komponente. In √§hnlicher Weise wird eine alternative Aufzeichnung weiter durchgef√ºhrt. <br><br>  Das Folgende zeigt alle Nicht-Null-Schreibvorg√§nge in <code>PPUSCROLL</code> w√§hrend dieser Wiedergabe (in Zeitlupe) 16 Bilder des Bildschirms mit der Handlung des Spiels.  Die Bildlaufpositionskomponente Y wird alle zwei Frames erh√∂ht.  Alle Schreibvorg√§nge in <code>PPUSCROLL</code> in diesem Beispiel werden w√§hrend vblank ausgef√ºhrt, wodurch der gesamte Hintergrund mitgescrollt wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cad/0d1/003/cad0d1003d55488a17d988e6607739f2.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bc/ffb/c09/1bcffbc09db9bfe792ba85981acbe4b3.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/rz/fi/kgrzfigaydwrvo3qqth5bcmkecq.png"></div><br><h3>  Scrolling Screen Split </h3><br>  Schreibvorg√§nge in <code>PPUSCROLL</code> w√§hrend vblank werden am Anfang des unmittelbar nach vblank gezeichneten Frames wirksam.  Wenn sich die Bildlaufposition w√§hrend des Renderns des Rahmens √§ndert (d. H. Nicht w√§hrend vblank), wird diese √Ñnderung wirksam, wenn die Zeichnung die n√§chste Pixelreihe erreicht.  Teilweises horizontales Scrollen wird durch Schreiben in <code>PPUSCROLL</code> implementiert, w√§hrend das PPU-Ger√§t vor dem Scrollen die letzte <code>PPUSCROLL</code> zeichnet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddf/e12/b49/ddfe12b49ce180cb921243f32e77351a.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/38c/0bb/4be38c0bb335a414ce99a2c8d2145009.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cu/uu/1t/cuuu1twsw4wbeynzisaewszsqo8.png"></div><br>  Beim Aktualisieren der Bildlaufposition in der Bildmitte wird nur die X-Position der Bildlaufposition angewendet.  Das hei√üt, die Bildlaufpositionskomponente Y wird verworfen.  Wenn das Spiel den Bildschirm teilen und die Position des Bildlaufteils des Rahmens √§ndern m√∂chte, kann es nur horizontal scrollen. <br><br>  Und trotzdem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/93e/4b7/1a093e4b76c8382f08d33b4202391094.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/184/2b0/7601842b02f37dc10abd97b93e0a9ec2.gif" width="1024"></div><br>  <code>PPUSCROLL</code> Sie es glauben oder nicht, der Wert des <code>PPUSCROLL</code> Registers <code>PPUSCROLL</code> sich w√§hrend dieses √úbergangs nicht ge√§ndert. <br><br>  Sie k√∂nnen ein ein Pixel hohes grafisches Artefakt unter der Benutzeroberfl√§che sehen.  Dies ist ein Fehler meines Emulators, der durch die fehlende Synchronisation der Prozessortaktzyklen mit der pixelweisen Wiedergabe verursacht wird. <br><br><h3>  Eingriffe in andere Register </h3><br>  Das zweite Register mit der Bezeichnung <code>PPUADDR</code> , das der Speicheradresse <code>0x2006</code> ist, wird zum Einstellen der aktuellen Videospeicheradresse verwendet.  Wenn ein Spiel beispielsweise eine der Kacheln in der Namenstabelle √§ndern m√∂chte, schreibt es zuerst die Videospeicheradresse der <code>PPUADDR</code> in <code>PPUADDR</code> und dann den neuen Wert der <code>PPUDATA</code> in <code>PPUDATA</code> - dies ist das dritte Register, das der Adresse <code>0x2007</code> . <br><br>  Das Schreiben in <code>PPUADDR</code> nicht w√§hrend vblank (d. H. Beim Rendern eines Frames) kann grafische Artefakte verursachen.  Dies liegt daran, dass die PPU-Kette, die vom Schreiben in <code>PPUADDR</code> betroffen ist, auch direkt vom PPU-Ger√§t gesteuert wird, <code>PPUADDR</code> Kacheln aus dem Videospeicher zum Zeichnen <code>PPUADDR</code> .  Da das Rendern auf dem Bildschirm von oben nach unten und von links nach rechts innerhalb der Linie ausgef√ºhrt wird, weist die PPU <code>PPUADDR</code> Wesentlichen <code>PPUADDR</code> Wert der Adresse der aktuell gezeichneten <code>PPUADDR</code> .  Wenn das Rendern von einer Kachel zur n√§chsten <code>PPUADDR</code> wird, wird <code>PPUADDR</code> um den aktuellen Wert erh√∂ht. <br><br>  Somit kann das Schreiben in <code>PPUADDR</code> in der Mitte des Rahmens die von der PPU aus dem Speicher empfangenen Kacheln f√ºr die Dauer des aktuellen Rahmens √§ndern. <br><br>  Lassen Sie <code>PPUADDR</code> Schreiboperationen w√§hrend des vertikalen Sprungs zu <code>PPUADDR</code> .  Da die Namenstabelle auch w√§hrend des √úbergangs aktualisiert wird, ist die Ausgabe <em>aller</em> Schreibvorg√§nge in <code>PPUADDR</code> zu umfangreich.  Bei einem horizontalen √úbergang wird das Scrollen w√§hrend des Renderns einer <code>PPUADDR</code> 63 eingestellt. Daher werden Schreibvorg√§nge in <code>PPUADDR</code> nur w√§hrend dieser Zeile in <code>PPUADDR</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/93e/4b7/1a093e4b76c8382f08d33b4202391094.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/184/2b0/7601842b02f37dc10abd97b93e0a9ec2.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3b/w0/iw/3bw0iwoau9zl8frbuh-mgh78-ia.png"></div><br>  Das Muster ist deutlich sichtbar.  Alle zwei Frames wird die in der Pixelzeile 63 aufgezeichnete Adresse um 32 (0x20) reduziert.  Aber wie f√ºhrt dies zu einer Aktualisierung der tats√§chlichen Bildlaufposition? <br><br><h3>  <i>Echtes</i> Bildlaufregister </h3><br>  Innerhalb der PPU befindet sich ein 15-Bit-Register, das nicht der CPU zugeordnet ist.  Es wird sowohl als aktuelle Adresse f√ºr den Zugriff auf den Videospeicher als auch als Hintergrund-Scrolling-Konfiguration verwendet. <br><br>  Wenn Sie mit diesem Wert als Adresse arbeiten, wird Bit 14 ignoriert und die Bits 0-13 werden als Adresse im Videospeicher behandelt. <br><br>  Wenn Sie mit diesem Wert als Bildlaufkonfiguration arbeiten, haben die verschiedenen Teile unterschiedliche Bedeutungen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/ot/-q/raot-qzjvlglrxraw3kyrpskouk.png"></div><br>  <strong>Die Auswahl einer Namenstabelle</strong> ist ein Wert zwischen 0 und 3, der die aktuelle Namenstabelle bestimmt, aus der die Zeichnung erstellt wird. <br><br>  <strong>Grobes Scrollen in X</strong> und <strong>Grobes Scrollen in Y</strong> bestimmen die Koordinate der Kachel in der ausgew√§hlten Namenstabelle.  Dies ist die aktuell zu zeichnende Kachel. <br><br>  <strong>Das genaue Scrollen entlang Y</strong> enth√§lt einen Wert von 0 bis 7, der den aktuellen vertikalen Versatz der Pixelzeile innerhalb der aktuellen Kachel bestimmt.  Kacheln sind Quadrate mit einer Seite von 8 Pixeln. <br><br>  In diesem Register fehlt ein <strong>genaues Scrollen auf X.</strong>  Es gibt ein separates Register, das nur den horizontalen Versatz des aktuellen Pixels enth√§lt. Es ist jedoch nicht wichtig zu erkl√§ren, wie das vertikale Scrollen in The Legend of Zelda ausgef√ºhrt wird. <br><br>  Was passiert mit diesem Register, wenn ein Spiel in <code>PPUADDR</code> schreibt?  Hier sind die ersten drei Schreibvorg√§nge aus der oben gezeigten Demo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nm/km/2b/nmkm2bpk5osxvd1ohc4kmne7ck4.png"></div><br>  Indem Sie die Eintr√§ge an der Adresse in Bildlaufkomponenten aufteilen, k√∂nnen Sie klar verstehen, was hier passiert.  Alle zwei Frames nimmt der Wert des <strong>groben Bildlaufs in Y</strong> ab, was zu einem vertikalen Bildlauf um eine Kachel oder 8 Pixel f√ºhrt. <br><br>  W√§hrend jedes Rahmens betr√§gt der anf√§ngliche Bildlaufversatz 0,0, wonach die Aufzeichnung auf der Pixelzeile 63 an der Adresse durchgef√ºhrt wird.  Dies bedeutet, dass die ersten 63 Pixelzeilen vom oberen Rand der ausgew√§hlten Namenstabelle mit dem Hintergrund der Benutzeroberfl√§che gezeichnet werden.  Die 64. Pixelreihe wird jedoch weiter gerendert, wobei von dieser Adresse aus vertikales Scrollen angewendet wird.  Da das vertikale Scrollen alle zwei Frames abnimmt, entsteht das Gef√ºhl des vertikalen Scrollens eines Teils des Bildschirms. <br><br><h3>  Scrollen Sie nach unten, um nach oben zu scrollen </h3><br>  Die Legende von Zelda kann diesen Trick nicht vollst√§ndig vor den Spielern verbergen.  Auf den vertikalen √úberg√§ngen des Bildschirms entsteht ein sichtbares Artefakt, das sich bei genauem Hinsehen bemerkbar macht.  Wenn Sie sich zwischen R√§umen bewegen, wird der erste Frame der Bildlaufanimation nach unten gescrollt.  Hier ist die Animation in sehr Zeitlupe. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/a8c/79d/af8a8c79d1b4c50280c31fbf1540852a.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a52/e37/9a6/a52e379a6e5d6dd444fe115d484bb846.gif" width="1024"></div><br>  In der Namenstabelle k√∂nnen Sie sehen, was wirklich passiert.  Obwohl es den Spielern so erscheint, als w√ºrde der sichtbare Bereich reibungslos nach oben scrollen, beginnt der Bildlauf√ºbergang damit, dass der sichtbare Bereich von der oberen linken Namenstabelle zur unteren linken Tabelle verschoben wird, die eine Kopie des Hintergrunds des Raums enth√§lt.  Dies ist erforderlich, da die Benutzeroberfl√§che am oberen Bildschirmrand ebenfalls Teil der Namenstabelle ist. Wenn der sichtbare Bereich von seiner urspr√ºnglichen Position nach oben gescrollt wird, wird die Benutzeroberfl√§che durchlaufen. <br><br>  Das vertikale Scrollen wird implementiert, indem in das <code>PPUADDR</code> Register in der Mitte des Rahmens geschrieben wird.  Der allererste zu schreibende Wert ist <code>0x2800</code> .  Zwei Bilder sp√§ter wird <code>0x23A0</code> aufgezeichnet, und dann beginnt der Wert mit jedem zweiten Bild um 32 abzunehmen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/la/gh/pklagh4idqhd3jg_mfkojhfv0lq.png"></div><br>  Durch Schreiben des Werts <code>0x2800</code> in das <code>0x2800</code> Register wird <code>PPUADDR</code> auf 2 gesetzt, was zum Rendern der unteren linken Namenstabelle f√ºhrt.  Da beide Bildlaufwerte 0 sind, beginnt sie in der oberen linken Kachel dieser Namenstabelle.  Das <strong>genaue Scrollen in Y</strong> ist jedoch 2, sodass ein vertikaler Versatz von zwei Pixeln vom oberen Rand der unteren linken Namenstabelle vorhanden ist.  Aus diesem Grund sehen wir im ersten Frame des √úbergangs einen 2 Balken hohen schwarzen Balken am unteren Bildschirmrand.  Der anf√§ngliche Bildlaufwert f√ºr die √úbergangsanimation wird um 2 Pixel nach unten verschoben, um den √úbergang nahtlos zu gestalten. <br><br>  Zwei Frames sp√§ter wird der <code>PPUADDR</code> in <code>0x23A0</code> .  Dies bringt uns zur√ºck zur oberen linken Namenstabelle und wir rendern aus der 29. Kachelreihe, dh der unteren.  <strong>Das genaue Scrollen in Y</strong> enth√§lt noch 2. <br><br>  Warum muss <strong>Exact Scrolling in Y</strong> auf 2 gesetzt werden?  Warum schreibt das Spiel nicht einfach <code>0x0800</code> und <code>0x03A0</code> , um nicht unter einem Zwei-Pixel-Offset zu leiden? <br><br>  Vier Namenstabellen belegen den 4-KB-Bereich im PPU-Adressraum von <code>0x2000</code> bis <code>0x2FFF</code> .  Jede Kachel in der Tabelle belegt ein Byte Videospeicher (tats√§chlich sind sie nur Indizes in einer anderen Tabelle), und die Reihenfolge der Kacheln und Namenstabellen im Videospeicher ist so, dass die <strong>Auswahl einer Tabelle mit Namen</strong> , das <strong>grobe Scrollen nach Y</strong> und das <strong>grobe Scrollen nach X</strong> den Versatz der Kachel im Inneren ausmachen Speicherbereiche mit Namenstabellen.  <code>0x2000</code> Sie also die unteren 12 Bits des internen PPU-Registers nehmen und zu <code>0x2000</code> , finden Sie die <code>0x2000</code> im Videospeicher.  Und das ist kein Zufall!  Genau so sollte das Register behandelt werden: sowohl als Adressregister als auch als Bildlaufregister. <br><br>  Aber es gibt einen Fehler. <br><br>  Bei der Verarbeitung als Adressregister werden die Bits 12 und 13 als Teil der Adresse betrachtet.  W√§hrend des Renderns √ºberschreibt die PPU das Register st√§ndig mit der Adresse der aktuell gerenderten Kachel.  Da sich die Kacheln in den Namenstabellen und die Tabellen im Speicherbereich von <code>0x2000</code> bis <code>0x2FFF</code> , weist die PPU dem Register Werte aus diesem Intervall zu. <br><br>  Wenn das Spiel in der Mitte des Frames in <code>PPUADDR</code> schreibt und die <code>PPUADDR</code> in der <code>PPUADDR</code> notiert, <code>PPUADDR</code> die PPU, <em>von einer anderen Stelle</em> im Videospeicher zu lesen.  Alle Bytes, die er zuf√§llig z√§hlt, werden als Kacheln wahrgenommen, was wahrscheinlich zu unerw√ºnschten Ergebnissen f√ºhrt.  Daher m√ºssen alle in der Mitte des Frames in <code>PPUADDR</code> aufgezeichneten Werte im Bereich von <code>0x2000</code> bis <code>0x2FFF</code> .  Unter Ber√ºcksichtigung jeder Zahl in diesem Intervall und unter Ber√ºcksichtigung ihrer Bildlaufkomponenten sollte der <strong>exakte Bildlaufwert in Y</strong> immer gleich 2 sein. <br><br>  Diese Einschr√§nkung bedeutet, dass wir das <strong>exakte Scrollen in Y-</strong> Richtung in der Mitte des Rahmens nicht √§ndern k√∂nnen. Wenn Sie also diesen Trick verwenden, um das vertikale Scrollen der Bildschirmtrennung zu implementieren, k√∂nnen Sie nur 8 Pixel gleichzeitig scrollen und haben immer einen vertikalen Versatz von zwei Pixeln vom Kachelrand.  Die Legende von Zelda verschiebt beim horizontalen Scrollen 4 Pixel pro Frame, beim vertikalen Scrollen jedoch 8 Pixel pro Frame, und jetzt wissen wir warum. <br><br>  Das Artefakt macht sich auch beim Scrollen zwischen den R√§umen bemerkbar. In diesem Fall tritt es jedoch am Ende der Animation auf. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/13b/89a/77d13b89abce5200d348de0379f409e5.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/468/eb2/9c2/468eb29c2eb3a97d7e4dd2a62682f1b9.gif" width="1024"></div><br><h2>  Zus√§tzliche Lekt√ºre </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das NesDev-Wiki</a> ist eine unsch√§tzbare Ressource, um mehr √ºber die NES-Hardware zu erfahren.  Das Thema dieses Beitrags sind insbesondere Seiten zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scrollen der PPU</a> <br>  und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PPU-Register</a> . </li><li>  Mein noch sehr unfertiger NES-Emulator ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> verf√ºgbar. </li></ul><br><h2>  Anmerkungen </h2><br>  Bis ich etwas √ºber das interne Register der PPU erfuhr, zeigte mein Emulator den Effekt des L√∂schens w√§hrend vertikaler √úberg√§nge des Bildschirms The Legend of Zelda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/932/2a0/a5a/9322a0a5a1522a0ae0f6fbd21080286e.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1a/078/755/d1a0787558999dd61ec2ba9dc9ba9026.gif" width="1024"></div><br>  Das Sprite von Link bewegte sich wie gew√ºnscht √ºber den Bildschirm, aber der Hintergrund rollte nicht.  Die L√∂schung wurde durch die Tatsache verursacht, dass das Spiel die Namenstabelle schrittweise aktualisierte, sodass sie die Grafiken des neuen Raums enthielt, das Scrollen jedoch nicht aktualisierte, um die Aktualisierungen au√üerhalb des Bildschirms zu halten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460383/">https://habr.com/ru/post/de460383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460367/index.html">Chaos Engineering: die Kunst der absichtlichen Zerst√∂rung. Teil 1</a></li>
<li><a href="../de460373/index.html">Unter der Haube Turbo-Seiten: Architektur der Webseite Fast Download-Technologie</a></li>
<li><a href="../de460375/index.html">Buch "Maschinelles Lernen f√ºr Wirtschaft und Marketing"</a></li>
<li><a href="../de460377/index.html">Verwenden von Liquibase zum Verwalten der Datenbankstruktur in einer Spring Boot-Anwendung. Teil 1</a></li>
<li><a href="../de460381/index.html">Was ist Durchsetzungsverm√∂gen und warum wird es ben√∂tigt?</a></li>
<li><a href="../de460387/index.html">SELinux Anf√§ngerleitfaden</a></li>
<li><a href="../de460393/index.html">Hintergrund: Was erwartet Sie von Fedora Silverblue?</a></li>
<li><a href="../de460395/index.html">Analytics als Feature: Der Prozess der Arbeit mit Daten in Plesk</a></li>
<li><a href="../de460397/index.html">Schnellstart mit WebComponents</a></li>
<li><a href="../de460399/index.html">SVG-Ladeanzeige auf Vue.js.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>