<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏿 🙃 🎬 Versión PVS-Studio 6.26 🐌 👿 🏂🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Por lo general, no escribimos notas sobre el lanzamiento de la nueva versión del analizador PVS-Studio. Sin embargo, la nueva versión incluye muchos c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Versión PVS-Studio 6.26</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/426905/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2b/55b/397/c2b55b397a33727e8c77fef4f5911fae.png" alt="PVS-Studio 6.26"></div><br>  Por lo general, no escribimos notas sobre el lanzamiento de la nueva versión del analizador PVS-Studio.  Sin embargo, la nueva versión incluye muchos cambios interesantes con respecto al análisis del código C y C ++, que nos gustaría contarles a nuestros usuarios. <br><a name="habracut"></a><br><h2>  Java próximamente </h2><br>  Para ser sincero, las últimas y más interesantes innovaciones en PVS-Studio todavía están ocultas.  Me refiero a soporte en el analizador de lenguaje Java.  Todavía no existe una versión beta pública de PVS-Studio para Java, pero estará disponible muy pronto.  Si desea participar en sus pruebas, puede escribirnos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">soporte</a> (elija: Quiero un analizador para Java). <br><br><h2>  Nuevos diagnósticos para C y C ++ </h2><br>  En la nueva versión, nos dejamos llevar un poco e inmediatamente agregamos 15 diagnósticos de uso general para C y C ++ (V1021-V1035).  En una versión menor, tantos diagnósticos nunca se han agregado a la vez.  Se pueden encontrar más detalles sobre cada uno de los diagnósticos en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> .  En mi opinión, los más interesantes entre los nuevos diagnósticos son: <br><br><ul><li>  V1026.  La variable se incrementa en el bucle.  Se producirá un comportamiento indefinido en caso de desbordamiento de entero con signo. </li><li>  V1033.  La variable se declara como automática en C. Su tipo predeterminado es int. </li></ul><br>  Diagnóstico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V1026</a> creado en base a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">discusión</a> en el foro linux.org.ru.  El programador se quejó de una falla en el compilador GCC 8, pero, como resultó más tarde, la falla fue el código incorrecto, lo que condujo a un comportamiento indefinido.  Miremos este caso. <br><br>  <b>Nota</b>  En la discusión original, la variable <i>s</i> es de tipo <i>const char * s</i> .  Además, en la plataforma de destino, el tipo <i>char</i> no está firmado.  Por lo tanto, para mayor claridad, escribí inmediatamente en el ejemplo que el tipo del puntero es <i>constante unsigned char *</i> . <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*s) { r += ((r * <span class="hljs-number"><span class="hljs-number">20891</span></span> + *s *<span class="hljs-number"><span class="hljs-number">200</span></span>) | *s ^ <span class="hljs-number"><span class="hljs-number">4</span></span> | *s ^ <span class="hljs-number"><span class="hljs-number">3</span></span>) ^ (r &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); s++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>; }</code> </pre> <br>  El compilador no genera código para el operador AND a nivel de bit (&amp;).  Debido a esto, la función devuelve valores negativos, aunque esto no debería suceder con la intención del programador. <br><br>  El desarrollador cree que esto es una falla en el compilador.  Pero el programador que escribió dicho código está realmente equivocado.  La función no funciona correctamente debido al hecho de que se produce un comportamiento indefinido en ella. <br><br>  El compilador ve que se considera una cierta cantidad en la variable <i>r</i> .  El desbordamiento de la variable <i>r</i> no debería ocurrir.  De lo contrario, este es un comportamiento indefinido que el compilador no debe considerar y tener en cuenta.  Entonces, el compilador cree que dado que el valor en la variable <i>r</i> después del final del ciclo no puede ser negativo, la operación <i>r &amp; 0x7fffffff</i> para restablecer el bit de signo es superflua y el compilador simplemente devuelve el valor de la variable <i>r</i> de la función. <br><br>  Diagnostics V1026 está diseñado para detectar tales errores.  Para arreglar el código, es suficiente leer el hash usando una variable sin signo.  Versión corregida del código: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*s) { r += ((r * <span class="hljs-number"><span class="hljs-number">20891</span></span> + *s *<span class="hljs-number"><span class="hljs-number">200</span></span>) | *s ^ <span class="hljs-number"><span class="hljs-number">4</span></span> | *s ^ <span class="hljs-number"><span class="hljs-number">3</span></span>) ^ (r &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); s++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(r &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>); }</code> </pre> <br>  Ahora veamos otro diagnóstico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V1033</a> .  Es interesante porque la causa de posibles errores fue la nueva palabra clave <i>automática</i> , que apareció en C ++ 11.  Y no es la innovación del lenguaje C ++ 11 en sí mismo lo que es culpable, sino los matices del plan psicológico :).  Te lo explicaré ahora.  Echa un vistazo a este código: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = <span class="hljs-number"><span class="hljs-number">3.14f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sum = d + i;</code> </pre> <br>  ¿Lo ves como un error?  Piensa en eso.  Aquí hay una imagen para que no lea más el texto de inmediato. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/606/b62/4c1/606b624c14976dfe4c257829a44bd520.png" alt="Hora de pensar"></div><br>  ¿Adivina qué podría estar mal?  Si no, aquí hay información más interesante.  La variable <i>suma</i> será 4, no 4.14.  Por qué <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/162/4e2/f84/1624e2f84f05fb9c6d281e961fba88ca.png" alt="Xs"></div><br>  ¡Ahora el lector dirá que fue un enigma deshonesto!  Lo que pasa es que esto no es C ++, sino C. <br><br>  Sucede que un proyecto usa C ++ y el viejo C. El programador se acostumbra a usar <i>auto</i> en C ++ y accidentalmente puede usar esta palabra en C. Pero significa algo más allí: <br><br>  <b><i>auto</i></b> <br><br>  <i>Define una variable local como teniendo una vida local.</i>  <i>La palabra clave auto utiliza la siguiente sintaxis:</i> <br><br><pre> <code class="cpp hljs">[<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>] data-definition;</code> </pre> <br>  <i>Como el tiempo de vida local es el predeterminado para las variables locales, la palabra clave auto se usa extremadamente raramente.</i> <br><br>  Resulta que la <i>suma</i> variable es de tipo <i>int</i> , y es por eso que su valor será 4. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dbf/089/35b/dbf08935b7bc60388f7813d41f944ea8.png" alt="Unicornio se esta riendo"></div><br>  Aunque el error puede parecer exótico, de hecho, en un proyecto que usa una mezcla de archivos C y C ++, es muy fácil de hacer.  En consecuencia, al analizar archivos C, PVS-Studio advierte sobre tales construcciones sospechosas. <br><br><h2>  Otras innovaciones </h2><br>  Se agregó la capacidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de verificar proyectos</a> para el sistema de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compilación Waf</a> . <br><br>  Continuamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desarrollando el</a> analizador hacia sistemas embebidos.  Esta versión agrega soporte de verificación de proyectos para GNU Arm Embedded Toolchain, compilador Arm Embedded GCC. <br><br>  Al analizar proyectos para el compilador de Visual C ++ (cl.exe, proyectos vcxproj para Visual Studio / Standalone), el informe del analizador ahora almacena el registro en las rutas a los archivos verificados.  El refinamiento lateral parece más fácil de lo que realmente es.  Al preprocesar archivos, el compilador cl.exe estropea el caso en los nombres de archivo.  Y tiene que restaurarlos nuevamente al analizador. <br><br>  Se agregó la capacidad de usar archivos pvsconfig de CLMonitor / Standalone en Windows. <br><br>  Se ha agregado un modo de análisis incremental para el módulo pvs-studio-analzyer / CMake.  El módulo PVS-Studio CMake ahora se puede usar en Windows para proyectos que usan el compilador Visual C ++ (cl.exe). <br><br>  Se agregó soporte para análisis incremental para proyectos de .NET Core / .NET Standard Visual Studio. <br><br><h2>  Enlaces de sitio </h2><br><ol><li>  PVS-Studio.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Historial de versiones</a> </li><li>  Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El comportamiento indefinido está más cerca de lo que piensas</a> . </li><li>  Will Dietz, Peng Li, John Regehr y Vikram Adve.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comprender el desbordamiento de enteros en C / C ++</a> . </li><li>  Egor Bredikhin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desarrollo de un nuevo analizador estático: PVS-Studio Java</a> . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426905/">https://habr.com/ru/post/es426905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426891/index.html">SAP Process Mining o cómo entender sus procesos de negocio</a></li>
<li><a href="../es426893/index.html">Cómo iniciar una aplicación de iOS a través de React Native</a></li>
<li><a href="../es426899/index.html">Video Science Meetup Video</a></li>
<li><a href="../es426901/index.html">La cámara más rápida del mundo dispara 10 billones de fotogramas por segundo</a></li>
<li><a href="../es426903/index.html">La ciudad de Chengdu quiere poner en órbita un reflector de satélite para iluminar las calles con una mancha de luz solar de 10 a 80 km</a></li>
<li><a href="../es426907/index.html">Problemas comunes de seguridad de la red corporativa que se pueden detectar con Check Point Security CheckUP</a></li>
<li><a href="../es426911/index.html">GreyEnergy: el sucesor de BlackEnergy ataca a las empresas del sector energético</a></li>
<li><a href="../es426913/index.html">Cómo hacer entrevistas entre informes y un pequeño informe sobre DevOops</a></li>
<li><a href="../es426915/index.html">NASA Hackathon: desafío de aplicaciones espaciales</a></li>
<li><a href="../es426917/index.html">Plataforma inteligente y segura de Cisco para negocios en la era digital</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>