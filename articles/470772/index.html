<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé© üêç üë¥ TON: recomendaciones y mejores pr√°cticas üëºüèº üôãüèΩ üñï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo es una traducci√≥n de un documento publicado en la p√°gina TON blockchain: smc-Guidelines.txt . Quiz√°s esto ayude a alguien a dar un paso ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TON: recomendaciones y mejores pr√°cticas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470772/"><p>  Este art√≠culo es una traducci√≥n de un documento publicado en la p√°gina TON blockchain: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">smc-Guidelines.txt</a> .  Quiz√°s esto ayude a alguien a dar un paso hacia el desarrollo de esta cadena de bloques.  Adem√°s, al final hice un breve resumen. </p><a name="habracut"></a><br><h2 id="vnutrennie-soobscheniya">  Mensajes internos </h2><br><p>  Los contratos inteligentes interact√∫an entre s√≠ enviando los llamados mensajes internos.  Cuando el mensaje interno llega a su destino especificado, se crea una transacci√≥n regular a nombre de la cuenta de destino, y el mensaje interno se procesa de acuerdo con el c√≥digo especificado y los datos constantes de esta cuenta (contrato inteligente).  En particular, una transacci√≥n de procesamiento puede crear uno o m√°s mensajes internos, algunos de los cuales pueden dirigirse a la direcci√≥n de origen del mensaje interno que se est√° procesando.  Esto se puede usar para crear "aplicaciones cliente-servidor" simples cuando una solicitud se incrusta (encapsula) en un mensaje interno y se env√≠a a otro contrato inteligente que procesa la solicitud y devuelve la respuesta, nuevamente como un mensaje interno. </p><br><p> Este enfoque lleva a la necesidad de distinguir entre mensajes internos a la "solicitud" y la "respuesta" (como una "consulta" o como una "respuesta"), o que no requieren ning√∫n procesamiento adicional (como una simple transferencia de dinero).  Adem√°s, cuando llega una respuesta, debe haber una manera de entender a qu√© solicitud se refiere. </p><br><p>  Para lograr este objetivo, se recomienda utilizar la siguiente plantilla de mensaje interno (recuerde que la cadena de bloques TON no impone ninguna restricci√≥n en el cuerpo del mensaje, es decir, es solo una recomendaci√≥n): </p><br><p>  0) El cuerpo del mensaje puede incrustarse en el mensaje en s√≠, o puede almacenarse en una celda separada (celda *), a la que se hace referencia en el mensaje, como se indica en el fragmento TL-B del diagrama (en ingl√©s es m√°s f√°cil de entender: o se almacena en una celda separada celda a la que se hace referencia desde el mensaje, como lo indica el fragmento del esquema TL-B): </p><br><pre><code class="plaintext hljs">message$_ {X:Type} ... body:(Either X ^X) = Message X;</code> </pre> <br><p>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://core.telegram.org/mtproto</a> - aqu√≠ puedes leer sobre esquemas TL) </p><br><p>  El contrato inteligente receptor debe aceptar al menos mensajes internos con el cuerpo del mensaje incrustado (incluso si se colocan en la celda que contiene el mensaje, siempre que encajen en la celda que contiene el mensaje, no est√° muy claro qu√© significa esto, por lo tanto, adjunta el texto original).  Si el contrato acepta cuerpos de mensajes en celdas separadas (usando el constructor "correcto" <code>(Either X ^X)</code> ), el procesamiento del mensaje entrante no debe depender del m√©todo particular de incrustar el cuerpo del mensaje.  Por otro lado, es absolutamente legal no admitir el cuerpo del mensaje en una celda separada para simplificar las solicitudes y respuestas. </p><br><p>  1) El cuerpo del mensaje generalmente comienza con los siguientes campos: </p><br><ul><li>  <em>op</em> : entero sin signo de 32 bits (big-endian) que identifica la operaci√≥n a ejecutar o el m√©todo de contrato inteligente a llamar. </li><li>  <em>query_id</em> es un entero sin signo de 64 bits (big-endian) utilizado en todos los mensajes internos de preguntas y respuestas para identificar la relaci√≥n de la respuesta a la solicitud (el <em>query_id de la</em> respuesta debe ser igual al <em>query_id de la</em> solicitud correspondiente).  Si <em>op</em> no es un m√©todo de solicitud-respuesta (llama a un m√©todo del que no se espera respuesta), se puede omitir <em>query_id</em> . </li><li>  el resto del cuerpo del mensaje es espec√≠fico para cada valor admitido del par√°metro <em>op</em> </li></ul><br><p>  2) Si <em>op</em> es cero, entonces el mensaje es un simple mensaje de transferencia con un comentario.  El comentario est√° contenido en el resto del mensaje (sin <em>query_id</em> y as√≠ sucesivamente, es decir, a partir del quinto byte (explicaci√≥n: si <em>query_id</em> no lo <em>est√°</em> , entonces el campo <em>op</em> ocupa los primeros 4 bytes)).  Si no comienza con el byte 0xff, el comentario es de texto;);  se puede mostrar al usuario final de la billetera "tal cual" (despu√©s de filtrar caracteres no v√°lidos y de control y verificar que se trata de una cadena UTF-8 v√°lida).  Por ejemplo, los usuarios pueden especificar el prop√≥sito de una simple transferencia de su billetera a la billetera de otro usuario en este campo.  Por otro lado, si un comentario comienza con el byte 0xff, el resto del mensaje es un "comentario binario" que no debe mostrarse al usuario final como texto (solo si es necesario un volcado hexadecimal).  El uso propuesto de comentarios binarios, por ejemplo, es contener un identificador de pago para el pago en la tienda y ser generado y procesado autom√°ticamente por el software de la tienda. </p><br><p>  La mayor√≠a de los contratos inteligentes no tienen que realizar acciones no triviales o rechazar un mensaje entrante cuando reciben un "mensaje de transferencia simple".  Por lo tanto, cuando <em>op</em> resulta ser cero, la funci√≥n de contrato inteligente para procesar mensajes internos entrantes (generalmente llamada <code>recv_internal()</code> ) deber√≠a salir inmediatamente con el c√≥digo 0, lo que indica √©xito (por ejemplo, arrojando la excepci√≥n 0 si no se instala un controlador personalizado en el contrato inteligente excepciones).  Esto conducir√° al hecho de que la cantidad transferida por el mensaje se acreditar√° a la cuenta del destinatario sin ning√∫n otro efecto. </p><br><p>  3) "Una transferencia de mensaje simple sin comentarios" tiene un cuerpo vac√≠o (incluso sin el campo <em>op</em> ).  Las consideraciones anteriores se aplican a dichos mensajes.  Tenga en cuenta que dichos mensajes deben tener su propio cuerpo incrustado en la celda del mensaje. </p><br><p>  4) Esperamos que el campo <em>op</em> de los mensajes de solicitud tenga el primer bit ("bit de orden superior", traducido como el primero, esto puede ser incorrecto, pero como se explica m√°s adelante queda claro) est√° vac√≠o, es decir, el valor del campo debe estar en el rango <code>1 .. 2^31-1</code> , y para los mensajes de respuesta, el primer bit (de orden superior) debe ser igual a 1, es decir, el valor del campo en el rango <code>2^31 .. 2^32-1</code> .  Si el mensaje no es una solicitud ni una respuesta (el cuerpo no contiene el par√°metro <em>query_id</em> ), entonces debe contener el par√°metro <em>op</em> en el rango como en el mensaje de solicitud: <code>1 .. 2^31 - 1</code> . </p><br><p>  5) Hay varios mensajes de respuesta "est√°ndar" para los cuales <em>op</em> es 0xffffffff y 0xffffffffe.  En general, los valores <em>op</em> de 0xfffffff0 a 0xffffffff est√°n reservados para tales respuestas est√°ndar. </p><br><ul><li>  <em>op = 0xffffffff</em> significa "la operaci√≥n no es compatible".  Le sigue un <em>query_id de</em> 64 bits extra√≠do de la consulta original y una operaci√≥n de 32 bits <em>de la</em> consulta original.  Todos menos los contratos inteligentes m√°s simples deber√≠an devolver este error cuando reciben una solicitud con un <em>operador</em> desconocido en el rango 1 ... 2 ^ 31-1. </li><li>  <em>op = 0xfffffffe</em> significa "operaci√≥n no permitida".  Le sigue el <em>query_id de</em> 64 bits <em>de la</em> consulta original, y luego la operaci√≥n de 32 bits extra√≠da de la consulta original. </li></ul><br><p>  Tenga en cuenta que las "respuestas" desconocidas (con <em>op</em> en el rango 2 ^ 31 ... 2 ^ 32-1) deben ignorarse (en particular, no debe generar una respuesta con <em>op</em> igual a 0xffffffff), as√≠ como un retorno inesperado ( (rebotado) -mensajes (con el conjunto de banderas "rebotado"). </p><br><h2 id="oplata-za-obrabotku-zaprosov-i-otpravlenie-otvetov">  Pago por procesar solicitudes y enviar respuestas </h2><br><p>  En general, si un contrato inteligente desea enviar una solicitud a otro contrato inteligente, debe pagar por enviar un mensaje interno al contrato inteligente objetivo (tarifas de reenv√≠o de mensajes), para procesar este mensaje en el destino (tarifa de gas: tarifas de gas) y para enviar una respuesta si es necesario (tarifas de reenv√≠o de mensajes). </p><br><p>  En la mayor√≠a de los casos, el remitente adjuntar√° una peque√±a cantidad de gramo al mensaje interno (por ejemplo, 1 gramo) (suficiente para pagar el procesamiento de este mensaje) y establecer√° el indicador de "rebote" en √©l (es decir, enviar√° un mensaje interno rebotable);  el destinatario devolver√° la parte no utilizada del valor recibido con la respuesta (restando la tarifa por enviarle el mensaje).  Esto generalmente se logra llamando a SENDRAWMSG con mode = 64 (v√©ase el Ap√©ndice A de la documentaci√≥n de TON VM). </p><br><p>  Si el destinatario no puede procesar el mensaje recibido y la ejecuci√≥n finaliza con un c√≥digo de salida distinto de cero (por ejemplo, debido a una excepci√≥n de deserializaci√≥n de celda no controlada), el mensaje ser√° "devuelto" autom√°ticamente al remitente, y la bandera de "rebote" ser√° desmarcada y configurada. bandera "rebotada".  El cuerpo del mensaje devuelto ser√° el mismo que el mensaje original;  por lo tanto, es importante verificar el indicador "devuelto" del mensaje interno entrante antes de analizar el campo <em>operativo</em> en el contrato inteligente y procesar la solicitud correspondiente (de lo contrario, existe el riesgo de que la solicitud contenida en el mensaje devuelto sea procesada por su remitente original como una nueva solicitud por separado).  Si se establece el indicador "devuelto", un c√≥digo especial puede comprender qu√© solicitud fall√≥ (por ejemplo, deserializando <em>op</em> y <em>query_id</em> de un mensaje devuelto) y tomar las medidas apropiadas.  Un contrato inteligente m√°s simple puede simplemente ignorar todos los mensajes devueltos (finalizar con un c√≥digo de salida cero si se establece el indicador "rebotado"). </p><br><p>  Por otro lado, el receptor puede analizar con √©xito la solicitud entrante y descubrir que el m√©todo <em>operativo</em> solicitado no es compatible o que se ha cumplido otra condici√≥n de error.  Luego, se debe enviar una respuesta con <em>op</em> igual a 0xffffffff u otro valor apropiado utilizando SENDRAWMSG con mode = 64, como se mencion√≥ anteriormente. </p><br><p>  En algunas situaciones, ¬øel remitente desea transferir una cierta cantidad de dinero al mismo tiempo?  al remitente?  (aqu√≠, aparentemente, un error, y estaba destinado al "destinatario") y recibe una confirmaci√≥n o un mensaje de error.  Por ejemplo, un contrato inteligente de elecciones de validador recibe una solicitud para participar en una elecci√≥n junto con una oferta como valor agregado.  En tales casos, tiene sentido adjuntar, digamos, un gramo adicional al valor estimado [costo] (Aqu√≠ la palabra valor se usa en todas partes, en el significado del pago de alguna acci√≥n, as√≠ que us√© la palabra "costo").  Si se produce un error (por ejemplo, la oferta no puede aceptarse por ning√∫n motivo), el monto total recibido (menos la tarifa de procesamiento) debe devolverse al remitente junto con el mensaje de error (por ejemplo, utilizando SENDRAWMSG con mode = 64, como se describe arriba).  Si tiene √©xito, se crea un mensaje de confirmaci√≥n y se devuelve exactamente un gramo (en este caso, la tarifa de transferencia del mensaje se resta de este valor; este es el modo = 1 de SENDRAWMSG). </p><br><h2 id="ispolzovanie-nevozvratnyh-non-bounceable-soobscheniy">  Usar mensajes no rebotables </h2><br><p>  Casi todos los mensajes internos enviados entre contratos inteligentes deben devolverse (puede traducirlo como "rebote", pero para no confundirse, es m√°s f√°cil usar esta terminolog√≠a), es decir, deben tener el bit "rebote" no vac√≠o.  Luego, si el contrato inteligente objetivo no existe, o si crea una excepci√≥n no controlada al procesar este mensaje, el mensaje ser√° "devuelto", asumiendo el resto del costo inicial (valor) (menos todas las tarifas por la transmisi√≥n de mensajes y gas).  El mensaje devuelto tendr√° el mismo cuerpo, pero con la bandera de "rebote" borrada y la bandera de "rebote" establecida.  Por lo tanto, todos los contratos inteligentes deben verificar el indicador de "rebote" de todos los mensajes entrantes y recibirlos silenciosamente (terminando inmediatamente con un c√≥digo de salida cero) o realizar un procesamiento especial para determinar qu√© solicitud saliente fall√≥.  La solicitud contenida en el cuerpo del mensaje devuelto nunca debe ejecutarse. </p><br><p>  En algunos casos, se deben usar mensajes internos no rebotables.  Por ejemplo, no se puede crear una nueva cuenta sin que se le env√≠e al menos un mensaje interno irrevocable.  Si este mensaje no contiene StateInit con el c√≥digo y los datos del nuevo contrato inteligente, no tiene sentido tener un cuerpo no vac√≠o en un mensaje interno no devuelto. </p><br><p>  Es una buena idea no permitir que el usuario final (p. Ej., Billetera) env√≠e mensajes irrevocables que llevan una gran cantidad (p. Ej., M√°s de cinco gramos), o al menos advertirles si intentan hacerlo.  Es mejor enviar una peque√±a cantidad primero, luego crear un nuevo contrato inteligente y luego enviar una cantidad mayor. </p><br><h2 id="vneshnie-soobscheniya">  Mensajes externos </h2><br><p>  Los mensajes externos se env√≠an externamente a contratos inteligentes ubicados en la cadena de bloques TON para obligarlos a realizar ciertas acciones.  Por ejemplo, el contrato inteligente de la billetera espera recibir mensajes externos que contengan pedidos (por ejemplo, mensajes internos que se enviar√°n desde el contrato inteligente de la billetera) firmados por el propietario de la billetera;  cuando el contrato inteligente de la billetera recibe dicho mensaje externo, primero verifica la firma, luego recibe el mensaje (al lanzar la primitiva ACEPTAR TVM) y luego realiza todas las acciones necesarias. </p><br><p>  Tenga en cuenta que todos los mensajes externos deben estar protegidos contra ataques de reproducci√≥n.  Los validadores generalmente eliminan un mensaje externo del conjunto de mensajes externos propuestos (recibidos de la red);  sin embargo, en algunas situaciones, otro validador puede procesar el mismo mensaje externo dos veces (creando as√≠ una segunda transacci√≥n para el mismo mensaje externo, lo que conduce a la duplicaci√≥n de la acci√≥n original).  Peor a√∫n, un atacante puede extraer un mensaje externo de un bloque que contiene una transacci√≥n de procesamiento y reenviarlo m√°s tarde.  Esto puede causar, por ejemplo, un contrato de billetera inteligente para repetir el pago. </p><br><p>  La forma m√°s f√°cil de proteger los contratos inteligentes de los ataques de rastreo asociados con mensajes externos es almacenar el <em>contador cur-seqno de</em> 32 bits en los datos constantes del contrato inteligente y esperar el <em>valor req-seqno</em> en la (parte firmada) de cualquier mensaje externo entrante.  Luego se acepta el mensaje externo (ACEPTADO - una pista de la ACEPTACI√ìN primitiva) solo si la firma es v√°lida y <em>req-seqno</em> es igual a <em>cur-seqno</em> .  Despu√©s de un procesamiento exitoso, el valor de <em>cur-seqno</em> en los datos persistentes aumenta en uno, por lo que el mismo mensaje externo nunca ser√° recibido nuevamente. </p><br><p>  Tambi√©n puede incluir el campo <em>expirar</em> en un mensaje externo y aceptar el mensaje solo si el tiempo actual de Unix es menor que el valor de este campo.  Este enfoque se puede usar en combinaci√≥n con <em>seqno</em> ;  alternativamente, el contrato inteligente receptor puede almacenar un conjunto (hashes) de todos los √∫ltimos mensajes externos recibidos (no caducados) en sus datos permanentes y rechazar un nuevo mensaje externo si es un duplicado de uno de los mensajes guardados.  Tambi√©n debe implementar la recopilaci√≥n y eliminaci√≥n de mensajes caducados en este conjunto para evitar el crecimiento ilimitado de datos persistentes. </p><br><p>  Como regla general, un mensaje externo comienza con una firma de 256 bits (si es necesario), un <em>req-seqno de</em> 32 bits (si es necesario), una <em>expiraci√≥n de</em> 32 bits (si es necesario) y posiblemente una operaci√≥n de 32 bits y otros par√°metros necesarios en dependiendo de <em>op</em> .  La plantilla de mensaje externo no tiene que estar tan estandarizada como la plantilla de mensaje interno, ya que los mensajes externos no se utilizan para la interacci√≥n entre diferentes contratos inteligentes (escritos por diferentes desarrolladores y administrados por diferentes propietarios). </p><br><h2 id="get-metody">  Obtener m√©todos </h2><br><p>  Se espera que algunos contratos inteligentes implementen ciertos m√©todos get bien definidos.  Por ejemplo, se espera que cualquier contrato inteligente dns resolver para TON DNS implemente el m√©todo dnsresolve get.  Los contratos inteligentes personalizados pueden definir sus m√©todos de obtenci√≥n espec√≠ficos.  Nuestra √∫nica recomendaci√≥n general en este momento es implementar el m√©todo de obtenci√≥n "seqno" (sin par√°metros), que devuelve la <em>seqno</em> actual <em>del</em> contrato inteligente, que utiliza n√∫meros de secuencia para evitar ataques de reproducci√≥n asociados con m√©todos externos entrantes siempre que dicho m√©todo tenga significado. </p><br><p>  Diccionario: </p><br><ul><li>  Celda: una celda TVM consta de como m√°ximo 1023 bits de datos y como m√°ximo cuatro referencias a otras celdas.  Todos los datos persistentes (incluido el c√≥digo TVM) en TON Blockchain se representan como una colecci√≥n de c√©lulas TVM (cf. [1, 2.5.14]).  - una celda TVM consta de no m√°s de 1023 bits de datos y no m√°s de cuatro enlaces a otras celdas.  Todos los datos persistentes (incluido el c√≥digo TVM) en la cadena de bloques TON se presentan como un conjunto de celdas TVM (cf. [1, 2.5.14]).  - extracto de la descripci√≥n de la m√°quina virtual TON ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://test.ton.org/tvm.pdf</a> ) </li></ul><br><h2 id="kakie-mozhno-sdelat-vyvody-na-osnove-prochitannogo">  ¬øQu√© conclusiones se pueden sacar de lo que leo? </h2><br><ol><li>  Puede enviar mensajes externos a contratos para activar una acci√≥n. </li><li>  Ataques: hay, por ejemplo, ataques de repetici√≥n </li><li>  Vale la pena hacer el m√©todo <em>seqno</em> para proteger contra ataques de repetici√≥n. </li><li>  Los solucionadores de Dns tienen el m√©todo dnsresolve </li><li>  Puede almacenar hashes de mensajes externos para protegerse contra ataques, pero debe eliminarlos a tiempo, para esto vale la pena usar el campo <em>expired_at</em> para mensajes externos </li><li>  Los mensajes sin devoluci√≥n solo son necesarios para crear contratos; de lo contrario, todos los mensajes internos son devueltos </li><li>  Los mensajes de solicitud-respuesta deben contener los siguientes campos: <em>op, query_id</em> - opcional y algunos m√°s dependiendo del valor de <em>op</em> </li><li>  Puede adjuntar comentarios de texto en formato UTF-8 para personas y "comentarios binarios" para lectura y procesamiento autom√°ticos por software de terceros. </li><li>  Vale la pena manejar excepciones y hacerlo sabiamente </li><li>  "Mensaje simple sin comentarios": debe tener un cuerpo vac√≠o </li><li>  El bit de orden superior de los mensajes de solicitud-respuesta toma un valor de 0 para los mensajes de solicitud y un valor de 1 para los mensajes de respuesta </li><li>  Hay valores operativos est√°ndar para mensajes de respuesta para identificar errores </li><li>  Si se recibe un mensaje de respuesta con una operaci√≥n desconocida, se debe ignorar, es decir, completar la ejecuci√≥n con el c√≥digo 0 </li><li>  Tiene que pagar por enviar mensajes, por gas y por enviar una respuesta.  Al mismo tiempo, si envi√≥ m√°s de lo necesario, el exceso volver√° en la respuesta. </li><li>  Al recibir mensajes, siempre vale la pena verificar <em>primero el</em> indicador <em>rebotado.</em> </li></ol><br><p>  ¬°Gracias por su atenci√≥n, me complacer√° recibir comentarios constructivos! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/470772/">https://habr.com/ru/post/470772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../470750/index.html">Amazon atrapado atrapando los mejores productos</a></li>
<li><a href="../470752/index.html">Analizando pagos de Wechat</a></li>
<li><a href="../470754/index.html">Chatbot de RASA: experiencia de Parallels</a></li>
<li><a href="../470756/index.html">Crear una aplicaci√≥n de fondo para el chat en l√≠nea de Apollo, Node.js</a></li>
<li><a href="../470758/index.html">Resumen de la actividad viral en septiembre de 2019</a></li>
<li><a href="../470774/index.html">Nuevas anotaciones de tipo en Python 3.8 (Protocolo, Final, TypedDict, Literal)</a></li>
<li><a href="../470778/index.html">Revisi√≥n de la unidad Seagate ST2000DM008: r√°pido "dos" sin sobreprecio</a></li>
<li><a href="../470780/index.html">La barra est√° tomada: lo nuevo de Seagate para almacenamiento</a></li>
<li><a href="../470782/index.html">Datos en la frontera: c√≥mo construir una nueva arquitectura de TI</a></li>
<li><a href="../470784/index.html">El dise√±o de color de los misteriosos mundos de Dead Cells.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>