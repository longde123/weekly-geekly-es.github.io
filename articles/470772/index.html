<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎩 🐍 👴 TON: recomendaciones y mejores prácticas 👼🏼 🙋🏽 🖕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artículo es una traducción de un documento publicado en la página TON blockchain: smc-Guidelines.txt . Quizás esto ayude a alguien a dar un paso ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TON: recomendaciones y mejores prácticas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470772/"><p>  Este artículo es una traducción de un documento publicado en la página TON blockchain: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">smc-Guidelines.txt</a> .  Quizás esto ayude a alguien a dar un paso hacia el desarrollo de esta cadena de bloques.  Además, al final hice un breve resumen. </p><a name="habracut"></a><br><h2 id="vnutrennie-soobscheniya">  Mensajes internos </h2><br><p>  Los contratos inteligentes interactúan entre sí enviando los llamados mensajes internos.  Cuando el mensaje interno llega a su destino especificado, se crea una transacción regular a nombre de la cuenta de destino, y el mensaje interno se procesa de acuerdo con el código especificado y los datos constantes de esta cuenta (contrato inteligente).  En particular, una transacción de procesamiento puede crear uno o más mensajes internos, algunos de los cuales pueden dirigirse a la dirección de origen del mensaje interno que se está procesando.  Esto se puede usar para crear "aplicaciones cliente-servidor" simples cuando una solicitud se incrusta (encapsula) en un mensaje interno y se envía a otro contrato inteligente que procesa la solicitud y devuelve la respuesta, nuevamente como un mensaje interno. </p><br><p> Este enfoque lleva a la necesidad de distinguir entre mensajes internos a la "solicitud" y la "respuesta" (como una "consulta" o como una "respuesta"), o que no requieren ningún procesamiento adicional (como una simple transferencia de dinero).  Además, cuando llega una respuesta, debe haber una manera de entender a qué solicitud se refiere. </p><br><p>  Para lograr este objetivo, se recomienda utilizar la siguiente plantilla de mensaje interno (recuerde que la cadena de bloques TON no impone ninguna restricción en el cuerpo del mensaje, es decir, es solo una recomendación): </p><br><p>  0) El cuerpo del mensaje puede incrustarse en el mensaje en sí, o puede almacenarse en una celda separada (celda *), a la que se hace referencia en el mensaje, como se indica en el fragmento TL-B del diagrama (en inglés es más fácil de entender: o se almacena en una celda separada celda a la que se hace referencia desde el mensaje, como lo indica el fragmento del esquema TL-B): </p><br><pre><code class="plaintext hljs">message$_ {X:Type} ... body:(Either X ^X) = Message X;</code> </pre> <br><p>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://core.telegram.org/mtproto</a> - aquí puedes leer sobre esquemas TL) </p><br><p>  El contrato inteligente receptor debe aceptar al menos mensajes internos con el cuerpo del mensaje incrustado (incluso si se colocan en la celda que contiene el mensaje, siempre que encajen en la celda que contiene el mensaje, no está muy claro qué significa esto, por lo tanto, adjunta el texto original).  Si el contrato acepta cuerpos de mensajes en celdas separadas (usando el constructor "correcto" <code>(Either X ^X)</code> ), el procesamiento del mensaje entrante no debe depender del método particular de incrustar el cuerpo del mensaje.  Por otro lado, es absolutamente legal no admitir el cuerpo del mensaje en una celda separada para simplificar las solicitudes y respuestas. </p><br><p>  1) El cuerpo del mensaje generalmente comienza con los siguientes campos: </p><br><ul><li>  <em>op</em> : entero sin signo de 32 bits (big-endian) que identifica la operación a ejecutar o el método de contrato inteligente a llamar. </li><li>  <em>query_id</em> es un entero sin signo de 64 bits (big-endian) utilizado en todos los mensajes internos de preguntas y respuestas para identificar la relación de la respuesta a la solicitud (el <em>query_id de la</em> respuesta debe ser igual al <em>query_id de la</em> solicitud correspondiente).  Si <em>op</em> no es un método de solicitud-respuesta (llama a un método del que no se espera respuesta), se puede omitir <em>query_id</em> . </li><li>  el resto del cuerpo del mensaje es específico para cada valor admitido del parámetro <em>op</em> </li></ul><br><p>  2) Si <em>op</em> es cero, entonces el mensaje es un simple mensaje de transferencia con un comentario.  El comentario está contenido en el resto del mensaje (sin <em>query_id</em> y así sucesivamente, es decir, a partir del quinto byte (explicación: si <em>query_id</em> no lo <em>está</em> , entonces el campo <em>op</em> ocupa los primeros 4 bytes)).  Si no comienza con el byte 0xff, el comentario es de texto;);  se puede mostrar al usuario final de la billetera "tal cual" (después de filtrar caracteres no válidos y de control y verificar que se trata de una cadena UTF-8 válida).  Por ejemplo, los usuarios pueden especificar el propósito de una simple transferencia de su billetera a la billetera de otro usuario en este campo.  Por otro lado, si un comentario comienza con el byte 0xff, el resto del mensaje es un "comentario binario" que no debe mostrarse al usuario final como texto (solo si es necesario un volcado hexadecimal).  El uso propuesto de comentarios binarios, por ejemplo, es contener un identificador de pago para el pago en la tienda y ser generado y procesado automáticamente por el software de la tienda. </p><br><p>  La mayoría de los contratos inteligentes no tienen que realizar acciones no triviales o rechazar un mensaje entrante cuando reciben un "mensaje de transferencia simple".  Por lo tanto, cuando <em>op</em> resulta ser cero, la función de contrato inteligente para procesar mensajes internos entrantes (generalmente llamada <code>recv_internal()</code> ) debería salir inmediatamente con el código 0, lo que indica éxito (por ejemplo, arrojando la excepción 0 si no se instala un controlador personalizado en el contrato inteligente excepciones).  Esto conducirá al hecho de que la cantidad transferida por el mensaje se acreditará a la cuenta del destinatario sin ningún otro efecto. </p><br><p>  3) "Una transferencia de mensaje simple sin comentarios" tiene un cuerpo vacío (incluso sin el campo <em>op</em> ).  Las consideraciones anteriores se aplican a dichos mensajes.  Tenga en cuenta que dichos mensajes deben tener su propio cuerpo incrustado en la celda del mensaje. </p><br><p>  4) Esperamos que el campo <em>op</em> de los mensajes de solicitud tenga el primer bit ("bit de orden superior", traducido como el primero, esto puede ser incorrecto, pero como se explica más adelante queda claro) está vacío, es decir, el valor del campo debe estar en el rango <code>1 .. 2^31-1</code> , y para los mensajes de respuesta, el primer bit (de orden superior) debe ser igual a 1, es decir, el valor del campo en el rango <code>2^31 .. 2^32-1</code> .  Si el mensaje no es una solicitud ni una respuesta (el cuerpo no contiene el parámetro <em>query_id</em> ), entonces debe contener el parámetro <em>op</em> en el rango como en el mensaje de solicitud: <code>1 .. 2^31 - 1</code> . </p><br><p>  5) Hay varios mensajes de respuesta "estándar" para los cuales <em>op</em> es 0xffffffff y 0xffffffffe.  En general, los valores <em>op</em> de 0xfffffff0 a 0xffffffff están reservados para tales respuestas estándar. </p><br><ul><li>  <em>op = 0xffffffff</em> significa "la operación no es compatible".  Le sigue un <em>query_id de</em> 64 bits extraído de la consulta original y una operación de 32 bits <em>de la</em> consulta original.  Todos menos los contratos inteligentes más simples deberían devolver este error cuando reciben una solicitud con un <em>operador</em> desconocido en el rango 1 ... 2 ^ 31-1. </li><li>  <em>op = 0xfffffffe</em> significa "operación no permitida".  Le sigue el <em>query_id de</em> 64 bits <em>de la</em> consulta original, y luego la operación de 32 bits extraída de la consulta original. </li></ul><br><p>  Tenga en cuenta que las "respuestas" desconocidas (con <em>op</em> en el rango 2 ^ 31 ... 2 ^ 32-1) deben ignorarse (en particular, no debe generar una respuesta con <em>op</em> igual a 0xffffffff), así como un retorno inesperado ( (rebotado) -mensajes (con el conjunto de banderas "rebotado"). </p><br><h2 id="oplata-za-obrabotku-zaprosov-i-otpravlenie-otvetov">  Pago por procesar solicitudes y enviar respuestas </h2><br><p>  En general, si un contrato inteligente desea enviar una solicitud a otro contrato inteligente, debe pagar por enviar un mensaje interno al contrato inteligente objetivo (tarifas de reenvío de mensajes), para procesar este mensaje en el destino (tarifa de gas: tarifas de gas) y para enviar una respuesta si es necesario (tarifas de reenvío de mensajes). </p><br><p>  En la mayoría de los casos, el remitente adjuntará una pequeña cantidad de gramo al mensaje interno (por ejemplo, 1 gramo) (suficiente para pagar el procesamiento de este mensaje) y establecerá el indicador de "rebote" en él (es decir, enviará un mensaje interno rebotable);  el destinatario devolverá la parte no utilizada del valor recibido con la respuesta (restando la tarifa por enviarle el mensaje).  Esto generalmente se logra llamando a SENDRAWMSG con mode = 64 (véase el Apéndice A de la documentación de TON VM). </p><br><p>  Si el destinatario no puede procesar el mensaje recibido y la ejecución finaliza con un código de salida distinto de cero (por ejemplo, debido a una excepción de deserialización de celda no controlada), el mensaje será "devuelto" automáticamente al remitente, y la bandera de "rebote" será desmarcada y configurada. bandera "rebotada".  El cuerpo del mensaje devuelto será el mismo que el mensaje original;  por lo tanto, es importante verificar el indicador "devuelto" del mensaje interno entrante antes de analizar el campo <em>operativo</em> en el contrato inteligente y procesar la solicitud correspondiente (de lo contrario, existe el riesgo de que la solicitud contenida en el mensaje devuelto sea procesada por su remitente original como una nueva solicitud por separado).  Si se establece el indicador "devuelto", un código especial puede comprender qué solicitud falló (por ejemplo, deserializando <em>op</em> y <em>query_id</em> de un mensaje devuelto) y tomar las medidas apropiadas.  Un contrato inteligente más simple puede simplemente ignorar todos los mensajes devueltos (finalizar con un código de salida cero si se establece el indicador "rebotado"). </p><br><p>  Por otro lado, el receptor puede analizar con éxito la solicitud entrante y descubrir que el método <em>operativo</em> solicitado no es compatible o que se ha cumplido otra condición de error.  Luego, se debe enviar una respuesta con <em>op</em> igual a 0xffffffff u otro valor apropiado utilizando SENDRAWMSG con mode = 64, como se mencionó anteriormente. </p><br><p>  En algunas situaciones, ¿el remitente desea transferir una cierta cantidad de dinero al mismo tiempo?  al remitente?  (aquí, aparentemente, un error, y estaba destinado al "destinatario") y recibe una confirmación o un mensaje de error.  Por ejemplo, un contrato inteligente de elecciones de validador recibe una solicitud para participar en una elección junto con una oferta como valor agregado.  En tales casos, tiene sentido adjuntar, digamos, un gramo adicional al valor estimado [costo] (Aquí la palabra valor se usa en todas partes, en el significado del pago de alguna acción, así que usé la palabra "costo").  Si se produce un error (por ejemplo, la oferta no puede aceptarse por ningún motivo), el monto total recibido (menos la tarifa de procesamiento) debe devolverse al remitente junto con el mensaje de error (por ejemplo, utilizando SENDRAWMSG con mode = 64, como se describe arriba).  Si tiene éxito, se crea un mensaje de confirmación y se devuelve exactamente un gramo (en este caso, la tarifa de transferencia del mensaje se resta de este valor; este es el modo = 1 de SENDRAWMSG). </p><br><h2 id="ispolzovanie-nevozvratnyh-non-bounceable-soobscheniy">  Usar mensajes no rebotables </h2><br><p>  Casi todos los mensajes internos enviados entre contratos inteligentes deben devolverse (puede traducirlo como "rebote", pero para no confundirse, es más fácil usar esta terminología), es decir, deben tener el bit "rebote" no vacío.  Luego, si el contrato inteligente objetivo no existe, o si crea una excepción no controlada al procesar este mensaje, el mensaje será "devuelto", asumiendo el resto del costo inicial (valor) (menos todas las tarifas por la transmisión de mensajes y gas).  El mensaje devuelto tendrá el mismo cuerpo, pero con la bandera de "rebote" borrada y la bandera de "rebote" establecida.  Por lo tanto, todos los contratos inteligentes deben verificar el indicador de "rebote" de todos los mensajes entrantes y recibirlos silenciosamente (terminando inmediatamente con un código de salida cero) o realizar un procesamiento especial para determinar qué solicitud saliente falló.  La solicitud contenida en el cuerpo del mensaje devuelto nunca debe ejecutarse. </p><br><p>  En algunos casos, se deben usar mensajes internos no rebotables.  Por ejemplo, no se puede crear una nueva cuenta sin que se le envíe al menos un mensaje interno irrevocable.  Si este mensaje no contiene StateInit con el código y los datos del nuevo contrato inteligente, no tiene sentido tener un cuerpo no vacío en un mensaje interno no devuelto. </p><br><p>  Es una buena idea no permitir que el usuario final (p. Ej., Billetera) envíe mensajes irrevocables que llevan una gran cantidad (p. Ej., Más de cinco gramos), o al menos advertirles si intentan hacerlo.  Es mejor enviar una pequeña cantidad primero, luego crear un nuevo contrato inteligente y luego enviar una cantidad mayor. </p><br><h2 id="vneshnie-soobscheniya">  Mensajes externos </h2><br><p>  Los mensajes externos se envían externamente a contratos inteligentes ubicados en la cadena de bloques TON para obligarlos a realizar ciertas acciones.  Por ejemplo, el contrato inteligente de la billetera espera recibir mensajes externos que contengan pedidos (por ejemplo, mensajes internos que se enviarán desde el contrato inteligente de la billetera) firmados por el propietario de la billetera;  cuando el contrato inteligente de la billetera recibe dicho mensaje externo, primero verifica la firma, luego recibe el mensaje (al lanzar la primitiva ACEPTAR TVM) y luego realiza todas las acciones necesarias. </p><br><p>  Tenga en cuenta que todos los mensajes externos deben estar protegidos contra ataques de reproducción.  Los validadores generalmente eliminan un mensaje externo del conjunto de mensajes externos propuestos (recibidos de la red);  sin embargo, en algunas situaciones, otro validador puede procesar el mismo mensaje externo dos veces (creando así una segunda transacción para el mismo mensaje externo, lo que conduce a la duplicación de la acción original).  Peor aún, un atacante puede extraer un mensaje externo de un bloque que contiene una transacción de procesamiento y reenviarlo más tarde.  Esto puede causar, por ejemplo, un contrato de billetera inteligente para repetir el pago. </p><br><p>  La forma más fácil de proteger los contratos inteligentes de los ataques de rastreo asociados con mensajes externos es almacenar el <em>contador cur-seqno de</em> 32 bits en los datos constantes del contrato inteligente y esperar el <em>valor req-seqno</em> en la (parte firmada) de cualquier mensaje externo entrante.  Luego se acepta el mensaje externo (ACEPTADO - una pista de la ACEPTACIÓN primitiva) solo si la firma es válida y <em>req-seqno</em> es igual a <em>cur-seqno</em> .  Después de un procesamiento exitoso, el valor de <em>cur-seqno</em> en los datos persistentes aumenta en uno, por lo que el mismo mensaje externo nunca será recibido nuevamente. </p><br><p>  También puede incluir el campo <em>expirar</em> en un mensaje externo y aceptar el mensaje solo si el tiempo actual de Unix es menor que el valor de este campo.  Este enfoque se puede usar en combinación con <em>seqno</em> ;  alternativamente, el contrato inteligente receptor puede almacenar un conjunto (hashes) de todos los últimos mensajes externos recibidos (no caducados) en sus datos permanentes y rechazar un nuevo mensaje externo si es un duplicado de uno de los mensajes guardados.  También debe implementar la recopilación y eliminación de mensajes caducados en este conjunto para evitar el crecimiento ilimitado de datos persistentes. </p><br><p>  Como regla general, un mensaje externo comienza con una firma de 256 bits (si es necesario), un <em>req-seqno de</em> 32 bits (si es necesario), una <em>expiración de</em> 32 bits (si es necesario) y posiblemente una operación de 32 bits y otros parámetros necesarios en dependiendo de <em>op</em> .  La plantilla de mensaje externo no tiene que estar tan estandarizada como la plantilla de mensaje interno, ya que los mensajes externos no se utilizan para la interacción entre diferentes contratos inteligentes (escritos por diferentes desarrolladores y administrados por diferentes propietarios). </p><br><h2 id="get-metody">  Obtener métodos </h2><br><p>  Se espera que algunos contratos inteligentes implementen ciertos métodos get bien definidos.  Por ejemplo, se espera que cualquier contrato inteligente dns resolver para TON DNS implemente el método dnsresolve get.  Los contratos inteligentes personalizados pueden definir sus métodos de obtención específicos.  Nuestra única recomendación general en este momento es implementar el método de obtención "seqno" (sin parámetros), que devuelve la <em>seqno</em> actual <em>del</em> contrato inteligente, que utiliza números de secuencia para evitar ataques de reproducción asociados con métodos externos entrantes siempre que dicho método tenga significado. </p><br><p>  Diccionario: </p><br><ul><li>  Celda: una celda TVM consta de como máximo 1023 bits de datos y como máximo cuatro referencias a otras celdas.  Todos los datos persistentes (incluido el código TVM) en TON Blockchain se representan como una colección de células TVM (cf. [1, 2.5.14]).  - una celda TVM consta de no más de 1023 bits de datos y no más de cuatro enlaces a otras celdas.  Todos los datos persistentes (incluido el código TVM) en la cadena de bloques TON se presentan como un conjunto de celdas TVM (cf. [1, 2.5.14]).  - extracto de la descripción de la máquina virtual TON ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://test.ton.org/tvm.pdf</a> ) </li></ul><br><h2 id="kakie-mozhno-sdelat-vyvody-na-osnove-prochitannogo">  ¿Qué conclusiones se pueden sacar de lo que leo? </h2><br><ol><li>  Puede enviar mensajes externos a contratos para activar una acción. </li><li>  Ataques: hay, por ejemplo, ataques de repetición </li><li>  Vale la pena hacer el método <em>seqno</em> para proteger contra ataques de repetición. </li><li>  Los solucionadores de Dns tienen el método dnsresolve </li><li>  Puede almacenar hashes de mensajes externos para protegerse contra ataques, pero debe eliminarlos a tiempo, para esto vale la pena usar el campo <em>expired_at</em> para mensajes externos </li><li>  Los mensajes sin devolución solo son necesarios para crear contratos; de lo contrario, todos los mensajes internos son devueltos </li><li>  Los mensajes de solicitud-respuesta deben contener los siguientes campos: <em>op, query_id</em> - opcional y algunos más dependiendo del valor de <em>op</em> </li><li>  Puede adjuntar comentarios de texto en formato UTF-8 para personas y "comentarios binarios" para lectura y procesamiento automáticos por software de terceros. </li><li>  Vale la pena manejar excepciones y hacerlo sabiamente </li><li>  "Mensaje simple sin comentarios": debe tener un cuerpo vacío </li><li>  El bit de orden superior de los mensajes de solicitud-respuesta toma un valor de 0 para los mensajes de solicitud y un valor de 1 para los mensajes de respuesta </li><li>  Hay valores operativos estándar para mensajes de respuesta para identificar errores </li><li>  Si se recibe un mensaje de respuesta con una operación desconocida, se debe ignorar, es decir, completar la ejecución con el código 0 </li><li>  Tiene que pagar por enviar mensajes, por gas y por enviar una respuesta.  Al mismo tiempo, si envió más de lo necesario, el exceso volverá en la respuesta. </li><li>  Al recibir mensajes, siempre vale la pena verificar <em>primero el</em> indicador <em>rebotado.</em> </li></ol><br><p>  ¡Gracias por su atención, me complacerá recibir comentarios constructivos! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/470772/">https://habr.com/ru/post/470772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../470750/index.html">Amazon atrapado atrapando los mejores productos</a></li>
<li><a href="../470752/index.html">Analizando pagos de Wechat</a></li>
<li><a href="../470754/index.html">Chatbot de RASA: experiencia de Parallels</a></li>
<li><a href="../470756/index.html">Crear una aplicación de fondo para el chat en línea de Apollo, Node.js</a></li>
<li><a href="../470758/index.html">Resumen de la actividad viral en septiembre de 2019</a></li>
<li><a href="../470774/index.html">Nuevas anotaciones de tipo en Python 3.8 (Protocolo, Final, TypedDict, Literal)</a></li>
<li><a href="../470778/index.html">Revisión de la unidad Seagate ST2000DM008: rápido "dos" sin sobreprecio</a></li>
<li><a href="../470780/index.html">La barra está tomada: lo nuevo de Seagate para almacenamiento</a></li>
<li><a href="../470782/index.html">Datos en la frontera: cómo construir una nueva arquitectura de TI</a></li>
<li><a href="../470784/index.html">El diseño de color de los misteriosos mundos de Dead Cells.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>