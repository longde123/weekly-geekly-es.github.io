<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🎨 💋 🚯 Metode Sederhana untuk Mengoptimalkan Program Go ⛺️ 👱 👨🏿‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya selalu peduli dengan kinerja. Saya tidak tahu persis mengapa. Tapi saya hanya kesal dengan layanan dan program yang lambat. Sepertinya saya tidak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metode Sederhana untuk Mengoptimalkan Program Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457004/">  Saya selalu peduli dengan kinerja.  Saya tidak tahu persis mengapa.  Tapi saya hanya kesal dengan layanan dan program yang lambat.  Sepertinya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saya tidak sendiri</a> . <br><br><blockquote>  <i>Dalam pengujian A / B, kami mencoba memperlambat output halaman dalam peningkatan 100 milidetik dan menemukan bahwa bahkan keterlambatan yang sangat kecil pun menyebabkan penurunan signifikan dalam pendapatan.</i>  - Greg Linden, Amazon.com </blockquote><br>  Dari pengalaman, produktivitas yang rendah dimanifestasikan dalam satu dari dua cara: <br><br><ul><li>  Operasi yang berkinerja baik dalam skala kecil menjadi tidak dapat digunakan dengan meningkatnya jumlah pengguna.  Biasanya ini adalah operasi O (N) atau O (N²).  Ketika basis pengguna kecil, semuanya berfungsi dengan baik.  Produk ini terburu-buru untuk dibawa ke pasar.  Ketika basis tumbuh, semakin banyak situasi patologis yang tak terduga muncul - dan layanan berhenti. <br></li><li> Banyak sumber individual pekerjaan suboptimal, "kematian dari seribu luka." </li></ul><a name="habracut"></a><br>  Untuk sebagian besar karir saya, saya belajar ilmu data dengan Python atau membuat layanan di Go.  Dalam kasus kedua, saya memiliki lebih banyak pengalaman dalam optimasi.  Go biasanya bukan hambatan dalam layanan yang saya tulis - program basis data sering dibatasi oleh I / O.  Namun, dalam pipa batch pembelajaran mesin yang saya kembangkan, program ini sering dibatasi oleh CPU.  Jika Go menggunakan prosesor terlalu banyak, ada berbagai strategi. <br><br>  Artikel ini menjelaskan beberapa metode yang dapat digunakan untuk meningkatkan produktivitas secara signifikan tanpa banyak usaha.  Saya sengaja mengabaikan metode yang membutuhkan upaya signifikan atau perubahan besar dalam struktur program. <br><br><h1>  Sebelum Anda mulai </h1><br>  Sebelum membuat perubahan apa pun pada program, luangkan waktu untuk membuat garis dasar yang sesuai untuk perbandingan.  Jika tidak, maka Anda akan berkeliaran dalam gelap, bertanya-tanya apakah ada manfaat dari perubahan yang dilakukan.  Pertama, tulis tolok ukur dan ambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">profil</a> untuk digunakan di pprof.  Yang terbaik adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menulis patokan juga di Go</a> : ini membuatnya lebih mudah untuk menggunakan profil pprof dan memori.  Juga gunakan benchcmp: alat yang berguna untuk membandingkan perbedaan kinerja antara tes. <br><br>  Jika kodenya tidak terlalu kompatibel dengan tolok ukur, mulailah saja dengan sesuatu yang dapat diukur.  Anda dapat membuat profil kode secara manual dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">runtime / pprof</a> . <br><br>  Jadi mari kita mulai! <br><br><h3>  Gunakan sync.Pool untuk menggunakan kembali objek yang dipilih sebelumnya </h3><br>  sync.Pool mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar rilis</a> .  Hal ini memungkinkan Anda untuk menggunakan kembali struktur yang sebelumnya dialokasikan dan mengamortisasi distribusi objek melalui banyak kegunaan, mengurangi pekerjaan pengumpul sampah.  APInya sangat sederhana.  Menerapkan fungsi yang mengalokasikan instance baru dari objek.  API akan mengembalikan tipe pointer. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bufpool = sync.Pool{ New: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} { buf := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">512</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;buf }}</code> </pre> <br>  Setelah itu, Anda dapat melakukan <code>Get()</code> objek dari kolam dan <code>Put()</code> kembali ketika Anda selesai. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// sync.Pool returns a interface{}: you must cast it to the underlying type // before you use it. b := *bufpool.Get().(*[]byte) defer bufpool.Put(&amp;b) // Now, go do interesting things with your byte buffer. buf := bytes.NewBuffer(b)</span></span></code> </pre> <br>  Ada nuansa.  Sebelum Go 1.13, kolam dibersihkan dengan setiap pengumpulan sampah.  Ini dapat mempengaruhi kinerja program yang mengalokasikan banyak memori.  Pada 1,13, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tampaknya lebih banyak objek bertahan setelah GC</a> . <br><br>  <b>!!!</b>  <b>Sebelum mengembalikan objek ke kolam, pastikan untuk mengatur ulang bidang struktur.</b> <br><br>  Jika tidak, maka Anda bisa mendapatkan objek kotor dari kumpulan yang berisi data dari penggunaan sebelumnya.  Ini adalah risiko keamanan yang serius! <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> AuthenticationResponse { Token <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> UserID <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } rsp := authPool.Get().(*AuthenticationResponse) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> authPool.Put(rsp) <span class="hljs-comment"><span class="hljs-comment">// If we don't hit this if statement, we might return data from other users! if blah { rsp.UserID = "user-1" rsp.Token = "super-secret" } return rsp</span></span></code> </pre> <br>  Cara aman untuk selalu menjamin nol memori adalah dengan melakukan ini secara eksplisit: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// reset resets all fields of the AuthenticationResponse before pooling it. func (a* AuthenticationResponse) reset() { a.Token = "" a.UserID = "" } rsp := authPool.Get().(*AuthenticationResponse) defer func() { rsp.reset() authPool.Put(rsp) }()</span></span></code> </pre> <br>  Satu-satunya kasus ketika ini bukan masalah adalah ketika Anda menggunakan memori persis yang Anda tulis.  Sebagai contoh: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( r io.Reader w io.Writer ) <span class="hljs-comment"><span class="hljs-comment">// Obtain a buffer from the pool. buf := *bufPool.Get().(*[]byte) defer bufPool.Put(&amp;buf) // We only write to w exactly what we read from r, and no more. nr, er := r.Read(buf) if nr &gt; 0 { nw, ew := w.Write(buf[0:nr]) }</span></span></code> </pre> <br><h3>  Hindari menggunakan struktur yang mengandung pointer sebagai kunci untuk peta besar </h3><br>  Fuh, aku terlalu verbose.  Maafkan aku  Mereka sering berbicara (termasuk mantan kolega saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Phil Pearl</a> ) tentang kinerja Go dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ukuran besar</a> .  Selama pengumpulan sampah, runtime memindai objek dengan pointer dan melacaknya.  Jika Anda memiliki <code>map[string]int</code> sangat besar, maka GC harus memeriksa setiap baris.  Ini terjadi pada setiap pengumpulan sampah, karena garis mengandung pointer. <br><br>  Dalam contoh ini, kita menulis 10 juta elemen untuk <code>map[string]int</code> dan mengukur durasi pengumpulan sampah.  Kami mengalokasikan peta kami di area paket untuk menjamin alokasi memori dari heap. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( numElements = <span class="hljs-number"><span class="hljs-number">10000000</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeGC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { t := time.Now() runtime.GC() fmt.Printf(<span class="hljs-string"><span class="hljs-string">"gc took: %s\n"</span></span>, time.Since(t)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numElements; i++ { foo[strconv.Itoa(i)] = i } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { timeGC() time.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) } }</code> </pre> <br>  Menjalankan program, kita akan melihat hal berikut: <br><br><pre>  inthash → buka instal &amp;&amp; inthash
 gc mengambil: 98.726321ms
 gc mengambil: 105.524633ms
 gc mengambil: 102.829451ms
 gc mengambil: 102.71908ms
 gc mengambil: 103.084104ms
 gc mengambil: 104.821989ms </pre><br>  Ini waktu yang cukup lama di negara komputer! <br><br>  Apa yang bisa dilakukan untuk mengoptimalkan?  Menghapus pointer di mana-mana adalah ide yang baik, agar tidak memuat pengumpul sampah.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ada petunjuk di baris</a> ;  jadi mari kita terapkan ini sebagai <code>map[int]int</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( numElements = <span class="hljs-number"><span class="hljs-number">10000000</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeGC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { t := time.Now() runtime.GC() fmt.Printf(<span class="hljs-string"><span class="hljs-string">"gc took: %s\n"</span></span>, time.Since(t)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numElements; i++ { foo[i] = i } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { timeGC() time.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) } }</code> </pre> <br>  Menjalankan program lagi, kita melihat: <br><br><pre>  inthash → buka instal &amp;&amp; inthash
 gc mengambil: 3.608993ms
 gc mengambil: 3.926913ms
 gc mengambil: 3.955706ms
 gc mengambil: 4.063795ms
 gc mengambil: 3,91519ms
 gc mengambil: 3.75226ms </pre><br>  Jauh lebih baik.  Kami telah mempercepat pengumpulan sampah sebanyak 35 kali.  Ketika digunakan dalam produksi, akan perlu untuk mengaitkan string ke dalam bilangan bulat sebelum memasukkan ke dalam kartu. <br><br>  Omong-omong, ada banyak lagi cara untuk menghindari GC.  Jika Anda mengalokasikan array raksasa dari struktur, int, atau byte yang tidak berarti, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GC tidak akan memindai ini</a> : artinya, Anda menghemat waktu GC.  Metode seperti itu biasanya memerlukan revisi substansial dari program, jadi hari ini kita tidak akan membahas topik ini. <br><br>  Seperti halnya optimasi apa pun, efeknya dapat bervariasi.  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utas tweet dari Damian Gryski</a> untuk contoh menarik tentang cara menghapus garis dari peta besar yang mendukung struktur data yang lebih pintar sebenarnya <i>meningkatkan</i> konsumsi memori.  Secara umum, baca semua yang dia terbitkan. <br><br><h3>  Membuat kode generasi untuk menghindari refleksi runtime </h3><br>  Membungkam dan menghapus struktur Anda ke dalam berbagai format serialisasi, seperti JSON, adalah operasi tipikal, terutama saat membuat layanan microser.  Untuk banyak layanan mikro, ini biasanya merupakan satu-satunya pekerjaan.  Fungsinya seperti <code>json.Marshal</code> dan <code>json.Unmarshal</code> mengandalkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">refleksi dalam runtime</a> untuk membuat serial bidang struktur menjadi byte dan sebaliknya.  Ini dapat bekerja lambat: refleksi tidak seefisien kode eksplisit. <br><br>  Namun, ada opsi pengoptimalan.  Mekanik marsaling JSON terlihat seperti ini: <br><br><pre> <code class="json hljs">package json // Marshal take an object and returns its representation in JSON. func Marshal(obj interface{}) ([]byte, error) { // Check if this object knows how to marshal itself to JSON // by satisfying the Marshaller interface. if m, is := obj.(json.Marshaller); is { return m.MarshalJSON() } // It doesn't know how to marshal itself. Do default reflection based marshallling. return marshal(obj) }</code> </pre> <br>  Jika kita mengetahui proses virtualisasi di JSON, kita memiliki petunjuk untuk menghindari refleksi dalam runtime.  Tetapi kami tidak ingin menulis secara manual semua kode virtualisasi, jadi apa yang harus dilakukan?  Biarkan komputer membuat kode ini!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembuat</a> kode seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">easyjson</a> melihat struktur dan menghasilkan kode yang sangat optimal yang sepenuhnya kompatibel dengan antarmuka marshaling yang ada seperti <code>json.Marshaller</code> . <br><br>  Unduh paket dan tulis perintah berikut dalam <code>$file.go</code> , yang berisi struktur yang Anda inginkan untuk menghasilkan kode. <br><br><pre>  easyjson -semua $ file.go </pre><br>  File <code>$file_easyjson.go</code> harus dibuat.  Karena <code>easyjson</code> mengimplementasikan antarmuka <code>json.Marshaller</code> untuk Anda, fungsi-fungsi ini akan dipanggil secara default alih-alih refleksi.  Selamat: Anda baru saja mempercepat kode JSON Anda tiga kali.  Ada banyak trik untuk lebih meningkatkan produktivitas. <br><br>  Saya merekomendasikan paket ini karena saya telah menggunakannya sendiri sebelumnya, dan berhasil.  Tapi hati-hati.  Tolong jangan menganggap ini sebagai undangan untuk memulai debat agresif dengan saya tentang paket JSON tercepat. <br><br>  Pastikan untuk membuat kembali kode marshaling ketika struktur berubah.  Jika Anda lupa melakukan ini, bidang yang baru ditambahkan tidak akan diserialisasi, yang akan menyebabkan kebingungan!  Anda dapat menggunakan <code>go generate</code> untuk tugas-tugas ini.  Untuk menjaga sinkronisasi dengan struktur, saya lebih suka menempatkan <code>generate.go</code> di root paket, yang menyebabkan <code>go generate</code> untuk semua file paket: ini dapat membantu ketika Anda memiliki banyak file yang perlu menghasilkan kode tersebut.  Kiat utama: untuk memastikan bahwa struktur diperbarui, panggil <code>go generate</code> di CI dan periksa bahwa tidak ada perbedaan dengan kode terdaftar. <br><br><h3>  Gunakan string. Builder untuk membangun string </h3><br>  Di Go, string tidak dapat diubah: anggap saja sebagai byte read-only.  Ini berarti bahwa setiap kali Anda membuat string, Anda mengalokasikan memori dan berpotensi membuat lebih banyak pekerjaan untuk pengumpul sampah. <br><br>  Go 1.10 menerapkan string. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Builder</a> sebagai cara yang efisien untuk membuat string.  Secara internal, ia menulis ke buffer byte.  Hanya ketika memanggil <code>String()</code> di builder yang benar-benar membuat string.  Dia mengandalkan beberapa trik tidak aman untuk mengembalikan byte yang mendasarinya sebagai string dengan alokasi nol: lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog ini</a> untuk studi lebih lanjut tentang cara kerjanya. <br><br>  Bandingkan kinerja kedua pendekatan: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main.go package main import "strings" var strs = []string{ "here's", "a", "some", "long", "list", "of", "strings", "for", "you", } func buildStrNaive() string { var s string for _, v := range strs { s += v } return s } func buildStrBuilder() string { b := strings.Builder{} // Grow the buffer to a decent length, so we don't have to continually // re-allocate. b.Grow(60) for _, v := range strs { b.WriteString(v) } return b.String() }</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main_test.go package main import ( "testing" ) var str string func BenchmarkStringBuildNaive(b *testing.B) { for i := 0; i &lt; bN; i++ { str = buildStrNaive() } } func BenchmarkStringBuildBuilder(b *testing.B) { for i := 0; i &lt; bN; i++ { str = buildStrBuilder() }</span></span></code> </pre> <br>  Berikut adalah hasil pada Macbook Pro saya: <br><br><pre>  strbuild -&gt; go test -bench =.  -benchmem
 goos: darwin
 goarch: amd64
 pkg: github.com/sjwhitworth/perfblog/strbuild
 BenchmarkStringBuildNaive-8 5.000.000 255 ns / op 216 B / op 8 allocs / op
 BenchmarkStringBuildBuilder-8 20.000.000 54,9 ns / op 64 B / op 1 allocs / op </pre><br>  Seperti yang Anda lihat, <code>strings.Builder</code> adalah 4,7 kali lebih cepat, menyebabkan alokasi delapan kali lebih sedikit dan memakan memori empat kali lebih sedikit. <br><br>  Ketika masalah kinerja, gunakan <code>strings.Builder</code> . <code>strings.Builder</code> .  Secara umum, saya sarankan menggunakannya di mana-mana, kecuali untuk kasus string bangunan yang paling sepele. <br><br><h3>  Gunakan strconv sebagai ganti fmt </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fmt</a> adalah salah satu paket paling terkenal di Go.  Anda mungkin menggunakannya di program pertama Anda untuk menampilkan "halo, dunia".  Tetapi ketika datang untuk mengkonversi bilangan bulat dan mengapung ke string, itu tidak seefisien adiknya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">strconv</a> .  Paket ini menunjukkan kinerja yang baik dengan sedikit perubahan pada API. <br><br>  <code>fmt</code> pada dasarnya mengambil <code>interface{}</code> sebagai argumen fungsi.  Ada dua kelemahan: <br><br><ul><li>  Anda kehilangan keamanan tipe.  Bagi saya itu sangat penting. <br></li><li>  Ini dapat meningkatkan jumlah sekresi yang dibutuhkan.  Melewati jenis tanpa pointer sebagai <code>interface{}</code> biasanya menghasilkan alokasi tumpukan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Posting blog ini</a> menjelaskan mengapa demikian. </li><li>  Program berikut menunjukkan perbedaan dalam kinerja: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main.go package main import ( "fmt" "strconv" ) func strconvFmt(a string, b int) string { return a + ":" + strconv.Itoa(b) } func fmtFmt(a string, b int) string { return fmt.Sprintf("%s:%d", a, b) } func main() {}</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main_test.go package main import ( "testing" ) var ( a = "boo" blah = 42 box = "" ) func BenchmarkStrconv(b *testing.B) { for i := 0; i &lt; bN; i++ { box = strconvFmt(a, blah) } a = box } func BenchmarkFmt(b *testing.B) { for i := 0; i &lt; bN; i++ { box = fmtFmt(a, blah) } a = box }</span></span></code> </pre> <br>  Tolak ukur pada Macbook Pro: <br><br><pre>  strfmt → lanjutkan uji -bench =.  -benchmem
 goos: darwin
 goarch: amd64
 pkg: github.com/sjwhitworth/perfblog/strfmt
 BenchmarkStrconv-8 30.000.000 39,5 ns / op 32 B / op 1 allocs / op
 BenchmarkFmt-8 10.000.000 143 ns / op 72 B / op 3 allocs / op </pre><br>  Seperti yang Anda lihat, opsi strconv adalah 3,5 kali lebih cepat, menyebabkan alokasi tiga kali lebih sedikit dan menghabiskan setengah memori. <br><br><h3>  Alokasikan slice tank dengan membuat untuk menghindari redistribusi </h3><br>  Sebelum beralih ke peningkatan kinerja, mari kita segera perbarui informasi yang diiris dalam memori.  Sepotong adalah konstruksi yang sangat berguna di Go.  Ini menyediakan array yang dapat diskalakan dengan kemampuan untuk menerima tampilan yang berbeda dalam memori dasar yang sama tanpa realokasi.  Jika Anda melihat di bawah tenda, maka irisan terdiri dari tiga elemen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> slice <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// pointer to underlying data in the slice. data uintptr // the number of elements in the slice. len int // the number of elements that the slice can // grow to before a new underlying array // is allocated. cap int }</span></span></code> </pre> <br>  Apa bidang-bidang ini? <br><br><ul><li>  <code>data</code> : penunjuk ke data yang mendasarinya di slice <br></li><li>  <code>len</code> : jumlah elemen saat ini di slice <br></li><li>  <code>cap</code> : jumlah elemen yang dapat ditumbuhkan oleh irisan sebelum didistribusikan ulang </li></ul><br>  Bagian di bawah kap adalah array dengan panjang tetap.  Ketika nilai maksimum ( <code>cap</code> ) tercapai, array baru dengan nilai ganda dialokasikan, memori disalin dari potongan lama ke yang baru, dan array lama dibuang. <br><br>  Saya sering melihat kode seperti ini di mana irisan dengan kapasitas batas nol dialokasikan jika kapasitas irisan diketahui sebelumnya: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> userIDs []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, bar := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> rsp.Users { userIDs = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(userIDs, bar.ID) }</code> </pre> <br>  Dalam hal ini, irisan dimulai dengan nol ukuran <code>len</code> dan batas kapasitas batas nol.  Setelah menerima jawaban, kami menambahkan elemen ke slice, pada saat yang sama kami mencapai kapasitas batas: array basis baru dipilih, di mana <code>cap</code> dua kali lipat, dan data disalin ke sana.  Jika kita mendapatkan 8 elemen dalam jawaban, ini mengarah ke 5 redistribusi. <br><br>  Metode berikut ini jauh lebih efisien: <br><br><pre> <code class="go hljs">userIDs := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(rsp.Users)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, bar := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> rsp.Users { userIDs = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(userIDs, bar.ID) }</code> </pre> <br>  Di sini kami secara eksplisit mengalokasikan kapasitas untuk irisan menggunakan make.  Sekarang kita dapat menambahkan data dengan aman di sana, tanpa redistribusi dan penyalinan tambahan. <br><br>  Jika Anda tidak tahu berapa banyak memori yang dialokasikan, karena kapasitasnya dinamis atau kemudian dihitung dalam program, ukur distribusi akhir ukuran slice setelah program berjalan.  Saya biasanya mengambil persentil ke-90 atau ke-99 dan mengkode nilai dalam program.  Dalam kasus di mana CPU lebih mahal daripada RAM untuk Anda, tetapkan nilai ini lebih tinggi dari yang Anda anggap perlu. <br><br>  Tip juga berlaku untuk map: <code>make(map[string]string, len(foo))</code> akan mengalokasikan memori yang cukup untuk menghindari redistribusi. <br><br>  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> tentang cara kerja irisan. <br><br><h3>  Gunakan metode untuk mentransfer irisan byte </h3><br>  Saat menggunakan paket, gunakan metode yang memungkinkan transmisi byte byte: metode ini biasanya memberikan kontrol lebih besar atas distribusi. <br><br>  Contoh yang baik adalah membandingkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">time.Format</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">time.AppendFormat</a> .  Yang pertama mengembalikan string.  Di bawah tenda, ini memilih sepotong byte baru dan memanggil <code>time.AppendFormat</code> .  Yang kedua mengambil buffer byte, menulis representasi waktu yang diformat, dan mengembalikan sepotong byte yang diperluas.  Ini sering ditemukan dalam paket lain di perpustakaan standar: lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">strconv.AppendFloat</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bytes.NewBuffer</a> . <br><br>  Mengapa ini meningkatkan produktivitas?  Nah, sekarang Anda bisa meneruskan irisan byte yang Anda terima dari <code>sync.Pool</code> , alih-alih mengalokasikan buffer baru setiap kali.  Atau Anda dapat meningkatkan ukuran buffer awal ke nilai yang lebih cocok untuk program Anda untuk mengurangi jumlah salinan slice yang diulang. <br><br><h1>  Ringkasan </h1><br>  Anda dapat menerapkan semua metode ini ke basis kode Anda.  Seiring waktu, Anda akan membangun model mental untuk alasan tentang kinerja dalam program Go.  Ini akan sangat membantu dalam desain mereka. <br><br>  Tapi gunakan itu tergantung situasinya.  Ini adalah nasihat, bukan Injil.  Ukur dan periksa semuanya dengan tolok ukur. <br><br>  Dan tahu kapan harus berhenti.  Meningkatkan produktivitas adalah latihan yang baik: tugas itu menarik, dan hasilnya langsung terlihat.  Namun, manfaat peningkatan produktivitas tergantung pada situasi.  Jika layanan Anda memberikan jawaban dalam 10 ms, dan penundaan jaringan adalah 90 ms, Anda mungkin sebaiknya tidak mencoba mengurangi 10 ms hingga 5 ms ini: Anda masih memiliki 95 ms.  Bahkan jika Anda mengoptimalkan layanan hingga maksimal 1 ms, total penundaan masih menjadi 91 ms.  Mungkin makan ikan yang lebih besar. <br><br>  Optimalkan dengan bijak! <br><br><h3>  Referensi </h3><br>  Jika Anda ingin informasi lebih lanjut, berikut adalah sumber inspirasi yang hebat: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bahaya Lebih Lanjut dari Tumpukan Besar di Jalan</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Efisiensi Distribusi dalam Layanan Go Kinerja Tinggi</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana saya berhenti khawatir dan jatuh cinta pada banyak orang</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bytes. Buffer, saya pikir kamu adalah teman saya</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gc buruk tetapi Anda seharusnya tidak merasa buruk</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembuatan profil dan pengoptimalan di Go</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penggunaan Memori di CockroachDB</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghilangkan Penundaan GC di Tumpukan Besar</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tujuh langkah untuk mempercepat seratus kali lipat</a> </li></ul></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457004/">https://habr.com/ru/post/id457004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456982/index.html">Sistem navigasi radio yang digunakan oleh pesawat terbang untuk pendaratan yang aman tidak aman dan cenderung retak</a></li>
<li><a href="../id456984/index.html">Kurangi konsumsi energi di pusat data - chip foton baru akan membantu</a></li>
<li><a href="../id456986/index.html">Durov tidak ada hubungannya dengan TON</a></li>
<li><a href="../id456988/index.html">Kisah seorang pengacara IT. Bisnis outsourcing kehidupan. Bagian 3</a></li>
<li><a href="../id456998/index.html">Kisah Lengkap Harold dan Bob Herbert Tree in Fallout</a></li>
<li><a href="../id457008/index.html">Antiquities: Three Palm Stories</a></li>
<li><a href="../id457010/index.html">Kenapa saya tidak menggunakan komponen web</a></li>
<li><a href="../id457016/index.html">Metodologi BEM sebagai contoh stiker dalam OpenCart</a></li>
<li><a href="../id457018/index.html">Lebih dari kompleksitas</a></li>
<li><a href="../id457020/index.html">Pilihan sumber akademik dan sains-pop</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>