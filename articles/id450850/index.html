<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📚 🛠️ 📮 Menuju masa depan yang lebih cerah untuk kompiler pintar 🧓🏼 😡 🍽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sekarang topik pembelajaran mesin dan kecerdasan buatan sangat populer, pada saat ini, berkat kekuatan komputer, ide dan algoritma yang telah muncul s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menuju masa depan yang lebih cerah untuk kompiler pintar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450850/">  Sekarang topik pembelajaran mesin dan kecerdasan buatan sangat populer, pada saat ini, berkat kekuatan komputer, ide dan algoritma yang telah muncul sejak lama dapat diimplementasikan dan ditingkatkan secara signifikan.  Hampir setiap hari Anda dapat membaca berita tentang pencapaian baru di bidang ini.  Selain itu, pembelajaran mesin digunakan di hampir semua bidang ... dan pengembangan penyusun tidak terkecuali.  Namun, area ini cukup spesifik dan memiliki karakteristik dan kesulitan tersendiri dalam membuat kompiler pintar.  Pada saat yang sama, ada banyak studi tentang topik ini dan mereka telah dilakukan untuk waktu yang lama baik di lingkungan akademik dan di dalam berbagai perusahaan. <br><br>  Di mana tepatnya mencoba menerapkan metode pembelajaran mesin saat membuat kompiler?  Dan mengapa sejauh ini kompiler "pintar" belum menjadi bagian dari kehidupan sehari-hari pengembang? <br><a name="habracut"></a><br><h2>  Opsi untuk menggunakan pembelajaran mesin dalam pengembangan kompiler </h2><br>  Mari kita mulai dengan pertanyaan pertama tentang penggunaan spesifik pembelajaran mesin.  Faktanya adalah bahwa kompiler modern adalah sistem yang kompleks dengan sejumlah besar optimisasi yang memungkinkan Anda untuk mendapatkan kode mesin yang lebih efisien.  Namun, beberapa optimasi dan tugas lain, seperti alokasi register, adalah NP-complete, yang memaksa pengembang kompiler untuk menggunakan algoritma heuristik.  Akibatnya, sebagian besar kompiler memiliki sejumlah besar bendera pengoptimalan yang memungkinkan Anda mengonfigurasi heuristik yang digunakan.  Dalam LLVM, hampir setiap bagian memiliki beberapa opsi tersembunyi yang dapat mempengaruhi operasinya, mereka dapat digunakan baik menggunakan flag -mllvm saat memanggil dentang, atau dalam utilitas opt.  Namun, berbagai flag ini tersembunyi di balik opsi yang jauh lebih sering digunakan, yang berisi banyak pengaturan sekaligus dan biasanya disebut level optimisasi.  Untuk kompiler C / C ++, ini dikenal paling -O1, -O2, -O3 untuk mengoptimalkan runtime dan -Os untuk mengoptimalkan ukuran kode.  Namun, sayangnya, kode optimal tidak selalu hasilnya (pakar assembler dapat menulis ulang kode yang dihasilkan dengan cara terbaik), banyak tergantung pada kode sumber dalam bahasa tingkat tinggi, arsitektur prosesor, fitur bahasa, dll. <br><br>  Terlepas dari kenyataan bahwa saat ini prosesor modern memiliki RAM yang cukup dan kinerja yang cukup tinggi, masih ada area di mana kinerja aplikasi, efisiensi energi dan ukuran kode mesin memainkan peran kunci.  Contoh-contoh bidang tersebut meliputi pengembangan perangkat lunak untuk sistem tertanam dengan jumlah RAM terbatas, pemrosesan sinyal digital, sistem waktu-nyata, dll.  Oleh karena itu, dalam kasus di mana Anda perlu mendapatkan kode mesin berkinerja tinggi untuk sistem yang cukup besar, pemilihan opsi kompilasi yang benar yang memberikan hasil terbaik adalah tugas penting.  Selain itu, masalah terburuk-run-time ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WCET</a> ) belum hilang ketika sistem real-time perlu menghitung dan meminimalkan, jika mungkin, waktu pelaksanaan tugas tertentu pada platform.  Hingga saat ini, programmer yang bekerja dengan sistem dengan jumlah RAM terbatas tidak dapat sepenuhnya bergantung pada kompiler, dan seringkali secara mandiri mengoptimalkan kode mesin yang dihasilkan. <br><br>  Sulit bagi seseorang untuk memprediksi optimasi mana yang akan memberikan hasil yang baik dan yang dapat mengarah pada regresi, karena untuk ini Anda harus memiliki pemahaman yang baik tentang seluk-beluk algoritma heuristik yang digunakan, pengetahuan yang baik tentang struktur dan bagian-bagian dari kompiler yang digunakan, dan juga sepenuhnya mengetahui kode program yang dikompilasi, yang Proses pengembangan aplikasi saat ini tidak mungkin.  Akibatnya, mengidentifikasi opsi kompilasi terbaik untuk suatu program bagi seseorang menjadi tugas pencarian lengkap berbagai kombinasi opsi dan pengukuran kinerja dan ukuran kode. <br><br>  Selain itu, ada batasan dalam bentuk unit kompilasi yang dengannya Anda dapat bekerja dan untuk itu Anda dapat memilih opsi.  Jadi untuk C / C ++, ini masih merupakan file yang dapat berisi banyak kode, yang, mungkin, akan bermanfaat untuk dioptimalkan dengan cara yang berbeda, tetapi saat ini ini tidak mungkin.  Oleh karena itu, kompiler "pintar" yang dapat melatih dan kemudian mendapatkan kode yang dioptimalkan dengan baik untuk berbagai kasus adalah impian bagi beberapa pengembang. <br><br><h2>  Penelitian dan Solusi yang Ada </h2><br>  Secara alami, masalah pemilihan opsi kompilasi otomatis telah menarik bagi para peneliti selama bertahun-tahun.  Salah satu proyek yang paling terkenal adalah pengembangan G. Fursin dan peneliti dari tim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MILEPOST GCC-nya</a> , yang merupakan versi dari kompiler gcc yang dapat dengan sendirinya memilih lintasan optimasi berdasarkan pelatihan sebelumnya pada sampel data yang diperoleh.  Dalam karya ini, kami menggunakan satu set 55 karakteristik untuk menyelesaikan masalah dan model yang agak sederhana berdasarkan pada gagasan untuk mendistribusikan solusi yang baik berdasarkan pada algoritma K dari tetangga terdekat.  Perkembangan inilah yang menunjukkan bahwa tuning optimisasi pass dapat menghasilkan kode yang dua kali lebih cepat dari kode yang diperoleh menggunakan opsi optimalisasi maksimum standar -O3. <br><br>  Ada juga studi oleh G. Pekhimenko dan A.D.  Brown untuk TPO IBM ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Toronto Portable Optimizer</a> ).  Tugas utama mereka adalah memilih nilai heuristik yang dapat dipilih untuk optimisasi dan serangkaian transformasi kode.  Untuk implementasi, regresi logistik digunakan, yang memungkinkan untuk membuat pengaturan denda yang efektif untuk pelatihan yang lebih cepat.  Pengklasifikasi dibangun di Matlab.  Probabilitas penggunaan dihitung untuk setiap pass, dan digunakan jika lebih dari 50%.  Sebagai hasil dari karakteristik yang mereka coba kurangi dalam penelitian ini, itu adalah waktu kompilasi statis. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">A.Askhari</a> terlibat dalam pemilihan langsung opsi kompilasi untuk seluruh program untuk meminimalkan waktu eksekusi, waktu kompilasi, ukuran kode, dan konsumsi daya.  Untuk ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kerangka Kerja cTuning</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kerangka Kerja</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kolektif yang</a> dikembangkan oleh G. Fursin dan A. Lokhmotov (juga dikembangkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> ) digunakan. <br><br>  Ada juga studi oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">M. Stephenson dan S. Amarasinge dalam</a> memilih optimasi untuk algoritma tertentu yang sangat penting (alokasi register, DATA PREFETCHING, HYPERBLOCK FORMATION).  Untuk setiap fungsi, karakteristiknya sendiri digunakan sesuai.  Untuk solusinya, digunakan algoritma genetika.  Pengujian produk yang dikembangkan dilakukan di Open Research Compiler (ORC). <br><br>  Ada juga proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MAGEEC</a> (Mesin Dipandu Energi Efisien Kompiler), yang tujuannya agak berbeda.  Infrastruktur yang dikembangkan menggunakan pembelajaran mesin untuk memilih optimasi yang diperlukan untuk menghasilkan kode dengan efisiensi energi maksimum untuk sistem komputasi kinerja tinggi.  MAGEEC dirancang untuk bekerja dengan gcc dan LLVM.  Kompiler ini adalah bagian dari proyek TSERO (Total Software Energy Reporting and Optimization) yang lebih besar. <br><br>  Salah satu penelitian yang berhubungan langsung dengan LLVM adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LLVMTuner</a> , produk perangkat lunak yang dikembangkan di University of Illinois oleh I. Chen dan W. Adwe.  Pada 2017, disajikan laporan yang menggambarkan hasil yang tersedia saat itu.  Dalam pekerjaan ini, kami mengoptimalkan siklus "panas" individual.  Kerangka kerja ini dirancang untuk konfigurasi otomatis program besar.  LLVMTuner berjalan pada middleware LLVM IR, menggunakan profil untuk mengidentifikasi loop panas, dan kemudian secara otomatis menyesuaikan heuristik untuk mereka.  Fokusnya adalah pada siklus tingkat atas.  Siklus yang dipilih dan fungsi panggilan apa pun ditransfer ke modul terpisah, yang selanjutnya akan dioptimalkan.  Solusi ini memungkinkan Anda untuk mendapatkan peningkatan kinerja pada program besar. <br><br><h2>  Masalah yang ada </h2><br>  Namun, tidak ada kompiler yang digunakan secara luas yang secara mandiri menyesuaikan heuristik untuk mengoptimalkan lintasan.  Apa masalahnya?  Seperti yang Anda ketahui, efektivitas metode pembelajaran mesin dan kualitas model yang diperoleh tergantung pada pilihan fitur yang benar dan kualitas data untuk pelatihan (meskipun ada algoritma yang kurang sensitif terhadap data "berisik").  Tanpa mengetahui struktur dan algoritma yang digunakan dalam kompiler, tidaklah mudah untuk memilih serangkaian karakteristik yang lengkap dan cukup untuk pelatihan, meskipun ada yang cukup jelas dan logis, misalnya, ukuran siklus, jumlah keluar dari siklus, dll.  Oleh karena itu, sulit untuk mengembangkan solusi universal yang cocok untuk banyak kompiler sekaligus, dan itu bukan fakta bahwa secara umum dimungkinkan.  Selain itu, kemungkinan ini tidak diperlukan. <br><br>  Karena pengembangan kompiler harus efisien dan layak dalam waktu yang cukup singkat, wajar bahwa bahkan perusahaan besar mengembangkan kompiler industrinya berdasarkan pada solusi siap pakai.  Sebagian besar solusi modern dapat dibagi menjadi dua kategori: berjalan pada mesin virtual, misalnya, kompiler JVM - JIT, dan kompiler berdasarkan LLVM, sistem yang mengimplementasikan mesin virtual dengan instruksi seperti RISC - kompiler statis dan dinamis.  Tentu saja, masih ada solusi perusahaan sendiri, tetapi mereka menjadi kurang kompetitif karena kurangnya komunitas besar yang terlibat dalam pengembangan teknologi yang digunakan di dalamnya.  Akibatnya, saat ini banyak perusahaan besar seperti Google, Apple, Adobe, ARM menggunakan LLVM untuk mengembangkan solusi mereka sendiri.  Tentu saja, gcc tetap merupakan kompiler utama untuk C / C ++, solusi lain ada untuk bahasa lain, tetapi bagaimanapun, jika, misalnya, solusi untuk LLVM ditemukan, ini sudah akan mencakup bagian yang layak dari kompiler yang ada saat ini. <br><br>  Pengumpulan karakteristik untuk pelatihan juga menjadi masalah besar, karena multi-pass compiler sangat mengubah representasi menengah, dan karakteristik yang dikumpulkan pada tahap awal tidak cukup relevan untuk optimisasi kompiler kemudian, karakteristik ini dapat berubah dengan probabilitas tinggi.  Karakteristik, di samping itu, masuk akal untuk mengumpulkan secara terpisah untuk berbagai jenis elemen: modul, siklus, blok dasar, karena optimasi biasanya dirancang untuk mengubah jenis elemen tertentu, dalam LLVM, bahkan menurut kriteria ini, bagian-bagiannya dibagi. <br><br>  Tetapi, pertama-tama, muncul pertanyaan tentang mengidentifikasi unsur-unsur yang perlu dikumpulkan dari karakteristik.  Ada banyak cara untuk menghitung pengidentifikasi unik yang dapat disimpan selama semua optimasi, misalnya: <br><br><ul><li>  Hash ujung depan berbasis AST </li><li>  nomor unik yang ditugaskan di parsing front-end </li><li>  Angka 64-bit yang dihasilkan atas dasar busur CFG (control-flow graph) menggunakan checksum (mirip dengan PGO (Profile-guided optimization) di LLVM) </li></ul><br>  Namun, Anda perlu menyimpan pengidentifikasi ini dengan benar selama transformasi, ketika elemen-elemen dapat bergabung menjadi satu, membelah, membuat yang baru dan menghapus yang asli, yang bukan tugas yang mudah. <br><br>  Kedua, pada prinsipnya sulit untuk mengevaluasi batas siklus sumber, blok dasar, dll. Yang tertulis dalam kode sumber, pada IR yang sudah dikonversi.  Misalnya, karena pembuatan kode mesin multi-tahap yang diadopsi oleh LLVM, informasi tentang unit dasar mesin hilang setelah pembuatan kode berdasarkan instruksi mesin di AsmPrinter.  Dan dengan demikian, informasi tentang pengidentifikasi blok dasar dan siklus juga hilang, yang, misalnya, offset dari awal fungsi diukur, oleh karena itu, dengan metode ini, hanya pada tahap menghasilkan kode mesin dapat offset diperoleh dalam bentuk jumlah byte.  Namun, pada tahap selanjutnya menghasilkan kode mesin ketika bekerja dengan fragmen mesin, berbagai keberpihakan dapat ditambahkan, yang mengubah ukuran instruksi yang diperhitungkan sebelumnya, dan instruksi nop juga ditambahkan.  Karena itu, untuk blok dasar di akhir fungsi besar, kesalahan perhitungan bisa sangat besar, hingga pergeseran total ke blok / siklus lain.  Dan meskipun beberapa transformasi pada tahap selanjutnya dapat dilacak dan diperhitungkan, ini tidak akan memberikan jaminan untuk akurasi pengukuran, karena ukuran instruksi dapat bervariasi hingga tautan. <br><br><img src="https://habrastorage.org/webt/af/xw/2-/afxw2-jziob0rhikr1nqaw_wmai.png"><br><br>  Seperti yang Anda lihat, bahkan koleksi atribut berdasarkan pelatihan yang dibutuhkan cukup rumit dan memakan waktu, dan yang di masa depan kemungkinan akan menjadi set input untuk model yang terlatih untuk pengambilan keputusan.  Dan tidak ada solusi yang jelas untuk masalah ini, yang menyulitkan pekerjaan langsung yang terkait dengan pembelajaran mesin dan menarik sejumlah besar orang karena kurangnya dataset yang memadai.  Nah, kesulitan khas dalam menemukan solusi untuk masalah pembelajaran mesin, memilih model, metode, menentukan subset atribut yang benar dengan sejumlah besar dari mereka, dll.  ada dalam hal ini.  Hampir setiap orang yang menemukan pembelajaran mesin mengetahui tentang mereka dan, mungkin, sesuatu yang unik dan spesifik untuk penyusun tidak ada di sini. <br><br>  Sulit diprediksi kapan kompiler pintar akan menyebar luas.  Kompiler modern juga memiliki masalah lain yang tidak mungkin diselesaikan dengan metode ini, dan yang saat ini mungkin lebih diprioritaskan.  Namun, kompiler telah menjadi jauh lebih cerdas daripada mereka pada awal penampilan mereka, dan proses ini akan terus berlanjut, meskipun mungkin agak lambat dari yang diinginkan kebanyakan pengembang. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450850/">https://habr.com/ru/post/id450850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450836/index.html">Di rel di belakang awan: cara mencuci kaca di gedung pencakar langit</a></li>
<li><a href="../id450840/index.html">Senter terakhir sudah lelah atau Akankah flicker menyelamatkan Belarus (upd. Spinner?)</a></li>
<li><a href="../id450844/index.html">Pengantar Pemetaan Contoh</a></li>
<li><a href="../id450846/index.html">Keajaiban kemasan dari Microsoft: kernel Linux di Windows 10 dan mesin IE di dalam Chromium Edge</a></li>
<li><a href="../id450848/index.html">Tentang fosfor kuning dan sifat panik manusia</a></li>
<li><a href="../id450854/index.html">Pengalaman dalam mengembangkan aset Persatuan untuk menemukan jalur di ruang 3D</a></li>
<li><a href="../id450858/index.html">Pertemuan Open Source Networking - sekarang di Yandex.Cloud # 3.2019</a></li>
<li><a href="../id450860/index.html">Smart socket REDMOND SkyPort 100S</a></li>
<li><a href="../id450862/index.html">@Pythonetc April 2019</a></li>
<li><a href="../id450864/index.html">Kiat dan trik dari saluran Telegram saya @pythonetc, April 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>