<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèè üîû üßñ [DotNetBook] Eventos de exce√ß√£o e como obter StackOverflow e ExecutionEngineException do zero ü•ò üö∞ üíÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eventos de exce√ß√£o 


 No caso geral, nem sempre sabemos sobre as exce√ß√µes que ocorrer√£o em nossos programas porque quase sempre usamos algo que √© esc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[DotNetBook] Eventos de exce√ß√£o e como obter StackOverflow e ExecutionEngineException do zero</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/419929/"><img width="350" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png" align="left"><br><h2 id="sobytiya-ob-isklyuchitelnyh-situaciyah">  Eventos de exce√ß√£o </h2><br><p> No caso geral, nem sempre sabemos sobre as exce√ß√µes que ocorrer√£o em nossos programas porque quase sempre usamos algo que √© escrito por outras pessoas e que est√° em outros subsistemas e bibliotecas.  N√£o s√≥ pode haver uma variedade de situa√ß√µes em seu pr√≥prio c√≥digo, no c√≥digo de outras bibliotecas, como tamb√©m existem muitos problemas associados √† execu√ß√£o de c√≥digo em dom√≠nios isolados.  E apenas neste caso, seria extremamente √∫til poder receber dados sobre a opera√ß√£o de c√≥digo isolado.  Afinal, uma situa√ß√£o pode ser bastante real quando o c√≥digo de terceiros intercepta todos os erros sem exce√ß√£o, eliminando sua <code>fault</code> bloco: </p><br><pre> <code class="plaintext hljs">try { // ... } catch { // do nothing, just to make code call more safe }</code> </pre> <br><p>  Em tal situa√ß√£o, pode ser que a execu√ß√£o do c√≥digo n√£o seja mais t√£o segura quanto parece, mas n√£o temos mensagens sobre problemas.  A segunda op√ß√£o √© quando o aplicativo suprime alguma exce√ß√£o, mesmo legal.  E o resultado - a seguinte exce√ß√£o em um local aleat√≥rio far√° com que o aplicativo falhe no futuro devido a um erro aparentemente aleat√≥rio.  Aqui eu gostaria de ter uma id√©ia de qual era o pano de fundo desse erro.  Qual √© o curso dos eventos que levaram a essa situa√ß√£o.  E uma maneira de tornar isso poss√≠vel √© usar eventos adicionais relacionados a situa√ß√µes excepcionais: <code>AppDomain.FirstChanceException</code> e <code>AppDomain.UnhandledException</code> . </p><br><blockquote><h3>  Nota </h3><br>  O cap√≠tulo publicado em Habr√© n√£o √© atualizado e, provavelmente, j√° est√° um pouco desatualizado.  E, portanto, consulte o original para obter textos mais recentes: <br><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  Livro do CLR: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub, sum√°rio</a> </li><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  Livro do CLR: <a href="">GitHub, cap√≠tulo</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Livros da vers√£o 0.5.2, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p><a name="habracut"></a><br><p>  De fato, quando voc√™ "lan√ßa uma exce√ß√£o", o m√©todo usual de algum subsistema <code>Throw</code> interno √© chamado, que por si s√≥ executa as seguintes opera√ß√µes: </p><br><ul><li>  Lan√ßa <code>AppDomain.FirstChanceException</code> </li><li>  Procura por filtros correspondentes na cadeia de manipuladores </li><li>  Faz com que o manipulador pr√©-role a pilha para o quadro desejado. </li><li>  Se nenhum manipulador foi encontrado, um <code>AppDomain.UnhandledException</code> √© <code>AppDomain.UnhandledException</code> , travando o encadeamento no qual a exce√ß√£o ocorreu. </li></ul><br><p>  Deve-se fazer uma reserva imediatamente ao responder a uma pergunta que atormentou muitas mentes: √© poss√≠vel, de alguma forma, cancelar a exce√ß√£o que ocorreu no c√≥digo n√£o controlado que √© executado no dom√≠nio isolado sem, assim, interromper o segmento em que essa exce√ß√£o foi lan√ßada?  A resposta √© concisa e simples: n√£o.  Se uma exce√ß√£o n√£o for detectada em toda a gama de m√©todos chamados, ela n√£o poder√° ser tratada em princ√≠pio.  Caso contr√°rio, surge uma situa√ß√£o estranha: se usarmos uma <code>AppDomain.FirstChanceException</code> manipular (algum tipo de <code>catch</code> sint√©tica) a exce√ß√£o, em que quadro a pilha de threads deve reverter?  Como definir isso como parte das regras do .NET CLR?  De jeito nenhum.  Simplesmente n√£o √© poss√≠vel.  A √∫nica coisa que podemos fazer √© registrar as informa√ß√µes recebidas para pesquisas futuras. </p><br><p>  A segunda coisa a falar sobre "em terra" √© por que esses eventos foram introduzidos n√£o no <code>Thread</code> , mas no <code>AppDomain</code> .  Afinal, se voc√™ seguir a l√≥gica, surgem exce√ß√µes onde?  No fluxo de execu√ß√£o de comandos.  I.e.  na verdade <code>Thread</code> .  Ent√£o, por que o dom√≠nio tem problemas?  A resposta √© muito simples: para quais situa√ß√µes foram <code>AppDomain.UnhandledException</code> e <code>AppDomain.UnhandledException</code> ?  Entre outras coisas - para criar caixas de areia para plugins.  I.e.  para situa√ß√µes em que existe um determinado <code>AppDomain</code> configurado para o PartialTrust.  Tudo pode acontecer dentro deste AppDomain: os threads podem ser criados l√° a qualquer momento ou os existentes no ThreadPool podem ser usados.  Acontece que, estando fora deste processo (n√£o escrevemos esse c√≥digo), n√£o podemos assinar os eventos de fluxos internos.  S√≥ porque n√£o temos id√©ia de quais fluxos foram criados l√°.  Mas temos a garantia de ter um <code>AppDomain</code> que organize a sandbox e o link para o qual temos. </p><br><p>  Portanto, de fato, recebemos dois eventos regionais: algo aconteceu que n√£o era suposto ( <code>FirstChanceExecption</code> ) e "tudo est√° ruim", ningu√©m lidou com a exce√ß√£o: n√£o foi fornecido.  Portanto, o fluxo de execu√ß√£o de comando n√£o faz sentido e ( <code>Thread</code> ) ser√° enviado. </p><br><p>  O que pode ser obtido com esses eventos e por que √© ruim que os desenvolvedores ignorem esses eventos? </p><br><h3 id="appdomainfirstchanceexception">  AppDomain.FirstChanceException </h3><br><p>  Este evento √© inerentemente puramente informativo por natureza e n√£o pode ser "processado".  Sua tarefa √© notific√°-lo de que ocorreu uma exce√ß√£o nesse dom√≠nio e ela come√ßar√° a ser processada pelo c√≥digo do aplicativo ap√≥s o processamento do evento.  Sua execu√ß√£o possui alguns recursos que devem ser lembrados durante o design do processador. </p><br><p>  Mas vamos primeiro ver um exemplo sint√©tico simples de seu processamento: </p><br><pre> <code class="plaintext hljs">void Main() { var counter = 0; AppDomain.CurrentDomain.FirstChanceException += (_, args) =&gt; { Console.WriteLine(args.Exception.Message); if(++counter == 1) { throw new ArgumentOutOfRangeException(); } }; throw new Exception("Hello!"); }</code> </pre> <br><p>  O que √© not√°vel nesse c√≥digo?  Sempre que algum c√≥digo lan√ßa uma exce√ß√£o, a primeira coisa que acontece √© registr√°-lo no console.  I.e.  mesmo que voc√™ esque√ßa ou n√£o consiga imaginar lidar com algum tipo de exce√ß√£o, ele ainda aparecer√° no log de eventos que voc√™ est√° organizando.  A segunda √© uma condi√ß√£o um tanto estranha para gerar uma exce√ß√£o interna.  O problema √© que, dentro do manipulador <code>FirstChanceException</code> voc√™ n√£o pode simplesmente lan√ßar e lan√ßar mais uma exce√ß√£o.  Em vez disso, mesmo isso: dentro do manipulador FirstChanceException, voc√™ <em>n√£o pode</em> lan√ßar pelo menos nenhuma exce√ß√£o.  Se voc√™ fizer isso, h√° dois eventos poss√≠veis.  Na primeira, se n√£o houvesse uma <code>if(++counter == 1)</code> , <code>FirstChanceException</code> uma <code>FirstChanceException</code> infinita para uma nova <code>ArgumentOutOfRangeException</code> .  O que isso significa?  Isso significa que, em um certo est√°gio, <code>StackOverflowException</code> uma <code>StackOverflowException</code> : <code>throw new Exception("Hello!")</code> <code>FirstChanceException</code> m√©todo CLR Throw, que lan√ßa <code>FirstChanceException</code> , que lan√ßa <code>Throw</code> j√° para <code>ArgumentOutOfRangeException</code> e depois se repete.  A segunda op√ß√£o - nos defendemos pela profundidade da recurs√£o usando a condi√ß√£o de <code>counter</code> .  I.e.  neste caso, lan√ßamos uma exce√ß√£o apenas uma vez.  O resultado √© mais do que inesperado: recebemos uma exce√ß√£o que realmente funciona dentro da instru√ß√£o <code>Throw</code> .  E o que √© mais adequado para esse tipo de erro?  De acordo com o ECMA-335, se uma instru√ß√£o foi lan√ßada em uma exce√ß√£o, uma <code>ExecutionEngineException</code> deve ser lan√ßada!  Mas n√£o somos capazes de lidar com essa situa√ß√£o excepcional.  Isso leva a uma falha completa do aplicativo.  Quais s√£o as op√ß√µes de processamento seguro que temos? </p><br><p>  A primeira coisa que vem √† mente √© definir um bloco <code>try-catch</code> em todo o c√≥digo do manipulador <code>FirstChanceException</code> : </p><br><pre> <code class="plaintext hljs">void Main() { var fceStarted = false; var sync = new object(); EventHandler&lt;FirstChanceExceptionEventArgs&gt; handler; handler = new EventHandler&lt;FirstChanceExceptionEventArgs&gt;((_, args) =&gt; { lock (sync) { if (fceStarted) { //     - ,        -      , //   try  . Console.WriteLine($"FirstChanceException inside FirstChanceException ({args.Exception.GetType().FullName})"); return; } fceStarted = true; try { //     . ,   Console.WriteLine(args.Exception.Message); throw new ArgumentOutOfRangeException(); } catch (Exception exception) { //       Console.WriteLine("Success"); } finally { fceStarted = false; } } }); AppDomain.CurrentDomain.FirstChanceException += handler; try { throw new Exception("Hello!"); } finally { AppDomain.CurrentDomain.FirstChanceException -= handler; } } OUTPUT: Hello! Specified argument was out of the range of valid values. FirstChanceException inside FirstChanceException (System.ArgumentOutOfRangeException) Success !Exception: Hello!</code> </pre> <br><p>  I.e.  por um lado, temos o c√≥digo para manipular o evento <code>FirstChanceException</code> e, por outro, temos c√≥digo adicional para manipular exce√ß√µes no pr√≥prio <code>FirstChanceException</code> .  No entanto, as t√©cnicas de log para as duas situa√ß√µes devem ser diferentes.  Se o log de processamento de eventos puder ocorrer como voc√™ desejar, o processamento de erros l√≥gicos de processamento <code>FirstChanceException</code> dever√° ocorrer sem exce√ß√£o em princ√≠pio.  A segunda coisa que voc√™ provavelmente notou √© a sincroniza√ß√£o entre os threads.  Isso pode levantar a quest√£o: por que est√° aqui se alguma exce√ß√£o √© lan√ßada em qualquer thread, o que significa que <code>FirstChanceException</code> deve ser seguro para threads.  No entanto, nem tudo √© t√£o alegre.  <code>FirstChanceException</code> que temos no AppDomain.  E isso significa que isso ocorre para qualquer thread iniciado em um dom√≠nio espec√≠fico.  I.e.  se tivermos um dom√≠nio no qual v√°rios threads forem iniciados, <code>FirstChanceException</code> poder√° ser paralelo.  E isso significa que precisamos nos proteger de alguma forma com a sincroniza√ß√£o: por exemplo, usando <code>lock</code> . </p><br><p>  A segunda maneira √© tentar desviar o processamento para um thread vizinho que pertence a um dom√≠nio de aplicativo diferente.  No entanto, vale ressaltar que, com essa implementa√ß√£o, devemos criar um dom√≠nio dedicado especificamente para esta tarefa, para que n√£o funcione, para que outros fluxos que estejam funcionando possam colocar esse dom√≠nio: </p><br><pre> <code class="plaintext hljs">static void Main() { using (ApplicationLogger.Go(AppDomain.CurrentDomain)) { throw new Exception("Hello!"); } } public class ApplicationLogger : MarshalByRefObject { ConcurrentQueue&lt;Exception&gt; queue = new ConcurrentQueue&lt;Exception&gt;(); CancellationTokenSource cancellation; ManualResetEvent @event; public void LogFCE(Exception message) { queue.Enqueue(message); } private void StartThread() { cancellation = new CancellationTokenSource(); @event = new ManualResetEvent(false); var thread = new Thread(() =&gt; { while (!cancellation.IsCancellationRequested) { if (queue.TryDequeue(out var exception)) { Console.WriteLine(exception.Message); } Thread.Yield(); } @event.Set(); }); thread.Start(); } private void StopAndWait() { cancellation.Cancel(); @event.WaitOne(); } public static IDisposable Go(AppDomain observable) { var dom = AppDomain.CreateDomain("ApplicationLogger", null, new AppDomainSetup { ApplicationBase = AppDomain.CurrentDomain.BaseDirectory, }); var proxy = (ApplicationLogger)dom.CreateInstanceAndUnwrap(typeof(ApplicationLogger).Assembly.FullName, typeof(ApplicationLogger).FullName); proxy.StartThread(); var subscription = new EventHandler&lt;FirstChanceExceptionEventArgs&gt;((_, args) =&gt; { proxy.LogFCE(args.Exception); }); observable.FirstChanceException += subscription; return new Subscription(() =&gt; { observable.FirstChanceException -= subscription; proxy.StopAndWait(); }); } private class Subscription : IDisposable { Action act; public Subscription (Action act) { this.act = act; } public void Dispose() { act(); } } }</code> </pre> <br><p>  Nesse caso, manipular <code>FirstChanceException</code> √© o mais seguro poss√≠vel: no thread vizinho pertencente ao dom√≠nio vizinho.  Nesse caso, erros no processamento de uma mensagem n√£o podem interromper os fluxos de trabalho do aplicativo.  Al√©m disso, voc√™ pode ouvir separadamente a UnhandledException do dom√≠nio de log de mensagens: erros fatais durante o log n√£o derrubar√£o o aplicativo inteiro. </p><br><h3 id="appdomainunhandledexception">  AppDomain.UnhandledException </h3><br><p>  A segunda mensagem que podemos capturar e que lida com o tratamento de exce√ß√µes √© <code>AppDomain.UnhandledException</code> .  Essa mensagem √© uma p√©ssima not√≠cia para n√≥s, pois significa que n√£o havia ningu√©m que pudesse encontrar uma maneira de lidar com o erro em um determinado segmento.  Al√©m disso, se tal situa√ß√£o ocorreu, tudo o que podemos fazer √© "limpar" as consequ√™ncias de tal erro.  I.e.  de qualquer forma, para limpar os recursos pertencentes apenas a esse fluxo, se houver algum.  No entanto, uma situa√ß√£o ainda melhor √© lidar com exce√ß√µes enquanto estiver na raiz dos threads sem bloquear o thread.  I.e.  essencialmente colocar <code>try-catch</code> .  Vamos tentar considerar a adequa√ß√£o desse comportamento. </p><br><p>  Suponha que tenhamos uma biblioteca que precise criar threads e implementar algum tipo de l√≥gica nesses threads.  N√≥s, como usu√°rios desta biblioteca, estamos interessados ‚Äã‚Äãapenas em garantir chamadas √† API e em receber mensagens de erro.  Se a biblioteca travar fluxos sem notificar sobre isso, isso n√£o pode nos ajudar muito.  Al√©m disso, o colapso do fluxo levar√° a uma mensagem <code>AppDomain.UnhandledException</code> , na qual n√£o h√° informa√ß√µes sobre qual fluxo espec√≠fico fica do seu lado.  Se estamos falando sobre nosso c√≥digo, tamb√©m √© improv√°vel que um fluxo com falha seja √∫til para n√≥s.  De qualquer forma, n√£o atendi √† necessidade disso.  Nossa tarefa √© processar os erros corretamente, enviar informa√ß√µes sobre a ocorr√™ncia para o log de erros e finalizar o fluxo corretamente.  I.e.  envolva essencialmente o m√©todo com o qual o thread inicia no <code>try-catch</code> : </p><br><pre> <code class="plaintext hljs"> ThreadPool.QueueUserWorkitem(_ =&gt; { using(Disposables aggregator = ...){ try { // do work here, plus: aggregator.Add(subscriptions); aggregator.Add(dependantResources); } catch (Exception ex) { logger.Error(ex, "Unhandled exception"); } } });</code> </pre> <br><p>  Nesse esquema, obtemos o que precisamos: por um lado, n√£o romperemos o fluxo.  Por outro lado, limpe corretamente os recursos locais se eles foram criados.  Bem, no ap√™ndice - organizamos o registro do erro recebido.  Mas espere, voc√™ diz.  De alguma forma, voc√™ renunciou √† edi√ß√£o do evento <code>AppDomain.UnhandledException</code> .  Realmente n√£o √© necess√°rio?  √â necess√°rio.  Mas apenas para informar que esquecemos de envolver alguns threads no <code>try-catch</code> com toda a l√≥gica necess√°ria.  Com tudo: com registro e purifica√ß√£o de recursos.  Caso contr√°rio, ser√° completamente errado: capturar e extinguir todas as exce√ß√µes, como se elas n√£o estivessem presentes. </p><br><blockquote><h3>  Link para o livro inteiro </h3><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  Livro do CLR: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Livros da vers√£o 0.5.0, PDF: <a href="">Vers√£o do GitHub</a> </li></ul><br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt419929/">https://habr.com/ru/post/pt419929/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt419919/index.html">Controle de vers√£o dentro do SQL Server</a></li>
<li><a href="../pt419921/index.html">Como perder 10 milh√µes de pacotes por segundo</a></li>
<li><a href="../pt419923/index.html">Meu trabalho tempor√°rio, rel√≥gios da placa-m√£e</a></li>
<li><a href="../pt419925/index.html">Controle de vers√£o de arquivos individuais usando o GitHub Gist</a></li>
<li><a href="../pt419927/index.html">Exce√ß√µes [DotNetBook]: arquitetura de sistema de tipos</a></li>
<li><a href="../pt419931/index.html">[DotNetBook] Hora de hist√≥rias divertidas: situa√ß√µes excepcionalmente excepcionais</a></li>
<li><a href="../pt419933/index.html">Como fazer pesquisas de usu√°rios no Github usando Angular</a></li>
<li><a href="../pt419935/index.html">Exatamente uma vez N√ÉO √© exatamente o mesmo: an√°lise do artigo</a></li>
<li><a href="../pt419939/index.html">Como eu tornei a navega√ß√£o no React Native n√£o t√£o terr√≠vel</a></li>
<li><a href="../pt419941/index.html">Audiomania Office Photo Tour: Parte Um</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>