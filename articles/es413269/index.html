<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñïüèæ üßëüèø‚Äçü§ù‚ÄçüßëüèΩ üõÄüèª C√≥mo las m√°quinas analizan big data: una introducci√≥n a los algoritmos de agrupamiento üë©üèº‚Äçüç≥ üöà ü§öüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Traducci√≥n de c√≥mo las m√°quinas tienen sentido de Big Data: una introducci√≥n a los algoritmos de agrupamiento . 

 Echa un vistazo a la imagen de abaj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo las m√°quinas analizan big data: una introducci√≥n a los algoritmos de agrupamiento</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/413269/"><img src="https://habrastorage.org/webt/1t/cz/rt/1tczrtuly-qxcq8pwrfwgdubvqm.jpeg"><br><br>  <i>Traducci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥mo las m√°quinas tienen sentido de Big Data: una introducci√≥n a los algoritmos de agrupamiento</a> .</i> <br><br>  Echa un vistazo a la imagen de abajo.  Esta es una colecci√≥n de insectos (los caracoles no son insectos, pero no encontraremos fallas) de varias formas y tama√±os.  Ahora div√≠dalos en varios grupos seg√∫n el grado de similitud.  No hay trampa.  Comience agrupando ara√±as. <br><br><img src="https://habrastorage.org/webt/yh/jr/c_/yhjrc_z9obxthw3uymiywxkyehq.png"><br><a name="habracut"></a><br>  Terminado?  Aunque no hay una soluci√≥n "correcta" aqu√≠, debe haber dividido estas criaturas en cuatro <b>grupos</b> .  En un grupo hay ara√±as, en el segundo, un par de caracoles, en el tercero, mariposas, y en el cuarto, un tr√≠o de abejas y avispas. <br><br>  Bien hecho, ¬øverdad?  Probablemente podr√≠a hacer lo mismo si hubiera el doble de insectos en la imagen.  Y si tuviera mucho tiempo, o un ansia de entomolog√≠a, entonces probablemente habr√≠a agrupado cientos de insectos. <br><br>  Sin embargo, para una m√°quina, agrupar diez objetos en grupos significativos no es una tarea f√°cil.  Gracias a una rama tan compleja de las matem√°ticas como la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">combinatoria</a> , sabemos que 10 insectos se agrupan de 115,975 formas.  Y si hay 20 insectos, entonces el n√∫mero de opciones de agrupaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">superar√° los 50 billones</a> . <br><br>  Con un centenar de insectos, el n√∫mero de posibles soluciones ser√° mayor que el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">n√∫mero de part√≠culas elementales en el Universo conocido</a> .  Cuanto mas  Seg√∫n mis estimaciones, unos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">quinientos millones de billones de millones de veces m√°s</a> .  Resulta m√°s de <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuatro millones de billones de</a></b> soluciones de <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">google</a></b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øqu√© es google?</a> ).  Y esto es solo para cientos de objetos. <br><br>  Casi todas estas combinaciones no tendr√°n sentido.  A pesar de la cantidad inimaginable de soluciones, usted mismo encontr√≥ r√°pidamente una de las pocas formas √∫tiles de agrupamiento. <br><br>  Los humanos damos por sentado nuestra excelente capacidad para catalogar y comprender grandes cantidades de datos.  No importa si se trata de texto, im√°genes en la pantalla o una secuencia de objetos: las personas, en general, entienden de manera efectiva los datos que provienen del mundo circundante. <br><br>  Dado que un aspecto clave del desarrollo de IA y el aprendizaje autom√°tico es que las m√°quinas pueden comprender r√°pidamente grandes vol√∫menes de datos de entrada, ¬øc√≥mo puedo mejorar la eficiencia del trabajo?  En este art√≠culo, consideraremos tres algoritmos de agrupamiento con los que las m√°quinas pueden comprender r√°pidamente grandes cantidades de datos.  Esta lista est√° lejos de ser completa, hay otros algoritmos, pero ya es bastante posible comenzar con ella. <br><br>  Para cada algoritmo, describir√© cu√°ndo se puede usar, c√≥mo funciona y tambi√©n dar√© un ejemplo con an√°lisis paso a paso.  Creo que para una comprensi√≥n real del algoritmo, debe repetir su trabajo usted mismo.  Si est√° <b>realmente interesado</b> , se dar√° cuenta de que es mejor ejecutar algoritmos en papel.  Acto, nadie te va a culpar! <br><br><img src="https://habrastorage.org/webt/6g/yv/nu/6gyvnuxigsioglh_xamfblafeua.png"><br>  <i>Tres grupos sospechosamente limpios con k = 3</i> <br><br><h2>  K-significa agrupamiento </h2><br><h5>  Utilizado por: </h5><br>  Cuando comprenda cu√°ntos grupos se pueden obtener para encontrar <b>un predeterminado</b> (a priori). <br><br><h5>  C√≥mo funciona </h5><br>  El algoritmo asigna aleatoriamente cada observaci√≥n a una de las <b>k</b> categor√≠as y luego calcula el <b>promedio</b> de cada categor√≠a.  Luego reasigna cada observaci√≥n a la categor√≠a con el promedio m√°s cercano, y nuevamente calcula los promedios.  El proceso se repite hasta que se necesiten reasignaciones. <br><br><h5>  Ejemplo de trabajo: </h5><br>  Tome un grupo de 12 jugadores y el n√∫mero de goles marcados por cada uno de ellos en la temporada actual (por ejemplo, en el rango de 3 a 30).  Dividimos a los jugadores, por ejemplo, en tres grupos. <br><br>  <b>Paso 1</b> : debes dividir aleatoriamente a los jugadores en tres grupos y calcular el promedio de cada uno de ellos. <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = (<span class="hljs-number"><span class="hljs-number">5</span></span> + <span class="hljs-number"><span class="hljs-number">20</span></span> + <span class="hljs-number"><span class="hljs-number">11</span></span>) / <span class="hljs-number"><span class="hljs-number">3</span></span> = <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre> <br>  <b>Paso 2</b> : reasigne a cada jugador al grupo con el promedio m√°s cercano.  Por ejemplo, el jugador A (5 goles) va al grupo 2 (promedio = 9).  Luego nuevamente calculamos los promedios grupales. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">12</span></span>) Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">9</span></span>) Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">16</span></span>) Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">21</span></span></code> </pre> <br>  <b>Repita el</b> paso 2 una y otra vez hasta que los jugadores dejen de cambiar de grupo.  En este ejemplo artificial, esto suceder√° en la pr√≥xima iteraci√≥n.  <b>Basta!</b>  ¬°Has formado tres grupos a partir de un conjunto de datos! <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">11</span></span>) Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">4</span></span>) Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">21</span></span>) Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">23</span></span></code> </pre> <br>  Los grupos deben corresponder a la posici√≥n de los jugadores en el campo: defensores, defensores centrales y delanteros.  K-significa trabajar en este ejemplo porque hay razones para creer que los datos se dividir√°n en estas tres categor√≠as. <br><br>  Por lo tanto, en funci√≥n de la variaci√≥n estad√≠stica en el rendimiento, la m√°quina puede justificar la ubicaci√≥n de los jugadores en el campo para cualquier deporte de equipo.  Esto es √∫til para el an√°lisis deportivo, as√≠ como para cualquier otra tarea en la que dividir el conjunto de datos en grupos predefinidos ayuda a sacar las conclusiones apropiadas. <br><br>  Hay varias variaciones del algoritmo descrito.  La formaci√≥n inicial de grupos puede realizarse de varias maneras.  Examinamos la clasificaci√≥n aleatoria de jugadores en grupos, seguida del c√°lculo de promedios.  Como resultado, los promedios iniciales del grupo est√°n cerca uno del otro, lo que aumenta la repetibilidad. <br><br>  Un enfoque alternativo es formar grupos que consisten en un solo jugador, y luego agrupar a los jugadores en los grupos m√°s cercanos.  Los grupos resultantes dependen m√°s de la etapa inicial de formaci√≥n, y la repetibilidad en conjuntos de datos con alta variabilidad disminuye.  Pero con este enfoque, puede llevar menos iteraciones completar el algoritmo, ya que se dedicar√° menos tiempo a dividir los grupos. <br><br>  El inconveniente obvio de la agrupaci√≥n de k-means es que debe adivinar <b>de antemano</b> cu√°ntos grupos tiene.  Existen m√©todos para evaluar la conformidad de un conjunto particular de grupos.  Por ejemplo, la suma de cuadrados dentro del grupo es una medida de variabilidad dentro de cada grupo.  Cuanto "mejores" son los grupos, menor es la suma total de cuadrados intragrupo. <br><br><h2>  Agrupaci√≥n jer√°rquica </h2><br><h5>  Utilizado por: </h5><br>  Cuando necesita revelar la relaci√≥n entre los valores (observaciones). <br><br><h5>  C√≥mo funciona </h5><br>  La matriz de distancia se calcula en la que el valor de la celda ( <i>i, j</i> ) es la m√©trica de la distancia entre los valores de <i>i</i> y <i>j</i> .  Luego se toma un par de los valores m√°s cercanos y se calcula el promedio.  Se crea una nueva matriz de distancia, los valores emparejados se combinan en un objeto.  Luego se toma un par de los valores m√°s cercanos de esta nueva matriz y se calcula un nuevo valor promedio.  El ciclo se repite hasta que todos los valores est√©n agrupados. <br><br><h5>  Ejemplo de trabajo: </h5><br>  Tome un conjunto de datos extremadamente simplificado con varias especies de ballenas y delfines.  Soy bi√≥logo y puedo asegurarle que se utilizan muchas m√°s propiedades para construir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√°rboles filogen√©ticos</a> .  Pero para nuestro ejemplo, nos restringimos a la longitud corporal caracter√≠stica de seis especies de mam√≠feros marinos.  Habr√° dos etapas de c√°lculos. <br><br><img src="https://habrastorage.org/webt/ho/im/do/hoimdoymetxkqlurmxoqutbochi.jpeg" width="628"><br><br>  <b>Paso 1</b> : se calcula la matriz de distancias entre todas las vistas.  Utilizaremos la m√©trica euclidiana que describe qu√© tan lejos est√°n nuestros datos unos de otros, como los asentamientos en el mapa.  Puede obtener la diferencia en la longitud de los cuerpos de cada par leyendo el valor en la intersecci√≥n de la columna y la fila correspondientes. <br><br><img src="https://habrastorage.org/webt/yy/eb/uo/yyebuo8b9stsem9pzjqic7noofg.jpeg" width="469"><br><br>  <b>Paso 2</b> : Tome un par de dos especies m√°s cercanas entre s√≠.  En este caso, se trata de un delf√≠n nariz de botella y un delf√≠n gris, en el que la longitud media del cuerpo es de 3,3 m. <br><br>  Repetimos el paso 1, nuevamente calculando la matriz de distancia, pero esta vez combinamos delf√≠n nariz de botella y delf√≠n gris en un objeto con una longitud corporal de 3,3 m. <br><br><img src="https://habrastorage.org/webt/ty/rr/tq/tyrrtqpqet7se07snsamey6sk5m.jpeg" width="484"><br><br>  Ahora repetimos el paso 2, pero con una nueva matriz de distancia.  Esta vez, la molienda y la orca ser√°n las m√°s cercanas, as√≠ que pongamos un par y calculemos el promedio: 7 m. <br><br>  Luego, repita el paso 1: nuevamente, calcule la matriz de distancia, pero con la molienda y la orca en forma de un solo objeto con una longitud corporal de 7 m. <br><br><img src="https://habrastorage.org/webt/0u/yi/ok/0uyioklconrrjskxp-jujhqpdhg.jpeg" width="551"><br><br>  Repita el paso 2 con esta matriz.  La distancia m√°s peque√±a (3.7 m) estar√° entre los dos objetos combinados, por lo que los combinaremos en un objeto a√∫n m√°s grande y calcularemos el valor promedio - 5.2 m. <br><br>  Luego repita el paso 1 y calcule una nueva matriz combinando el delf√≠n nariz de botella / delf√≠n gris con la molienda / orca. <br><br><img src="https://habrastorage.org/webt/15/uq/5s/15uq5ssub0h3yhz7omxjcucy6lc.jpeg" width="503"><br><br>  Repita el paso 2. La distancia m√°s peque√±a (5 m) ser√° entre la jorobada y la aleta, por lo que las combinamos y calculamos el promedio - 17.5 m. <br><br>  Nuevamente paso 1: calcule la matriz. <br><br><img src="https://habrastorage.org/webt/wq/6h/x2/wq6hx2vppdkd41tyx9fp3tf_ksk.jpeg" width="506"><br><br>  Finalmente, repita el paso 2: solo queda una distancia (12.3 m), por lo que uniremos a todos en un solo objeto y nos detendremos.  Esto es lo que sucedi√≥: <br><br><pre> <code class="hljs json">[[[BD, RD],[PW, KW]],[HW, FW]]</code> </pre> <br>  El objeto tiene una estructura jer√°rquica (recuerde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JSON</a> ), por lo que se puede mostrar como un gr√°fico de √°rbol o dendrograma.  El resultado es similar a un √°rbol geneal√≥gico.  Cuanto m√°s cerca est√©n dos valores en un √°rbol, m√°s ser√°n similares o estar√°n m√°s estrechamente conectados. <br><br><img src="https://habrastorage.org/webt/o-/ax/kv/o-axkvnp3rdgbt843ej8dsodneq.png"><br>  <i>Un dendrograma simple generado usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">R-Fiddle.org</a></i> <br><br>  La estructura del dendrograma le permite comprender la estructura del conjunto de datos en s√≠.  En nuestro ejemplo, tenemos dos ramas principales: una con una jorobada y un finwal, la otra con un delf√≠n nariz de botella / delf√≠n gris y una orca. <br><br>  En biolog√≠a evolutiva, se utilizan conjuntos de datos mucho m√°s grandes con muchas especies y una gran cantidad de caracteres para identificar las relaciones taxon√≥micas.  Fuera de la biolog√≠a, la agrupaci√≥n jer√°rquica se aplica en las √°reas de miner√≠a de datos y aprendizaje autom√°tico. <br><br>  Este enfoque no requiere la predicci√≥n del n√∫mero requerido de cl√∫steres.  Puede dividir el dendrograma resultante en grupos, "recortando" el √°rbol a la altura deseada.  Puede elegir la altura de diferentes maneras, dependiendo de la resoluci√≥n deseada de la agrupaci√≥n de datos. <br>  Por ejemplo, si el dendrograma anterior se corta a una altura de 10, entonces intersectaremos las dos ramas principales, dividiendo as√≠ el dendrograma en dos columnas.  Si se corta a una altura de 2, luego divida el dendrograma en tres grupos. <br><br>  Otros algoritmos de agrupamiento jer√°rquico pueden diferir en tres aspectos de los descritos en este art√≠culo. <br><br>  Lo m√°s importante es el enfoque.  Aqu√≠ usamos el m√©todo <b>aglomerativo</b> : comenzamos con valores individuales y los agrupamos c√≠clicamente hasta que obtuvimos un gran grupo.  Un enfoque alternativo (y computacionalmente m√°s complejo) implica la secuencia inversa: primero se crea un gran grupo, y luego se divide secuencialmente en grupos cada vez m√°s peque√±os hasta que permanecen valores separados. <br><br>  Tambi√©n hay varios m√©todos para calcular matrices de distancia.  Las m√©tricas euclidianas son suficientes para la mayor√≠a de las tareas, pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">otras m√©tricas</a> son m√°s adecuadas en algunas situaciones. <br><br>  Finalmente, el criterio de vinculaci√≥n puede variar.  La relaci√≥n entre grupos depende de su proximidad entre s√≠, pero la definici√≥n de "proximidad" puede ser diferente.  En nuestro ejemplo, medimos la distancia entre los valores promedio (o "centroides") de cada grupo y combinamos los grupos m√°s cercanos en pares.  Pero puedes usar otra definici√≥n. <br><br>  Supongamos que cada grupo consta de varios valores discretos.  La distancia entre dos grupos puede definirse como la distancia m√≠nima (o m√°xima) entre cualquiera de sus valores, como se muestra a continuaci√≥n.  Para diferentes contextos, es conveniente usar diferentes definiciones del criterio de uni√≥n. <br><br><img src="https://habrastorage.org/webt/mi/rm/em/mirmemzgr_pbyyumzxolhgftfoa.png"><br>  <i>Rojo / azul: grupo centroide;</i>  <i>rojo / verde: combinaci√≥n basada en m√≠nimos;</i>  <i>verde / azul: fusi√≥n basada en m√°ximos.</i> <br><br><h2>  Definici√≥n de comunidades en gr√°ficos (Detecci√≥n de comunidad de gr√°ficos) </h2><br><h5>  Utilizado por: </h5><br>  Cuando sus datos pueden presentarse en forma de red o "gr√°fico". <br><br><h5>  C√≥mo funciona </h5><br>  <b>Una comunidad en un gr√°fico</b> puede definirse aproximadamente como un subconjunto de v√©rtices que est√°n m√°s conectados entre s√≠ que con el resto de la red.  Existen diferentes algoritmos de definici√≥n de comunidad basados ‚Äã‚Äãen definiciones m√°s espec√≠ficas, como Edge Betweenness, Modularity-Maximsation, Walktrap, Clique Percolation, Leading Eigenvector ... <br><br><h5>  Ejemplo de trabajo: </h5><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La teor√≠a de grafos</a> es una rama muy interesante de las matem√°ticas que nos permite modelar sistemas complejos en forma de conjuntos abstractos de "puntos" (v√©rtices, nodos) conectados por "l√≠neas" (bordes). <br><br>  Quiz√°s la primera aplicaci√≥n de gr√°ficos que viene a la mente es el estudio de las redes sociales.  En este caso, los picos representan personas que est√°n conectadas por costillas a amigos / suscriptores.  Pero puede imaginar cualquier sistema en forma de red si puede justificar el m√©todo de conexi√≥n significativa de componentes.  Las aplicaciones innovadoras de agrupamiento utilizando la teor√≠a de grafos incluyen la extracci√≥n de propiedades de datos visuales y el an√°lisis de redes reguladoras gen√©ticas. <br><br>  Como un simple ejemplo, veamos el gr√°fico a continuaci√≥n.  Esto muestra los ocho sitios que visito con m√°s frecuencia.  Los enlaces entre ellos se basan en enlaces en art√≠culos de Wikipedia.  Dichos datos se pueden recopilar manualmente, pero para proyectos grandes es mucho m√°s r√°pido escribir un script Python.  Por ejemplo, esto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://raw.githubusercontent.com/pg0408/Medium-articles/master/graph_maker.py</a> . <br><br><img src="https://habrastorage.org/webt/qi/nh/7l/qinh7l-i5pblst_uwrknqda6w6k.png"><br>  <i>El gr√°fico se construye usando el paquete igraph para R 3.3.3</i> <br><br>  El color de los picos depende de la participaci√≥n en las comunidades, y el tama√±o depende de la centralidad.  Tenga en cuenta que los m√°s centrales son Google y Twitter. <br><br>  Adem√°s, los grupos resultantes reflejan con mucha precisi√≥n tareas reales (esto siempre es un indicador importante de rendimiento).  Los v√©rtices que representan los enlaces / sitios de b√∫squeda est√°n resaltados en amarillo;  sitios resaltados en azul para publicaciones en l√≠nea (art√≠culos, tweets o c√≥digo);  resaltados en rojo est√°n PayPal y YouTube, fundados por ex empleados de PayPal.  Buena deducci√≥n para la computadora! <br><br>  Adem√°s de visualizar sistemas grandes, el verdadero poder de las redes reside en el an√°lisis matem√°tico.  Comencemos convirtiendo la imagen de red en un formato matem√°tico.  La siguiente <b>es la</b> matriz de <b>adyacencia</b> de la red. <br><br><img src="https://habrastorage.org/webt/yx/gx/_x/yxgx_xezjyqcvpnsimmblg0by2a.jpeg" width="523"><br><br>  Los valores en las intersecciones de columnas y filas indican si hay un borde entre este par de v√©rtices.  Por ejemplo, entre Medium y Twitter est√°, por lo tanto, en la intersecci√≥n de esta l√≠nea y la columna se encuentra 1. Y entre Medium y PayPal no hay borde, por lo que en la celda correspondiente hay 0. <br><br>  Si representamos todas las propiedades de la red en forma de matriz de adyacencia, esto nos permitir√° sacar todo tipo de conclusiones √∫tiles.  Por ejemplo, la suma de los valores en cualquier columna o fila caracteriza el <b>grado de</b> cada v√©rtice, es decir, el n√∫mero de objetos conectados a este v√©rtice.  Generalmente indicado por la letra <i>k</i> . <br><br>  Si sumamos los grados de todos los v√©rtices y los dividimos entre dos, obtenemos L, el n√∫mero de aristas en la red.  Y el n√∫mero de filas y columnas es igual a N: el n√∫mero de v√©rtices en la red. <br><br>  Conociendo solo k, L, N y los valores en todas las celdas de la matriz de adyacencia A, podemos calcular la modularidad de cualquier agrupaci√≥n. <br><br>  Supongamos que hemos agrupado una red en varias comunidades.  Luego puede usar el valor de modularidad para predecir la "calidad" de la agrupaci√≥n.  Una mayor modularidad indica que dividimos la red en comunidades "exactas", y una menor modularidad sugiere que los grupos se forman m√°s por casualidad que razonablemente.  Para hacerlo m√°s claro: <br><br><img src="https://habrastorage.org/webt/hg/le/gj/hglegjtps3qnirey4nn01lxp-lu.png"><br>  La modularidad sirve como una medida de la "calidad" de los grupos. <br><br>  La modularidad se puede calcular utilizando la siguiente f√≥rmula: <br><br><img src="https://habrastorage.org/webt/n7/04/sb/n704sbaigjz6d9l35ovo40o1avq.png"><br><br>  Veamos esta f√≥rmula de aspecto incre√≠ble. <br><br>  <b>M</b> , como sabes, esto es modularidad. <br><br>  El coeficiente de <b>1 / 2L</b> significa que dividimos el resto del "cuerpo" de la f√≥rmula por 2L, es decir, por el doble n√∫mero de aristas en la red.  En Python, uno podr√≠a escribir: <br><br><pre> <code class="python hljs">sum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,N): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,N): ans = <span class="hljs-comment"><span class="hljs-comment">#stuff with i and j as indices sum += ans</span></span></code> </pre> <br>  ¬øQu√© es <code>#stuff with i and j</code> ?  El bit entre par√©ntesis nos dice que restemos (k_i k_j) / 2L de A_ij, donde A_ij es el valor en la matriz en la intersecci√≥n de la fila i y la columna j. <br><br>  Los valores k_i y k_j son los grados de cada v√©rtice.  Se pueden encontrar sumando los valores en la fila i y la columna j, respectivamente.  Si los multiplicamos y dividimos por 2L, obtenemos el n√∫mero esperado de aristas entre los v√©rtices i y j si la red se mezclara al azar. <br><br>  El contenido de los corchetes refleja la diferencia entre la estructura real de la red y la esperada si la red se reconstruyera al azar.  Si juegas con los valores, entonces la mayor modularidad estar√° en A_ij = 1 y baja (k_i k_j) / 2L.  Es decir, la modularidad aumenta si hay un borde "inesperado" entre los v√©rtices i y j. <br><br>  Finalmente, multiplicamos el contenido de los corchetes por lo que se indica en la f√≥rmula como Œ¥c_i, c_j.  Esta es la funci√≥n Kronecker-delta.  Aqu√≠ est√° su implementaci√≥n en Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Kronecker_Delta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ci, cj)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ci == cj: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> Kronecker_Delta(<span class="hljs-string"><span class="hljs-string">"A"</span></span>,<span class="hljs-string"><span class="hljs-string">"A"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#returns 1 Kronecker_Delta("A","B") #returns 0</span></span></code> </pre> <br>  Si, muy simple.  La funci√≥n toma dos argumentos, y si son id√©nticos, devuelve 1, y si no, entonces 0. <br><br>  En otras palabras, si los v√©rtices i y j caen en un grupo, entonces Œ¥c_i, c_j = 1. Y si est√°n en grupos diferentes, la funci√≥n devolver√° 0. <br><br>  Como multiplicamos el contenido de los corchetes por el s√≠mbolo de Kronecker, el resultado de la suma invertida <b>Œ£</b> ser√° el m√°s alto cuando los v√©rtices dentro de un grupo est√©n conectados por una gran cantidad de bordes "inesperados".  Por lo tanto, la modularidad es un indicador de qu√© tan bien se agrupa un gr√°fico en comunidades individuales. <br><br>  La divisi√≥n por 2L limita la modularidad superior a la unidad.  Si la modularidad es cercana a 0 o negativa, esto significa que la agrupaci√≥n actual de la red no tiene sentido.  Al aumentar la modularidad, podemos encontrar una mejor manera de agrupar la red. <br><br>  Tenga en cuenta que para evaluar la "calidad" de la agrupaci√≥n de un gr√°fico, debemos determinar de antemano c√≥mo se agrupar√°.  Desafortunadamente, a menos que la muestra sea muy peque√±a, debido a la complejidad computacional, es simplemente f√≠sicamente imposible pasar est√∫pidamente por todos los m√©todos de agrupar un gr√°fico comparando su modularidad. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Combinatorics</a> sugiere que para una red con 8 v√©rtices, hay 4.140 m√©todos de agrupamiento.  Para una red con 16 v√©rtices, ya habr√° m√°s de 10 mil millones de formas, para una red con 32 v√©rtices, 128 septillones, y para una red con 80 v√©rtices, la cantidad de m√©todos de agrupamiento exceder√° la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cantidad de √°tomos en el Universo observable</a> . <br><br>  Por lo tanto, en lugar de enumerar, usaremos el m√©todo heur√≠stico, que ayudar√° a calcular relativamente f√°cilmente los cl√∫steres con la m√°xima modularidad.  Este es un algoritmo llamado <i>Fast-Greedy Modularity-Maximization</i> , una especie de an√°logo al algoritmo de agrupamiento jer√°rquico aglomerativo descrito anteriormente.  En lugar de combinar en base a la proximidad, Mod-Max une comunidades dependiendo de los cambios en la modularidad.  C√≥mo funciona <br><br>  <b>Primero,</b> cada v√©rtice se asigna a su propia comunidad y se calcula la modularidad de toda la red: M. <br><br>  <b>Paso 1</b> : para cada par de comunidades conectadas por al menos un borde, el algoritmo calcula el cambio resultante en la modularidad ŒîM en el caso de combinar estos pares de comunidades. <br><br>  <b>Paso 2</b> : luego se toma un par, cuando se combina, ŒîM ser√° m√°ximo y se combinar√°.  Para este agrupamiento, se calcula y almacena una nueva modularidad. <br><br>  Se <b>repiten los</b> pasos 1 y 2: cada vez que se une un par de comunidades, lo que da la mayor ŒîM, un nuevo esquema de agrupamiento y su M. <br><br>  Las iteraciones se <b>detienen</b> cuando todos los v√©rtices se agrupan en un gran grupo.  Ahora el algoritmo verifica los registros almacenados y encuentra el esquema de agrupamiento con la mayor modularidad.  Es ella quien regresa como una estructura comunitaria. <br><br>  Fue computacionalmente dif√≠cil, al menos para las personas.  La teor√≠a de grafos es una rica fuente de problemas computacionales dif√≠ciles y problemas NP-dif√≠ciles.  Usando gr√°ficos, podemos sacar muchas conclusiones √∫tiles sobre sistemas complejos y conjuntos de datos.  Preg√∫ntele a Larry Page, cuyo algoritmo PageRank, que ayud√≥ a Google a transformarse de una startup a una posici√≥n dominante global en menos de una generaci√≥n, se basa completamente en la teor√≠a de gr√°ficos. <br><br>  Los estudios sobre teor√≠a de grafos de hoy se centran en identificar comunidades.  Hay muchas alternativas al algoritmo de maximizaci√≥n de modularidad, que, aunque √∫til, no est√° exento de inconvenientes. <br><br>  Primero, con un enfoque aglomerativo, las comunidades peque√±as y bien definidas a menudo se combinan en comunidades m√°s grandes.  Esto se llama l√≠mite de resoluci√≥n: el algoritmo no asigna comunidades m√°s peque√±as que un cierto tama√±o.  Otro inconveniente es que, en lugar de un pico global pronunciado y f√°cilmente alcanzable, el algoritmo Mod-Max busca generar una "meseta" amplia a partir de muchos valores de modularidad cercanos.  Como resultado, es dif√≠cil destacar al ganador. <br><br>  Otros algoritmos utilizan diferentes m√©todos para definir comunidades.  Por ejemplo, Edge-Betweenness es un algoritmo divisivo (divisorio) que comienza agrupando todos los v√©rtices en un gran grupo.  Luego, los bordes menos "importantes" se eliminan iterativamente hasta que se a√≠slan todos los v√©rtices.  El resultado es una estructura jer√°rquica en la que los v√©rtices est√°n m√°s cerca uno del otro, cuanto m√°s son similares. <br><br>  El algoritmo, Clique Percolation, tiene en cuenta las posibles intersecciones entre comunidades.  Hay un grupo de algoritmos basados ‚Äã‚Äãen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una caminata aleatoria</a> en un gr√°fico, y hay m√©todos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">agrupaci√≥n espectral</a> que se ocupan de la descomposici√≥n espectral (descomposici√≥n propia) de la matriz de adyacencia y otras matrices derivadas de ella.  Todas estas ideas se utilizan para resaltar caracter√≠sticas, por ejemplo, en visi√≥n artificial. <br><br>  No analizaremos ejemplos de trabajo para cada algoritmo en detalle.  ,              ,     20    . <br><br><h2>  Conclusi√≥n </h2><br> ,     - ,   ,         .   ,       ,       20-40 . <br><br>     ,   ‚Äî    ,            . ,     ,       . <br><br>    ,  ,     ,   ,   . , -  , ,    ?     - ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413269/">https://habr.com/ru/post/es413269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413253/index.html">Richard Hamming: Cap√≠tulo 21. Fibra √≥ptica</a></li>
<li><a href="../es413255/index.html">Richard Hamming: Cap√≠tulo 27. Datos inv√°lidos</a></li>
<li><a href="../es413261/index.html">Como funciona la b√∫squeda</a></li>
<li><a href="../es413265/index.html">A la casa de ba√±os con IT</a></li>
<li><a href="../es413267/index.html">10 cualidades imprescindibles a tener en cuenta para un gerente de producto novato</a></li>
<li><a href="../es413271/index.html">Sin contrase√±as: c√≥mo funciona el sistema de autenticaci√≥n en un registro distribuido</a></li>
<li><a href="../es413273/index.html">Gesti√≥n de los requisitos de productos de TI dentro de la empresa.</a></li>
<li><a href="../es413275/index.html">Pruebas comparativas de parrillas para lograr el resultado m√°s delicioso.</a></li>
<li><a href="../es413277/index.html">JSFiddle - nueva versi√≥n</a></li>
<li><a href="../es413279/index.html">La aplicaci√≥n m√≥vil calcula el contenido cal√≥rico de los platos en los restaurantes.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>