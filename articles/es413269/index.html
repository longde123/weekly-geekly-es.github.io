<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕🏾 🧑🏿‍🤝‍🧑🏽 🛀🏻 Cómo las máquinas analizan big data: una introducción a los algoritmos de agrupamiento 👩🏼‍🍳 🚈 🤚🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Traducción de cómo las máquinas tienen sentido de Big Data: una introducción a los algoritmos de agrupamiento . 

 Echa un vistazo a la imagen de abaj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo las máquinas analizan big data: una introducción a los algoritmos de agrupamiento</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/413269/"><img src="https://habrastorage.org/webt/1t/cz/rt/1tczrtuly-qxcq8pwrfwgdubvqm.jpeg"><br><br>  <i>Traducción de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cómo las máquinas tienen sentido de Big Data: una introducción a los algoritmos de agrupamiento</a> .</i> <br><br>  Echa un vistazo a la imagen de abajo.  Esta es una colección de insectos (los caracoles no son insectos, pero no encontraremos fallas) de varias formas y tamaños.  Ahora divídalos en varios grupos según el grado de similitud.  No hay trampa.  Comience agrupando arañas. <br><br><img src="https://habrastorage.org/webt/yh/jr/c_/yhjrc_z9obxthw3uymiywxkyehq.png"><br><a name="habracut"></a><br>  Terminado?  Aunque no hay una solución "correcta" aquí, debe haber dividido estas criaturas en cuatro <b>grupos</b> .  En un grupo hay arañas, en el segundo, un par de caracoles, en el tercero, mariposas, y en el cuarto, un trío de abejas y avispas. <br><br>  Bien hecho, ¿verdad?  Probablemente podría hacer lo mismo si hubiera el doble de insectos en la imagen.  Y si tuviera mucho tiempo, o un ansia de entomología, entonces probablemente habría agrupado cientos de insectos. <br><br>  Sin embargo, para una máquina, agrupar diez objetos en grupos significativos no es una tarea fácil.  Gracias a una rama tan compleja de las matemáticas como la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">combinatoria</a> , sabemos que 10 insectos se agrupan de 115,975 formas.  Y si hay 20 insectos, entonces el número de opciones de agrupación <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">superará los 50 billones</a> . <br><br>  Con un centenar de insectos, el número de posibles soluciones será mayor que el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">número de partículas elementales en el Universo conocido</a> .  Cuanto mas  Según mis estimaciones, unos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">quinientos millones de billones de millones de veces más</a> .  Resulta más de <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuatro millones de billones de</a></b> soluciones de <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">google</a></b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿qué es google?</a> ).  Y esto es solo para cientos de objetos. <br><br>  Casi todas estas combinaciones no tendrán sentido.  A pesar de la cantidad inimaginable de soluciones, usted mismo encontró rápidamente una de las pocas formas útiles de agrupamiento. <br><br>  Los humanos damos por sentado nuestra excelente capacidad para catalogar y comprender grandes cantidades de datos.  No importa si se trata de texto, imágenes en la pantalla o una secuencia de objetos: las personas, en general, entienden de manera efectiva los datos que provienen del mundo circundante. <br><br>  Dado que un aspecto clave del desarrollo de IA y el aprendizaje automático es que las máquinas pueden comprender rápidamente grandes volúmenes de datos de entrada, ¿cómo puedo mejorar la eficiencia del trabajo?  En este artículo, consideraremos tres algoritmos de agrupamiento con los que las máquinas pueden comprender rápidamente grandes cantidades de datos.  Esta lista está lejos de ser completa, hay otros algoritmos, pero ya es bastante posible comenzar con ella. <br><br>  Para cada algoritmo, describiré cuándo se puede usar, cómo funciona y también daré un ejemplo con análisis paso a paso.  Creo que para una comprensión real del algoritmo, debe repetir su trabajo usted mismo.  Si está <b>realmente interesado</b> , se dará cuenta de que es mejor ejecutar algoritmos en papel.  Acto, nadie te va a culpar! <br><br><img src="https://habrastorage.org/webt/6g/yv/nu/6gyvnuxigsioglh_xamfblafeua.png"><br>  <i>Tres grupos sospechosamente limpios con k = 3</i> <br><br><h2>  K-significa agrupamiento </h2><br><h5>  Utilizado por: </h5><br>  Cuando comprenda cuántos grupos se pueden obtener para encontrar <b>un predeterminado</b> (a priori). <br><br><h5>  Cómo funciona </h5><br>  El algoritmo asigna aleatoriamente cada observación a una de las <b>k</b> categorías y luego calcula el <b>promedio</b> de cada categoría.  Luego reasigna cada observación a la categoría con el promedio más cercano, y nuevamente calcula los promedios.  El proceso se repite hasta que se necesiten reasignaciones. <br><br><h5>  Ejemplo de trabajo: </h5><br>  Tome un grupo de 12 jugadores y el número de goles marcados por cada uno de ellos en la temporada actual (por ejemplo, en el rango de 3 a 30).  Dividimos a los jugadores, por ejemplo, en tres grupos. <br><br>  <b>Paso 1</b> : debes dividir aleatoriamente a los jugadores en tres grupos y calcular el promedio de cada uno de ellos. <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = (<span class="hljs-number"><span class="hljs-number">5</span></span> + <span class="hljs-number"><span class="hljs-number">20</span></span> + <span class="hljs-number"><span class="hljs-number">11</span></span>) / <span class="hljs-number"><span class="hljs-number">3</span></span> = <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre> <br>  <b>Paso 2</b> : reasigne a cada jugador al grupo con el promedio más cercano.  Por ejemplo, el jugador A (5 goles) va al grupo 2 (promedio = 9).  Luego nuevamente calculamos los promedios grupales. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">12</span></span>) Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">9</span></span>) Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">16</span></span>) Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">21</span></span></code> </pre> <br>  <b>Repita el</b> paso 2 una y otra vez hasta que los jugadores dejen de cambiar de grupo.  En este ejemplo artificial, esto sucederá en la próxima iteración.  <b>Basta!</b>  ¡Has formado tres grupos a partir de un conjunto de datos! <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">11</span></span>) Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">4</span></span>) Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">21</span></span>) Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">23</span></span></code> </pre> <br>  Los grupos deben corresponder a la posición de los jugadores en el campo: defensores, defensores centrales y delanteros.  K-significa trabajar en este ejemplo porque hay razones para creer que los datos se dividirán en estas tres categorías. <br><br>  Por lo tanto, en función de la variación estadística en el rendimiento, la máquina puede justificar la ubicación de los jugadores en el campo para cualquier deporte de equipo.  Esto es útil para el análisis deportivo, así como para cualquier otra tarea en la que dividir el conjunto de datos en grupos predefinidos ayuda a sacar las conclusiones apropiadas. <br><br>  Hay varias variaciones del algoritmo descrito.  La formación inicial de grupos puede realizarse de varias maneras.  Examinamos la clasificación aleatoria de jugadores en grupos, seguida del cálculo de promedios.  Como resultado, los promedios iniciales del grupo están cerca uno del otro, lo que aumenta la repetibilidad. <br><br>  Un enfoque alternativo es formar grupos que consisten en un solo jugador, y luego agrupar a los jugadores en los grupos más cercanos.  Los grupos resultantes dependen más de la etapa inicial de formación, y la repetibilidad en conjuntos de datos con alta variabilidad disminuye.  Pero con este enfoque, puede llevar menos iteraciones completar el algoritmo, ya que se dedicará menos tiempo a dividir los grupos. <br><br>  El inconveniente obvio de la agrupación de k-means es que debe adivinar <b>de antemano</b> cuántos grupos tiene.  Existen métodos para evaluar la conformidad de un conjunto particular de grupos.  Por ejemplo, la suma de cuadrados dentro del grupo es una medida de variabilidad dentro de cada grupo.  Cuanto "mejores" son los grupos, menor es la suma total de cuadrados intragrupo. <br><br><h2>  Agrupación jerárquica </h2><br><h5>  Utilizado por: </h5><br>  Cuando necesita revelar la relación entre los valores (observaciones). <br><br><h5>  Cómo funciona </h5><br>  La matriz de distancia se calcula en la que el valor de la celda ( <i>i, j</i> ) es la métrica de la distancia entre los valores de <i>i</i> y <i>j</i> .  Luego se toma un par de los valores más cercanos y se calcula el promedio.  Se crea una nueva matriz de distancia, los valores emparejados se combinan en un objeto.  Luego se toma un par de los valores más cercanos de esta nueva matriz y se calcula un nuevo valor promedio.  El ciclo se repite hasta que todos los valores estén agrupados. <br><br><h5>  Ejemplo de trabajo: </h5><br>  Tome un conjunto de datos extremadamente simplificado con varias especies de ballenas y delfines.  Soy biólogo y puedo asegurarle que se utilizan muchas más propiedades para construir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">árboles filogenéticos</a> .  Pero para nuestro ejemplo, nos restringimos a la longitud corporal característica de seis especies de mamíferos marinos.  Habrá dos etapas de cálculos. <br><br><img src="https://habrastorage.org/webt/ho/im/do/hoimdoymetxkqlurmxoqutbochi.jpeg" width="628"><br><br>  <b>Paso 1</b> : se calcula la matriz de distancias entre todas las vistas.  Utilizaremos la métrica euclidiana que describe qué tan lejos están nuestros datos unos de otros, como los asentamientos en el mapa.  Puede obtener la diferencia en la longitud de los cuerpos de cada par leyendo el valor en la intersección de la columna y la fila correspondientes. <br><br><img src="https://habrastorage.org/webt/yy/eb/uo/yyebuo8b9stsem9pzjqic7noofg.jpeg" width="469"><br><br>  <b>Paso 2</b> : Tome un par de dos especies más cercanas entre sí.  En este caso, se trata de un delfín nariz de botella y un delfín gris, en el que la longitud media del cuerpo es de 3,3 m. <br><br>  Repetimos el paso 1, nuevamente calculando la matriz de distancia, pero esta vez combinamos delfín nariz de botella y delfín gris en un objeto con una longitud corporal de 3,3 m. <br><br><img src="https://habrastorage.org/webt/ty/rr/tq/tyrrtqpqet7se07snsamey6sk5m.jpeg" width="484"><br><br>  Ahora repetimos el paso 2, pero con una nueva matriz de distancia.  Esta vez, la molienda y la orca serán las más cercanas, así que pongamos un par y calculemos el promedio: 7 m. <br><br>  Luego, repita el paso 1: nuevamente, calcule la matriz de distancia, pero con la molienda y la orca en forma de un solo objeto con una longitud corporal de 7 m. <br><br><img src="https://habrastorage.org/webt/0u/yi/ok/0uyioklconrrjskxp-jujhqpdhg.jpeg" width="551"><br><br>  Repita el paso 2 con esta matriz.  La distancia más pequeña (3.7 m) estará entre los dos objetos combinados, por lo que los combinaremos en un objeto aún más grande y calcularemos el valor promedio - 5.2 m. <br><br>  Luego repita el paso 1 y calcule una nueva matriz combinando el delfín nariz de botella / delfín gris con la molienda / orca. <br><br><img src="https://habrastorage.org/webt/15/uq/5s/15uq5ssub0h3yhz7omxjcucy6lc.jpeg" width="503"><br><br>  Repita el paso 2. La distancia más pequeña (5 m) será entre la jorobada y la aleta, por lo que las combinamos y calculamos el promedio - 17.5 m. <br><br>  Nuevamente paso 1: calcule la matriz. <br><br><img src="https://habrastorage.org/webt/wq/6h/x2/wq6hx2vppdkd41tyx9fp3tf_ksk.jpeg" width="506"><br><br>  Finalmente, repita el paso 2: solo queda una distancia (12.3 m), por lo que uniremos a todos en un solo objeto y nos detendremos.  Esto es lo que sucedió: <br><br><pre> <code class="hljs json">[[[BD, RD],[PW, KW]],[HW, FW]]</code> </pre> <br>  El objeto tiene una estructura jerárquica (recuerde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JSON</a> ), por lo que se puede mostrar como un gráfico de árbol o dendrograma.  El resultado es similar a un árbol genealógico.  Cuanto más cerca estén dos valores en un árbol, más serán similares o estarán más estrechamente conectados. <br><br><img src="https://habrastorage.org/webt/o-/ax/kv/o-axkvnp3rdgbt843ej8dsodneq.png"><br>  <i>Un dendrograma simple generado usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">R-Fiddle.org</a></i> <br><br>  La estructura del dendrograma le permite comprender la estructura del conjunto de datos en sí.  En nuestro ejemplo, tenemos dos ramas principales: una con una jorobada y un finwal, la otra con un delfín nariz de botella / delfín gris y una orca. <br><br>  En biología evolutiva, se utilizan conjuntos de datos mucho más grandes con muchas especies y una gran cantidad de caracteres para identificar las relaciones taxonómicas.  Fuera de la biología, la agrupación jerárquica se aplica en las áreas de minería de datos y aprendizaje automático. <br><br>  Este enfoque no requiere la predicción del número requerido de clústeres.  Puede dividir el dendrograma resultante en grupos, "recortando" el árbol a la altura deseada.  Puede elegir la altura de diferentes maneras, dependiendo de la resolución deseada de la agrupación de datos. <br>  Por ejemplo, si el dendrograma anterior se corta a una altura de 10, entonces intersectaremos las dos ramas principales, dividiendo así el dendrograma en dos columnas.  Si se corta a una altura de 2, luego divida el dendrograma en tres grupos. <br><br>  Otros algoritmos de agrupamiento jerárquico pueden diferir en tres aspectos de los descritos en este artículo. <br><br>  Lo más importante es el enfoque.  Aquí usamos el método <b>aglomerativo</b> : comenzamos con valores individuales y los agrupamos cíclicamente hasta que obtuvimos un gran grupo.  Un enfoque alternativo (y computacionalmente más complejo) implica la secuencia inversa: primero se crea un gran grupo, y luego se divide secuencialmente en grupos cada vez más pequeños hasta que permanecen valores separados. <br><br>  También hay varios métodos para calcular matrices de distancia.  Las métricas euclidianas son suficientes para la mayoría de las tareas, pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">otras métricas</a> son más adecuadas en algunas situaciones. <br><br>  Finalmente, el criterio de vinculación puede variar.  La relación entre grupos depende de su proximidad entre sí, pero la definición de "proximidad" puede ser diferente.  En nuestro ejemplo, medimos la distancia entre los valores promedio (o "centroides") de cada grupo y combinamos los grupos más cercanos en pares.  Pero puedes usar otra definición. <br><br>  Supongamos que cada grupo consta de varios valores discretos.  La distancia entre dos grupos puede definirse como la distancia mínima (o máxima) entre cualquiera de sus valores, como se muestra a continuación.  Para diferentes contextos, es conveniente usar diferentes definiciones del criterio de unión. <br><br><img src="https://habrastorage.org/webt/mi/rm/em/mirmemzgr_pbyyumzxolhgftfoa.png"><br>  <i>Rojo / azul: grupo centroide;</i>  <i>rojo / verde: combinación basada en mínimos;</i>  <i>verde / azul: fusión basada en máximos.</i> <br><br><h2>  Definición de comunidades en gráficos (Detección de comunidad de gráficos) </h2><br><h5>  Utilizado por: </h5><br>  Cuando sus datos pueden presentarse en forma de red o "gráfico". <br><br><h5>  Cómo funciona </h5><br>  <b>Una comunidad en un gráfico</b> puede definirse aproximadamente como un subconjunto de vértices que están más conectados entre sí que con el resto de la red.  Existen diferentes algoritmos de definición de comunidad basados ​​en definiciones más específicas, como Edge Betweenness, Modularity-Maximsation, Walktrap, Clique Percolation, Leading Eigenvector ... <br><br><h5>  Ejemplo de trabajo: </h5><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La teoría de grafos</a> es una rama muy interesante de las matemáticas que nos permite modelar sistemas complejos en forma de conjuntos abstractos de "puntos" (vértices, nodos) conectados por "líneas" (bordes). <br><br>  Quizás la primera aplicación de gráficos que viene a la mente es el estudio de las redes sociales.  En este caso, los picos representan personas que están conectadas por costillas a amigos / suscriptores.  Pero puede imaginar cualquier sistema en forma de red si puede justificar el método de conexión significativa de componentes.  Las aplicaciones innovadoras de agrupamiento utilizando la teoría de grafos incluyen la extracción de propiedades de datos visuales y el análisis de redes reguladoras genéticas. <br><br>  Como un simple ejemplo, veamos el gráfico a continuación.  Esto muestra los ocho sitios que visito con más frecuencia.  Los enlaces entre ellos se basan en enlaces en artículos de Wikipedia.  Dichos datos se pueden recopilar manualmente, pero para proyectos grandes es mucho más rápido escribir un script Python.  Por ejemplo, esto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://raw.githubusercontent.com/pg0408/Medium-articles/master/graph_maker.py</a> . <br><br><img src="https://habrastorage.org/webt/qi/nh/7l/qinh7l-i5pblst_uwrknqda6w6k.png"><br>  <i>El gráfico se construye usando el paquete igraph para R 3.3.3</i> <br><br>  El color de los picos depende de la participación en las comunidades, y el tamaño depende de la centralidad.  Tenga en cuenta que los más centrales son Google y Twitter. <br><br>  Además, los grupos resultantes reflejan con mucha precisión tareas reales (esto siempre es un indicador importante de rendimiento).  Los vértices que representan los enlaces / sitios de búsqueda están resaltados en amarillo;  sitios resaltados en azul para publicaciones en línea (artículos, tweets o código);  resaltados en rojo están PayPal y YouTube, fundados por ex empleados de PayPal.  Buena deducción para la computadora! <br><br>  Además de visualizar sistemas grandes, el verdadero poder de las redes reside en el análisis matemático.  Comencemos convirtiendo la imagen de red en un formato matemático.  La siguiente <b>es la</b> matriz de <b>adyacencia</b> de la red. <br><br><img src="https://habrastorage.org/webt/yx/gx/_x/yxgx_xezjyqcvpnsimmblg0by2a.jpeg" width="523"><br><br>  Los valores en las intersecciones de columnas y filas indican si hay un borde entre este par de vértices.  Por ejemplo, entre Medium y Twitter está, por lo tanto, en la intersección de esta línea y la columna se encuentra 1. Y entre Medium y PayPal no hay borde, por lo que en la celda correspondiente hay 0. <br><br>  Si representamos todas las propiedades de la red en forma de matriz de adyacencia, esto nos permitirá sacar todo tipo de conclusiones útiles.  Por ejemplo, la suma de los valores en cualquier columna o fila caracteriza el <b>grado de</b> cada vértice, es decir, el número de objetos conectados a este vértice.  Generalmente indicado por la letra <i>k</i> . <br><br>  Si sumamos los grados de todos los vértices y los dividimos entre dos, obtenemos L, el número de aristas en la red.  Y el número de filas y columnas es igual a N: el número de vértices en la red. <br><br>  Conociendo solo k, L, N y los valores en todas las celdas de la matriz de adyacencia A, podemos calcular la modularidad de cualquier agrupación. <br><br>  Supongamos que hemos agrupado una red en varias comunidades.  Luego puede usar el valor de modularidad para predecir la "calidad" de la agrupación.  Una mayor modularidad indica que dividimos la red en comunidades "exactas", y una menor modularidad sugiere que los grupos se forman más por casualidad que razonablemente.  Para hacerlo más claro: <br><br><img src="https://habrastorage.org/webt/hg/le/gj/hglegjtps3qnirey4nn01lxp-lu.png"><br>  La modularidad sirve como una medida de la "calidad" de los grupos. <br><br>  La modularidad se puede calcular utilizando la siguiente fórmula: <br><br><img src="https://habrastorage.org/webt/n7/04/sb/n704sbaigjz6d9l35ovo40o1avq.png"><br><br>  Veamos esta fórmula de aspecto increíble. <br><br>  <b>M</b> , como sabes, esto es modularidad. <br><br>  El coeficiente de <b>1 / 2L</b> significa que dividimos el resto del "cuerpo" de la fórmula por 2L, es decir, por el doble número de aristas en la red.  En Python, uno podría escribir: <br><br><pre> <code class="python hljs">sum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,N): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,N): ans = <span class="hljs-comment"><span class="hljs-comment">#stuff with i and j as indices sum += ans</span></span></code> </pre> <br>  ¿Qué es <code>#stuff with i and j</code> ?  El bit entre paréntesis nos dice que restemos (k_i k_j) / 2L de A_ij, donde A_ij es el valor en la matriz en la intersección de la fila i y la columna j. <br><br>  Los valores k_i y k_j son los grados de cada vértice.  Se pueden encontrar sumando los valores en la fila i y la columna j, respectivamente.  Si los multiplicamos y dividimos por 2L, obtenemos el número esperado de aristas entre los vértices i y j si la red se mezclara al azar. <br><br>  El contenido de los corchetes refleja la diferencia entre la estructura real de la red y la esperada si la red se reconstruyera al azar.  Si juegas con los valores, entonces la mayor modularidad estará en A_ij = 1 y baja (k_i k_j) / 2L.  Es decir, la modularidad aumenta si hay un borde "inesperado" entre los vértices i y j. <br><br>  Finalmente, multiplicamos el contenido de los corchetes por lo que se indica en la fórmula como δc_i, c_j.  Esta es la función Kronecker-delta.  Aquí está su implementación en Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Kronecker_Delta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ci, cj)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ci == cj: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> Kronecker_Delta(<span class="hljs-string"><span class="hljs-string">"A"</span></span>,<span class="hljs-string"><span class="hljs-string">"A"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#returns 1 Kronecker_Delta("A","B") #returns 0</span></span></code> </pre> <br>  Si, muy simple.  La función toma dos argumentos, y si son idénticos, devuelve 1, y si no, entonces 0. <br><br>  En otras palabras, si los vértices i y j caen en un grupo, entonces δc_i, c_j = 1. Y si están en grupos diferentes, la función devolverá 0. <br><br>  Como multiplicamos el contenido de los corchetes por el símbolo de Kronecker, el resultado de la suma invertida <b>Σ</b> será el más alto cuando los vértices dentro de un grupo estén conectados por una gran cantidad de bordes "inesperados".  Por lo tanto, la modularidad es un indicador de qué tan bien se agrupa un gráfico en comunidades individuales. <br><br>  La división por 2L limita la modularidad superior a la unidad.  Si la modularidad es cercana a 0 o negativa, esto significa que la agrupación actual de la red no tiene sentido.  Al aumentar la modularidad, podemos encontrar una mejor manera de agrupar la red. <br><br>  Tenga en cuenta que para evaluar la "calidad" de la agrupación de un gráfico, debemos determinar de antemano cómo se agrupará.  Desafortunadamente, a menos que la muestra sea muy pequeña, debido a la complejidad computacional, es simplemente físicamente imposible pasar estúpidamente por todos los métodos de agrupar un gráfico comparando su modularidad. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Combinatorics</a> sugiere que para una red con 8 vértices, hay 4.140 métodos de agrupamiento.  Para una red con 16 vértices, ya habrá más de 10 mil millones de formas, para una red con 32 vértices, 128 septillones, y para una red con 80 vértices, la cantidad de métodos de agrupamiento excederá la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cantidad de átomos en el Universo observable</a> . <br><br>  Por lo tanto, en lugar de enumerar, usaremos el método heurístico, que ayudará a calcular relativamente fácilmente los clústeres con la máxima modularidad.  Este es un algoritmo llamado <i>Fast-Greedy Modularity-Maximization</i> , una especie de análogo al algoritmo de agrupamiento jerárquico aglomerativo descrito anteriormente.  En lugar de combinar en base a la proximidad, Mod-Max une comunidades dependiendo de los cambios en la modularidad.  Cómo funciona <br><br>  <b>Primero,</b> cada vértice se asigna a su propia comunidad y se calcula la modularidad de toda la red: M. <br><br>  <b>Paso 1</b> : para cada par de comunidades conectadas por al menos un borde, el algoritmo calcula el cambio resultante en la modularidad ΔM en el caso de combinar estos pares de comunidades. <br><br>  <b>Paso 2</b> : luego se toma un par, cuando se combina, ΔM será máximo y se combinará.  Para este agrupamiento, se calcula y almacena una nueva modularidad. <br><br>  Se <b>repiten los</b> pasos 1 y 2: cada vez que se une un par de comunidades, lo que da la mayor ΔM, un nuevo esquema de agrupamiento y su M. <br><br>  Las iteraciones se <b>detienen</b> cuando todos los vértices se agrupan en un gran grupo.  Ahora el algoritmo verifica los registros almacenados y encuentra el esquema de agrupamiento con la mayor modularidad.  Es ella quien regresa como una estructura comunitaria. <br><br>  Fue computacionalmente difícil, al menos para las personas.  La teoría de grafos es una rica fuente de problemas computacionales difíciles y problemas NP-difíciles.  Usando gráficos, podemos sacar muchas conclusiones útiles sobre sistemas complejos y conjuntos de datos.  Pregúntele a Larry Page, cuyo algoritmo PageRank, que ayudó a Google a transformarse de una startup a una posición dominante global en menos de una generación, se basa completamente en la teoría de gráficos. <br><br>  Los estudios sobre teoría de grafos de hoy se centran en identificar comunidades.  Hay muchas alternativas al algoritmo de maximización de modularidad, que, aunque útil, no está exento de inconvenientes. <br><br>  Primero, con un enfoque aglomerativo, las comunidades pequeñas y bien definidas a menudo se combinan en comunidades más grandes.  Esto se llama límite de resolución: el algoritmo no asigna comunidades más pequeñas que un cierto tamaño.  Otro inconveniente es que, en lugar de un pico global pronunciado y fácilmente alcanzable, el algoritmo Mod-Max busca generar una "meseta" amplia a partir de muchos valores de modularidad cercanos.  Como resultado, es difícil destacar al ganador. <br><br>  Otros algoritmos utilizan diferentes métodos para definir comunidades.  Por ejemplo, Edge-Betweenness es un algoritmo divisivo (divisorio) que comienza agrupando todos los vértices en un gran grupo.  Luego, los bordes menos "importantes" se eliminan iterativamente hasta que se aíslan todos los vértices.  El resultado es una estructura jerárquica en la que los vértices están más cerca uno del otro, cuanto más son similares. <br><br>  El algoritmo, Clique Percolation, tiene en cuenta las posibles intersecciones entre comunidades.  Hay un grupo de algoritmos basados ​​en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una caminata aleatoria</a> en un gráfico, y hay métodos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">agrupación espectral</a> que se ocupan de la descomposición espectral (descomposición propia) de la matriz de adyacencia y otras matrices derivadas de ella.  Todas estas ideas se utilizan para resaltar características, por ejemplo, en visión artificial. <br><br>  No analizaremos ejemplos de trabajo para cada algoritmo en detalle.  ,              ,     20    . <br><br><h2>  Conclusión </h2><br> ,     - ,   ,         .   ,       ,       20-40 . <br><br>     ,   —    ,            . ,     ,       . <br><br>    ,  ,     ,   ,   . , -  , ,    ?     - ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413269/">https://habr.com/ru/post/es413269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413253/index.html">Richard Hamming: Capítulo 21. Fibra óptica</a></li>
<li><a href="../es413255/index.html">Richard Hamming: Capítulo 27. Datos inválidos</a></li>
<li><a href="../es413261/index.html">Como funciona la búsqueda</a></li>
<li><a href="../es413265/index.html">A la casa de baños con IT</a></li>
<li><a href="../es413267/index.html">10 cualidades imprescindibles a tener en cuenta para un gerente de producto novato</a></li>
<li><a href="../es413271/index.html">Sin contraseñas: cómo funciona el sistema de autenticación en un registro distribuido</a></li>
<li><a href="../es413273/index.html">Gestión de los requisitos de productos de TI dentro de la empresa.</a></li>
<li><a href="../es413275/index.html">Pruebas comparativas de parrillas para lograr el resultado más delicioso.</a></li>
<li><a href="../es413277/index.html">JSFiddle - nueva versión</a></li>
<li><a href="../es413279/index.html">La aplicación móvil calcula el contenido calórico de los platos en los restaurantes.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>