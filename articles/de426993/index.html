<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∂ üë´ üèîÔ∏è Muss ich C lernen, um zu verstehen, wie ein Computer funktioniert? üë®‚Äçüåæ ü§πüèº üçó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe oft geh√∂rt, dass Leute vorschlagen, C. zu studieren, um die Computerleistung zu verstehen. Ist das eine gute Idee? Sind sie sicher? Ich werde...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Muss ich C lernen, um zu verstehen, wie ein Computer funktioniert?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426993/">  Ich habe oft geh√∂rt, dass Leute vorschlagen, C. zu studieren, um die Computerleistung zu verstehen. Ist das eine gute Idee?  Sind sie sicher?  Ich werde die Schlussfolgerungen des Artikels sofort skizzieren, nur um absolute Klarheit zu schaffen: <br><br><ul><li>  In C funktioniert der Computer nicht. </li><li>  Ich glaube nicht, dass die meisten Leute w√∂rtlich sprechen, also spielt es keine Rolle. </li><li>  Wenn Sie den Kontext verstehen, kann das Lernen von C aus diesem Grund abh√§ngig von Ihren Zielen immer noch sinnvoll sein. </li></ul><br>  Ich habe vor, zwei weitere Artikel mit einer detaillierteren Erl√§uterung der Schlussfolgerungen zu schreiben, aber das reicht bereits aus.  F√ºgen Sie hier Links hinzu, wenn die Artikel erscheinen. <br><a name="habracut"></a><br>  Ich habe oft von Leuten geh√∂rt: <br><br><blockquote> Wenn Sie C studieren, k√∂nnen Sie verstehen, wie Computer funktionieren. </blockquote><br>  Ich denke nicht, dass die Idee anfangs falsch ist, aber sie hat einige Vorbehalte.  Wenn Sie sie im Auge behalten, k√∂nnte dies eine praktikable Strategie sein, um neue und wichtige Dinge zu lernen.  Ich sehe jedoch selten Leute, die diese Vorbehalte ausf√ºhrlich diskutieren. Deshalb schreibe ich diesen Artikel, um meiner Meinung nach einen sehr notwendigen Kontext zu bieten ... Wenn Sie dar√ºber nachdenken, C zu lernen, um zu verstehen, wie Ihr Computer funktioniert, dann ist dieser Artikel f√ºr Sie.  Ich hoffe, sie hilft dir dabei, es herauszufinden. <br><br><blockquote>  Bevor wir wirklich anfangen, m√∂chte ich noch etwas sagen: Wenn Sie C lernen wollen, dann lernen Sie!  Lernen ist gro√üartig.  Das Erlernen von C ist f√ºr mein Verst√§ndnis von Computer und meine Karriere sehr wichtig geworden.  Das Erlernen dieser Sprache und ihres Platzes in der Geschichte einer Programmiersprache macht Sie zu einem besseren Programmierer.  Sie brauchen keine Entschuldigung.  Lerne Dinge nur um zu lernen.  Dieser Artikel soll eine Richtlinie sein, um die Wahrheit zu verstehen. Er behandelt nicht, ob C studiert werden soll oder nicht. </blockquote><br>  Zun√§chst einmal, wem diese Idee allgemein empfohlen wird.  Wenn Sie versuchen, ‚Äûherauszufinden, wie Computer funktionieren‚Äú, ist es selbstverst√§ndlich, dass Sie dies derzeit nicht verstehen.  Welche Programmierer verstehen nicht, wie Computer funktionieren?  Ich habe im Grunde gesehen, dass dieses Gef√ºhl von Leuten kommt, die haupts√§chlich in dynamisch getippten ‚ÄûSkriptsprachen‚Äú wie Ruby, Python oder JavaScript programmieren.  Sie wissen angeblich nicht, wie Computer funktionieren, weil diese Sprachen in einer virtuellen Maschine funktionieren, in der nur die Semantik der virtuellen Maschine eine Rolle spielt.  Letztendlich besteht die gesamte Idee einer virtuellen Maschine darin, Portabilit√§t bereitzustellen.  Das Ziel besteht nicht darin, von den Ger√§ten abh√§ngig zu sein, auf denen die VM ausgef√ºhrt wird. <br><br>  Es gibt nur ein Problem: C funktioniert auch in einer virtuellen Maschine. <br><br><h3>  Abstrakte Maschine C. </h3><br>  Aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation C99</a> , Abschnitt 5.1.2.3, ‚ÄûProgrammausf√ºhrung‚Äú: <br><br><blockquote>  Die semantischen Beschreibungen in dieser Internationalen Norm beschreiben das Verhalten einer abstrakten Maschine, bei der Optimierungsprobleme nicht relevant sind. </blockquote><br>  Meiner Meinung nach ist dies beim Lernen von C am wichtigsten. Die Sprache beschreibt nicht ‚Äûwie ein Computer funktioniert‚Äú, sondern wie eine ‚Äûabstrakte C-Maschine‚Äú funktioniert.  Alles andere Wichtige ergibt sich aus diesem Konzept. <br><br><blockquote> Noch ein Hinweis: Hier habe ich C99 gew√§hlt, was nicht der neueste C-Standard ist. Warum?  Nun, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MSVC hat ... interessante C-Sprachunterst√ºtzung</a> und ich bin heutzutage ein Windows-Benutzer.  Ja, Sie k√∂nnen <code>clang</code> und <code>gcc</code> unter Windows ausf√ºhren.  Es gibt keinen so gro√üen Unterschied zwischen C89, C99 und C11, was das betrifft, wor√ºber wir sprechen.  Irgendwann muss man sich entscheiden.  Die hier erw√§hnte Version enth√§lt einige √Ñnderungen an der urspr√ºnglichen Spezifikation. </blockquote><br>  M√∂glicherweise haben Sie in Ihrem C-Vortrag einen anderen Satz geh√∂rt: ‚ÄûC ist ein tragbarer Assembler.‚Äú  Wenn Sie √ºber diesen Satz nachdenken, werden Sie verstehen, dass C nicht dem Betrieb eines Computers entsprechen kann, wenn dies zutrifft: Es gibt viele verschiedene Computer mit unterschiedlichen Architekturen.  Wenn C wie ein Assembler ist, der auf verschiedenen Computern mit unterschiedlichen Architekturen ausgef√ºhrt wird, kann es nicht gleichzeitig genau wie jeder dieser Computer funktionieren.  Er <i>muss</i> die Details verbergen, sonst ist er nicht tragbar! <br><br>  Trotzdem denke ich, dass diese Tatsache keine Rolle spielt, da sich die Leute kaum w√∂rtlich auf "C ist, wie der Computer funktioniert" beziehen.  Bevor wir darauf zur√ºckkommen, sprechen wir √ºber die abstrakte C-Maschine und warum viele diesen Aspekt von C nicht zu verstehen scheinen. <br><br><h3>  Exkurs: Warum irren sich die Menschen? </h3><br>  Ich kann nur √ºber meine Erfahrungen sprechen, obwohl es sicher nicht einzigartig ist. <br><br>  Ich habe GW-BASIC gelernt, dann C, dann C ++, dann Java.  Ich habe von Java geh√∂rt, bevor ich ungef√§hr 1999, vier Jahre nach seinem Erscheinen, anfing, es zu schreiben.  Das Marketing stellte zu dieser Zeit Java und C ++ aktiv gegen√ºber und konzentrierte sich auf die JVM als Plattform und auf die Tatsache, dass das Maschinenmodell sie von C ++ unterscheidet, weshalb C. Sun Microsystems nicht mehr existiert, aber der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spiegel</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pressemitteilung</a> erinnert uns daran: <br><br><blockquote>  Java-Anwendungen sind plattformunabh√§ngig.  Sie m√ºssen nur die Java Virtual Machine auf jede Plattform portieren.  Es fungiert als Interpreter zwischen dem Computer des Benutzers und der Java-Anwendung.  Eine in der Java-Umgebung geschriebene Anwendung kann √ºberall funktionieren, sodass Anwendungen nicht mehr auf mehrere Plattformen portiert werden m√ºssen. </blockquote><br>  Das Hauptmotto war "Einmal schreiben, √ºberall laufen".  Diese beiden S√§tze haben gezeigt, wie ich (und viele andere) Java verstanden habe und wie es sich von C ++ unterscheidet.  Java hat einen Interpreter, eine virtuelle Java-Maschine.  In C ++ gibt es keine virtuelle Maschine. <br><br>  Mit solch einem leistungsstarken Marketing ist die ‚Äûvirtuelle Maschine‚Äú in den K√∂pfen vieler Menschen zum Synonym f√ºr ‚Äûeine gro√üe Laufzeit und / oder einen gro√üen Interpreter‚Äú geworden.  Sprachen ohne diese Funktion waren zu stark an einen bestimmten Computer gebunden und mussten portiert werden, da sie nicht wirklich plattformunabh√§ngig waren.  Der Hauptgrund f√ºr die Existenz von Java war eine √Ñnderung dieses C ++ - Fehlers. <br><br><blockquote>  "Laufzeitumgebung", "virtuelle Maschine" und "abstrakte Maschine" sind unterschiedliche W√∂rter f√ºr dasselbe Grundkonzept.  Seitdem haben sie jedoch aufgrund einer geringf√ºgigen Abweichung bei der Umsetzung dieser Ideen unterschiedliche Konnotationen erhalten. </blockquote><br>  Ich pers√∂nlich glaube, dass dieses Marketing von 1995 der Grund ist, warum Programmierer die Natur von C immer noch falsch verstehen. <br><br>  Ist diese Aussage also falsch?  Warum sollte Sun Microsystems Millionen und Abermillionen Dollar f√ºr die F√∂rderung von L√ºgen ausgeben?  Wenn C auch auf einer abstrakten Maschine basiert, die plattform√ºbergreifende Portabilit√§t bietet, warum ben√∂tigen wir Java?  Ich denke, dies ist der Schl√ºssel zum Verst√§ndnis dessen, was Menschen wirklich meinen, wenn sie sagen: "C ist, wie der Computer funktioniert." <br><br><h3>  Was meinen die Leute wirklich? </h3><br>  Obwohl C im Kontext einer virtuellen Maschine arbeitet, unterscheidet es sich immer noch erheblich von Java-√§hnlichen Sprachen.  Sun hat nicht gelogen.  Um zu verstehen, m√ºssen Sie die Geschichte von C kennen. <br><br>  1969 schrieb Bell Labs ein Computer-Betriebssystem in Assemblersprache.  1970 wurde es UNIX genannt.  Im Laufe der Zeit kaufte Bell Labs immer mehr neue Computer, einschlie√ülich des PDP-11. <br><br>  Als es an der Zeit war, Unix auf PDP-11 zu portieren, entschieden sie sich f√ºr eine h√∂here Sprache, was zu dieser Zeit eine ziemlich radikale Idee war.  Stellen Sie sich vor, ich werde Ihnen heute sagen: ‚ÄûIch werde ein Betriebssystem in Java schreiben‚Äú - Sie werden wahrscheinlich lachen, obwohl die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Idee realisierbar ist</a> .  Die Situation (nach meinem Verst√§ndnis habe ich damals nicht gelebt) war ungef√§hr dieselbe.  Wir haben eine Sprache namens B in Betracht gezogen, die jedoch einige der Funktionen des PDP-11 nicht unterst√ºtzte. Daher haben sie einen Nachfolger geschaffen, indem sie ihn "C" nannten, da dies der n√§chste Buchstabe im Alphabet war. <br><br><blockquote>  Es gab keine Sprache "A";  B war erfolgreich mit BCPL (Basic Combined Programming Language). </blockquote><br>  1972 wurde der erste C-Compiler auf PDP-11 geschrieben und gleichzeitig UNIX in C umgeschrieben. Anfangs dachten sie nicht √ºber Portabilit√§t nach, aber C wurde ber√ºhmt, sodass C-Compiler auf andere Systeme portiert wurden. <br><br>  1978 erschien die erste Ausgabe des Buches "Programmiersprache C".  Das liebevoll als "K &amp; R" bezeichnete Buch √§hnelte nach den Namen seiner Autoren √ºberhaupt nicht der Spezifikation, sondern beschrieb gleichzeitig die Sprache hinreichend detailliert, wodurch auch andere versuchten, Compiler C zu schreiben. Sp√§ter wird diese "Version" "K &amp; R C" genannt. <br><br>  Als sich UNIX und C verbreiteten, wurden beide auf viele Computer portiert.  In den 70er und 80er Jahren wuchs ihre Hardware-Basis st√§ndig.  Genauso wie C erstellt wurde, weil B nicht alle Funktionen von PDP-11 unterst√ºtzte, verwendeten viele Compiler Spracherweiterungen.  Da es nur K &amp; R und keine Spezifikation gab, wurde dies als akzeptabel angesehen, solange die Erweiterungen ziemlich nahe beieinander lagen.  Bis 1983 verursachte das Fehlen jeglicher Standardisierung Probleme, weshalb ANSI ein Team zusammenstellte, um die Spezifikation vorzubereiten.  1989 kam der C89-Standard heraus, der manchmal als "ANSI C" bezeichnet wird. <br><br>  Spezifikation C hat versucht, diese verschiedenen Implementierungen auf verschiedener Hardware zu vereinheitlichen.  Somit ist die abstrakte C-Maschine eine Art kleinstm√∂gliche Spezifikation, die es erm√∂glichen w√ºrde, dass derselbe Code auf allen Plattformen gleich funktioniert.  C-Implementierungen wurden kompiliert, nicht interpretiert, daher gab es keinen Interpreter, daher gab es keine ‚ÄûVM‚Äú im Sinne von 1995.  C-Programme werden jedoch auf diesem abstrakten, nicht vorhandenen Computer geschrieben, und dann wird der Code in einen Assembler konvertiert, der f√ºr den bestimmten Computer spezifisch ist, auf dem das Programm ausgef√ºhrt wird.  Sie k√∂nnen sich beim Schreiben von portablem C-Code nicht auf bestimmte Details verlassen. Dies macht das Schreiben von portablem C sehr schwierig, da Sie beim Schreiben der ersten Version Ihres Codes m√∂glicherweise eine plattformspezifische Annahme getroffen haben. <br><br>  Dies l√§sst sich am besten anhand eines Beispiels veranschaulichen.  Einer der Hauptdatentypen in C ist <code>char</code> , vom Wort "Zeichen".  Die abstrakte C-Maschine bestimmt jedoch nicht, wie viele Bits in <code>char</code> .  Nun, bestimmt, aber nicht nach Anzahl;  Es bestimmt die Gr√∂√üe von <code>CHAR_BIT</code> , die eine Konstante ist.  Abschnitt 5.2.4.2.1 der Spezifikation: <br><br><blockquote>  Die unten angegebenen Werte sollten durch konstante Ausdr√ºcke ersetzt werden, die f√ºr die Vorverarbeitungsanweisungen <code>#if</code> geeignet sind oder verwendet werden. ... Die Werte in bestimmten Implementierungen sollten gleich oder gr√∂√üer (absoluter Wert) der hier angegebenen Werte mit demselben Vorzeichen sein. <br><br> <code>CHAR_BIT: 8</code> </blockquote> <br>  Mit anderen Worten, Sie wissen, dass <code>char</code> mindestens 8 Bit betr√§gt, die Implementierungen jedoch m√∂glicherweise gr√∂√üer sind.  Um eine "abstrakte C-Maschine" richtig zu codieren, muss bei der Verarbeitung von <code>char</code> <code>CHAR_BIT</code> anstelle von <code>8</code> als Gr√∂√üe verwendet werden.  Dies ist jedoch keine Art von Interpreterfunktion, da wir an virtuelle Maschinen denken.  Dies ist eine Eigenschaft, wie der Compiler Quellcode in Maschinencode √ºbersetzt. <br><br><blockquote>  Ja, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es gibt Systeme, bei</a> denen <code>CHAR_BIT</code> nicht <code>8</code> . </blockquote><br>  Daher ist diese "abstrakte Maschine", obwohl technisch dieselbe Idee wie die virtuelle Java-Maschine, eher ein Kompilierungskonstrukt zum Verwalten von Compilern beim Erstellen von Assembler-Code als eine Art Laufzeitpr√ºfung oder -eigenschaft.  Der √§quivalente Typ in Java ist ein <code>byte</code> , das immer 8 Bit betr√§gt, und die JVM-Implementierung hat die Aufgabe, was auf Plattformen mit mehr Bytes zu tun ist.  (Ich bin mir nicht sicher, ob die JVM auf einer dieser Plattformen funktioniert, aber so sollte es funktionieren.)  Die abstrakte C-Maschine wurde als minimaler Wrapper f√ºr verschiedene ‚ÄûHardware‚Äú erstellt und nicht als eine Art Plattform aus festem Stoff, die in Software f√ºr Ihren Code geschrieben wurde. <br><br>  Obwohl Sun technisch falsch war, bedeuten sie in der Praxis ein wenig von dem, was sie w√∂rtlich sagen, und was sie <i>bedeuten,</i> ist wahr.  Gleiches gilt f√ºr den Satz ‚ÄûLernen Sie C, um zu verstehen, wie Computer funktionieren‚Äú. <br><br><h3>  Lernen Sie C, um besser zu verstehen, wie Computer funktionieren </h3><br>  Was meinen <i>die</i> Leute <i>wirklich</i> ?  Im Zusammenhang mit ‚Äûsollte ein Rubist C lernen, um zu verstehen, wie Computer funktionieren‚Äú - dies ist ein Ratschlag, ‚Äûauf das Eisenniveau‚Äú zu gehen.  Das hei√üt, nicht nur zu verstehen, wie Ihr eigenes Programm in der virtuellen Maschine funktioniert, sondern auch, wie die Kombination aus Programm und VM im Kontext der Maschine selbst funktioniert. <br><br>  Wenn Sie C lernen <i>, erhalten</i> Sie mehr Details, da die abstrakte Maschine sowohl der Hardware als auch den Abstraktionen der Betriebssysteme viel n√§her kommt.  Die C-Sprache unterscheidet sich stark von Hochsprachen, so dass das Lernen viel lehren kann. <br><br>  Es ist jedoch wichtig, sich daran zu erinnern, dass C im Wesentlichen eine Hardware- <i>Abstraktion</i> ist und Abstraktionen nicht perfekt sind.  Seien Sie vorsichtig, was C macht oder wie es mit der Maschine selbst funktioniert.  Wenn Sie zu tief gehen, werden Sie sicherlich auf diese Unterschiede sto√üen, die Probleme verursachen k√∂nnen.  Die meisten Schulungsressourcen f√ºr C, insbesondere heute, wenn die Ger√§te homogener werden, f√∂rdern die Idee, dass ein Computer so funktioniert.  Daher kann es f√ºr einen Sch√ºler schwierig sein zu verstehen, was unter der Haube geschieht und welche Abstraktion von C. <br><br>  In dieser Diskussion haben wir nicht einmal andere Themen angesprochen.  Zum Beispiel ist die Hardware aufgrund der enormen Beliebtheit von C einheitlicher geworden, da sie sich tendenziell der Semantik der abstrakten C-Maschine n√§hert. Wenn sich Ihre Architektur zu stark von der C-Semantik unterscheidet, k√∂nnen C-Programme viel langsamer als andere ausgef√ºhrt werden. und die Hardwaregeschwindigkeit wird oft durch Tests in C gemessen. Dieser Artikel ist bereits ziemlich lang ... <br><br>  Aus diesem Grund denke ich, dass eine genauere Version dieser Aussage lautet: ‚ÄûWenn Sie C lernen, lernen Sie <i>mehr</i> √ºber die Funktionsweise von Computern.‚Äú  Ich denke wirklich, dass eine ungef√§hre Bekanntschaft mit C f√ºr viele Programmierer n√ºtzlich ist, auch wenn sie selbst kein C schreiben. Die Einf√ºhrung von C gibt Ihnen auch einen Eindruck von der Geschichte unserer Branche. <br><br>  Es gibt andere M√∂glichkeiten, dieses Thema zu untersuchen.  C <i>ist von Natur aus</i> nicht daf√ºr gedacht, etwas √ºber einen Computer zu lernen, aber es ist eine gute Option. <br><br>  In der Programmierung gibt es so viel zu lernen.  Ich w√ºnsche Ihnen viel Erfolg auf dieser Reise. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426993/">https://habr.com/ru/post/de426993/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426981/index.html">10 Tricks f√ºr erweitertes Dashboarding in Splunk. Teil 1</a></li>
<li><a href="../de426983/index.html">Neu in SObjectizer-5.5.23: Wunscherf√ºllung oder Pandoras Box?</a></li>
<li><a href="../de426985/index.html">Kubebox und andere Konsolen-Shells f√ºr Kubernetes</a></li>
<li><a href="../de426987/index.html">Lerne OpenGL. Lektion 6.3 - Bildbasierte Beleuchtung. Diffuse Bestrahlung</a></li>
<li><a href="../de426991/index.html">Startup Digest: 10 bevorstehende IT-Events in Moskau</a></li>
<li><a href="../de426995/index.html">Recycling schadet sowohl Produkten als auch Mitarbeitern</a></li>
<li><a href="../de426997/index.html">So erstellen Sie benutzerdefinierte Formen mit MaterialShapeDrawable</a></li>
<li><a href="../de426999/index.html">Den Trends folgen oder sich in Richtung RxJava und LiveData bewegen</a></li>
<li><a href="../de427003/index.html">Hexagon-Karten in Unity: Nebel des Krieges, Kartenforschung, prozedurale Generierung</a></li>
<li><a href="../de427005/index.html">KI-Entwickler - der Beruf der Million√§re?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>