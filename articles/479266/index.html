<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-143967986-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-143967986-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∫ üòë üòÉ Analysis of CPU load generated by individual JavaScript components üßõüèæ üé∂ üë©üèæ‚Äçü§ù‚Äçüë©üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let's talk a little about how to observe how much CPU resources the application JavaScript code consumes. At the same time, I propose to build our con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analysis of CPU load generated by individual JavaScript components</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/479266/">  Let's talk a little about how to observe how much CPU resources the application JavaScript code consumes.  At the same time, I propose to build our conversation around components - the basic building blocks of the application.  With this approach, any efforts to improve productivity (or efforts to find the causes of program slowdowns) can be concentrated on (hopefully) small, self-sufficient fragments of the project.  At the same time, I assume that your front-end application, like many other modern projects, was created by assembling small fragments of the interface suitable for repeated use.  If this is not so, then our reasoning can be applied to another application, but you will have to find your own way of dividing your large-scale code into fragments and you will need to think about how to analyze these fragments. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/479266/"><img src="https://habrastorage.org/webt/cx/wv/2y/cxwv2ylp34aq6hzys-fss3azza0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Why is this needed?</font> </h2><br>  Why measure CPU consumption by JavaScript?  The fact is that these days, application performance is most often tied to the capabilities of the processor.  Let me freely quote the words of Steve Soders and Pat Minan from an interview I took for <a href="https://podcast.perfplanet.com/">Planet Performance Podcast</a> .  Both said that application performance is no longer limited to network capabilities or network latencies.  Networks are getting faster and faster.  The developers, in addition, learned to compress the server text responses using GZIP (or, rather, using brotli) and figured out how to optimize the images.  It is all very simple. <br><br>  The performance bottleneck of modern applications is processors.  This is especially true in the mobile environment.  And at the same time, our expectations about the interactive capabilities of modern web applications have grown.  We expect that the interfaces of such applications will work very quickly and smoothly.  And all this requires more and more JavaScript code.  In addition, we need to remember that 1 MB of images is not the same as 1 MB of JavaScript.  Images are downloaded progressively, and the application at this time solves other problems.  But the JavaScript code is often such a resource, without which the application is inoperative.  To ensure the functioning of a modern application, large amounts of JS-code are required, which, before they really work, need to be parse and execute.  And these are tasks that depend heavily on the capabilities of the processor. <br><br><h2>  <font color="#3AC1EF">Performance indicator</font> </h2><br>  We will use such an indicator of the speed of code fragments as the number of processor instructions required to process them.  This will allow us to separate the measurements from the properties of a particular computer and from the state in which it is at the time of measurement.  Time-based metrics (like TTI) have too much ‚Äúnoise‚Äù.  They depend on the state of the network connection, as well as on anything else that happens on the computer at the time of measurement.  For example, some scripts executed during loading of the investigated page, or viruses that are busy with something in the background processes, can influence the temporal performance indicators.  The same can be said about browser extensions, which can consume a lot of system resources and slow down the page.  When calculating the number of processor instructions, on the other hand, the time does not matter.  Such indicators can be, as you will soon see, truly stable. <br><br><h2>  <font color="#3AC1EF">Idea</font> </h2><br>  Here is the idea underlying our work: we need to create a ‚Äúlaboratory‚Äù in which the code will be launched and examined when changes are made to it.  By "laboratory" I mean a regular computer, perhaps the one that you constantly use.  Version control systems give us at our disposal hooks with which you can intercept certain events and perform certain checks.  Of course, measurements in the ‚Äúlaboratory‚Äù can be performed after committing.  But you probably know that changes to code that has reached the commit stage will be made more slowly than to code that is being written (if at all).  The same applies to fixing the beta code of the product, and fixing the code that got into production. <br><br>  We need each time the code is changed, its performance be compared before and after changes are made.  In doing so, we strive to investigate components in isolation.  As a result, we will be able to clearly see the problems and be able to know exactly where they arise. <br><br>  The good thing is that such studies can be carried out in a real browser, using, for example, Puppeteer.  This is a tool that allows you to control the browser without a user interface from Node.js. <br><br><h2>  <font color="#3AC1EF">Search code for research</font> </h2><br>  In order to find the code for the study, we can refer to any style guide, or to any design system.  In general, we are happy with anything that provides brief, isolated examples of the use of components. <br><br>  What is a ‚Äústyle guide‚Äù?  This is usually a web application that demonstrates all the components or ‚Äúbuilding blocks‚Äù of user interface elements that are available to the developer.  It can be either a certain library of third-party components, or something created by your own efforts. <br><br>  While searching for such projects on the Internet, I came across a recent discussion <a href="https://twitter.com/toggleModal/status/1189913353902276608">thread</a> on Twitter that talked about relatively new libraries of React components.  I looked at several of the libraries mentioned there. <br><br>  Not surprisingly, modern high-quality libraries are provided with documentation that includes working code examples.  Here are a couple of libraries and <code>Button</code> components implemented by their means.  The documentation for these libraries contains examples of the use of these components.  We are talking about the Chakra library and the Semantic UI React library. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/95d/a0c/64c95da0c7b84620135e33e377c47bd2.png"></div><br>  <i><font color="#999999">Button Component Chakra Documentation</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d3/b45/093/7d3b45093ae1f8c6d99e174ca389a9e0.png"></div><br>  <i><font color="#999999">Button Semantic UI React Documentation</font></i> <br><br>  This is exactly what we need.  These are examples whose code we can examine for their consumption of processor resources.  Similar examples can be found in the bowels of the documentation, or in code comments written in the JSDoc style.  Perhaps, if you are lucky, you will find such examples, designed as separate files, say, in the form of unit test files.  Surely it will be so.  After all, we all write unit tests.  True? <br><br><h2>  <font color="#3AC1EF">Files</font> </h2><br>  Imagine, for the sake of demonstrating the described method of performance analysis, that there is a <code>Button</code> component in the library that we are studying, the code of which is in the <code>Button.js</code> file. The file with the <code>Button-test.js</code> unit test is attached to this file, as well as a file with an example of using the component - <code>Button-example.js</code> .  We need to create some kind of test page, in the environment of which test code can be run.  Something like <code>test.html</code> . <br><br><h2>  <font color="#3AC1EF">Component</font> </h2><br>  Here is a simple <code>Button</code> component.  I use React here, but your components can be written using any technology convenient for you. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Button = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span>  props.href    ? &lt;a {...props} className="Button"/&gt;    : &lt;button {...props} className="Button"/&gt; export default Button;</code> </pre> <br><h2>  <font color="#3AC1EF">Example</font> </h2><br>  And here is an example of using the <code>Button</code> component.  As you can see, in this case there are two component options that use different properties. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Button <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'Button'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> [  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> alert('ouch')}&gt;    Click me  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>,  &lt;Button href=<span class="hljs-string"><span class="hljs-string">"https://reactjs.com"</span></span>&gt;    Follow me  &lt;<span class="hljs-regexp"><span class="hljs-regexp">/Button&gt;, ]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Test</font> </h2><br>  Here is the <code>test.html</code> page that can load any components.  Notice the method calls to the <code>performance</code> object.  It is with their help that we, at our request, write to the Chrome performance log file.  Very soon we will use these records. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> examples =  <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(location.hash + <span class="hljs-string"><span class="hljs-string">'-example.js'</span></span>); examples.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">example</span></span></span><span class="hljs-function"> =&gt;</span></span>  performance.mark(<span class="hljs-string"><span class="hljs-string">'my mark start'</span></span>);  ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{example}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, where);  performance.mark(<span class="hljs-string"><span class="hljs-string">'my mark end'</span></span>);  performance.measure(    <span class="hljs-string"><span class="hljs-string">'my mark'</span></span>, <span class="hljs-string"><span class="hljs-string">'my mark start'</span></span>, <span class="hljs-string"><span class="hljs-string">'my mark end'</span></span>); );</code> </pre> <br><h2>  <font color="#3AC1EF">Test runner</font> </h2><br>  In order to load a test page in Chrome, we can use the <a href="https://github.com/GoogleChrome/puppeteer">Puppeteer</a> Node.js library, which gives us access to the API for managing the browser.  You can use this library on any operating system.  It has its own copy of Chrome, but it can also be used to work with an instance of Chrome or Chromium of various versions already existing on the developer's computer.  Chrome can be launched so that its window is invisible.  Tests are performed automatically, while the developer does not need to see the browser window.  Chrome can be launched in normal mode.  This is useful for debugging purposes. <br><br>  Here is an example Node.js script run from the command line that loads a test page and writes data to a performance log file.  Everything that happens in the browser between the <code>tracing.start()</code> and <code>end()</code> commands is written (I want to note, in great detail) to the <code>trace.json</code> file. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pup <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pup.launch(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.tracing.start({<span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'trace.json'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'test.html#Button'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.tracing.stop(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.close();</code> </pre> <br>  The developer can manage the "detail" of performance data by specifying the "categories" of tracing.  You can see the list of available categories if you go to Chrome at <code>chrome://tracing</code> , click <code>Record</code> and open the <code>Edit categories</code> section in the window that appears. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51e/047/a3e/51e047a3e5a8b6980192bc6eb6c3047a.png"></div><br>  <i><font color="#999999">Configuring the composition of data written to the performance log</font></i> <br><br><h2>  <font color="#3AC1EF">results</font> </h2><br>  After the test page is examined using Puppeteer, you can analyze the results of performance measurements by going to the browser at <code>chrome://tracing</code> and downloading the just recorded <code>trace.json</code> file. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63c/13b/47c/63c13b47c6bf063822716d5cf13d2830.png"></div><br>  <i><font color="#999999">Trace.json visualization</font></i> <br><br>  Here you can see the results of calling the <code>performance.measure('my mark')</code> method.  The <code>measure()</code> call is for debugging purposes only, in case the developer wants to open the <code>trace.json</code> file and see it.  Everything that happened with the page is enclosed in the block <code>my mark</code> . <br><br>  Here is a <code>trace.json</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b76/9ac/4a4/b769ac4a4abd96771a74255a12a4522c.png"></div><br>  <i><font color="#999999">Fragment of trace.json file</font></i> <br><br>  In order to find out what we need, it is enough to subtract the indicator of the number of processor instructions ( <code>ticount</code> ) of the <code>Start</code> marker from the same indicator of the <code>End</code> marker.  This allows you to find out how many processor instructions are needed to display the component in the browser.  This is the same number that you can use to find out if a component has become faster or slower. <br><br><h2>  <font color="#3AC1EF">The devil is in the details</font> </h2><br>  Now we have measured only indicators characterizing the first output to the page of a single component.  And nothing else.  It is imperative to measure indicators related to the smallest amount of code that can be executed.  This allows you to reduce the level of "noise".  The devil is in the details.  The smaller the performance of which is measured, the better.  After measurements, it is necessary to remove from the results obtained what is beyond the influence of the developer.  For example, data related to garbage collection operations.  The component does not control such operations.  If they are executed, this means that the browser, in the process of rendering the component, decided to launch them itself.  As a result, the processor resources that went to garbage collection should be removed from the final results. <br><br>  The data block related to garbage collection (this ‚Äúdata block‚Äù is more correctly called an ‚Äúevent‚Äù) is called <code>V8.GCScavenger</code> .  Its <code>tidelta</code> should be subtracted from the number of processor instructions that go into rendering the component.  <a href="https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview">Here is the</a> documentation for trace events.  True, it is outdated, and does not contain information about the indicators we need: <br><br><ul><li>  <code>tidelta</code> - the number of processor instructions required to process an event. </li><li>  <code>ticount</code> - the number of instructions to start the event. </li></ul><br>  You need to be very careful about what we are measuring.  Browsers are highly intelligent entities.  They optimize code that runs more than once.  In the next graph, you can see the number of processor instructions needed to output a certain component.  The first rendering operation requires the most resources.  Subsequent operations create a much lower load on the processor.  This should be borne in mind when analyzing code performance. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/880/329/857/880329857fe02edf503db2e4bff07380.png"></div><br>  <i><font color="#999999">10 rendering operations of the same component</font></i> <br><br>  Here is another detail: if the component performs some asynchronous operations (for example, it uses <code>setTimeout()</code> or <code>fetch()</code> ), then the load on the system created by the asynchronous code is not taken into account.  Maybe it's good.  Maybe it‚Äôs bad.  If you are investigating the performance of such components, consider a separate study of asynchronous code. <br><br><h2>  <font color="#3AC1EF">Strong signal</font> </h2><br>  If you take a responsible approach to resolving the issue of what exactly is being measured, then you can get a truly stable signal that reflects the impact on the performance of any changes.  I love the smoothness of the lines in the next graph. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/905/b1b/58b/905b1b58bd6e5fdbb34f4e0b0dedaebd.png"></div><br>  <i><font color="#999999">Stable measurement results</font></i> <br><br>  The bottom graph shows the measurement results of 10 rendering operations of a simple <code>&lt;span&gt;</code> element in React.  Nothing else is included in these results.  It turns out that this operation requires from 2.15 to 2.2 million processor instructions.  If you wrap the <code>&lt;span&gt;</code> in the <code>&lt;p&gt;</code> , then to output such a design you need about 2.3 million instructions.  This level of accuracy strikes me.  If a developer can see the performance difference that appears when a single <code>&lt;p&gt;</code> element is added to a page, this means that the developer has a really powerful tool in their hands. <br><br>  How exactly to represent measurements of such accuracy is up to the developer.  If he doesn‚Äôt need such accuracy, he can always measure the rendering performance of larger fragments. <br><br><h2>  <font color="#3AC1EF">Additional performance information</font> </h2><br>  Now that the developer has at his disposal a system for finding numerical indicators that accurately characterize the performance of the smallest fragments of code, the developer can use this system to solve various problems.  So, using <code>performance.mark()</code> you can write additional useful information to <code>trace.json</code> .  You can tell the members of the development team what is happening and what causes an increase in the number of processor instructions needed to execute some code.  You can include in the performance reports information about the number of DOM nodes, or about the number of write operations in the DOM performed by React.  In fact, here you can display information about a lot.  You can count the number of page layout recalculations.  Using Puppeteer you can take screenshots of pages and compare how the interface looks before and after making changes.  Sometimes the increase in the number of processor instructions needed to display a page looks completely unsurprising.  For example, if 10 buttons and 12 fields for editing and formatting text are added to the new version of the page. <br><br><h2>  <font color="#3AC1EF">Summary</font> </h2><br>  Is it possible for everyone that was discussed here to use it today?  Yes you can.  To do this, you need Chrome version 78 or higher.  If <code>trace.json</code> has <code>ticount</code> and <code>tidelta</code> , then the above is available to you.  Earlier versions of Chrome do not. <br><br>  Unfortunately, information about the number of processor instructions cannot be obtained on the Mac platform.  I have not tried Windows yet, so I can‚Äôt say anything definite about this OS.  In general - our friends are Unix and Linux. <br><br>  It should be noted that in order for the browser to be able to provide information on processor instructions, you will need to use a couple of flags - these are <code>--no-sandbox</code> and <code>--enable-thread-instruction-count</code> .  Here's how to pass them to a browser launched by Puppeteer: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch({  <span class="hljs-attr"><span class="hljs-attr">args</span></span>: [    <span class="hljs-string"><span class="hljs-string">'--no-sandbox'</span></span>,    <span class="hljs-string"><span class="hljs-string">'--enable-thread-instruction-count'</span></span>,  ]});</code> </pre> <br>  Hopefully now you can take your web application performance analysis to the next level. <br><br>  <b>Dear readers!</b>  Do you plan to use the methodology for analyzing the performance of web projects presented here? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub"><img src="https://habrastorage.org/webt/yx/3g/bv/yx3gbv0xlht1gyjfwlg2z_kgylo.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a href="https://habr.com/ru/post/479266/">https://habr.com/ru/post/479266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479250/index.html">How I learned to work with microcontrollers - a beginner's experience</a></li>
<li><a href="../479252/index.html">List Comprehension vs Map</a></li>
<li><a href="../479256/index.html">In the wake of the Astrotracker in Two Evenings - My Experience</a></li>
<li><a href="../479258/index.html">IGF 2019. Is the Internet falling apart?</a></li>
<li><a href="../479262/index.html">The digest of fresh materials from the world of the front-end for the last week No. 392 (December 2 - 8, 2019)</a></li>
<li><a href="../479268/index.html">Event Listeners and Web Workers</a></li>
<li><a href="../479270/index.html">What new can you expect from Node.js in 2020?</a></li>
<li><a href="../479272/index.html">[bookmark] 9 tools that increase web developer productivity</a></li>
<li><a href="../479274/index.html">10 Python Tricks to Know About</a></li>
<li><a href="../479276/index.html">Three Pandas Methods You May Not Know About</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter54458986 = new Ya.Metrika({
                  id:54458986,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/54458986" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-143967986-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=IU0EG0jaqnehka2lu5TyzAcchrZXI4Yb1QXKQvJxpqE&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>