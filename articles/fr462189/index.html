<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙏🏾 🤸🏽 🌽 Gravure de données avec travajs 💪🏿 👶🏼 🌥️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans mon article précédent, j'ai décrit les principaux points lors du développement d'une autre bibliothèque opensource . J'ai oublié de mentionner en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gravure de données avec travajs</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462189/"><img src="https://habrastorage.org/webt/kb/fw/tm/kbfwtmm5xe1jxdaa1l2avw8geuo.jpeg"><br><br>  Dans mon article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">précédent,</a> j'ai décrit les principaux points lors du développement d'une autre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bibliothèque opensource</a> .  J'ai oublié de mentionner encore une chose: si vous ne parlez à personne de la bibliothèque, quelle qu'elle soit, personne ne le saura probablement. <br><br>  Alors, rencontrez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trava.js</a> - une validation juteuse au profit du projet.  Soit dit en passant, nous utilisons de l'herbe depuis plus de six mois, et j'ai pensé qu'il était temps de vous parler des avantages de l'utiliser.  Déjà même séché, alors retenez votre souffle.  Et allez-y. <br><a name="habracut"></a><br><h2>  Concept </h2><br>  À première vue, il semble que la validation soit un sujet banal qui ne nécessite pas d'attention particulière.  La valeur est vraie ou non, ce qui pourrait être plus simple: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// any checking... if (!check(value)) return false; return true; }</span></span></code> </pre> <br>  Mais généralement, ce serait bien de savoir ce qui s'est exactement passé: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check1(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'ERROR_1'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check2(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'ERROR_2'</span></span>; }</code> </pre><br>  En fait, c'est tout, le problème est résolu. <br><br>  Sinon pour un «mais». <br><br>  De l'expérience du développement d'applications réelles, il a été remarqué que l'affaire ne s'arrête pas à la validation.  Habituellement, ces données doivent également être converties dans un format spécifique, pour une raison non prise en charge par le sérialiseur dès la sortie de l'emballage, par exemple, des dates, des ensembles ou d'autres types de données personnalisés.  Étant donné qu'il s'agit principalement de JSON, en pratique, il s'avère que vous devez effectuer un double passage dans la structure de données d'entrée lors de la validation et de la transformation.  L'idée est venue, pourquoi ne pas combiner ces deux étapes en une seule.  Un plus possible serait également la présence d'un schéma de données déclaratif explicite. <br><br>  Pour prendre en charge la conversion d'une valeur dans un format spécifique, le validateur doit pouvoir renvoyer non seulement une erreur, mais également une valeur réduite.  Dans le monde js, plusieurs options d'interface sont assez courantes avec des retours d'erreur possibles. <br><br><ol><li>  Le plus courant est probablement le retour du tuple [error, data]: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check1(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'ERROR_1'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check2(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'ERROR_2'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, value]; }</code> </pre> <br>  Il existe également une option similaire dans laquelle aucun tableau n'est renvoyé, mais l'objet <i>{error, data}</i> , mais il n'y a aucune différence fondamentale.  L'avantage de cette approche est l'évidence, l'inconvénient est que maintenant partout où vous devez maintenir ce contrat.  Pour la validation, cela ne cause aucun inconvénient, mais pour les transformations, cela est clairement superflu. <br></li><li>  Utilisez des exceptions.  Bien qu'à mon avis une erreur de validation soit une situation standard dans l'application, rien n'est exceptionnel.  Honnêtement, je pense que les exceptions ne sont mieux utilisées que lorsque quelque chose a vraiment mal tourné.  En outre, des exceptions peuvent être appelées accidentellement dans les valideurs eux-mêmes, et vous ne savez peut-être pas du tout que c'était une erreur dans le code, et non dans la valeur.  L'avantage de l'approche est la simplification de l'interface - maintenant, toujours la valeur est retournée de la manière habituelle, et l'erreur est levée comme exception. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Il existe une option</a> pour mettre une erreur dans une variable globale.  Mais je ne tirerais pas l'État inutilement. <br></li><li>  Utilisez un type distinct pour les erreurs.  Cela ressemble à l'option avec des exceptions, si vous leur enlevez le type d'erreur, mais ne le jetez pas. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check1(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Trava.ValidationError({ <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-number"><span class="hljs-number">401</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check2(value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Trava.ValidationError({ <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-number"><span class="hljs-number">405</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parseOrTransform(value); <span class="hljs-comment"><span class="hljs-comment">// apply some parse or transform }</span></span></code> </pre> <br></li></ol>  J'ai opté pour cette dernière option, bien que ce soit aussi un compromis, mais globalement pas mal.  <i>Trava.ValidationError est</i> proposé comme type d'erreur, qui hérite de l' <i>erreur</i> standard et ajoute la possibilité d'utiliser un type de données arbitraire pour signaler une erreur.  Il n'est pas nécessaire d'utiliser <i>Trava.ValidationError</i> , vous pouvez utiliser l' <i>erreur</i> standard, mais n'oubliez pas que le message d'erreur n'est que des chaînes. <br><br>  Pour résumer, nous pouvons dire que le validateur est une fonction propre et synchrone qui, en plus de la valeur, peut renvoyer une erreur.  Extrêmement simple.  Et cette théorie fonctionne bien sans bibliothèques.  Dans la pratique, les validateurs sont combinés en chaînes et hiérarchies, et ici l'herbe sera certainement utile. <br><br><h2>  La composition </h2><br>  La composition est peut-être le cas le plus courant de travailler avec des valideurs.  La mise en œuvre de la composition peut être différente.  Par exemple, dans les célèbres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bibliothèques</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">joi</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">v8n,</a> cela se fait à travers un objet et une chaîne de méthodes: <br><br><pre> <code class="javascript hljs">Joi.string().alphanum().min(<span class="hljs-number"><span class="hljs-number">0</span></span>).max(<span class="hljs-number"><span class="hljs-number">255</span></span>)</code> </pre> <br>  Bien qu'elle soit belle à première vue, cette approche présente plusieurs inconvénients, dont l'un est fatal.  Et voici la chose.  D'après mon expérience, un validateur est toujours une chose pour une application spécifique, donc l'accent principal dans la bibliothèque devrait être sur la commodité d'étendre les validateurs et l'intégration avec l'approche existante, et non sur le nombre de primitives de base, qui, à mon avis, ne font qu'ajouter du poids à la bibliothèque, mais la plupart ne seront pas utilisés.  Prenons par exemple le même validateur pour la chaîne.  Ensuite, il s'avère que vous devez couper les espaces à partir des extrémités, puis soudain, vous devez autoriser l'utilisation de caractères spéciaux dans un seul cas, et quelque part, vous devez conduire à des minuscules, etc.  En fait, il peut y avoir une infinité de telles primitives, et je ne vois tout simplement pas l'intérêt de commencer à les ajouter à la bibliothèque.  À mon avis, l'utilisation d'objets est également redondante et entraîne une augmentation de la complexité lors de l'expansion, même si à première vue elle semble faciliter la vie.  Par exemple, c <i>joi n'est</i> pas si facile <a href="">d'écrire votre validateur</a> . <br><br>  Une approche fonctionnelle et de l'herbe ici peuvent aider.  Le même exemple de validation d'un nombre spécifié dans la plage de 0 à 255: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    const isNumber = n =&gt; typeof n == 'number' &amp;&amp; !isNaN(n); //  const numberValidator = Trava.Check(isNumber); const byteValidator = Trava.Compose([ numberValidator, Trava.Check(n =&gt; 0 &lt;= n &amp;&amp; n &lt; 256), ]); byteValidator(-1); // !</span></span></code> </pre><br>  L'instruction <b>Check</b> fait un validateur de la vérification de la vérité (valeur =&gt; vrai / faux).  Et <b>Compose enchaîne les</b> validateurs.  Une fois exécutée, la chaîne est interrompue après la première erreur.  L'important est que les fonctions ordinaires soient utilisées partout, ce qui est très simple à développer et à utiliser.  C'est cette facilité d'expansion, à mon avis, qui est une caractéristique clé d'une bibliothèque de validation valide. <br><br>  Traditionnellement, une place distincte dans la validation est occupée par la vérification de la valeur <i>nulle</i> et <i>non définie</i> .  Il y a des opérateurs auxiliaires dans l'herbe pour cela: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   null  undefined const requiredNumberValidator = Trava.Required(numberValidator); requiredNumberValidator(undefined); // ! const optNumberValidator = Trava.Optional(numberValidator, 2); // 2 is default optNumberValidator(undefined); // 2 optNumberValidator(null); // null const nullNumberValidator = Trava.Nullable(numberValidator, 3); // 3 is default nullNumberValidator(undefined); // 3 nullNumberValidator(null); // 3</span></span></code> </pre><br>  Il y a plusieurs autres opérateurs auxiliaires dans l'herbe, et ils composent tous magnifiquement et étonnamment simplement se développent.  Comme les fonctions ordinaires :) <br><br><h2>  Hiérarchie </h2><br>  Les types de données simples sont organisés dans une hiérarchie.  Les cas les plus courants sont les objets et les tableaux.  Il y a des opérateurs dans l'herbe qui facilitent le travail avec eux: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const byteArrayValidator = Trava.Each(byteValidator); byteArrayValidator([1, -1, 2, -3]); // ValidationError: {"1":"Incorrect value","3":"Incorrect value"} //   const pointValidator = Trava.Keys({ x: numberValidator, y: numberValidator, }); pointValidator({x: 1, y: 'a'}); // ValidationError: {"y":"Incorrect value"}</span></span></code> </pre><br>  Lors de la validation des objets, il a été décidé de souligner la sévérité de la définition: toutes les clés sont requises par défaut (encapsulées dans <b>Obligatoire</b> ).  Les clés non spécifiées dans le validateur sont supprimées. <br><br>  Certains <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jsonschema</a> , solutions de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quatuor</a> préfèrent décrire les validateurs sous forme de données, par exemple {x: 'nombre', y: 'nombre'}, mais cela conduit aux mêmes difficultés lors de l'expansion.  Un avantage significatif de cette approche est la possibilité de sérialisation et d'échange de circuits, ce qui est impossible avec des fonctions.  Cependant, cela peut être facilement implémenté au-dessus de l'interface fonctionnelle.  Pas besoin de cacher les fonctions derrière les lignes!  Les fonctions ont déjà des noms et c'est tout ce qui est nécessaire. <br><br>  Pour faciliter l'utilisation à l'intérieur des valideurs, les opérateurs <b>Composer</b> et <b>Clés</b> peuvent être omis; il est également pratique d'envelopper le validateur racine dans <b>Trava</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pointValidator = Trava({ <span class="hljs-comment"><span class="hljs-comment">//  -&gt; Keys x: [numberValidator, Trava.Check(v =&gt; v &gt; 180)], //  -&gt; Compose y: [numberValidator, Trava.Check(v =&gt; v &lt; 180)], });</span></span></code> </pre> <br>  Si vous appelez <b>Trava</b> avec le deuxième argument, la valeur de retour sera le résultat de l'application du validateur: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> point = Trava({ <span class="hljs-attr"><span class="hljs-attr">x</span></span>: [numberValidator, Trava.Check(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> v &gt; <span class="hljs-number"><span class="hljs-number">180</span></span>)], <span class="hljs-attr"><span class="hljs-attr">y</span></span>: [numberValidator, Trava.Check(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> v &lt; <span class="hljs-number"><span class="hljs-number">180</span></span>)], }, <span class="hljs-comment"><span class="hljs-comment">//      { x: 200, y: 100, }); // { x: 200, y: 100 }</span></span></code> </pre> <br>  Jusqu'à présent, la prise en charge a été implémentée uniquement pour les tableaux et les objets, comme  empoisonner JSON et ça suffit.  Tirez les demandes de Wellcome! <br><br><h2>  Contexte </h2><br>  Lorsque vous utilisez le validateur comme dernier paramètre, vous pouvez passer le contexte qui sera accessible à partir de tous les validateurs appelés comme dernier paramètre.  Personnellement, cette opportunité ne m'a pas encore été utile, mais elle est possible. <br><br>  Pour certains validateurs qui peuvent renvoyer une erreur, il est possible de définir un message d'erreur à différents niveaux.  Un exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pos = Trava.Check(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> v &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); pos(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ValidationError: "Incorrect value" (by default)</span></span></code> </pre><br>  Remplacer pour un seul cas: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pos = Trava.Check(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> v &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"    "</span></span>); pos(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ValidationError: "    "</span></span></code> </pre><br>  Remplacer pour tous les cas: <br><br><pre> <code class="javascript hljs">Trava.Check.ErrorMessage = <span class="hljs-string"><span class="hljs-string">" "</span></span>; pos(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ValidationError: " "</span></span></code> </pre><br>  De plus, pour une configuration plus détaillée, vous pouvez transférer une fonction à l'endroit de l'erreur, qui devrait retourner une erreur et sera appelée avec les paramètres du validateur. <br><br><h2>  Cas d'utilisation </h2><br>  La plupart du temps, nous empoisonnons JSON sur le backend avec koa.  Le frontend s'assoit également lentement.  Il est pratique d'avoir des valideurs communs aux deux extrémités.  Et maintenant, je vais montrer un cas d'utilisation presque réel.  Supposons que vous souhaitiez implémenter une API pour créer et mettre à jour les données des patients. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// validators.js const trava = require('trava'); const { isFilledString, isDate, isNumber } = require('../common/validators'); const patientSchema = { name: isFilledString, dateOfBirth: isDate, height: isNumber, } //        //      const patientNew = trava(patientSchema); //      const patientPatch = trava(mapValues(patientSchema, trava.Optional)); module.exports = { patientNew, patientPatch, }; // controllers.js const validate = require('./validators'); const { ValidationError } = require('../common/errors'); function create (ctx) { const patientData = validate.patientNew(ctx.request.body); //       Error,             Error if (patientData instanceof Error) return ValidationError(ctx, patientData); // ...create new patient } function update (ctx) { const patientData = validate.patientPatch(ctx.request.body); if (patientData instanceof Error) return ValidationError(ctx, patientData); // ...update patient data }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">common / errors.js</b> <div class="spoiler_text">  const trava = require ('trava'); <br><br>  fonction ValidationError (ctx, params) { <br>  if (params instanceof Error) { <br>  params = trava.ValidationError.extractData (params); <br>  } <br>  ctx.body = { <br>  code: 'VALIDATION_ERROR', <br>  params, <br>  }; <br>  ctx.status = HttpStatus.BAD_REQUEST; <br>  } <br></div></div><br>  Bien que l'exemple soit très simple, il ne peut pas être qualifié de simplifié.  Dans une application réelle, seuls les valideurs seront compliqués.  Vous pouvez également effectuer la validation dans un middleware - le validateur est appliqué entièrement au contexte ou au corps de la requête. <br><br>  Dans le processus de travail et d'utilisation de la validation, nous sommes arrivés à la conclusion que de simples valideurs synchrones et de simples messages d'erreur suffisent.  En fait, nous sommes arrivés à la conclusion que nous n'utilisons que deux messages: «REQUIS» et «INVALIDE», qui sont localisés sur le frontend avec des invites pour les champs.  Les autres vérifications qui nécessitent des actions supplémentaires (par exemple, lors de l'inscription pour vérifier qu'un tel courrier existe déjà) n'entrent pas dans le cadre de la validation.  En tout cas, l'herbe ne concerne pas ce cas. <br><br><h2>  En conclusion </h2><br>  Dans ce court article, j'ai décrit presque toutes les fonctionnalités de la bibliothèque, en dehors de la portée de l'article, il existe plusieurs assistants simplifiant la vie.  Je demande des détails sur github <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/uNmAnNeR/travajs</a> . <br><br>  Nous avions besoin d'un outil aussi personnalisable que possible, dans lequel il n'y a rien de superflu, mais en même temps il y a tout le nécessaire pour le travail quotidien.  Et je pense qu'en général cela a été réalisé, j'espère que quelqu'un facilitera également la vie.  Je serai heureux de souhaits et suggestions. <br>  Pour la santé. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462189/">https://habr.com/ru/post/fr462189/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462175/index.html">Nous traitons les abréviations et les expressions latines en anglais</a></li>
<li><a href="../fr462177/index.html">Visite photographique du musée minéralogique du nom de Fersman</a></li>
<li><a href="../fr462179/index.html">Chaînes F ou comment rendre le code un peu plus rapide et plus lisible</a></li>
<li><a href="../fr462181/index.html">Règles pour une communication efficace dans les chats de groupe</a></li>
<li><a href="../fr462185/index.html">La révolution est finie. Existe-t-il une alternative à une batterie lithium-ion?</a></li>
<li><a href="../fr462191/index.html">Musée DataArt: visite du nord de l'Italie</a></li>
<li><a href="../fr462197/index.html">Conseils pour libérer votre esprit et augmenter votre créativité</a></li>
<li><a href="../fr462203/index.html">KVM (sous) VDI avec des machines virtuelles uniques utilisant bash</a></li>
<li><a href="../fr462205/index.html">Gagner PHDays 9 The Standoff: la chronique de l'équipe True0xA3</a></li>
<li><a href="../fr462209/index.html">Solutions de vidéoconférence Polycom. Des souvenirs 6 ans plus tard ... Étape 2. Partie 1. RMX1500</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>