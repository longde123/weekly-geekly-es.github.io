<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👧‍👦 👨🏽 ⛈️ Pengalaman menggunakan redux tanpa reduksi 📘 👩🏼‍🤝‍👨🏾 🍍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya ingin berbagi pengalaman menggunakan redux dalam aplikasi perusahaan. Berbicara tentang perangkat lunak perusahaan sebagai bagian dari artikel, s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengalaman menggunakan redux tanpa reduksi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424613/"><img src="https://habrastorage.org/webt/nn/at/cx/nnatcxzguqw8cg7b1nx315f3c8y.jpeg"><br><br>  Saya ingin berbagi pengalaman menggunakan redux dalam aplikasi perusahaan.  Berbicara tentang perangkat lunak perusahaan sebagai bagian dari artikel, saya fokus pada fitur-fitur berikut: <br><br><ul><li>  Pertama, ini adalah volume fungsionalitas.  Ini adalah sistem yang telah dikembangkan selama bertahun-tahun, terus membangun modul baru, atau menyulitkan apa yang sudah ada di sana tanpa batas. </li><li>  Kedua, sering, jika kita mempertimbangkan bukan layar presentasi, tetapi tempat kerja seseorang, maka sejumlah besar komponen yang terpasang dapat dipasang pada satu halaman. </li><li>  Ketiga, kompleksitas logika bisnis.  Jika kita ingin mendapatkan aplikasi yang responsif dan menyenangkan untuk digunakan, sebagian besar dari logika harus dilakukan oleh klien. </li></ul><br>  Dua poin pertama memberlakukan pembatasan pada margin produktivitas.  Lebih lanjut tentang ini nanti.  Dan sekarang, saya mengusulkan untuk membahas masalah yang Anda temui menggunakan alur kerja redux klasik, mengembangkan sesuatu yang lebih rumit daripada daftar TODO. <br><a name="habracut"></a><br><h3>  Redux klasik </h3><br>  Sebagai contoh, pertimbangkan aplikasi berikut: <br><br><img src="https://image.ibb.co/ej3Pwp/1.png" alt="gambar"><br><br>  Pengguna menggerakkan sajak - mendapat penilaian tentang bakatnya.  Kontrol dengan pengenalan ayat dikontrol dan perhitungan kembali penilaian terjadi untuk setiap perubahan.  Ada juga tombol di mana teks dengan hasil diatur ulang, dan pesan ditampilkan kepada pengguna yang dapat ia mulai dari awal.  Kode sumber di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utas</a> ini. <br><br>  Organisasi Kode: <br><br><img src="https://image.ibb.co/dyXv2U/2.png" alt="gambar"><br><br>  Ada dua modul.  Lebih tepatnya, satu modul secara langsung adalah poemScoring.  Dan akar aplikasi dengan fungsi umum untuk seluruh sistem adalah aplikasi.  Di sana kami memiliki informasi tentang pengguna, menampilkan pesan kepada pengguna.  Setiap modul memiliki reduksi, aksi, kontrol, dll. Seiring dengan bertambahnya aplikasi, modul-modul baru bertambah banyak. <br><br>  Rangkaian reduksi, menggunakan redux-immutable, membentuk kondisi sepenuhnya tidak berubah berikut ini: <br><br><img src="https://image.ibb.co/nFrYp9/3.png" alt="gambar"><br><br>  Cara kerjanya: <br><br>  1. Kontrol tindakan-pencipta pengiriman: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> at <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../constants/actionTypes'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poemTextChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getstate</span></span></span><span class="hljs-function">) </span></span>{ dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: at.POEM_TYPE, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: text }); }; }</code> </pre> <br>  Konstanta jenis tindakan dipindahkan ke file terpisah.  Pertama, kami sangat aman dari kesalahan ketik.  Kedua, Intellisense akan tersedia untuk kita. <br><br>  2. Kemudian datang ke peredam. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> logic <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../logic/poem'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poemScoringReducer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state = Immutable.Map(</span></span></span><span class="hljs-function">), </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> at.POEM_TYPE: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> logic.onType(state, action.payload); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre> <br>  Pemrosesan logika dipindahkan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi case</a> terpisah.  Jika tidak, kode peredam akan dengan cepat menjadi tidak dapat dibaca. <br><br>  3. Logika pemrosesan klik menggunakan analisis leksikal dan kecerdasan buatan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { onType(state, text) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state .set(<span class="hljs-string"><span class="hljs-string">'poemText'</span></span>, text) .set(<span class="hljs-string"><span class="hljs-string">'score'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.calcScore(text)); }, calcScore(text) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> score = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(text.length / <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> score &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> ? <span class="hljs-number"><span class="hljs-number">5</span></span> : score; } };</code> </pre> <br>  Dalam kasus tombol "Puisi baru", kami memiliki pencipta aksi berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newPoem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getstate</span></span></span><span class="hljs-function">) </span></span>{ dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: at.POEM_TYPE, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }); dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: appAt.SHOW_MESSAGE, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: <span class="hljs-string"><span class="hljs-string">'You can begin a new poem now!'</span></span> }); }; }</code> </pre> <br>  Pertama, kirim tindakan yang sama dengan yang mengatur ulang teks dan skor kami.  Kemudian, kirim tindakan, yang akan ditangkap oleh peredam lain dan menampilkan pesan kepada pengguna. <br>  Semuanya indah.  Mari kita buat masalah untuk diri kita sendiri: <br><br><h3>  Masalahnya: </h3><br>  Kami telah memposting aplikasi kami.  Tetapi pengguna kami, melihat bahwa mereka diminta untuk menulis puisi, secara alami mulai memposting karya mereka, yang tidak sesuai dengan standar korporat bahasa puisi.  Dengan kata lain, kita perlu memoderasi kata-kata cabul. <br><br>  Apa yang akan kita lakukan: <br><br><ul><li>  dalam teks input, perlu untuk mengganti semua kata yang tidak berbudaya dengan <b>* disensor *</b> </li><li>  selain itu, jika pengguna telah menggerakkan kata kotor, Anda perlu memperingatkannya dengan pesan bahwa ia melakukan kesalahan. </li></ul><br>  Bagus  Kami hanya perlu menganalisis teks, selain menghitung skor, untuk mengganti kata-kata buruk.  Tidak masalah  Dan juga, untuk memberi tahu pengguna, Anda perlu daftar apa yang kami hapus.  Kode sumber ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Kami membuat kembali fungsi logika sehingga, di samping status baru, mengembalikan informasi yang diperlukan untuk pesan kepada pengguna (kata yang diganti): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { onType(state, text) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { reductedText, censoredWords } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.redactText(text); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newState = state .set(<span class="hljs-string"><span class="hljs-string">'poemText'</span></span>, reductedText) .set(<span class="hljs-string"><span class="hljs-string">'score'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.calcScore(reductedText)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { newState, censoredWords }; }, calcScore(text) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> score = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(text.length / <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> score &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> ? <span class="hljs-number"><span class="hljs-number">5</span></span> : score; }, redactText(text) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = { <span class="hljs-attr"><span class="hljs-attr">reductedText</span></span>:text }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> censoredWords = []; obscenseWords.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">badWord</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.reductedText.indexOf(badWord) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { result.reductedText = result.reductedText.replace(badWord, <span class="hljs-string"><span class="hljs-string">'*censored*'</span></span>); censoredWords.push(badWord); } }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (censoredWords.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { result.censoredWords = censoredWords.join(<span class="hljs-string"><span class="hljs-string">' ,'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } };</code> </pre> <br>  Mari kita terapkan sekarang.  Tapi bagaimana caranya?  Dalam peredam, tidak masuk akal bagi kita untuk memanggilnya lagi, karena kita akan meletakkan teks dan evaluasi di negara bagian, tetapi apa yang harus dilakukan dengan pesan?  Untuk mengirim pesan, dalam hal apa pun, kami harus mengirim tindakan yang sesuai.  Jadi, kami sedang menyelesaikan aksi-pencipta. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poemTextChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getState</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> globalState = getState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> scoringStateOld = globalState.get(<span class="hljs-string"><span class="hljs-string">'poemScoring'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//        const { newState, censoredWords } = logic.onType(scoringStateOld, text); dispatch({ //        type: at.POEM_TYPE, payload: newState }); if (censoredWords) { //    ,    const userName = globalState.getIn(['app', 'account', 'name']); const message = `${userName}, avoid of using word ${censoredWords}, please!`; dispatch({ type: appAt.SHOW_MESSAGE, payload: message }); } }; }</span></span></code> </pre> <br>  Ini juga diperlukan untuk memodifikasi reducer, karena tidak lagi memanggil fungsi logika: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> at.POEM_TYPE: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action.payload; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state;</code> </pre> <br>  Apa yang terjadi: <br><br><img src="https://image.ibb.co/nkmzU9/4.png" alt="gambar"><br><br>  <b>Dan sekarang, pertanyaannya adalah.</b>  Mengapa kita memerlukan peredam yang, sebagian besar, hanya akan mengembalikan muatan alih-alih negara baru?  Ketika tindakan lain muncul yang memproses logika dalam tindakan, apakah perlu mendaftarkan jenis tindakan baru?  Atau mungkin membuat satu SET_STATE yang umum?  Mungkin tidak, karena itu, inspektur akan berantakan.  Jadi kami akan memproduksi kasing yang sama? <br><br>  Inti dari masalah adalah sebagai berikut.  Jika pemrosesan logika melibatkan bekerja dengan sepotong negara, yang bertanggung jawab atas beberapa peredam, maka Anda harus menulis segala macam penyimpangan.  Sebagai contoh, hasil antara fungsi kasus, yang kemudian harus tersebar di berbagai reduksi menggunakan beberapa tindakan. <br><br>  Situasi serupa, jika fungsi case membutuhkan lebih banyak informasi daripada apa yang ada di peredam Anda, Anda harus melakukan seruannya ke tindakan, di mana ada akses ke negara global, diikuti dengan mengirim negara baru sebagai muatan.  Pengecil harus dibagi dalam hal apa pun, jika ada banyak logika dalam modul.  Dan ini menciptakan ketidaknyamanan yang luar biasa. <br><br>  Mari kita lihat situasi di satu sisi.  Dalam aksi kami, kami mendapat bagian dari dunia.  Ini diperlukan untuk <i>mengubahnya</i> ( <i>globalState.get ('poemScoring');</i> ).  Ternyata kita sudah tahu apa yang terjadi dengan negara bagian itu.  Kami memiliki negara bagian baru.  Kami tahu di mana harus meletakkannya.  Tetapi alih-alih memasukkannya ke dalam global, kami menjalankannya dengan semacam teks konstan di seluruh kaskade pereduksi sehingga melewati setiap sakelar dan menggantinya hanya sekali.  Saya dari realisasi ini, keriput.  Saya mengerti bahwa ini dilakukan untuk kemudahan pengembangan dan untuk mengurangi konektivitas.  Tetapi dalam kasus kami, itu tidak lagi memiliki peran. <br><br>  <b>Sekarang, saya akan mencantumkan semua poin yang tidak saya sukai dalam implementasi saat ini, jika harus ditingkatkan secara luas dan mendalam untuk waktu yang tidak terbatas</b> : <br><br><ol><li>  Ketidaknyamanan yang signifikan saat bekerja dengan kondisi di luar peredam. </li><li>  Masalah pemisahan kode.  Setiap kali kami mengirim tindakan, ia akan melewati setiap peredam, melewati setiap kasus.  Lebih mudah untuk tidak repot ketika Anda memiliki aplikasi kecil.  Tetapi, jika Anda memiliki monster yang dibangun selama beberapa tahun dengan puluhan reduksi dan ratusan case, maka saya mulai berpikir tentang kelayakan pendekatan semacam itu.  Mungkin, bahkan dengan ribuan kasus, ini tidak akan berdampak signifikan pada kinerja.  Tapi, memahami bahwa ketika mencetak teks, setiap pers akan menyebabkan bagian melalui ratusan kasus, saya tidak bisa membiarkannya apa adanya.  Apa pun, kelambanan terkecil, dikalikan dengan tak terhingga, cenderung tak terhingga.  Dengan kata lain, jika Anda tidak memikirkan hal-hal seperti itu, cepat atau lambat, masalah akan muncul. <br><br>  Apa saja pilihannya? <br><br>  <b>a.</b>  Aplikasi yang terisolasi dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyedia</a> mereka sendiri.  Di setiap modul (sub-aplikasi), Anda harus menduplikasi bagian umum negara bagian (akun, pesan, dll.). <br><br>  <b>b.</b>  Gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">reduksi asinkron yang dapat dicolokkan</a> .  Ini tidak direkomendasikan oleh Dan sendiri. <br><br>  <b>c.</b>  Gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">filter aksi</a> dalam reduksi.  Artinya, setiap pengiriman harus disertai dengan informasi tentang modul mana ia dikirim.  Dan di root reducers dari modul, tulis kondisi yang sesuai.  Saya sudah mencoba.  Tidak ada jumlah kesalahan tidak disengaja baik sebelum atau sesudah.  Ada kebingungan konstan tentang ke mana tindakan itu berlangsung. </li><li>  Setiap kali suatu tindakan dikirimkan, tidak hanya ada lari untuk setiap peredam, tetapi juga koleksi keadaan terbalik.  Tidak masalah jika negara telah berubah di reducer - itu akan diganti dalam CombedReducers. </li><li>  Setiap pengiriman memaksa mapStateToProps untuk diproses untuk setiap komponen yang terpasang yang dipasang pada halaman.  Jika kita membagi reduksi, kita harus membagi pengiriman.  Apakah penting bahwa kita memiliki tombol yang menimpa teks dan menampilkan pesan dengan kiriman yang berbeda?  Mungkin tidak.  Tetapi saya memiliki pengalaman pengoptimalan, ketika mengurangi jumlah pengiriman dari 15 menjadi 3 memungkinkan untuk secara signifikan meningkatkan respons sistem, dengan jumlah yang sama dari logika bisnis yang diproses.  Saya tahu bahwa ada perpustakaan yang dapat menggabungkan beberapa pengiriman menjadi satu batch, tetapi ini merupakan perjuangan dengan investigasi menggunakan kruk. </li><li>  Saat menghancurkan pengiriman, terkadang sangat sulit untuk melihat apa yang terjadi.  Tidak ada satu tempat, semuanya tersebar di file yang berbeda.  Penting untuk mencari di mana pemrosesan dilaksanakan dengan mencari konstanta dalam semua kode sumber. </li><li>  Dalam kode di atas, komponen dan tindakan mengakses status global secara langsung: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userName = globalState.getIn([<span class="hljs-string"><span class="hljs-string">'app'</span></span>, <span class="hljs-string"><span class="hljs-string">'account'</span></span>, <span class="hljs-string"><span class="hljs-string">'name'</span></span>]); … <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> text = state.getIn([<span class="hljs-string"><span class="hljs-string">'poemScoring'</span></span>, <span class="hljs-string"><span class="hljs-string">'poemText'</span></span>]);</code> </pre> <br>  Ini tidak baik karena beberapa alasan: <br><br>  <b>a.</b>  Modul idealnya harus diisolasi.  Mereka tidak perlu tahu di negara bagian mana mereka tinggal. <br><br>  <b>b.</b>  Menyebutkan jalur yang sama di tempat yang berbeda seringkali penuh tidak hanya dengan kesalahan / kesalahan ketik, tetapi juga membuat refactoring sangat sulit jika mengubah konfigurasi negara global, atau mengubah cara penyimpanannya. <br></li><li>  Semakin banyak, saat menulis tindakan baru, saya mendapat kesan bahwa saya sedang menulis kode demi kode.  Misalkan kita ingin menambahkan kotak centang ke halaman dan mencerminkan keadaan boolean dalam cerita.  Jika kita menginginkan organisasi aksi / reduksi yang seragam, maka kita harus: <br><br>  - Mendaftar konstan aksi-jenis <br>  - Tulis kawah aksi <br>  - Dalam kontrol, impor dan daftarkan di mapDispatchToProps <br>  - Mendaftar di PropTypes <br>  - Buat handleCheckBoxClick di kontrol dan tentukan di kotak centang <br>  - Tambahkan saklar di peredam dengan panggilan fungsi kasus <br>  - Tulis fungsi case dalam logika <br><br>  Demi satu cek tinju! </li><li>  Status yang dihasilkan dengan CombedRers bersifat statis.  Tidak masalah apakah Anda sudah masuk modul B atau tidak, bagian ini akan ada dalam cerita.  Kosong, tetapi akan.  Tidak nyaman menggunakan inspektur saat ada banyak simpul kosong yang tidak digunakan di steet. </li></ol><br><h3>  Cara kami mencoba menyelesaikan beberapa masalah yang dijelaskan di atas </h3><br>  Jadi, kami mendapat reduksi bodoh, dan dalam action-craters / logic kami menulis footpieces kode untuk bekerja dengan struktur immutable yang tertanam dalam.  Untuk menghilangkan ini, saya menggunakan mekanisme penyeleksi hierarkis, yang memungkinkan tidak hanya akses ke bagian negara yang diinginkan, tetapi juga menggantinya (setIn nyaman).  Saya menerbitkan ini dalam paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyeleksi yang tidak dapat diubah</a> . <br><br>  <b>Mari kita lihat contoh cara kerjanya</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> ): <br>  Dalam modul poemScoring, kami menjelaskan objek penyeleksi.  Kami menjelaskan bidang-bidang tersebut dari keadaan yang ingin kami akses langsung baca / tulis.  Sarang dan parameter apa pun untuk mengakses elemen koleksi diperbolehkan.  Tidak perlu menggambarkan semua bidang yang mungkin ada di artikel kami. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> extendSelectors <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'immutable-selectors'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selectors = { <span class="hljs-attr"><span class="hljs-attr">poemText</span></span>:{}, <span class="hljs-attr"><span class="hljs-attr">score</span></span>:{} }; extendSelectors(selectors, [ <span class="hljs-string"><span class="hljs-string">'poemScoring'</span></span> ]); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> selectors;</code> </pre> <br>  Lebih lanjut, metode extendedSelectors mengubah setiap bidang dalam objek kita menjadi fungsi pemilih.  Parameter kedua menunjukkan jalur ke bagian negara bagian yang dikendalikan pemilih.  Kami tidak membuat objek baru, tetapi mengubah objek saat ini.  Ini memberi kami bonus dalam bentuk kecerdasan kerja: <br><br><img src="https://image.ibb.co/iYdDp9/5.png" alt="gambar"><br><br>  Apa objek kami - pemilih setelah ekspansi: <br><br><img src="https://image.ibb.co/iAGcGp/5_5.png" alt="gambar"><br><br>  Fungsi <i>selectors.poemText (state)</i> cukup menjalankan <i>state.getIn (['poemScoring', 'poemText'])</i> . <br><br>  Function <i>root (state)</i> - mendapat 'poemScoring'. <br><br>  Setiap pemilih memiliki fungsi <i>ganti</i> sendiri <i>(globalState, newPart)</i> , yang melalui setIn mengembalikan negara global baru dengan bagian yang sesuai diganti. <br><br>  Juga, objek <i>datar</i> ditambahkan ke mana semua kunci pemilih unik digandakan.  Artinya, jika kita menggunakan kondisi yang dalam <br><br><pre> <code class="javascript hljs">selectors = { <span class="hljs-attr"><span class="hljs-attr">dive</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">in</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">to</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">the</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">deep</span></span>:{} } } } }}</code> </pre> <br>  Anda bisa menjadi lebih dalam sebagai <i>selectors.dive.in.to.the.deep (state)</i> atau sebagai <i>selectors.flat.deep (state)</i> . <br><br>  Silakan.  Kami perlu memperbarui akuisisi data di kontrol: <br><br>  Puisi: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapStateToProps</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, ownprops</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">text</span></span>:selectors.poemText(state) || <span class="hljs-string"><span class="hljs-string">''</span></span> }; }</code> </pre> <br><br>  Skor: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapStateToProps</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, ownprops</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> score = selectors.score(state); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { score }; }</code> </pre> <br>  Selanjutnya, ubah peredam root: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> initialState <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./initialState'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStateReducer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state = initialState, action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action.setState) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action.setState; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; <span class="hljs-comment"><span class="hljs-comment">// return combinedReducers(state, action); // } } export default setStateReducer;</span></span></code> </pre> <br>  Jika diinginkan, kita dapat menggabungkan menggunakan CombedReducers. <br><br>  Action crater, misalnya, poemTextChange: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poemTextChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getState</span></span></span><span class="hljs-function">) </span></span>{ dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'Poem typing'</span></span>, <span class="hljs-attr"><span class="hljs-attr">setState</span></span>: logic.onType(getState(), text), <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: text }); }; }</code> </pre> <br>  Kita tidak bisa lagi menggunakan konstanta tipe tindakan, karena tipe sekarang hanya digunakan untuk visualisasi di inspektur.  Kami di proyek menulis deskripsi teks lengkap tentang tindakan dalam bahasa Rusia.  Anda juga dapat membuang muatan, tetapi saya mencoba menyimpannya sehingga di inspektur, jika perlu, saya mengerti dengan parameter apa tindakan itu dipanggil. <br><br>  Dan, faktanya, logikanya sendiri: <br><br><pre> <code class="javascript hljs"> onType(gState, text) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { reductedText, censoredWords } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.redactText(text); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> poemState = selectors.root(gState) || Immutable.Map(); <span class="hljs-comment"><span class="hljs-comment">//     const newPoemState = poemState //  .set('poemText', reductedText) .set('score', this.calcScore(reductedText)); let newGState = selectors.root.replace(gState, newPoemState); //    if (censoredWords) { //  ,    const userName = appSelectors.flat.userName(gState); const messageText = `${userName}, avoid of using word ${censoredWords}, please!`; newGState = message.showMessage(newGState, messageText); } return newGState; },</span></span></code> </pre> <br>  Pada saat yang sama, <i>message.showMessage</i> diimpor dari logika modul tetangga, yang menjelaskan pemilihnya: <br><br><pre> <code class="javascript hljs"> showMessage(gState, text) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> selectors.message.text.replace(gState, text); }.</code> </pre> <br>  Apa yang ternyata: <br><br><img src="https://image.ibb.co/hviDp9/6.png" alt="gambar"><br><br>  Perhatikan bahwa kami memiliki satu pengiriman, data dalam dua modul berubah. <br>  Semua ini memungkinkan kami untuk menyingkirkan reduksi dan konstanta tipe tindakan, serta menyelesaikan atau mengatasi sebagian besar hambatan yang diuraikan di atas. <br><br><h4>  Bagaimana lagi ini bisa diterapkan? </h4><br>  Pendekatan ini nyaman digunakan ketika perlu untuk memastikan bahwa kontrol atau modul Anda memberikan pekerjaan dengan berbagai keadaan.  Katakanlah satu puisi saja tidak cukup untuk kita.  Kami ingin pengguna dapat membuat puisi pada dua tab yang berbeda dalam disiplin ilmu yang berbeda (anak-anak, romantis).  Dalam hal ini, kami tidak dapat mengimpor penyeleksi dalam logika / kontrol, tetapi menentukannya sebagai parameter dalam kontrol eksternal: <br><br><pre> <code class="javascript hljs"> &lt;Poem selectors = {selectors.hildPoem}/&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Poem</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">selectors</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{selectors.romanticPoem}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Dan, lebih lanjut, berikan parameter ini ke kawah aksi.  Ini cukup untuk membuat kombinasi kompleks dari komponen dan logika tertutup sepenuhnya, sehingga mudah digunakan kembali. <br><br>  <b>Keterbatasan saat menggunakan pemilih-tidak berubah:</b> <br><br>  Ini tidak akan berfungsi untuk menggunakan kunci di negara "nama", karena untuk fungsi induk akan ada upaya untuk menimpa properti yang dipesan. <br><br><h3>  Apa hasilnya </h3><br>  Akibatnya, pendekatan yang agak fleksibel diperoleh, hubungan kode implisit oleh konstanta teks dihilangkan, overhead dikurangi sambil menjaga kenyamanan pengembangan.  Ada juga inspektur redux yang berfungsi penuh dengan kemungkinan perjalanan waktu.  Saya tidak punya keinginan untuk kembali ke reduksi standar. <br><br>  Secara umum, itu saja.  Terima kasih untuk waktu anda  Mungkin seseorang akan tertarik untuk mencobanya! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424613/">https://habr.com/ru/post/id424613/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424603/index.html">Buku “Mengapa kita salah? Berpikir Perangkap dalam Tindakan. " Kutipan Bagian 1</a></li>
<li><a href="../id424605/index.html">Dana Zuckerberg: Kolaborasi + Teknologi + Open Science</a></li>
<li><a href="../id424607/index.html">Naiknya Helidon</a></li>
<li><a href="../id424609/index.html">Cara memperpanjang Kubernetes</a></li>
<li><a href="../id424611/index.html">Cara membuat karyawan dari freelancer</a></li>
<li><a href="../id424615/index.html">Output fungsi kurva untuk parameter, sinyal, dan tidak terbatas membatasi Wolfram Mathematica saja</a></li>
<li><a href="../id424621/index.html">Superhero non-film. Siapa dan bagaimana melindungi situs konstruksi Lakhta Center dari kebakaran?</a></li>
<li><a href="../id424623/index.html">Mari kita proses suara di Go</a></li>
<li><a href="../id424625/index.html">Kode Sumber Layanan Web Aeroflot Kebocoran</a></li>
<li><a href="../id424627/index.html">Perubahan register kas. Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>