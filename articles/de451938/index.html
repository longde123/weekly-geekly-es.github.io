<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎊 👨‍👩‍👧 🐼 Gehen Sie zu Bitmap-Indizes: Wild Search 😸 🌱 🕧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 
 Ich habe diesen Bericht auf Englisch auf der GopherCon Russia 2019-Konferenz in Moskau und auf Russisch auf dem Treffen in Nischni Nowgor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gehen Sie zu Bitmap-Indizes: Wild Search</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/451938/"><img src="https://habrastorage.org/webt/hg/g_/eq/hgg_eq6037im5xzqx0ibzmdyoku.jpeg"><br><br><h2>  Einführung </h2><br>  Ich habe diesen Bericht auf Englisch auf der GopherCon Russia 2019-Konferenz in Moskau und auf Russisch auf dem Treffen in Nischni Nowgorod verfasst.  Es geht um einen Bitmap-Index - weniger verbreitet als B-Tree, aber nicht weniger interessant.  Ich teile die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufzeichnung der</a> Rede auf der Konferenz auf Englisch und das Textprotokoll auf Russisch. <br><br>  Wir werden untersuchen, wie der Bitmap-Index funktioniert, wann er besser ist, wann er schlechter als andere Indizes ist und in welchen Fällen er viel schneller als diese ist.  Wir werden sehen, welche gängigen DBMS bereits Bitmap-Indizes haben.  versuche deine eigenen auf Go zu schreiben.  Und zum Nachtisch werden wir vorgefertigte Bibliotheken verwenden, um unsere eigene superschnelle spezialisierte Datenbank zu erstellen. <br><br>  Ich hoffe wirklich, dass meine Arbeit für Sie nützlich und interessant sein wird.  Lass uns gehen! <br><a name="habracut"></a><br><h2>  Einführung </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WvlUH6MjUuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://bit.ly/bitmapindexes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/mkevac/gopherconrussia2019</a> <br><br>  Hallo an alle!  Es ist sechs Uhr abends, wir sind alle super müde.  Gute Zeit, um über die langweilige Theorie der Datenbankindizes zu sprechen, oder?  Keine Sorge, ich werde hier und da ein paar Zeilen Quellcode haben.  :-) <br><br>  Wenn ohne Witze, dann ist der Bericht voller Informationen, und wir haben nicht viel Zeit.  Also fangen wir an. <br><img src="https://habrastorage.org/webt/ui/p9/0n/uip90nv7gann0i9cq_xqctdilh0.png"><br>  Heute werde ich über Folgendes sprechen: <br><br><ul><li>  Was sind Indizes? <br></li><li>  Was ist ein Bitmap-Index? <br></li><li>  wo es verwendet wird und wo es NICHT verwendet wird und warum; <br></li><li>  einfache Implementierung auf Go und ein wenig Kampf mit dem Compiler; <br></li><li>  etwas weniger einfache, aber viel produktivere Implementierung in Go-Assembler; <br></li><li>  "Probleme" von Bitmap-Indizes; <br></li><li>  bestehende Implementierungen. <br></li></ul><br><br><h2>  Was sind Indizes? </h2><br><img src="https://habrastorage.org/webt/ig/uh/ii/iguhiixwichncqrv6gdszecwgzg.png"><br><br>  Ein Index ist eine separate Datenstruktur, die wir zusätzlich zu den Hauptdaten speichern und aktualisieren.  Es wird verwendet, um die Suche zu beschleunigen.  Ohne Indizes würde eine Suche einen vollständigen Durchlauf der Daten erfordern (ein Prozess, der als vollständiger Scan bezeichnet wird), und dieser Prozess weist eine lineare algorithmische Komplexität auf.  Datenbanken enthalten jedoch normalerweise eine große Datenmenge und die lineare Komplexität ist zu langsam.  Idealerweise würden wir einen Logarithmus oder eine Konstante erhalten. <br><br>  Dies ist ein riesiges komplexes Thema, das mit Feinheiten und Kompromissen überfordert ist. Nach jahrzehntelanger Entwicklung und Forschung verschiedener Datenbanken bin ich jedoch bereit zu argumentieren, dass es nur wenige weit verbreitete Ansätze zur Erstellung von Datenbankindizes gibt. <br><br><img src="https://habrastorage.org/webt/aa/yv/wn/aayvwnmn7tbaucc39k3x7ejolsa.png"><br><br>  Der erste Ansatz besteht darin, den Suchbereich hierarchisch zu verkleinern und den Suchbereich in kleinere Teile zu unterteilen. <br><br>  Normalerweise machen wir das mit allen Arten von Bäumen.  Ein Beispiel ist eine große Schachtel mit Materialien in Ihrem Schrank, in der sich kleinere Schachteln mit Materialien befinden, die nach verschiedenen Themen unterteilt sind.  Wenn Sie Materialien benötigen, werden Sie diese wahrscheinlich in einer Box mit den Worten "Materialien" suchen und nicht in der mit "Cookies", oder? <br><br><img src="https://habrastorage.org/webt/zk/oq/_3/zkoq_3s8yr3izbnqvgd9nxmtvyi.png"><br><br>  Der zweite Ansatz besteht darin, sofort das gewünschte Element oder die gewünschte Elementgruppe auszuwählen.  Wir tun dies in Hash-Maps oder in umgekehrten Indizes.  Die Verwendung von Hash-Maps ist dem vorherigen Beispiel sehr ähnlich. Nur anstelle einer Box mit Boxen in Ihrem Schrank gibt es viele kleine Boxen mit endgültigen Elementen. <br><br><img src="https://habrastorage.org/webt/kv/zh/0q/kvzh0qp0teoe7h1_ixbeum9jdne.png"><br><br>  Der dritte Ansatz besteht darin, die Notwendigkeit einer Suche zu beseitigen.  Wir machen das mit Bloom-Filtern oder Kuckucksfiltern.  Ersteres gibt sofort eine Antwort, sodass keine Suche erforderlich ist. <br><br><img src="https://habrastorage.org/webt/ic/b2/4f/icb24fzrjaf4ntui8cymh3orj3c.png"><br><br>  Der letzte Ansatz besteht darin, alle Kapazitäten, die uns modernes Eisen bietet, voll auszuschöpfen.  Genau das machen wir in Bitmap-Indizes.  Ja, wenn wir sie verwenden, müssen wir manchmal den gesamten Index durchgehen, aber wir machen das sehr effizient. <br><br>  Wie gesagt, das Thema Datenbankindizes ist umfangreich und voller Kompromisse.  Dies bedeutet, dass wir manchmal mehrere Ansätze gleichzeitig verwenden können: wenn wir die Suche noch weiter beschleunigen müssen oder wenn alle möglichen Suchtypen abgedeckt werden müssen. <br><br>  Heute werde ich über den am wenigsten bekannten Ansatz sprechen - über Bitmap-Indizes. <br><br><h2>  Wer soll ich darüber reden? </h2><br><img src="https://habrastorage.org/webt/dh/i9/-r/dhi9-rzto3wlple4rympbmrdhx4.png"><br><br>  Ich arbeite als Teamleiter in Badoo (vielleicht kennen Sie unser anderes Produkt, Bumble, besser).  Wir haben bereits mehr als 400 Millionen Benutzer auf der ganzen Welt und viele Funktionen, die sich mit der Auswahl des besten Paares für sie befassen.  Wir verwenden dazu benutzerdefinierte Dienste, die auch Bitmap-Indizes verwenden. <br><br><h2>  Was ist ein Bitmap-Index? </h2><br><img src="https://habrastorage.org/webt/iz/ty/tu/iztytuxzo4kzx7vyc7vwrwwslze.png"><br>  Bitmap-Indizes verwenden, wie der Name schon sagt, Bitmaps oder Bitsets, um einen Suchindex zu implementieren.  Aus der Vogelperspektive besteht dieser Index aus einer oder mehreren solcher Bitmaps, die Entitäten (wie Personen) und deren Eigenschaften oder Parameter (Alter, Augenfarbe usw.) darstellen, sowie aus einem Algorithmus, der Bitoperationen verwendet (UND, ODER NICHT), um auf eine Suchanfrage zu antworten. <br><img src="https://habrastorage.org/webt/24/20/ey/2420eyiyck6eqjz7t6xf9zs-gvq.jpeg"><br>  Uns wird gesagt, dass Bitmap-Indizes am besten geeignet und sehr produktiv sind für Fälle, in denen eine Suche Abfragen über viele Spalten hinweg mit geringer Kardinalität kombiniert (stellen Sie sich „Augenfarbe“ oder „Familienstand“ vor, etwa „Entfernung vom Stadtzentrum“). )  Aber später werde ich zeigen, dass sie bei Spalten mit hoher Kardinalität perfekt funktionieren. <br><br>  Betrachten Sie das einfachste Beispiel eines Bitmap-Index. <br><img src="https://habrastorage.org/webt/yc/rf/1d/ycrf1dwjkvooel8tctktagyxi0a.jpeg"><br>  Stellen Sie sich vor, wir haben eine Liste von Moskauer Restaurants mit binären Eigenschaften wie diesen: <br><br><ul><li>  in der Nähe der U-Bahn (in der Nähe der U-Bahn); <br></li><li>  Es gibt einen privaten Parkplatz (hat einen privaten Parkplatz); <br></li><li>  es gibt eine Veranda (hat Terrasse); <br></li><li>  Sie können einen Tisch reservieren (akzeptiert Reservierungen); <br></li><li>  geeignet für Vegetarier (vegan freundlich); <br></li><li>  teuer (teuer). <br></li></ul><br><img src="https://habrastorage.org/webt/sg/oq/db/sgoqdbv90ujmnpkajxcc-8eg0eg.jpeg"><br>  Geben Sie jedem Restaurant eine Seriennummer ab 0 und weisen Sie Speicher für 6 Bitmaps zu (eine für jedes Merkmal).  Dann füllen wir diese Bitmaps aus, je nachdem, ob das Restaurant diese Eigenschaft hat oder nicht.  Wenn Restaurant 4 eine Veranda hat, wird Bit Nr. 4 in der Bitmap „Es gibt eine Veranda“ auf 1 gesetzt (wenn es keine Veranda gibt, dann auf 0). <br><img src="https://habrastorage.org/webt/jl/ap/ge/jlapgeh1fk9cvapi-9gyxtlgnty.jpeg"><br>  Jetzt haben wir den einfachsten möglichen Bitmap-Index und können damit Fragen beantworten wie: <br><br><ul><li>  "Zeigen Sie mir Restaurants für Vegetarier geeignet"; <br></li><li>  "Zeigen Sie mir preiswerte Restaurants mit einer Veranda, auf der Sie einen Tisch reservieren können." <br></li></ul><br><br><img src="https://habrastorage.org/webt/2p/wq/t7/2pwqt76nijteahvflvizdufiumy.jpeg"><br><img src="https://habrastorage.org/webt/_d/fg/wq/_dfgwq--uyewk4k_fryjd533tug.jpeg"><br>  Wie?  Mal sehen.  Die erste Anfrage ist sehr einfach.  Alles, was wir tun müssen, ist, die Bitmap „Für Vegetarier geeignet“ zu nehmen und daraus eine Liste von Restaurants zu machen, deren Teile ausgestellt sind. <br><img src="https://habrastorage.org/webt/oe/0-/hd/oe0-hd5hqr6b6unvqtdoadn3jtu.jpeg"><br><img src="https://habrastorage.org/webt/en/3r/co/en3rcomfemoy-arkj9qx3fqmveu.jpeg"><br>  Die zweite Abfrage ist etwas komplizierter.  Wir müssen die NOT-Bit-Operation für die "teure" Bitmap verwenden, um eine Liste kostengünstiger Restaurants zu erhalten. Stellen Sie sie dann mit der Bitmap "Sie können eine Tabelle reservieren" ein und setzen Sie das Ergebnis mit der Bitmap "Es gibt eine Veranda".  Die resultierende Bitmap enthält eine Liste der Einrichtungen, die alle unsere Kriterien erfüllen.  In diesem Beispiel ist dies nur das Yunost-Restaurant. <br><img src="https://habrastorage.org/webt/wm/jr/f5/wmjrf5nhch2k9zriz_sfuxzqfec.jpeg"><br><img src="https://habrastorage.org/webt/si/sf/c2/sisfc2h6lro8nu4yctf96absj_u.jpeg"><br>  Es gibt viel Theorie, aber keine Sorge, wir werden den Code sehr bald sehen. <br><br><h2>  Wo werden Bitmap-Indizes verwendet? </h2><br><img src="https://habrastorage.org/webt/zu/sd/up/zusdupegzydvhacdl-wzmwytrbq.jpeg"><br>  Wenn Sie Bitmap-Indizes „googeln“, beziehen sich 90% der Antworten auf Oracle DB.  Aber der Rest des DBMS unterstützt wahrscheinlich auch so eine coole Sache, oder?  Nicht wirklich. <br><br>  Lassen Sie uns die Liste der Hauptverdächtigen durchgehen. <br><img src="https://habrastorage.org/webt/-k/xy/zn/-kxyznvnwct15_2jzp3rulwotic.jpeg"><br>  MySQL unterstützt noch keine Bitmap-Indizes, es gibt jedoch einen Vorschlag mit einem Vorschlag zum Hinzufügen dieser Option ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://dev.mysql.com/worklog/task/?id=1524</a> ). <br><br>  PostgreSQL unterstützt keine Bitmap-Indizes, verwendet jedoch einfache Bitmaps und Bitoperationen, um Suchergebnisse über mehrere andere Indizes hinweg zu kombinieren. <br><br>  Tarantool verfügt über Bitset-Indizes und unterstützt eine einfache Suche. <br><br>  Redis verfügt über einfache Bitfelder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(https://redis.io/commands/bitfield</a> ), die nicht durchsucht werden können. <br><br>  MongoDB unterstützt noch keine Bitmap-Indizes, es gibt jedoch auch einen Vorschlag mit einem Vorschlag zum Hinzufügen dieser Option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://jira.mongodb.org/browse/SERVER-1723</a> <br><br>  Elasticsearch verwendet darin Bitmaps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps</a> ). <br><br><br><img src="https://habrastorage.org/webt/kv/rd/zo/kvrdzoime8mqrf1vtl_iqwgjaea.jpeg"><br><br><ul><li>  Aber ein neuer Nachbar erschien in unserem Haus: Pilosa.  Dies ist eine neue nicht relationale Datenbank, die in Go geschrieben wurde.  Es enthält nur Bitmap-Indizes und basiert alles darauf.  Wir werden etwas später über sie sprechen. <br></li></ul><br><br><h2>  Gehen Sie zur Implementierung </h2><br>  Aber warum werden Bitmap-Indizes so selten verwendet?  Bevor ich diese Frage beantworte, möchte ich Ihnen die Implementierung eines sehr einfachen Bitmap-Index für Go demonstrieren. <br><img src="https://habrastorage.org/webt/db/ua/jt/dbuajtkgolu346p22gzcufwsll4.jpeg"><br>  Bitmaps sind im Wesentlichen nur Daten.  Verwenden Sie in Go dafür Byte-Slices. <br><br>  Wir haben eine Bitmap pro Restaurantmerkmal, und jedes Bit in der Bitmap gibt an, ob ein bestimmtes Restaurant über diese Eigenschaft verfügt oder nicht. <br><img src="https://habrastorage.org/webt/j2/az/1i/j2az1inrzzj0rcdg9dajst7afhc.jpeg"><br>  Wir brauchen zwei Hilfsfunktionen.  Eine wird verwendet, um unsere Bitmaps mit zufälligen Daten zu füllen.  Zufällig, aber mit einer gewissen Wahrscheinlichkeit, dass das Restaurant jede Eigenschaft hat.  Ich glaube zum Beispiel, dass es in Moskau nur sehr wenige Restaurants gibt, in denen Sie keinen Tisch reservieren können, und es scheint mir, dass ungefähr 20% der Einrichtungen für Vegetarier geeignet sind. <br><br>  Die zweite Funktion konvertiert die Bitmap in eine Liste von Restaurants. <br><img src="https://habrastorage.org/webt/aj/d7/vg/ajd7vgvjt7_2ssgiw7hh2jue9vu.jpeg"><br><img src="https://habrastorage.org/webt/gl/nv/wv/glnvwvokatnkyd08nxslinseoyc.jpeg"><br>  Um die Anfrage „Zeigen Sie mir preiswerte Restaurants mit einer Veranda und wo Sie einen Tisch reservieren können“ zu beantworten, benötigen wir zwei Bit-Operationen: NOT und AND. <br><br>  Wir können unseren Code ein wenig vereinfachen, indem wir die komplexere AND NOT-Operation verwenden. <br><br>  Wir haben Funktionen für jede dieser Operationen.  Beide gehen die Slices durch, nehmen die entsprechenden Elemente von jedem, kombinieren sie mit einer Bitoperation und fügen das Ergebnis in das resultierende Slice ein. <br><img src="https://habrastorage.org/webt/_f/-m/wa/_f-mwakzpgavqkr_a6m3lzzo_gy.jpeg"><br>  Und jetzt können wir unsere Bitmaps und Funktionen verwenden, um auf eine Suchanfrage zu antworten. <br><img src="https://habrastorage.org/webt/rp/tn/uq/rptnuqmitwu5f-ag2w4tquglhca.jpeg"><br>  Die Leistung ist nicht so hoch, obwohl die Funktionen sehr einfach sind und wir anständig gespart haben, dass wir nicht jedes Mal, wenn die Funktion aufgerufen wurde, ein neues resultierendes Slice zurückgegeben haben. <br><br>  Nachdem ich ein wenig mit pprof profiliert hatte, bemerkte ich, dass der Go-Compiler eine sehr einfache, aber sehr wichtige Optimierung verpasste: das Inlining von Funktionen. <br><img src="https://habrastorage.org/webt/4s/6j/vs/4s6jvsys1nnmrpxnzpyfed8myq8.jpeg"><br>  Tatsache ist, dass der Go-Compiler schreckliche Angst vor Schleifen hat, die Slices durchlaufen, und sich kategorisch weigert, Inline-Funktionen zu verwenden, die Schleifen enthalten. <br><img src="https://habrastorage.org/webt/ok/e_/th/oke_thx54xevzrxjqc6fmqx8w5y.jpeg"><br>  Aber ich habe keine Angst, und ich kann den Compiler täuschen, indem ich goto anstelle einer Schleife verwende, wie in den guten alten Zeiten. <br><br><img src="https://habrastorage.org/webt/bx/xo/ea/bxxoeatd8s3mby2jyemkac3jyfg.jpeg"><br><img src="https://habrastorage.org/webt/5k/fm/2l/5kfm2let9qh2ynkerqdkkd1thao.jpeg"><br><br>  Und wie Sie sehen, erweitert der Compiler unsere Funktion jetzt glücklich!  Dadurch sparen wir ca. 2 Mikrosekunden.  Nicht schlecht! <br><br><img src="https://habrastorage.org/webt/or/tx/lw/ortxlwhbagw4oafvij-sngkxbsm.jpeg"><br><br>  Der zweite Engpass ist leicht zu erkennen, wenn Sie sich die Assembler-Ausgabe genau ansehen.  Der Compiler hat direkt in unserer heißesten Schleife eine Slice-gebundene Prüfung hinzugefügt.  Tatsache ist, dass Go eine sichere Sprache ist. Der Compiler befürchtet, dass meine drei Argumente (drei Slices) unterschiedliche Größen haben.  Schließlich besteht dann theoretisch die Möglichkeit, dass der sogenannte Pufferüberlauf auftritt. <br><br>  Lassen Sie uns den Compiler beruhigen, indem wir ihm zeigen, dass alle Slices dieselbe Größe haben.  Wir können dies tun, indem wir zu Beginn unserer Funktion eine einfache Prüfung hinzufügen. <br><img src="https://habrastorage.org/webt/rq/v7/en/rqv7enj1mgqnsrgwnlkwscks0ri.jpeg"><br>  Wenn der Compiler dies sieht, überspringt er den Test gerne und wir sparen am Ende weitere 500 Nanosekunden. <br><br><h2>  Große Mengen </h2><br>  Okay, wir haben es geschafft, etwas Leistung aus unserer einfachen Implementierung herauszuholen, aber dieses Ergebnis ist mit der aktuellen Hardware tatsächlich viel schlechter als möglich. <br><br>  Alles, was wir tun, sind grundlegende Bitoperationen, und unsere Prozessoren führen sie sehr effizient aus.  Leider „füttern“ wir unseren Prozessor mit sehr kleinen Arbeiten.  Unsere Funktionen führen Operationen byteweise aus.  Wir können unseren Code sehr einfach so optimieren, dass er mit 8-Byte-Chunks unter Verwendung von UInt64-Slices funktioniert. <br><br><img src="https://habrastorage.org/webt/-w/vl/rd/-wvlrdx24mrcvy_vovvjeouaxjs.jpeg"><br><br>  Wie Sie sehen können, hat diese kleine Änderung unser Programm um das Achtfache beschleunigt, da die Charge um das Achtfache erhöht wurde.  Die Verstärkung kann als linear bezeichnet werden. <br><br><img src="https://habrastorage.org/webt/tf/ej/nk/tfejnkdoftg8gs7vfpgrmbxfejq.jpeg"><br><h2>  Assembler-Implementierung </h2><br><img src="https://habrastorage.org/webt/ii/3d/du/ii3ddup__yc_-dhzsuivs6fcpeu.jpeg"><br>  Dies ist jedoch nicht das Ende.  Unsere Prozessoren können mit Teilen von 16, 32 und sogar 64 Bytes arbeiten.  Solche "breiten" Operationen werden als Einzelbefehls-Mehrfachdaten (SIMD; ein Befehl, viele Daten) bezeichnet, und der Prozess der Transformation des Codes, so dass er solche Operationen verwendet, wird als Vektorisierung bezeichnet. <br><br>  Leider ist der Go-Compiler kein ausgezeichneter Schüler in der Vektorisierung.  Derzeit besteht die einzige Möglichkeit, Code auf Go zu vektorisieren, darin, diese Vorgänge manuell mit dem Go-Assembler auszuführen. <br><br><img src="https://habrastorage.org/webt/qv/dr/ap/qvdrapgfhvfhrei2ies1w2vtcds.jpeg"><br><br>  Assembler Go ist ein seltsames Tier.  Sie wissen wahrscheinlich, dass Assembler stark an die Architektur des Computers gebunden ist, für den Sie schreiben, aber dies ist bei Go nicht der Fall.  Der Go-Assembler ähnelt eher einer IRL (Intermediate Representation Language) oder einer Intermediate Language: Er ist praktisch plattformunabhängig.  Rob Pike hat vor einigen Jahren auf der GopherCon in Denver eine hervorragende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Präsentation</a> zu diesem Thema gehalten. <br><br>  Darüber hinaus verwendet Go das ungewöhnliche Plan 9-Format, das sich von den allgemein anerkannten Formaten AT &amp; T und Intel unterscheidet. <br><img src="https://habrastorage.org/webt/kp/8r/px/kp8rpxg_xmp3faph2ysefnjavxk.jpeg"><br>  Man kann mit Sicherheit sagen, dass das manuelle Schreiben von Go Assembler nicht die unterhaltsamste Aktivität ist. <br><br>  Glücklicherweise gibt es bereits zwei übergeordnete Tools, mit denen wir Go Assembler schreiben können: PeachPy und Avo.  Beide Dienstprogramme generieren Go-Assembler aus höherwertigem Code, der in Python bzw. Go geschrieben ist. <br><img src="https://habrastorage.org/webt/mf/qz/zb/mfqzzbyuqtrdk06iiiw4ufe5eou.jpeg"><br>  Diese Dienstprogramme vereinfachen Dinge wie die Registerzuweisung, Schreibzyklen und vereinfachen im Allgemeinen den Einstieg in die Welt der Assembler-Programmierung in Go. <br><br>  Wir werden avo verwenden, daher werden unsere Programme fast normale Go-Programme sein. <br><img src="https://habrastorage.org/webt/qd/ij/l2/qdijl2s77ub_c1om5budqbudjx4.jpeg"><br>  So sieht das einfachste Beispiel eines Avo-Programms aus.  Wir haben eine main () - Funktion, die die Add () - Funktion in sich selbst definiert, deren Bedeutung darin besteht, zwei Zahlen hinzuzufügen.  Es gibt Hilfsfunktionen zum Abrufen von Parametern nach Namen und zum Abrufen eines der freien und geeigneten Prozessorregister.  Jede Prozessoroperation hat eine entsprechende Funktion auf avo, wie in ADDQ zu sehen.  Schließlich sehen wir eine Hilfsfunktion zum Speichern des resultierenden Werts. <br><img src="https://habrastorage.org/webt/8q/ze/6_/8qze6_requgfy9fimtn5tiirtn8.jpeg"><br>  Durch den Aufruf von go generate führen wir das Programm auf avo aus und am Ende werden zwei Dateien generiert: <br><br><ul><li>  add.s mit dem resultierenden Go-Assembler-Code; <br></li><li>  stub.go mit Funktionsheadern zum Verbinden zweier Welten: Go und Assembler. <br></li></ul><br><img src="https://habrastorage.org/webt/mz/bk/pi/mzbkpixqbe5kygtl9vphoeak39w.jpeg"><br>  Nachdem wir gesehen haben, was und wie Avo funktioniert, werfen wir einen Blick auf unsere Funktionen.  Ich habe sowohl skalare als auch Vektorversionen (SIMD) von Funktionen implementiert. <br><br>  Schauen Sie sich zunächst die skalaren Versionen an. <br><img src="https://habrastorage.org/webt/9v/1a/gj/9v1agjswpb-wnfoyqbb1x0rb6vo.jpeg"><br>  Wie im vorherigen Beispiel bitten wir Sie, uns ein kostenloses und korrektes Allzweckregister zur Verfügung zu stellen. Wir müssen die Offsets und Größen für die Argumente nicht berechnen.  All das tut uns nichts. <br><img src="https://habrastorage.org/webt/rt/yj/ju/rtyjjuzuc4ycx2au4tqohzaxsby.jpeg"><br>  Früher haben wir Labels und goto (oder Jumps) verwendet, um die Leistung zu verbessern und den Go-Compiler auszutricksen, aber jetzt machen wir das von Anfang an.  Tatsache ist, dass Schleifen ein übergeordnetes Konzept sind.  In Assembler haben wir nur Beschriftungen und Sprünge. <br><img src="https://habrastorage.org/webt/c4/gk/ww/c4gkwwdt0to9yorwoya2jurfrj8.jpeg"><br>  Der verbleibende Code sollte bereits bekannt und verständlich sein.  Wir emulieren die Schleife mit Beschriftungen und Sprüngen, nehmen einen kleinen Teil der Daten aus unseren beiden Slices, kombinieren sie mit einer Bitoperation (UND in diesem Fall NICHT) und fügen das Ergebnis dann in das resultierende Slice ein.  Das ist alles. <br><img src="https://habrastorage.org/webt/vw/gj/fg/vwgjfg2tkeaxec2n7qkvgneqpve.jpeg"><br>  So sieht der endgültige Assembler-Code aus.  Wir mussten weder die Offsets und Größen berechnen (grün hervorgehoben) noch die verwendeten Register verfolgen (rot hervorgehoben). <br><img src="https://habrastorage.org/webt/of/sc/4v/ofsc4vbjkv2imcihypew4_japuo.jpeg"><br>  Wenn wir die Leistung der Implementierung in Assembler mit der Leistung der besten Implementierung in Go vergleichen, werden wir feststellen, dass es dieselbe ist.  Und es wird erwartet.  Schließlich haben wir nichts Besonderes gemacht - wir haben nur reproduziert, was der Go-Compiler tun würde. <br><br>  Leider können wir den Compiler nicht zwingen, unsere in Assembler geschriebenen Funktionen zu integrieren.  Der Go-Compiler verfügt heute nicht über diese Funktion, obwohl die Anforderung, sie hinzuzufügen, schon seit geraumer Zeit besteht. <br><br>  Aus diesem Grund ist es unmöglich, kleine Assembler-Funktionen zu nutzen.  Wir müssen entweder große Funktionen schreiben oder das neue math / bits-Paket verwenden oder die Assemblerseite umgehen. <br><br>  Schauen wir uns nun die Vektorversionen unserer Funktionen an. <br><img src="https://habrastorage.org/webt/ac/qe/bs/acqebsweofbwzmvcwt-vro9yx4m.jpeg"><br>  In diesem Beispiel habe ich mich für AVX2 entschieden, daher werden Operationen verwendet, die mit 32-Byte-Chunks arbeiten.  Die Codestruktur ist der skalaren Option sehr ähnlich: Laden von Parametern, bitte stellen Sie uns ein kostenloses allgemeines Register usw. zur Verfügung. <br><img src="https://habrastorage.org/webt/ef/5g/wa/ef5gwafb0stn7wunw8ryjcjyt_k.jpeg"><br>  Eine der Neuerungen besteht darin, dass breitere Vektoroperationen spezielle breite Register verwenden.  Bei 32-Byte-Chunks handelt es sich um Register mit dem Präfix Y. Aus diesem Grund wird im Code die Funktion YMM () angezeigt.  Wenn ich den AVX-512 mit 64-Bit-Chunks verwenden würde, wäre das Präfix Z. <br><br>  Die zweite Neuerung ist, dass ich mich für eine Optimierung namens Loop Unrolling entschieden habe, dh acht Loop-Operationen manuell durchzuführen, bevor ich zum Start der Loop springe.  Diese Optimierung reduziert die Anzahl der Brunchs (Zweige) im Code und ist durch die Anzahl der verfügbaren freien Register begrenzt. <br><img src="https://habrastorage.org/webt/vj/1c/nd/vj1cndpc9uqyrzgfqrld4vfda5o.jpeg"><br>  Was ist mit der Leistung?  Sie ist schön!  Wir haben ungefähr sieben Mal beschleunigt, verglichen mit der besten Lösung für unterwegs.  Beeindruckend, oder? <br><img src="https://habrastorage.org/webt/d_/9b/ag/d_9bag_w0set74ryc4j5oqm5slm.jpeg"><br>  Aber auch diese Implementierung könnte möglicherweise durch die Verwendung von AVX-512, Prefetching oder JIT (Just-in-Time-Compiler) für den Abfrageplaner beschleunigt werden.  Dies ist jedoch sicherlich ein Thema für einen separaten Bericht. <br><br><h2>  Probleme mit dem Bitmap-Index </h2><br>  Nachdem wir uns bereits eine einfache Implementierung des Go-Bitmap-Index und eine viel effizientere Assemblersprache angesehen haben, wollen wir abschließend darüber sprechen, warum Bitmap-Indizes so selten verwendet werden. <br><img src="https://habrastorage.org/webt/qs/yf/as/qsyfasqoxbr_heaolyqpd9ms7hk.jpeg"><br>  In den alten wissenschaftlichen Arbeiten werden drei Probleme von Bitmap-Indizes erwähnt, aber neuere wissenschaftliche Arbeiten und ich argumentieren, dass sie nicht mehr relevant sind.  Wir werden uns nicht eingehend mit jedem dieser Probleme befassen, aber wir werden sie oberflächlich betrachten. <br><br><h2>  Das Problem der großen Kardinalität </h2><br>  Uns wird also gesagt, dass Bitmap-Indizes nur für Felder mit geringer Kardinalität geeignet sind, dh für Felder mit wenigen Werten (z. B. Geschlecht oder Augenfarbe), und der Grund dafür ist, dass die übliche Darstellung solcher Felder (ein Bit pro Wert) Im Falle einer großen Kardinalität nimmt es zu viel Platz ein und außerdem werden diese Bitmap-Indizes schwach (selten) gefüllt. <br><img src="https://habrastorage.org/webt/zf/na/lt/zfnaltbokwrnweeiwtighgvq5cm.jpeg"><br><img src="https://habrastorage.org/webt/sa/p4/mw/sap4mwjq8sslx6_zgdanmn8fcwu.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manchmal können wir eine andere Darstellung verwenden, zum Beispiel die Standarddarstellung, mit der wir Zahlen darstellen. </font><font style="vertical-align: inherit;">Aber es war das Aufkommen von Komprimierungsalgorithmen, die alles veränderten. </font><font style="vertical-align: inherit;">In den letzten Jahrzehnten haben Wissenschaftler und Forscher eine Vielzahl von Komprimierungsalgorithmen für Bitmaps entwickelt. </font><font style="vertical-align: inherit;">Ihr Hauptvorteil ist, dass Sie die Bitmaps für Bitoperationen nicht erweitern müssen - wir können Bitoperationen direkt auf den komprimierten Bitmaps ausführen. </font></font><br><img src="https://habrastorage.org/webt/mv/56/bt/mv56btwi703wsb0nya7ofor5lew.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In letzter Zeit tauchen hybride Ansätze auf, wie beispielsweise brüllende Bitmaps. </font><font style="vertical-align: inherit;">Sie verwenden gleichzeitig drei verschiedene Darstellungen für Bitmaps - tatsächlich Bitmaps, Arrays und die sogenannten Bitläufe - und gleichen sie aus, um die Leistung zu maximieren und den Speicherverbrauch zu minimieren.</font></font><br><br>    roaring     .          ,        Go. <br><img src="https://habrastorage.org/webt/af/xy/wy/afxywyhipsvsfla4tuot6ir0tei.jpeg"><br>   ,        ,   (binning). ,     ,   .  —     ,  , ,       .       185,2   185,3 . <br><br> ,          1 . <br><br>      ,        50    250 ,   ,  ,            200 . <br><br> ,         . <br><br><h2>     </h2><br>   bitmap-   ,       . <br><br>          ,          .   ,             .  ,     ,    — lock contention,      . <br><img src="https://habrastorage.org/webt/xg/ju/xl/xgjuxll8jn3btfxhniispsepbmw.jpeg"><br>             . <br><br>  —    .    bitmap- ,       .               lock contention. <br><br>     —    .       ,       ,   —    .    -   (,   100   500 )      . ,       ,          . <br><br>      :       . <br><br><h2>    </h2><br><br>   bitmap-   , ,   ,        ,   « ». <br><br>  ,  ,    AND, OR  . .      - «       200  300   ». <br><img src="https://habrastorage.org/webt/fq/qy/en/fqqyeneeggnmx0iccptaz8eygmm.jpeg"><br>                   OR. <br><img src="https://habrastorage.org/webt/jr/du/ey/jrdueypemf_a69m1wikbjpialze.jpeg"><br>        . ,    50 .       50 . <br><br>       ,      .      range-encoded bitmaps. <br><img src="https://habrastorage.org/webt/vq/hx/a5/vqhxa5jyy4w9_e5lurbjhntabie.jpeg"><br>           -  (, 200),      ,  . 200  .     300: 300  .  Usw. <br><br>   ,        ,      .     ,      300 ,      ,      199 .  Fertig. <br><img src="https://habrastorage.org/webt/wh/bc/hs/whbchsdcr0qrupa6jhu9fcpufke.jpeg"><br>  ,       bitmap-.   ,   ,      . , S2  Google.            ,   .           « » (   ). <br><br><h2>   </h2><br>               .   -    - ,   ,    . <br><br>      ,   ,   bitmap-  .   ,   SIMD, . <br><br>  ,    ,   . <br><img src="https://habrastorage.org/webt/em/cg/km/emcgkmutgbpdj_arrdnfoub6lt0.jpeg"><br><h2> Roaring  </h2><br> -,    roaring bitmaps-,     .        ,     ,    bitmap-. <br><img src="https://habrastorage.org/webt/k3/mv/yh/k3mvyhvcdb8sh7g-aejhgqeob6c.jpeg"><br>  ,       Go-   SIMD,  , Go-  ,    C, . <br><br><h2> Pilosa </h2><br>  ,    , —  Pilosa,  ,  ,  bitmap-  .    ,       . <br><img src="https://habrastorage.org/webt/uw/gs/56/uwgs563qvexzg27dd5x15zbzlto.jpeg"><br> Pilosa  roaring         ,      ,     : , range-encoded bitmaps,    . . <br><br>       Pilosa       . <br><img src="https://habrastorage.org/webt/8d/jm/kn/8djmknf2jltazwrepy_ia4j7k_4.jpeg"><br>     ,    .      Pilosa,     ,         , ,   . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danach verwenden wir NICHT auf dem "teuren" Feld und schneiden dann das Ergebnis (oder UND) mit dem Terrassenfeld und dem Reservierungsfeld. </font><font style="vertical-align: inherit;">Und schließlich erhalten wir das Endergebnis. </font></font><br><img src="https://habrastorage.org/webt/bg/bu/oi/bgbuoi1v8n8vus4einuldy4u8zu.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich hoffe wirklich, dass in absehbarer Zeit in DBMS wie MySQL und PostgreSQL auch diese neue Art von Indizes erscheinen wird - Bitmap-Indizes.</font></font><br><img src="https://habrastorage.org/webt/ez/h4/g1/ezh4g1de2gpbozwi8-yubjvhpp4.jpeg"><br><h2>  Fazit </h2><br><img src="https://habrastorage.org/webt/tp/0f/3v/tp0f3vktlhcltdxbu7fatn7qqhq.jpeg"><br>  Wenn Sie noch nicht eingeschlafen sind, danke.  Ich musste wegen der begrenzten Zeit im Vorbeigehen auf viele Themen eingehen, aber ich hoffe, dass der Bericht nützlich und vielleicht sogar motivierend war. <br><br>  Es ist gut, über Bitmap-Indizes Bescheid zu wissen, auch wenn Sie sie gerade nicht benötigen.  Lassen Sie sie ein weiteres Werkzeug in Ihrer Schublade sein. <br><br>  Wir haben verschiedene Performance-Tricks für Go und die Dinge behandelt, mit denen der Go-Compiler nicht sehr gut zurechtkommt.  Aber es ist absolut nützlich, dass jeder Go-Programmierer es weiß. <br><br>  Das ist alles was ich erzählen wollte.  Vielen Dank! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451938/">https://habr.com/ru/post/de451938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451928/index.html">So richten Sie Webanalysen auf AMP-Seiten ein</a></li>
<li><a href="../de451930/index.html">Automatisierung der Treppenhausbeleuchtung</a></li>
<li><a href="../de451932/index.html">PHDays 9: Willkommen im Bereich Sichere Entwicklung</a></li>
<li><a href="../de451934/index.html">Alexander Lamden: „Jedes Stück Eisen hat einen Charakter“</a></li>
<li><a href="../de451936/index.html">Suchen nach Sicherheitslücken im UC-Browser</a></li>
<li><a href="../de451942/index.html">Wie das Dröhnen in Afrika Tausende von Menschenleben rettet</a></li>
<li><a href="../de451944/index.html">2019: Jahr des DEX (Dezentrale Börsen)</a></li>
<li><a href="../de451948/index.html">Die Geschichte der drei Patronen</a></li>
<li><a href="../de451950/index.html">Virtuelle Kraftwerke. Ist es möglich, die Quellen "grüner" Energie zu verwalten?</a></li>
<li><a href="../de451954/index.html">Weitere geheime Telegramme</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>