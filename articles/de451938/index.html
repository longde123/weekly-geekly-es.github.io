<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéä üë®‚Äçüë©‚Äçüëß üêº Gehen Sie zu Bitmap-Indizes: Wild Search üò∏ üå± üïß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Ich habe diesen Bericht auf Englisch auf der GopherCon Russia 2019-Konferenz in Moskau und auf Russisch auf dem Treffen in Nischni Nowgor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gehen Sie zu Bitmap-Indizes: Wild Search</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/451938/"><img src="https://habrastorage.org/webt/hg/g_/eq/hgg_eq6037im5xzqx0ibzmdyoku.jpeg"><br><br><h2>  Einf√ºhrung </h2><br>  Ich habe diesen Bericht auf Englisch auf der GopherCon Russia 2019-Konferenz in Moskau und auf Russisch auf dem Treffen in Nischni Nowgorod verfasst.  Es geht um einen Bitmap-Index - weniger verbreitet als B-Tree, aber nicht weniger interessant.  Ich teile die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufzeichnung der</a> Rede auf der Konferenz auf Englisch und das Textprotokoll auf Russisch. <br><br>  Wir werden untersuchen, wie der Bitmap-Index funktioniert, wann er besser ist, wann er schlechter als andere Indizes ist und in welchen F√§llen er viel schneller als diese ist.  Wir werden sehen, welche g√§ngigen DBMS bereits Bitmap-Indizes haben.  versuche deine eigenen auf Go zu schreiben.  Und zum Nachtisch werden wir vorgefertigte Bibliotheken verwenden, um unsere eigene superschnelle spezialisierte Datenbank zu erstellen. <br><br>  Ich hoffe wirklich, dass meine Arbeit f√ºr Sie n√ºtzlich und interessant sein wird.  Lass uns gehen! <br><a name="habracut"></a><br><h2>  Einf√ºhrung </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WvlUH6MjUuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://bit.ly/bitmapindexes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/mkevac/gopherconrussia2019</a> <br><br>  Hallo an alle!  Es ist sechs Uhr abends, wir sind alle super m√ºde.  Gute Zeit, um √ºber die langweilige Theorie der Datenbankindizes zu sprechen, oder?  Keine Sorge, ich werde hier und da ein paar Zeilen Quellcode haben.  :-) <br><br>  Wenn ohne Witze, dann ist der Bericht voller Informationen, und wir haben nicht viel Zeit.  Also fangen wir an. <br><img src="https://habrastorage.org/webt/ui/p9/0n/uip90nv7gann0i9cq_xqctdilh0.png"><br>  Heute werde ich √ºber Folgendes sprechen: <br><br><ul><li>  Was sind Indizes? <br></li><li>  Was ist ein Bitmap-Index? <br></li><li>  wo es verwendet wird und wo es NICHT verwendet wird und warum; <br></li><li>  einfache Implementierung auf Go und ein wenig Kampf mit dem Compiler; <br></li><li>  etwas weniger einfache, aber viel produktivere Implementierung in Go-Assembler; <br></li><li>  "Probleme" von Bitmap-Indizes; <br></li><li>  bestehende Implementierungen. <br></li></ul><br><br><h2>  Was sind Indizes? </h2><br><img src="https://habrastorage.org/webt/ig/uh/ii/iguhiixwichncqrv6gdszecwgzg.png"><br><br>  Ein Index ist eine separate Datenstruktur, die wir zus√§tzlich zu den Hauptdaten speichern und aktualisieren.  Es wird verwendet, um die Suche zu beschleunigen.  Ohne Indizes w√ºrde eine Suche einen vollst√§ndigen Durchlauf der Daten erfordern (ein Prozess, der als vollst√§ndiger Scan bezeichnet wird), und dieser Prozess weist eine lineare algorithmische Komplexit√§t auf.  Datenbanken enthalten jedoch normalerweise eine gro√üe Datenmenge und die lineare Komplexit√§t ist zu langsam.  Idealerweise w√ºrden wir einen Logarithmus oder eine Konstante erhalten. <br><br>  Dies ist ein riesiges komplexes Thema, das mit Feinheiten und Kompromissen √ºberfordert ist. Nach jahrzehntelanger Entwicklung und Forschung verschiedener Datenbanken bin ich jedoch bereit zu argumentieren, dass es nur wenige weit verbreitete Ans√§tze zur Erstellung von Datenbankindizes gibt. <br><br><img src="https://habrastorage.org/webt/aa/yv/wn/aayvwnmn7tbaucc39k3x7ejolsa.png"><br><br>  Der erste Ansatz besteht darin, den Suchbereich hierarchisch zu verkleinern und den Suchbereich in kleinere Teile zu unterteilen. <br><br>  Normalerweise machen wir das mit allen Arten von B√§umen.  Ein Beispiel ist eine gro√üe Schachtel mit Materialien in Ihrem Schrank, in der sich kleinere Schachteln mit Materialien befinden, die nach verschiedenen Themen unterteilt sind.  Wenn Sie Materialien ben√∂tigen, werden Sie diese wahrscheinlich in einer Box mit den Worten "Materialien" suchen und nicht in der mit "Cookies", oder? <br><br><img src="https://habrastorage.org/webt/zk/oq/_3/zkoq_3s8yr3izbnqvgd9nxmtvyi.png"><br><br>  Der zweite Ansatz besteht darin, sofort das gew√ºnschte Element oder die gew√ºnschte Elementgruppe auszuw√§hlen.  Wir tun dies in Hash-Maps oder in umgekehrten Indizes.  Die Verwendung von Hash-Maps ist dem vorherigen Beispiel sehr √§hnlich. Nur anstelle einer Box mit Boxen in Ihrem Schrank gibt es viele kleine Boxen mit endg√ºltigen Elementen. <br><br><img src="https://habrastorage.org/webt/kv/zh/0q/kvzh0qp0teoe7h1_ixbeum9jdne.png"><br><br>  Der dritte Ansatz besteht darin, die Notwendigkeit einer Suche zu beseitigen.  Wir machen das mit Bloom-Filtern oder Kuckucksfiltern.  Ersteres gibt sofort eine Antwort, sodass keine Suche erforderlich ist. <br><br><img src="https://habrastorage.org/webt/ic/b2/4f/icb24fzrjaf4ntui8cymh3orj3c.png"><br><br>  Der letzte Ansatz besteht darin, alle Kapazit√§ten, die uns modernes Eisen bietet, voll auszusch√∂pfen.  Genau das machen wir in Bitmap-Indizes.  Ja, wenn wir sie verwenden, m√ºssen wir manchmal den gesamten Index durchgehen, aber wir machen das sehr effizient. <br><br>  Wie gesagt, das Thema Datenbankindizes ist umfangreich und voller Kompromisse.  Dies bedeutet, dass wir manchmal mehrere Ans√§tze gleichzeitig verwenden k√∂nnen: wenn wir die Suche noch weiter beschleunigen m√ºssen oder wenn alle m√∂glichen Suchtypen abgedeckt werden m√ºssen. <br><br>  Heute werde ich √ºber den am wenigsten bekannten Ansatz sprechen - √ºber Bitmap-Indizes. <br><br><h2>  Wer soll ich dar√ºber reden? </h2><br><img src="https://habrastorage.org/webt/dh/i9/-r/dhi9-rzto3wlple4rympbmrdhx4.png"><br><br>  Ich arbeite als Teamleiter in Badoo (vielleicht kennen Sie unser anderes Produkt, Bumble, besser).  Wir haben bereits mehr als 400 Millionen Benutzer auf der ganzen Welt und viele Funktionen, die sich mit der Auswahl des besten Paares f√ºr sie befassen.  Wir verwenden dazu benutzerdefinierte Dienste, die auch Bitmap-Indizes verwenden. <br><br><h2>  Was ist ein Bitmap-Index? </h2><br><img src="https://habrastorage.org/webt/iz/ty/tu/iztytuxzo4kzx7vyc7vwrwwslze.png"><br>  Bitmap-Indizes verwenden, wie der Name schon sagt, Bitmaps oder Bitsets, um einen Suchindex zu implementieren.  Aus der Vogelperspektive besteht dieser Index aus einer oder mehreren solcher Bitmaps, die Entit√§ten (wie Personen) und deren Eigenschaften oder Parameter (Alter, Augenfarbe usw.) darstellen, sowie aus einem Algorithmus, der Bitoperationen verwendet (UND, ODER NICHT), um auf eine Suchanfrage zu antworten. <br><img src="https://habrastorage.org/webt/24/20/ey/2420eyiyck6eqjz7t6xf9zs-gvq.jpeg"><br>  Uns wird gesagt, dass Bitmap-Indizes am besten geeignet und sehr produktiv sind f√ºr F√§lle, in denen eine Suche Abfragen √ºber viele Spalten hinweg mit geringer Kardinalit√§t kombiniert (stellen Sie sich ‚ÄûAugenfarbe‚Äú oder ‚ÄûFamilienstand‚Äú vor, etwa ‚ÄûEntfernung vom Stadtzentrum‚Äú). )  Aber sp√§ter werde ich zeigen, dass sie bei Spalten mit hoher Kardinalit√§t perfekt funktionieren. <br><br>  Betrachten Sie das einfachste Beispiel eines Bitmap-Index. <br><img src="https://habrastorage.org/webt/yc/rf/1d/ycrf1dwjkvooel8tctktagyxi0a.jpeg"><br>  Stellen Sie sich vor, wir haben eine Liste von Moskauer Restaurants mit bin√§ren Eigenschaften wie diesen: <br><br><ul><li>  in der N√§he der U-Bahn (in der N√§he der U-Bahn); <br></li><li>  Es gibt einen privaten Parkplatz (hat einen privaten Parkplatz); <br></li><li>  es gibt eine Veranda (hat Terrasse); <br></li><li>  Sie k√∂nnen einen Tisch reservieren (akzeptiert Reservierungen); <br></li><li>  geeignet f√ºr Vegetarier (vegan freundlich); <br></li><li>  teuer (teuer). <br></li></ul><br><img src="https://habrastorage.org/webt/sg/oq/db/sgoqdbv90ujmnpkajxcc-8eg0eg.jpeg"><br>  Geben Sie jedem Restaurant eine Seriennummer ab 0 und weisen Sie Speicher f√ºr 6 Bitmaps zu (eine f√ºr jedes Merkmal).  Dann f√ºllen wir diese Bitmaps aus, je nachdem, ob das Restaurant diese Eigenschaft hat oder nicht.  Wenn Restaurant 4 eine Veranda hat, wird Bit Nr. 4 in der Bitmap ‚ÄûEs gibt eine Veranda‚Äú auf 1 gesetzt (wenn es keine Veranda gibt, dann auf 0). <br><img src="https://habrastorage.org/webt/jl/ap/ge/jlapgeh1fk9cvapi-9gyxtlgnty.jpeg"><br>  Jetzt haben wir den einfachsten m√∂glichen Bitmap-Index und k√∂nnen damit Fragen beantworten wie: <br><br><ul><li>  "Zeigen Sie mir Restaurants f√ºr Vegetarier geeignet"; <br></li><li>  "Zeigen Sie mir preiswerte Restaurants mit einer Veranda, auf der Sie einen Tisch reservieren k√∂nnen." <br></li></ul><br><br><img src="https://habrastorage.org/webt/2p/wq/t7/2pwqt76nijteahvflvizdufiumy.jpeg"><br><img src="https://habrastorage.org/webt/_d/fg/wq/_dfgwq--uyewk4k_fryjd533tug.jpeg"><br>  Wie?  Mal sehen.  Die erste Anfrage ist sehr einfach.  Alles, was wir tun m√ºssen, ist, die Bitmap ‚ÄûF√ºr Vegetarier geeignet‚Äú zu nehmen und daraus eine Liste von Restaurants zu machen, deren Teile ausgestellt sind. <br><img src="https://habrastorage.org/webt/oe/0-/hd/oe0-hd5hqr6b6unvqtdoadn3jtu.jpeg"><br><img src="https://habrastorage.org/webt/en/3r/co/en3rcomfemoy-arkj9qx3fqmveu.jpeg"><br>  Die zweite Abfrage ist etwas komplizierter.  Wir m√ºssen die NOT-Bit-Operation f√ºr die "teure" Bitmap verwenden, um eine Liste kosteng√ºnstiger Restaurants zu erhalten. Stellen Sie sie dann mit der Bitmap "Sie k√∂nnen eine Tabelle reservieren" ein und setzen Sie das Ergebnis mit der Bitmap "Es gibt eine Veranda".  Die resultierende Bitmap enth√§lt eine Liste der Einrichtungen, die alle unsere Kriterien erf√ºllen.  In diesem Beispiel ist dies nur das Yunost-Restaurant. <br><img src="https://habrastorage.org/webt/wm/jr/f5/wmjrf5nhch2k9zriz_sfuxzqfec.jpeg"><br><img src="https://habrastorage.org/webt/si/sf/c2/sisfc2h6lro8nu4yctf96absj_u.jpeg"><br>  Es gibt viel Theorie, aber keine Sorge, wir werden den Code sehr bald sehen. <br><br><h2>  Wo werden Bitmap-Indizes verwendet? </h2><br><img src="https://habrastorage.org/webt/zu/sd/up/zusdupegzydvhacdl-wzmwytrbq.jpeg"><br>  Wenn Sie Bitmap-Indizes ‚Äûgoogeln‚Äú, beziehen sich 90% der Antworten auf Oracle DB.  Aber der Rest des DBMS unterst√ºtzt wahrscheinlich auch so eine coole Sache, oder?  Nicht wirklich. <br><br>  Lassen Sie uns die Liste der Hauptverd√§chtigen durchgehen. <br><img src="https://habrastorage.org/webt/-k/xy/zn/-kxyznvnwct15_2jzp3rulwotic.jpeg"><br>  MySQL unterst√ºtzt noch keine Bitmap-Indizes, es gibt jedoch einen Vorschlag mit einem Vorschlag zum Hinzuf√ºgen dieser Option ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://dev.mysql.com/worklog/task/?id=1524</a> ). <br><br>  PostgreSQL unterst√ºtzt keine Bitmap-Indizes, verwendet jedoch einfache Bitmaps und Bitoperationen, um Suchergebnisse √ºber mehrere andere Indizes hinweg zu kombinieren. <br><br>  Tarantool verf√ºgt √ºber Bitset-Indizes und unterst√ºtzt eine einfache Suche. <br><br>  Redis verf√ºgt √ºber einfache Bitfelder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(https://redis.io/commands/bitfield</a> ), die nicht durchsucht werden k√∂nnen. <br><br>  MongoDB unterst√ºtzt noch keine Bitmap-Indizes, es gibt jedoch auch einen Vorschlag mit einem Vorschlag zum Hinzuf√ºgen dieser Option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://jira.mongodb.org/browse/SERVER-1723</a> <br><br>  Elasticsearch verwendet darin Bitmaps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps</a> ). <br><br><br><img src="https://habrastorage.org/webt/kv/rd/zo/kvrdzoime8mqrf1vtl_iqwgjaea.jpeg"><br><br><ul><li>  Aber ein neuer Nachbar erschien in unserem Haus: Pilosa.  Dies ist eine neue nicht relationale Datenbank, die in Go geschrieben wurde.  Es enth√§lt nur Bitmap-Indizes und basiert alles darauf.  Wir werden etwas sp√§ter √ºber sie sprechen. <br></li></ul><br><br><h2>  Gehen Sie zur Implementierung </h2><br>  Aber warum werden Bitmap-Indizes so selten verwendet?  Bevor ich diese Frage beantworte, m√∂chte ich Ihnen die Implementierung eines sehr einfachen Bitmap-Index f√ºr Go demonstrieren. <br><img src="https://habrastorage.org/webt/db/ua/jt/dbuajtkgolu346p22gzcufwsll4.jpeg"><br>  Bitmaps sind im Wesentlichen nur Daten.  Verwenden Sie in Go daf√ºr Byte-Slices. <br><br>  Wir haben eine Bitmap pro Restaurantmerkmal, und jedes Bit in der Bitmap gibt an, ob ein bestimmtes Restaurant √ºber diese Eigenschaft verf√ºgt oder nicht. <br><img src="https://habrastorage.org/webt/j2/az/1i/j2az1inrzzj0rcdg9dajst7afhc.jpeg"><br>  Wir brauchen zwei Hilfsfunktionen.  Eine wird verwendet, um unsere Bitmaps mit zuf√§lligen Daten zu f√ºllen.  Zuf√§llig, aber mit einer gewissen Wahrscheinlichkeit, dass das Restaurant jede Eigenschaft hat.  Ich glaube zum Beispiel, dass es in Moskau nur sehr wenige Restaurants gibt, in denen Sie keinen Tisch reservieren k√∂nnen, und es scheint mir, dass ungef√§hr 20% der Einrichtungen f√ºr Vegetarier geeignet sind. <br><br>  Die zweite Funktion konvertiert die Bitmap in eine Liste von Restaurants. <br><img src="https://habrastorage.org/webt/aj/d7/vg/ajd7vgvjt7_2ssgiw7hh2jue9vu.jpeg"><br><img src="https://habrastorage.org/webt/gl/nv/wv/glnvwvokatnkyd08nxslinseoyc.jpeg"><br>  Um die Anfrage ‚ÄûZeigen Sie mir preiswerte Restaurants mit einer Veranda und wo Sie einen Tisch reservieren k√∂nnen‚Äú zu beantworten, ben√∂tigen wir zwei Bit-Operationen: NOT und AND. <br><br>  Wir k√∂nnen unseren Code ein wenig vereinfachen, indem wir die komplexere AND NOT-Operation verwenden. <br><br>  Wir haben Funktionen f√ºr jede dieser Operationen.  Beide gehen die Slices durch, nehmen die entsprechenden Elemente von jedem, kombinieren sie mit einer Bitoperation und f√ºgen das Ergebnis in das resultierende Slice ein. <br><img src="https://habrastorage.org/webt/_f/-m/wa/_f-mwakzpgavqkr_a6m3lzzo_gy.jpeg"><br>  Und jetzt k√∂nnen wir unsere Bitmaps und Funktionen verwenden, um auf eine Suchanfrage zu antworten. <br><img src="https://habrastorage.org/webt/rp/tn/uq/rptnuqmitwu5f-ag2w4tquglhca.jpeg"><br>  Die Leistung ist nicht so hoch, obwohl die Funktionen sehr einfach sind und wir anst√§ndig gespart haben, dass wir nicht jedes Mal, wenn die Funktion aufgerufen wurde, ein neues resultierendes Slice zur√ºckgegeben haben. <br><br>  Nachdem ich ein wenig mit pprof profiliert hatte, bemerkte ich, dass der Go-Compiler eine sehr einfache, aber sehr wichtige Optimierung verpasste: das Inlining von Funktionen. <br><img src="https://habrastorage.org/webt/4s/6j/vs/4s6jvsys1nnmrpxnzpyfed8myq8.jpeg"><br>  Tatsache ist, dass der Go-Compiler schreckliche Angst vor Schleifen hat, die Slices durchlaufen, und sich kategorisch weigert, Inline-Funktionen zu verwenden, die Schleifen enthalten. <br><img src="https://habrastorage.org/webt/ok/e_/th/oke_thx54xevzrxjqc6fmqx8w5y.jpeg"><br>  Aber ich habe keine Angst, und ich kann den Compiler t√§uschen, indem ich goto anstelle einer Schleife verwende, wie in den guten alten Zeiten. <br><br><img src="https://habrastorage.org/webt/bx/xo/ea/bxxoeatd8s3mby2jyemkac3jyfg.jpeg"><br><img src="https://habrastorage.org/webt/5k/fm/2l/5kfm2let9qh2ynkerqdkkd1thao.jpeg"><br><br>  Und wie Sie sehen, erweitert der Compiler unsere Funktion jetzt gl√ºcklich!  Dadurch sparen wir ca. 2 Mikrosekunden.  Nicht schlecht! <br><br><img src="https://habrastorage.org/webt/or/tx/lw/ortxlwhbagw4oafvij-sngkxbsm.jpeg"><br><br>  Der zweite Engpass ist leicht zu erkennen, wenn Sie sich die Assembler-Ausgabe genau ansehen.  Der Compiler hat direkt in unserer hei√üesten Schleife eine Slice-gebundene Pr√ºfung hinzugef√ºgt.  Tatsache ist, dass Go eine sichere Sprache ist. Der Compiler bef√ºrchtet, dass meine drei Argumente (drei Slices) unterschiedliche Gr√∂√üen haben.  Schlie√ülich besteht dann theoretisch die M√∂glichkeit, dass der sogenannte Puffer√ºberlauf auftritt. <br><br>  Lassen Sie uns den Compiler beruhigen, indem wir ihm zeigen, dass alle Slices dieselbe Gr√∂√üe haben.  Wir k√∂nnen dies tun, indem wir zu Beginn unserer Funktion eine einfache Pr√ºfung hinzuf√ºgen. <br><img src="https://habrastorage.org/webt/rq/v7/en/rqv7enj1mgqnsrgwnlkwscks0ri.jpeg"><br>  Wenn der Compiler dies sieht, √ºberspringt er den Test gerne und wir sparen am Ende weitere 500 Nanosekunden. <br><br><h2>  Gro√üe Mengen </h2><br>  Okay, wir haben es geschafft, etwas Leistung aus unserer einfachen Implementierung herauszuholen, aber dieses Ergebnis ist mit der aktuellen Hardware tats√§chlich viel schlechter als m√∂glich. <br><br>  Alles, was wir tun, sind grundlegende Bitoperationen, und unsere Prozessoren f√ºhren sie sehr effizient aus.  Leider ‚Äûf√ºttern‚Äú wir unseren Prozessor mit sehr kleinen Arbeiten.  Unsere Funktionen f√ºhren Operationen byteweise aus.  Wir k√∂nnen unseren Code sehr einfach so optimieren, dass er mit 8-Byte-Chunks unter Verwendung von UInt64-Slices funktioniert. <br><br><img src="https://habrastorage.org/webt/-w/vl/rd/-wvlrdx24mrcvy_vovvjeouaxjs.jpeg"><br><br>  Wie Sie sehen k√∂nnen, hat diese kleine √Ñnderung unser Programm um das Achtfache beschleunigt, da die Charge um das Achtfache erh√∂ht wurde.  Die Verst√§rkung kann als linear bezeichnet werden. <br><br><img src="https://habrastorage.org/webt/tf/ej/nk/tfejnkdoftg8gs7vfpgrmbxfejq.jpeg"><br><h2>  Assembler-Implementierung </h2><br><img src="https://habrastorage.org/webt/ii/3d/du/ii3ddup__yc_-dhzsuivs6fcpeu.jpeg"><br>  Dies ist jedoch nicht das Ende.  Unsere Prozessoren k√∂nnen mit Teilen von 16, 32 und sogar 64 Bytes arbeiten.  Solche "breiten" Operationen werden als Einzelbefehls-Mehrfachdaten (SIMD; ein Befehl, viele Daten) bezeichnet, und der Prozess der Transformation des Codes, so dass er solche Operationen verwendet, wird als Vektorisierung bezeichnet. <br><br>  Leider ist der Go-Compiler kein ausgezeichneter Sch√ºler in der Vektorisierung.  Derzeit besteht die einzige M√∂glichkeit, Code auf Go zu vektorisieren, darin, diese Vorg√§nge manuell mit dem Go-Assembler auszuf√ºhren. <br><br><img src="https://habrastorage.org/webt/qv/dr/ap/qvdrapgfhvfhrei2ies1w2vtcds.jpeg"><br><br>  Assembler Go ist ein seltsames Tier.  Sie wissen wahrscheinlich, dass Assembler stark an die Architektur des Computers gebunden ist, f√ºr den Sie schreiben, aber dies ist bei Go nicht der Fall.  Der Go-Assembler √§hnelt eher einer IRL (Intermediate Representation Language) oder einer Intermediate Language: Er ist praktisch plattformunabh√§ngig.  Rob Pike hat vor einigen Jahren auf der GopherCon in Denver eine hervorragende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pr√§sentation</a> zu diesem Thema gehalten. <br><br>  Dar√ºber hinaus verwendet Go das ungew√∂hnliche Plan 9-Format, das sich von den allgemein anerkannten Formaten AT &amp; T und Intel unterscheidet. <br><img src="https://habrastorage.org/webt/kp/8r/px/kp8rpxg_xmp3faph2ysefnjavxk.jpeg"><br>  Man kann mit Sicherheit sagen, dass das manuelle Schreiben von Go Assembler nicht die unterhaltsamste Aktivit√§t ist. <br><br>  Gl√ºcklicherweise gibt es bereits zwei √ºbergeordnete Tools, mit denen wir Go Assembler schreiben k√∂nnen: PeachPy und Avo.  Beide Dienstprogramme generieren Go-Assembler aus h√∂herwertigem Code, der in Python bzw. Go geschrieben ist. <br><img src="https://habrastorage.org/webt/mf/qz/zb/mfqzzbyuqtrdk06iiiw4ufe5eou.jpeg"><br>  Diese Dienstprogramme vereinfachen Dinge wie die Registerzuweisung, Schreibzyklen und vereinfachen im Allgemeinen den Einstieg in die Welt der Assembler-Programmierung in Go. <br><br>  Wir werden avo verwenden, daher werden unsere Programme fast normale Go-Programme sein. <br><img src="https://habrastorage.org/webt/qd/ij/l2/qdijl2s77ub_c1om5budqbudjx4.jpeg"><br>  So sieht das einfachste Beispiel eines Avo-Programms aus.  Wir haben eine main () - Funktion, die die Add () - Funktion in sich selbst definiert, deren Bedeutung darin besteht, zwei Zahlen hinzuzuf√ºgen.  Es gibt Hilfsfunktionen zum Abrufen von Parametern nach Namen und zum Abrufen eines der freien und geeigneten Prozessorregister.  Jede Prozessoroperation hat eine entsprechende Funktion auf avo, wie in ADDQ zu sehen.  Schlie√ülich sehen wir eine Hilfsfunktion zum Speichern des resultierenden Werts. <br><img src="https://habrastorage.org/webt/8q/ze/6_/8qze6_requgfy9fimtn5tiirtn8.jpeg"><br>  Durch den Aufruf von go generate f√ºhren wir das Programm auf avo aus und am Ende werden zwei Dateien generiert: <br><br><ul><li>  add.s mit dem resultierenden Go-Assembler-Code; <br></li><li>  stub.go mit Funktionsheadern zum Verbinden zweier Welten: Go und Assembler. <br></li></ul><br><img src="https://habrastorage.org/webt/mz/bk/pi/mzbkpixqbe5kygtl9vphoeak39w.jpeg"><br>  Nachdem wir gesehen haben, was und wie Avo funktioniert, werfen wir einen Blick auf unsere Funktionen.  Ich habe sowohl skalare als auch Vektorversionen (SIMD) von Funktionen implementiert. <br><br>  Schauen Sie sich zun√§chst die skalaren Versionen an. <br><img src="https://habrastorage.org/webt/9v/1a/gj/9v1agjswpb-wnfoyqbb1x0rb6vo.jpeg"><br>  Wie im vorherigen Beispiel bitten wir Sie, uns ein kostenloses und korrektes Allzweckregister zur Verf√ºgung zu stellen. Wir m√ºssen die Offsets und Gr√∂√üen f√ºr die Argumente nicht berechnen.  All das tut uns nichts. <br><img src="https://habrastorage.org/webt/rt/yj/ju/rtyjjuzuc4ycx2au4tqohzaxsby.jpeg"><br>  Fr√ºher haben wir Labels und goto (oder Jumps) verwendet, um die Leistung zu verbessern und den Go-Compiler auszutricksen, aber jetzt machen wir das von Anfang an.  Tatsache ist, dass Schleifen ein √ºbergeordnetes Konzept sind.  In Assembler haben wir nur Beschriftungen und Spr√ºnge. <br><img src="https://habrastorage.org/webt/c4/gk/ww/c4gkwwdt0to9yorwoya2jurfrj8.jpeg"><br>  Der verbleibende Code sollte bereits bekannt und verst√§ndlich sein.  Wir emulieren die Schleife mit Beschriftungen und Spr√ºngen, nehmen einen kleinen Teil der Daten aus unseren beiden Slices, kombinieren sie mit einer Bitoperation (UND in diesem Fall NICHT) und f√ºgen das Ergebnis dann in das resultierende Slice ein.  Das ist alles. <br><img src="https://habrastorage.org/webt/vw/gj/fg/vwgjfg2tkeaxec2n7qkvgneqpve.jpeg"><br>  So sieht der endg√ºltige Assembler-Code aus.  Wir mussten weder die Offsets und Gr√∂√üen berechnen (gr√ºn hervorgehoben) noch die verwendeten Register verfolgen (rot hervorgehoben). <br><img src="https://habrastorage.org/webt/of/sc/4v/ofsc4vbjkv2imcihypew4_japuo.jpeg"><br>  Wenn wir die Leistung der Implementierung in Assembler mit der Leistung der besten Implementierung in Go vergleichen, werden wir feststellen, dass es dieselbe ist.  Und es wird erwartet.  Schlie√ülich haben wir nichts Besonderes gemacht - wir haben nur reproduziert, was der Go-Compiler tun w√ºrde. <br><br>  Leider k√∂nnen wir den Compiler nicht zwingen, unsere in Assembler geschriebenen Funktionen zu integrieren.  Der Go-Compiler verf√ºgt heute nicht √ºber diese Funktion, obwohl die Anforderung, sie hinzuzuf√ºgen, schon seit geraumer Zeit besteht. <br><br>  Aus diesem Grund ist es unm√∂glich, kleine Assembler-Funktionen zu nutzen.  Wir m√ºssen entweder gro√üe Funktionen schreiben oder das neue math / bits-Paket verwenden oder die Assemblerseite umgehen. <br><br>  Schauen wir uns nun die Vektorversionen unserer Funktionen an. <br><img src="https://habrastorage.org/webt/ac/qe/bs/acqebsweofbwzmvcwt-vro9yx4m.jpeg"><br>  In diesem Beispiel habe ich mich f√ºr AVX2 entschieden, daher werden Operationen verwendet, die mit 32-Byte-Chunks arbeiten.  Die Codestruktur ist der skalaren Option sehr √§hnlich: Laden von Parametern, bitte stellen Sie uns ein kostenloses allgemeines Register usw. zur Verf√ºgung. <br><img src="https://habrastorage.org/webt/ef/5g/wa/ef5gwafb0stn7wunw8ryjcjyt_k.jpeg"><br>  Eine der Neuerungen besteht darin, dass breitere Vektoroperationen spezielle breite Register verwenden.  Bei 32-Byte-Chunks handelt es sich um Register mit dem Pr√§fix Y. Aus diesem Grund wird im Code die Funktion YMM () angezeigt.  Wenn ich den AVX-512 mit 64-Bit-Chunks verwenden w√ºrde, w√§re das Pr√§fix Z. <br><br>  Die zweite Neuerung ist, dass ich mich f√ºr eine Optimierung namens Loop Unrolling entschieden habe, dh acht Loop-Operationen manuell durchzuf√ºhren, bevor ich zum Start der Loop springe.  Diese Optimierung reduziert die Anzahl der Brunchs (Zweige) im Code und ist durch die Anzahl der verf√ºgbaren freien Register begrenzt. <br><img src="https://habrastorage.org/webt/vj/1c/nd/vj1cndpc9uqyrzgfqrld4vfda5o.jpeg"><br>  Was ist mit der Leistung?  Sie ist sch√∂n!  Wir haben ungef√§hr sieben Mal beschleunigt, verglichen mit der besten L√∂sung f√ºr unterwegs.  Beeindruckend, oder? <br><img src="https://habrastorage.org/webt/d_/9b/ag/d_9bag_w0set74ryc4j5oqm5slm.jpeg"><br>  Aber auch diese Implementierung k√∂nnte m√∂glicherweise durch die Verwendung von AVX-512, Prefetching oder JIT (Just-in-Time-Compiler) f√ºr den Abfrageplaner beschleunigt werden.  Dies ist jedoch sicherlich ein Thema f√ºr einen separaten Bericht. <br><br><h2>  Probleme mit dem Bitmap-Index </h2><br>  Nachdem wir uns bereits eine einfache Implementierung des Go-Bitmap-Index und eine viel effizientere Assemblersprache angesehen haben, wollen wir abschlie√üend dar√ºber sprechen, warum Bitmap-Indizes so selten verwendet werden. <br><img src="https://habrastorage.org/webt/qs/yf/as/qsyfasqoxbr_heaolyqpd9ms7hk.jpeg"><br>  In den alten wissenschaftlichen Arbeiten werden drei Probleme von Bitmap-Indizes erw√§hnt, aber neuere wissenschaftliche Arbeiten und ich argumentieren, dass sie nicht mehr relevant sind.  Wir werden uns nicht eingehend mit jedem dieser Probleme befassen, aber wir werden sie oberfl√§chlich betrachten. <br><br><h2>  Das Problem der gro√üen Kardinalit√§t </h2><br>  Uns wird also gesagt, dass Bitmap-Indizes nur f√ºr Felder mit geringer Kardinalit√§t geeignet sind, dh f√ºr Felder mit wenigen Werten (z. B. Geschlecht oder Augenfarbe), und der Grund daf√ºr ist, dass die √ºbliche Darstellung solcher Felder (ein Bit pro Wert) Im Falle einer gro√üen Kardinalit√§t nimmt es zu viel Platz ein und au√üerdem werden diese Bitmap-Indizes schwach (selten) gef√ºllt. <br><img src="https://habrastorage.org/webt/zf/na/lt/zfnaltbokwrnweeiwtighgvq5cm.jpeg"><br><img src="https://habrastorage.org/webt/sa/p4/mw/sap4mwjq8sslx6_zgdanmn8fcwu.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manchmal k√∂nnen wir eine andere Darstellung verwenden, zum Beispiel die Standarddarstellung, mit der wir Zahlen darstellen. </font><font style="vertical-align: inherit;">Aber es war das Aufkommen von Komprimierungsalgorithmen, die alles ver√§nderten. </font><font style="vertical-align: inherit;">In den letzten Jahrzehnten haben Wissenschaftler und Forscher eine Vielzahl von Komprimierungsalgorithmen f√ºr Bitmaps entwickelt. </font><font style="vertical-align: inherit;">Ihr Hauptvorteil ist, dass Sie die Bitmaps f√ºr Bitoperationen nicht erweitern m√ºssen - wir k√∂nnen Bitoperationen direkt auf den komprimierten Bitmaps ausf√ºhren. </font></font><br><img src="https://habrastorage.org/webt/mv/56/bt/mv56btwi703wsb0nya7ofor5lew.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In letzter Zeit tauchen hybride Ans√§tze auf, wie beispielsweise br√ºllende Bitmaps. </font><font style="vertical-align: inherit;">Sie verwenden gleichzeitig drei verschiedene Darstellungen f√ºr Bitmaps - tats√§chlich Bitmaps, Arrays und die sogenannten Bitl√§ufe - und gleichen sie aus, um die Leistung zu maximieren und den Speicherverbrauch zu minimieren.</font></font><br><br>    roaring     .          ,        Go. <br><img src="https://habrastorage.org/webt/af/xy/wy/afxywyhipsvsfla4tuot6ir0tei.jpeg"><br>   ,        ,   (binning). ,     ,   .  ‚Äî     ,  , ,       .       185,2   185,3 . <br><br> ,          1 . <br><br>      ,        50    250 ,   ,  ,            200 . <br><br> ,         . <br><br><h2>     </h2><br>   bitmap-   ,       . <br><br>          ,          .   ,             .  ,     ,    ‚Äî lock contention,      . <br><img src="https://habrastorage.org/webt/xg/ju/xl/xgjuxll8jn3btfxhniispsepbmw.jpeg"><br>             . <br><br>  ‚Äî    .    bitmap- ,       .               lock contention. <br><br>     ‚Äî    .       ,       ,   ‚Äî    .    -   (,   100   500 )      . ,       ,          . <br><br>      :       . <br><br><h2>    </h2><br><br>   bitmap-   , ,   ,        ,   ¬´ ¬ª. <br><br>  ,  ,    AND, OR  . .      - ¬´       200  300   ¬ª. <br><img src="https://habrastorage.org/webt/fq/qy/en/fqqyeneeggnmx0iccptaz8eygmm.jpeg"><br>                   OR. <br><img src="https://habrastorage.org/webt/jr/du/ey/jrdueypemf_a69m1wikbjpialze.jpeg"><br>        . ,    50 .       50 . <br><br>       ,      .      range-encoded bitmaps. <br><img src="https://habrastorage.org/webt/vq/hx/a5/vqhxa5jyy4w9_e5lurbjhntabie.jpeg"><br>           -  (, 200),      ,  . 200  .     300: 300  .  Usw. <br><br>   ,        ,      .     ,      300 ,      ,      199 .  Fertig. <br><img src="https://habrastorage.org/webt/wh/bc/hs/whbchsdcr0qrupa6jhu9fcpufke.jpeg"><br>  ,       bitmap-.   ,   ,      . , S2  Google.            ,   .           ¬´ ¬ª (   ). <br><br><h2>   </h2><br>               .   -    - ,   ,    . <br><br>      ,   ,   bitmap-  .   ,   SIMD, . <br><br>  ,    ,   . <br><img src="https://habrastorage.org/webt/em/cg/km/emcgkmutgbpdj_arrdnfoub6lt0.jpeg"><br><h2> Roaring  </h2><br> -,    roaring bitmaps-,     .        ,     ,    bitmap-. <br><img src="https://habrastorage.org/webt/k3/mv/yh/k3mvyhvcdb8sh7g-aejhgqeob6c.jpeg"><br>  ,       Go-   SIMD,  , Go-  ,    C, . <br><br><h2> Pilosa </h2><br>  ,    , ‚Äî  Pilosa,  ,  ,  bitmap-  .    ,       . <br><img src="https://habrastorage.org/webt/uw/gs/56/uwgs563qvexzg27dd5x15zbzlto.jpeg"><br> Pilosa  roaring         ,      ,     : , range-encoded bitmaps,    . . <br><br>       Pilosa       . <br><img src="https://habrastorage.org/webt/8d/jm/kn/8djmknf2jltazwrepy_ia4j7k_4.jpeg"><br>     ,    .      Pilosa,     ,         , ,   . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danach verwenden wir NICHT auf dem "teuren" Feld und schneiden dann das Ergebnis (oder UND) mit dem Terrassenfeld und dem Reservierungsfeld. </font><font style="vertical-align: inherit;">Und schlie√ülich erhalten wir das Endergebnis. </font></font><br><img src="https://habrastorage.org/webt/bg/bu/oi/bgbuoi1v8n8vus4einuldy4u8zu.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich hoffe wirklich, dass in absehbarer Zeit in DBMS wie MySQL und PostgreSQL auch diese neue Art von Indizes erscheinen wird - Bitmap-Indizes.</font></font><br><img src="https://habrastorage.org/webt/ez/h4/g1/ezh4g1de2gpbozwi8-yubjvhpp4.jpeg"><br><h2>  Fazit </h2><br><img src="https://habrastorage.org/webt/tp/0f/3v/tp0f3vktlhcltdxbu7fatn7qqhq.jpeg"><br>  Wenn Sie noch nicht eingeschlafen sind, danke.  Ich musste wegen der begrenzten Zeit im Vorbeigehen auf viele Themen eingehen, aber ich hoffe, dass der Bericht n√ºtzlich und vielleicht sogar motivierend war. <br><br>  Es ist gut, √ºber Bitmap-Indizes Bescheid zu wissen, auch wenn Sie sie gerade nicht ben√∂tigen.  Lassen Sie sie ein weiteres Werkzeug in Ihrer Schublade sein. <br><br>  Wir haben verschiedene Performance-Tricks f√ºr Go und die Dinge behandelt, mit denen der Go-Compiler nicht sehr gut zurechtkommt.  Aber es ist absolut n√ºtzlich, dass jeder Go-Programmierer es wei√ü. <br><br>  Das ist alles was ich erz√§hlen wollte.  Vielen Dank! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451938/">https://habr.com/ru/post/de451938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451928/index.html">So richten Sie Webanalysen auf AMP-Seiten ein</a></li>
<li><a href="../de451930/index.html">Automatisierung der Treppenhausbeleuchtung</a></li>
<li><a href="../de451932/index.html">PHDays 9: Willkommen im Bereich Sichere Entwicklung</a></li>
<li><a href="../de451934/index.html">Alexander Lamden: ‚ÄûJedes St√ºck Eisen hat einen Charakter‚Äú</a></li>
<li><a href="../de451936/index.html">Suchen nach Sicherheitsl√ºcken im UC-Browser</a></li>
<li><a href="../de451942/index.html">Wie das Dr√∂hnen in Afrika Tausende von Menschenleben rettet</a></li>
<li><a href="../de451944/index.html">2019: Jahr des DEX (Dezentrale B√∂rsen)</a></li>
<li><a href="../de451948/index.html">Die Geschichte der drei Patronen</a></li>
<li><a href="../de451950/index.html">Virtuelle Kraftwerke. Ist es m√∂glich, die Quellen "gr√ºner" Energie zu verwalten?</a></li>
<li><a href="../de451954/index.html">Weitere geheime Telegramme</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>