<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍎 🎗️ 🙇🏼 Sisipan assembler ... dalam C #? ☝🏾 🌦️ 🥄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Maka, kisah ini dimulai dengan kebetulan tiga faktor. Saya: 



1. kebanyakan ditulis dalam C #; 
2. hanya secara kasar membayangkan bagaimana itu dia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sisipan assembler ... dalam C #?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464931/">  Maka, kisah ini dimulai dengan kebetulan tiga faktor.  Saya: <br><br><ol><li>  kebanyakan ditulis dalam C #; </li><li>  hanya secara kasar membayangkan bagaimana itu diatur dan bekerja; </li><li>  menjadi tertarik assembler. </li></ol><br>  Campuran yang tampaknya tidak bersalah ini memunculkan ide aneh: apakah mungkin untuk menggabungkan beberapa bahasa ini?  Tambahkan C # kemampuan untuk melakukan insert assembler, seperti di C ++. <br><br>  Jika Anda tertarik pada konsekuensi apa yang menyebabkan ini, selamat datang di kucing. <br><br> <a href=""><img src="https://habrastorage.org/webt/u-/sg/dk/u-sgdkb-3zwyqg682kuh2vvv1vq.png"></a> <br><a name="habracut"></a><br><h2>  Kesulitan pertama </h2><br>  Bahkan pada saat itu, saya menyadari bahwa sangat tidak mungkin ada alat standar untuk memanggil kode assembler dari kode C # - ini terlalu bertentangan dengan salah satu konsep penting bahasa: keamanan memori.  Setelah studi dangkal masalah (yang, antara lain, mengkonfirmasi firasat awal - "di luar kotak" tidak ada kemungkinan seperti itu), menjadi jelas bahwa selain masalah ideologis, ada masalah teknis murni: C #, seperti yang Anda tahu, dikompilasi menjadi bytecode perantara, yang selanjutnya ditafsirkan oleh mesin virtual CLR.  Dan di sini kita dihadapkan dengan masalah yang sangat: di satu sisi, kompiler (selanjutnya saya maksudkan Roslyn dari Microsoft, karena ini adalah standar di bidang kompiler C #), jelas, tidak mengenali dan menerjemahkan perintah assembler dari tampilan teks ke representasi biner, yang berarti bahwa kita harus menggunakan instruksi mesin secara langsung dalam bentuk biner mereka sebagai sisipan, dan di sisi lain, mesin virtual memiliki bytecode sendiri dan tidak dapat mengenali dan menjalankan itu  perintah paket yang kami tawarkan padanya. <br><br>  Solusi teoritis untuk masalah ini jelas - Anda perlu memastikan bahwa kode penyisipan biner dijalankan oleh prosesor, melewati interpretasi mesin virtual.  Hal paling sederhana yang terlintas dalam pikiran adalah untuk menyimpan kode biner sebagai array byte, yang kontrolnya akan ditransfer entah bagaimana pada waktu yang tepat.  Dari sini tampak tugas pertama: Anda harus menemukan cara untuk mentransfer kontrol ke apa yang terkandung dalam area memori arbitrer. <br><br><h2>  Prototipe pertama: "memanggil" sebuah array </h2><br>  Tugas ini mungkin merupakan hambatan paling serius untuk memasukkan.  Sangat mudah untuk menggunakan alat bahasa untuk mendapatkan pointer ke array kami, tetapi dalam C # world pointer hanya ada untuk data dan tidak mungkin untuk mengubahnya menjadi sebuah pointer, katakanlah, sebuah fungsi sehingga Anda dapat memanggilnya nanti (baik, atau setidaknya saya tidak tahu cara harus dilakukan). <br><br>  Untungnya (atau sayangnya), tidak ada yang baru di bawah bulan dan pencarian cepat di Yandex untuk kata-kata "C #" dan "assembler inserts" membawa saya ke sebuah artikel di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">majalah edisi Desember 2007]] [Aker]</a> .  Setelah dengan jujur ​​menyalin fungsi dari sana dan menyesuaikannya dengan kebutuhan saya, saya dapat <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualProtect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* lpAddress, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flNewProtect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">* lpflOldProtect</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* InvokeAsm(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* firstAsmArg, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* secondAsmArg, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] code) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* p = &amp;i; p += <span class="hljs-number"><span class="hljs-number">0x14</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; i = *p; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* b = code) { *p = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)b; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> prev; VirtualProtect((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)b, (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)code.Length, <span class="hljs-number"><span class="hljs-number">0x40</span></span>, &amp;prev); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)i; }</code> </pre> <br>  Gagasan utama kode ini adalah mengganti alamat pengirim dari fungsi <code>InvokeAsm()</code> pada stack dengan alamat array byte yang ingin Anda transfer kontrolnya.  Kemudian, setelah keluar dari fungsi, alih-alih melanjutkan eksekusi program, eksekusi kode biner kami akan dimulai. <br><br>  Kami akan berurusan dengan sihir yang <code>InvokeAsm()</code> di <code>InvokeAsm()</code> lebih terinci.  Pertama, kita mendeklarasikan variabel lokal, yang, tentu saja, muncul di stack, lalu kita mendapatkan alamatnya (sehingga mendapatkan alamat bagian atas stack).  Selanjutnya, kita tambahkan konstanta ajaib tertentu yang diperoleh dengan menghitung dengan susah payah di debugger offset alamat pengirim relatif ke atas tumpukan, simpan alamat kembali dan tulis alamat array byte kami sebagai gantinya.  Arti suci menyimpan alamat pengirim sudah jelas - kita perlu melanjutkan menjalankan program setelah penyisipan kita, yang berarti kita perlu tahu di mana harus mentransfer kontrol setelahnya.  Selanjutnya adalah panggilan ke fungsi WinAPI dari perpustakaan kernel32.dll - <code>VirtualProtect()</code> .  Diperlukan untuk mengubah atribut halaman memori di mana kode penyisipan berada.  Tentu saja, ketika mengompilasi program, itu muncul di bagian data, dan halaman memori yang sesuai memiliki akses baca dan tulis.  Kita juga perlu menambahkan izin untuk mengeksekusi isinya.  Akhirnya, kami mengembalikan alamat pengirim nyata yang tersimpan.  Tentu saja, alamat ini tidak akan dikembalikan ke kode yang disebut <code>InvokeAsm()</code> , karena  eksekusi segera setelah <code>return (void*)i;</code>  "Gagal" di sisipan.  Namun, konvensi pemanggilan yang digunakan oleh mesin virtual (stdcall dengan optimasi dinonaktifkan dan fastcall dengan diaktifkan) berarti mengembalikan nilai melalui register EAX, mis.  untuk kembali dari sisipan, kita harus mengikuti dua instruksi: <code>push eax</code> (kode 0x50) dan <code>ret</code> (kode 0xC3). <br><br><div class="spoiler">  <b class="spoiler_title">Klarifikasi</b> <div class="spoiler_text">  Di masa depan, kita akan berbicara tentang arsitektur x86 (atau lebih tepatnya, IA-32) - norak karena fakta bahwa pada waktu itu saya setidaknya entah bagaimana mengenalnya, tidak seperti, katakanlah, x86-64.  Namun, metode transfer kontrol yang dijelaskan di atas harus berfungsi untuk kode 64-bit. <br></div></div><br>  Akhirnya, Anda harus memperhatikan dua argumen yang tidak digunakan: <code>void* firstAsmArg</code> dan <code>void* secondAsmArg</code> .  Mereka diperlukan untuk mentransfer data pengguna sewenang-wenang ke insert assembler.  Argumen ini akan ditempatkan di tempat yang dikenal di stack (stdcall), atau, sekali lagi, di register terkenal (fastcall). <br><br><div class="spoiler">  <b class="spoiler_title">Sedikit tentang optimasi</b> <div class="spoiler_text">  Karena, dari sudut pandang kompiler, kode tidak mengerti apa itu, mungkin saja secara tidak sengaja membuang beberapa panggilan penting / sebaris sesuatu / tidak menyimpan beberapa argumen "tidak digunakan" / entah bagaimana mengganggu pelaksanaan rencana kami.  Ini sebagian diselesaikan oleh <code>[MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]</code> , namun, bahkan tindakan pencegahan seperti itu tidak memberikan efek yang diinginkan: misalnya, variabel lokal <code>i</code> , yang merupakan kunci untuk seluruh fungsi, tiba-tiba menjadi register, yang jelas-jelas merusak semuanya, .  Oleh karena itu, untuk sepenuhnya menghilangkan kemungkinan ada sesuatu yang salah, Anda harus membangun perpustakaan dengan optimasi dinonaktifkan (baik menonaktifkannya di properti proyek atau menggunakan konfigurasi Debug).  Akibatnya, stdcall akan digunakan, jadi di masa depan saya akan melanjutkan dari konvensi pemanggilan ini. <br></div></div><br><h2>  Perangkat tambahan </h2><br><h3>  Aman lebih baik daripada tidak aman </h3><br>  Tentu saja, tidak ada pertanyaan tentang keamanan apa pun (dalam arti kata ini digunakan dalam C #).  Namun, metode <code>InvokeAsm()</code> yang dijelaskan di atas beroperasi pada pointer, yang berarti bahwa itu hanya dapat dipanggil dari blok yang ditandai dengan kata kunci <code>unsafe</code> , yang tidak selalu nyaman - setidaknya itu memerlukan kompilasi dengan switch / tidak aman (atau tanda centang yang sesuai di properti proyek di VS).  Oleh karena itu, tampaknya logis untuk menyediakan shell yang beroperasi setidaknya IntPtr (paling buruk), dan idealnya, memungkinkan pengguna untuk menentukan jenis yang akan dikirim dan dikembalikan.  Nah, kedengarannya seperti generik, kita menulis generik, apa lagi yang ada, orang bertanya, untuk dibicarakan?  Bahkan - ada sesuatu. <br><br>  Yang paling jelas: bagaimana cara mendapatkan pointer ke argumen yang tipenya tidak diketahui?  Konstruksi tipe <code>T* ptr = &amp;arg</code> tidak diizinkan dalam C #, dan, secara umum, tidak sulit untuk memahami alasannya: pengguna dapat menggunakan salah satu dari jenis yang dikelola sebagai parameter tipe, penunjuk yang tidak dapat diperoleh.  Solusinya bisa dengan membatasi parameter tipe <code>unmanaged</code> , tetapi, pertama, itu muncul hanya dalam C # 7.3, dan kedua, itu tidak memungkinkan melewati string dan array sebagai argumen, meskipun operator <code>fixed</code> memungkinkan mereka untuk digunakan (kita mendapatkan pointer ke yang pertama karakter atau elemen array, masing-masing).  Selain itu, saya ingin memberi pengguna kesempatan untuk beroperasi termasuk jenis yang dikontrol - karena kami mulai melanggar aturan bahasa, kami akan melanggarnya sampai akhir! <br><br><h3>  Mendapatkan pointer ke objek yang dikelola dan objek dengan pointer </h3><br>  Dan lagi, setelah perundingan yang tidak membuahkan hasil, saya mulai mencari solusi akhir.  Kali ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel tentang Habré</a> membantu saya.  Singkatnya, salah satu metode yang diusulkan di dalamnya adalah menulis perpustakaan bantu, dan bukan dalam C #, tetapi langsung di IL.  Tugasnya adalah untuk mendorong objek (sebenarnya referensi ke objek) ke tumpukan mesin virtual, dilewatkan sebagai argumen, dan kemudian mengambil sesuatu yang lain dari tumpukan - misalnya, angka atau <code>IntPtr</code> .  Dengan melakukan langkah-langkah yang sama dalam urutan terbalik, Anda dapat mengubah pointer (misalnya, dikembalikan dari insert assembler) menjadi objek.  Metode ini baik karena semua yang terjadi jelas dan transparan.  Tetapi ada kekurangannya: Saya ingin bertahan dengan sesedikit mungkin file, jadi alih-alih menulis perpustakaan terpisah, saya memutuskan untuk menyematkan kode IL di yang utama.  Satu-satunya cara yang saya temukan adalah menulis metode rintisan dalam C #, membangun proyek, membongkar biner menggunakan ildasme, menulis ulang kode metode rintisan dan meletakkan semuanya kembali bersama-sama dengan ilasm.  Ini adalah beberapa tindakan tambahan, dan mengingat bahwa Anda perlu melakukannya setiap kali Anda membuatnya setelah membuat perubahan pada kode ... Secara umum, saya bosan dengan hal itu dengan cepat, dan saya mulai mencari alternatif. <br><br>  Tepat pada saat itu, sebuah buku yang luar biasa jatuh ke tangan saya, berkat yang saya pelajari banyak untuk diri saya sendiri - “CLR via C #” oleh Jeffrey Richter.  Di dalamnya, di suatu tempat di sekitar bab kedua puluh, kami berbicara tentang struktur <code>GCHandle</code> , yang memiliki metode <code>Alloc()</code> yang mengambil objek dan salah satu <code>GCHandleType</code> enumerasi <code>GCHandleType</code> .  Jadi, jika Anda memanggil metode ini dengan mengirimkannya objek yang diinginkan dan <code>GCHandle.Pinned</code> , Anda bisa mendapatkan alamat objek ini dalam memori.  Selain itu, sebelum memanggil <code>GCHandle.Free()</code> objek sudah diperbaiki, mis.  sepenuhnya dilindungi dari efek pengumpul sampah.  Namun, ada masalah tertentu.  Pertama-tama, <code>GCHandle</code> tidak membantu dengan cara apa pun untuk menyelesaikan konversi "pointer → object", hanya "object → pointer".  Lebih penting lagi, untuk menggunakan <code>GCHandleType.Pinned</code> kelas atau struktur objek yang alamatnya ingin kita dapatkan harus memiliki <code>[StructLayout(LayoutKind.Sequential)]</code> , sedangkan <code>LayoutKind.Auto</code> digunakan secara <code>LayoutKind.Auto</code> .  Jadi metode ini hanya cocok untuk beberapa jenis standar dan untuk jenis khusus yang awalnya dirancang dengan mempertimbangkan hal ini.  Bukan metode universal yang ingin kita temukan, bukan? <br><br>  Baiklah, coba lagi.  Sekarang mari kita perhatikan dua fungsi tidak berdokumen, yang, bagaimanapun, didukung oleh Roslyn: <code>__makeref()</code> dan <code>__refvalue()</code> .  Yang pertama mengambil objek dan mengembalikan instance dari struktur <code>TypedReference</code> yang menyimpan referensi ke objek dan tipenya, sedangkan yang kedua mengekstrak objek dari instance <code>typedReference</code> ditransmisikan.  Mengapa fitur-fitur ini penting bagi kami?  Karena <code>TypedReference</code> adalah struktur!  Dalam konteks diskusi, ini berarti bahwa kita bisa mendapatkan pointer ke sana, yang, bersama-sama, akan menjadi pointer ke bidang pertama dari struktur ini.  Yaitu, ia menyimpan tautan sangat ke objek yang menarik bagi kita.  Kemudian, untuk mendapatkan pointer ke objek yang dikelola, kita perlu membaca nilai dengan pointer ke <code>__makeref()</code> akan kembali dan mengubahnya menjadi pointer.  Untuk mendapatkan objek dengan pointer, Anda harus memanggil <code>__makeref()</code> dari objek kosong bersyarat dari tipe yang diperlukan, mendapatkan pointer ke instance <code>TypedReference</code> dikembalikan, menulis pointer ke objek di atasnya, dan kemudian memanggil <code>__refvalue()</code> .  Hasilnya adalah sesuatu seperti kode ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Tout ToInstance&lt;Tout&gt;(IntPtr ptr) { Tout temp = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; TypedReference tr = __makeref(temp); Marshal.WriteIntPtr(*(IntPtr*)(&amp;tr), ptr); Tout instance = __refvalue(tr, Tout); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* ToPointer&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> T obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T).IsValueType) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)&amp;tr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> **(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>***)&amp;tr; } }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Komentar</b> <div class="spoiler_text">  Kembali ke tugas menulis pembungkus yang aman untuk <code>InvokeAsm()</code> , harus dicatat bahwa metode mendapatkan pointer menggunakan <code>__makeref()</code> dan <code>__refvalue()</code> , tidak seperti menggunakan <code>GCHandle.Alloc(GCHandleType.Pinned)</code> , tidak menjamin bahwa pengumpul sampah kami tidak ada di mana-mana objek tidak akan bergerak.  Oleh karena itu, pembungkus harus dimulai dengan mematikan pengumpul sampah dan diakhiri dengan mengembalikan fungsinya.  Solusinya agak kasar, tetapi efektif. <br></div></div><br><h2>  Bagi mereka yang tidak ingat opcodes </h2><br>  Jadi, kami belajar cara memanggil kode biner, belajar untuk tidak hanya memberikan nilai langsung, tetapi juga menunjuk ke apa pun sebagai argumen ... Hanya ada satu masalah.  Di mana mendapatkan kode biner yang sama?  Anda dapat mempersenjatai diri dengan pensil, notepad, dan tabel opcode (misalnya, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> ) atau mengambil hex editor dengan dukungan assembler x86 atau bahkan penerjemah penuh, tetapi semua opsi ini berarti bahwa pengguna harus menggunakan sesuatu yang lain kecuali perpustakaan.  Ini bukan yang saya inginkan, jadi saya memutuskan untuk memasukkan penerjemah saya di perpustakaan, yang secara tradisional disebut SASM (kependekan dari Stack Assembler; itu tidak ada hubungannya dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IDE</a> ). <br><br><div class="spoiler">  <b class="spoiler_title">Penafian</b> <div class="spoiler_text">  Saya tidak pandai string parsing, jadi kode penerjemah ... baik, tidak sempurna, untuk sedikitnya.  Selain itu, saya tidak kuat dalam ekspresi reguler, jadi mereka tidak ada di sana.  Dan secara umum - pengurai berulang. <br></div></div><br>  Saya mungkin tidak akan berbicara tentang proses menciptakan "keajaiban" ini - tidak ada yang menarik dalam cerita ini, tetapi saya akan menjelaskan secara singkat fitur-fitur utama.  Sebagian besar instruksi x86 saat ini didukung.  Instruksi coprocessor matematika untuk bekerja dengan angka floating point dan dari ekstensi (MMX, SSE, AVX) belum didukung.  Dimungkinkan untuk mendeklarasikan konstanta, prosedur, variabel stack lokal, variabel global, memori yang dialokasikan selama terjemahan secara langsung dalam array dengan kode biner (jika variabel-variabel ini dinamai menggunakan label, maka nilainya juga dapat diperoleh dari C # setelah melakukan penyisipan dengan metode pemanggilan) <code>GetBYTEVariable()</code> , <code>GetWORDVariable()</code> , <code>GetDWORDVariable()</code> , <code>GetAStringVariable()</code> dan <code>GetWStringVariable()</code> dari objek <code>SASMCode</code> ), <code>addr</code> dan <code>invoke</code> makro hadir.  Salah satu fitur penting adalah dukungan untuk mengimpor fungsi dari perpustakaan eksternal menggunakan <code>extern &lt; &gt; lib &lt; &gt;</code> construct. <br><br>  <code>asmret</code> macro layak untuk paragraf terpisah.  Dalam proses penerjemahan, terbentang dalam 11 instruksi yang membentuk epilog.  Prolog ditambahkan ke awal kode yang diterjemahkan secara default.  Tugas mereka adalah untuk menyimpan / mengembalikan keadaan prosesor.  Selain itu, prolog menambahkan empat konstanta - <code>$first</code> , <code>$second</code> , <code>$this</code> dan <code>$return</code> .  Selama penerjemahan, konstanta ini digantikan oleh alamat pada stack, di mana, masing-masing, adalah argumen pertama dan kedua dilewatkan ke insert assembler, alamat dari perintah insert pertama dan alamat pengirim. <br><br><h2>  Ringkasan </h2><br>  Kode itu akan mengatakan lebih dari sekadar kata-kata, dan akan aneh jika tidak membagikan hasil kerja yang cukup panjang, jadi saya mengundang semua orang yang saya tertarik ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br><br>  Namun, jika saya mencoba untuk menggeneralisasi segala sesuatu yang telah dilakukan, maka, menurut pendapat saya, sebuah proyek yang menarik dan bahkan, sampai batas tertentu, tidak sia-sia.  Sebagai contoh, algoritma identik untuk menyortir insert dalam C # dan menggunakan insert assembler berbeda dalam kecepatan lebih dari dua kali (tentu saja, lebih memilih assembler).  Dalam proyek-proyek serius, tentu saja, tidak disarankan untuk menggunakan perpustakaan yang dihasilkan (efek samping yang tidak dapat diprediksi mungkin terjadi, meskipun sangat tidak mungkin), tetapi sangat mungkin untuk diri Anda sendiri. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464931/">https://habr.com/ru/post/id464931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464919/index.html">Kontrol sumber daya bawaan RAM yang digunakan dalam aplikasi</a></li>
<li><a href="../id464921/index.html">System.IO.Pipelines - alat yang sedikit dikenal bagi pecinta kinerja tinggi</a></li>
<li><a href="../id464925/index.html">Panduan Suara UX: situasi, pola, alat (dan sedikit dukungan moral)</a></li>
<li><a href="../id464927/index.html">Penambang ASIC bekas: risiko, verifikasi, dan hashrate yang ditambahkan</a></li>
<li><a href="../id464929/index.html">Pemuatan gambar browser yang malas (memuat atribut)</a></li>
<li><a href="../id464933/index.html">Aplikasi untuk e-book di sistem operasi Android. Bagian 4. Game</a></li>
<li><a href="../id464935/index.html">DevOpsSec Nyaman: Nemesida WAF Gratis untuk NGINX dengan API dan akun pribadi</a></li>
<li><a href="../id464937/index.html">Intisari materi menarik untuk pengembang seluler # 312 (pada 19 - 25 Agustus)</a></li>
<li><a href="../id464939/index.html">Menguji @ NonNull / @ Nullable annotations</a></li>
<li><a href="../id464947/index.html">Acara digital di Moskow dari 25 Agustus hingga 1 September</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>