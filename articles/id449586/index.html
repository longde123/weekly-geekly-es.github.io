<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏽 🍕 👩🏽‍🏭 Prinsip sulit dari tanggung jawab tunggal ↕️ ✊🏽 📫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Latar belakang 
 Selama beberapa tahun terakhir, saya telah berpartisipasi dalam sejumlah besar wawancara. Pada masing-masing dari mereka saya bertany...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prinsip sulit dari tanggung jawab tunggal</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449586/"><h1>  Latar belakang </h1><br>  Selama beberapa tahun terakhir, saya telah berpartisipasi dalam sejumlah besar wawancara.  Pada masing-masing dari mereka saya bertanya kepada pelamar tentang prinsip tanggung jawab tunggal (selanjutnya disebut SRP).  Dan kebanyakan orang tidak tahu apa-apa tentang prinsip itu.  Dan bahkan dari mereka yang bisa membaca definisi tersebut, hampir tidak ada yang bisa mengatakan bagaimana mereka menggunakan prinsip ini dalam pekerjaan mereka.  Mereka tidak bisa mengatakan bagaimana SRP mempengaruhi kode yang mereka tulis atau ulasan kode rekan.  Beberapa dari mereka juga memiliki kesalahpahaman bahwa SRP, seperti SOLID keseluruhan, hanya relevan untuk pemrograman berorientasi objek.  Juga, seringkali orang tidak dapat mengidentifikasi kasus-kasus pelanggaran prinsip ini, hanya karena kode ditulis dengan gaya yang direkomendasikan oleh kerangka kerja yang terkenal. <br>  Redux adalah contoh utama dari kerangka kerja yang pedomannya melanggar SRP. <br><a name="habracut"></a><br><h1>  Masalah SRP </h1><br>  Saya ingin memulai dengan nilai prinsip ini, dengan manfaat yang diberikannya.  Dan saya juga ingin mencatat bahwa prinsip ini berlaku tidak hanya untuk OOP, tetapi juga untuk pemrograman prosedural, fungsional dan bahkan deklaratif.  HTML, sebagai perwakilan dari yang terakhir, dapat dan juga harus didekomposisi, terutama sekarang ketika dikendalikan oleh kerangka kerja UI seperti React atau Angular.  Selain itu, prinsip ini berlaku untuk bidang teknik lainnya.  Dan tidak hanya rekayasa, ada ekspresi seperti itu dalam mata pelajaran militer: "memecah belah dan menaklukkan", yang pada umumnya merupakan perwujudan dari prinsip yang sama.  Kompleksitas membunuh, membaginya menjadi beberapa bagian dan Anda akan menang. <br>  Mengenai bidang teknik lainnya, di sini di hub, ada artikel yang menarik tentang bagaimana pesawat yang dikembangkan mesin gagal, tidak beralih untuk mundur atas perintah pilot.  Masalahnya adalah mereka salah menafsirkan keadaan sasis.  Alih-alih mengandalkan sistem yang mengendalikan sasis, pengontrol mesin langsung membaca sensor, sakelar batas, dll. Yang terletak di sasis.  Itu juga disebutkan dalam artikel bahwa mesin harus menjalani sertifikasi panjang sebelum itu bahkan memakai pesawat prototipe.  Dan pelanggaran SRP dalam kasus ini jelas mengarah pada fakta bahwa ketika mengubah desain sasis, kode pada pengontrol mesin perlu dimodifikasi dan disertifikasi ulang.  Lebih buruk lagi, pelanggaran terhadap prinsip ini hampir sepadan dengan pesawat dan kehidupan pilot.  Untungnya, pemrograman kita sehari-hari tidak mengancam konsekuensi seperti itu, namun, Anda tetap tidak boleh mengabaikan prinsip-prinsip penulisan kode yang baik.  Dan inilah alasannya: <br><br><ol><li>  Dekomposisi kode mengurangi kompleksitasnya.  Misalnya, jika solusi untuk masalah mengharuskan Anda untuk menulis kode dengan kompleksitas siklomatik empat, maka metode yang bertanggung jawab untuk menyelesaikan dua masalah tersebut pada saat yang sama akan membutuhkan kode dengan kompleksitas 16. Jika dibagi menjadi dua metode, maka total kompleksitas akan menjadi 8. Tentu saja, ini tidak selalu turun ke jumlah terhadap pekerjaan, tetapi tren akan kira-kira sama pula. </li><li>  Unit testing kode terurai disederhanakan dan lebih efisien. </li><li>  Kode terurai menciptakan lebih sedikit resistensi untuk berubah.  Saat melakukan perubahan, kecil kemungkinannya untuk melakukan kesalahan. </li><li>  Kode semakin terstruktur.  Mencari sesuatu dalam kode yang diatur dalam file dan folder jauh lebih mudah daripada di satu sepatu besar. </li><li>  Pemisahan kode boilerplate dari logika bisnis mengarah pada fakta bahwa pembuatan kode dapat diterapkan dalam suatu proyek. </li></ol><br>  Dan semua tanda ini berjalan bersamaan, ini adalah tanda-tanda kode yang sama.  Anda tidak harus memilih antara, misalnya, kode yang telah diuji dengan baik dan kode yang terstruktur dengan baik. <br><br><h1>  Definisi yang ada tidak berfungsi </h1><br>  Salah satu definisi adalah: "seharusnya hanya ada satu alasan untuk mengubah kode (kelas atau fungsi)".  Masalah dengan definisi ini adalah bahwa itu bertentangan dengan prinsip Open-Close, yang kedua dari kelompok prinsip SOLID.  Definisi: "kode harus terbuka untuk ekstensi dan ditutup untuk perubahan."  Satu alasan untuk perubahan versus larangan total terhadap perubahan.  Jika kita mengungkapkan secara lebih terperinci apa yang dimaksud di sini, ternyata tidak ada konflik antara prinsip-prinsip tersebut, tetapi pasti ada konflik antara definisi fuzzy. <br><br>  Definisi kedua, yang lebih langsung adalah: "kode hanya memiliki satu tanggung jawab."  Masalah dengan definisi ini adalah sifat manusia untuk menggeneralisasi segalanya. <br><br>  Misalnya, ada peternakan yang menanam ayam, dan pada saat itu peternakan hanya memiliki satu tanggung jawab.  Maka keputusan dibuat untuk membiakkan bebek di sana juga.  Secara naluriah, kita akan menyebutnya sebagai peternakan unggas, daripada mengakui bahwa sekarang ada dua tanggung jawab.  Tambahkan domba di sana, dan sekarang ini adalah peternakan hewan peliharaan.  Kemudian kami ingin menanam tomat atau jamur di sana, dan menghasilkan nama yang lebih umum berikut.  Hal yang sama berlaku untuk "satu alasan" untuk perubahan.  Alasan ini dapat digeneralisasikan dengan imajinasi yang mencukupi. <br><br>  Contoh lain adalah kelas manajer stasiun ruang angkasa.  Dia tidak melakukan apa-apa lagi, dia hanya mengelola stasiun ruang angkasa.  Bagaimana Anda menyukai kelas ini dengan satu tanggung jawab? <br>  Dan, karena saya menyebutkan Redux ketika pelamar pekerjaan mengetahui teknologi ini, saya juga mengajukan pertanyaan, apakah peredam SRP tipikal melanggar? <br><br>  Reducer, saya ingat, termasuk pernyataan switch, dan kebetulan itu tumbuh hingga puluhan atau bahkan ratusan kasus.  Dan satu-satunya tanggung jawab peredam adalah mengelola transisi status aplikasi Anda.  Itulah, secara harfiah, beberapa pelamar menjawab.  Dan tidak ada petunjuk yang bisa menghilangkan pendapat ini. <br><br>  Secara total, jika beberapa jenis kode tampaknya memenuhi prinsip SRP, tetapi pada saat yang sama baunya tidak menyenangkan - tahu mengapa ini terjadi.  Karena definisi "kode harus memiliki satu tanggung jawab" sama sekali tidak berfungsi. <br><br><h1>  Definisi yang lebih tepat </h1><br>  Dari percobaan dan kesalahan, saya memiliki definisi yang lebih baik: <br>  <b>Kode Tanggung Jawab Seharusnya Tidak Terlalu Besar</b> <br><br>  Ya, sekarang Anda perlu "mengukur" tanggung jawab kelas atau fungsi.  Dan jika itu terlalu besar, maka Anda perlu membagi tanggung jawab besar ini menjadi beberapa tanggung jawab yang lebih kecil.  Kembali ke contoh peternakan, bahkan tanggung jawab untuk membesarkan ayam bisa terlalu besar dan masuk akal untuk memisahkan ayam broiler dari ayam petelur, misalnya. <br><br>  Tetapi bagaimana mengukurnya, bagaimana menentukan bahwa tanggung jawab kode ini terlalu besar? <br><br>  Sayangnya, saya tidak memiliki metode yang akurat secara matematis, hanya metode empiris.  Dan sebagian besar dari semua ini datang dengan pengalaman, pengembang pemula sama sekali tidak dapat menguraikan kode, yang lebih maju lebih baik dalam memilikinya, meskipun mereka tidak selalu dapat menjelaskan mengapa mereka melakukannya dan bagaimana hal itu jatuh pada teori seperti SRP. <br><br><ol><li>  Kompleksitas siklomatik metrik.  Sayangnya, ada beberapa cara untuk menutupi metrik ini, tetapi jika Anda mengumpulkannya, maka ada kemungkinan ia akan menunjukkan tempat paling rentan dalam aplikasi Anda. </li><li>  Ukuran fungsi dan kelas.  Fungsi 800-line tidak perlu dibaca untuk memahami bahwa ada sesuatu yang salah dengannya. </li><li>  Banyak impor.  Suatu kali saya membuka file dalam proyek tim tetangga dan melihat seluruh layar impor, menekan halaman ke bawah dan lagi hanya ada impor di layar.  Hanya setelah pers kedua saya melihat awal kode.  Anda dapat mengatakan bahwa semua IDE modern dapat menyembunyikan impor di bawah "tanda plus", tetapi saya mengatakan bahwa kode yang baik tidak perlu menyembunyikan "bau".  Selain itu, saya perlu menggunakan kembali sepotong kecil kode dan saya menghapusnya dari file ini ke yang lain, dan seperempat atau bahkan sepertiga dari impor bergerak di belakang bagian ini.  Kode ini jelas bukan milik di sana. </li><li>  Tes unit.  Jika Anda masih kesulitan menentukan jumlah tanggung jawab, paksa diri Anda untuk menulis tes.  Jika Anda perlu menulis dua lusin tes pada tujuan utama suatu fungsi, tidak menghitung kasus batas, dll, maka diperlukan dekomposisi. </li><li>  Hal yang sama berlaku untuk terlalu banyak langkah persiapan di awal tes dan pemeriksaan di akhir.  Di Internet, omong-omong, Anda dapat menemukan pernyataan utopis yang disebut  Seharusnya hanya ada satu penegasan dalam ujian.  Saya percaya bahwa ide bagus yang sewenang-wenang, yang dibesarkan secara absolut, dapat menjadi sangat tidak praktis. </li><li>  Logika bisnis tidak boleh secara langsung bergantung pada alat eksternal.  Driver Oracle, rute Express, diinginkan untuk memisahkan semua ini dari logika bisnis dan / atau bersembunyi di balik antarmuka. </li></ol><br>  Beberapa poin: <br><br>  Tentu saja, seperti yang telah saya sebutkan, ada sisi lain dari koin, dan 800 metode pada satu baris mungkin tidak lebih baik dari satu metode pada 800 baris, harus ada keseimbangan dalam segala hal. <br><br>  Yang kedua - saya tidak membahas pertanyaan di mana harus meletakkan kode ini atau itu sesuai dengan tanggung jawabnya.  Sebagai contoh, kadang-kadang pengembang juga mengalami kesulitan dengan menarik terlalu banyak logika ke dalam lapisan DAL. <br><br>  Ketiga, saya tidak mengusulkan batasan keras tertentu seperti "tidak lebih dari 50 baris per fungsi".  Pendekatan ini hanya melibatkan arahan untuk pengembangan pengembang, dan mungkin tim.  Dia bekerja untuk saya, dia harus mendapatkan uang untuk orang lain. <br><br>  Dan akhirnya, jika Anda melewati TDD, ini saja sudah pasti akan membuat Anda menguraikan kode jauh sebelum Anda menulis 20 tes dengan masing-masing 20 pernyataan. <br><br><h1>  Memisahkan logika bisnis dari kode boilerplate </h1><br>  Berbicara tentang aturan kode yang baik, Anda tidak dapat melakukannya tanpa contoh.  Contoh pertama adalah tentang memisahkan kode boilerplate. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ae/61f/2a4/4ae61f2a4fba4563cbe17e3cfe6da69a.png"><br><br>  Contoh ini menunjukkan bagaimana kode back-end biasanya ditulis.  Orang-orang biasanya menulis logika yang tidak dapat dipisahkan dengan kode yang menunjukkan parameter ke server Web Express seperti URL, metode permintaan, dll. <br><br>  Saya menandai logika bisnis sebagai penanda hijau, dan kode diselingi merah yang berinteraksi dengan parameter kueri (merah). <br><br>  Saya selalu berbagi dua tanggung jawab ini dengan cara ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4b9/1a2/6a2/4b91a26a2b7d860804f22d72442c9947.png"><br><br>  Dalam contoh ini, semua interaksi dengan Express ada dalam file terpisah. <br><br>  Sekilas, mungkin tampak bahwa contoh kedua tidak membawa perbaikan, ada 2 file, bukan satu, baris tambahan muncul, yang belum ada sebelumnya - nama kelas dan metode tanda tangan.  Lalu apa yang diberikan oleh pemisahan kode ini?  Pertama-tama, "titik masuk aplikasi" tidak lagi Ekspres.  Sekarang ini adalah fungsi jenis huruf biasa.  Atau fungsi javascript, apakah C #, yang menulis WebAPI tentang apa. <br><br>  Ini, pada gilirannya, memungkinkan Anda untuk melakukan berbagai tindakan yang tidak tersedia pada contoh pertama.  Misalnya, Anda dapat menulis tes perilaku tanpa harus menaikkan Express, tanpa menggunakan permintaan http di dalam tes.  Dan bahkan tidak perlu melakukan segala macam pembasahan, ganti objek Router dengan objek "test" Anda, sekarang kode aplikasi hanya dapat dipanggil langsung dari tes. <br><br>  Fitur menarik lainnya yang disediakan oleh dekomposisi ini adalah bahwa Anda sekarang dapat menulis pembuat kode yang akan mem-parsing userApiService dan menghasilkan kode berdasarkan basisnya yang menghubungkan layanan ini dengan Express.  Dalam publikasi masa depan saya, saya berencana untuk menunjukkan yang berikut: pembuatan kode tidak akan menghemat waktu dalam proses penulisan kode.  Biaya pembuat kode tidak akan terbayar dengan fakta bahwa sekarang Anda tidak perlu menyalin pelat baja ini.  Pembuatan kode akan terbayar dengan fakta bahwa kode yang dihasilkannya tidak memerlukan dukungan, yang akan menghemat waktu dan, yang paling penting, saraf pengembang dalam jangka panjang. <br><br><h1>  Bagilah dan taklukkan </h1><br>  Metode penulisan kode ini sudah ada sejak lama, saya tidak menemukannya sendiri.  Saya baru saja sampai pada kesimpulan bahwa sangat nyaman ketika menulis logika bisnis.  Dan untuk ini, saya datang dengan contoh fiktif lain, menunjukkan bagaimana Anda dapat dengan cepat dan mudah menulis kode yang segera terurai dengan baik dan juga didokumentasikan sendiri dengan metode penamaan. <br><br>  Katakanlah Anda mendapat tugas dari analis bisnis untuk membuat metode yang mengirimkan laporan karyawan ke perusahaan asuransi.  Untuk melakukan ini: <br><br><ol><li>  Data harus diambil dari database </li><li>  Konversi ke format yang diinginkan </li><li>  Kirim laporan yang dihasilkan </li></ol><br>  Persyaratan semacam itu tidak selalu ditulis secara eksplisit, kadang-kadang urutan seperti itu dapat tersirat atau diklarifikasi dari percakapan dengan analis.  Dalam proses penerapan metode ini, jangan buru-buru membuka koneksi ke database atau jaringan, sebagai gantinya cobalah menerjemahkan algoritma sederhana ini ke dalam kode "apa adanya".  Sesuatu seperti ini: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendEmployeeReportToProvider</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reportId</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> dal.getEmployeeReportData(reportId);​ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> formatted = reportDataService.prepareEmployeeReport(data);​ <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> networkService.sendReport(formatted);​ }</code> </pre> <br>  Dengan pendekatan ini, ternyata menjadi kode yang cukup sederhana, mudah dibaca dan diuji, meskipun saya percaya bahwa kode ini sepele dan tidak perlu pengujian.  Dan itu adalah tanggung jawab metode ini untuk tidak mengirim laporan, tanggung jawabnya adalah untuk membagi tugas yang kompleks ini menjadi tiga subtugas. <br><br>  Selanjutnya, kami kembali ke persyaratan dan mengetahui bahwa laporan harus terdiri dari bagian gaji dan bagian dengan jam kerja. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareEmployeeReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reportData</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> salarySection = prepareSalarySection(reportData);​ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workHoursSection = prepareWorkHoursSection(reportData);​ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { salarySection, workHoursSection };​ }</code> </pre><br>  Dan seterusnya dan seterusnya kami terus memecah tugas sampai implementasi metode kecil yang dekat dengan sisa-sisa sepele. <br><br><h1>  Interaksi dengan Prinsip Buka-Tutup </h1><br>  Di awal artikel saya mengatakan bahwa definisi prinsip-prinsip SRP dan Open-Close saling bertentangan.  Yang pertama mengatakan bahwa harus ada satu alasan untuk perubahan, yang kedua mengatakan bahwa kode harus ditutup untuk perubahan.  Dan prinsip-prinsip itu sendiri, tidak hanya tidak saling bertentangan, sebaliknya, mereka bekerja secara sinergis satu sama lain.  Semua 5 prinsip SOLID ditujukan pada satu tujuan yang baik - untuk memberi tahu pengembang kode mana yang "buruk" dan bagaimana mengubahnya sehingga menjadi "baik".  Ironisnya - saya baru saja mengganti 5 tanggung jawab dengan satu lagi tanggung jawab. <br>  Jadi, di samping contoh sebelumnya dengan mengirimkan laporan ke perusahaan asuransi, bayangkan bahwa seorang analis bisnis mendatangi kami dan mengatakan bahwa sekarang kita perlu menambahkan fungsionalitas kedua ke proyek.  Laporan yang sama harus dicetak. <br>  Bayangkan ada pengembang yang percaya bahwa SRP "bukan tentang dekomposisi." <br>  Dengan demikian, prinsip ini tidak menunjukkan kepadanya perlunya pembusukan, dan ia menyadari seluruh tugas pertama dalam satu fungsi.  Setelah tugas datang kepadanya, ia menggabungkan dua tanggung jawab menjadi satu, karena  mereka memiliki banyak kesamaan dan menggeneralisasi namanya.  Sekarang tanggung jawab ini disebut "laporan layanan."  Implementasi ini terlihat seperti ini: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveEmployeeReportToProvider</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reportId, serveMethod</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* lots of code to read and convert the report */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(serveMethod) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sendToProvider: <span class="hljs-comment"><span class="hljs-comment">/* implementation of sending */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> print: <span class="hljs-comment"><span class="hljs-comment">/* implementation of printing */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre><br>  Mengingatkan beberapa kode dalam proyek Anda?  Seperti yang saya katakan, kedua definisi langsung SRP tidak berfungsi.  Mereka tidak mengirimkan informasi kepada pengembang bahwa kode tersebut tidak dapat ditulis.  Dan kode apa yang bisa ditulis.  Masih ada satu alasan bagi pengembang untuk mengubah kode ini.  Dia hanya menyebut alasan sebelumnya, menambahkan saklar dan tenang.  Dan di sini prinsip prinsip Open-Close datang ke tempat kejadian, yang secara langsung mengatakan bahwa tidak mungkin untuk memodifikasi file yang ada.  Itu perlu untuk menulis kode sehingga ketika menambahkan fungsionalitas baru perlu untuk menambahkan file baru, dan tidak mengedit yang sudah ada.  Artinya, kode semacam itu buruk dari sudut pandang dua prinsip sekaligus.  Dan jika yang pertama tidak membantu melihatnya, yang kedua akan membantu. <br><br>  Dan bagaimana metode membagi dan menaklukkan memecahkan masalah yang sama: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printEmployeeReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reportId</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> dal.getEmployeeReportData(reportId);​ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> formatted = reportDataService.prepareEmployeeReport(data);​ <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> printService.printReport(formatted);​ }</code> </pre><br>  Tambahkan fungsi baru.  Saya kadang-kadang menyebut mereka "fungsi skrip" karena mereka tidak membawa implementasi, mereka menentukan urutan panggilan bagian terurai tanggung jawab kami.  Jelas, dua baris pertama, dua tanggung jawab terdekomposisi pertama bertepatan dengan dua baris pertama dari fungsi yang diterapkan sebelumnya.  Sama seperti dua langkah pertama dari dua tugas yang dijelaskan oleh seorang analis bisnis bersamaan. <br>  Jadi, untuk menambahkan fungsionalitas baru ke proyek, kami menambahkan metode skrip baru dan layanan printService baru.  File lama tidak diubah.  Artinya, metode penulisan kode ini baik dari sudut pandang dua prinsip.  Dan SRP dan Buka-Tutup <br><br><h1>  Alternatif </h1><br>  Saya juga ingin menyebutkan alternatif, cara bersaing untuk mendapatkan kode terurai dengan baik yang terlihat seperti ini - pertama kita menulis kode "di dahi", kemudian refactor menggunakan berbagai teknik, misalnya, menurut buku Fowler "Refactoring".  Metode-metode ini mengingatkan saya pada pendekatan matematika untuk permainan catur, di mana Anda tidak mengerti apa yang sebenarnya Anda lakukan dalam hal strategi, Anda hanya menghitung "berat" dari posisi Anda dan mencoba untuk memaksimalkannya dengan membuat gerakan.  Saya tidak suka pendekatan ini karena satu alasan kecil - untuk menyebutkan metode dan variabel sudah sulit, dan ketika mereka tidak memiliki nilai bisnis, itu menjadi tidak mungkin.  Misalnya, jika teknik ini menyarankan Anda perlu memilih 6 garis yang identik dari sini dan dari sana, lalu menyorotinya, apa yang Anda sebut metode ini?  someSixIdenticalLines ()? <br>  Saya ingin melakukan reservasi - Saya tidak berpikir metode ini buruk, saya hanya tidak bisa belajar bagaimana menggunakannya. <br><br><h1>  Total </h1><br>  Dalam mengikuti prinsip, Anda dapat menemukan manfaat. <br><br>  Definisi "harus ada satu tanggung jawab" tidak berfungsi. <br><br>  Ada definisi yang lebih baik dan sejumlah fitur tidak langsung, yang disebut  kode berbau menandakan kebutuhan untuk membusuk. <br><br>  Pendekatan "membagi dan menaklukkan" memungkinkan Anda untuk segera menulis kode terstruktur dengan baik dan mendokumentasikan diri. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449586/">https://habr.com/ru/post/id449586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449572/index.html">Tentang tender, pembelian tender dan pembentukan tugas tender</a></li>
<li><a href="../id449574/index.html">Fitur SpecFlow yang Berguna</a></li>
<li><a href="../id449576/index.html">Perangkat lunak untuk mengelola lengan robot, secara otomatis mendeteksi konfigurasinya</a></li>
<li><a href="../id449578/index.html">Ilusi desain yang cerdas</a></li>
<li><a href="../id449584/index.html">Advantech EKI-2000 Industrial Unmanaged Switches</a></li>
<li><a href="../id449588/index.html">Apa kekuatan dan kelemahan pasar hosting</a></li>
<li><a href="../id449590/index.html">Kapitalisasi pasar Microsoft melebihi $ 1 triliun 04/25/2019</a></li>
<li><a href="../id449596/index.html">Game SFML sederhana</a></li>
<li><a href="../id449600/index.html">"Rumah pintar" dengan Yandex.Alisa</a></li>
<li><a href="../id449602/index.html">Terinspirasi oleh produksi dan bola basket: bagaimana Yandex mempersiapkan kejuaraan pemrograman</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>