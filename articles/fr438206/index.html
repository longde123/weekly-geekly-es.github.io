<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüíº üõ∑ üìÖ 26 recommandations pour l'utilisation du type var en Java ü§≥üèº üï∫üèæ üôè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le Java Local Variable Type Inference (LVTI) ou, bri√®vement, le type var (l'identifiant var n'est pas un mot-cl√©, mais un nom de type r√©serv√©) a √©t√© a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>26 recommandations pour l'utilisation du type var en Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438206/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/0c/mq/zq/0cmqzquxmzrie0s3ryftj5dqvga.png"></div><br><p>  <strong>Le Java Local Variable Type Inference (LVTI)</strong> ou, bri√®vement, le type <strong>var</strong> (l'identifiant <strong>var</strong> n'est pas un mot-cl√©, mais un nom de type r√©serv√©) a √©t√© ajout√© √† Java 10 √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 286: Local-Variable Type Inference</a> .  √âtant une fonction de compilation √† 100%, elle n'affecte pas le bytecode, le runtime ou les performances.  Fondamentalement, le compilateur v√©rifie le c√¥t√© droit de l'op√©rateur d'affectation et, en fonction de celui-ci, d√©termine le type sp√©cifique de la variable, puis le remplace par <strong>var</strong> . </p><br><p> De plus, il est utile pour r√©duire la verbosit√© du code passe-partout et acc√©l√®re √©galement le processus de programmation lui-m√™me.  Par exemple, il est tr√®s pratique d'√©crire <strong><code>var evenAndOdd =...</code></strong> au lieu de <strong><code>Map&lt;Boolean, List&lt;Integer&gt;&gt; evenAndOdd =...</code></strong> </p><br><p>  L'apparition de <strong>var</strong> ne signifie pas qu'il est toujours et pratique de l'utiliser partout, parfois il sera plus pratique de le faire avec des outils standards. </p><br><p>  Dans cet article, nous examinerons 26 situations, avec des exemples de cas o√π vous pouvez utiliser <strong>var</strong> et quand cela n'en vaut pas la peine. </p><a name="habracut"></a><br><h2 id="punkt-1-staraytes-davat-osmyslennye-imena-lokalnym-peremennym">  Point 1: essayez de donner des noms significatifs aux variables locales </h2><br><p>  Habituellement, nous nous concentrons sur le fait de donner les noms corrects aux champs des classes, mais nous ne pr√™tons pas la m√™me attention aux noms des variables locales.  Lorsque nos m√©thodes sont parfaitement impl√©ment√©es, contiennent peu de code et ont de bons noms, alors tr√®s souvent nous ne pr√™tons pas attention aux variables locales, ni m√™me r√©duisons compl√®tement leurs noms. </p><br><p>  Lorsque nous utilisons <strong>var</strong> au lieu d'√©crire des types explicites, le compilateur les d√©tecte automatiquement et substitue <strong>var</strong> .  Mais d'un autre c√¥t√©, √† la suite de cela, il devient plus difficile pour les gens de lire et de comprendre le code, car l'utilisation de <strong>var</strong> peut compliquer sa lisibilit√© et sa compr√©hension.  Dans la plupart des cas, cela est d√ª au fait que nous avons tendance √† consid√©rer le type d'une variable comme information principale et son nom comme secondaire.  Bien que ce soit exactement le contraire. </p><br><h3 id="primer-1">  Exemple 1: </h3><br><p>  Beaucoup conviendront probablement que dans l'exemple ci-dessous, les noms des variables locales sont trop courts: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// HAVING public boolean callDocumentationTask() { DocumentationTool dtl = ToolProvider.getSystemDocumentationTool(); DocumentationTask dtt = dtl.getTask(...); return dtt.call(); }</span></span></code> </pre> <br><p>  Lorsque vous utilisez des noms courts, avec <strong>var</strong> , le code devient encore moins clair: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public boolean callDocumentationTask() { var dtl = ToolProvider.getSystemDocumentationTool(); var dtt = dtl.getTask(...); return dtt.call(); }</span></span></code> </pre> <br><p>  Option plus pr√©f√©r√©e: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public boolean callDocumentationTask() { var documentationTool = ToolProvider.getSystemDocumentationTool(); var documentationTask = documentationTool.getTask(...); return documentationTask.call(); }</span></span></code> </pre> <br><h3 id="primer-2">  Exemple 2: </h3><br><p>  √âvitez de nommer des variables comme ceci: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public List&lt;Product&gt; fetchProducts(long userId) { var u = userRepository.findById(userId); var p = u.getCart(); return p; }</span></span></code> </pre> <br><p>  Utilisez des noms plus significatifs: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public List&lt;Product&gt; fetchProducts(long userId) { var user = userRepository.findById(userId); var productList = user.getCart(); return productList; }</span></span></code> </pre> <br><h3 id="primer-3">  Exemple 3: </h3><br><p>  Afin de donner des noms plus compr√©hensibles aux variables locales, n'allez pas aux extr√™mes: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var byteArrayOutputStream = new ByteArrayOutputStream();</span></span></code> </pre> <br><p>  Au lieu de cela, vous pouvez utiliser une option plus courte mais non moins compr√©hensible: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var outputStream = new ByteArrayOutputStream(); // or var outputStreamOfFoo = new ByteArrayOutputStream();</span></span></code> </pre> <br><p>  Saviez-vous que Java a une classe interne nomm√©e: <br>  <strong>InternalFrameInternalFrameTitlePaneInternalFrameTitlePaneMaximizeButtonWindowNotFocusedState</strong> </p><br><p>  Eh bien, nommer des variables avec ce type peut √™tre d√©licat :) </p><br><h2 id="punkt-2-ispolzuyte-literaly-chtoby-pomoch-var-tochno-opredelit-tip-primitiva-int-long-float-double">  Point 2: utilisez des litt√©raux pour aider √† d√©terminer le type de primitive (int, long, float, double) </h2><br><p>  Sans l'utilisation de litt√©raux pour les types primitifs, nous pouvons constater que les types attendus et implicites peuvent diff√©rer.  Cela est d√ª √† la conversion de type implicite utilis√©e par les variables <strong>var</strong> . </p><br><p>  Par exemple, les deux fragments de code suivants se comportent comme pr√©vu.  Ici, nous d√©clarons explicitement les types <strong>bool√©ens</strong> et <strong>char</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is of type boolean char a = 'a'; // this is of type char</span></span></code> </pre> <br><p>  Maintenant, nous utilisons <strong>var</strong> , au lieu de d√©clarer explicitement des types: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is inferred as boolean var a = 'a'; // this is inferred as char</span></span></code> </pre> <br><p>  Jusqu'ici tout va bien.  Faites maintenant la m√™me chose pour les types <strong>int</strong> , <strong>long</strong> , <strong>float</strong> et <strong>double</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> intNumber = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is of type int long longNumber = 20; // this is of type long float floatNumber = 20; // this is of type float, 20.0 double doubleNumber = 20; // this is of type double, 20.0</span></span></code> </pre> <br><p>  Bien que l'extrait de code ci-dessus soit simple et direct, utilisons maintenant <strong>var</strong> au lieu de sp√©cifier explicitement les types. </p><br><p>  A √©viter: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var intNumber = 20; // this is inferred as int var longNumber = 20; // this is inferred as int var floatNumber = 20; // this is inferred as int var doubleNumber = 20; // this is inferred as int</span></span></code> </pre> <br><p>  Les quatre variables seront sorties en tant <strong>qu'int</strong> .  Pour corriger ce comportement, nous devons utiliser des litt√©raux Java: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var intNumber = 20; // this is inferred as int var longNumber = 20L; // this is inferred as long var floatNumber = 20F; // this is inferred as float, 20.0 var doubleNumber = 20D; // this is inferred as double, 20.0</span></span></code> </pre> <br><p>  Mais que se passe-t-il si nous d√©clarons un nombre d√©cimal? </p><br><p>  √âvitez cela si vous pr√©voyez d'obtenir une variable de type <strong>float</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID, IF THIS IS A FLOAT var floatNumber = 20.5; // this is inferred as double</span></span></code> </pre> <br><p>  Pour √©viter toute surprise, utilisez le litt√©ral appropri√©: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER, IF THIS IS A FLOAT var floatNumber = 20.5F; // this is inferred as float</span></span></code> </pre> <br><h2 id="punkt-3-v-nekotoryh-sluchayah-var-i-neyavnye-privedeniya-tipov-mogut-uprostit-podderzhku-koda">  Point 3: dans certains cas, les conversions de type var et implicite peuvent simplifier la prise en charge du code </h2><br><p>  Par exemple, supposons que notre code se situe entre deux m√©thodes.  Une m√©thode permet d'obtenir un panier d'achat avec diff√©rents produits et de calculer le meilleur prix.  Pour ce faire, il compare diff√©rents prix sur le march√© et renvoie le prix total sous forme de <strong>flotteur</strong> .  Une autre m√©thode d√©duit simplement ce prix de la carte. </p><br><p>  Voyons d'abord une m√©thode qui calcule le meilleur prix: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeBestPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] items)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> price = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price; }</code> </pre> <br><p>  Deuxi√®mement, regardons la m√©thode qui fonctionne avec la carte: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">debitCard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount, ...)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Maintenant, nous pla√ßons notre code entre ces deux m√©thodes de service externes en tant que client.  Nos utilisateurs peuvent choisir les marchandises √† acheter, nous calculons le meilleur prix pour eux, puis radions les fonds de la carte: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public void purchaseCart(long customerId) { ... float price = computeBestPrice(...); debitCard(price, ...); }</span></span></code> </pre> <br><p>  Apr√®s un certain temps, la soci√©t√© propri√©taire de l'API d√©cide d'abandonner la repr√©sentation mat√©rielle des prix au profit de la d√©cimale (au lieu de <strong>float</strong> , <strong>int</strong> est d√©sormais utilis√©).  Ils ont donc modifi√© le code API comme suit: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeBestPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] items)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> realprice = ...; ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> price = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) realprice; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">debitCard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount, ...)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Le fait est que notre code utilise une d√©claration explicite d'une variable <strong>flottante</strong> comme prix.  Dans sa forme actuelle, nous recevrons une erreur lors de la compilation.  Mais si nous avions pr√©vu une telle situation et utilis√© <strong>var</strong> au lieu de <strong>float</strong> , alors notre code continuerait √† fonctionner sans probl√®me, gr√¢ce √† la conversion de type implicite: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public void purchaseCart(long customerId) { ... var price = computeBestPrice(...); debitCard(price, ...); }</span></span></code> </pre> <br><h2 id="punkt-4-kogda-literaly-ne-yavlyayutsya-podhodyaschim-resheniem-to-ispolzuyte-yavnoe-privedenie-tipov-ili-otkazhites-ot-var">  Point 4: lorsque les litt√©raux ne sont pas une solution appropri√©e, utilisez une conversion explicite ou jetez var </h2><br><p>  Certains types primitifs en Java n'ont pas de litt√©raux sp√©ciaux, par exemple des <strong>octets</strong> et <strong>des</strong> types <strong>courts</strong> .  Dans ce cas, en utilisant la d√©signation de type explicite, nous pouvons cr√©er des variables sans aucun probl√®me. </p><br><p>  Utilisez ceci au lieu de <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER THIS INSTEAD OF USING VAR byte byteNumber = 45; // this is of type byte short shortNumber = 4533; // this is of type short</span></span></code> </pre> <br><p>  Mais pourquoi dans cette situation privil√©gier la notation de type explicite au lieu d'utiliser simplement <strong>var</strong> ?  Eh bien, √©crivons ce code en utilisant <strong>var</strong> .  Notez que dans les deux cas, le compilateur supposera que vous avez besoin de variables de type <strong>int</strong> . </p><br><p>  √âvitez cette erreur: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var byteNumber = 45; // this is inferred as int var shortNumber = 4533; // this is inferred as int</span></span></code> </pre> <br><p>  Il n'y a pas de litt√©raux ici qui pourraient nous √™tre utiles, nous sommes donc oblig√©s d'utiliser une conversion explicite de type descendant.  Personnellement, j'√©viterai de telles situations, car je ne vois aucun avantage ici. </p><br><p>  N'utilisez cette entr√©e que si vous voulez vraiment utiliser <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER THIS ONLY IF YOU WANT TO USE VAR var byteNumber = (byte) 45; // this is inferred as byte var shortNumber = (short) 4533; // this is inferred as short</span></span></code> </pre> <br><h2 id="punkt-5-izbegayte-ispolzovaniya-var-esli-nazvaniya-peremennyh-ne-soderzhat-dostatochnoy-informacii-o-tipe-dlya-ponimaniya-koda">  Point 5: √©vitez d'utiliser var si les noms de variables ne contiennent pas suffisamment d'informations de type pour comprendre le code </h2><br><p>  L'avantage d'utiliser <strong>var</strong> est d'√©crire du code plus concis.  Par exemple, dans le cas de l'utilisation de constructeurs, nous pouvons √©viter d'avoir √† r√©p√©ter le nom de classe et, par cons√©quent, √©liminer la redondance de code. </p><br><p>  √âvitez ce qui suit: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID MemoryCacheImageInputStream inputStream = new MemoryCacheImageInputStream(...);</span></span></code> </pre> <br><p>  Utilisez plut√¥t: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var inputStream = new MemoryCacheImageInputStream(...);</span></span></code> </pre> <br><p>  Pour la construction ci-dessous, <strong>var</strong> sera √©galement un bon moyen de simplifier le code sans perdre d'informations. </p><br><p>  A √©viter: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fm = compiler.getStandardFileManager(...);</span></span></code> </pre> <br><p>  Utilisez le code suivant: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var compiler = ToolProvider.getSystemJavaCompiler(); var fileManager = compiler.getStandardFileManager(...);</span></span></code> </pre> <br><p>  Alors, pourquoi sommes-nous plus √† l'aise avec <strong>var</strong> dans les exemples pr√©sent√©s?  Parce que toutes les informations n√©cessaires sont contenues dans les noms des variables.  Mais si <strong>var</strong> , en combinaison avec un nom de variable, r√©duit la clart√© du code, il vaut mieux refuser de l'utiliser. </p><br><p>  A √©viter: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public File fetchCartContent() { return new File(...); } // As a human, is hard to infer the "cart" type without // inspecting the fetchCartContent() method var cart = fetchCartContent();</span></span></code> </pre> <br><p>  Utilisation: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public File fetchCartContent() { return new File(...); } File cart = fetchCartContent();</span></span></code> </pre> <br><p>  Consid√©rez, par exemple, l'utilisation de la classe <strong><code>java.nio.channels.Selector</code></strong> .  Cette classe a une m√©thode <strong><code>open()</code></strong> statique qui renvoie un nouveau s√©lecteur et l'ouvre.  Mais ici, vous pouvez facilement penser que la m√©thode <strong><code>Selector.open()</code></strong> peut renvoyer un type <strong>bool√©en</strong> , selon le succ√®s de l'ouverture d'un s√©lecteur existant, ou m√™me retourner <strong>void</strong> .  L'utilisation de <strong>var</strong> ici entra√Ænera une perte d'informations et une confusion dans le code. </p><br><h2 id="punkt-6-tip-var-garantiruet-bezopasnost-vo-vremya-kompilyacii">  Point 6: le type var garantit la s√©curit√© √† la compilation </h2><br><p>  Cela signifie que nous ne pouvons pas compiler une application qui tente d'effectuer des affectations incorrectes.  Par exemple, le code ci-dessous ne compile pas: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var items = 10; items = "10 items"; // incompatible types: String cannot be converted to int</span></span></code> </pre> <br><p>  Mais celui-ci compile: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = <span class="hljs-number"><span class="hljs-number">10</span></span>; items = <span class="hljs-number"><span class="hljs-number">20</span></span>;</code> </pre> <br><p>  Et ce code compile avec succ√®s: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = <span class="hljs-string"><span class="hljs-string">"10"</span></span>; items = <span class="hljs-string"><span class="hljs-string">"10 items"</span></span>;</code> </pre> <br><p>  Une fois que le compilateur a d√©fini la valeur de la variable <strong>var</strong> , nous ne pouvons assigner rien d'autre que ce type. </p><br><h2 id="punkt-7-var-ne-mozhet-ispolzovatsya-dlya-sozdaniya-ekzemplyara-konkretnogo-tipa-i-naznacheniya-ego-peremennoy-tipa-interfeysa">  Point 7: var ne peut pas √™tre utilis√© pour instancier un type sp√©cifique et l'affecter √† une variable de type d'interface </h2><br><p>  En Java, nous utilisons l'approche "programmation avec interfaces".  Par exemple, nous cr√©ons une instance de la classe ArrayList, en l'associant √† une abstraction (interface): </p><br><pre> <code class="java hljs">List&lt;String&gt; products = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br><p>  Et nous √©vitons des choses comme lier un objet √† une variable du m√™me type: </p><br><pre> <code class="java hljs">ArrayList&lt;String&gt; products = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br><p>  C'est la pratique la plus courante et la plus souhaitable, car nous pouvons facilement remplacer l'impl√©mentation d'interface par une autre.  Pour cela, il suffit de d√©clarer une variable de type interface. </p><br><p>  Nous ne pourrons pas suivre ce concept en utilisant des variables var, car  un type sp√©cifique leur est toujours affich√©.  Par exemple, dans l'extrait de code suivant, le compilateur d√©terminera le type de la variable en tant que <strong><code>ArrayList&lt;String&gt;</code></strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;String&gt;(); <span class="hljs-comment"><span class="hljs-comment">// inferred as ArrayList&lt;String&gt;</span></span></code> </pre> <br><p>  Plusieurs arguments de d√©fense expliquent ce comportement: </p><br><ul><li><p>  <strong>var est</strong> utilis√© pour les variables locales, o√π, dans la plupart des cas, la programmation utilisant des interfaces est moins utilis√©e que dans les cas avec des param√®tres de m√©thode renvoy√©s par des valeurs ou des champs </p><br></li><li><p>  La port√©e des variables locales doit √™tre petite, donc la r√©solution des probl√®mes caus√©s par le passage √† une autre impl√©mentation ne devrait pas √™tre tr√®s difficile </p><br></li><li><p>  <strong>var</strong> traite le code de droite comme l'initialiseur utilis√© pour d√©terminer le type r√©el.  Si, √† un moment donn√©, l'initialiseur est modifi√©, le type en cours de d√©finition peut √©galement changer, provoquant des probl√®mes dans le code qui repose sur cette variable. </p><br></li></ul><br><h2 id="punkt-8-veroyatnost-vyvoda-neozhidaemogo-tipa">  Paragraphe 8: la probabilit√© d'un type inattendu </h2><br><p>  L'utilisation de var en combinaison avec un <strong>op√©rateur diamant</strong> (&lt;&gt;) en l'absence d'informations pour identifier le type peut conduire √† des r√©sultats inattendus. </p><br><p>  Avant Java 7, l'inf√©rence de type explicite √©tait utilis√©e pour les collections: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicitly specifying generic class's instantiation parameter type List&lt;String&gt; products = new ArrayList&lt;String&gt;();</span></span></code> </pre> <br><p>  √Ä partir de Java 7, l' <strong>op√©rateur diamant a</strong> √©t√© introduit.  Dans ce cas, le compilateur d√©rivera ind√©pendamment le type n√©cessaire: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// inferring generic class's instantiation parameter type List&lt;String&gt; products = new ArrayList&lt;&gt;();</span></span></code> </pre> <br><p>  Quel type sera affich√© dans le code ci-dessous? </p><br><p>  Vous devez √©viter de telles constructions: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var productList = new ArrayList&lt;&gt;(); // is inferred as ArrayList&lt;Object&gt;</span></span></code> </pre> <br><p>  Le type sera d√©fini comme <strong><code>ArrayList&lt;Object&gt;</code></strong> .  En effet, les informations n√©cessaires pour d√©terminer correctement le type ne sont pas fournies.  Cela conduit au fait que le type le plus proche sera s√©lectionn√©, ce qui peut √™tre compatible avec le contexte de ce qui se passe.  Dans ce cas, <strong><code>Object</code></strong> . </p><br><p>  Ainsi, <strong>var</strong> ne peut √™tre utilis√© que si nous fournissons les informations n√©cessaires pour d√©terminer le type attendu.  Le type peut √™tre sp√©cifi√© directement ou pass√© en argument. </p><br><p>  Sp√©cifiez directement le type: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var productList = new ArrayList&lt;String&gt;(); // inferred as ArrayList&lt;String&gt;</span></span></code> </pre> <br><p>  Passez des arguments du type requis: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productStack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayDeque&lt;String&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(productStack); <span class="hljs-comment"><span class="hljs-comment">// inferred as ArrayList&lt;String&gt;</span></span></code> </pre> <br><pre> <code class="java hljs">Product p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(); Product p2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listOfProduct = List.of(p1, p2); <span class="hljs-comment"><span class="hljs-comment">// inferred as List&lt;Product&gt; // DON'T DO THIS var listofProduct = List.of(); // inferred as List&lt;Object&gt; listofProduct.add(p1); listofProduct.add(p2);</span></span></code> </pre> <br><h2 id="punkt-9-prisvoenie-massiva-k-var-peremennoy-ne-trebuet-skobok--">  √âl√©ment 9: attribuer un tableau √† une variable var ne n√©cessite pas de crochets [] </h2><br><p>  Nous savons tous comment d√©clarer des tableaux en Java: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// or, less preferred int numbers[] = new int[5];</span></span></code> </pre> <br><p>  Que diriez-vous d'utiliser <strong>var</strong> lorsque vous travaillez avec des tableaux?  Dans ce cas, il n'est pas n√©cessaire d'utiliser des supports sur le c√¥t√© gauche. </p><br><p>  √âvitez ce qui suit (cela ne compile m√™me pas): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var[] numbers = new int[5]; // or var numbers[] = new int[5];</span></span></code> </pre> <br><p>  Utilisation: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var numbers = new int[5]; // inferred as array of int numbers[0] = 2; // work numbers[0] = 2.2; // doesn't work numbers[0] = "2"; // doesn't work</span></span></code> </pre> <br><p>  Le code ci-dessous utilisant <strong>var</strong> ne parvient pas non plus √† compiler.  En effet, le compilateur ne peut pas d√©terminer le type du c√¥t√© droit: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type work as expected int[] numbers = {1, 2, 3}; // IT DOESN'T COMPILE var numbers = {1, 2, 3}; var numbers[] = {1, 2, 3}; var[] numbers = {1, 2, 3};</span></span></code> </pre> <br><h2 id="punkt-10-var-nelzya-ispolzovat-pri-obyavlenii-neskolkih-peremennyh-v-odnoy-stroke">  √âl√©ment 10: var ne peut pas √™tre utilis√© lors de la d√©claration de plusieurs variables sur la m√™me ligne </h2><br><p>  Si vous souhaitez d√©clarer des variables du m√™me type √† la fois, vous devez savoir que <strong>var</strong> ne convient pas pour cela.  Le code suivant ne compile pas: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE // error: 'var' is not allowed in a compound declaration var hello = "hello", bye = "bye", welcome = "welcome";</span></span></code> </pre> <br><p>  Utilisez plut√¥t: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER String hello = "hello", bye = "bye", welcome = "welcome";</span></span></code> </pre> <br><p>  Ou est-ce: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var hello = "hello"; var bye = "bye"; var welcome = "welcome";</span></span></code> </pre> <br><h2 id="punkt-11-lokalnye-peremennye-dolzhny-stremitsya-k-minimizacii-svoey-oblasti-vidimosti-tip-var-usilivaet-eto-utverzhdenie">  Point 11: les variables locales doivent s'efforcer de minimiser leur port√©e.  Le type var renforce cette d√©claration. </h2><br><p>  Gardez une petite port√©e pour les variables locales - je suis s√ªr que vous avez entendu cette d√©claration avant <strong>var</strong> . </p><br><p>  La lisibilit√© et la r√©solution rapide des bogues sont des arguments en faveur de cette approche.  Par exemple, d√©finissons une pile comme suit: </p><br><p>  √âvitez ceci: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID ... var stack = new Stack&lt;String&gt;(); stack.push("George"); stack.push("Tyllen"); stack.push("Martin"); stack.push("Kelly"); ... // 50 lines of code that doesn't use stack // George, Tyllen, Martin, Kelly stack.forEach(...); ...</span></span></code> </pre> <br><p>  Notez que nous appelons la m√©thode <strong><code>forEach()</code></strong> , h√©rit√©e de <strong><code>java.util.Vector</code></strong> .  Cette m√©thode passera par la pile comme n'importe quel autre vecteur et c'est ce dont nous avons besoin.  Mais maintenant, nous avons d√©cid√© d'utiliser <strong><code>ArrayDeque</code></strong> au lieu de <strong><code>Stack</code></strong> .  Lorsque nous faisons cela, la m√©thode <strong><code>forEach()</code></strong> recevra une impl√©mentation de ArrayDeque qui traversera la pile comme une pile standard (LIFO) </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID ... var stack = new ArrayDeque&lt;String&gt;(); stack.push("George"); stack.push("Tyllen"); stack.push("Martin"); stack.push("Kelly"); ... // 50 lines of code that doesn't use stack // Kelly, Martin, Tyllen, George stack.forEach(...); ...</span></span></code> </pre> <br><p>  Ce n'est pas ce que nous voulons.  Il est trop difficile de suivre l'erreur ici, car le code contenant la partie <strong><code>forEach()</code></strong> n'est pas situ√© √† c√¥t√© du code dans lequel les modifications ont √©t√© apport√©es.  Pour augmenter la vitesse de recherche et de correction des erreurs, il est pr√©f√©rable d'√©crire du code √† l'aide de la variable de <strong><code>stack</code></strong> , le plus pr√®s possible de la d√©claration de cette variable. </p><br><p>  Il est pr√©f√©rable de proc√©der comme suit: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER ... var stack = new Stack&lt;String&gt;(); stack.push("George"); stack.push("Tyllen"); stack.push("Martin"); stack.push("Kelly"); ... // George, Tyllen, Martin, Kelly stack.forEach(...); ... // 50 lines of code that doesn't use stack</span></span></code> </pre> <br><p>  D√©sormais, lorsque le d√©veloppeur passera de <strong><code>Stack</code></strong> √† <strong><code>ArrayQueue</code></strong> , il pourra rapidement remarquer l'erreur et la corriger. </p><br><h2 id="punkt-12-tip-var-uproschaet-ispolzovanie-razlichnyh-tipov-v-ternarnyh-operatorah">  Article 12: le type var simplifie l'utilisation de diff√©rents types dans les op√©rateurs ternaires </h2><br><p>  Nous pouvons utiliser diff√©rents types d'op√©randes sur le c√¥t√© droit de l'op√©rateur ternaire. </p><br><p>  Lors de la sp√©cification explicite de types, le code suivant ne se compile pas: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE List code = containsDuplicates ? List.of(12, 1, 12) : Set.of(12, 1, 10); // or Set code = containsDuplicates ? List.of(12, 1, 12) : Set.of(12, 1, 10);</span></span></code> </pre> <br><p>  N√©anmoins, nous pouvons le faire: </p><br><pre> <code class="java hljs">Collection code = containsDuplicates ? List.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>) : Set.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); Object code = containsDuplicates ? List.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>) : Set.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br><p>  Le code ci-dessous ne compile pas non plus: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE int code = intOrString ? 12112 : "12112"; String code = intOrString ? 12112 : "12112";</span></span></code> </pre> <br><p>  Mais vous pouvez utiliser des types plus g√©n√©raux: </p><br><pre> <code class="java hljs">Serializable code = intOrString ? <span class="hljs-number"><span class="hljs-number">12112</span></span> : <span class="hljs-string"><span class="hljs-string">"12112"</span></span>; Object code = intOrString ? <span class="hljs-number"><span class="hljs-number">12112</span></span> : <span class="hljs-string"><span class="hljs-string">"12112"</span></span>;</code> </pre> <br><p>  Dans tous ces cas, il vaut mieux pr√©f√©rer <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER // inferred as Collection&lt;Integer&gt; var code = containsDuplicates ? List.of(12, 1, 12) : Set.of(12, 1, 10); // inferred as Serializable var code = intOrString ? 12112 : "12112";</span></span></code> </pre> <br><p>  Il ne r√©sulte pas de ces exemples que le type <strong>var</strong> d√©finit les types d'objet au moment de l'ex√©cution.  Ce n'est pas le cas! </p><br><p>  Et, bien s√ªr, le type <strong>var</strong> fonctionnera correctement avec les m√™mes types des deux op√©randes: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// inferred as float var code = oneOrTwoDigits ? 1211.2f : 1211.25f;</span></span></code> </pre> <br><h2 id="punkt-13-tip-var-mozhet-byt-ispolzovan-vnutri-ciklov">  Point 13: le type var peut √™tre utilis√© √† l'int√©rieur des boucles </h2><br><p>  Nous pouvons facilement remplacer la d√©claration explicite des types dans les boucles <strong>for</strong> par le type <strong>var</strong> . </p><br><p>  Changer un type <strong>int</strong> explicite en <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type for (int i = 0; i &lt; 5; i++) { ... } // using var for (var i = 0; i &lt; 5; i++) { // i is inferred of type int ... }</span></span></code> </pre> <br><p>  Changer le type explicite d' <strong><code>Order</code></strong> en <strong>var</strong> : </p><br><pre> <code class="java hljs">List&lt;Order&gt; orderList = ...; <span class="hljs-comment"><span class="hljs-comment">// explicit type for (Order order : orderList) { ... } // using var for (var order : orderList) { // order type is inferred as Order ... }</span></span></code> </pre> <br><h2 id="punkt-14-var-otlichno-rabotaet-s-potokami-stream-v-java-8">  Point 14: var fonctionne bien avec les flux dans Java 8 </h2><br><p>  Il est tr√®s simple d'utiliser var de Java 10 avec des flux apparus dans Java 8. </p><br><p>  Vous pouvez simplement remplacer la d√©claration explicite de type <strong>Stream</strong> par <strong>var</strong> : </p><br><h3 id="primer-1-1">  Exemple 1: </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Stream&lt;Integer&gt; numbers = Stream.of(1, 2, 3, 4, 5); numbers.filter(t -&gt; t % 2 == 0).forEach(System.out::println); // using var var numbers = Stream.of(1, 2, 3, 4, 5); // inferred as Stream&lt;Integer&gt; numbers.filter(t -&gt; t % 2 == 0).forEach(System.out::println);</span></span></code> </pre> <br><h3 id="primer-2-1">  Exemple 2: </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit types Stream&lt;String&gt; paths = Files.lines(Path.of("...")); List&lt;File&gt; files = paths.map(p -&gt; new File(p)).collect(toList()); // using var var paths = Files.lines(Path.of("...")); // inferred as Stream&lt;String&gt; var files = paths.map(p -&gt; new File(p)).collect(toList()); // inferred as List&lt;File&gt;</span></span></code> </pre><br><h2 id="punkt-15-var-mozhno-ispolzovat-pri-obyavlenii-lokalnyh-peremennyh-prednaznachennyh-dlya-razbieniya-bolshih-cepochek-vyrazheniy-na-chasti">  Article 15: var peut √™tre utilis√© lors de la d√©claration de variables locales destin√©es √† casser de grandes cha√Ænes d'expressions en parties </h2><br><p>  Les expressions avec beaucoup d'imbrication semblent impressionnantes et ressemblent g√©n√©ralement √† une sorte de code intelligent et important.  Dans le cas o√π il est n√©cessaire de faciliter la lisibilit√© du code, il est recommand√© de d√©composer une grande expression √† l'aide de variables locales.  Mais parfois, √©crire beaucoup de variables locales semble √™tre un travail tr√®s √©puisant que j'aimerais √©viter. </p><br><p>  Un exemple d'une grande expression: </p><br><pre> <code class="java hljs">List&lt;Integer&gt; intList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// AVOID int result = intList.stream() .collect(Collectors.partitioningBy(i -&gt; i % 2 == 0)) .values() .stream() .max(Comparator.comparing(List::size)) .orElse(Collections.emptyList()) .stream() .mapToInt(Integer::intValue) .sum();</span></span></code> </pre> <br><p>  Mieux d√©composer le code en ses composants: </p><br><pre> <code class="java hljs">List&lt;Integer&gt; intList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// PREFER Map&lt;Boolean, List&lt;Integer&gt;&gt; evenAndOdd = intList.stream() .collect(Collectors.partitioningBy(i -&gt; i % 2 == 0)); Optional&lt;List&lt;Integer&gt;&gt; evenOrOdd = evenAndOdd.values() .stream() .max(Comparator.comparing(List::size)); int sumEvenOrOdd = evenOrOdd.orElse(Collections.emptyList()) .stream() .mapToInt(Integer::intValue) .sum();</span></span></code> </pre> <br><p>  La deuxi√®me version du code semble plus lisible et plus simple, mais la premi√®re version a √©galement le droit d'exister.  Il est tout √† fait normal que notre esprit s'adapte √† la compr√©hension de telles expressions et les pr√©f√®re aux variables locales.  Cependant, l'utilisation du type <strong>var</strong> peut aider √† briser de grandes structures en r√©duisant l'effort de d√©claration des variables locales: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> intList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// PREFER var evenAndOdd = intList.stream() .collect(Collectors.partitioningBy(i -&gt; i % 2 == 0)); var evenOrOdd = evenAndOdd.values() .stream() .max(Comparator.comparing(List::size)); var sumEvenOrOdd = evenOrOdd.orElse(Collections.emptyList()) .stream() .mapToInt(Integer::intValue) .sum();</span></span></code> </pre> <br><h2 id="punkt-16-var-ne-mozhet-byt-ispolzovan-kak-tip-vozvraschaemogo-znacheniya-ili-kak-tip-argumenta-metoda">  Article 16: var ne peut pas √™tre utilis√© comme type de retour ou comme type d'argument de m√©thode </h2><br><p>  Les deux extraits de code ci-dessous ne seront pas compil√©s. </p><br><p>  Utilisation de <strong>var</strong> comme type de retour: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE public var countItems(Order order, long timestamp) { ... }</span></span></code> </pre> <br><p>  Utilisation de <strong>var</strong> comme type d'argument de m√©thode: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE public int countItems(var order, var timestamp) { ... }</span></span></code> </pre> <br><h2 id="punkt-17-lokalnye-peremennye-tipa-var-mogut-byt-peredany-kak-parametry-metoda-ili-mogut-prinimat-vozvraschaemoe-metodom-znachenie">  Article 17: les variables locales de type var peuvent √™tre pass√©es comme param√®tres de la m√©thode ou elles peuvent prendre la valeur retourn√©e par la m√©thode </h2><br><p>  Les fragments de code suivants se compileront et fonctionneront correctement: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Order order, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timestamp)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> order = ...; <span class="hljs-comment"><span class="hljs-comment">// an Order instance var timestamp = ...; // a long representing a timestamp var itemsNr = countItems(order, timestamp); // inferred as int type ... }</span></span></code> </pre> <br><p>        : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;A, B&gt; <span class="hljs-function"><span class="hljs-function">B </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A container, B tocontain)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> order = ...; <span class="hljs-comment"><span class="hljs-comment">// Order instance var product = ...; // Product instance var resultProduct = contains(order, product); // inferred as Product type</span></span></code> </pre> <br><h2 id="punkt-18-peremennye-var-mogut-byt-ispolzovany-s-anonimnymi-klassami">  18:  var       </h2><br><p>    : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// AVOID Weighter weighter = new Weighter() { @Override public int getWeight(Product product) { ... } }; Product product = ...; // a Product instance int weight = weighter.getWeight(product);</span></span></code> </pre> <br><p>  <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// PREFER var weighter = new Weighter() { @Override public int getWeight(Product product) { ... } }; var product = ...; // a Product instance var weight = weighter.getWeight(product);</span></span></code> </pre> <br><h2 id="punkt-19-peremennye-tipa-var-mogut-ispolzovatsya-v-kachestve-effectively-final-peremennyh">  19:   var     effectively final  </h2><br><p> , : </p><br><blockquote> <em>‚Ä¶   Java SE 8,           ,   final  effectively final.   ,        ,  effectively final</em> . </blockquote><p>  ,   <strong>var</strong>   effectively final.      . </p><br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// AVOID int ratio = 5; // this is effectively final Weighter weighter = new Weighter() { @Override public int getWeight(Product product) { return ratio * ...; } }; ratio = 3; // this reassignment will cause error</span></span></code> </pre> <br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// PREFER var ratio = 5; // this is effectively final var weighter = new Weighter() { @Override public int getWeight(Product product) { return ratio * ...; } }; ratio = 3; // this reassignment will cause error</span></span></code> </pre> <br><h2 id="punkt-20-var-peremennye-mogut-byt-final-peremennymi">  20: var-   final- </h2><br><p>   <strong>var</strong>     ( ,     effectively final).     ,  <strong>final</strong> . </p><br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID // IT DOESN'T COMPILE public void discount(int price) { final int limit = 2000; final int discount = 5; if (price &gt; limit) { discount++; // this reassignment will cause error, which is ok } }</span></span></code> </pre> <br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER // IT DOESN'T COMPILE public void discount(int price) { final var limit = 2000; final var discount = 5; if (price &gt; limit) { discount++; // this reassignment will cause error, which is ok } }</span></span></code> </pre> <br><h2 id="punkt-21-lyambda-vyrazheniyam-i-ssylkam-na-metody-nuzhny-yavnye-tipy">  21:          </h2><br><p>  <strong>var</strong>   ,     .          ,   <strong>var</strong> ,  : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE // lambda expression needs an explicit target-type var f = x -&gt; x + 1; // method reference needs an explicit target-type var exception = IllegalArgumentException::new;</span></span></code> </pre> <br><p>   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER Function&lt;Integer, Integer&gt; f = x -&gt; x + 1; Supplier&lt;IllegalArgumentException&gt; exception = IllegalArgumentException::new;</span></span></code> </pre> <br><p>   Java 11   <strong>var</strong> -    .      Java 11: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java 11 (var x, var y) -&gt; x + y // or (@Nonnull var x, @Nonnull var y) -&gt; x + y</span></span></code> </pre> <br><h2 id="punkt-22-inicializirovat-var-nullem-zaprescheno">  22:  var null'  </h2><br><p>   <strong>var</strong> -  . </p><br><p>     (  <strong>null</strong> ): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var message = null; // result in an error of type: variable initializer is 'null'</span></span></code> </pre> <br><p>      ( ): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var message; // result in: cannot use 'var' on variable without initializer ... message = "hello";</span></span></code> </pre> <br><p>        : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER String message = null; // or String message; ... message = "hello";</span></span></code> </pre> <br><h2 id="punkt-23-tip-var-nelzya-ispolzovat-v-polyah-klassa">  23:  var      </h2><br><p>    <strong>var</strong>   ,      . </p><br><p>      : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE public class Product { private var price; // error: 'var' is not allowed here private var name; // error: 'var' is not allowed here ... }</span></span></code> </pre> <br><p>   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public class Product { private int price; private String name; ... }</span></span></code> </pre> <br><h2 id="punkt-24-var-nelzya-ispolzovat-v-bloke-catch">  24: var     catch </h2><br><p>   ,    try-with-resources </p><br><h3 id="blok-catch">  catch </h3><br><p>    ,    ,   . </p><br><p>     : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE try { TimeUnit.NANOSECONDS.sleep(5000); } catch (var ex) { ... }</span></span></code> </pre> <br><p>        : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER try { TimeUnit.NANOSECONDS.sleep(5000); } catch (InterruptedException ex) { ... }</span></span></code> </pre> <br><h3 id="try-with-resources"> Try-with-resources </h3><br><p> , <strong>var</strong>     <strong>try-with-resources</strong> . </p><br><p> ,  : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type try (PrintWriter writer = new PrintWriter(new File("welcome.txt"))) { writer.println("Welcome message"); }</span></span></code> </pre> <br><p>     <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// using var try (var writer = new PrintWriter(new File("welcome.txt"))) { writer.println("Welcome message"); }</span></span></code> </pre> <br><h2 id="punkt-25-tip-var-mozhno-ispolzovat-s-dzhenerikami">  25:  var     </h2><br><p> ,     : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ T temp = t; ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temp; }</code> </pre> <br><p>   ,  <strong>var</strong>    ,       <strong>T</strong>  <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = t; ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temp; }</code> </pre> <br><p>     ,      <strong>var</strong> : </p><br><pre> <code class="java hljs">codepublic &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;T&gt; numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); numbers.add((T) Integer.valueOf(<span class="hljs-number"><span class="hljs-number">3</span></span>)); numbers.add((T) Double.valueOf(<span class="hljs-number"><span class="hljs-number">3.9</span></span>)); numbers.add(t); numbers.add(<span class="hljs-string"><span class="hljs-string">"5"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// error: incompatible types: String cannot be converted to T ... }</span></span></code> </pre> <br><p>     <strong>List&lt;T&gt;</strong>  <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;T&gt;(); <span class="hljs-comment"><span class="hljs-comment">// DON'T DO THIS, DON'T FORGET THE, T var numbers = new ArrayList&lt;&gt;(); numbers.add((T) Integer.valueOf(3)); numbers.add((T) Double.valueOf(3.9)); numbers.add(t); numbers.add("5"); // error: incompatible types: String cannot be converted to T ... }</span></span></code> </pre> <br><h2 id="punkt-26-budte-vnimatelny-s-tipom-var-pri-ispolzovanii-wildcards--kovariantov-i-kontrvariantov">  26:     var   Wildcards (?),    </h2><br><h3 id="ispolzovanie--wildcards"> ? Wildcards </h3><br><p>    <strong>var</strong>  : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Class&lt;?&gt; clazz = Integer.class; // use var var clazz = Integer.class;</span></span></code> </pre> <br><p>    <strong>Foo&lt;?&gt;</strong>  <strong>var</strong>  ,      ,    <strong>var</strong>    . </p><br><p>     ,   , , ,    .       ,     <strong>ArrayList</strong>  ,     <strong>Collection&lt;?&gt;</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Collection&lt;?&gt; stuff = new ArrayList&lt;&gt;(); stuff.add("hello"); // compile time error stuff.add("world"); // compile time error // use var, this will remove the error, but I don't think that this is // what you had in mind when you wrote the above code var stuff = new ArrayList&lt;&gt;(); strings.add("hello"); // no error strings.add("world"); // no error</span></span></code> </pre> <br><h3 id="ispolzovanie-kovariantov-foo--extends-t-i-kontrvariantov-foo--super-t">   (Foo &lt;? extends T&gt;)   (Foo &lt;? super T&gt;) </h3><br><p>  ,    : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Class&lt;? extends Number&gt; intNumber = Integer.class; Class&lt;? super FilterReader&gt; fileReader = Reader.class;</span></span></code> </pre> <br><p>            ,    ,   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE // error: Class&lt;Reader&gt; cannot be converted to Class&lt;? extends Number&gt; Class&lt;? extends Number&gt; intNumber = Reader.class; // error: Class&lt;Integer&gt; cannot be converted to Class&lt;? super FilterReader&gt; Class&lt;? super FilterReader&gt; fileReader = Integer.class;</span></span></code> </pre> <br><p>    <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// using var var intNumber = Integer.class; var fileReader = Reader.class;</span></span></code> </pre> <br><p>       ,     .        ‚Äì     : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// this will compile just fine var intNumber = Reader.class; var fileReader = Integer.class;</span></span></code> </pre> <br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>       ¬´ <strong>var</strong> ¬ª,    Java 10.    ,           .   ,      <strong>var</strong>    ,     . </p><br><p>  <strong>var</strong>      Java! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438206/">https://habr.com/ru/post/fr438206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438192/index.html">Dell Inspiron 14 (5482): 2-en-1 √©conomique avec de bonnes options de mise √† niveau</a></li>
<li><a href="../fr438196/index.html">Si le projet est ¬´Th√©√¢tre¬ª, utilisez des acteurs ...</a></li>
<li><a href="../fr438198/index.html">Entrons dans l'histoire: o√π poussent les jambes des quadrocopt√®res</a></li>
<li><a href="../fr438202/index.html">JavaScript: champs de classes publics et priv√©s</a></li>
<li><a href="../fr438204/index.html">Dispositif de compilateur Swift. Partie 1</a></li>
<li><a href="../fr438210/index.html">Civilisation des ressorts, 2/5</a></li>
<li><a href="../fr438212/index.html">Preuve de concept: comment v√©rifier que la mise en ≈ìuvre du ML en vaut la chandelle</a></li>
<li><a href="../fr438214/index.html">Les startups technologiques am√©ricaines feront face √† de nouveaux contr√¥les gouvernementaux en 2019</a></li>
<li><a href="../fr438218/index.html">OpenSceneGraph: Gestion des √©v√©nements</a></li>
<li><a href="../fr438224/index.html">Quartier du gouvernement. Pilote</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>