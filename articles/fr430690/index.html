<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôèüèæ üë®üèº‚Äçüîß üõï Exceptions d√©terministes et gestion des erreurs dans le ¬´C ++ du futur¬ª üå•Ô∏è üçâ ü¶é</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il est √©trange que sur Habrt, il n'y ait encore aucune mention d'une proposition bruyante pour la norme C ++ appel√©e "Zero-overhead deterministic exce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exceptions d√©terministes et gestion des erreurs dans le ¬´C ++ du futur¬ª</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430690/"><iframe width="560" height="315" src="https://www.youtube.com/embed/cbUTAoHy6Ls" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Il est √©trange que sur Habrt, il n'y ait encore aucune mention d'une proposition bruyante pour la norme C ++ appel√©e "Zero-overhead deterministic exceptions".  Corriger cette omission ennuyeuse. </p><br><p>  Si vous √™tes pr√©occup√© par la surcharge des exceptions, ou si vous avez d√ª compiler du code sans prise en charge des exceptions, ou simplement vous demander ce qui se passera avec la gestion des erreurs en C ++ 2b (une r√©f√©rence √† un article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©cent</a> ), je demande cat.  Vous attendez une compression de tout ce qui peut maintenant √™tre trouv√© sur le sujet, et quelques sondages. </p><a name="habracut"></a><br><p>  La discussion ci-dessous portera non seulement sur les exceptions statiques, mais aussi sur les propositions li√©es √† la norme, et sur toutes sortes d'autres fa√ßons de g√©rer les erreurs.  Si vous √™tes all√© ici pour regarder la syntaxe, alors voici: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_error::divide_by_zero; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> as_double(x) / y; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; safe_divide(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (arithmetic_error e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p>  Si le type d'erreur sp√©cifique est sans importance / inconnu, alors vous pouvez simplement utiliser <code>throws</code> et <code>catch (std::error e)</code> . </p><br><h2 id="polezno-znat">  Bon √† savoir </h2><br><h3 id="stdoptional-i-stdexpected">  <code>std::optional</code> et <code>std::expected</code> </h3><br><p>  D√©cidons que l'erreur qui pourrait potentiellement se produire dans la fonction n'est pas suffisamment ¬´fatale¬ª pour lui jeter une exception.  Traditionnellement, les informations d'erreur sont renvoy√©es √† l'aide d'un param√®tre out.  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Filesystem TS</a> offre un certain nombre de fonctionnalit√©s similaires: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p, error_code&amp; ec);</code> </pre> <br><p>  (Ne lancez pas d'exception car le fichier n'a pas √©t√© trouv√©?) N√©anmoins, le traitement des codes d'erreur est lourd et sujet aux bogues.  Le code d'erreur est facile √† oublier de v√©rifier.  Les styles de code modernes <a href="">interdisent l'</a> utilisation des param√®tres de sortie; √† la place, il est recommand√© de renvoyer une structure contenant l'int√©gralit√© du r√©sultat. </p><br><p>  Depuis un certain temps, Boost propose une solution √©l√©gante pour g√©rer ces erreurs "non fatales" qui peuvent survenir dans certains sc√©narios dans le programme appropri√©: </p><br><pre> <code class="cpp hljs">expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span>, error_code&gt; file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p);</code> </pre> <br><p>  Le type <code>expected</code> est similaire √† la <code>variant</code> , mais il fournit une interface pratique pour travailler avec le ¬´r√©sultat¬ª et l '¬´erreur¬ª.  Par d√©faut, le r√©sultat <code>expected</code> est stock√© dans <code>expected</code> .  L'impl√©mentation <code>file_size</code> pourrait ressembler √† ceci: </p><br><pre> <code class="cpp hljs">file_info* info = read_file_info(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info != null) { <span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> size = info-&gt;size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; <span class="hljs-comment"><span class="hljs-comment">// &lt;== } else { error_code error = get_error(); return std::unexpected(error); // &lt;== }</span></span></code> </pre> <br><p>  Si la cause de l'erreur ne nous int√©resse pas, ou que l'erreur ne peut consister qu'en ¬´absence¬ª du r√©sultat, alors <code>optional</code> peut √™tre utilis√©: </p><br><pre> <code class="cpp hljs">optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; parse_int(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; s); optional&lt;U&gt; get_or_null(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;T, U&gt; m, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; key);</code> </pre> <br><p>  En C ++ 17 de Boost, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">facultatif</a> est venu √† std (sans prise en charge de <code>optional&lt;T&amp;&gt;</code> );  en C ++ 20, ils peuvent ajouter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">attendu</a> (ce n'est que la proposition, merci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">RamzesXI</a> pour la correction). </p><br><h3 id="contracts">  Contrats </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les contrats</a> (√† ne pas confondre avec les concepts) est une nouvelle fa√ßon d'imposer des restrictions sur les param√®tres de fonction, ajout√©e en C ++ 20.  3 annotations ajout√©es: </p><br><ul><li>  <strong>attend</strong> v√©rifie les param√®tres de la fonction </li><li>  <strong>assure la</strong> v√©rification de la valeur de retour de la fonction (la prend comme argument) </li><li>  <strong>assert</strong> - un remplacement civilis√© pour la macro assert </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsafe_at</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> [[expects: i &lt; v.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">]]</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> [[expects: x &gt;</span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>]] [[ensures ret: ret &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>]]; <span class="hljs-function"><span class="hljs-function">value </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_single</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;value&gt; result = fetch(<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;key&gt;{e}); [[assert result.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br><p>  Vous pouvez configurer en cas de rupture de contrat: </p><br><ul><li>  Appel√© comportement ind√©fini, ou </li><li>  Il a v√©rifi√© et appel√© l'exit utilisateur, apr√®s quoi <code>std::terminate</code> </li></ul><br><p>  Il est impossible de continuer √† ex√©cuter le programme apr√®s une rupture de contrat, car les compilateurs utilisent les garanties des contrats pour optimiser le code de fonction.  S'il y a le moindre doute que le contrat sera ex√©cut√©, il convient d'ajouter un contr√¥le suppl√©mentaire. </p><br><h3 id="stderror_code">  std :: error_code </h3><br><p>  La biblioth√®que <code>&lt;system_error&gt;</code> , ajout√©e en C ++ 11, vous permet de standardiser la gestion des codes d'erreur dans votre programme.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: error_code se</a> compose d'un code d'erreur de type <code>int</code> et d'un pointeur vers l'objet d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classe</a> descendante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: error_category</a> .  Cet objet, en effet, joue le r√¥le d'une table de fonctions virtuelles et d√©termine le comportement d'un <code>std::error_code</code> . </p><br><p>  Pour cr√©er votre <code>std::error_code</code> , vous devez d√©finir votre <code>std::error_category</code> descendante <code>std::error_category</code> et impl√©menter des m√©thodes virtuelles, dont la plus importante est: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Vous devez √©galement cr√©er une variable globale pour votre <code>std::error_category</code> .  La gestion des erreurs en utilisant error_code + attendu ressemble √† ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> result = expected&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code&gt;; my::<span class="hljs-function"><span class="hljs-function">file_handle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_internal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; error)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name)</span></span></span><span class="hljs-function"> -&gt; result&lt;my::file&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> raw_error = <span class="hljs-number"><span class="hljs-number">0</span></span>; my::file_handle maybe_result = open_internal(name, &amp;raw_error); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code error{raw_error, my::filesystem_error}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unexpected{error}; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> my::file{maybe_result}; } }</code> </pre> <br><p>  Il est important que dans <code>std::error_code</code> valeur de 0 signifie aucune erreur.  Si ce n'est pas le cas pour vos codes d'erreur, puis avant de convertir le code d'erreur syst√®me en <code>std::error_code</code> , vous devez remplacer le code 0 par SUCCESS, et vice versa. </p><br><p>  Tous les codes d'erreur syst√®me sont d√©crits dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">errc</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">system_category</a> .  Si √† un certain stade le transfert manuel des codes d'erreur devient trop morne, vous pouvez toujours envelopper le code d'erreur dans l' <code>std::system_error</code> et le jeter. </p><br><h3 id="destructive-move--trivially-relocatable">  Mouvement destructif / D√©pla√ßable de mani√®re triviale </h3><br><p>  Vous devez cr√©er une autre classe d'objets poss√©dant certaines ressources.  Tr√®s probablement, vous voudrez le rendre non copiable, mais mobile, car les objets immobiles ne sont pas pratiques √† utiliser (avant C ++ 17, ils ne pouvaient pas √™tre renvoy√©s par une fonction). </p><br><p>  Mais voici le probl√®me: dans tous les cas, l'objet d√©plac√© doit √™tre supprim√©.  Par cons√©quent, un √©tat sp√©cial ¬´d√©plac√©¬ª est n√©cessaire, c'est-√†-dire un objet ¬´vide¬ª qui ne supprime rien.  Il s'av√®re que chaque classe C ++ doit avoir un √©tat vide, c'est-√†-dire qu'il est impossible de cr√©er une classe avec un invariant (garantie) d'exactitude, du constructeur au destructeur.  Par exemple, il n'est pas possible de cr√©er la classe <code>open_file</code> correcte d'un fichier ouvert pendant toute sa dur√©e de vie.  Il est √©trange d'observer cela dans l'une des rares langues qui utilisent activement RAII. </p><br><p>  Un autre probl√®me est la mise √† z√©ro des anciens objets lors du d√©placement ajoute une surcharge: le remplissage de <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> peut √™tre jusqu'√† 2 fois plus lent que <code>std::vector&lt;T*&gt;</code> raison du tas de mise √† z√©ro des anciens pointeurs lors du d√©placement , suivi de la suppression des mannequins. </p><br><p>  Les d√©veloppeurs C ++ ont longtemps l√©ch√© Rust, o√π les destructeurs ne sont pas appel√©s sur les objets d√©plac√©s.  Cette fonctionnalit√© est appel√©e mouvement destructif.  Malheureusement, la proposition <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trivially relocatable</a> ne propose pas de l'ajouter au C ++.  Mais le probl√®me des frais g√©n√©raux sera r√©solu. </p><br><p>  Une classe est consid√©r√©e comme pouvant √™tre d√©plac√©e de mani√®re triviale si deux op√©rations: d√©placer et supprimer l'ancien objet sont √©quivalentes √† memcpy de l'ancien objet vers le nouveau.  L'ancien objet n'est pas supprim√©, les auteurs l'appellent "d√©posez-le par terre". </p><br><p>  Un type peut √™tre d√©plac√© de mani√®re triviale du point de vue du compilateur si l'une des conditions (r√©cursives) suivantes est vraie: </p><br><ol><li>  Il est trivialement mobile + trivialement destructible (par exemple structure <code>int</code> ou POD) </li><li>  Il s'agit de la classe marqu√©e avec l'attribut <code>[[trivially_relocatable]]</code> </li><li>  Il s'agit d'une classe dont tous les membres sont d√©localisables de mani√®re triviale. </li></ol><br><p>  Vous pouvez utiliser ces informations avec <code>std::uninitialized_relocate</code> , qui ex√©cute move init + delete de la mani√®re habituelle, ou acc√©l√©r√©e si possible.  Il est sugg√©r√© de marquer comme <code>[[trivially_relocatable]]</code> plupart des types de la biblioth√®que standard, y compris <code>std::string</code> , <code>std::vector</code> , <code>std::unique_ptr</code> .  Overhead <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> avec ceci √† l'esprit La proposition dispara√Ætra. </p><br><h2 id="chto-ne-tak-s-isklyucheniyami-seychas">  Qu'est-ce qui ne va pas avec les exceptions maintenant? </h2><br><p>  Le m√©canisme d'exception C ++ a √©t√© d√©velopp√© en 1992.  Diverses options de mise en ≈ìuvre ont √©t√© propos√©es.  Parmi ceux-ci, un m√©canisme de table d'exceptions a √©t√© s√©lectionn√© qui garantit l'absence de surcharge pour le chemin principal de l'ex√©cution du programme.  Parce que d√®s le moment m√™me de leur cr√©ation, on a suppos√© que les <em>exceptions devaient √™tre lev√©es tr√®s rarement</em> . </p><br><p>  Inconv√©nients des exceptions dynamiques (c'est-√†-dire r√©guli√®res): </p><br><ol><li>  Dans le cas de l'exception lev√©e, le temps syst√®me est en moyenne d'environ 10 000 √† 100 000 cycles CPU, et dans le pire des cas, il peut atteindre l'ordre des millisecondes </li><li>  La taille des fichiers binaires augmente de 15 √† 38% </li><li>  Incompatibilit√© avec l'interface de programmation C </li><li>  Prise en charge des exceptions implicites dans toutes les fonctions sauf <code>noexcept</code> .  Une exception peut √™tre lev√©e presque n'importe o√π dans le programme, m√™me lorsque l'auteur de la fonction ne s'y attend pas </li></ol><br><p>  En raison de ces lacunes, la port√©e des exceptions est consid√©rablement limit√©e.  Lorsque des exceptions ne peuvent pas s'appliquer: </p><br><ol><li>  Lorsque le d√©terminisme est important, c'est-√†-dire lorsqu'il est inacceptable que le code fonctionne ¬´parfois¬ª 10, 100, 1000 fois plus lentement que d'habitude </li><li>  Quand ils ne sont pas pris en charge dans ABI, par exemple, dans les microcontr√¥leurs </li><li>  Lorsqu'une grande partie du code est √©crit en C </li><li>  Dans les entreprises avec une grande quantit√© de code h√©rit√© ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Google Style Guide</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qt</a> ).  S'il y a au moins une fonction non prot√©g√©e contre les exceptions dans le code, alors selon la loi de la m√©chancet√©, une exception sera lev√©e t√¥t ou tard et cr√©era un bogue </li><li>  Dans les entreprises qui embauchent des programmeurs qui n'ont aucune id√©e de la s√©curit√© des exceptions </li></ol><br><p>  Selon les enqu√™tes, sur les lieux de travail de 52% (!) D√©veloppeurs, les exceptions sont interdites par les r√®gles de l'entreprise. </p><br><p>  Mais les exceptions font partie int√©grante de C ++!  En incluant l'indicateur <code>-fno-exceptions</code> , les d√©veloppeurs perdent la possibilit√© d'utiliser une partie importante de la biblioth√®que standard.  Cela incite en outre les entreprises √† planter leurs propres ¬´biblioth√®ques standard¬ª et, oui, √† inventer leur propre classe de cha√Ænes. </p><br><p>  Mais ce n'est pas la fin.  Les exceptions sont le seul moyen standard d'annuler la cr√©ation d'un objet dans le constructeur et de g√©n√©rer une erreur.  Lorsqu'elles sont d√©sactiv√©es, une abomination telle qu'une initialisation en deux phases appara√Æt.  Les op√©rateurs ne peuvent pas non plus utiliser de codes d'erreur, ils sont donc remplac√©s par des fonctions comme <code>assign</code> . </p><br><h2 id="proposal-isklyucheniya-buduschego">  Proposition: exceptions de l'avenir </h2><br><h3 id="novyy-mehanizm-peredachi-isklyucheniy">  Nouveau m√©canisme de transfert d'exception </h3><br><p>  Herb Sutter dans P709 a d√©crit un nouveau m√©canisme de transfert d'exception.  En principe, la fonction retourne <code>std::expected</code> , cependant, au lieu d'un discriminateur s√©par√© de type <code>bool</code> , qui avec l'alignement occupera jusqu'√† 8 octets sur la pile, ce bit d'information est transmis d'une mani√®re plus rapide, par exemple, √† Carry Flag. </p><br><p>  Les fonctions qui ne touchent pas CF (la plupart d'entre elles) auront la possibilit√© d'utiliser gratuitement des exceptions statiques - √† la fois dans le cas d'un retour normal et dans le cas d'une lev√©e d'exception!  Les fonctions qui sont oblig√©es de l'enregistrer et de le restaurer recevront une surcharge minimale, et ce sera toujours plus rapide que <code>std::expected</code> et tout code d'erreur ordinaire. </p><br><p>  Les exceptions statiques ressemblent √† ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::divide_by_zero; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == INT_MIN &amp;&amp; j == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::integer_divide_overflows; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i / j; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i + safe_divide(j, k); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; foo(i, j, k); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (erithmetic_errc e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p>  Dans la version alternative, il est propos√© d'obliger le mot cl√© <code>try</code> dans la m√™me expression que l'appel de la fonction <code>try i + safe_divide(j, k)</code> : <code>try i + safe_divide(j, k)</code> .  Cela r√©duira √† presque z√©ro le nombre de cas d'utilisation de fonctions <code>throws</code> dans du code qui n'est pas s√ªr pour les exceptions.  Dans tous les cas, contrairement aux exceptions dynamiques, l'EDI pourra en quelque sorte mettre en √©vidence les expressions qui l√®vent des exceptions. </p><br><p>  Le fait que l'exception lev√©e ne soit pas stock√©e s√©par√©ment, mais soit plac√©e directement √† la place de la valeur retourn√©e, impose des restrictions sur le type d'exception.  Premi√®rement, il doit √™tre facilement d√©pla√ßable.  Deuxi√®mement, sa taille ne doit pas √™tre tr√®s grande (mais elle peut √™tre quelque chose comme <code>std::unique_ptr</code> ), sinon toutes les fonctions r√©serveront plus d'espace sur la pile. </p><br><h3 id="status_code">  code_√©tat </h3><br><p>  La biblioth√®que <code>&lt;system_error2&gt;</code> , d√©velopp√©e par Niall Douglas, contiendra <code>status_code&lt;T&gt;</code> - "new, better" <code>error_code</code> .  Les principales diff√©rences avec <code>error_code</code> : </p><br><ol><li>  <code>status_code</code> - un type de mod√®le qui peut √™tre utilis√© pour stocker presque tous les codes d'erreur imaginables (avec un pointeur sur <code>status_code_category</code> ), sans utiliser d'exceptions statiques </li><li>  <code>T</code> devrait √™tre relocalisable et copiable (ce dernier, √† mon humble avis, ne devrait pas √™tre obligatoire).  Lors de la copie et de la suppression, les fonctions virtuelles sont appel√©es depuis <code>status_code_category</code> </li><li>  <code>status_code</code> peut stocker non seulement des donn√©es d'erreur, mais aussi des informations suppl√©mentaires sur une op√©ration r√©ussie </li><li>  La fonction "virtuelle" <code>code.message()</code> ne retourne pas <code>std::string</code> , mais <code>string_ref</code> est un type de cha√Æne assez lourd, qui est un virtuel "possiblement propri√©taire" <code>std::string_view</code> .  L√†, vous pouvez <code>string_view</code> ou <code>string</code> , ou <code>std::shared_ptr&lt;string&gt;</code> , ou une autre fa√ßon folle de poss√©der une cha√Æne.  Niall pr√©tend que <code>#include &lt;string&gt;</code> rendrait l'en-t√™te <code>&lt;system_error2&gt;</code> inacceptable "lourd" </li></ol><br><p>  Ensuite, <code>errored_status_code&lt;T&gt;</code> est entr√© - un wrapper sur <code>status_code&lt;T&gt;</code> avec le constructeur suivant: </p><br><pre> <code class="cpp hljs">errored_status_code(status_code&lt;T&gt;&amp;&amp; code) [[expects: code.failure() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>]] : code_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(code)) {}</code> </pre> <br><h3 id="error">  erreur </h3><br><p>  Le type d'exception par d√©faut ( <code>throws</code> sans type), ainsi que le type de base des exceptions vers lesquelles tous les autres sont convertis (comme <code>std::exception</code> ), est <code>error</code> .  Il est d√©fini quelque chose comme ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> error = errored_status_code&lt;<span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span>&gt;;</code> </pre> <br><p>  Autrement dit, l' <code>error</code> est un tel code d'√©tat "erreur", dans lequel la valeur ( <code>value</code> ) est plac√©e dans 1 pointeur.  √âtant donn√© que le m√©canisme <code>status_code_category</code> garantit une suppression, un d√©placement et une copie corrects, th√©oriquement, toute structure de donn√©es peut √™tre enregistr√©e par <code>error</code> .  En pratique, ce sera l'une des options suivantes: </p><br><ol><li>  Entiers (int) </li><li>  <code>std::exception_handle</code> , c'est-√†-dire un pointeur vers une exception dynamique lev√©e </li><li>  <code>status_code_ptr</code> , c'est-√†-dire <code>unique_ptr</code> √† un <code>status_code&lt;T&gt;</code> arbitraire <code>status_code&lt;T&gt;</code> . </li></ol><br><p>  Le probl√®me est que le cas 3 n'est pas pr√©vu pour donner la possibilit√© de ramener l' <code>error</code> au <code>status_code&lt;T&gt;</code> .  La seule chose que vous pouvez faire est d'obtenir le <code>message()</code> <code>status_code&lt;T&gt;</code> compress√©.  Pour pouvoir r√©cup√©rer la valeur renvoy√©e en <code>error</code> , lancez-la comme exception dynamique (!), Puis interceptez-la et enveloppez-la par <code>error</code> .  En g√©n√©ral, Niall pense que seuls les codes d'erreur et les messages de cha√Æne doivent √™tre stock√©s en <code>error</code> , ce qui est suffisant pour n'importe quel programme. </p><br><p>  Pour distinguer diff√©rents types d'erreurs, il est propos√© d'utiliser l'op√©rateur de comparaison ¬´virtuel¬ª: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { open_file(name); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e == filesystem_error::already_exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> my_exception(<span class="hljs-string"><span class="hljs-string">"Unknown filesystem error, unable to continue"</span></span>); } }</code> </pre> <br><p>  L'utilisation de plusieurs blocs catch ou <code>dynamic_cast</code> pour s√©lectionner le type d'exception √©chouera! </p><br><h3 id="vzaimodeystvie-s-dinamicheskimi-isklyucheniyami">  Interaction avec les exceptions dynamiques </h3><br><p>  Une fonction peut avoir l'une des sp√©cifications suivantes: </p><br><ul><li>  <code>noexcept</code> : ne lance aucune exception </li><li>  <code>throws(E)</code> : l√®ve uniquement les exceptions statiques </li><li>  (rien): ne lance que des exceptions dynamiques </li></ul><br><p>  <code>throws</code> n'implique <code>noexcept</code> .  Si une exception dynamique est lev√©e √† partir d'une fonction "statique", elle est encapsul√©e par <code>error</code> .  Si une exception statique est lev√©e √† partir d'une fonction "dynamique", elle est <code>status_error</code> dans une exception <code>status_error</code> .  Un exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> erithmetic_errc::divide_by_zero; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> throws </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  arithmetic_errc   intptr_t //     error foo(); } void baz() { // error    status_error bar(); } void qux() throws { // error    status_error baz(); }</span></span></code> </pre> <br><h3 id="isklyucheniya-v-c">  Exceptions en C?! </h3><br><p>  La proposition pr√©voit l'ajout d'exceptions √† l'une des futures normes C, et ces exceptions seront compatibles ABI avec les exceptions statiques C ++.  Une structure similaire √† <code>std::expected&lt;T, U&gt;</code> , l'utilisateur devra d√©clarer ind√©pendamment, bien que la redondance puisse √™tre supprim√©e √† l'aide de macros.  La syntaxe se compose (pour simplifier, nous le supposerons) des mots-cl√©s √©choue, √©choue, capture. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> / x; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> failure(<span class="hljs-number"><span class="hljs-number">2.0f</span></span>); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expected_int_float</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> error; }; <span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span> failed; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ expected_int_float result = <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(invert(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.failed) { print_error(result.error); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } print_success(result.value); }</code> </pre> <br><p>  Dans le m√™me temps, en C ++, il sera √©galement possible d'appeler des fonctions <code>fails</code> partir de C, en les d√©clarant dans des blocs <code>extern C</code> .  Ainsi, en C ++, il y aura toute une galaxie de mots-cl√©s pour travailler avec des exceptions: </p><br><ul><li>  <code>throw()</code> - supprim√© en C ++ 20 </li><li>  <code>noexcept</code> - sp√©cificateur de fonction, la fonction ne <code>noexcept</code> pas d'exceptions dynamiques </li><li>  <code>noexcept(expression)</code> - sp√©cificateur de fonction, la fonction ne <code>noexcept(expression)</code> pas d'exceptions dynamiques fournies </li><li>  <code>noexcept(expression)</code> - Une expression <code>noexcept(expression)</code> -t-elle des exceptions dynamiques? </li><li>  <code>throws(E)</code> - sp√©cificateur de fonction, la fonction l√®ve des exceptions statiques </li><li>  <code>throws</code> = <code>throws(std::error)</code> </li><li>  <code>fails(E)</code> - une fonction import√©e de C l√®ve des exceptions statiques </li></ul><br><p>  Ainsi, en C ++, ils ont apport√© (ou plut√¥t livr√©) un panier de nouveaux outils pour la gestion des erreurs.  Ensuite, une question logique se pose: </p><br><h2 id="kogda-chto-ispolzovat">  Quand utiliser quoi? </h2><br><h3 id="napravlenie-v-celom">  Direction g√©n√©rale </h3><br><p>  Les erreurs sont divis√©es en plusieurs niveaux: </p><br><ul><li>  Erreurs du programmeur.  Trait√© √† l'aide de contrats.  Ils conduisent √† la collecte des journaux et √† la fin du programme conform√©ment au concept de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fail-fast</a> .  Exemples: pointeur nul (lorsque ce n'est pas valide);  division par z√©ro;  erreurs d'allocation de m√©moire non pr√©vues par le programmeur. </li><li>  Erreurs fatales fournies par le programmeur.  Jet√© un million de fois moins souvent qu'un retour normal d'une fonction, ce qui justifie l'utilisation d'exceptions dynamiques.  Dans de tels cas, vous devez g√©n√©ralement red√©marrer l'ensemble du sous-syst√®me du programme ou donner une erreur lors de l'ex√©cution de l'op√©ration.  Exemples: connexion soudainement perdue avec la base de donn√©es;  erreurs d'allocation de m√©moire fournies par le programmeur. </li><li>  Erreurs r√©cup√©rables lorsque <em>quelque chose a</em> emp√™ch√© la fonction de terminer sa t√¢che, mais la fonction appelante peut savoir quoi en faire.  G√©r√© par des exceptions statiques.  Exemples: travailler avec le syst√®me de fichiers;  autres erreurs d'entr√©e / sortie (IO);  Donn√©es utilisateur incorrectes  <code>vector::at()</code> . </li><li>  La fonction a termin√© sa t√¢che avec succ√®s, mais avec un r√©sultat inattendu.  <code>std::optional</code> , <code>std::expected</code> , <code>std::variant</code> .  Exemples: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>stoi()</code></a> ;  <code>vector::find()</code> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>map::insert</code></a> . </li></ul><br><p>  Dans la biblioth√®que standard, il est plus fiable d'abandonner compl√®tement l'utilisation des exceptions dynamiques afin de rendre la compilation "sans exceptions" l√©gale. </p><br><h3 id="errno">  errno </h3><br><p>  Les fonctions qui utilisent <code>errno</code> pour travailler rapidement et facilement avec les codes d'erreur C et C ++ doivent √™tre remplac√©es respectivement par <code>throws(std::errc)</code> <code>fails(int)</code> et <code>throws(std::errc)</code> .  Pendant un certain temps, l'ancienne et la nouvelle version des fonctions de la biblioth√®que standard coexisteront, puis l'ancienne sera d√©clar√©e obsol√®te. </p><br><h3 id="out-of-memory">  M√©moire insuffisante </h3><br><p>  Les erreurs d'allocation de m√©moire sont g√©r√©es par le <code>new_handler</code> global <code>new_handler</code> , qui peut: </p><br><ol><li>  √âliminez le manque de m√©moire et poursuivez l'ex√©cution </li><li>  Jetez une exception </li><li>  Programme de crash </li></ol><br><p>  Maintenant, <code>std::bad_alloc</code> lanc√© par d√©faut.  Il est sugg√©r√© d'appeler <code>std::terminate()</code> par d√©faut.  Si vous avez besoin de l'ancien comportement, remplacez le gestionnaire par celui dont vous avez besoin au d√©but de <code>main()</code> . </p><br><p>  Toutes les fonctions existantes de la biblioth√®que standard deviendront <code>noexcept</code> et <code>noexcept</code> le programme lorsque <code>std::bad_alloc</code> .  Dans le m√™me temps, de nouvelles API comme <code>vector::try_push_back</code> seront ajout√©es, ce qui permettra des erreurs d'allocation de m√©moire. </p><br><h3 id="logic_error"> <code>logic_error</code> </h3> <br><p>  Les exceptions <code>std::logic_error</code> , <code>std::domain_error</code> , <code>std::invalid_argument</code> , <code>std::length_error</code> , <code>std::out_of_range</code> , <code>std::future_error</code> signalent une violation d'une condition de fonction.  Le nouveau mod√®le d'erreur devrait utiliser des contrats √† la place.  Les types d'exceptions r√©pertori√©s <strong>ne</strong> seront <strong>pas</strong> d√©pr√©ci√©s, mais presque tous les cas d'utilisation dans la biblioth√®que standard seront remplac√©s par <code>[[expects: ‚Ä¶]]</code> . </p><br><h2 id="tekuschee-sostoyanie-proposal">  Statut actuel de la proposition </h2><br><p>  La proposition est maintenant dans un √©tat provisoire.  Il a d√©j√† beaucoup chang√© et peut encore changer beaucoup.  Certains d√©veloppements n'ont pas r√©ussi √† √™tre publi√©s, donc l'API propos√©e <code>&lt;system_error2&gt;</code> pas enti√®rement pertinente. </p><br><p>  La proposition est d√©crite dans 3 documents: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P709</a> - document original des armoiries de Sutter </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1095</a> - Exceptions d√©termin√©es dans Niall Douglas Vision, certaines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">choses ont chang√©</a> , compatibilit√© avec le langage C ajout√©e </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1028</a> - API de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">impl√©mentation de test de</a> <code>std::error</code> </li></ol><br><p>  Il n'existe actuellement aucun compilateur qui prend en charge les exceptions statiques.  En cons√©quence, il n'est pas encore possible de faire leurs rep√®res. </p><br><p>           C++23.   , , ,   C++26,    ,  ,  . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>            ,     ,     .    ,            .   . </p><br><p>  ,   ^^ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430690/">https://habr.com/ru/post/fr430690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430680/index.html">√âcrire un processeur et un environnement simples pour cela</a></li>
<li><a href="../fr430682/index.html">Trois ans du projet de microsatellites lunaires: √©tapes de la croissance</a></li>
<li><a href="../fr430684/index.html">Analyse des contrats Ethereum en direct pour une erreur d'envoi non contr√¥l√©. 2e partie</a></li>
<li><a href="../fr430686/index.html">Pr√©sentation: la premi√®re machine de d√©coupe au jet d'eau de WAZER</a></li>
<li><a href="../fr430688/index.html">Transfert de donn√©es via QR anim√© vers Gomobile et GopherJS</a></li>
<li><a href="../fr430692/index.html">Ing√©nierie sociale avec le logiciel Universal Windows Platform (APPX)</a></li>
<li><a href="../fr430694/index.html">Un petit guide pour apprendre le C ++: quoi, quand et sur quoi cr√©er</a></li>
<li><a href="../fr430700/index.html">Un syst√®me unifi√© d'enregistrement des vues de films en ligne commencera √† fonctionner en Russie</a></li>
<li><a href="../fr430702/index.html">Formation tr√®s √©trange</a></li>
<li><a href="../fr430704/index.html">Comment les technologies de l'intelligence artificielle aident les ventes d'avias √† se d√©velopper: sept exemples</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>