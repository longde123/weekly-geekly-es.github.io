<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙏🏾 👨🏼‍🔧 🛕 Exceptions déterministes et gestion des erreurs dans le «C ++ du futur» 🌥️ 🍉 🦎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il est étrange que sur Habrt, il n'y ait encore aucune mention d'une proposition bruyante pour la norme C ++ appelée "Zero-overhead deterministic exce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exceptions déterministes et gestion des erreurs dans le «C ++ du futur»</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430690/"><iframe width="560" height="315" src="https://www.youtube.com/embed/cbUTAoHy6Ls" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Il est étrange que sur Habrt, il n'y ait encore aucune mention d'une proposition bruyante pour la norme C ++ appelée "Zero-overhead deterministic exceptions".  Corriger cette omission ennuyeuse. </p><br><p>  Si vous êtes préoccupé par la surcharge des exceptions, ou si vous avez dû compiler du code sans prise en charge des exceptions, ou simplement vous demander ce qui se passera avec la gestion des erreurs en C ++ 2b (une référence à un article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">récent</a> ), je demande cat.  Vous attendez une compression de tout ce qui peut maintenant être trouvé sur le sujet, et quelques sondages. </p><a name="habracut"></a><br><p>  La discussion ci-dessous portera non seulement sur les exceptions statiques, mais aussi sur les propositions liées à la norme, et sur toutes sortes d'autres façons de gérer les erreurs.  Si vous êtes allé ici pour regarder la syntaxe, alors voici: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_error::divide_by_zero; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> as_double(x) / y; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; safe_divide(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (arithmetic_error e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p>  Si le type d'erreur spécifique est sans importance / inconnu, alors vous pouvez simplement utiliser <code>throws</code> et <code>catch (std::error e)</code> . </p><br><h2 id="polezno-znat">  Bon à savoir </h2><br><h3 id="stdoptional-i-stdexpected">  <code>std::optional</code> et <code>std::expected</code> </h3><br><p>  Décidons que l'erreur qui pourrait potentiellement se produire dans la fonction n'est pas suffisamment «fatale» pour lui jeter une exception.  Traditionnellement, les informations d'erreur sont renvoyées à l'aide d'un paramètre out.  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Filesystem TS</a> offre un certain nombre de fonctionnalités similaires: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p, error_code&amp; ec);</code> </pre> <br><p>  (Ne lancez pas d'exception car le fichier n'a pas été trouvé?) Néanmoins, le traitement des codes d'erreur est lourd et sujet aux bogues.  Le code d'erreur est facile à oublier de vérifier.  Les styles de code modernes <a href="">interdisent l'</a> utilisation des paramètres de sortie; à la place, il est recommandé de renvoyer une structure contenant l'intégralité du résultat. </p><br><p>  Depuis un certain temps, Boost propose une solution élégante pour gérer ces erreurs "non fatales" qui peuvent survenir dans certains scénarios dans le programme approprié: </p><br><pre> <code class="cpp hljs">expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span>, error_code&gt; file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p);</code> </pre> <br><p>  Le type <code>expected</code> est similaire à la <code>variant</code> , mais il fournit une interface pratique pour travailler avec le «résultat» et l '«erreur».  Par défaut, le résultat <code>expected</code> est stocké dans <code>expected</code> .  L'implémentation <code>file_size</code> pourrait ressembler à ceci: </p><br><pre> <code class="cpp hljs">file_info* info = read_file_info(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info != null) { <span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> size = info-&gt;size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; <span class="hljs-comment"><span class="hljs-comment">// &lt;== } else { error_code error = get_error(); return std::unexpected(error); // &lt;== }</span></span></code> </pre> <br><p>  Si la cause de l'erreur ne nous intéresse pas, ou que l'erreur ne peut consister qu'en «absence» du résultat, alors <code>optional</code> peut être utilisé: </p><br><pre> <code class="cpp hljs">optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; parse_int(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; s); optional&lt;U&gt; get_or_null(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;T, U&gt; m, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; key);</code> </pre> <br><p>  En C ++ 17 de Boost, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">facultatif</a> est venu à std (sans prise en charge de <code>optional&lt;T&amp;&gt;</code> );  en C ++ 20, ils peuvent ajouter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">attendu</a> (ce n'est que la proposition, merci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">RamzesXI</a> pour la correction). </p><br><h3 id="contracts">  Contrats </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les contrats</a> (à ne pas confondre avec les concepts) est une nouvelle façon d'imposer des restrictions sur les paramètres de fonction, ajoutée en C ++ 20.  3 annotations ajoutées: </p><br><ul><li>  <strong>attend</strong> vérifie les paramètres de la fonction </li><li>  <strong>assure la</strong> vérification de la valeur de retour de la fonction (la prend comme argument) </li><li>  <strong>assert</strong> - un remplacement civilisé pour la macro assert </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsafe_at</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> [[expects: i &lt; v.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">]]</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> [[expects: x &gt;</span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>]] [[ensures ret: ret &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>]]; <span class="hljs-function"><span class="hljs-function">value </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_single</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;value&gt; result = fetch(<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;key&gt;{e}); [[assert result.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br><p>  Vous pouvez configurer en cas de rupture de contrat: </p><br><ul><li>  Appelé comportement indéfini, ou </li><li>  Il a vérifié et appelé l'exit utilisateur, après quoi <code>std::terminate</code> </li></ul><br><p>  Il est impossible de continuer à exécuter le programme après une rupture de contrat, car les compilateurs utilisent les garanties des contrats pour optimiser le code de fonction.  S'il y a le moindre doute que le contrat sera exécuté, il convient d'ajouter un contrôle supplémentaire. </p><br><h3 id="stderror_code">  std :: error_code </h3><br><p>  La bibliothèque <code>&lt;system_error&gt;</code> , ajoutée en C ++ 11, vous permet de standardiser la gestion des codes d'erreur dans votre programme.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: error_code se</a> compose d'un code d'erreur de type <code>int</code> et d'un pointeur vers l'objet d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classe</a> descendante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: error_category</a> .  Cet objet, en effet, joue le rôle d'une table de fonctions virtuelles et détermine le comportement d'un <code>std::error_code</code> . </p><br><p>  Pour créer votre <code>std::error_code</code> , vous devez définir votre <code>std::error_category</code> descendante <code>std::error_category</code> et implémenter des méthodes virtuelles, dont la plus importante est: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Vous devez également créer une variable globale pour votre <code>std::error_category</code> .  La gestion des erreurs en utilisant error_code + attendu ressemble à ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> result = expected&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code&gt;; my::<span class="hljs-function"><span class="hljs-function">file_handle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_internal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; error)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name)</span></span></span><span class="hljs-function"> -&gt; result&lt;my::file&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> raw_error = <span class="hljs-number"><span class="hljs-number">0</span></span>; my::file_handle maybe_result = open_internal(name, &amp;raw_error); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code error{raw_error, my::filesystem_error}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unexpected{error}; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> my::file{maybe_result}; } }</code> </pre> <br><p>  Il est important que dans <code>std::error_code</code> valeur de 0 signifie aucune erreur.  Si ce n'est pas le cas pour vos codes d'erreur, puis avant de convertir le code d'erreur système en <code>std::error_code</code> , vous devez remplacer le code 0 par SUCCESS, et vice versa. </p><br><p>  Tous les codes d'erreur système sont décrits dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">errc</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">system_category</a> .  Si à un certain stade le transfert manuel des codes d'erreur devient trop morne, vous pouvez toujours envelopper le code d'erreur dans l' <code>std::system_error</code> et le jeter. </p><br><h3 id="destructive-move--trivially-relocatable">  Mouvement destructif / Déplaçable de manière triviale </h3><br><p>  Vous devez créer une autre classe d'objets possédant certaines ressources.  Très probablement, vous voudrez le rendre non copiable, mais mobile, car les objets immobiles ne sont pas pratiques à utiliser (avant C ++ 17, ils ne pouvaient pas être renvoyés par une fonction). </p><br><p>  Mais voici le problème: dans tous les cas, l'objet déplacé doit être supprimé.  Par conséquent, un état spécial «déplacé» est nécessaire, c'est-à-dire un objet «vide» qui ne supprime rien.  Il s'avère que chaque classe C ++ doit avoir un état vide, c'est-à-dire qu'il est impossible de créer une classe avec un invariant (garantie) d'exactitude, du constructeur au destructeur.  Par exemple, il n'est pas possible de créer la classe <code>open_file</code> correcte d'un fichier ouvert pendant toute sa durée de vie.  Il est étrange d'observer cela dans l'une des rares langues qui utilisent activement RAII. </p><br><p>  Un autre problème est la mise à zéro des anciens objets lors du déplacement ajoute une surcharge: le remplissage de <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> peut être jusqu'à 2 fois plus lent que <code>std::vector&lt;T*&gt;</code> raison du tas de mise à zéro des anciens pointeurs lors du déplacement , suivi de la suppression des mannequins. </p><br><p>  Les développeurs C ++ ont longtemps léché Rust, où les destructeurs ne sont pas appelés sur les objets déplacés.  Cette fonctionnalité est appelée mouvement destructif.  Malheureusement, la proposition <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trivially relocatable</a> ne propose pas de l'ajouter au C ++.  Mais le problème des frais généraux sera résolu. </p><br><p>  Une classe est considérée comme pouvant être déplacée de manière triviale si deux opérations: déplacer et supprimer l'ancien objet sont équivalentes à memcpy de l'ancien objet vers le nouveau.  L'ancien objet n'est pas supprimé, les auteurs l'appellent "déposez-le par terre". </p><br><p>  Un type peut être déplacé de manière triviale du point de vue du compilateur si l'une des conditions (récursives) suivantes est vraie: </p><br><ol><li>  Il est trivialement mobile + trivialement destructible (par exemple structure <code>int</code> ou POD) </li><li>  Il s'agit de la classe marquée avec l'attribut <code>[[trivially_relocatable]]</code> </li><li>  Il s'agit d'une classe dont tous les membres sont délocalisables de manière triviale. </li></ol><br><p>  Vous pouvez utiliser ces informations avec <code>std::uninitialized_relocate</code> , qui exécute move init + delete de la manière habituelle, ou accélérée si possible.  Il est suggéré de marquer comme <code>[[trivially_relocatable]]</code> plupart des types de la bibliothèque standard, y compris <code>std::string</code> , <code>std::vector</code> , <code>std::unique_ptr</code> .  Overhead <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> avec ceci à l'esprit La proposition disparaîtra. </p><br><h2 id="chto-ne-tak-s-isklyucheniyami-seychas">  Qu'est-ce qui ne va pas avec les exceptions maintenant? </h2><br><p>  Le mécanisme d'exception C ++ a été développé en 1992.  Diverses options de mise en œuvre ont été proposées.  Parmi ceux-ci, un mécanisme de table d'exceptions a été sélectionné qui garantit l'absence de surcharge pour le chemin principal de l'exécution du programme.  Parce que dès le moment même de leur création, on a supposé que les <em>exceptions devaient être levées très rarement</em> . </p><br><p>  Inconvénients des exceptions dynamiques (c'est-à-dire régulières): </p><br><ol><li>  Dans le cas de l'exception levée, le temps système est en moyenne d'environ 10 000 à 100 000 cycles CPU, et dans le pire des cas, il peut atteindre l'ordre des millisecondes </li><li>  La taille des fichiers binaires augmente de 15 à 38% </li><li>  Incompatibilité avec l'interface de programmation C </li><li>  Prise en charge des exceptions implicites dans toutes les fonctions sauf <code>noexcept</code> .  Une exception peut être levée presque n'importe où dans le programme, même lorsque l'auteur de la fonction ne s'y attend pas </li></ol><br><p>  En raison de ces lacunes, la portée des exceptions est considérablement limitée.  Lorsque des exceptions ne peuvent pas s'appliquer: </p><br><ol><li>  Lorsque le déterminisme est important, c'est-à-dire lorsqu'il est inacceptable que le code fonctionne «parfois» 10, 100, 1000 fois plus lentement que d'habitude </li><li>  Quand ils ne sont pas pris en charge dans ABI, par exemple, dans les microcontrôleurs </li><li>  Lorsqu'une grande partie du code est écrit en C </li><li>  Dans les entreprises avec une grande quantité de code hérité ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Google Style Guide</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qt</a> ).  S'il y a au moins une fonction non protégée contre les exceptions dans le code, alors selon la loi de la méchanceté, une exception sera levée tôt ou tard et créera un bogue </li><li>  Dans les entreprises qui embauchent des programmeurs qui n'ont aucune idée de la sécurité des exceptions </li></ol><br><p>  Selon les enquêtes, sur les lieux de travail de 52% (!) Développeurs, les exceptions sont interdites par les règles de l'entreprise. </p><br><p>  Mais les exceptions font partie intégrante de C ++!  En incluant l'indicateur <code>-fno-exceptions</code> , les développeurs perdent la possibilité d'utiliser une partie importante de la bibliothèque standard.  Cela incite en outre les entreprises à planter leurs propres «bibliothèques standard» et, oui, à inventer leur propre classe de chaînes. </p><br><p>  Mais ce n'est pas la fin.  Les exceptions sont le seul moyen standard d'annuler la création d'un objet dans le constructeur et de générer une erreur.  Lorsqu'elles sont désactivées, une abomination telle qu'une initialisation en deux phases apparaît.  Les opérateurs ne peuvent pas non plus utiliser de codes d'erreur, ils sont donc remplacés par des fonctions comme <code>assign</code> . </p><br><h2 id="proposal-isklyucheniya-buduschego">  Proposition: exceptions de l'avenir </h2><br><h3 id="novyy-mehanizm-peredachi-isklyucheniy">  Nouveau mécanisme de transfert d'exception </h3><br><p>  Herb Sutter dans P709 a décrit un nouveau mécanisme de transfert d'exception.  En principe, la fonction retourne <code>std::expected</code> , cependant, au lieu d'un discriminateur séparé de type <code>bool</code> , qui avec l'alignement occupera jusqu'à 8 octets sur la pile, ce bit d'information est transmis d'une manière plus rapide, par exemple, à Carry Flag. </p><br><p>  Les fonctions qui ne touchent pas CF (la plupart d'entre elles) auront la possibilité d'utiliser gratuitement des exceptions statiques - à la fois dans le cas d'un retour normal et dans le cas d'une levée d'exception!  Les fonctions qui sont obligées de l'enregistrer et de le restaurer recevront une surcharge minimale, et ce sera toujours plus rapide que <code>std::expected</code> et tout code d'erreur ordinaire. </p><br><p>  Les exceptions statiques ressemblent à ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::divide_by_zero; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == INT_MIN &amp;&amp; j == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::integer_divide_overflows; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i / j; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i + safe_divide(j, k); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; foo(i, j, k); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (erithmetic_errc e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p>  Dans la version alternative, il est proposé d'obliger le mot clé <code>try</code> dans la même expression que l'appel de la fonction <code>try i + safe_divide(j, k)</code> : <code>try i + safe_divide(j, k)</code> .  Cela réduira à presque zéro le nombre de cas d'utilisation de fonctions <code>throws</code> dans du code qui n'est pas sûr pour les exceptions.  Dans tous les cas, contrairement aux exceptions dynamiques, l'EDI pourra en quelque sorte mettre en évidence les expressions qui lèvent des exceptions. </p><br><p>  Le fait que l'exception levée ne soit pas stockée séparément, mais soit placée directement à la place de la valeur retournée, impose des restrictions sur le type d'exception.  Premièrement, il doit être facilement déplaçable.  Deuxièmement, sa taille ne doit pas être très grande (mais elle peut être quelque chose comme <code>std::unique_ptr</code> ), sinon toutes les fonctions réserveront plus d'espace sur la pile. </p><br><h3 id="status_code">  code_état </h3><br><p>  La bibliothèque <code>&lt;system_error2&gt;</code> , développée par Niall Douglas, contiendra <code>status_code&lt;T&gt;</code> - "new, better" <code>error_code</code> .  Les principales différences avec <code>error_code</code> : </p><br><ol><li>  <code>status_code</code> - un type de modèle qui peut être utilisé pour stocker presque tous les codes d'erreur imaginables (avec un pointeur sur <code>status_code_category</code> ), sans utiliser d'exceptions statiques </li><li>  <code>T</code> devrait être relocalisable et copiable (ce dernier, à mon humble avis, ne devrait pas être obligatoire).  Lors de la copie et de la suppression, les fonctions virtuelles sont appelées depuis <code>status_code_category</code> </li><li>  <code>status_code</code> peut stocker non seulement des données d'erreur, mais aussi des informations supplémentaires sur une opération réussie </li><li>  La fonction "virtuelle" <code>code.message()</code> ne retourne pas <code>std::string</code> , mais <code>string_ref</code> est un type de chaîne assez lourd, qui est un virtuel "possiblement propriétaire" <code>std::string_view</code> .  Là, vous pouvez <code>string_view</code> ou <code>string</code> , ou <code>std::shared_ptr&lt;string&gt;</code> , ou une autre façon folle de posséder une chaîne.  Niall prétend que <code>#include &lt;string&gt;</code> rendrait l'en-tête <code>&lt;system_error2&gt;</code> inacceptable "lourd" </li></ol><br><p>  Ensuite, <code>errored_status_code&lt;T&gt;</code> est entré - un wrapper sur <code>status_code&lt;T&gt;</code> avec le constructeur suivant: </p><br><pre> <code class="cpp hljs">errored_status_code(status_code&lt;T&gt;&amp;&amp; code) [[expects: code.failure() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>]] : code_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(code)) {}</code> </pre> <br><h3 id="error">  erreur </h3><br><p>  Le type d'exception par défaut ( <code>throws</code> sans type), ainsi que le type de base des exceptions vers lesquelles tous les autres sont convertis (comme <code>std::exception</code> ), est <code>error</code> .  Il est défini quelque chose comme ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> error = errored_status_code&lt;<span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span>&gt;;</code> </pre> <br><p>  Autrement dit, l' <code>error</code> est un tel code d'état "erreur", dans lequel la valeur ( <code>value</code> ) est placée dans 1 pointeur.  Étant donné que le mécanisme <code>status_code_category</code> garantit une suppression, un déplacement et une copie corrects, théoriquement, toute structure de données peut être enregistrée par <code>error</code> .  En pratique, ce sera l'une des options suivantes: </p><br><ol><li>  Entiers (int) </li><li>  <code>std::exception_handle</code> , c'est-à-dire un pointeur vers une exception dynamique levée </li><li>  <code>status_code_ptr</code> , c'est-à-dire <code>unique_ptr</code> à un <code>status_code&lt;T&gt;</code> arbitraire <code>status_code&lt;T&gt;</code> . </li></ol><br><p>  Le problème est que le cas 3 n'est pas prévu pour donner la possibilité de ramener l' <code>error</code> au <code>status_code&lt;T&gt;</code> .  La seule chose que vous pouvez faire est d'obtenir le <code>message()</code> <code>status_code&lt;T&gt;</code> compressé.  Pour pouvoir récupérer la valeur renvoyée en <code>error</code> , lancez-la comme exception dynamique (!), Puis interceptez-la et enveloppez-la par <code>error</code> .  En général, Niall pense que seuls les codes d'erreur et les messages de chaîne doivent être stockés en <code>error</code> , ce qui est suffisant pour n'importe quel programme. </p><br><p>  Pour distinguer différents types d'erreurs, il est proposé d'utiliser l'opérateur de comparaison «virtuel»: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { open_file(name); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e == filesystem_error::already_exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> my_exception(<span class="hljs-string"><span class="hljs-string">"Unknown filesystem error, unable to continue"</span></span>); } }</code> </pre> <br><p>  L'utilisation de plusieurs blocs catch ou <code>dynamic_cast</code> pour sélectionner le type d'exception échouera! </p><br><h3 id="vzaimodeystvie-s-dinamicheskimi-isklyucheniyami">  Interaction avec les exceptions dynamiques </h3><br><p>  Une fonction peut avoir l'une des spécifications suivantes: </p><br><ul><li>  <code>noexcept</code> : ne lance aucune exception </li><li>  <code>throws(E)</code> : lève uniquement les exceptions statiques </li><li>  (rien): ne lance que des exceptions dynamiques </li></ul><br><p>  <code>throws</code> n'implique <code>noexcept</code> .  Si une exception dynamique est levée à partir d'une fonction "statique", elle est encapsulée par <code>error</code> .  Si une exception statique est levée à partir d'une fonction "dynamique", elle est <code>status_error</code> dans une exception <code>status_error</code> .  Un exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> erithmetic_errc::divide_by_zero; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> throws </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  arithmetic_errc   intptr_t //     error foo(); } void baz() { // error    status_error bar(); } void qux() throws { // error    status_error baz(); }</span></span></code> </pre> <br><h3 id="isklyucheniya-v-c">  Exceptions en C?! </h3><br><p>  La proposition prévoit l'ajout d'exceptions à l'une des futures normes C, et ces exceptions seront compatibles ABI avec les exceptions statiques C ++.  Une structure similaire à <code>std::expected&lt;T, U&gt;</code> , l'utilisateur devra déclarer indépendamment, bien que la redondance puisse être supprimée à l'aide de macros.  La syntaxe se compose (pour simplifier, nous le supposerons) des mots-clés échoue, échoue, capture. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> / x; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> failure(<span class="hljs-number"><span class="hljs-number">2.0f</span></span>); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expected_int_float</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> error; }; <span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span> failed; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ expected_int_float result = <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(invert(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.failed) { print_error(result.error); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } print_success(result.value); }</code> </pre> <br><p>  Dans le même temps, en C ++, il sera également possible d'appeler des fonctions <code>fails</code> partir de C, en les déclarant dans des blocs <code>extern C</code> .  Ainsi, en C ++, il y aura toute une galaxie de mots-clés pour travailler avec des exceptions: </p><br><ul><li>  <code>throw()</code> - supprimé en C ++ 20 </li><li>  <code>noexcept</code> - spécificateur de fonction, la fonction ne <code>noexcept</code> pas d'exceptions dynamiques </li><li>  <code>noexcept(expression)</code> - spécificateur de fonction, la fonction ne <code>noexcept(expression)</code> pas d'exceptions dynamiques fournies </li><li>  <code>noexcept(expression)</code> - Une expression <code>noexcept(expression)</code> -t-elle des exceptions dynamiques? </li><li>  <code>throws(E)</code> - spécificateur de fonction, la fonction lève des exceptions statiques </li><li>  <code>throws</code> = <code>throws(std::error)</code> </li><li>  <code>fails(E)</code> - une fonction importée de C lève des exceptions statiques </li></ul><br><p>  Ainsi, en C ++, ils ont apporté (ou plutôt livré) un panier de nouveaux outils pour la gestion des erreurs.  Ensuite, une question logique se pose: </p><br><h2 id="kogda-chto-ispolzovat">  Quand utiliser quoi? </h2><br><h3 id="napravlenie-v-celom">  Direction générale </h3><br><p>  Les erreurs sont divisées en plusieurs niveaux: </p><br><ul><li>  Erreurs du programmeur.  Traité à l'aide de contrats.  Ils conduisent à la collecte des journaux et à la fin du programme conformément au concept de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fail-fast</a> .  Exemples: pointeur nul (lorsque ce n'est pas valide);  division par zéro;  erreurs d'allocation de mémoire non prévues par le programmeur. </li><li>  Erreurs fatales fournies par le programmeur.  Jeté un million de fois moins souvent qu'un retour normal d'une fonction, ce qui justifie l'utilisation d'exceptions dynamiques.  Dans de tels cas, vous devez généralement redémarrer l'ensemble du sous-système du programme ou donner une erreur lors de l'exécution de l'opération.  Exemples: connexion soudainement perdue avec la base de données;  erreurs d'allocation de mémoire fournies par le programmeur. </li><li>  Erreurs récupérables lorsque <em>quelque chose a</em> empêché la fonction de terminer sa tâche, mais la fonction appelante peut savoir quoi en faire.  Géré par des exceptions statiques.  Exemples: travailler avec le système de fichiers;  autres erreurs d'entrée / sortie (IO);  Données utilisateur incorrectes  <code>vector::at()</code> . </li><li>  La fonction a terminé sa tâche avec succès, mais avec un résultat inattendu.  <code>std::optional</code> , <code>std::expected</code> , <code>std::variant</code> .  Exemples: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>stoi()</code></a> ;  <code>vector::find()</code> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>map::insert</code></a> . </li></ul><br><p>  Dans la bibliothèque standard, il est plus fiable d'abandonner complètement l'utilisation des exceptions dynamiques afin de rendre la compilation "sans exceptions" légale. </p><br><h3 id="errno">  errno </h3><br><p>  Les fonctions qui utilisent <code>errno</code> pour travailler rapidement et facilement avec les codes d'erreur C et C ++ doivent être remplacées respectivement par <code>throws(std::errc)</code> <code>fails(int)</code> et <code>throws(std::errc)</code> .  Pendant un certain temps, l'ancienne et la nouvelle version des fonctions de la bibliothèque standard coexisteront, puis l'ancienne sera déclarée obsolète. </p><br><h3 id="out-of-memory">  Mémoire insuffisante </h3><br><p>  Les erreurs d'allocation de mémoire sont gérées par le <code>new_handler</code> global <code>new_handler</code> , qui peut: </p><br><ol><li>  Éliminez le manque de mémoire et poursuivez l'exécution </li><li>  Jetez une exception </li><li>  Programme de crash </li></ol><br><p>  Maintenant, <code>std::bad_alloc</code> lancé par défaut.  Il est suggéré d'appeler <code>std::terminate()</code> par défaut.  Si vous avez besoin de l'ancien comportement, remplacez le gestionnaire par celui dont vous avez besoin au début de <code>main()</code> . </p><br><p>  Toutes les fonctions existantes de la bibliothèque standard deviendront <code>noexcept</code> et <code>noexcept</code> le programme lorsque <code>std::bad_alloc</code> .  Dans le même temps, de nouvelles API comme <code>vector::try_push_back</code> seront ajoutées, ce qui permettra des erreurs d'allocation de mémoire. </p><br><h3 id="logic_error"> <code>logic_error</code> </h3> <br><p>  Les exceptions <code>std::logic_error</code> , <code>std::domain_error</code> , <code>std::invalid_argument</code> , <code>std::length_error</code> , <code>std::out_of_range</code> , <code>std::future_error</code> signalent une violation d'une condition de fonction.  Le nouveau modèle d'erreur devrait utiliser des contrats à la place.  Les types d'exceptions répertoriés <strong>ne</strong> seront <strong>pas</strong> dépréciés, mais presque tous les cas d'utilisation dans la bibliothèque standard seront remplacés par <code>[[expects: …]]</code> . </p><br><h2 id="tekuschee-sostoyanie-proposal">  Statut actuel de la proposition </h2><br><p>  La proposition est maintenant dans un état provisoire.  Il a déjà beaucoup changé et peut encore changer beaucoup.  Certains développements n'ont pas réussi à être publiés, donc l'API proposée <code>&lt;system_error2&gt;</code> pas entièrement pertinente. </p><br><p>  La proposition est décrite dans 3 documents: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P709</a> - document original des armoiries de Sutter </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1095</a> - Exceptions déterminées dans Niall Douglas Vision, certaines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">choses ont changé</a> , compatibilité avec le langage C ajoutée </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1028</a> - API de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">implémentation de test de</a> <code>std::error</code> </li></ol><br><p>  Il n'existe actuellement aucun compilateur qui prend en charge les exceptions statiques.  En conséquence, il n'est pas encore possible de faire leurs repères. </p><br><p>           C++23.   , , ,   C++26,    ,  ,  . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>            ,     ,     .    ,            .   . </p><br><p>  ,   ^^ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430690/">https://habr.com/ru/post/fr430690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430680/index.html">Écrire un processeur et un environnement simples pour cela</a></li>
<li><a href="../fr430682/index.html">Trois ans du projet de microsatellites lunaires: étapes de la croissance</a></li>
<li><a href="../fr430684/index.html">Analyse des contrats Ethereum en direct pour une erreur d'envoi non contrôlé. 2e partie</a></li>
<li><a href="../fr430686/index.html">Présentation: la première machine de découpe au jet d'eau de WAZER</a></li>
<li><a href="../fr430688/index.html">Transfert de données via QR animé vers Gomobile et GopherJS</a></li>
<li><a href="../fr430692/index.html">Ingénierie sociale avec le logiciel Universal Windows Platform (APPX)</a></li>
<li><a href="../fr430694/index.html">Un petit guide pour apprendre le C ++: quoi, quand et sur quoi créer</a></li>
<li><a href="../fr430700/index.html">Un système unifié d'enregistrement des vues de films en ligne commencera à fonctionner en Russie</a></li>
<li><a href="../fr430702/index.html">Formation très étrange</a></li>
<li><a href="../fr430704/index.html">Comment les technologies de l'intelligence artificielle aident les ventes d'avias à se développer: sept exemples</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>