<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏽 🔨 😠 Le livre "Objets élégants. Édition Java » 👩🏻‍💼 ☺️ 🏂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, habrozhiteli! Ce livre révise sérieusement l'essence et les principes de la programmation orientée objet (POO) et peut être métaphoriquement ap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le livre "Objets élégants. Édition Java »</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/418157/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/w_/ty/kk/w_tykkzjrz7fxozztm-4tp4asci.jpeg" align="left" alt="image"></a>  Salut, habrozhiteli!  Ce livre révise sérieusement l'essence et les principes de la programmation orientée objet (POO) et peut être métaphoriquement appelé «POO Lobachevsky».  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Egor Bugaenko</a> , développeur avec 20 ans d'expérience, analyse de manière critique les dogmes de la POO et propose de regarder ce paradigme d'une manière complètement nouvelle.  Ainsi, il stigmatise les méthodes statiques, les getters, les setters, les méthodes mutables, croyant que c'est mal.  Pour un programmeur débutant, ce volume peut devenir un éclaircissement ou un choc, et pour un programmeur expérimenté, c'est une lecture obligatoire. <br><br><h3>  Extrait «N'utilisez pas de méthodes statiques» </h3><br>  Ah, les méthodes statiques ... Un de mes sujets préférés.  Il m'a fallu plusieurs années pour réaliser l'importance de ce problème.  Maintenant, je regrette tout le temps que j'ai passé à écrire des logiciels procéduraux plutôt que des objets.  J'étais aveugle, mais maintenant j'ai vu.  Les méthodes statiques sont tout aussi importantes sinon même un problème plus important dans la POO que d'avoir une constante NULL.  Les méthodes statiques, en principe, n'auraient pas dû être en Java et dans d'autres langages orientés objet, mais, hélas, elles existent.  Nous ne devrions pas connaître des choses telles que le mot-clé statique en Java, mais, hélas, sont forcés .. Je ne sais pas qui les a amenés à Java, mais ils sont du mal absolu .. Les méthodes statiques, pas les auteurs de cette fonctionnalité.  Je l'espère. <br><a name="habracut"></a><br>  Voyons quelles sont les méthodes statiques et pourquoi nous les créons toujours.  Disons que j'ai besoin de la fonctionnalité de chargement d'une page Web via des requêtes HTTP.  Je crée une telle «classe»: <br><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WebPage</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String uri</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  HTTP- //     UTF8- } }</span></span></code> </pre> <br>  Il est très pratique de l'utiliser: <br><br><pre> <code class="hljs pgsql">String html = WebPage.<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>("http://www.java.com");</code> </pre> <br>  La méthode read () appartient à la classe de méthodes à laquelle je m'oppose.  Je suggère d'utiliser un objet à la place (j'ai également changé le nom de la méthode conformément aux recommandations de la section 2.4): <br><br><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebPage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String uri; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">content</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  HTTP- //     UTF8- } }</span></span></code> </pre> <br>  Voici comment l'utiliser: <br><br><pre> <code class="hljs vbscript"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span> html = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebPage(<span class="hljs-string"><span class="hljs-string">"http://www.java.com"</span></span>) .content();</code> </pre> <br>  Vous pouvez dire qu'il n'y a pas beaucoup de différence entre eux.  Les méthodes statiques fonctionnent encore plus rapidement, car nous n'avons pas besoin de créer un nouvel objet chaque fois que nous devons télécharger une page Web.  Appelez simplement la méthode statique, elle fera le travail, vous obtiendrez le résultat et vous continuerez à travailler. Il n'est pas nécessaire de jouer avec les objets et le garbage collector.  De plus, nous pouvons regrouper plusieurs méthodes statiques dans une classe utilitaire et la nommer, par exemple, WebUtils. <br><br>  Ces méthodes vous aideront à charger des pages Web, à obtenir des informations statistiques, à déterminer le temps de réponse, etc. Elles comporteront de nombreuses méthodes et leur utilisation est simple et intuitive.  De plus, la façon d'appliquer des méthodes statiques est également intuitive.  Tout le monde comprend comment ils fonctionnent.  Écrivez simplement WebPage.read (), et - vous l'avez deviné!  - la page sera lue.  Nous avons donné des instructions à l'ordinateur, et il l'exécute. Simple et clair, non?  Et non! <br><br>  Les méthodes statiques dans n'importe quel contexte sont un indicateur indubitable d'un mauvais programmeur qui n'a aucune idée de la POO.  Il n'y a aucune justification pour appliquer des méthodes statiques dans n'importe quelle situation.  Prendre soin de la performance ne compte pas.  Les méthodes statiques sont une moquerie d'un paradigme orienté objet.  Ils existent en Java, Ruby, C ++, PHP et d'autres langages.  Malheureusement  Nous ne pouvons pas les jeter, nous ne pouvons pas réécrire toutes les bibliothèques open source pleines de méthodes statiques, mais nous pouvons arrêter de les utiliser dans notre code. <br><br>  Nous devons cesser d'utiliser des méthodes statiques. <br><br>  Maintenant, regardons-les de plusieurs positions différentes et discutons de leurs lacunes pratiques.  Je peux vous les généraliser à l'avance: les méthodes statiques dégradent la maintenabilité du logiciel.  Cela ne devrait pas vous surprendre.  Tout se résume à la maintenabilité. <br><br><h3>  Objective versus Computer Thinking </h3><br>  Initialement, j'ai appelé cette sous-section Objective versus Procedural Thinking, mais plus tard je l'ai renommée.  «Pensée procédurale» signifie presque la même chose, mais l'expression «penser comme un ordinateur» décrit mieux le problème. Nous avons hérité de cette façon de penser des premiers langages de programmation tels que Assembly, C, COBOL, Basic, Pascal et bien d'autres.  La base du paradigme est que l'ordinateur fonctionne pour nous, et nous lui disons quoi faire, en lui donnant des instructions explicites, par exemple: <br><br><pre> <code class="hljs cmake"> CMP AX, BX JNAE <span class="hljs-keyword"><span class="hljs-keyword">greater</span></span> MOV CX, BX RET <span class="hljs-keyword"><span class="hljs-keyword">greater</span></span>: MOV CX, AX RET</code> </pre> <br>  Il s'agit d'une «routine» d'assembleur pour le processeur Intel 8086. Elle trouve et renvoie le plus grand des deux nombres.  Nous les mettons respectivement dans les registres AX et BX, et le résultat tombe dans le registre CX.  Voici exactement le même code C: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; }</code> </pre> <br>  "Qu'est-ce qui ne va pas avec ça?"  - demandez-vous.  Rien .. Tout va bien avec ce code - il fonctionne comme il se doit. C'est ainsi que tous les ordinateurs fonctionnent.  Ils s'attendent à ce que nous leur donnions des instructions à suivre les uns après les autres. Pendant de nombreuses années, nous avons écrit des programmes de cette façon.  L'avantage de cette approche est que nous restons proches du processeur, dirigeant son mouvement ultérieur.  Nous sommes aux commandes et l'ordinateur suit nos instructions.  Nous indiquons à l'ordinateur comment trouver le plus grand des deux nombres.  Nous prenons des décisions, il les suit.  Le flux d'exécution est toujours cohérent, du début du script à sa fin. <br><br>  Ce type de pensée linéaire est appelé «penser comme un ordinateur».  L'ordinateur à un moment donné commence à exécuter des instructions et à un moment donné le termine.  Lors de l'écriture de code en C, nous sommes obligés de penser de cette façon.  Les opérateurs séparés par des points-virgules vont de haut en bas.  Ce style est hérité de l'assembleur. <br>  Bien que les langages d'un niveau plus élevé que l'assembleur aient des procédures, des sous-programmes et d'autres mécanismes d'abstraction, ils n'éliminent pas une façon de penser cohérente. Le programme continue de fonctionner de haut en bas.  Il n'y a rien de mal à une telle approche lors de l'écriture de petits programmes, mais à plus grande échelle, il est difficile de penser comme ça. <br><br>  Jetez un œil au même code écrit dans le langage de programmation fonctionnel Lisp: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defun</span></span> max (<span class="hljs-name"><span class="hljs-name">ab</span></span>) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> ab) ab))</code> </pre> <br>  Pouvez-vous dire où commence et se termine l'exécution de ce code?  Non.  Nous ne savons pas comment le processeur obtiendra le résultat, ni comment la fonction if fonctionnera.  Nous sommes très éloignés du processeur.  Nous pensons comme une fonction, pas comme un ordinateur.  Lorsque nous avons besoin d'une nouvelle chose, nous la définissons: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> x (<span class="hljs-name"><span class="hljs-name">max</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>))</code> </pre> <br>  Nous définissons, ne donnons pas d'instructions au processeur.  Avec cette ligne, nous lions x à (max 5 9).  Nous ne demandons pas à l'ordinateur de calculer le plus grand des deux nombres.  Nous disons simplement que x est le plus grand des deux nombres.  Nous ne contrôlons pas comment et quand il sera calculé.  Notez que cela est important: x est le plus grand des nombres.  La relation «est» («être», «être») est la différence entre un paradigme de programmation fonctionnel, logique et orienté objet d'un paradigme procédural. <br><br>  Avec un état d'esprit informatique, nous sommes à la barre et contrôlons le flux d'instructions.  Avec une façon de penser orientée objet, nous déterminons simplement qui est qui et nous les laissons interagir quand ils en ont besoin.  Voici à quoi devrait ressembler le calcul du plus grand des deux nombres dans la POO: <br><br><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Max</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Number a; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Number b; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Number left, Number right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = right; } }</code> </pre> <br>  Et donc je vais l'utiliser: <br><br><pre> <code class="hljs pgsql">Number x = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Max(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>);</code> </pre> <br>  Écoutez, je ne calcule pas le plus grand des deux nombres.  Je détermine que x est le plus grand des deux nombres.  Peu m'importe ce qui se trouve à l'intérieur de l'objet de la classe Max et comment exactement il implémente l'interface numérique.  Je ne donne pas d'instructions au processeur concernant ce calcul.  J'instancie juste l'objet.  C'est très similaire à def en Lisp .. En ce sens, la POO est très similaire à la programmation fonctionnelle. <br><br>  En revanche, les méthodes statiques en POO sont les mêmes que les sous-routines en C ou assembleur.  Ils ne sont pas liés à la POO et nous obligent à écrire du code procédural dans une syntaxe orientée objet.  Voici le code Java: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> x = Math.max(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>);</code> </pre> <br>  C'est complètement faux et ne doit pas être utilisé dans une conception orientée objet réelle. <br><br><h3>  Style déclaratif versus impératif </h3><br>  La programmation impérative «décrit les calculs en termes d'opérateurs qui changent l'état d'un programme». La programmation déclarative, quant à elle, «exprime la logique du calcul sans décrire le flux de son exécution» (je cite Wikipedia).  En fait, nous en avons parlé au cours de plusieurs pages précédentes.  La programmation impérative est similaire à ce que font les ordinateurs - exécution séquentielle d'instructions.  La programmation déclarative est plus proche de la façon naturelle de penser dans laquelle nous avons des entités et des relations entre elles.  De toute évidence, la programmation déclarative est une approche plus puissante, mais une approche impérative est plus compréhensible pour les programmeurs procéduraux.  Pourquoi l'approche déclarative est-elle plus puissante?  Ne changez pas, et après quelques pages, nous arrivons au point. <br><br>  Qu'est-ce que tout cela a à voir avec les méthodes statiques?  Peu importe qu'il s'agisse d'une méthode ou d'un objet statique, nous devons encore écrire if (a&gt; b) quelque part, non?  Oui, exactement.  La méthode statique et l'objet ne sont qu'un wrapper sur l'instruction if, qui effectue la tâche de comparaison de a avec b.  La différence réside dans la façon dont cette fonctionnalité est utilisée par d'autres classes, objets et méthodes.  Et c'est une différence significative.  Considérez-le avec un exemple. <br>  Disons que j'ai un intervalle limité à deux entiers, et un entier qui devrait tomber dedans. Je dois m'assurer qu'il l'est.  Voici ce que je dois faire si la méthode max () est statique: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span>(<span class="hljs-type"><span class="hljs-type">int</span></span> l, <span class="hljs-type"><span class="hljs-type">int</span></span> r, <span class="hljs-type"><span class="hljs-type">int</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.min(Math.max(l, x), r); }</code> </pre> <br>  Nous devons créer une autre méthode statique, entre (), qui utilise les deux méthodes statiques disponibles, Math.min () et Math.max ().  Il n'y a qu'une seule façon de le faire - une approche impérative, car la valeur est calculée immédiatement.  Lorsque je fais un appel, j'obtiens immédiatement le résultat: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = Math.between(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  9</span></span></code> </pre> <br>  J'obtiens le numéro 9 juste après avoir appelé entre ().  Une fois l'appel effectué, mon processeur commencera immédiatement à travailler sur ce calcul.  Il s'agit d'une approche impérative.  Et à quoi ressemble l'approche déclarative? <br><br>  Ici, jetez un oeil: <br><br><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Between</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Number num; Between(Number left, Number right, Number x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.num = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Min(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Max(left, x), right); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.num.intValue(); } }</code> </pre> <br>  Voici comment je vais l'utiliser: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Number</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Between(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   !</span></span></code> </pre> <br>  Sentez-vous la différence?  Elle est extrêmement importante.  Ce style sera déclaratif, car je ne dis pas au processeur que les calculs doivent être effectués immédiatement.  Je viens de déterminer ce que c'était et de laisser à l'utilisateur le soin de décider quand (et s'il était nécessaire) de calculer la variable y à l'aide de la méthode intValue ().  Peut-être qu'il ne sera jamais calculé et mon processeur ne saura jamais quel est le nombre 9. Tout ce que j'ai fait, c'est déclarer ce que c'est.  Je viens d'annoncer.  Je n'ai pas encore donné de travail au processeur.  Comme indiqué dans la définition, exprimé la logique sans décrire le processus. <br><br>  J'entends déjà: «D'accord, je vous comprends.  Il existe deux approches - déclarative et procédurale, mais pourquoi la première est-elle meilleure que la seconde? »  J'ai mentionné plus tôt qu'il est évident que l'approche déclarative est plus puissante, mais n'a pas expliqué pourquoi.  Maintenant que nous avons examiné les deux approches avec des exemples, nous allons discuter des avantages d'une approche déclarative. <br><br>  Premièrement, c'est plus rapide.  À première vue, cela peut sembler plus lent.  Mais si vous regardez de plus près, il deviendra clair qu'en fait, c'est plus rapide, car l'optimisation des performances est entièrement entre nos mains.  En effet, il faudra plus de temps pour créer une instance de la classe Between que d'appeler la méthode static between (), au moins dans la plupart des langages de programmation disponibles au moment de la rédaction de ce livre. J'espère vraiment que nous aurons un langage dans un futur proche dans lequel l'instanciation d'un objet sera aussi rapide que l'appel d'une méthode.  Mais nous ne sommes pas encore venus à lui.  C'est pourquoi l'approche déclarative est plus lente ... lorsque le chemin d'exécution est simple et direct. <br><br>  Si nous parlons d'un simple appel à une méthode statique, alors ce sera certainement plus rapide que de créer une instance d'un objet et d'appeler ses méthodes.  Mais si nous avons de nombreuses méthodes statiques, elles seront appelées séquentiellement lors de la résolution du problème, et pas seulement pour travailler sur les résultats dont nous avons vraiment besoin.  Que diriez-vous de ceci: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> doIt() { <span class="hljs-type"><span class="hljs-type">int</span></span> x = Math.<span class="hljs-keyword"><span class="hljs-keyword">between</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*  ? */</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>.println("x=" + x); } }</code> </pre> <br>  Dans cet exemple, nous calculons x, que nous ayons besoin de sa valeur ou non. Le processeur trouvera la valeur 9 dans les deux cas. La méthode suivante utilisant l'approche déclarative fonctionnera-t-elle aussi vite que la précédente? <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> doIt() { <span class="hljs-type"><span class="hljs-type">Integer</span></span> x = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Between</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*  ? */</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>.println("x=" + x); } }</code> </pre> <br>  Je pense que le code déclaratif sera plus rapide.  C'est mieux optimisé.  Et il ne dit pas au processeur quoi faire. Au contraire, il permet au processeur de décider quand et où le résultat est vraiment nécessaire - les calculs sont effectués à la demande. <br><br>  L'essentiel est que l'approche déclarative est plus rapide car elle est optimale.  C'est le premier argument en faveur d'une approche déclarative par rapport à l'impératif de la programmation orientée objet.  Le style impératif n'a définitivement pas sa place dans la POO, et la première raison en est l'optimisation des performances. Il ne faut pas dire que plus vous contrôlez l'optimisation du code, plus il est suivi.  Au lieu de laisser l'optimisation du processus de calcul au compilateur, à la machine virtuelle ou au processeur, nous le faisons nous-mêmes. <br><br>  Le deuxième argument est le polymorphisme.  En termes simples, le polymorphisme est la capacité de briser les dépendances entre les blocs de code.  Supposons que je veuille changer l'algorithme pour déterminer si un nombre tombe dans un certain intervalle.  C'est assez primitif en soi, mais je veux le changer.  Je ne veux pas utiliser les classes Max et Min.  Et je veux qu'il effectue une comparaison en utilisant les instructions if-then-else .. Voici comment procéder de manière déclarative: <br><br><pre> <code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Between</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Number num; Between(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> right, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Min(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Max(left, x), right)); } Between(Number number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.num = number; } }</code> </pre> <br>  Il s'agit de la même classe Between que dans l'exemple précédent, mais avec un constructeur supplémentaire.  Maintenant, je peux l'utiliser avec un autre algorithme: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">Integer</span></span> x = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Between</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> IntegerWithMyOwnAlgorithm(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>) );</code> </pre> <br>  Ce n'est probablement pas le meilleur exemple, car la classe Between est très primitive, mais j'espère que vous comprenez ce que je veux dire.  La classe Between est très facile à séparer des classes Max et Min, car ce sont des classes.  Dans la programmation orientée objet, un objet est un citoyen à part entière, mais pas la méthode statique.  Nous pouvons passer l'objet comme argument au constructeur, mais nous ne pouvons pas faire de même avec la méthode statique.  Dans la POO, les objets sont associés à des objets, communiquent avec des objets et échangent des données avec eux.  Pour détacher complètement un objet des autres objets, nous devons nous assurer qu'il n'utilise le nouvel opérateur dans aucune de ses méthodes (voir section 3.6), ainsi que dans le constructeur principal. <br><br>  Permettez-moi de répéter: pour détacher complètement un objet des autres objets, il vous suffit de vous assurer que le nouvel opérateur n'est utilisé dans aucune de ses méthodes, y compris le constructeur principal. <br><br>  Pouvez-vous faire le même découplage et refactoring avec un extrait de code impératif? <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> y = Math.<span class="hljs-keyword"><span class="hljs-keyword">between</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>);</code> </pre> <br>  Non, tu ne peux pas.  La méthode statique entre () utilise deux méthodes statiques, min () et max (), et vous ne pouvez rien faire avant de l'avoir complètement réécrite.  Et comment pouvez-vous le réécrire?  Passer le quatrième paramètre à la nouvelle méthode statique? <br><br>  À quel point sera-t-il laid?  Je pense vraiment. <br><br>  Voici mon deuxième argument en faveur d'un style de programmation déclaratif - il réduit la cohésion des objets et le rend très élégant. Sans oublier le fait que moins de cohésion signifie plus de maintenabilité. <br><br>  Le troisième argument en faveur de la supériorité de l'approche déclarative sur l'impératif - l'approche déclarative parle des résultats, alors que l'impératif explique la seule façon de les obtenir.  La seconde approche est beaucoup moins intuitive que la première.  Je dois d'abord «exécuter» le code dans ma tête pour comprendre quel résultat attendre.  Voici une approche impérative: <br><br><pre> <code class="hljs pgsql">Collection&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; evens = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> LinkedList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> number : numbers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { evens.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(number); } }</code> </pre> <br>  Pour comprendre ce que fait ce code, je dois le parcourir, visualiser ce cycle. En fait, je dois faire ce que fait le processeur - parcourir tout le tableau des nombres et mettre les nombres pairs dans la nouvelle liste.  Voici le même algorithme, écrit dans un style déclaratif: <br><br><pre> <code class="hljs pgsql">Collection&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; evens = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Filtered( numbers, <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Predicate&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt;() { @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> suitable(<span class="hljs-type"><span class="hljs-type">Integer</span></span> number) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>; } } );</code> </pre> <br>  Ce morceau de code est beaucoup plus proche de la langue anglaise que le précédent.  Il se lit comme suit: "evens est une collection filtrée qui inclut uniquement les éléments qui sont pairs."  Je ne sais pas exactement comment la classe Filtered crée une collection - utilise-t-elle une instruction for ou autre chose.  Tout ce que j'ai besoin de savoir en lisant ce code, c'est que la collection a été filtrée.  Les détails de l'implémentation sont masqués et le comportement est exprimé. <br><br>  Je me rends compte que pour certains lecteurs de ce livre, il était plus facile de percevoir le premier fragment. Il est un peu plus court et très similaire à ce que vous voyez quotidiennement dans le code que vous traitez.  Je vous assure que c'est une question d'habitude.  C'est un sentiment trompeur.  Commencez à penser en termes d'objets et de leur comportement, plutôt qu'en termes d'algorithmes et leur exécution, et vous obtiendrez une véritable perception.  Le style déclaratif se rapporte directement aux objets et à leur comportement, et l'impératif - aux algorithmes et à leur exécution. <br><br>  Si vous trouvez ce code moche, essayez Groovy, par exemple: <br><br><pre> <code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evens</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Filtered</span></span>( numbers, { <span class="hljs-type"><span class="hljs-type">Integer</span></span> number -&gt; number % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> } );</code> </pre> <br>  Le quatrième argument est l'intégrité du code.  Jetez un autre coup d'œil aux deux extraits précédents.  Veuillez noter que dans le deuxième fragment, nous déclarons evens comme un seul opérateur - evens = Filtered (...).  Cela signifie que toutes les lignes de code responsables du calcul de cette collection sont côte à côte et ne peuvent pas être séparées par erreur.  Au contraire, dans le premier fragment, il n'y a pas de «collage» évident des lignes.  Vous pouvez facilement modifier leur ordre par erreur et l'algorithme se cassera. <br><br>  Dans un morceau de code aussi simple, c'est un petit problème, car l'algorithme est évident.  Mais si le fragment du code impératif est plus grand - disons, 50 lignes, il peut être difficile de comprendre quelles lignes de code sont liées les unes aux autres .. Nous avons discuté un peu plus tôt du problème de la concaténation temporelle - lors de la discussion des objets immuables .. Le style de programmation déclarative aide également à éliminer cette concaténation , grâce à laquelle la maintenabilité est améliorée. <br><br>  Il y a probablement encore des arguments, mais j'ai cité le plus important, de mon point de vue, de ceux liés à la POO.  J'espère avoir pu vous convaincre que le style déclaratif est ce dont vous avez besoin.  Certains d'entre vous peuvent dire: «Oui, je comprends ce que vous voulez dire.  Je combinerai les approches déclaratives et impératives, le cas échéant.  J'utiliserai des objets là où cela a du sens et des méthodes statiques quand je devrai faire rapidement quelque chose de simple, comme calculer le plus grand des deux nombres. ".." Non, tu te trompes! "  - Je vais te répondre.  Vous ne devez pas les combiner. N'utilisez jamais un style impératif.  Ce n'est pas un dogme. Cela a une explication très pragmatique. <br><br>  Le style impératif ne peut pas être combiné avec un caractère déclaratif purement technique.      ,   —      . <br><br> ,       — max()  min().     ,     .      ,  ,    ..         —   Between,     between().     ? , ,   ,   ,  .       .    ,        Between.  ,      - ,        . <br><br>      - :      ,       —     .      . <br><br> «    ! —  . —   ?»    …   ,     .   - ,     - (     ). ,    ,   — .    ,     ..           ,         .    ,    , —  ,   ,     ,       .  ,   Apache Commons    FileUtils.readLines(),       .        : <br><br><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileLines</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> File file; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Iterator&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.asList( FileUtils.readLines(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.file) ).iterator(); } }</code> </pre> <br> ,       ,      : <br><br><pre> <code class="hljs lisp">Iterable&lt;String&gt; lines = new FileLines(<span class="hljs-name"><span class="hljs-name">f</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>        FileLines,        .     .    ,          ,     —  FileLines.    ,       . <br><br><h3> - </h3><br>   -      ,     ,      (    -)..  ,  java.lang.Math —   -.      Java, Ruby ,  ,      .     ?       .   1.1           ,   —   . -   , : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Math { private Math() { //   } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">int</span></span> max(<span class="hljs-type"><span class="hljs-type">int</span></span> a, <span class="hljs-type"><span class="hljs-type">int</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } }</code> </pre> <br>    ,   -,    ,   ,     .   , ,   ,     . <br><br> - —      - . - —        —    .   ,    ,      . - —    ..    . <br><br><h3>  «» </h3><br>  «» —  ,   ,     . ,       ,          .     : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Math</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Math INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Math(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Math</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Math </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.INSTANCE; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } }</code> </pre> <br>     .     Math,   INSTANCE..      ,   getInstance().   ,       .      INSTANCE —  getInstance(). <br><br> «»    ,      .    ,     .      ,   .  , , ,      ,     -,      .     - Math,    ,     : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Math</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Math</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } }</code> </pre> <br>      max(): <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">Math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); <span class="hljs-comment"><span class="hljs-comment">// - Math.getInstance().max(5, 9); // </span></span></code> </pre> <br>   ? ,     ,     .    ,         -?         Java-. ,      : «   ».  Par exemple: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> User INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User.INSTANCE; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String txt</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = txt; } }</code> </pre> <br>    ,           .     «,     ».       -,    , -  . .. ,           -: «  »..    .      ..  -,    ,     : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User.name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String txt</span></span></span><span class="hljs-function">)</span></span> { User.name = txt; } }</code> </pre> <br>  -  ,         . ,    ?     ?      ,   —  ,   ,  - —    ,   .  ,    ,       setInstance()   getInstance().   ,     . ,     : <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Math</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.getInstance</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.max</span></span>(5, 9);</code> </pre> <br>      Math.  ,  Math — ,    .       ,         Math ,     .         ,    .    ,  , ,       -,     .  ,   ,   Math.max()     -.    ?   : <br><br><pre> <code class="hljs cmake"><span class="hljs-keyword"><span class="hljs-keyword">Math</span></span> <span class="hljs-keyword"><span class="hljs-keyword">math</span></span> = new FakeMath(); <span class="hljs-keyword"><span class="hljs-keyword">Math</span></span>.setInstance(<span class="hljs-keyword"><span class="hljs-keyword">math</span></span>);</code> </pre> <br>  «»      ,    .   :    -  ,     .  -   —     . - —     —    . <br><br> ,   ?   -,     ,   .  Pourquoi? ,      —  ,  ,  ..       .      .    ,        : <br><br><pre> <code class="hljs mel">#include &lt;stdio&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> line = <span class="hljs-number"><span class="hljs-number">0</span></span>; void echo(char* <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>) { printf(<span class="hljs-string"><span class="hljs-string">"[%d] %s\n"</span></span>, ++line, <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>); }</code> </pre> <br>      echo(),    line.    line          *.-..   .   Java  ,         .  Java,    Ruby     --,   .  Pourquoi?         .    .      .   . ,         .   ,      ,    GOTO. <br><br> ,       , -      Java,     «»..      - ,      .      . <br>    .   . <br><br> «  ? —  . —   ,           ,    ?» ,   ,      ,        .    -  .    ? ! <br><br>      ,     . <br><br> ,      ,         ..   .  .     ,    .   ,     :    ,    ,     . . , ,      ,       .      ,   —  ,      2.1. <br><br>     .     . <br><br><h3>   </h3><br>     :            ,        ()? ,    ,     ,      .. ,    ?      Lisp, Clojure  Haskell  Java  C++? <br><br>  ,       : <br><br><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Max</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = right; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b ? <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b; } }</code> </pre> <br>      : <br><br><pre> <code class="hljs pgsql">Number x = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Max(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>);</code> </pre> <br>        Lisp ,      : <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> max (<span class="hljs-name"><span class="hljs-name">ab</span></span>) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> ab) ab))</code> </pre> <br> ,    ?   Lisp  . <br><br>       ,     ,    —  .   -   ,      -  -,   .   ,  -  Java,     ,  Java  ,     -.  —  ,   .    . <br><br>  ,   -        .  -,    Java,   (   ) ,    .    . <br><br><h3>   </h3><br> ,    .   —  -   .    —   - , —   ,       ,  : <br><br><pre> <code class="hljs lisp">names = new Sorted( <span class="hljs-name"><span class="hljs-name">new</span></span> Unique( <span class="hljs-name"><span class="hljs-name">new</span></span> Capitalized( <span class="hljs-name"><span class="hljs-name">new</span></span> Replaced( <span class="hljs-name"><span class="hljs-name">new</span></span> FileNames( <span class="hljs-name"><span class="hljs-name">new</span></span> Directory( <span class="hljs-string"><span class="hljs-string">"/var/users/*.xml"</span></span> ) ), <span class="hljs-string"><span class="hljs-string">"([^.]+)\\.xml"</span></span>, <span class="hljs-string"><span class="hljs-string">"$1"</span></span> ) ) ) )<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  ,    ,     -.   ,     3.2.    ,     names,        ,     ,    .   ,    ,      ,   .    . <br><br>          ? ,  ,    ,       . <br><br>  ,     .  Directory, FileNames, Replaced, Capitalized, Unique  Sorted — ,        .      .       . <br><br>      ,      (   ).  , Unique —  Iterable,     .  FileNames —    ,    . <br>      -       .       ,     ..  -    app.run(),      .          if, for, switch  while.   ,    . <br><br>  if   Java      ,   .       Java ,      If?     : <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">float</span></span> rate; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (client.age() &gt; <span class="hljs-number"><span class="hljs-number">65</span></span>){ <span class="hljs-attribute"><span class="hljs-attribute">rate</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>; } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">rate</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>     - : <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> rate = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">If</span></span>( client.age() &gt; <span class="hljs-number"><span class="hljs-number">65</span></span>, <span class="hljs-number"><span class="hljs-number">2.5</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span> );</code> </pre> <br>    ? <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> rate = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">If</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Greater(client.age(), <span class="hljs-number"><span class="hljs-number">65</span></span>), <span class="hljs-number"><span class="hljs-number">2.5</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span> );</code> </pre> <br>  ,  : <br><br><pre> <code class="hljs lisp">float rate = new If( <span class="hljs-name"><span class="hljs-name">new</span></span> GreaterThan( <span class="hljs-name"><span class="hljs-name">new</span></span> AgeOf(<span class="hljs-name"><span class="hljs-name">client</span></span>), <span class="hljs-number"><span class="hljs-number">65</span></span> ), <span class="hljs-number"><span class="hljs-number">2.5</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span> )<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>    -   .     —  ,   rate. <br><br>    ,      ,      .   if, for, switch  while.    If, For, Switch  While.  ? <br><br>       ,      .    .            .   ,    .. ,            . <br>   ,  -  —       . <br><br>       ?  ,   :        .     ,        .             .     .      ,    —  . <br><br>  :           static —      ,     ,  . <br><br>  »Plus d'informations sur le livre sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de l'éditeur</a> <br><br>    20%   — <b>Java</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418157/">https://habr.com/ru/post/fr418157/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418145/index.html">Le premier procès contre Roskomnadzor d'une entreprise qui a souffert lorsque Telegram a été bloqué</a></li>
<li><a href="../fr418147/index.html">Silence of Ruby Executions: Transactional Rails / PostgreSQL Thriller</a></li>
<li><a href="../fr418149/index.html">Phishing avec balise de titre</a></li>
<li><a href="../fr418153/index.html">Vidéo Meetup Kolesa Android: à propos de MVVM, des antipatterns et du développement modulaire</a></li>
<li><a href="../fr418155/index.html">Diode LED Diode Zener</a></li>
<li><a href="../fr418159/index.html">Où aller chez le designer: prestigieux prix de la Russie, de l'Europe de l'Est et des pays de la CEI</a></li>
<li><a href="../fr418161/index.html">À Stanford, des batteries de streaming à température ambiante ont été développées</a></li>
<li><a href="../fr418163/index.html">Tests de production: Netflix Chaos Automation Platform</a></li>
<li><a href="../fr418165/index.html">Quasar, Sobaken et Vermin: révéler les détails de la campagne de cyberespionnage en cours</a></li>
<li><a href="../fr418167/index.html">ScadaPy: ajouter le protocole IEC 60870-5-104</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>