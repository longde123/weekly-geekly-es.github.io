<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👉🏿 🌪️ 🦃 RobotDyn Strikes Double: Mega + ESP8266 🙎🏼 🛢️ 🕊️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa yang dilakukan pengembang di waktu senggang yang jarang? Itu benar, menelusuri daftar harga toko besi. Ada satu menit gratis dan saya memutuskan u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RobotDyn Strikes Double: Mega + ESP8266</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/402429/"><img src="https://habrastorage.org/files/07a/66b/52f/07a66b52ff5d4326bcef6a7fd2749aef.jpg" alt="RobotDyn Mega + ESP8266"><br>  Apa yang dilakukan pengembang di waktu senggang yang jarang?  Itu benar, menelusuri daftar harga toko besi.  Ada satu menit gratis dan saya memutuskan untuk melihat-lihat halaman toko online populer - kebosanan, tidak ada yang menarik, kami sudah melihat semua ini ... dan kemudian tiba-tiba mata saya tertuju pada Mega berikutnya.  Bah!  Ya, ini bukan hanya Mega, tetapi dikombinasikan dengan ESP8266 yang dicintai semua orang dan dengan hati-hati dilengkapi dengan sakelar untuk dua pengontrol untuk bekerja bersama - berkabel (menggunakan Ethernet Shield) dengan banyak GPIO dan Wi-Fi untuk komunikasi nirkabel. <br><br>  Tidak buruk!  Saya berpikir dan mengingat tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AMS</a> - di sana Anda dapat menginstal dua server - berkabel dan nirkabel dan menghubungkannya ke dalam satu sistem - ESP8266 akan menerima 54 pin digital dan 16 analog, dan Mega akan menerima kontrol nirkabel melalui Wi-Fi dan semua roti ESP8266.  Dahulu kala saya tidak menemukan papan yang begitu menarik. <br><br>  - Halo!  Apakah Anda memiliki papan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mega + ESP8266</a> ? <br>  - Ya, tetapi kita hanya memiliki satu yang tersisa. <br>  "Kenapa hanya satu?" <br>  - Sisanya dibongkar. <br>  "Tolong selamatkan dia, untukku." <br><a name="habracut"></a><br><h2>  Beberapa kata tentang perusahaan </h2><br>  Saya menyukai RobotDyn dua hal: yang pertama - dengan solusi teknologinya.  Tidak perlu melangkah jauh, contoh yang bagus adalah papan Mega + ESP8266 yang sedang dipertimbangkan.  Sesuatu seperti ini belum saya lihat di toko online kami (dan bukan milik kami, tetapi saya tidak benar-benar mencarinya di sini).  Dan ini bukan satu-satunya contoh, masih ada opsi Uno + ESP8266 dan perusahaan jelas tidak akan berhenti di situ, ternyata masih banyak perangkat menarik yang menunggu kami. <br><br>  Dan yang kedua adalah kebijakan penetapan harganya.  Saya tidak akan membahas masalah ini di sini secara rinci, tetapi saya akan mengatakan bahwa harga mengejutkan saya - moto perusahaan adalah "Harga seperti pada Aliexpress". <br><br>  Singkatnya, saya menggambarkan latar belakang di mana semua acara selanjutnya akan dibuka, sekarang kita langsung menuju ke rincian teknis dan deskripsi papan dan bagaimana bekerja dengannya. <br><br><h2>  Papan itu sendiri </h2><br>  Secara umum, papan biasa, tidak jauh berbeda dari banyak yang serupa, jika tidak untuk satu bagian kecil, yaitu, chip ESP8266EX terintegrasi ke dalam papan.  Ini segera mentransfer papan ke kategori solusi luar biasa.  Saya ingin menarik perhatian Anda ke satu detail lagi - bukan modul standar tipe ESP-12 yang terintegrasi ke dalam board, tetapi chip dan semua kabel dibuat di papan itu sendiri, yang secara transparan mengisyaratkan tingkat pengembang.  Saya juga ingin mencatat bahwa papan memiliki antena cetak dan konektor untuk menghubungkan antena eksternal, yang dalam banyak kasus dapat sangat berguna. <br><img src="https://habrastorage.org/files/1d1/cee/155/1d1cee155967488581228289df3b6f28.jpg" alt="RobotDyn Mega + ESP8266"><br>  Ada konektor pin di papan untuk menghubungkan ke terminal ESP8266 dan beberapa sakelar, yang layak disebut sedikit lebih banyak.  Gagasan utama menggunakan papan adalah dengan menggunakan sakelar, Anda dapat mengonfigurasi interaksi tiga komponennya dengan cara yang berbeda: chip Atmega2560, chip ESP8266EX, dan konverter CH340G USB-TTL.  Koneksi tunggal dan kompleks dimungkinkan, yang memungkinkan Anda mengatur banyak opsi untuk interaksi semua bagian papan.  Ini membuka peluang besar untuk membangun berbagai perangkat, tetapi lebih lanjut tentang ini nanti. <br><br><img src="https://habrastorage.org/files/cb4/2f4/819/cb42f4819ba940369ad71818bbc7ff03.jpg" alt="Pin ESP8266"><br><br>  Saya juga ingin mencatat kapasitas muat papan yang layak.  Dilihat oleh prasasti di atasnya, ia mampu memberikan arus beban 1,6 A pada saluran 5-volt dan 1 A pada 3,3 volt.  Yang sangat bagus, terutama secara agregat. <br><br>  Tidak ada lagi yang bisa dikatakan tentang papan, kita beralih ke menginstal perangkat lunak dan mengujinya. <br><br><h2>  Pengujian dewan </h2><br>  Karena papan terintegrasi dan praktis tidak ada ruang kosong di atasnya, dan kabel bagian frekuensi tinggi ESP8266EX dilakukan di atasnya, pada awalnya timbul keraguan tentang operasi yang benar dan bebas masalah dari seluruh ekonomi ini. <br><br>  Ke depan, saya akan mengatakan bahwa terlepas dari kekhawatiran saya, semuanya berjalan stabil dan seperti yang diharapkan.  Kami menghubungkan switch pada papan Atmega2560 ke USB - kami mendapatkan Arduino Mega, kami menghubungkan ESP8266EX ke USB - kami mendapatkan ESP8266, kami beralih ke mode koneksi Atmega2560 dengan ESP8266EX kami mendapatkan koneksi antara chip melalui antarmuka serial.  Semuanya bekerja persis seperti yang dijelaskan dalam dokumentasi dan persis seperti yang diharapkan secara intuitif. <br><br>  Nilai tambah yang besar dari solusi ini adalah bahwa para pengembang menjaga kesesuaian tingkat sinyal logis dari semua komponen sistem.  Siapa pun yang secara manual mencoba mengkonfigurasi modul ESP8266 dan menghubungkan dengan benar semua resistor pull-up akan mengerti saya.  Tidak ada masalah seperti itu, semua pekerjaan Anda dikurangi hingga mengklik sakelar di papan sesuai dengan instruksi dari pabrikan. <br><br><h2>  Uji beban </h2><br>  Bagaimana cara menguji papan?  Anda dapat mengunduh beberapa sketsa standar, tetapi ini akan menjadi tes tentang tidak ada apa-apa.  Opsi ini dapat bekerja dengan baik, dan dalam kondisi pertempuran sistem akan gagal.  Oleh karena itu, pekerjaan kedua bagian di bawah kendali versi yang sesuai dari Server Arduino Mega dipilih sebagai uji beban berat.  Untuk Mega - Arduino Mega Server untuk Mega dan untuk ESP8266 - Arduino Mega Server untuk ESP8266 dalam versi M1. <br><br>  Kit distribusi M1 dipilih karena fakta bahwa hanya 1 MB memori flash untuk ESP8266 dipasang di papan tulis.  Ini, menurut saya, hampir merupakan satu-satunya kesalahan bagi pengembang - di masa depan papan revisi, saya akan merekomendasikan bahwa mereka menempatkan 4 MB chip memori.  Perbedaan harga kecil, dan kemungkinan saat menggunakan versi dengan 4 MB jauh lebih besar.  Tetapi karena ada versi AMS untuk sistem dengan 1 MB, saya tidak terlalu memperhatikan poin ini dan melanjutkan pengujian. <br><br>  Apa yang harus saya katakan?  Kami menghidupkan papan, mengisi perangkat lunak dan mendapatkan dua server independen.  Satu kabel melalui Ethernet Shield dan satu nirkabel melalui Wi-Fi.  Cantik! <br><br>  Saya juga ingin mencatat bahwa bahkan penambahan Ethernet Shield dengan pembaca kartu ke sistem yang sudah canggih ini tidak menyebabkan konflik atau kegagalan - semuanya hanya berjalan seperti seharusnya.  Dan dalam beberapa kasus bahkan lebih baik dari biasanya - ini adalah papan pertama di mana firmware ESP8266 melalui udara berhasil lulus dalam 100% kasus, di semua papan dan modul lain ada kerusakan dari waktu ke waktu dengan flashing. <br><br>  Dan dua server berputar, memuat papan, memenuhi tugas mereka dan ... itu saja.  Semuanya hanya berfungsi, tidak ada yang bisa dikatakan, tapi ini mungkin pujian terbaik untuk sistem teknis apa pun. <br><br><h2>  Paling menarik </h2><br>  Apa yang saya jelaskan di sini menarik dari sudut pandang akademis murni: papan yang menarik, solusi teknis yang menarik, tetapi tentu saja kami tertarik dengan aplikasi praktisnya.  Apa sorotan praktis dan terapannya? <br><br>  Faktanya adalah bahwa dengan satu sakelar di papan dimungkinkan untuk menghubungkan dua bagiannya (Mega dan ESP) ke dalam satu unit dan dengan demikian, pertama, dapatkan sistem kualitas baru dan, kedua, mengimbangi kelemahan yang melekat pada masing-masing bagian masing-masing. <br><br>  Mari kita mulai dengan ESP8266.  Kelemahan utama dari solusi yang umumnya sangat baik ini adalah ketiadaan pin GPIO.  Seperti yang mereka katakan, satu, dua dan salah perhitungan.  Sulit untuk mengatakan apa yang dipikirkan oleh pengembang chip ini, tetapi sebelum rilis ESP32 mereka memiliki sedikit waktu untuk berpikir dan mereka memperbaiki kekurangan ini dalam chip baru.  Tetapi kami secara khusus berurusan dengan 8266. <br><br>  Papan ini memungkinkan Anda untuk membuat gerakan kuda dan menggunakan kekuatan penuh Mega, dan ini, antara lain, 54 output digital dan 16 analog dalam ESP8266.  Artinya, ESP reyot kami tiba-tiba mendapat peluang besar untuk bekerja dengan sensor, aktuator, dan periferal lainnya.  Ternyata, bisa dikatakan, bayi ESP menggunakan steroid. <br><br>  Ini hanya salah satu opsi yang mungkin untuk menggunakan papan, berbaring di permukaan. <br><br>  Sekarang mari kita lihat Mega.  Dia tidak mengganggu antarmuka nirkabel dan kemampuan untuk berinteraksi dengan perangkat Wi-Fi, yang dapat memberinya integrasi dengan bagian ESP dari sistem.  Dan pada saat yang sama, masih ada kemungkinan operasi paralel melalui antarmuka Ethernet kabel. <br><br>  Dan ini juga hanya salah satu aplikasi yang mungkin untuk papan ini, berbaring di permukaan. <br><br>  Nah, berbagai opsi jembatan: Ethernet - Wi-Fi, nRF24 - Ethernet, nRF24 - Wi-Fi, nRF24 (1) - nRF24 (2), nooLite - Wi-Fi, nooLite - Ethernet, nooLite (1) - nooLite (2) ), dll., hingga tak terbatas.  Anda dapat merutekan sinyal dari puluhan subsistem yang digunakan oleh Arduino Mega Server antara dua bagian papan dan antarmuka yang terhubung dengannya. <br><br>  Saya bahkan tidak tahu harus berkata apa.  Sangat keren <br><br><h2>  Rincian teknis </h2><br>  Sekarang sedikit tentang detail teknis.  Anda melihat tabel di mana semua mode operasi papan yang mungkin disajikan dan semua posisi yang mungkin dari switch di atasnya ditampilkan.  Mari kita pertimbangkan secara singkat setiap mode. <br><br><img src="https://habrastorage.org/files/a51/cc7/874/a51cc7874a274215b06fc93c7d7dbd4d.png" alt="Tabel mode pengoperasian papan RobotDyn"><br><br><h4>  Arduino Mega 2560 </h4><br>  Mode operasi papan yang paling sederhana, dalam tabel ini ditetapkan sebagai mode 3. Jika Anda mengatur sakelar 3 dan 4 ke posisi ON, dan sisanya ke posisi OFF, kita mendapatkan Arduino Mega 2560 yang biasa. Tidak ada yang menarik, karena itu tidak layak membeli papan ini, Anda dapat adalah untuk membeli Mega yang biasa. <br><br><h4>  ESP8266 </h4><br>  Juga bukan mode operasi yang sangat menarik.  Dalam tabel, ini dibagi menjadi dua sub-mode, yang ditunjuk sebagai 1 (memuat sketsa ke ESP) dan 2 (ESP ke mode koneksi USB).  Ini semua fungsi dari ESP8266 standar dan demi penggunaan seperti itu juga tidak layak membeli papan ini, Anda bisa bertahan dengan modul ESP biasa. <br><br><h4>  Semuanya independen </h4><br>  Kami juga tidak mempertimbangkan opsi ini di nomor 6, karena di dalamnya semua koneksi antara bagian-bagian papan rusak dan pasti tidak berguna bagi kami untuk apa pun. <br><br><h4>  Koneksi antara Mega dan ESP </h4><br>  Dalam mode ini, ditetapkan sebagai 5, komunikasi dibuat antara Mega dan ESP melalui antarmuka serial, tetapi tidak ada komunikasi dengan konverter USB-TTL.  ESP menggunakan Serial standar, sedangkan Mega menggunakan Serial3 standar yang tidak kalah.  Sambungan bekerja dengan stabil dan mulus pada kecepatan 115200. Ini adalah mode operasi yang agak spesifik ketika tidak ada pengontrol yang memiliki koneksi USB.  Jadi dia juga tidak terlalu menarik bagi kita. <br><br><h4>  Komunikasi antara Mega dan ESP dan Mega dan USB pada saat yang sama </h4><br>  Tapi ini yang disebut kartu truf.  Kami mendapatkan semuanya sekaligus - koneksi USB Mega dan kemampuan untuk mengunggah sketsa ke Mega dan mengontrol operasinya melalui USB yang sama, kemungkinan komunikasi antara Mega dan ESP dan kemampuan untuk mengunggah sketsa ke ESP8266 dan mengontrol operasinya di antarmuka USB ... Mega!  Artinya, isian penuh, tidak langsung meninggalkan kasir. <br><br>  Ini adalah satu-satunya mode operasi yang benar yang tercantum dalam tabel.  Ingat nomor kemenangannya, yaitu empat.  Dalam konfigurasi sakelar di papan, juga terlihat indah - 1, 2, 3, 4 dalam posisi ON, sisanya OFF. <br><br>  Pembaca yang penuh perhatian akan bertanya: bagaimana kita bisa mengunggah sketsa ke ESP8266 jika port USB sibuk menghubungkan ke bagian Mega sistem?  Dan ini adalah pertanyaan yang tepat, jawabannya tidak mungkin.  Lalu mengapa Anda menulis bahwa dalam konfigurasi ini kita dapat mengunggah sketsa ke ESP8266?  Karena Arduino Mega Server memiliki kemampuan untuk mengunduh sketsa di udara langsung dari Arduino IDE dengan menekan beberapa tombol, jadi itu benar - kami memiliki isian penuh, semuanya langsung bekerja. <br><br>  Tetapi bagaimana dengan mereka yang ingin menggunakan papan tanpa Server Arduino Mega?  Hanya ada dua opsi: klik sakelar secara konstan, atau tambahkan kemampuan untuk mengunduh sketsa melalui udara di desain Anda.  Saya pribadi lebih suka opsi kedua. <br><br><h2>  Pengaturan IDE Arduino </h2><br>  Pengaturan Arduino IDE untuk Mega tidak menimbulkan pertanyaan, semuanya standar di sana, dan untuk ESP8266 saya akan memberikan tangkapan layar menu dengan pengaturan untuk implementasi spesifik bagian ESP pada papan RobotDyn.  Anda harus menetapkan parameter yang sama untuk Anda sendiri, dengan pengecualian nomor port - pada sistem Anda kemungkinan besar akan memiliki nilai yang berbeda. <br><br><img src="https://habrastorage.org/files/e1f/d98/bac/e1fd98bacc664b7e931699cb65b1c6ae.png" alt="Pengaturan ESP8266 di Arduino IDE"><br><br><h2>  Arduino Mega Server untuk RobotDyn Mega + ESP8266 </h2><br>  Untuk board ini, versi dual khusus dari Arduino Mega Server telah dirilis, yang berisi dua server sekaligus, dioptimalkan khusus untuk board ini.  Ini adalah bagian luar dari pertanyaan, kedua server ini berisi fungsionalitas standar dan dapat digunakan untuk proyek Anda. <br><br>  Anda dapat menggunakan kedua server ini secara independen pada papan yang sama, atau Anda dapat menambahkan fungsionalitas yang Anda butuhkan dan menggunakannya dalam mode tandem dan dalam jembatan antara dua jaringan dan semua antarmuka yang terhubung ke server. <br><br>  Perakitan Arduino Mega Server pertama untuk papan RobotDyn Mega + ESP8266 berisi contoh uji interaksi dua pengontrol melalui antarmuka Serial.  Ini adalah demonstrasi kemampuan teknologi yang dapat digunakan untuk mengembangkan solusi Anda sendiri. <br><br>  Sekarang sedikit lebih banyak tentang pengembangan protokol untuk interaksi dua pengendali melalui antarmuka Serial pada umumnya dan pada papan ini pada khususnya. <br><br><h2>  Pengembangan Protokol </h2><br>  Apa yang harus kita bangun rumah?  Perlu mengembangkan protokol interaksi antara dua bagian sistem melalui antarmuka serial?  - kami akan kembangkan, di sini yang utama adalah mengatur tugas dengan jelas dan benar.  Untuk menunjukkan operasi tandem sistem, kami menampilkan indikator operasi "mitra" di panel dasbor setiap server. <br><br>  <em><strong>Sedikit tentang terminologi.</strong></em>  <em>Untuk Mega, "mitra" adalah ESP8266, untuk ESP8266, masing-masing, Mega.</em> <br><br>  Ketika mitra bekerja, indikator akan menyala kehijauan, saat tidak bekerja, merah dan abu-abu saat negara tidak terdefinisi.  Ini sangat nyaman - selama operasi, Anda akan segera melihat keadaan alter ego sistem Anda. <br><br>  Untuk solusi praktis untuk masalah ini, ada sejuta cara, kami akan memilih yang berikut: blok komunikasi dari kedua bagian sistem akan identik, interaksi akan terjadi dalam mode dupleks penuh, blok informasi akan memiliki format yang sederhana dan jelas: <br><br><pre><code class="java hljs">?=</code> </pre> <br>  atau <br><br><pre> <code class="java hljs">?</code> </pre><br>  Ini hanyalah contoh uji untuk menyelesaikan tugas, Anda dapat memodifikasi protokol interaksi ini atau menulis sendiri, cocok untuk tugas Anda.  Tetapi pada protokol yang sudah diterapkan, Anda tidak hanya dapat memantau status mitra, tetapi juga menggunakannya untuk banyak tujuan lain, misalnya, mentransmisikan status pin pengontrol, status sensor atau mengirim perintah kontrol ke mitra. <br><br>  Secara khusus, dalam sistem kami, tim akan terlihat seperti ini: <br><br>  <strong>? mega = 1</strong> - Mega mengirim data tentang kinerjanya.  Parameter "mega", nilai "1". <br><br>  <strong>? esp = 1</strong> - ESP8266 mengirim data tentang kesehatannya.  Parameternya adalah "esp", nilainya "1". <br><br>  Jadi, misalnya, pertimbangkan implementasi protokol untuk bagian-mega sistem. <br><br>  Dengan cara standar, kita menginisialisasi modul AMS dan perangkat keras Serial3 Mega pada kecepatan 115200. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">robotdynInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Serial3.begin(<span class="hljs-number"><span class="hljs-number">115200</span></span>); modulRobotdyn = MODUL_ENABLE; started(<span class="hljs-string"><span class="hljs-string">"RobotDyn"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); }</code> </pre><br>  Kami memeriksa status port Serial3 dan dalam hal data dari mitra, kami membentuk variabel string serialReq yang berisi data atau perintah yang diterima. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSerial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Serial3.available() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sFlag) { serialReq = <span class="hljs-string"><span class="hljs-string">""</span></span>; sFlag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = Serial3.read(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-number"><span class="hljs-number">10</span></span>) { sFlag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; parseSerialStr(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-number"><span class="hljs-number">13</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// skip } else { if (serialReq.length() &lt; MAX_SERIAL_REQ) { serialReq += c; } } // if } // while (Serial3.available() &gt; 0) } // checkSerial()</span></span></code> </pre><br>  Kami menguraikan perintah dan data dan jika ada informasi tentang keadaan mitra kami mengambil tindakan dalam bentuk mengubah keadaan variabel esp. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseSerialCmd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String command, parameter; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serialReq.indexOf(F(<span class="hljs-string"><span class="hljs-string">"?"</span></span>)) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pBegin = serialReq.indexOf(F(<span class="hljs-string"><span class="hljs-string">"?"</span></span>)) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serialReq.indexOf(F(<span class="hljs-string"><span class="hljs-string">"="</span></span>)) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pParam = serialReq.indexOf(F(<span class="hljs-string"><span class="hljs-string">"="</span></span>)); command = serialReq.substring(pBegin, pParam); parameter = serialReq.substring(pParam + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { command = serialReq.substring(pBegin); parameter = <span class="hljs-string"><span class="hljs-string">""</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (command != F(<span class="hljs-string"><span class="hljs-string">"esp"</span></span>)) { Serial.print(F(<span class="hljs-string"><span class="hljs-string">"command/parameter: "</span></span>)); Serial.print(command); Serial.print(F(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)); Serial.println(parameter); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (command == F(<span class="hljs-string"><span class="hljs-string">"esp"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter == F(<span class="hljs-string"><span class="hljs-string">"1"</span></span>)) { esp = <span class="hljs-number"><span class="hljs-number">1</span></span>; espTimer = millis(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { esp = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">// if (request.indexOf(F("?")) &gt;= 0) } // parseSerialCmd()</span></span></code> </pre><br>  Anda dapat dengan mudah menambahkan pemrosesan perintah lain dengan mengubah dan menambahkan ke bagian kode yang sesuai. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (command == F(<span class="hljs-string"><span class="hljs-string">"esp"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter == F(<span class="hljs-string"><span class="hljs-string">"1"</span></span>)) { esp = <span class="hljs-number"><span class="hljs-number">1</span></span>; espTimer = millis(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { esp = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Jika Anda menggunakan banyak perintah dan data dalam proyek dan penguraian Anda sendiri, bagian kode ini lebih baik untuk merancang dalam bentuk fungsi yang sesuai. <br><br>  Tetap hanya mempertimbangkan fungsi standar modul AMS, yang bertanggung jawab atas pekerjaannya.  Pertama, status port diperiksa, lalu setiap empat detik perintah dikirim ke mitra bahwa Mega masih hidup dan bekerja, dan waktu berlalu sejak data terakhir diterima dari mitra diperiksa, dan jika melebihi 8 detik, disimpulkan bahwa mitra tidak bekerja. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">robotdynWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ checkSerial(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cycle4s) { Serial3.println(F(<span class="hljs-string"><span class="hljs-string">"?mega=1"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (millis() - espTimer &gt; <span class="hljs-number"><span class="hljs-number">8000</span></span>) { esp = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } }</code> </pre><br>  Itu semua ajaib.  Benar, tidak ada yang rumit? <br><br><div class="spoiler">  <b class="spoiler_title">Kode lengkap modul yang bertanggung jawab untuk komunikasi antar sistem antara Mega 2560 dan ESP8266</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* Modul RobotDyn part of Arduino Mega Server project */</span></span> #ifdef ROBOTDYN_FEATURE bool sFlag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; unsigned <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> espTimer = millis(); <span class="hljs-comment"><span class="hljs-comment">// Serial request #define MAX_SERIAL_REQ 32 String serialReq = ""; void robotdynInit() { Serial3.begin(115200); modulRobotdyn = MODUL_ENABLE; started("RobotDyn", true); } void printSerialStr() { Serial.print("["); Serial.print(serialReq); Serial.println("]"); } void parseSerialCmd() { String command, parameter; if (serialReq.indexOf(F("?")) &gt;= 0) { int pBegin = serialReq.indexOf(F("?")) + 1; if (serialReq.indexOf(F("=")) &gt;= 0) { int pParam = serialReq.indexOf(F("=")); command = serialReq.substring(pBegin, pParam); parameter = serialReq.substring(pParam + 1); } else { command = serialReq.substring(pBegin); parameter = ""; } // if (command != F("esp")) { Serial.print(F("command/parameter: ")); Serial.print(command); Serial.print(F("/")); Serial.println(parameter); //} if (command == F("esp")) { if (parameter == F("1")) { esp = 1; espTimer = millis(); } else { esp = 0; } } } // if (request.indexOf(F("?")) &gt;= 0) } // parseSerialCmd() void parseSerialStr() { if (serialReq[0] == '?') { parseSerialCmd(); } else { printSerialStr(); } } void checkSerial() { while (Serial3.available() &gt; 0) { if (sFlag) { serialReq = ""; sFlag = false; } char c = Serial3.read(); if (c == 10) { sFlag = true; parseSerialStr(); } else if (c == 13) { // skip } else { if (serialReq.length() &lt; MAX_SERIAL_REQ) { serialReq += c; } } // if } // while (Serial3.available() &gt; 0) } // checkSerial() void robotdynWork() { checkSerial(); if (cycle4s) { Serial3.println(F("?mega=1")); if (millis() - espTimer &gt; 8000) { esp = 0; } } } #endif // ROBOTDYN_FEATURE</span></span></code> </pre><br></div></div><br><h2>  Seperti apa output di monitor serial </h2><br>  Di Mega 2560 Serial Monitor, output, data, dan perintah dari bagian ESP dari sistem terlihat persis seperti miliknya.  Untuk membedakan output mitra dari output Mega, datanya dilampirkan dalam tanda kutip persegi.  Dalam hal ini, Anda dapat melihat ESP8266 reboot dan log boot AMS di monitor Seri Mega. <br><br><img src="https://habrastorage.org/files/a03/904/3b8/a039043b86d442d7a54e10bb73b314c7.png" alt="ESP8266 output ke monitor seri Mega 2560"><br><br>  Dan log pertukaran sebenarnya dari perintah antara dua bagian sistem melalui antarmuka Serial.  Anda melihat output ESP8266 dengan informasi tentang decoding data status Mega di antarmuka Serial Mega, terlampir dalam tanda kutip persegi. <br><br><img src="https://habrastorage.org/files/b5f/444/6cf/b5f4446cf54c4c048fa568f1e3418823.png" alt="ESP8266 Output pada Decoding Perintah Mega"><br><h2>  Keindahan dalam antarmuka </h2><br>  Sekarang sedikit tentang bagaimana semuanya terlihat di antarmuka Arduino Mega Server.  Untuk memulai, saya akan memberikan tangkapan layar dari kedua bagian sistem di tempat kerja. <br><br><img src="https://habrastorage.org/files/774/faf/c92/774fafc92eb54ba29905a6ec201501da.png" alt="Arduino Mega Server untuk RobotDyn Mega + ESP8266"><br><br>  Elips dilingkari di sekitar prasasti yang mengidentifikasi pengontrol dan bagian dari sistem yang Anda gunakan saat ini.  Lingkaran dilingkari di sekitar indikator yang menunjukkan status mitra.  Saat ini, semuanya sudah beres, kedua bagian sistem bekerja secara normal dan berinteraksi secara normal satu sama lain melalui antarmuka internal.  Jika terjadi kesalahan, maka Anda akan mengetahuinya setelah maksimal 8 detik. <br><br><img src="https://habrastorage.org/files/f49/7ef/a1f/f497efa1ff1f427a860d4e61cdc5e13d.png" alt="Ada yang salah"><br><br>  Ada yang salah.  ESP8266 menerima pembaruan firmware melalui udara dan Mega-bagian dari sistem mencatat saat reboot-nya.  Setelah beberapa detik, bagian ESP dari sistem akan dilanjutkan dan indikator akan mati merah. <br><br>  Untuk kenyamanan, ketika Anda mengarahkan kursor ke indikator status mitra, petunjuk muncul dan kemampuan untuk mengkliknya dan di jendela terpisah antarmuka bagian kedua sistem, dalam hal ini bagian ESP, terbuka.  Ini dilakukan untuk kenyamanan, Anda dapat kapan saja dengan satu klik membuka antarmuka bagian kedua dari sistem. <br><br><img src="https://habrastorage.org/files/d00/a61/a28/d00a61a28c6b439086a42e4510e896cb.png" alt="Tip alat untuk AMS"><br><br><h2>  Gagasan Proyek </h2><br>  Sekarang sedikit tentang apa yang dapat Anda lakukan dari semua ini, memiliki sedikit imajinasi.  Papan biasa, benar-benar bijaksana pada pandangan pertama, memungkinkan Anda untuk melakukan banyak hal yang benar-benar tidak biasa dan menarik.  Ini terutama berlaku pada kombinasi dengan Server Arduino Mega. <br><br>  Jadi, hal pertama yang terlintas dalam pikiran: <br><br>  <strong>Meneruskan data dari sensor antar pengontrol.</strong>  Di kedua sisi dan dalam jumlah yang tidak terbatas.  Ini adalah salah satu sistem yang memiliki kelebihan dari kedua bagiannya, dan kemungkinan tidak hanya bertambah, tetapi apa yang disebut efek sinergis diamati. <br><br>  <strong>Jembatan antar antarmuka.</strong>  Arduino Mega Server dapat bekerja dengan banyak antarmuka dan sistem ini memungkinkan Anda untuk merutekan data dan perintah antara semua antarmuka kabel dan nirkabel yang terhubung. <br><br>  <strong>Bekerja di jaringan yang sama</strong> ketika Mega via Ethernet Shield dan ESP8266 via Wi-Fi berkomunikasi dengan perangkat berkabel dan nirkabel di jaringan yang sama. <br><br>  <strong>Bekerja di jaringan yang berbeda</strong> ketika Mega terhubung ke Ethernet berkabel, dan ESP8266 melalui Wi-Fi ke jaringan lain dan sistem merutekan perintah dan data dari satu jaringan ke yang lain. <br><br>  <strong>Output dari satu bagian sistem dalam antarmuka yang lain.</strong>  Via Ethernet menggunakan umpan web standar atau melalui koneksi Serial internal. <br><br>  <strong>Debugging</strong>  Salah satu bagian dari sistem dapat bertindak sebagai debugger dan penguji bagian lain dari sistem sesuai dengan program Anda. <br><br>  <strong>Pengawas waktu.</strong>  Setiap pengontrol dapat bertindak sebagai semacam pengawas dalam hubungannya dengan yang lain. <br><br>  <strong>Kegagalan pembalakan.</strong>  Setiap pengontrol dapat menyimpan catatan pekerjaan mitranya, menyusun statistik dan melaporkan situasi yang mengkhawatirkan. <br><br>  <strong>Database untuk ESP8266.</strong>  Menggunakan sistem ini, Anda dapat mengatur sesuatu seperti database SQL pada Mega untuk ESP8266.  ESP melakukan tugasnya, dan Mega bertindak sebagai sistem penyimpanan (hingga 32 GB). <br><br>  <strong>Saling berkedip.</strong>  Pengontrol dapat saling bercampur secara dinamis sesuai dengan logika yang disematkan atau pada saat kedatangan perintah kontrol eksternal. <br><br>  <strong>Menghubungkan modul.</strong>  Pengontrol dapat terhubung ke berbagai periferal yang mengalami masalah saat menyambung ke salah satu bagian sistem. <br><br>  Dan seterusnya dan seterusnya, saya pikir pembaca yang ingin tahu akan dapat secara mandiri menemukan banyak cara yang tidak kalah menarik untuk menggunakan sistem ini. <br><br><h2>  Kesimpulan </h2><br>  Menurut pendapat saya, ini adalah solusi yang sangat menarik, dan kami harus mengucapkan banyak terima kasih kepada RobotDyn untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">biaya yang begitu</a> menarik.  Saya, setidaknya, mengatakan ini dengan tulus. <br><br>  Unduh kit distribusi Arduino Mega Server untuk RobotDyn Mega + ESP8266 dan lihat sendiri apa yang tertulis di sini di situs resmi proyek Arduino Mega Server di bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">unduhan</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id402429/">https://habr.com/ru/post/id402429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id402417/index.html">Pengendara sepeda itu merayap tanpa disadari</a></li>
<li><a href="../id402419/index.html">Parsing the New Nintendo Switch</a></li>
<li><a href="../id402421/index.html">Venus Week di Belahan Bumi Utara</a></li>
<li><a href="../id402423/index.html">Latihan bahasa offline</a></li>
<li><a href="../id402425/index.html">Ahli kimia adalah yang pertama menghargai manfaat komputer kuantum</a></li>
<li><a href="../id402431/index.html">ONYX BOOX Vasco Da Gama: lebih pintar dari buku, lebih sederhana dari pada tablet</a></li>
<li><a href="../id402433/index.html">Sejarah Pencakar Langit</a></li>
<li><a href="../id402435/index.html">Intisari "World Hi-Fi": audio portabel, perangkat lunak, format, dan vinil</a></li>
<li><a href="../id402437/index.html">IPTV lebih tipis dari RMB</a></li>
<li><a href="../id402439/index.html">Geolokasi komersial: privasi murah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>