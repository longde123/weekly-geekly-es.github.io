<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🔬 🐤 💃 Da ich im Wettbewerb um JavaScript-Entwickler von Telegram nicht den ersten Platz belegt habe 🍿 🎧 ⏪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aktive Benutzer von Telegram, insbesondere diejenigen, die Pavel Durov abonniert haben, haben wahrscheinlich etwas darüber gehört, dass Telegram auf I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Da ich im Wettbewerb um JavaScript-Entwickler von Telegram nicht den ersten Platz belegt habe</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/460625/">  Aktive Benutzer von Telegram, insbesondere diejenigen, die Pavel Durov abonniert haben, haben wahrscheinlich etwas darüber gehört, dass Telegram auf Ihren Internetseiten einen Wettbewerb für iOS-, Android- und JavaScript-Entwickler sowie für Designer veranstaltet hat.  Trotz der Tatsache, dass es ein ziemlich episches Ereignis mit der Verteilung solider Preise war (einer der Teilnehmer erhielt 50.000 US-Dollar für den ersten Platz, nachdem er die schnellste und einfachste Android-Anwendung geschrieben hatte), schrieben sie zumindest auf Runet irgendwie wenig darüber.  Mein Debütbeitrag wird versuchen, die Situation zu beheben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b51/6e9/071/b516e9071bc91d08b80222b9e9bfbcbd.png"></div><a name="habracut"></a><br>  Da ich ein Full-Stack-JavaScript-Entwickler bin (um genau zu sein ein TypeScript-Entwickler), habe ich mich entschlossen, mich selbst zu testen.  Manila ist nicht nur ein Preisfonds, sondern auch das Format selbst: Dies ist kein Programmierwettbewerb, bei dem Abstraktheit und Denkgeschwindigkeit wichtig sind.  Hier war alles im Komplex wichtig: Erfahrung, mittelfristige Entwicklungsgeschwindigkeit, Geschmack in UI-Fragen, Kenntnisse der gesamten Informatik und Selbstkritik.  Gemäß den Wettbewerbsbedingungen musste eine Bibliothek für die Anzeige von Grafiken für eine der Plattformen entwickelt werden: iOS, Android oder Web. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z7/jx/um/z7jxumisjsnktyff0u06fsyutma.jpeg"></div><br>  Entwickler für verschiedene Plattformen konkurrierten nicht miteinander und jede Plattform hatte ihre eigenen Gewinner.  Die Hauptkriterien waren: Arbeitsgeschwindigkeit (auch auf älteren Geräten), Konsistenz mit dem Design, reibungslose Animation und minimale Anwendungsgröße.  Bereits vorhandene Lösungen und Bibliotheken konnten nicht verwendet werden, alles musste von Grund auf neu geschrieben werden. <br><br>  Zuvor nahm ich an Wettbewerben für Entwickler teil, bei denen nicht mehr als 5 Stunden für alle Aufgaben vorgesehen waren. Diese Stunden mussten in enormem Stress verbracht werden.  Trotz der Tatsache, dass das Telegramm keine solche Belastung erforderte, um die Aufgabe zu erfüllen, ist es einer der schwierigsten Wettbewerbe, an denen ich teilnehmen musste.  Die scheinbar unkomplizierte Aufgabe erwies sich als so umfangreich, dass ich, wenn ich dafür bezahlt würde, diese „Grafiken“ monatelang schneiden könnte, um einen Kompromiss zwischen der Codeleistung und ihrer architektonischen Harmonie zu finden.  Es hat geholfen, dass drei ( <b>upd:</b> zwei, danke an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">vlad2711</a> für die Änderung) Wochen für die Lösung zugewiesen wurden.  Einige der Rivalen haben sich speziell verabschiedet, um mehr Zeit für den Wettbewerb <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufzuwenden</a> , und ich habe beschlossen, die Entwicklung des Wettbewerbs abends und am Wochenende wie gewohnt mit der Arbeit in „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ontanta</a> “ zu verbinden. <br><br><h1>  LEINWAND gegen SVG </h1><br>  Das wichtigste architektonische Problem, mit dem wir alle konfrontiert waren, war die Wahl eines Grafik-Rendering-Tools.  Derzeit bieten uns Webstandards zwei Ansätze: durch die Erzeugung von On-the-Fly-SVG-Grafiken und die gute alte Leinwand.  Hier sind die Vor- und Nachteile von jedem. <br><br><h3>  Leinwand </h3><br>  <b>+</b> Absolute Vielseitigkeit - Mit der Möglichkeit, die Farbe jedes Pixels auf der Leinwand zu ändern, können Sie alles zeichnen, was Sie wollen. <br>  <b>+</b> [Potenzial] Hohe Leistung - Wenn Sie Leinwand vorbereiten können, kann dies eine gute Leistung zeigen.  Es wäre toll, Webgl zu verwenden, aber die Unterstützung auf Smartphones ist schlecht. <br><br>  <b>-</b> Alle Berechnungen und das gesamte Rendern von Hand - im Gegensatz zu SVG, wo die Zwischenpunkte der Polylinie einmal festgelegt werden können und Sie dann das Ansichtsfeld manipulieren können, um die „Kamera“ entlang der Abschnitte der Polylinie zu bewegen, mit Leinwand ist alles komplizierter: Es gibt hier keine „Kameras“ nur Koordinaten von der oberen linken Ecke;  Wenn Sie den aktuellen Anzeigebereich des Diagramms "verschieben" müssen, müssen Sie alle Koordinaten aller seiner Punkte relativ zur neuen Position des Anzeigebereichs neu berechnen.  Mit anderen Worten, das Ansichtsfeld, das in svg standardmäßig enthalten ist, muss manuell im Canvas implementiert werden. <br>  <b>-</b> Die gesamte Animation ist manuell - basierend auf dem vorherigen Absatz werden alle möglichen Animationen realisiert, indem die Koordinaten, Farb- und Transparenzwerte neu berechnet und die gesamte Szene N-mal pro Sekunde neu gezeichnet werden. Je öfter die Szene nachgezählt und neu gezeichnet werden konnte, desto glatter wurde die Animation. <br><br><h3>  Svg </h3><br>  <b>+</b> Einfaches Zeichnen - Fügen Sie SVG nur einmal die erforderlichen Linien, Formen und mehr hinzu, indem Sie die Parameter Ansichtsfenster, Farbe und Transparenz ändern und eine Diagrammnavigation bereitstellen. <br>  <b>+</b> Einfache Implementierung von Animationen - wieder reicht es aus, Ne basierend auf dem vorherigen Absatz, neue Werte für das Ansichtsfeld, die Farbe und die Transparenz mehrmals pro Sekunde anzugeben, und das Bild wird selbst neu gezeichnet, der Browser kümmert sich darum.  Vergessen Sie außerdem nicht, dass Formen und Grundelemente in SVG in CSS gestaltet werden können, sodass sie mithilfe von CSS3-Animationen animiert werden können. Dies eröffnet die größten Möglichkeiten, mit minimalem Aufwand coole Animationen zu erhalten. <br>  <b>+</b> Standardmäßig gute Leistung - Wenn Sie leicht etwas Langsames und Hunderte von Ressourcen auf die Leinwand bringen können, sieht das auf SVG basierende Ergebnis immer recht leicht, anständig und flüssig aus. <br><br>  Aber die Münze hat eine Kehrseite. <br><br>  <b>-</b> Bescheidene Optimierungsmöglichkeiten - da wir nicht svg, sondern den Browser zeichnen, ist es unmöglich, diesen Prozess zu steuern. Wenn Sie die Leistung steigern möchten, indem Sie beispielsweise bereits einzelne gezeichnete Elemente zwischenspeichern, können Sie dies in keiner Weise tun.  Höchstwahrscheinlich wird dies bereits vom Browser durchgeführt, aber wir können nicht sicher sein, bis zum Ende. <br>  <b>-</b> Begrenzte Werkzeuge - In SVG steuern wir nicht mehr jedes Pixel der Leinwand, sondern denken und codieren im Rahmen von Vektorprimitiven.  Für diese Aufgabe ist dies jedoch ein unbedeutendes Minus, das im Rahmen der Wettbewerbsaufgabe einige wiederum unbedeutende Einschränkungen auferlegt. <br><br>  Ich musste mich nie mit der Wahl eines Instruments quälen, da ich ein ekelhaftes Charaktermerkmal habe - ich bin Maximalist und habe in meiner Arbeit nur mein Lieblingsinstrument verwendet.  So kam es, dass mein Lieblingswerkzeug seit meiner Studienzeit, als ich mich mit DirectDraw amüsierte, immer eine Leinwand war, auf der "mach was du willst".  Und Leinwand zur Lösung eines Wettbewerbsproblems erwies sich als wirklich gut, aber es spielte mir nur ein Plus davon in die Hände: die breitesten Möglichkeiten für Optimierungen, da das Hauptkriterium immer noch die Anwendungsleistung war. <br><br><h1>  Guter Code ist nicht gut </h1><br>  Die Aufgabe ist klar: Sie müssen Punkte an der richtigen Stelle und zur richtigen Zeit auf die Leinwand zeichnen.  Es bleibt der Code zu schreiben.  Wieder war es notwendig zu wählen, diesmal zwischen dem Schreiben eines produktiven kompakten Codes mit einem „Fußtuch“ in einem prozeduralen Stil oder nicht sehr produktiv und noch weniger kompakt in meinem bevorzugten objektorientierten.  Sie haben wahrscheinlich bereits vermutet, dass ich die zweite Option gewählt habe und sie mit einem anderen meiner Favoriten gewürzt habe - TypeScript. <br><br>  Und diese Wahl war nicht sehr richtig.  Aufgrund der Verwendung von Abstraktionen und Kapselungen ist es nicht immer möglich, Zwischenberechnungsergebnisse zu speichern, zu übertragen und wiederzuverwenden, was sich negativ auf die Leistung auswirkt.  Und aufgrund der weit verbreiteten Verwendung, ohne die OOP in JS nicht möglich ist, wird der Code schlecht minimiert, während auch die Größe eine Rolle spielt. <br><br>  Es ist Zeit, einen Link zum Github zu geben: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/native-elements/telechart</a> .  Bei Interesse empfehle ich, auf die Historie der Commits zu achten, da sie an Optimierungsprüfungen und erfolglose Versuche erinnert, ein paar zusätzliche Rendering-Frames pro Sekunde herauszuquetschen. <br><br>  Nun, im Wettbewerb habe ich den Preis nicht angenommen.  Und das Problem, wie es bei uns Programmierern oft vorkommt, stellte sich nicht als unzureichende Erfahrung, schneller Verstand oder Geschwindigkeit heraus, sondern als unzureichende Selbstkritik: Die Tatsache, dass ich es geschafft habe, funktioniert und wie auf dem Bild aussieht, hat mich gefreut, aber Was die Rendering-Bremsen angeht, dachte ich, ich hätte alles getan, was ich konnte, der Rest tat wahrscheinlich das Gleiche.  Ich schäme mich, darüber zu sprechen, aber ich war mir sicher, dass ich den ersten oder zweiten Platz einnehmen würde.  Tatsächlich stellte sich heraus, dass ich ein Brems- und Buggy-Programm geschrieben habe, nicht das schlechteste, aber alles andere als das beste.  Als ich die Arbeit anderer Entwickler sah, wurde mir klar, dass ich keine Chance hatte und nur meine Ellbogen beißen konnte.  Wenn ich bei meiner Arbeit unparteiisch wäre, würde ich mich mit Produktivität befassen, dem wichtigsten Teil der Wettbewerbsaufgabe. <br><br>  Eine der wertvollsten Lektionen in meinem Berufsleben, die ich nicht müde werde, ist, dass ein guter Ingenieur im Gegensatz zu beispielsweise einem Künstler verpflichtet ist, die Qualität seiner Arbeit objektiv zu bewerten und das Selbstvertrauen zu verwerfen, da das Ergebnis seiner Arbeit nicht nur das Auge erfreuen sollte sollte aber richtig und gut funktionieren. <br><br>  Dies war die erste Phase des Wettbewerbs.  Die Gewinner wurden großzügig belohnt.  Zu meiner unbeschreiblichen Freude endete die Geschichte nicht dort, weil die zweite Stufe angekündigt wurde: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tq/ge/fb/tqgefbqq70vn363qi-f9ef1d9my.jpeg"></div><br>  Es war notwendig, Ihr Handwerk in nur einer Woche zu verfeinern und zusätzliche Diagrammtypen zu implementieren.  Ich werde sofort zeigen, was passiert ist, und unten werde ich Ihnen erzählen, wie es passiert ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ea/607/144/3ea6071449116820be794f886f9ebc21.png"></div><br>  In meinem Fall musste ich vor dem Hinzufügen neuer Funktionen die Leistung der alten verstehen.  Das erste Problem, das ich gelöst habe, ist <br><br>  <b>Zuckende Animation</b> <br><br>  Selbst wenn Sie genug Leistung haben, um 60 Bilder pro Sekunde zu erzeugen, ist die Animation nicht flüssig, wenn die Position des Elements oder seine Transparenz nicht durch die seit dem Start der Animation verstrichene Zeit bestimmt wird.  Dies ist auf ungleiche Zeitintervalle zwischen den Ticks zurückzuführen: Beispielsweise arbeitete ein Tick nach 10 ms und der zweite nach 40 ms, während das Objekt beim ersten und zweiten Tick um 1 Pixel nach links verschoben wurde - das heißt, seine Bewegungsgeschwindigkeit schwebt ständig. optisch sieht es aus wie ein "Zucken".  Mit anderen Worten, Sie müssen etwas falsch machen: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> left = <span class="hljs-number"><span class="hljs-number">10</span></span>, interval = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { left += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left &gt;= <span class="hljs-number"><span class="hljs-number">90</span></span>) { clearInterval(interval) } }, <span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br>  Und so: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> left = <span class="hljs-number"><span class="hljs-number">10</span></span>, startLeft = <span class="hljs-number"><span class="hljs-number">10</span></span>, targetLeft = <span class="hljs-number"><span class="hljs-number">90</span></span>, startTime = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(), duration = <span class="hljs-number"><span class="hljs-number">1000</span></span>, interval = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { left = startLeft + (targetLeft - startLeft) * (<span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() - startTime) / duration <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left &gt;= targetLeft) { left = targetLeft clearInterval(interval) } })</code> </pre><br>  Da der Code viele animierte Parameter enthält, habe ich eine <a href="">universelle Klasse</a> gefilmt, die die Aufgabe erleichtert und der Animation auch ising hinzufügt.  Es ist ganz einfach zu bedienen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> left = Telemation.create(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>) … drawVerticalLine(left.value) <span class="hljs-comment"><span class="hljs-comment">//      ,  .</span></span></code> </pre> <br>  Dann kommt die 60-fps-Regel ins Spiel.  PC-Spieler werden mich verstehen: Damit eine Animation perfekt aussieht, muss sie mit einer Geschwindigkeit von mindestens 60 fps gerendert werden.  Dementsprechend sollte jedes Rendern des Rahmens nicht länger als 1/60 Sekunde dauern.  Dies erfordert leistungsstarke Hardware und guten Code. <br><br>  Weitere Untersuchungen haben dies gezeigt <br><br>  <b>Das Malen der Leinwand wird langsamer, wenn sich HTML-Elemente über der Leinwand befinden</b> . <br><br>  Anfangs habe ich "leere" HTML-Elemente verwendet, um die Kontrolle über das aktuelle Ansichtsfenster zu implementieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac7/3f2/3b4/ac73f23b4010f587f19950259c95ac03.png"></div><br>  Diese Elemente wurden auf der Leinwand platziert, und obwohl sie keinen Inhalt hatten, wurden sie nur zum Verfolgen von Mausereignissen verwendet. Als Ergebnis von Experimenten stellte sich heraus, dass ihre Anwesenheit die Renderleistung verringert.  Indem ich sie entfernte und die Logik der Bestimmung von Ereignissen zur Steuerung des Anzeigebereichs etwas komplizierter machte, erhöhte ich die Geschwindigkeit beim Rendern des Rahmens. <br><br>  Es blieb, den letzten Nagel vom Deckel des Sarges der Leistung zu ziehen: Ich tat es <br><br>  <b>Minimap-Caching</b> <br><br>  Zuvor wurden für die Minikarte wieder Linien in jedem Frame gezeichnet.  Dies ist eine teure Operation, da der gesamte Zeitplan für das Jahr angezeigt wird (365 Punkte pro Zeile).  Die offensichtliche Lösung, für deren Implementierung ich von Anfang an einfach zu faul war, bestand darin, die Linien des Diagramms für die Minikarte einmal zu zeichnen, das Ergebnis im Cache zu speichern und diesen Cache in Zukunft zu verwenden.  Nach dieser Optimierung ist die Anwendungsleistung nicht mehr peinlich. <br><br><h1>  Was kommt als nächstes? </h1><br>  Es gab immer noch viele erfolgreiche und nicht sehr um die Leistung kämpfende Versuche: Versuche, die Ergebnisse von Koordinatenberechnungen zwischenzuspeichern, Experimente mit den lineJoin-Parametern von CanvasRenderingContext2D (schnellere Gehrung), aber sie sind nicht so interessant, weil sie keinen merklichen Leistungsgewinn oder gar keinen erzielten. <br><br>  Von den acht Tagen habe ich fünf für die Beschleunigung des Codes und nur drei für die Fertigstellung der neuen Funktionalität aufgewendet.  Ja, ich habe nur drei Tage gebraucht, um neue Diagrammtypen hinzuzufügen, und hier hat sich OOP als sehr praktisch herausgestellt, wodurch sich die Codebasis leicht erhöht hat.  Ich hatte nicht genug Zeit, um die Bonusaufgabe abzuschließen (+5 zusätzliche Charts).  Ich glaube, dass ich diese fünf Tage, die ich damit verbracht habe, die Konsequenzen meines Selbstbewusstseins zu beseitigen, damit verbringen könnte, das Bonusproblem zu lösen. <br><br>  Trotzdem ergab meine Arbeit das Ergebnis: 4. Platz und ein Trostpreis von tausend Dollar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f59/2c6/cdc/f592c6cdc54f45723ddc6747d3c5c3f0.png"></div><br>  Der Wettbewerb ging übrigens weiter, aber ohne mich. <br><br>  Ich freue mich über die Teilnahme: Ich war nicht nur interessant und ein interessantes Abenteuer, sondern habe auch eine gute Berufserfahrung und eine Lektion fürs Leben erhalten. <br><br>  Darüber hinaus habe ich diese Bibliothek bei der Entwicklung unseres Corporate Timetrackers verwendet, über den ich in naher Zukunft auch sprechen möchte. <br><br>  Zur Diskussion schlage ich folgende Frage vor: Warum braucht Telegramm das alles?  Ich glaube, dass Telegram für angemessenes Geld die beste Bibliothek der Welt für die Anzeige von Diagrammen erhalten wird: das beste Ergebnis aus Hunderten von Versuchen, es besser zu machen als andere.  Das Wettbewerbsprinzip ermöglicht es Ihnen, ein so hohes Qualitätsniveau zu erreichen, dass niemand auf Bestellung und ohne Geld arbeiten kann. <br><br>  Und ein paar Links: <br><br><ul><li>  Wettbewerbsergebnisse: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">t.me/contest/81</a> </li><li>  Alle Wettbewerbsteilnehmer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">contest.dev/chart-js</a> </li><li>  Meine Seite auf der Wettbewerbswebsite: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">contest.dev/chart-js/entry74</a> </li><li>  Meine Bewerbung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jschart.usercontent.dev/entry74</a> </li><li>  Wenn es kein Telegramm gibt, können Sie es hier sehen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">asyncoders.com/telechart/index.html</a> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Und ein bisschen freie Stellen</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS Developer (Cloud-Richtung)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemarchitekt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemanalytiker</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Führender Systemingenieur VMware</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwickler 1C</a> </li></ul></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460625/">https://habr.com/ru/post/de460625/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460611/index.html">Failover: Perfektionismus ruiniert uns und ... Faulheit</a></li>
<li><a href="../de460615/index.html">Im Gefolge von Industrial Ninja: Wie PLC an den Positive Hack Days 9 gehackt wurde</a></li>
<li><a href="../de460617/index.html">Die ganze Wahrheit über RTOS. Artikel 30. Initialisierungs- und Startverfahren für Nucleus SE</a></li>
<li><a href="../de460621/index.html">Tic Tac Toe Teil 4: Interaktion mit dem Flask Backend über HTTP</a></li>
<li><a href="../de460623/index.html">Über die Folter von Julian Assange</a></li>
<li><a href="../de460627/index.html">vGPU - Verwendung kann nicht ignoriert werden</a></li>
<li><a href="../de460629/index.html">Die Wahrscheinlichkeit, dass 2 Bergleute dieselbe Welt haben</a></li>
<li><a href="../de460631/index.html">In 80 Tagen um das Abzeichen: auf der anderen Seite OFFZONE</a></li>
<li><a href="../de460633/index.html">Implementierungsdetails für RSTP und Proprietary Extended Ring Redundancy</a></li>
<li><a href="../de460635/index.html">CLRium # 6: Parallelität und Parallelität. Zwei Tage: vom Prozessor zum Async / Warten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>