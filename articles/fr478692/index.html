<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§í ‚ôªÔ∏è üì® Prise en charge de Java 8 sur Android ‚ô£Ô∏è üèÇ üèñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! J'attire votre attention sur la traduction d'un merveilleux article d'une s√©rie d'articles du c√©l√®bre Jake Worton sur la fa√ßon dont And...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prise en charge de Java 8 sur Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/478692/">  Bonjour, Habr!  J'attire votre attention sur la traduction d'un merveilleux article d'une s√©rie d'articles du <a href="https://twitter.com/JakeWharton%3Flang%3Den">c√©l√®bre Jake Worton</a> sur la fa√ßon dont Android 8 est pris en charge par Java. <br><br><img src="https://habrastorage.org/webt/ho/ap/qe/hoapqe-nhkwts3ekeettjbuiao8.png"><br><br>  <font color="#0000ff"><a href="https://jakewharton.com/androids-java-8-support/">L'article d'origine est ici</a></font> <br><a name="habracut"></a><br>  J'ai travaill√© √† la maison pendant plusieurs ann√©es et j'ai souvent entendu mes coll√®gues se plaindre d'Android prenant en charge diff√©rentes versions de Java. <br><br>  C'est un sujet assez compliqu√©.  Vous devez d'abord d√©cider ce que nous entendons par ¬´prise en charge Java dans Android¬ª, car dans une version du langage, il peut y avoir beaucoup de choses: fonctionnalit√©s (lambdas, par exemple), bytecode, outils, API, JVM et ainsi de suite. <br><br>  Lorsque les gens parlent de la prise en charge de Java 8 dans Android, cela signifie g√©n√©ralement la prise en charge des fonctionnalit√©s linguistiques.  Commen√ßons donc avec eux. <br><br><h2>  Lambdas </h2><br>  Une des principales innovations de Java 8 a √©t√© les lambdas. <br>  Le code est devenu plus concis et plus simple, les lambdas nous ont √©vit√©s d'avoir √† √©crire des classes anonymes volumineuses en utilisant une interface avec une seule m√©thode √† l'int√©rieur. <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ sayHi(s -&gt; System.out.println(s)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Logger logger)</span></span></span><span class="hljs-function"> </span></span>{ logger.log(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); } }</code> </pre> <br>  Apr√®s avoir compil√© cela en utilisant javac et l' <code>dx tool</code> h√©rit√©, nous obtenons l'erreur suivante: <br><br><pre> <code class="plaintext hljs">$ javac *.java $ ls Java8.java Java8.class Java8$Logger.class $ $ANDROID_HOME/build-tools/28.0.2/dx --dex --output . *.class Uncaught translation error: com.android.dx.cf.code.SimException: ERROR in Java8.main:([Ljava/lang/String;)V: invalid opcode ba - invokedynamic requires --min-sdk-version &gt;= 26 (currently 13) 1 error; aborting</code> </pre> <br>  Cette erreur se produit du fait que les lambdas utilisent une nouvelle instruction dans le bytecode - <code>invokedynamic</code> , qui a √©t√© ajout√©e dans Java 7. √Ä partir du texte d'erreur, vous pouvez voir qu'Android ne la prend en charge qu'√† partir de l'API 26 (Android 8). <br><br>  Cela ne semble pas tr√®s bon, car presque personne ne publiera une application avec 26 minApi.  Pour contourner ce <i>probl√®me, le</i> processus dit de <i>d√©suchage</i> est <i>utilis√©</i> , ce qui rend possible la prise en charge de lambda sur toutes les versions de l'API. <br><br><h2>  Histoire de la d√©saccharization </h2><br>  Elle est assez color√©e dans le monde Android.  Le but de la d√©saccharization est toujours le m√™me: permettre √† de nouvelles fonctionnalit√©s de langue de fonctionner sur tous les appareils. <br><br>  Initialement, par exemple, pour prendre en charge les lambdas dans Android, les d√©veloppeurs ont connect√© le plugin <a href="https://github.com/evant/gradle-retrolambda">Retrolambda</a> .  Il a utilis√© le m√™me m√©canisme int√©gr√© que la JVM, convertissant les lambdas en classes, mais il l'a fait au moment de l'ex√©cution, et non au moment de la compilation.  Les classes g√©n√©r√©es √©taient tr√®s co√ªteuses en termes de nombre de m√©thodes, mais au fil du temps, apr√®s des am√©liorations et des am√©liorations, cet indicateur est tomb√© √† quelque chose de plus ou moins raisonnable. <br><br>  Ensuite, l'√©quipe Android a <a href="https://android-developers.googleblog.com/2014/12/hello-world-meet-our-new-experimental.html">annonc√© un nouveau compilateur</a> qui prend en charge toutes les fonctionnalit√©s de Java 8 et est plus productif.  Il a √©t√© construit sur le compilateur Java Eclipse, mais au lieu de g√©n√©rer un bytecode Java, il a g√©n√©r√© un bytecode Dalvik.  Cependant, ses performances laissaient encore beaucoup √† d√©sirer. <br><br>  Lorsque le nouveau compilateur a √©t√© (heureusement) abandonn√©, le transformateur de bytecode Java dans le bytecode Java, qui a fait le jonglage, a <a href="https://android-developers.googleblog.com/2017/04/java-8-language-features-support-update.html">√©t√© int√©gr√© dans le plugin Android Gradle</a> de <a href="https://docs.bazel.build/versions/master/bazel-and-android.html">Bazel</a> , le syst√®me de build de Google.  Et ses performances √©tant encore faibles, la recherche d'une meilleure solution s'est poursuivie en parall√®le. <br><br>  Et maintenant, on nous a <a href="https://android-developers.googleblog.com/2017/08/next-generation-dex-compiler-now-in.html"><code>  dexer</code></a> - <i>D8</i> , qui √©tait cens√© remplacer l' <code>dx tool</code> .  D√©saccharization a maintenant √©t√© effectu√©e lors de la conversion des fichiers JAR compil√©s en <code>.dex</code> (dexing).  Les performances du D8 sont bien meilleures que celles du <code>dx</code> , et depuis Android Gradle Plugin 3.1, il est devenu le dexer par d√©faut. <br><br><h2>  D8 </h2><br>  Maintenant, en utilisant D8, nous pouvons compiler le code ci-dessus. <br><br><pre> <code class="plaintext hljs">$ java -jar d8.jar \ --lib $ANDROID_HOME/platforms/android-28/android.jar \ --release \ --output . \ *.class $ ls Java8.java Java8.class Java8$Logger.class classes.dex</code> </pre> <br>  Pour voir comment le lambda D8 a √©t√© converti, vous pouvez utiliser l' <code>dexdump tool</code> , qui est inclus dans le SDK Android.  Il affichera beaucoup de tout, mais nous nous concentrerons uniquement sur cela: <br><br><pre> <code class="plaintext hljs">$ $ANDROID_HOME/build-tools/28.0.2/dexdump -d classes.dex [0002d8] Java8.main:([Ljava/lang/String;)V 0000: sget-object v0, LJava8$1;.INSTANCE:LJava8$1; 0002: invoke-static {v0}, LJava8;.sayHi:(LJava8$Logger;)V 0005: return-void [0002a8] Java8.sayHi:(LJava8$Logger;)V 0000: const-string v0, "Hello" 0002: invoke-interface {v1, v0}, LJava8$Logger;.log:(Ljava/lang/String;)V 0005: return-void ‚Ä¶</code> </pre> <br>  Si vous n'avez pas encore lu le bytecode, ne vous inqui√©tez pas: une grande partie de ce qui est √©crit ici peut √™tre comprise intuitivement. <br><br>  Dans le premier bloc, notre m√©thode <code>main</code> avec l'index <code>0000</code> obtient une r√©f√©rence du champ <code>INSTANCE</code> √† la classe <code>INSTANCE</code> <code>Java8$1</code> .  Cette classe a √©t√© g√©n√©r√©e pendant la <code></code> .  Le bytecode de la m√©thode principale ne contient aucune mention du corps de notre lambda, donc, tr√®s probablement, il est associ√© √† la classe <code>Java8$1</code> .  L'index <code>0002</code> appelle ensuite la m√©thode statique <code>sayHi</code> utilisant le lien vers <code>INSTANCE</code> .  La <code>sayHi</code> n√©cessite <code>Java8$Logger</code> , il semble donc que <code>Java8$1</code> impl√©mente cette interface.  Nous pouvons le v√©rifier ici: <br><br><pre> <code class="plaintext hljs">Class #2 - Class descriptor : 'LJava8$1;' Access flags : 0x1011 (PUBLIC FINAL SYNTHETIC) Superclass : 'Ljava/lang/Object;' Interfaces - #0 : 'LJava8$Logger;'</code> </pre> <br>  L'indicateur <code>SYNTHETIC</code> signifie que la classe <code>Java8$1</code> √©t√© g√©n√©r√©e et la liste des interfaces qu'elle contient contient le <code>Java8$Logger</code> . <br>  Cette classe repr√©sente notre lambda.  Si vous regardez l'impl√©mentation de la m√©thode <code>log</code> , vous ne verrez pas le corps du lambda. <br><br><pre> <code class="plaintext hljs">‚Ä¶ [00026c] Java8$1.log:(Ljava/lang/String;)V 0000: invoke-static {v1}, LJava8;.lambda$main$0:(Ljava/lang/String;)V 0003: return-void ‚Ä¶</code> </pre> <br>  Au lieu de cela, la m√©thode <code>static</code> de la classe <code>Java8</code> est <code>Java8</code> - <code>lambda$main$0</code> .  Je r√©p√®te, cette m√©thode est pr√©sent√©e uniquement en bytecode. <br><br><pre> <code class="plaintext hljs">‚Ä¶ #1 : (in LJava8;) name : 'lambda$main$0' type : '(Ljava/lang/String;)V' access : 0x1008 (STATIC SYNTHETIC) [0002a0] Java8.lambda$main$0:(Ljava/lang/String;)V 0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; 0002: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V 0005: return-void</code> </pre> <br>  L'indicateur <code>SYNTHETIC</code> nous indique √† nouveau que cette m√©thode a √©t√© g√©n√©r√©e et que son bytecode contient simplement le corps lambda: un appel √† <code>System.out.println</code> .  La raison pour laquelle le corps lambda est √† l'int√©rieur de <i>Java8.class</i> est simple - il peut avoir besoin d'acc√©der <code>private</code> membres <code>private</code> de la classe, auxquels la classe g√©n√©r√©e n'aura pas acc√®s. <br><br>  Tout ce dont vous avez besoin pour comprendre comment fonctionne la <i>d√©saccharization</i> est d√©crit ci-dessus.  Cependant, en le regardant dans le bytecode Dalvik, vous pouvez voir que tout y est beaucoup plus compliqu√© et effrayant. <br><br><h2>  Transformation de la source </h2><br>  Pour mieux comprendre comment se produit la <i>d√©saccharization</i> , essayons pas √† pas de convertir notre classe en quelque chose qui fonctionnera sur toutes les versions de l'API. <br><br>  Prenons la m√™me classe avec lambda comme base: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ sayHi(s -&gt; System.out.println(s)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Logger logger)</span></span></span><span class="hljs-function"> </span></span>{ logger.log(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); } }</code> </pre> <br>  Tout d'abord, le corps lambda est d√©plac√© vers la m√©thode <code>package private</code> du <code>package private</code> . <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(s -&gt; System.out.println(s)); + sayHi(s -&gt; lambda$main$0(s)); } + + static void lambda$main$0(String s) { + System.out.println(s); + }</code> </pre> <br>  Ensuite, une classe est impl√©ment√©e qui impl√©mente l'interface <code>Logger</code> , √† l'int√©rieur de laquelle un bloc de code du corps lambda est ex√©cut√©. <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(s -&gt; lambda$main$0(s)); + sayHi(new Java8$1()); } @@ } + +class Java8$1 implements Java8.Logger { + @Override public void log(String s) { + Java8.lambda$main$0(s); + } +}</code> </pre> <br>  Ensuite, une instance singleton de <code>Java8$1</code> , qui est stock√©e dans la variable <code>static</code> <code>INSTANCE</code> . <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(new Java8$1()); + sayHi(Java8$1.INSTANCE); } @@ class Java8$1 implements Java8.Logger { + static final Java8$1 INSTANCE = new Java8$1(); + @Override public void log(String s) {</code> </pre> <br>  Voici la derni√®re classe <i>doubl√©e</i> qui peut √™tre utilis√©e sur toutes les versions de l'API: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ sayHi(Java8$<span class="hljs-number"><span class="hljs-number">1</span></span>.INSTANCE); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> lambda$main$<span class="hljs-number"><span class="hljs-number">0</span></span>(String s) { System.out.println(s); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Logger logger)</span></span></span><span class="hljs-function"> </span></span>{ logger.log(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class">$1 </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Java8$<span class="hljs-number"><span class="hljs-number">1</span></span> INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Java8$<span class="hljs-number"><span class="hljs-number">1</span></span>(); <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span><span class="hljs-function"> </span></span>{ Java8.lambda$main$<span class="hljs-number"><span class="hljs-number">0</span></span>(s); } }</code> </pre> <br>  Si vous regardez la classe g√©n√©r√©e dans le bytecode Dalvik, vous ne trouverez pas de noms comme Java8 $ 1 - il y aura quelque chose comme <code>-$$Lambda$Java8$QkyWJ8jlAksLjYziID4cZLvHwoY</code> .  La raison pour laquelle une telle d√©nomination est g√©n√©r√©e pour la classe, et quels sont ses avantages, tire √† un article distinct. <br><br><h2>  Prise en charge native de lambda </h2><br>  Lorsque nous avons utilis√© l' <code>dx tool</code> pour compiler une classe contenant des lambdas, un message d'erreur a d√©clar√© que cela ne fonctionnerait qu'avec 26 API. <br><br><pre> <code class="plaintext hljs">$ $ANDROID_HOME/build-tools/28.0.2/dx --dex --output . *.class Uncaught translation error: com.android.dx.cf.code.SimException: ERROR in Java8.main:([Ljava/lang/String;)V: invalid opcode ba - invokedynamic requires --min-sdk-version &gt;= 26 (currently 13) 1 error; aborting</code> </pre> <br>  Par cons√©quent, il semble logique que si nous essayons de compiler cela avec l' <code>‚Äîmin-api 26</code> , alors la d√©saccharization ne se produira pas. <br><br><pre> <code class="bash hljs">$ java -jar d8.jar \ --lib <span class="hljs-variable"><span class="hljs-variable">$ANDROID_HOME</span></span>/platforms/android-28/android.jar \ --release \ --min-api 26 \ --output . \ *.class</code> </pre> <br>  Cependant, si nous <code>.dex</code> fichier <code>.dex</code> , il peut toujours y √™tre trouv√© <code>-$$Lambda$Java8$QkyWJ8jlAksLjYziID4cZLvHwoY</code> .  Pourquoi  Est-ce un bug D8? <br><br>  Pour r√©pondre √† cette question, et aussi pourquoi la d√©saccharization <i>se produit toujours</i> , nous devons regarder √† l'int√©rieur du bytecode Java de la classe <code>Java8</code> . <br><br><pre> <code class="bash hljs">$ javap -v Java8.class class Java8 { public static void main(java.lang.String...); Code: 0: invokedynamic <span class="hljs-comment"><span class="hljs-comment">#2, 0 // InvokeDynamic #0:log:()LJava8$Logger; 5: invokestatic #3 // Method sayHi:(LJava8$Logger;)V 8: return } ‚Ä¶</span></span></code> </pre> <br>  √Ä l'int√©rieur de la m√©thode <code>main</code> , nous voyons √† nouveau <i>invokedynamic</i> √† l'index <code>0</code> .  Le deuxi√®me argument de l'appel est <code>0</code> - l'index de la m√©thode d' <a href="https://stackoverflow.com/questions/30733557/what-is-a-bootstrap-method">amor√ßage qui lui est</a> associ√©e. <br><br>  Voici une liste de m√©thodes d' <i>amor√ßage</i> : <br><br><pre> <code class="plaintext hljs">‚Ä¶ BootstrapMethods: 0: #27 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:( Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String; Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType; Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;) Ljava/lang/invoke/CallSite; Method arguments: #28 (Ljava/lang/String;)V #29 invokestatic Java8.lambda$main$0:(Ljava/lang/String;)V #28 (Ljava/lang/String;)V</code> </pre> <br>  Ici, la m√©thode d' <i>amor√ßage</i> est appel√©e <code>metafactory</code> dans la classe <code>java.lang.invoke.LambdaMetafactory</code> .  Il <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html">vit dans le JDK</a> et cr√©e des classes anonymes √† la vol√©e lors de l'ex√©cution pour les lambdas, tout comme D8 les g√©n√®re en temps de calcul. <br><br>  Si vous regardez la <a href="https://developer.android.com/reference/java/lang/invoke/package-summary"><code> Android  java.lang.invoke</code></a> <br>  ou aux <a href="https://android.googlesource.com/platform/libcore/%2B/master/ojluni/src/main/java/java/lang/invoke/"><code> AOSP  java.lang.invoke</code></a> , nous voyons que cette classe n'est pas dans le runtime.  C'est pourquoi le jonglage se produit toujours au moment de la compilation, quel que soit le minApi que vous avez.  La machine virtuelle prend en charge les instructions de bytecode similaires √† <code>invokedynamic</code> , mais le <code>invokedynamic</code> int√©gr√© au JDK <code>LambdaMetafactory</code> pas disponible pour utilisation. <br><br><h2>  R√©f√©rences de m√©thode </h2><br>  Avec lambdas, Java 8 a ajout√© des r√©f√©rences de m√©thode - c'est un moyen efficace de cr√©er un lambda dont le corps r√©f√©rence une m√©thode existante. <br><br>  Notre interface <code>Logger</code> est un exemple.  Le corps lambda fait r√©f√©rence √† <code>System.out.println</code> .  Transformons le lambda en m√©thode de r√©f√©rence: <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(s -&gt; System.out.println(s)); + sayHi(System.out::println); }</code> </pre> <br>  Lorsque nous le compilons et jetons un ≈ìil au bytecode, nous verrons une diff√©rence avec la version pr√©c√©dente: <br><br><pre> <code class="plaintext hljs">[000268] -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM.log:(Ljava/lang/String;)V 0000: iget-object v0, v1, L-$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM;.f$0:Ljava/io/PrintStream; 0002: invoke-virtual {v0, v2}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V 0005: return-void</code> </pre> <br>  Au lieu d'appeler le <code>Java8.lambda$main$0</code> g√©n√©r√©, qui contient un appel √† <code>System.out.println</code> , maintenant <code>System.out.println</code> est appel√© directement. <br><br>  Une classe avec un lambda n'est plus un singleton <code>static</code> , mais par l'index <code>0000</code> dans le bytecode, nous voyons que nous obtenons un lien vers <code>PrintStream</code> - <code>System.out</code> , qui est ensuite utilis√© pour appeler <code>println</code> dessus. <br><br>  En cons√©quence, notre classe s'est transform√©e en ceci: <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(System.out::println); + sayHi(new -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM(System.out)); } @@ } + +class -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM implements Java8.Logger { + private final PrintStream ps; + + -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM(PrintStream ps) { + this.ps = ps; + } + + @Override public void log(String s) { + ps.println(s); + } +}</code> </pre> <br><h2>  M√©thodes <code>Default</code> et <code>static</code> dans les interfaces </h2><br>  Un autre changement important et majeur apport√© par Java 8 a √©t√© la possibilit√© de d√©clarer <code>static</code> m√©thodes <code>default</code> et <code>static</code> dans les interfaces. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String tag, String s)</span></span></span><span class="hljs-function"> </span></span>{ log(tag + <span class="hljs-string"><span class="hljs-string">": "</span></span> + s); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Logger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">systemOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> System.out::println; } }</code> </pre> <br>  Tout cela est √©galement pris en charge par D8.  En utilisant les m√™mes outils qu'auparavant, il est facile de voir une version connect√©e de Logger avec <code>static</code> m√©thodes par <code>default</code> et <code>static</code> .  L'une des diff√©rences avec les lambdas et les <code>method references</code> est que les m√©thodes par d√©faut et statiques sont impl√©ment√©es dans la machine virtuelle Android et, √† partir de l'API 24, D8 ne les <i>d√©couplera</i> pas. <br><br><h2>  Peut-√™tre utiliser simplement Kotlin? </h2><br>  En lisant l'article, la plupart d'entre vous ont probablement pens√© √† Kotlin.  Oui, il prend en charge toutes les fonctionnalit√©s de Java 8, mais elles sont impl√©ment√©es par <code>kotlinc</code> de la m√™me mani√®re que D8, √† l'exception de certains d√©tails. <br><br>  Par cons√©quent, le support Android pour les nouvelles versions de Java est toujours tr√®s important, m√™me si votre projet est √©crit √† 100% en Kotlin. <br><br>  Il est possible qu'√† l'avenir Kotlin ne prenne plus en charge le bytecode Java 6 et Java 7. <a href="https://blog.jetbrains.com/idea/2015/12/intellij-idea-16-eap-144-2608-is-out/">IntelliJ IDEA</a> , Gradle 5.0 est pass√© √† Java 8. Le nombre de plates-formes fonctionnant sur des machines virtuelles Java plus anciennes diminue. <br><br><h2>  Desugaring APIs </h2><br>  Pendant tout ce temps, j'ai parl√© des fonctionnalit√©s de Java 8, mais je n'ai rien dit sur les nouvelles API - flux, <code>CompletableFuture</code> , date / heure, etc. <br><br>  Pour revenir √† l'exemple de l'enregistreur, nous pouvons utiliser la nouvelle API date / heure pour savoir quand les messages ont √©t√© envoy√©s. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.time.*; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDateTime time, String s)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ sayHi((time, s) -&gt; System.out.println(time + <span class="hljs-string"><span class="hljs-string">" "</span></span> + s)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Logger logger)</span></span></span><span class="hljs-function"> </span></span>{ logger.log(LocalDateTime.now(), <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); } }</code> </pre> <br>  <i>Compilez-</i> le √† nouveau avec <code>javac</code> et convertissez-le en bytecode Dalvik avec D8, qui le <i>dissocie</i> pour le prendre en charge sur toutes les versions de l'API. <br><br><pre> <code class="plaintext hljs">$ javac *.java $ java -jar d8.jar \ --lib $ANDROID_HOME/platforms/android-28/android.jar \ --release \ --output . \ *.class</code> </pre> <br>  Vous pouvez m√™me l'ex√©cuter sur votre appareil pour vous assurer qu'il fonctionne. <br><br><pre> <code class="plaintext hljs">$ adb push classes.dex /sdcard classes.dex: 1 file pushed. 0.5 MB/s (1620 bytes in 0.003s) $ adb shell dalvikvm -cp /sdcard/classes.dex Java8 2018-11-19T21:38:23.761 Hello</code> </pre> <br>  Si l'API 26 et les versions ult√©rieures se trouvent sur cet appareil, le message Hello appara√Æt.  Sinon, nous verrons ce qui suit: <br><br><pre> <code class="plaintext hljs">java.lang.NoClassDefFoundError: Failed resolution of: Ljava/time/LocalDateTime; at Java8.sayHi(Java8.java:13) at Java8.main(Java8.java:9)</code> </pre> <br>  D8 a trait√© des lambdas, une m√©thode de r√©f√©rence, mais n'a rien fait pour fonctionner avec <code>LocalDateTime</code> , et c'est tr√®s triste. <br><br>  Les d√©veloppeurs doivent utiliser leurs propres impl√©mentations ou wrappers sur l'api date / heure, ou utiliser des biblioth√®ques comme <code>ThreeTenBP</code> pour travailler avec le temps, mais pourquoi ne pouvez-vous pas faire D8 de vos propres mains? <br><br><h2>  √âpilogue </h2><br>  Le manque de prise en charge de toutes les nouvelles API Java 8 reste un gros probl√®me dans l'√©cosyst√®me Android.  Apr√®s tout, il est peu probable que chacun de nous puisse nous permettre de sp√©cifier l'API de 26 min dans notre projet.  Les biblioth√®ques prenant en charge Android et JVM ne peuvent pas se permettre d'utiliser l'API qui nous a √©t√© pr√©sent√©e il y a 5 ans! <br><br>  Et m√™me si la prise en charge de Java 8 fait d√©sormais partie de D8, chaque d√©veloppeur doit toujours sp√©cifier explicitement la compatibilit√© des sources et des cibles dans Java 8. Si vous √©crivez vos propres biblioth√®ques, vous pouvez renforcer cette tendance en disposant des biblioth√®ques qui utilisent le bytecode Java 8. (m√™me si vous n'utilisez pas de nouvelles fonctionnalit√©s linguistiques). <br><br>  Beaucoup de travail est en cours sur D8, il semble donc que tout ira bien √† l'avenir avec la prise en charge des fonctionnalit√©s linguistiques.  M√™me si vous √©crivez uniquement sur Kotlin, il est tr√®s important de forcer l'√©quipe de d√©veloppement Android √† prendre en charge toutes les nouvelles versions de Java, √† am√©liorer le bytecode et les nouvelles API. <br><br>  Ce message est une version √©crite de mon discours <a href="https://jakewharton.com/digging-into-d8-and-r8/">Creuser dans D8 et R8</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr478692/">https://habr.com/ru/post/fr478692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr478672/index.html">Test et d√©marrage de l'IA: entretien avec Adam Carmi (Applitools)</a></li>
<li><a href="../fr478680/index.html">Pourquoi, et surtout, o√π vont les gens de l'informatique?</a></li>
<li><a href="../fr478684/index.html">Introduction au SSD. Partie 2. Interface</a></li>
<li><a href="../fr478688/index.html">Comment c'√©tait d'√©tudier la science des donn√©es en 2019</a></li>
<li><a href="../fr478690/index.html">Assemblage et d√©ploiement dynamiques d'images Docker avec werf en utilisant l'exemple de site de documentation versionn√©e</a></li>
<li><a href="../fr478694/index.html">Comme nous vous recommandons les derniers catalogues du cin√©ma en ligne ivi (+ code Python)</a></li>
<li><a href="../fr478696/index.html">Comment j'ai visit√© Urban Tech 2019. Rapport d'√©v√©nement</a></li>
<li><a href="../fr478698/index.html">Nous r√©alisons un plan de terrain interactif en 15 minutes</a></li>
<li><a href="../fr478702/index.html">Astuces de traitement m√©trique dans Kapacitor</a></li>
<li><a href="../fr478704/index.html">Que faire si les envois ont d√©j√† atteint le spam: 5 √©tapes pratiques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>