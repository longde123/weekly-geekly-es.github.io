<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñ üå≠ ü•É Algorithme Grover et recherche de donn√©es üìâ üßïüèø üõÄüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, habrozhiteli! Nous avons r√©cemment remis le livre de Chris Bernhard, Quantum Computing for Real IT . Ici, ils ont d√©cid√© de partager un extrait...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algorithme Grover et recherche de donn√©es</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/471010/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/xu/vp/8q/xuvp8q2m4cv20akrl-tdi11e650.png" alt="image"></div><br>  Salut, habrozhiteli!  Nous avons r√©cemment remis le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">livre de</a> Chris Bernhard, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quantum Computing for Real IT</a> .  Ici, ils ont d√©cid√© de partager un extrait du livre "Grover's Algorithm and Data Search" <br><br>  Nous entrons dans l'√®re du big data.  La recherche efficace d'ensembles de donn√©es gigantesques est actuellement une pr√©occupation br√ªlante pour de nombreuses grandes entreprises.  L'algorithme de Grover est th√©oriquement capable d'acc√©l√©rer les recherches de donn√©es. <br><br>  Love Grover a invent√© son algorithme en 1996.  Comme les algorithmes de Deutsch et Simon, il a une vitesse d'ex√©cution plus √©lev√©e que les algorithmes classiques en termes de complexit√© des requ√™tes.  Cependant, nous ne pourrons pas impl√©menter l'algorithme de r√©cup√©ration de donn√©es actuel sans oracles qui pourraient poser leurs questions.  Nous devons construire un algorithme qui effectue le travail de l'oracle.  Mais avant de commencer √† parler de la mise en ≈ìuvre de l'algorithme Grover, voyons ce qu'il fait et comment. <br><a name="habracut"></a><br><h3>  Algorithme de Grover </h3><br>  Imaginez que vous avez quatre cartes √† jouer.  Ils sont boulevers√©s.  Vous savez que l'un d'eux est un as de vers et vous devez le trouver.  Combien de cartes devrez-vous retourner jusqu'√† ce que vous sachiez o√π se trouve l'as de vers? <br><br>  Si vous √™tes chanceux, vous trouverez la carte souhait√©e au premier essai, si vous n'√™tes pas chanceux, vous pouvez retourner trois cartes, et aucune d'entre elles ne sera un as de vers.  Dans le pire des cas, en retournant trois cartes, vous saurez avec certitude que la derni√®re carte est l'as de ver que vous recherchez.  Ainsi, nous pouvons d√©couvrir o√π se trouve l'as en retournant une √† trois cartes.  En moyenne, vous devez retourner les cartes 2,25. <br><br>  C'est l'une des t√¢ches que l'algorithme de Grover r√©sout.  Avant de commencer la description de l'algorithme, nous reformulons le probl√®me.  Nous avons quatre s√©quences binaires: 00, 01, 10 et 11. Nous avons une fonction f qui renvoie 0 pour trois de ces s√©quences et 1 pour la quatri√®me s√©quence.  Nous devons trouver la s√©quence binaire correspondant √† la valeur de sortie 1. Par exemple, nous pouvons obtenir les r√©sultats suivants: f (00) = 0, f (01) = 0, f (10) = 1 et f (11) = 0. Maintenant, le probl√®me est est de savoir combien de fois la fonction doit √™tre calcul√©e pour obtenir le r√©sultat f (10) = 1. Ici, nous avons simplement reformul√© le probl√®me en rempla√ßant les cartes √† jouer par des fonctions, donc la r√©ponse √† cette question est d√©j√† connue: comme auparavant, en moyenne, il sera n√©cessaire de calculer la fonction 2,25 fois. <br><br>  Comme avec tous les algorithmes de requ√™te de complexit√©, nous construisons un oracle - une porte qui encapsule une fonction.  L'oracle de notre exemple, o√π il n'y a que quatre s√©quences binaires, est illustr√© √† la Fig.  9.1. <br><br>  La cha√Æne de l'algorithme Grover est repr√©sent√©e sur la Fig.  9.2. <br><br>  L'algorithme effectue deux √©tapes.  Sur le premier, le signe de l'amplitude de probabilit√© est invers√©, associ√© √† l'endroit que nous essayons de trouver.  Le second renforce cette amplitude de probabilit√©.  Voyons comment la cha√Æne proc√®de. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n_/0g/gy/n_0ggyb6_pma_97-qs66mvt-kri.png" alt="image"></div><br>  Apr√®s transmission via les valves Hadamard, les deux qubits sup√©rieurs obtiennent l'√©tat <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mn/x8/l-/mnx8l-are9pmkr7vhqgei894uca.png" alt="image"></div><br>  et le qubit inf√©rieur a un √©tat <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yt/av/sf/ytavsf_fwicnuaick1ix2wenkoo.png" alt="image"></div><br>  L'√©tat combin√© peut s'√©crire <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yb/yd/-q/ybyd-qncd1qely0j24fm1gaovtq.png" alt="image"></div><br>  Les qubits passent ensuite par la porte F. Il inverse 0 et 1 dans le troisi√®me qubit √† l'emplacement que nous essayons de trouver.  Pour notre cas f (10) = 1 on obtient <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rb/oe/rq/rboerqt-qdwrzyq3iwr6ytvrj18.png" alt="image"></div><br><br>  Il peut √™tre r√©√©crit comme <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rl/eo/ih/rleoihdnyso6gcvgiig9unrahqu.png" alt="image"></div><br><br>  En cons√©quence, nous obtenons deux qubits sup√©rieurs, non confondus avec les inf√©rieurs, mais l'amplitude de probabilit√© <img src="https://habrastorage.org/webt/s4/yi/2c/s4yi2ctlx8zymvvj02ush4y6tz4.png" alt="image">  changera le signe, indiquant l'emplacement souhait√©. <br><br>  Si nous mesurons les deux qubits sup√©rieurs √† cette √©tape, nous obtenons l'un des quatre emplacements, et les quatre r√©ponses possibles sont √©galement probables.  Nous devons faire un autre pas - pour augmenter l'amplitude de la probabilit√©.  L'amplification est r√©alis√©e en inversant la s√©quence des nombres par rapport √† leur moyenne.  Si le nombre est sup√©rieur √† la moyenne, il bascule et devient inf√©rieur √† la moyenne.  Si le nombre est inf√©rieur √† la moyenne, il bascule et devient sup√©rieur √† la moyenne.  Dans chaque cas, l'√©loignement de la moyenne est maintenu.  Pour illustrer, nous utilisons quatre nombres: 1, 1, 1 et ‚Äì1.  Leur somme est de 2 et la moyenne est de 2/4 ou 1/2.  Ensuite, nous commen√ßons √† trier les num√©ros dans la s√©quence.  Le premier nombre est 1. Il est 1/2 au-dessus de la moyenne.  Apr√®s le coup d'√âtat, il devrait √™tre 1/2 de moins que la moyenne.  Dans ce cas, il passera √† 0. Le nombre ‚Äì1 est inf√©rieur √† la moyenne de 3/2.  Apr√®s le coup d'√âtat, il devrait devenir 3/2 au-dessus de la moyenne, c'est-√†-dire se transformer en 2. <br><br>  Deux qubits sup√©rieurs ont actuellement un √©tat <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mi/eb/zx/miebzxscvcaw8r6hdj3oudogmsk.png" alt="image"></div><br>  En tournant les amplitudes par rapport √† la moyenne, on obtient <img src="https://habrastorage.org/webt/vc/3k/hv/vc3khv7pp6csf5n9u4skjqz5rfq.png" alt="image"><img src="https://habrastorage.org/webt/7f/tt/7z/7ftt7zqz5rtqjb7qebqxblbamyc.png" alt="image">  . <br>  Une fois la mesure termin√©e, nous en obtiendrons certainement 10, c'est-√†-dire qu'une r√©volution par rapport √† la moyenne nous donne exactement ce dont nous avons besoin.  Tout ce que nous avons √† faire est de nous assurer qu‚Äôil existe une porte ou, ce qui revient au m√™me, une matrice orthogonale d√©crivant une r√©volution par rapport √† la moyenne.  Une telle matrice existe: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3b/wm/lq/3bwmlqywrtg8jv3pknydbbzagh0.png" alt="image"></div><br>  √Ä la suite de l'action de la valve sur les deux qubits sup√©rieurs, nous obtenons <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1y/oq/ly/1yoqlylytnhsdqrjiqfaf04zyqs.png" alt="image"></div><br>  Dans cet exemple, o√π nous n'avons que deux qubits, nous ne devons utiliser l'oracle qu'une seule fois.  Il nous suffit de poser la seule question.  Pour le cas n = 2, l'algorithme de Grover donne une r√©ponse exacte apr√®s une seule question, alors que dans le cas classique, en moyenne, 2,25 questions doivent √™tre pos√©es. <br><br>  Cette id√©e s'√©tend au cas d'un nombre arbitraire de n qubits.  On commence par tourner le signe de l'amplitude de probabilit√©, qui correspond √† l'emplacement souhait√©.  Ensuite, nous effectuons une r√©volution par rapport √† la moyenne.  Cependant, dans ce cas, l'amplification de l'amplitude ne se produit pas aussi significativement que dans la situation √† deux qubits.  Prenons par exemple huit nombres, dont sept sont 1 et un est -1.  Leur somme est de 6 et la moyenne est de 6/8.  Apr√®s un flip, le 1 moyen tournera 1/2 et ‚Äì1 tournera 10/4.  Par cons√©quent, en pr√©sence de trois qubits, mesurant un qubit apr√®s amplification de l'amplitude, nous obtiendrons l'emplacement souhait√© avec une probabilit√© plus √©lev√©e que les autres.  Le probl√®me est qu'il y a une chance importante d'obtenir la mauvaise r√©ponse.  Nous avons besoin d'une probabilit√© plus √©lev√©e d'obtenir la bonne r√©ponse - nous devons encore amplifier l'amplitude avant de mesurer.  La solution est de retransf√©rer tous les qubits √† travers la cha√Æne.  Nous inversons √† nouveau le signe de l'amplitude de probabilit√© associ√©e √† l'emplacement souhait√© et inversons √† nouveau par rapport √† la moyenne. <br><br>  Prenons le cas g√©n√©ralis√©.  Nous devons trouver quelque chose dans l'un des m emplacements possibles.  Pour le trouver de fa√ßon classique, dans le pire des cas nous devons poser m - 1 questions.  Le nombre de questions augmente proportionnellement √† m.  Grover a calcul√© une formule qui d√©termine combien de fois sa cha√Æne doit √™tre utilis√©e pour obtenir la probabilit√© maximale d'une r√©ponse correcte.  Le nombre que cette formule donne cro√Æt proportionnellement <img src="https://habrastorage.org/webt/zf/wk/uv/zfwkuvnbn6kqnmfr05edx02rudw.png" alt="image">  .  Il s'agit d'une acc√©l√©ration quadratique. <br><br><h3>  Applications de l'algorithme Grover </h3><br>  Il y a plusieurs probl√®mes avec l'impl√©mentation de l'algorithme.  Tout d'abord, l'acc√©l√©ration quadratique est √©valu√©e par rapport √† la demande de complexit√©.  Pour utiliser l'oracle, vous devez le cr√©er, et si vous n'effectuez pas cette t√¢che avec soin, le nombre d'√©tapes effectu√©es par l'oracle l'emportera sur le nombre d'√©tapes que l'algorithme enregistre, et par cons√©quent, l'algorithme deviendra plus lent plut√¥t que plus rapide que le classique.  Un autre probl√®me est que, en d√©terminant l'acc√©l√©ration, nous supposons que l'ensemble de donn√©es est d√©sordonn√©.  Si l'ensemble de donn√©es a une structure sp√©cifique, vous pouvez souvent trouver un algorithme classique qui utilise cette structure et recherche une solution beaucoup plus rapidement.  Le dernier probl√®me est li√© √† l'acc√©l√©ration.  L'acc√©l√©ration quadratique n'est rien d'autre qu'une acc√©l√©ration exponentielle, que nous avons observ√©e dans d'autres algorithmes.  Est-il possible d'en faire plus?  Examinons ces probl√®mes. <br><br>  Les deux probl√®mes li√©s √† la mise en ≈ìuvre de l'oracle et la pr√©sence de la structure dans l'ensemble de donn√©es sont justifi√©s et montrent que dans la plupart des cas, l'algorithme Grover n'a pas d'application pratique pour la recherche dans la base de donn√©es.  Mais dans certaines situations, avoir une structure dans les donn√©es permet de cr√©er un oracle qui agit avec une grande efficacit√©.  Dans de telles situations, l'algorithme peut d√©passer les algorithmes classiques.  La r√©ponse √† la question de la possibilit√© d'obtenir un plus grand succ√®s a d√©j√† √©t√© donn√©e.  Il est prouv√© que l'algorithme de Grover est optimal.  Il n'y a pas d'algorithme quantique capable de r√©soudre un probl√®me avec une acc√©l√©ration plus que quadratique.  L'acc√©l√©ration quadratique, bien qu'elle ne soit pas aussi impressionnante que l'exponentielle, offre n√©anmoins certains avantages.  Lorsque vous travaillez avec de grands ensembles de donn√©es, toute acc√©l√©ration peut √™tre utile. <br><br>  Il est probable que l'algorithme Grover trouvera l'application principale non pas pour la recherche, comme cela a √©t√© pr√©sent√© ci-dessus, mais pour ses variations.  En particulier, l'id√©e d'amplifier l'amplitude peut √™tre utile. <br><br>  Nous n'avons examin√© que quelques algorithmes, mais les algorithmes Shore et Grover sont consid√©r√©s comme les plus importants.  Il existe de nombreux autres algorithmes bas√©s sur les id√©es inh√©rentes √† ces deux.1 Maintenant tournons notre attention des algorithmes quantiques vers d'autres domaines d'application de l'informatique quantique. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471010/">https://habr.com/ru/post/fr471010/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr470998/index.html">Jouets en bois, dixi√®me partie - 1996</a></li>
<li><a href="../fr471000/index.html">Jouets en bois, derni√®re partie - 1997</a></li>
<li><a href="../fr471004/index.html">Jouets en bois - un √©pilogue qui reste clou√© au plafond</a></li>
<li><a href="../fr471006/index.html">500 $ par mois: sur quoi les b√©n√©ficiaires d'un revenu de base inconditionnel d√©pensent-ils leur argent?</a></li>
<li><a href="../fr471008/index.html">Parlons de surveillance: enregistrement en direct du podcast Devops Deflope avec New Relic lors de la r√©union du 23 octobre</a></li>
<li><a href="../fr471012/index.html">Approche d'ing√©nierie du d√©veloppement logiciel. De la th√©orie √† la pratique</a></li>
<li><a href="../fr471014/index.html">Nous fabriquons un drone aquatique autonome, ou comme je r√™vais d'aider le Ba√Økal, mais je ne suis pas Gazprom. Partie 1</a></li>
<li><a href="../fr471016/index.html">Conception de base de donn√©es. Meilleures pratiques</a></li>
<li><a href="../fr471018/index.html">Comparaison des performances du PC et du smartphone, y compris l'iPhone 11</a></li>
<li><a href="../fr471020/index.html">Comment trouver un bug dans un microprocesseur sorti il ‚Äã‚Äãy a trente-cinq ans</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>