<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👃🏿 🏇🏿 💽 Crea tu Minecraft: genera niveles 3D a partir de cubos 🛵 🆗 🏒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En parte debido a la popularidad de Minecraft , recientemente ha habido un creciente interés en la idea de un juego que tiene lugar en un mundo en cub...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crea tu Minecraft: genera niveles 3D a partir de cubos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472574/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/jj/va/ccjjvazyarduee258az9-bbggkq.png"></div><br>  En parte debido a la popularidad de <b>Minecraft</b> , recientemente ha habido un creciente interés en la idea de un juego que tiene lugar en un mundo en cubos construido en relieve 3D y lleno de elementos como cuevas, acantilados, etc.  Tal mundo es una aplicación ideal para el ruido generado al estilo de mi biblioteca <b>ANL</b> .  Este artículo surgió de las discusiones de mis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">intentos</a> anteriores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de</a> implementar esta técnica.  Desde entonces, han aparecido cambios menores en la estructura de la biblioteca. <br><br>  En publicaciones anteriores, hablé sobre el uso de características de ruido 3D para implementar terrenos al estilo Minecraft.  Después de eso, la biblioteca evolucionó un poco, así que decidí volver a este tema.  Como tuve que responder muchas preguntas sobre este sistema, intentaré hablar más sobre los conceptos involucrados.  Para aclarar los conceptos básicos, comenzaré con la idea de generar un terreno 2D utilizado en juegos como Terraria y King Arthur's Gold, y luego expandiré el sistema a ejemplos 3D como Minecraft.  Esto me permitirá demostrar conceptos de manera más efectiva utilizando imágenes como ejemplo. <br><br>  Este sistema se desarrolló teniendo en cuenta el siguiente objetivo abstracto: deberíamos poder pasar la coordenada de un determinado punto o celda al sistema y determinar qué tipo de bloque debería estar en esta ubicación.  Queremos que el sistema sea una "caja negra": le pasamos un punto, devolvemos el tipo de bloque.  Por supuesto, esto se aplica solo a la generación inicial del mundo.  Los bloqueos en dichos juegos pueden ser cambiados por las acciones del jugador, y será inconveniente tratar de describir dichos cambios usando el mismo sistema.  Dichos cambios deben ser rastreados de alguna otra manera.  Este sistema genera el mundo original, prístino e intacto por las manos del jugador y otros personajes. <br><a name="habracut"></a><br>  Quizás esta técnica no sea adecuada para modelar sistemas como el césped u otras entidades biológicas, dado que dichos sistemas son entidades complejas que no son tan fáciles de modelar implícitamente.  Lo mismo se aplica a sistemas como la caída de nieve, la formación de hielo, etc. La técnica descrita en el artículo es un <i>método implícito</i> , es decir.  uno que puede estimarse en un punto y cuyo valor en un punto dado no depende de los valores circundantes.  Los sistemas biológicos y de otro tipo para realizar simulaciones precisas generalmente necesitan considerar los valores ambientales.  Por ejemplo: ¿cuánta luz solar cae sobre un bloque?  ¿Hay agua cerca?  Estas y otras preguntas deben responderse para simular el crecimiento y la propagación de los sistemas biológicos, así como, en menor medida, otros tipos de sistemas relacionados con el clima.  Además, esta técnica no es adecuada para modelar agua.  En este sistema no existe un concepto de flujo, conocimiento de mecánica de fluidos o gravedad.  El agua es un tema complejo que requiere muchos cálculos complejos. <br><br>  Entonces, solo estamos modelando la tierra y las piedras.  Necesitamos una función que le indique cuál debe ser la ubicación dada: tierra, arena, aire, oro, hierro, carbón, etc. ... Pero comenzaremos con la más simple.  Necesitamos una función que indique si el bloque es sólido o hueco (lleno de aire).  Esta función debería simular la tierra que nos rodea.  Es decir, el cielo está arriba, la tierra está abajo.  Entonces, asumamos la tarea bíblica y separemos el cielo de la tierra.  Para hacer esto, estudiamos la función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gradiente</a> .  La función Gradiente pasa un segmento de línea en un espacio N-dimensional (es decir, en cualquier espacio de coordenadas, ya sea 2D, 3D o superior), y calcula el campo de gradiente a lo largo de este segmento.  Las coordenadas entrantes se proyectan en este segmento y su valor de gradiente se calcula en función de dónde se encuentran en relación con los puntos finales del segmento.  Los puntos proyectados son valores asignados en el intervalo (-1.1).  Y este será un buen comienzo para nosotros.  Podemos definir la función Gradiente a lo largo del eje Y. En la parte superior del intervalo, comparamos el campo de gradiente con -1 (aire) y en la parte inferior con 1 (tierra). <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1}
 } </pre><br>  (Explicaré la entrada brevemente. El código de los ejemplos está escrito en la tabla de declaración de Lua. Para obtener más información sobre el formato, consulte la sección sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">integración de Lua</a> . En esencia, el formato está diseñado para que una clase especial lo analice y los convierta en árboles de instancias de módulos de ruido. Prefiero esto el formato es más detallado paso a paso en formato C ++, porque es más compacto y limpio. En mi opinión, el código fuente es más legible y comprimido que el código C ++. En su mayor parte, las declaraciones son fáciles de leer y comprender. Los módulos tienen nombres, las fuentes se especifican  nombre o valor. El código Lua utilizado para analizar las declaraciones de la tabla se incluye en el código fuente en caso de que desee utilizar estas declaraciones directamente). <br><br>  En el caso de 2D, la función Gradient recibe un segmento de línea recta en la forma (x1, x2, y1, y2), y en el caso de 3D, el formato se expande a (x1, x2, y1, y2, z1, z2).  El punto formado por (x1, y1) denota el comienzo del segmento de línea asociado con 0. El punto formado (x2, y2) es el final del segmento asociado con 1. Es decir, aquí mapeamos el segmento de línea (0,1) -&gt; ( 0,0) con un gradiente.  Por lo tanto, el gradiente estará entre las regiones de la función Y = 1 e Y = 0.  Es decir, esta tira forma las dimensiones del mundo en Y. Cualquier parte del mundo estará en esta tira.  Podemos ajustar cualquier región a lo largo de X (casi hasta el infinito, pero aquí la precisión <code>double</code> nos limita), pero todo es interesante, es decir.  La superficie de la tierra estará dentro de esta banda.  Este comportamiento se puede cambiar, pero dentro de él tenemos un gran grado de flexibilidad.  Simplemente no olvide que los valores que están por encima o por debajo de esta banda tienen más probabilidades de no ser interesantes, ya que los valores anteriores tienen más probabilidades de ser aire, y los valores de abajo son tierra.  (Como pronto verá, esta afirmación puede resultar errónea). Para la mayoría de las imágenes de esta serie, coincidiré con la región cuadrada dada por el cuadrado (0,1) -&gt; (1,0) en el espacio 2D.  Por lo tanto, al principio nuestro mundo se ve así: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f6/09d/543/5f609d54326fa4c746b5b391b1f75c6a.jpg"></div><br>  Nada interesante hasta ahora;  Además, esta imagen no responde a la pregunta "¿el punto dado es sólido o hueco?".  Para responder a esta pregunta, necesitamos aplicar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">función de paso</a> (función definida por partes).  En lugar de un gradiente suave, necesitamos una separación clara, en la que todas las ubicaciones de un lado sean huecas y todas las ubicaciones del otro lado sean sólidas.  En <b>ANL,</b> esto se puede implementar usando la función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Seleccionar</a> .  La función Seleccionar recibe dos funciones o valores entrantes (en este caso serán iguales a "sólido" y "Hueco" (Abierto)), y los selecciona en función del valor de la función de control (en este caso, Gradiente).  El módulo Seleccionar tiene dos parámetros adicionales, <b>umbral</b> y <b>caída</b> , que afectan este proceso.  En esta etapa, la <b>caída no es</b> deseable, por lo que la estableceremos en 0. El parámetro <b>umbral</b> decide a dónde irá la línea divisoria entre Sólido y Abierto.  Todo lo que sea mayor que este valor en la función Gradiente se convertirá en Sólido, y todo lo que sea menor que el umbral se abrirá.  Como Gradient compara el intervalo con valores de 0 y 1, sería lógico colocar el umbral en 0.5.  Entonces dividimos el espacio exactamente por la mitad.  El valor 1 será una ubicación sólida y el valor 0 será hueco.  Es decir, definimos la función del plano terrestre de la siguiente manera: <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_select", type = "select", low = 0, high = 1, umbral = 0.5, control = "ground_gradient"}
 }
</pre><br>  Al comparar la misma área de la función que antes, obtenemos algo similar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35a/d9c/4b5/35ad9c4b583840222252f7c136ba983a.jpg"></div><br>  Esta imagen responde claramente a la pregunta de si el punto dado es sólido o hueco.  Podemos llamar a la función con cualquier coordenada posible del espacio 2D, y su resultado será 1 o 0, dependiendo de dónde esté el punto en relación con la superficie de la tierra.  Sin embargo, tal función no es particularmente interesante, es solo una línea plana que se extiende hasta el infinito.  Para revivir la imagen, utilizamos una técnica llamada "turbulencia". <br><br>  La “turbulencia” es una designación compleja del concepto de agregar valores a las coordenadas entrantes de una función.  Imagine que llamamos a la función anterior de la tierra con la coordenada (0,1).  Se encuentra sobre el plano del suelo, porque en Y = 1 el gradiente tiene un valor de 0, que es menor que el umbral = 0.5.  Es decir, este punto se calculará como Abierto.  Pero, ¿qué pasa si, antes de invocar la función de la tierra, de alguna manera transformamos este punto?  Supongamos que restamos un valor aleatorio de la coordenada Y, por ejemplo, 3. Restamos 3 y obtenemos la coordenada (0, -2).  Si ahora llamamos a la función base para este punto, entonces el punto se considerará sólido, porque Y = -2 se encuentra debajo del segmento Gradiente correspondiente a 1. De repente, el punto hueco (0,1) se convierte en un sólido.  Obtendremos un bloque de piedra sólida que cuelga en el aire.  Esto se puede hacer con cualquier punto de la función sumando o restando un número aleatorio de la coordenada Y del punto entrante antes de llamar a la función ground_select.  Aquí hay una imagen de la función ground_select que muestra esto.  Antes de llamar a la función ground_select, el valor en el intervalo (-0.25, 0.25) se agrega a la coordenada Y de cada punto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f28/273/32e/f2827332ed068acf376b4b6cfbf0853d.jpg"></div><br>  Esto es más interesante que una línea plana, pero no muy similar a la tierra, porque cada punto se mueve a un valor completamente aleatorio, lo que crea un patrón caótico.  Sin embargo, si usamos una función aleatoria continua, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fractal</a> de la biblioteca <b>ANL</b> , entonces, en lugar de un patrón aleatorio, obtenemos algo más controlable.  Por lo tanto, conectemos un fractal al plano de la tierra y veamos qué sucede. <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, frecuencia = 2},
	 {name = "ground_scale", type = "scaleoffset", scale = 0.5, offset = 0, source = "ground_shape_fractal"},
	 {name = "ground_perturb", type = "translateomain", source = "ground_gradient", ty = "ground_scale"},<font></font>
	<font></font>
	 {name = "ground_select", type = "select", low = 0, high = 1, umbral = 0.5, control = "ground_perturb"}
 }
</pre><br>  Aquí vale la pena señalar un par de aspectos.  Primero, definimos el módulo Fractal y lo encadenamos al módulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ScaleOffset</a> .  El módulo ScaleOffset escala los valores fractales de salida a un nivel más conveniente.  Parte del relieve puede ser montañoso y requerir una escala mayor, y otra parte más plana y con una escala menor.  Hablaremos sobre diferentes tipos de terreno más adelante, pero por ahora los usaremos para demostración.  Los valores de salida de la función ahora darán la siguiente imagen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ca/56e/b55/8ca56eb55e7febec86f3dd80fcea2d0e.jpg"></div><br>  Esto es más interesante que solo ruido aleatorio, ¿verdad?  Al menos, se parece más a la tierra, aunque parte del paisaje parece inusual, y las islas voladoras son completamente extrañas.  La razón de esto fue que cada punto individual del mapa de salida se desplaza aleatoriamente por un valor diferente determinado por el fractal.  Para ilustrar esto, muestre la salida fractal que realiza la distorsión: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbd/67d/b62/fbd67db6235a14fdf6d734d2ac73f560.jpg"></div><br>  En la imagen de arriba, todos los puntos negros tienen un valor de -0.25, y todos los puntos blancos tienen un valor de 0.25.  Es decir, donde el fractal es negro, el punto correspondiente de la función de la Tierra se desplazará "hacia abajo" en 0.25.  (0.25 significa 1/4 de la pantalla.) Dado que un punto puede desplazarse ligeramente, y el otro punto sobre él en el espacio puede desplazarse más, existe la posibilidad de protuberancias de rocas e islas voladoras.  Las protuberancias en la naturaleza son bastante naturales, en contraste con las islas voladoras.  (A menos que estemos en la película "Avatar"). Si tu juego necesita un paisaje tan fantástico, es genial, pero si necesitas un modelo más realista, necesitamos ajustar un poco la función fractal.  Afortunadamente, la función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ScaleDomain</a> puede hacer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esto</a> . <br><br>  Queremos que la función se comporte como una función de mapa de altura.  Imagine un mapa de altura 2D en el que cada punto del mapa representa la altura de un punto en la cuadrícula de puntos de cuadrícula que se elevan hacia arriba o hacia abajo.  Los valores blancos del mapa indican colinas altas, negro - valles bajos.  Necesitamos un comportamiento similar, pero para lograrlo, necesitamos deshacernos esencialmente de una de las dimensiones.  En el caso de un mapa de altura, creamos una elevación 3D a partir de un mapa de altura 2D.  Del mismo modo, en el caso del terreno 2D, necesitamos un mapa de altura 1D.  Después de hacer que todos los puntos de un fractal con la misma coordenada Y tengan el mismo valor, podemos cambiar todos los puntos con la misma coordenada X en la misma cantidad, por lo que las islas voladoras desaparecen.  Para hacer esto, puede usar ScaleDomain, restableciendo el coeficiente de escala.  Es decir, antes de llamar a la función ground_shape_fractal, llamamos a ground_scale_y para establecer la coordenada y en 0. Esto asegura que el valor Y no afecte la salida del fractal, esencialmente convirtiéndolo en una función de ruido 1D.  Para hacer esto, haremos los siguientes cambios: <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, frecuencia = 2},
	 {name = "ground_scale", type = "scaleoffset", scale = 0.5, offset = 0, source = "ground_shape_fractal"},
	 {name = "ground_scale_y", type = "scaledomain", source = "ground_scale", scaley = 0},
	 {name = "ground_perturb", type = "translateomain", source = "ground_gradient", ty = "ground_scale_y"},<font></font>
	<font></font>
	 {name = "ground_select", type = "select", low = 0, high = 1, umbral = 0.5, control = "ground_perturb"}
 }
</pre><br>  Encadenaremos la función ScaleDomain con ground_scale y luego modificaremos los datos originales ground_perturb para que sean una función ScaleDomain.  Esto cambiará el fractal que desplaza la tierra y la convierte en algo así: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca7/e79/4dc/ca7e794dc19c6922c6278cfdf3437caf.jpg"></div><br>  Ahora, si echamos un vistazo a la salida, obtenemos el resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb2/31a/5d6/bb231a5d6c2e0cfb1f8181ba6de1dc61.jpg"></div><br>  Mucho mejor  Las islas voladoras han desaparecido por completo, y el relieve es más parecido a montañas y colinas.  Desafortunadamente, perdimos salientes y acantilados.  Ahora toda la tierra es continua e inclinada.  Si lo desea, puede arreglar esto de varias maneras. <br><br>  Primero, puede usar otra función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TranslateDomain</a> , junto con otra función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fractal</a> .  Si aplicamos una pequeña cantidad de turbulencia fractal a la dirección X, podemos distorsionar ligeramente los bordes y las superficies de las montañas, y esto probablemente será suficiente para formar precipicios y salientes.  Miremos en acción. <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, frecuencia = 2},
	 {name = "ground_scale", type = "scaleoffset", scale = 0.5, offset = 0, source = "ground_shape_fractal"},
	 {name = "ground_scale_y", type = "scaledomain", source = "ground_scale", scaley = 0},
	 {name = "ground_perturb", type = "translateomain", source = "ground_gradient", ty = "ground_scale_y"},
	 {name = "ground_overhang_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octavas = 6, frecuencia = 2},
	 {name = "ground_overhang_scale", type = "scaleoffset", source = "ground_overhang_fractal", scale = 0.2, offset = 0},
	 {name = "ground_overhang_perturb", type = "translateomain", source = "ground_perturb", tx = "ground_overhang_scale"},<font></font>
	<font></font>
	 {name = "ground_select", type = "select", low = 0, high = 1, umbral = 0.5, control = "ground_overhang_perturb"}
 }
</pre><br>  Y aquí está el resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c3/09f/c4e/4c309fc4e22125fa2083d5bf33e4dc20.jpg"></div><br>  La segunda forma: simplemente puede establecer el parámetro de <b>escala de la</b> función <b>ground_scale_y</b> <b>en un</b> valor mayor que 0. Si deja una escala pequeña en Y, obtendremos una fracción de la variabilidad, sin embargo, cuanto mayor sea la escala, más fuerte será el relieve que se asemejará a la versión anterior sin escala. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/225/f3f/746/225f3f7462f1c78bb48a3603363643aa.jpg"></div><br>  Los resultados parecen mucho más interesantes que las montañas en pendiente ordinarias.  Sin embargo, no importa cuán interesantes sean, el jugador aún se aburrirá de explorar el relieve con el mismo patrón, extendiéndose por muchos kilómetros.  Además, tal alivio sería muy poco realista.  En el mundo real, hay mucha variabilidad que hace que el terreno sea más interesante.  Veamos qué se puede hacer para hacer que el mundo sea más diverso. <br><br>  Mirando el ejemplo de código anterior, puede ver un patrón específico en él.  Tenemos una función de gradiente, que es controlada por funciones que le dan forma a la tierra, después de lo cual se aplica una función definida por partes y la tierra se llena.  Es decir, será más lógico complicar el alivio en la etapa de dar forma a la tierra.  En lugar de un fractal que se desplaza a lo largo de Y y otro que se desplaza a lo largo de X, podemos lograr el grado de complejidad requerido (teniendo en cuenta el rendimiento: cada fractal requiere costos computacionales adicionales, por lo que debemos tratar de ser conservadores). Podemos especificar las formas de la tierra, que son montañas, estribaciones , tierras bajas planas, tierras baldías, etc., y use la salida de las diversas funciones de selección encadenadas con fractales de baja frecuencia para delinear áreas de cada tipo.  Entonces, veamos cómo puede implementar diferentes tipos de terreno. <br><br>  Para ilustrar el principio, distinguimos tres tipos de relieve: mesetas (colinas de pendiente suave), montañas y tierras bajas (en su mayoría planas).  Para cambiar entre ellos, utilizamos un sistema basado en selección y los combinamos en un lienzo complejo.  Así que aquí vamos ... <br><br>  <b>Estribaciones:</b> <br><br>  Con ellos, todo es simple.  Podemos tomar el esquema utilizado anteriormente, reducir ligeramente la amplitud de las colinas, tal vez incluso hacerlas más sustractivas que aditivas.  para bajar las alturas medias.  También podemos reducir el recuento de octavas para suavizarlas. <br><br><pre> {name = "lowland_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 2, frecuencia = 1},
 {name = "lowland_autocorrect", type = "autocorrect", source = "lowland_shape_fractal", low = 0, high = 1},
 {name = "lowland_scale", type = "scaleoffset", source = "lowland_autocorrect", scale = 0.2, offset = -0.25},
 {name = "lowland_y_scale", type = "scaledomain", source = "lowland_scale", scaley = 0},
 {name = "lowland_terrain", type = "translateomain", source = "ground_gradient", ty = "lowland_y_scale"},
</pre><br>  <b>Tierras altas:</b> <br><br>  Con ellos, también, todo es simple.  (De hecho, ninguno de estos tipos de terreno es difícil). Sin embargo, utilizamos una base diferente para hacer que las colinas se vean como dunas. <br><br><pre> {name = "highland_shape_fractal", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octavas = 2, frecuencia = 2},
 {name = "highland_autocorrect", type = "autocorrect", source = "highland_shape_fractal", low = 0, high = 1},
 {name = "highland_scale", type = "scaleoffset", source = "highland_autocorrect", scale = 0.45, offset = 0},
 {name = "highland_y_scale", type = "scaledomain", source = "highland_scale", scaley = 0},
 {name = "highland_terrain", type = "translateomain", source = "ground_gradient", ty = "highland_y_scale"},
</pre><br>  <b>Montañas:</b> <br><br><pre> {name = "mountain_shape_fractal", type = "fractal", fractaltype = anl.BILLOW, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 4, frecuencia = 1},
 {name = "mountain_autocorrect", type = "autocorrect", source = "mountain_shape_fractal", low = 0, high = 1},
 {name = "mountain_scale", type = "scaleoffset", source = "mountain_autocorrect", scale = 0.75, offset = 0.25},
 {name = "mountain_y_scale", type = "scaledomain", source = "mountain_scale", scaley = 0.1},
 {name = "mountain_terrain", type = "translateomain", source = "ground_gradient", ty = "mountain_y_scale"},
</pre><br>  Por supuesto, puede abordar este proceso de manera aún más creativa, pero en general el patrón será así.  Destacamos las características del tipo de relieve y seleccionamos funciones de ruido para ellos.  Para todo esto, se aplican los mismos principios;  Las principales diferencias son la escala.  Ahora, para conectarlos, prepararemos fractales adicionales que controlarán la función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Seleccionar</a> .  Luego, encadenamos los módulos Select para generar todo el terreno. <br><br><pre> {nombre = "terreno_tipo_fractal", tipo = "fractal", fractaltipo = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octavas = 3, frecuencia = 0.5},
 {nombre = "terreno_autocorrección", tipo = "autocorrección", fuente = "terreno_tipo_fractal", bajo = 0, alto = 1},
 {nombre = "terrenos_tipo_caché", tipo = "caché", fuente = "relieve_autocorrección"},
 {name = "highland_mountain_select", type = "select", low = "highland_terrain", high = "mountain_terrain", control = "terrenos_tipo_caché", umbral = 0.55, caída = 0.15},
 {name = "highland_lowland_select", type = "select", low = "lowland_terrain", high = "highland_mountain_select", control = "terrenos_tipo_caché", umbral = 0.25, caída = 0.15},
</pre><br>  Entonces, aquí definimos tres tipos principales de terreno: tierras bajas, tierras altas y montañas.  Usamos un fractal para seleccionar uno de ellos, de modo que haya transiciones naturales (tierras bajas-&gt; tierras altas-&gt; montañas).  Luego usamos otro fractal para insertar aleatoriamente tierras baldías en el mapa.  Así es como se ve la cadena de módulos terminada: <br><br><pre> terraintree =
 {
	 {name = "lowland_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 2, frecuencia = 1},
	 {name = "lowland_autocorrect", type = "autocorrect", source = "lowland_shape_fractal", low = 0, high = 1},
	 {name = "lowland_scale", type = "scaleoffset", source = "lowland_autocorrect", scale = 0.2, offset = -0.25},
	 {name = "lowland_y_scale", type = "scaledomain", source = "lowland_scale", scaley = 0},
	 {name = "lowland_terrain", type = "translateomain", source = "ground_gradient", ty = "lowland_y_scale"},
	 {name = "ground_gradient", type = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "highland_shape_fractal", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octavas = 2, frecuencia = 2},
	 {name = "highland_autocorrect", type = "autocorrect", source = "highland_shape_fractal", low = 0, high = 1},
	 {name = "highland_scale", type = "scaleoffset", source = "highland_autocorrect", scale = 0.45, offset = 0},
	 {name = "highland_y_scale", type = "scaledomain", source = "highland_scale", scaley = 0},
	 {name = "highland_terrain", type = "translateomain", source = "ground_gradient", ty = "highland_y_scale"},<font></font>
<font></font>
	 {name = "mountain_shape_fractal", type = "fractal", fractaltype = anl.BILLOW, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 4, frecuencia = 1},
	 {name = "mountain_autocorrect", type = "autocorrect", source = "mountain_shape_fractal", low = 0, high = 1},
	 {name = "mountain_scale", type = "scaleoffset", source = "mountain_autocorrect", scale = 0.75, offset = 0.25},
	 {name = "mountain_y_scale", type = "scaledomain", source = "mountain_scale", scaley = 0.1},
	 {name = "mountain_terrain", type = "translateomain", source = "ground_gradient", ty = "mountain_y_scale"},<font></font>
<font></font>
	 {nombre = "terreno_tipo_fractal", tipo = "fractal", fractaltipo = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octavas = 3, frecuencia = 0.5},
	 {nombre = "terreno_autocorrección", tipo = "autocorrección", fuente = "terreno_tipo_fractal", bajo = 0, alto = 1},
	 {nombre = "terrenos_tipo_caché", tipo = "caché", fuente = "relieve_autocorrección"},
	 {name = "highland_mountain_select", type = "select", low = "highland_terrain", high = "mountain_terrain", control = "terrenos_tipo_caché", umbral = 0.55, caída = 0.15},
	 {name = "highland_lowland_select", type = "select", low = "lowland_terrain", high = "highland_mountain_select", control = "terrenos_tipo_caché", umbral = 0.25, caída = 0.15},
	 {name = "ground_select", type = "select", low = 0, high = 1, umbral = 0.5, control = "highland_lowland_select"}
 }
</pre><br>  Aquí hay algunos ejemplos de los relieves resultantes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/60f/afe/4c460fafe39eec4680ac6eb3c341beef.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/241/869/9c8241869337938b628d0b9a53a3e756.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/538/67a/f3a/53867af3a00abb26d5b0f32f5f728694.jpg"></div><br>  Puede notar que se obtiene una variabilidad bastante alta.  En algunos lugares, aparecen elevadas montañas rotas, en otros hay llanuras de pendiente suave.  Ahora necesitamos agregar cuevas para poder explorar las maravillas del inframundo. <br><br>  Para las cuevas, uso el sistema multiplicativo aplicado a <b>ground_select</b> .  Es decir, creo una función que genera 1 o 0, y las multiplico por la salida de <b>ground_select</b> .  Gracias a esto, cualquier punto de la función se vuelve hueco para el cual el valor de la función de las cuevas es 0. Es decir, donde quiero obtener la cueva, la función de las cuevas debería devolver 0, y donde la cueva no debería estar, la función debería ser 1. En cuanto a la forma cuevas, quiero establecer un sistema de cuevas basado en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Multifractal Ridged de</a> 1 octava. <br><br><pre> {name = "cave_shape", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 1, frecuencia = 2},
</pre><br>  El resultado es algo como esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31c/bf0/297/31cbf02975f1852907bb3a0f24ffd43a.jpg"></div><br>  Si aplicamos la función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Seleccionar</a> como una función definida por partes, como lo hicimos con el gradiente de tierra, implementándola de modo que la parte inferior del umbral de selección sea 1 (no hay cueva), y la parte superior es 0 (hay una cueva), el resultado se verá más o menos así : <br><br><pre> {name = "cave_shape", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 1, frecuencia = 2},
 {name = "cave_select", type = "select", low = 1, high = 0, control = "cave_shape", umbral = 0.8, caída = 0},
</pre><br>  Resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d8/55a/c47/1d855ac477dd48ba59d20ed30d89bde6.jpg"></div><br>  Por supuesto, se ve bastante suave, así que agrega un poco de ruido fractal para distorsionar el área. <br><br><pre> {name = "cave_shape", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 1, frecuencia = 2},
 {name = "cave_select", type = "select", low = 1, high = 0, control = "cave_shape", umbral = 0.8, caída = 0},
 {name = "cave_perturb_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, frecuencia = 3},
 {name = "cave_perturb_scale", type = "scaleoffset", source = "cave_perturb_fractal", scale = 0.25, offset = 0},<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{name = "cave_perturb", type = "translateomain", source = "cave_select", tx = "cave_perturb_scale"},</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resultado: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ec/deb/4fa/0ecdeb4faf32eea11c05a7a76b7c6225.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto hace que las cuevas sean un poco ruidosas y que no sean tan suaves. </font><font style="vertical-align: inherit;">Veamos ahora qué sucede si aplicas las cuevas al relieve:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d34/974/278/d34974278435e239ad7eb9193adc9672.jpg"></div><br><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">Al</font></b><font style="vertical-align: inherit;"> experimentar con el valor </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">umbral</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , podemos hacer que las cuevas sean más delgadas o más gruesas. Pero lo principal que debemos intentar es asegurarnos de que las cuevas no carcoman esos enormes fragmentos del relieve superficial. Para hacer esto, podemos volver a la función </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highland_lowland_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que, como recordamos, es la última función de alivio que distorsiona el gradiente de la tierra. Lo que es útil en esta función es que sigue siendo un gradiente, lo que aumenta el valor cuando la función se profundiza en el suelo. Podemos usar el gradiente para debilitar la función de las cuevas para que las cuevas aumenten a medida que se adentran en el suelo. Afortunadamente para nosotros, esta atenuación se puede lograr simplemente multiplicando la salida de la función </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highland_lowland_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la salida de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_shape</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y luego pasa el resultado al resto de la cadena de funciones. A continuación, haremos un cambio importante aquí: agregue la función </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caché</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La función de almacenamiento en caché guarda el resultado de la función para la coordenada entrante dada, y si la función se llama repetidamente con la misma coordenada, devolverá la copia en caché y no calculará el resultado nuevamente. Esto es útil en situaciones donde una función compleja ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highland_lowland_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) en una cadena de funciones se llama varias veces. Sin un caché, la cadena completa de una función compleja se recalcula con cada llamada. Para agregar el caché, primero debemos hacer los siguientes cambios:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{name = "highland_lowland_select", type = "select", low = "lowland_terrain", high = "highland_mountain_select", control = "terrenos_tipo_caché", umbral = 0.25, caída = 0.15},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{name = "highland_lowland_select_cache", type = "cache", source = "highland_lowland_select"},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{name = "ground_select", type = "select", low = 0, high = 1, umbral = 0.5, control = "highland_lowland_select_cache"},</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, agregamos Cache y luego redirigimos la entrada a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ground_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que se tomara del caché y no directamente de la función. </font><font style="vertical-align: inherit;">Luego podemos cambiar el código de las cuevas para agregar atenuación:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{name = "cave_shape", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 1, frecuencia = 4},</font></font><font></font>
{name="cave_attenuate_bias", type="bias", source="highland_lowland_select_cache", bias=0.45},<font></font>
{name="cave_shape_attenuate", type="combiner", operation=anl.MULT, source_0="cave_shape", source_1="cave_attenuate_bias"},<font></font>
{name="cave_perturb_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=6, frequency=3},<font></font>
{name="cave_perturb_scale", type="scaleoffset", source="cave_perturb_fractal", scale=0.5, offset=0},<font></font>
{name="cave_perturb", type="translatedomain", source="cave_shape_attenuate", tx="cave_perturb_scale"},<font></font>
{name="cave_select", type="select", low=1, high=0, control="cave_perturb", threshold=0.48, falloff=0},<font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En primer lugar, agregamos la función </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bias</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esto es por conveniencia, porque nos permite ajustar el intervalo de la función de atenuación de gradiente. Luego se </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agrega la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> función </font><b><font style="vertical-align: inherit;">cave_shape_attenuate</font></b><font style="vertical-align: inherit;"> , que es un </font><b><font style="vertical-align: inherit;">Combinador </font></b></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tipo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anl :: MULT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ella multiplica el gradiente por </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_shape</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Luego, el resultado de esta operación se pasa a la función </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_perturb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El resultado se parece a esto:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f8/55d/fd3/8f855dfd376c5d8049a075d28066f72c.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vemos que más cerca de la superficie de la tierra se han vuelto más delgados. </font><font style="vertical-align: inherit;">(No preste atención a la parte superior, esto es solo un artefacto de valores de gradiente negativos, no afecta a las cuevas terminadas. Si esto se convierte en un problema, digamos que si usamos esta función para otra cosa, entonces podemos limitar el gradiente al intervalo (0, 1).) Es un poco difícil ver cómo funciona esto en relación con el terreno, así que avancemos y organicemos todo para ver qué sucede. </font><font style="vertical-align: inherit;">Aquí está toda la cadena de funciones que hemos creado hasta ahora.</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terraintree =
</font></font> {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "ground_gradient", type = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1},</font></font><font></font>
	<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "lowland_shape_fractal", type = "fractal", fractaltype = anl.BILLOW, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 2, frecuencia = 0.25},</font></font><font></font>
	{name="lowland_autocorrect", type="autocorrect", source="lowland_shape_fractal", low=0, high=1},<font></font>
	{name="lowland_scale", type="scaleoffset", source="lowland_autocorrect", scale=0.125, offset=-0.45},<font></font>
	{name="lowland_y_scale", type="scaledomain", source="lowland_scale", scaley=0},<font></font>
	{name="lowland_terrain", type="translatedomain", source="ground_gradient", ty="lowland_y_scale"},<font></font>
	<font></font>
	{name="highland_shape_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=4, frequency=2},<font></font>
	{name="highland_autocorrect", type="autocorrect", source="highland_shape_fractal", low=-1, high=1},<font></font>
	{name="highland_scale", type="scaleoffset", source="highland_autocorrect", scale=0.25, offset=0},<font></font>
	{name="highland_y_scale", type="scaledomain", source="highland_scale", scaley=0},<font></font>
	{name="highland_terrain", type="translatedomain", source="ground_gradient", ty="highland_y_scale"},<font></font>
<font></font>
	{name="mountain_shape_fractal", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=8, frequency=1},<font></font>
	{name="mountain_autocorrect", type="autocorrect", source="mountain_shape_fractal", low=-1, high=1},<font></font>
	{name="mountain_scale", type="scaleoffset", source="mountain_autocorrect", scale=0.45, offset=0.15},<font></font>
	{name="mountain_y_scale", type="scaledomain", source="mountain_scale", scaley=0.25},<font></font>
	{name="mountain_terrain", type="translatedomain", source="ground_gradient", ty="mountain_y_scale"},<font></font>
<font></font>
	{name="terrain_type_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=3, frequency=0.125},<font></font>
	{name="terrain_autocorrect", type="autocorrect", source="terrain_type_fractal", low=0, high=1},<font></font>
	{name="terrain_type_y_scale", type="scaledomain", source="terrain_autocorrect", scaley=0},<font></font>
	{name="terrain_type_cache", type="cache", source="terrain_type_y_scale"},<font></font>
	{name="highland_mountain_select", type="select", low="highland_terrain", high="mountain_terrain", control="terrain_type_cache", threshold=0.55, falloff=0.2},<font></font>
	{name="highland_lowland_select", type="select", low="lowland_terrain", high="highland_mountain_select", control="terrain_type_cache", threshold=0.25, falloff=0.15},<font></font>
	{name="highland_lowland_select_cache", type="cache", source="highland_lowland_select"},<font></font>
	{name="ground_select", type="select", low=0, high=1, threshold=0.5, control="highland_lowland_select_cache"},<font></font>
	<font></font>
	{name="cave_shape", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
	{name="cave_attenuate_bias", type="bias", source="highland_lowland_select_cache", bias=0.45},<font></font>
	{name="cave_shape_attenuate", type="combiner", operation=anl.MULT, source_0="cave_shape", source_1="cave_attenuate_bias"},<font></font>
	{name="cave_perturb_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=6, frequency=3},<font></font>
	{name="cave_perturb_scale", type="scaleoffset", source="cave_perturb_fractal", scale=0.5, offset=0},<font></font>
	{name="cave_perturb", type="translatedomain", source="cave_shape_attenuate", tx="cave_perturb_scale"},<font></font>
	{name="cave_select", type="select", low=1, high=0, control="cave_perturb", threshold=0.48, falloff=0},<font></font>
	<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "ground_cave_multiply", type = "combiner", operation = anl.MULT, source_0 = "cave_select", source_1 = "ground_select"}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aquí hay ejemplos de tarjetas aleatorias derivadas de esta función: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f8/1a5/ca8/9f81a5ca8f1b739c03721b6a5ba280a5.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c86/5ec/b69/c865ecb69a1701a1b757535f289c6c0a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a82/332/1e3/a823321e389de00947e695424497f2e9.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora todo se ve bastante bien. Todas las cuevas son cavernas bastante grandes en las profundidades del subsuelo, pero más cerca de la superficie generalmente se convierten en pequeños túneles. Esto ayuda a crear una atmósfera de misterio. Al explorar la superficie, encontrarás una pequeña entrada a la cueva. ¿A dónde va ella? ¿Qué tan profundo se extiende? No podemos saber esto, pero en el proceso de estudio comienza a expandirse, convirtiéndose en un extenso sistema de cavernas llenas de oscuridad y peligros. Y botín, por supuesto. Siempre hay mucho botín. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede cambiar este sistema de muchas maneras diferentes, obteniendo resultados diferentes. Podemos cambiar los parámetros de umbral para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y los parámetros para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_attenuate_bias</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o reemplazar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_attenuate_bias</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">otras funciones para hacer coincidir el intervalo de gradiente con otros valores que se adapten mejor a sus necesidades. También puede agregar otro fractal que distorsiona el sistema de cuevas a lo largo del eje Y para eliminar la posibilidad de túneles anormalmente lisos a lo largo del eje X (causado por el hecho de que la forma de la cueva se distorsiona solo a lo largo del eje X). También puede agregar un nuevo fractal como fuente adicional de atenuación, especificar una tercera fuente para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_shape_attenuate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que escala la atenuación en función de las regiones, de modo que las cuevas en algunas áreas sean más densas (por ejemplo, en las montañas), y con menos frecuencia o completamente ausentes en otras. Esta selección regional se puede crear desde la función del </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terreno_tipo_fractal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para saber dónde se encuentran las zonas de montaña. </font><font style="vertical-align: inherit;">Todo se reduce a solo pensar en lo que desea, descubrir qué efecto tendrán las diferentes funciones en la salida y experimentar con los parámetros hasta obtener el resultado deseado. </font><font style="vertical-align: inherit;">Esta no es una ciencia exacta y, a menudo, el efecto deseado se puede alcanzar de diferentes maneras.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Desventajas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este método de generación de terreno tiene desventajas. </font><font style="vertical-align: inherit;">El proceso de generación de ruido puede ser bastante lento. </font><font style="vertical-align: inherit;">Es importante reducir la cantidad de fractales, la cantidad de octavas de esos fractales que usa y otras operaciones lentas, si es posible. </font><font style="vertical-align: inherit;">Intente usar fractales varias veces y guarde en caché todas las funciones que se llaman varias veces. </font><font style="vertical-align: inherit;">En este ejemplo, utilicé libremente fractales, creando uno para cada uno de los tres tipos de relieve. </font><font style="vertical-align: inherit;">Usando </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScaleOffset</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para cambiar los intervalos y tomando un fractal como base para todos ellos, ahorraría mucho tiempo de procesador. </font><font style="vertical-align: inherit;">En 2D, no todo es tan malo, pero cuando llegas a 3D e intentas comparar las cantidades de datos, el tiempo de procesamiento aumentará significativamente.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ir a 3D </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo esto es genial si creas un juego como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terraria</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">King Arthur's Gold</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero ¿qué </font><font style="vertical-align: inherit;">pasa si </font><font style="vertical-align: inherit;">necesitas algo como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minecraft</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infiniminer?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? ¿Qué cambios necesitaremos hacer en la cadena de funciones? De hecho, no hay muchos. La función que se muestra arriba funcionará casi sin modificaciones para el relieve 3D. Será suficiente para que compare el volumen 3D utilizando las variaciones 3D del generador, y también para comparar el eje Y con el eje vertical del volumen, y no con la región 2D. Sin embargo, se requerirá un cambio, a saber, una forma de realizar las cuevas. Como viste, Ridged Multifractal es ideal para un sistema de cuevas 2D, pero en 3D corta muchas conchas curvas, no túneles, y su efecto resulta ser incorrecto. Es decir, en 3D es necesario especificar dos formas fractales de cuevas, ambas son ruido Multifractal Ridged de 1 octava, pero con semillas diferentes. Con Seleccionar, configúrelos en 1 o 0 y multiplíquelos. Por lo tanto, en la intersección de los fractales, aparecerá una cueva,y todo lo demás permanecerá sólido, y la apariencia de los túneles se volverá más natural que usar un solo fractal.</font></font><br><br><pre>terraintree3d=
 {<font></font>
	{name="ground_gradient", type="gradient", x1=0, x2=0, y1=0, y2=1},<font></font>
	<font></font>
	{name="lowland_shape_fractal", type="fractal", fractaltype=anl.BILLOW, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=2, frequency=0.25},<font></font>
	{name="lowland_autocorrect", type="autocorrect", source="lowland_shape_fractal", low=0, high=1},<font></font>
	{name="lowland_scale", type="scaleoffset", source="lowland_autocorrect", scale=0.125, offset=-0.45},<font></font>
	{name="lowland_y_scale", type="scaledomain", source="lowland_scale", scaley=0},<font></font>
	{name="lowland_terrain", type="translatedomain", source="ground_gradient", ty="lowland_y_scale"},<font></font>
	<font></font>
	{name="highland_shape_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=4, frequency=2},<font></font>
	{name="highland_autocorrect", type="autocorrect", source="highland_shape_fractal", low=-1, high=1},<font></font>
	{name="highland_scale", type="scaleoffset", source="highland_autocorrect", scale=0.25, offset=0},<font></font>
	{name="highland_y_scale", type="scaledomain", source="highland_scale", scaley=0},<font></font>
	{name="highland_terrain", type="translatedomain", source="ground_gradient", ty="highland_y_scale"},<font></font>
<font></font>
	{name="mountain_shape_fractal", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=8, frequency=1},<font></font>
	{name="mountain_autocorrect", type="autocorrect", source="mountain_shape_fractal", low=-1, high=1},<font></font>
	{name="mountain_scale", type="scaleoffset", source="mountain_autocorrect", scale=0.45, offset=0.15},<font></font>
	{name="mountain_y_scale", type="scaledomain", source="mountain_scale", scaley=0.25},<font></font>
	{name="mountain_terrain", type="translatedomain", source="ground_gradient", ty="mountain_y_scale"},<font></font>
<font></font>
	{name="terrain_type_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=3, frequency=0.125},<font></font>
	{name="terrain_autocorrect", type="autocorrect", source="terrain_type_fractal", low=0, high=1},<font></font>
	{name="terrain_type_y_scale", type="scaledomain", source="terrain_autocorrect", scaley=0},<font></font>
	{name="terrain_type_cache", type="cache", source="terrain_type_y_scale"},<font></font>
	{name="highland_mountain_select", type="select", low="highland_terrain", high="mountain_terrain", control="terrain_type_cache", threshold=0.55, falloff=0.2},<font></font>
	{name="highland_lowland_select", type="select", low="lowland_terrain", high="highland_mountain_select", control="terrain_type_cache", threshold=0.25, falloff=0.15},<font></font>
	{name="highland_lowland_select_cache", type="cache", source="highland_lowland_select"},<font></font>
	{name="ground_select", type="select", low=0, high=1, threshold=0.5, control="highland_lowland_select_cache"},<font></font>
	<font></font>
	{name="cave_attenuate_bias", type="bias", source="highland_lowland_select_cache", bias=0.45},<font></font>
	{name="cave_shape1", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
	{name="cave_shape2", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
	{name="cave_shape_attenuate", type="combiner", operation=anl.MULT, source_0="cave_shape1", source_1="cave_attenuate_bias", source_2="cave_shape2"},             <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "cave_perturb_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, frecuencia = 3},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "cave_perturb_scale", type = "scaleoffset", source = "cave_perturb_fractal", scale = 0.5, offset = 0},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "cave_perturb", type = "translateomain", source = "cave_shape_attenuate", tx = "cave_perturb_scale"},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "cave_select", type = "select", low = 1, high = 0, control = "cave_perturb", umbral = 0.48, falloff = 0},</font></font><font></font>
	<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "ground_cave_multiply", type = "combiner", operation = anl.MULT, source_0 = "cave_select", source_1 = "ground_select"}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ejemplos de resultados: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/484/3fa/8e9/4843fa8e95e46162345f36edcf767fbe.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b91/671/848/b91671848dac9a42f371d549adf07181.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece que algunas de las configuraciones requieren ajuste. </font><font style="vertical-align: inherit;">Puede valer la pena reducir la atenuación o hacer que las cuevas sean más delgadas, reduciendo el número de octavas en el fractal del relieve, para que el relieve se vuelva más suave, etc. ... Repito, todo depende del resultado que se desee obtener.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472574/">https://habr.com/ru/post/472574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472562/index.html">Tendencias financieras: las grandes empresas necesitan cada vez más profesionales de TI</a></li>
<li><a href="../472566/index.html">El infierno personal del escritor Fraerman, o el cuento del primer amor</a></li>
<li><a href="../472568/index.html">Despliegue Apache Ignite Zero: ¿exactamente cero?</a></li>
<li><a href="../472570/index.html">Intel Xeon W Big Update</a></li>
<li><a href="../472572/index.html">DevOps y el caos: entrega de software en un mundo descentralizado</a></li>
<li><a href="../472576/index.html">XVI conferencia de desarrolladores de software libre o dónde obtener contribuyentes gratuitos</a></li>
<li><a href="../472580/index.html">Gestión de servicios empresariales: por qué ampliar la gestión de servicios más allá de TI</a></li>
<li><a href="../472582/index.html">Historia de Internet: la computadora como dispositivo de comunicación</a></li>
<li><a href="../472586/index.html">Análisis de altavoz: qué hay dentro y cómo funciona</a></li>
<li><a href="../472588/index.html">Todo lo que quería saber sobre el péndulo inverso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>