<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÉüèø üèáüèø üíΩ Crea tu Minecraft: genera niveles 3D a partir de cubos üõµ üÜó üèí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En parte debido a la popularidad de Minecraft , recientemente ha habido un creciente inter√©s en la idea de un juego que tiene lugar en un mundo en cub...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crea tu Minecraft: genera niveles 3D a partir de cubos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472574/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/jj/va/ccjjvazyarduee258az9-bbggkq.png"></div><br>  En parte debido a la popularidad de <b>Minecraft</b> , recientemente ha habido un creciente inter√©s en la idea de un juego que tiene lugar en un mundo en cubos construido en relieve 3D y lleno de elementos como cuevas, acantilados, etc.  Tal mundo es una aplicaci√≥n ideal para el ruido generado al estilo de mi biblioteca <b>ANL</b> .  Este art√≠culo surgi√≥ de las discusiones de mis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">intentos</a> anteriores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de</a> implementar esta t√©cnica.  Desde entonces, han aparecido cambios menores en la estructura de la biblioteca. <br><br>  En publicaciones anteriores, habl√© sobre el uso de caracter√≠sticas de ruido 3D para implementar terrenos al estilo Minecraft.  Despu√©s de eso, la biblioteca evolucion√≥ un poco, as√≠ que decid√≠ volver a este tema.  Como tuve que responder muchas preguntas sobre este sistema, intentar√© hablar m√°s sobre los conceptos involucrados.  Para aclarar los conceptos b√°sicos, comenzar√© con la idea de generar un terreno 2D utilizado en juegos como Terraria y King Arthur's Gold, y luego expandir√© el sistema a ejemplos 3D como Minecraft.  Esto me permitir√° demostrar conceptos de manera m√°s efectiva utilizando im√°genes como ejemplo. <br><br>  Este sistema se desarroll√≥ teniendo en cuenta el siguiente objetivo abstracto: deber√≠amos poder pasar la coordenada de un determinado punto o celda al sistema y determinar qu√© tipo de bloque deber√≠a estar en esta ubicaci√≥n.  Queremos que el sistema sea una "caja negra": le pasamos un punto, devolvemos el tipo de bloque.  Por supuesto, esto se aplica solo a la generaci√≥n inicial del mundo.  Los bloqueos en dichos juegos pueden ser cambiados por las acciones del jugador, y ser√° inconveniente tratar de describir dichos cambios usando el mismo sistema.  Dichos cambios deben ser rastreados de alguna otra manera.  Este sistema genera el mundo original, pr√≠stino e intacto por las manos del jugador y otros personajes. <br><a name="habracut"></a><br>  Quiz√°s esta t√©cnica no sea adecuada para modelar sistemas como el c√©sped u otras entidades biol√≥gicas, dado que dichos sistemas son entidades complejas que no son tan f√°ciles de modelar impl√≠citamente.  Lo mismo se aplica a sistemas como la ca√≠da de nieve, la formaci√≥n de hielo, etc. La t√©cnica descrita en el art√≠culo es un <i>m√©todo impl√≠cito</i> , es decir.  uno que puede estimarse en un punto y cuyo valor en un punto dado no depende de los valores circundantes.  Los sistemas biol√≥gicos y de otro tipo para realizar simulaciones precisas generalmente necesitan considerar los valores ambientales.  Por ejemplo: ¬øcu√°nta luz solar cae sobre un bloque?  ¬øHay agua cerca?  Estas y otras preguntas deben responderse para simular el crecimiento y la propagaci√≥n de los sistemas biol√≥gicos, as√≠ como, en menor medida, otros tipos de sistemas relacionados con el clima.  Adem√°s, esta t√©cnica no es adecuada para modelar agua.  En este sistema no existe un concepto de flujo, conocimiento de mec√°nica de fluidos o gravedad.  El agua es un tema complejo que requiere muchos c√°lculos complejos. <br><br>  Entonces, solo estamos modelando la tierra y las piedras.  Necesitamos una funci√≥n que le indique cu√°l debe ser la ubicaci√≥n dada: tierra, arena, aire, oro, hierro, carb√≥n, etc. ... Pero comenzaremos con la m√°s simple.  Necesitamos una funci√≥n que indique si el bloque es s√≥lido o hueco (lleno de aire).  Esta funci√≥n deber√≠a simular la tierra que nos rodea.  Es decir, el cielo est√° arriba, la tierra est√° abajo.  Entonces, asumamos la tarea b√≠blica y separemos el cielo de la tierra.  Para hacer esto, estudiamos la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gradiente</a> .  La funci√≥n Gradiente pasa un segmento de l√≠nea en un espacio N-dimensional (es decir, en cualquier espacio de coordenadas, ya sea 2D, 3D o superior), y calcula el campo de gradiente a lo largo de este segmento.  Las coordenadas entrantes se proyectan en este segmento y su valor de gradiente se calcula en funci√≥n de d√≥nde se encuentran en relaci√≥n con los puntos finales del segmento.  Los puntos proyectados son valores asignados en el intervalo (-1.1).  Y este ser√° un buen comienzo para nosotros.  Podemos definir la funci√≥n Gradiente a lo largo del eje Y. En la parte superior del intervalo, comparamos el campo de gradiente con -1 (aire) y en la parte inferior con 1 (tierra). <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1}
 } </pre><br>  (Explicar√© la entrada brevemente. El c√≥digo de los ejemplos est√° escrito en la tabla de declaraci√≥n de Lua. Para obtener m√°s informaci√≥n sobre el formato, consulte la secci√≥n sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">integraci√≥n de Lua</a> . En esencia, el formato est√° dise√±ado para que una clase especial lo analice y los convierta en √°rboles de instancias de m√≥dulos de ruido. Prefiero esto el formato es m√°s detallado paso a paso en formato C ++, porque es m√°s compacto y limpio. En mi opini√≥n, el c√≥digo fuente es m√°s legible y comprimido que el c√≥digo C ++. En su mayor parte, las declaraciones son f√°ciles de leer y comprender. Los m√≥dulos tienen nombres, las fuentes se especifican  nombre o valor. El c√≥digo Lua utilizado para analizar las declaraciones de la tabla se incluye en el c√≥digo fuente en caso de que desee utilizar estas declaraciones directamente). <br><br>  En el caso de 2D, la funci√≥n Gradient recibe un segmento de l√≠nea recta en la forma (x1, x2, y1, y2), y en el caso de 3D, el formato se expande a (x1, x2, y1, y2, z1, z2).  El punto formado por (x1, y1) denota el comienzo del segmento de l√≠nea asociado con 0. El punto formado (x2, y2) es el final del segmento asociado con 1. Es decir, aqu√≠ mapeamos el segmento de l√≠nea (0,1) -&gt; ( 0,0) con un gradiente.  Por lo tanto, el gradiente estar√° entre las regiones de la funci√≥n Y = 1 e Y = 0.  Es decir, esta tira forma las dimensiones del mundo en Y. Cualquier parte del mundo estar√° en esta tira.  Podemos ajustar cualquier regi√≥n a lo largo de X (casi hasta el infinito, pero aqu√≠ la precisi√≥n <code>double</code> nos limita), pero todo es interesante, es decir.  La superficie de la tierra estar√° dentro de esta banda.  Este comportamiento se puede cambiar, pero dentro de √©l tenemos un gran grado de flexibilidad.  Simplemente no olvide que los valores que est√°n por encima o por debajo de esta banda tienen m√°s probabilidades de no ser interesantes, ya que los valores anteriores tienen m√°s probabilidades de ser aire, y los valores de abajo son tierra.  (Como pronto ver√°, esta afirmaci√≥n puede resultar err√≥nea). Para la mayor√≠a de las im√°genes de esta serie, coincidir√© con la regi√≥n cuadrada dada por el cuadrado (0,1) -&gt; (1,0) en el espacio 2D.  Por lo tanto, al principio nuestro mundo se ve as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f6/09d/543/5f609d54326fa4c746b5b391b1f75c6a.jpg"></div><br>  Nada interesante hasta ahora;  Adem√°s, esta imagen no responde a la pregunta "¬øel punto dado es s√≥lido o hueco?".  Para responder a esta pregunta, necesitamos aplicar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funci√≥n de paso</a> (funci√≥n definida por partes).  En lugar de un gradiente suave, necesitamos una separaci√≥n clara, en la que todas las ubicaciones de un lado sean huecas y todas las ubicaciones del otro lado sean s√≥lidas.  En <b>ANL,</b> esto se puede implementar usando la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Seleccionar</a> .  La funci√≥n Seleccionar recibe dos funciones o valores entrantes (en este caso ser√°n iguales a "s√≥lido" y "Hueco" (Abierto)), y los selecciona en funci√≥n del valor de la funci√≥n de control (en este caso, Gradiente).  El m√≥dulo Seleccionar tiene dos par√°metros adicionales, <b>umbral</b> y <b>ca√≠da</b> , que afectan este proceso.  En esta etapa, la <b>ca√≠da no es</b> deseable, por lo que la estableceremos en 0. El par√°metro <b>umbral</b> decide a d√≥nde ir√° la l√≠nea divisoria entre S√≥lido y Abierto.  Todo lo que sea mayor que este valor en la funci√≥n Gradiente se convertir√° en S√≥lido, y todo lo que sea menor que el umbral se abrir√°.  Como Gradient compara el intervalo con valores de 0 y 1, ser√≠a l√≥gico colocar el umbral en 0.5.  Entonces dividimos el espacio exactamente por la mitad.  El valor 1 ser√° una ubicaci√≥n s√≥lida y el valor 0 ser√° hueco.  Es decir, definimos la funci√≥n del plano terrestre de la siguiente manera: <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_select", type = "select", low = 0, high = 1, umbral = 0.5, control = "ground_gradient"}
 }
</pre><br>  Al comparar la misma √°rea de la funci√≥n que antes, obtenemos algo similar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35a/d9c/4b5/35ad9c4b583840222252f7c136ba983a.jpg"></div><br>  Esta imagen responde claramente a la pregunta de si el punto dado es s√≥lido o hueco.  Podemos llamar a la funci√≥n con cualquier coordenada posible del espacio 2D, y su resultado ser√° 1 o 0, dependiendo de d√≥nde est√© el punto en relaci√≥n con la superficie de la tierra.  Sin embargo, tal funci√≥n no es particularmente interesante, es solo una l√≠nea plana que se extiende hasta el infinito.  Para revivir la imagen, utilizamos una t√©cnica llamada "turbulencia". <br><br>  La ‚Äúturbulencia‚Äù es una designaci√≥n compleja del concepto de agregar valores a las coordenadas entrantes de una funci√≥n.  Imagine que llamamos a la funci√≥n anterior de la tierra con la coordenada (0,1).  Se encuentra sobre el plano del suelo, porque en Y = 1 el gradiente tiene un valor de 0, que es menor que el umbral = 0.5.  Es decir, este punto se calcular√° como Abierto.  Pero, ¬øqu√© pasa si, antes de invocar la funci√≥n de la tierra, de alguna manera transformamos este punto?  Supongamos que restamos un valor aleatorio de la coordenada Y, por ejemplo, 3. Restamos 3 y obtenemos la coordenada (0, -2).  Si ahora llamamos a la funci√≥n base para este punto, entonces el punto se considerar√° s√≥lido, porque Y = -2 se encuentra debajo del segmento Gradiente correspondiente a 1. De repente, el punto hueco (0,1) se convierte en un s√≥lido.  Obtendremos un bloque de piedra s√≥lida que cuelga en el aire.  Esto se puede hacer con cualquier punto de la funci√≥n sumando o restando un n√∫mero aleatorio de la coordenada Y del punto entrante antes de llamar a la funci√≥n ground_select.  Aqu√≠ hay una imagen de la funci√≥n ground_select que muestra esto.  Antes de llamar a la funci√≥n ground_select, el valor en el intervalo (-0.25, 0.25) se agrega a la coordenada Y de cada punto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f28/273/32e/f2827332ed068acf376b4b6cfbf0853d.jpg"></div><br>  Esto es m√°s interesante que una l√≠nea plana, pero no muy similar a la tierra, porque cada punto se mueve a un valor completamente aleatorio, lo que crea un patr√≥n ca√≥tico.  Sin embargo, si usamos una funci√≥n aleatoria continua, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fractal</a> de la biblioteca <b>ANL</b> , entonces, en lugar de un patr√≥n aleatorio, obtenemos algo m√°s controlable.  Por lo tanto, conectemos un fractal al plano de la tierra y veamos qu√© sucede. <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, frecuencia = 2},
	 {name = "ground_scale", type = "scaleoffset", scale = 0.5, offset = 0, source = "ground_shape_fractal"},
	 {name = "ground_perturb", type = "translateomain", source = "ground_gradient", ty = "ground_scale"},<font></font>
	<font></font>
	 {name = "ground_select", type = "select", low = 0, high = 1, umbral = 0.5, control = "ground_perturb"}
 }
</pre><br>  Aqu√≠ vale la pena se√±alar un par de aspectos.  Primero, definimos el m√≥dulo Fractal y lo encadenamos al m√≥dulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ScaleOffset</a> .  El m√≥dulo ScaleOffset escala los valores fractales de salida a un nivel m√°s conveniente.  Parte del relieve puede ser monta√±oso y requerir una escala mayor, y otra parte m√°s plana y con una escala menor.  Hablaremos sobre diferentes tipos de terreno m√°s adelante, pero por ahora los usaremos para demostraci√≥n.  Los valores de salida de la funci√≥n ahora dar√°n la siguiente imagen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ca/56e/b55/8ca56eb55e7febec86f3dd80fcea2d0e.jpg"></div><br>  Esto es m√°s interesante que solo ruido aleatorio, ¬øverdad?  Al menos, se parece m√°s a la tierra, aunque parte del paisaje parece inusual, y las islas voladoras son completamente extra√±as.  La raz√≥n de esto fue que cada punto individual del mapa de salida se desplaza aleatoriamente por un valor diferente determinado por el fractal.  Para ilustrar esto, muestre la salida fractal que realiza la distorsi√≥n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbd/67d/b62/fbd67db6235a14fdf6d734d2ac73f560.jpg"></div><br>  En la imagen de arriba, todos los puntos negros tienen un valor de -0.25, y todos los puntos blancos tienen un valor de 0.25.  Es decir, donde el fractal es negro, el punto correspondiente de la funci√≥n de la Tierra se desplazar√° "hacia abajo" en 0.25.  (0.25 significa 1/4 de la pantalla.) Dado que un punto puede desplazarse ligeramente, y el otro punto sobre √©l en el espacio puede desplazarse m√°s, existe la posibilidad de protuberancias de rocas e islas voladoras.  Las protuberancias en la naturaleza son bastante naturales, en contraste con las islas voladoras.  (A menos que estemos en la pel√≠cula "Avatar"). Si tu juego necesita un paisaje tan fant√°stico, es genial, pero si necesitas un modelo m√°s realista, necesitamos ajustar un poco la funci√≥n fractal.  Afortunadamente, la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ScaleDomain</a> puede hacer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esto</a> . <br><br>  Queremos que la funci√≥n se comporte como una funci√≥n de mapa de altura.  Imagine un mapa de altura 2D en el que cada punto del mapa representa la altura de un punto en la cuadr√≠cula de puntos de cuadr√≠cula que se elevan hacia arriba o hacia abajo.  Los valores blancos del mapa indican colinas altas, negro - valles bajos.  Necesitamos un comportamiento similar, pero para lograrlo, necesitamos deshacernos esencialmente de una de las dimensiones.  En el caso de un mapa de altura, creamos una elevaci√≥n 3D a partir de un mapa de altura 2D.  Del mismo modo, en el caso del terreno 2D, necesitamos un mapa de altura 1D.  Despu√©s de hacer que todos los puntos de un fractal con la misma coordenada Y tengan el mismo valor, podemos cambiar todos los puntos con la misma coordenada X en la misma cantidad, por lo que las islas voladoras desaparecen.  Para hacer esto, puede usar ScaleDomain, restableciendo el coeficiente de escala.  Es decir, antes de llamar a la funci√≥n ground_shape_fractal, llamamos a ground_scale_y para establecer la coordenada y en 0. Esto asegura que el valor Y no afecte la salida del fractal, esencialmente convirti√©ndolo en una funci√≥n de ruido 1D.  Para hacer esto, haremos los siguientes cambios: <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, frecuencia = 2},
	 {name = "ground_scale", type = "scaleoffset", scale = 0.5, offset = 0, source = "ground_shape_fractal"},
	 {name = "ground_scale_y", type = "scaledomain", source = "ground_scale", scaley = 0},
	 {name = "ground_perturb", type = "translateomain", source = "ground_gradient", ty = "ground_scale_y"},<font></font>
	<font></font>
	 {name = "ground_select", type = "select", low = 0, high = 1, umbral = 0.5, control = "ground_perturb"}
 }
</pre><br>  Encadenaremos la funci√≥n ScaleDomain con ground_scale y luego modificaremos los datos originales ground_perturb para que sean una funci√≥n ScaleDomain.  Esto cambiar√° el fractal que desplaza la tierra y la convierte en algo as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca7/e79/4dc/ca7e794dc19c6922c6278cfdf3437caf.jpg"></div><br>  Ahora, si echamos un vistazo a la salida, obtenemos el resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb2/31a/5d6/bb231a5d6c2e0cfb1f8181ba6de1dc61.jpg"></div><br>  Mucho mejor  Las islas voladoras han desaparecido por completo, y el relieve es m√°s parecido a monta√±as y colinas.  Desafortunadamente, perdimos salientes y acantilados.  Ahora toda la tierra es continua e inclinada.  Si lo desea, puede arreglar esto de varias maneras. <br><br>  Primero, puede usar otra funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TranslateDomain</a> , junto con otra funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fractal</a> .  Si aplicamos una peque√±a cantidad de turbulencia fractal a la direcci√≥n X, podemos distorsionar ligeramente los bordes y las superficies de las monta√±as, y esto probablemente ser√° suficiente para formar precipicios y salientes.  Miremos en acci√≥n. <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, frecuencia = 2},
	 {name = "ground_scale", type = "scaleoffset", scale = 0.5, offset = 0, source = "ground_shape_fractal"},
	 {name = "ground_scale_y", type = "scaledomain", source = "ground_scale", scaley = 0},
	 {name = "ground_perturb", type = "translateomain", source = "ground_gradient", ty = "ground_scale_y"},
	 {name = "ground_overhang_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octavas = 6, frecuencia = 2},
	 {name = "ground_overhang_scale", type = "scaleoffset", source = "ground_overhang_fractal", scale = 0.2, offset = 0},
	 {name = "ground_overhang_perturb", type = "translateomain", source = "ground_perturb", tx = "ground_overhang_scale"},<font></font>
	<font></font>
	 {name = "ground_select", type = "select", low = 0, high = 1, umbral = 0.5, control = "ground_overhang_perturb"}
 }
</pre><br>  Y aqu√≠ est√° el resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c3/09f/c4e/4c309fc4e22125fa2083d5bf33e4dc20.jpg"></div><br>  La segunda forma: simplemente puede establecer el par√°metro de <b>escala de la</b> funci√≥n <b>ground_scale_y</b> <b>en un</b> valor mayor que 0. Si deja una escala peque√±a en Y, obtendremos una fracci√≥n de la variabilidad, sin embargo, cuanto mayor sea la escala, m√°s fuerte ser√° el relieve que se asemejar√° a la versi√≥n anterior sin escala. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/225/f3f/746/225f3f7462f1c78bb48a3603363643aa.jpg"></div><br>  Los resultados parecen mucho m√°s interesantes que las monta√±as en pendiente ordinarias.  Sin embargo, no importa cu√°n interesantes sean, el jugador a√∫n se aburrir√° de explorar el relieve con el mismo patr√≥n, extendi√©ndose por muchos kil√≥metros.  Adem√°s, tal alivio ser√≠a muy poco realista.  En el mundo real, hay mucha variabilidad que hace que el terreno sea m√°s interesante.  Veamos qu√© se puede hacer para hacer que el mundo sea m√°s diverso. <br><br>  Mirando el ejemplo de c√≥digo anterior, puede ver un patr√≥n espec√≠fico en √©l.  Tenemos una funci√≥n de gradiente, que es controlada por funciones que le dan forma a la tierra, despu√©s de lo cual se aplica una funci√≥n definida por partes y la tierra se llena.  Es decir, ser√° m√°s l√≥gico complicar el alivio en la etapa de dar forma a la tierra.  En lugar de un fractal que se desplaza a lo largo de Y y otro que se desplaza a lo largo de X, podemos lograr el grado de complejidad requerido (teniendo en cuenta el rendimiento: cada fractal requiere costos computacionales adicionales, por lo que debemos tratar de ser conservadores). Podemos especificar las formas de la tierra, que son monta√±as, estribaciones , tierras bajas planas, tierras bald√≠as, etc., y use la salida de las diversas funciones de selecci√≥n encadenadas con fractales de baja frecuencia para delinear √°reas de cada tipo.  Entonces, veamos c√≥mo puede implementar diferentes tipos de terreno. <br><br>  Para ilustrar el principio, distinguimos tres tipos de relieve: mesetas (colinas de pendiente suave), monta√±as y tierras bajas (en su mayor√≠a planas).  Para cambiar entre ellos, utilizamos un sistema basado en selecci√≥n y los combinamos en un lienzo complejo.  As√≠ que aqu√≠ vamos ... <br><br>  <b>Estribaciones:</b> <br><br>  Con ellos, todo es simple.  Podemos tomar el esquema utilizado anteriormente, reducir ligeramente la amplitud de las colinas, tal vez incluso hacerlas m√°s sustractivas que aditivas.  para bajar las alturas medias.  Tambi√©n podemos reducir el recuento de octavas para suavizarlas. <br><br><pre> {name = "lowland_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 2, frecuencia = 1},
 {name = "lowland_autocorrect", type = "autocorrect", source = "lowland_shape_fractal", low = 0, high = 1},
 {name = "lowland_scale", type = "scaleoffset", source = "lowland_autocorrect", scale = 0.2, offset = -0.25},
 {name = "lowland_y_scale", type = "scaledomain", source = "lowland_scale", scaley = 0},
 {name = "lowland_terrain", type = "translateomain", source = "ground_gradient", ty = "lowland_y_scale"},
</pre><br>  <b>Tierras altas:</b> <br><br>  Con ellos, tambi√©n, todo es simple.  (De hecho, ninguno de estos tipos de terreno es dif√≠cil). Sin embargo, utilizamos una base diferente para hacer que las colinas se vean como dunas. <br><br><pre> {name = "highland_shape_fractal", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octavas = 2, frecuencia = 2},
 {name = "highland_autocorrect", type = "autocorrect", source = "highland_shape_fractal", low = 0, high = 1},
 {name = "highland_scale", type = "scaleoffset", source = "highland_autocorrect", scale = 0.45, offset = 0},
 {name = "highland_y_scale", type = "scaledomain", source = "highland_scale", scaley = 0},
 {name = "highland_terrain", type = "translateomain", source = "ground_gradient", ty = "highland_y_scale"},
</pre><br>  <b>Monta√±as:</b> <br><br><pre> {name = "mountain_shape_fractal", type = "fractal", fractaltype = anl.BILLOW, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 4, frecuencia = 1},
 {name = "mountain_autocorrect", type = "autocorrect", source = "mountain_shape_fractal", low = 0, high = 1},
 {name = "mountain_scale", type = "scaleoffset", source = "mountain_autocorrect", scale = 0.75, offset = 0.25},
 {name = "mountain_y_scale", type = "scaledomain", source = "mountain_scale", scaley = 0.1},
 {name = "mountain_terrain", type = "translateomain", source = "ground_gradient", ty = "mountain_y_scale"},
</pre><br>  Por supuesto, puede abordar este proceso de manera a√∫n m√°s creativa, pero en general el patr√≥n ser√° as√≠.  Destacamos las caracter√≠sticas del tipo de relieve y seleccionamos funciones de ruido para ellos.  Para todo esto, se aplican los mismos principios;  Las principales diferencias son la escala.  Ahora, para conectarlos, prepararemos fractales adicionales que controlar√°n la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Seleccionar</a> .  Luego, encadenamos los m√≥dulos Select para generar todo el terreno. <br><br><pre> {nombre = "terreno_tipo_fractal", tipo = "fractal", fractaltipo = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octavas = 3, frecuencia = 0.5},
 {nombre = "terreno_autocorrecci√≥n", tipo = "autocorrecci√≥n", fuente = "terreno_tipo_fractal", bajo = 0, alto = 1},
 {nombre = "terrenos_tipo_cach√©", tipo = "cach√©", fuente = "relieve_autocorrecci√≥n"},
 {name = "highland_mountain_select", type = "select", low = "highland_terrain", high = "mountain_terrain", control = "terrenos_tipo_cach√©", umbral = 0.55, ca√≠da = 0.15},
 {name = "highland_lowland_select", type = "select", low = "lowland_terrain", high = "highland_mountain_select", control = "terrenos_tipo_cach√©", umbral = 0.25, ca√≠da = 0.15},
</pre><br>  Entonces, aqu√≠ definimos tres tipos principales de terreno: tierras bajas, tierras altas y monta√±as.  Usamos un fractal para seleccionar uno de ellos, de modo que haya transiciones naturales (tierras bajas-&gt; tierras altas-&gt; monta√±as).  Luego usamos otro fractal para insertar aleatoriamente tierras bald√≠as en el mapa.  As√≠ es como se ve la cadena de m√≥dulos terminada: <br><br><pre> terraintree =
 {
	 {name = "lowland_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 2, frecuencia = 1},
	 {name = "lowland_autocorrect", type = "autocorrect", source = "lowland_shape_fractal", low = 0, high = 1},
	 {name = "lowland_scale", type = "scaleoffset", source = "lowland_autocorrect", scale = 0.2, offset = -0.25},
	 {name = "lowland_y_scale", type = "scaledomain", source = "lowland_scale", scaley = 0},
	 {name = "lowland_terrain", type = "translateomain", source = "ground_gradient", ty = "lowland_y_scale"},
	 {name = "ground_gradient", type = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "highland_shape_fractal", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octavas = 2, frecuencia = 2},
	 {name = "highland_autocorrect", type = "autocorrect", source = "highland_shape_fractal", low = 0, high = 1},
	 {name = "highland_scale", type = "scaleoffset", source = "highland_autocorrect", scale = 0.45, offset = 0},
	 {name = "highland_y_scale", type = "scaledomain", source = "highland_scale", scaley = 0},
	 {name = "highland_terrain", type = "translateomain", source = "ground_gradient", ty = "highland_y_scale"},<font></font>
<font></font>
	 {name = "mountain_shape_fractal", type = "fractal", fractaltype = anl.BILLOW, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 4, frecuencia = 1},
	 {name = "mountain_autocorrect", type = "autocorrect", source = "mountain_shape_fractal", low = 0, high = 1},
	 {name = "mountain_scale", type = "scaleoffset", source = "mountain_autocorrect", scale = 0.75, offset = 0.25},
	 {name = "mountain_y_scale", type = "scaledomain", source = "mountain_scale", scaley = 0.1},
	 {name = "mountain_terrain", type = "translateomain", source = "ground_gradient", ty = "mountain_y_scale"},<font></font>
<font></font>
	 {nombre = "terreno_tipo_fractal", tipo = "fractal", fractaltipo = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octavas = 3, frecuencia = 0.5},
	 {nombre = "terreno_autocorrecci√≥n", tipo = "autocorrecci√≥n", fuente = "terreno_tipo_fractal", bajo = 0, alto = 1},
	 {nombre = "terrenos_tipo_cach√©", tipo = "cach√©", fuente = "relieve_autocorrecci√≥n"},
	 {name = "highland_mountain_select", type = "select", low = "highland_terrain", high = "mountain_terrain", control = "terrenos_tipo_cach√©", umbral = 0.55, ca√≠da = 0.15},
	 {name = "highland_lowland_select", type = "select", low = "lowland_terrain", high = "highland_mountain_select", control = "terrenos_tipo_cach√©", umbral = 0.25, ca√≠da = 0.15},
	 {name = "ground_select", type = "select", low = 0, high = 1, umbral = 0.5, control = "highland_lowland_select"}
 }
</pre><br>  Aqu√≠ hay algunos ejemplos de los relieves resultantes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/60f/afe/4c460fafe39eec4680ac6eb3c341beef.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/241/869/9c8241869337938b628d0b9a53a3e756.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/538/67a/f3a/53867af3a00abb26d5b0f32f5f728694.jpg"></div><br>  Puede notar que se obtiene una variabilidad bastante alta.  En algunos lugares, aparecen elevadas monta√±as rotas, en otros hay llanuras de pendiente suave.  Ahora necesitamos agregar cuevas para poder explorar las maravillas del inframundo. <br><br>  Para las cuevas, uso el sistema multiplicativo aplicado a <b>ground_select</b> .  Es decir, creo una funci√≥n que genera 1 o 0, y las multiplico por la salida de <b>ground_select</b> .  Gracias a esto, cualquier punto de la funci√≥n se vuelve hueco para el cual el valor de la funci√≥n de las cuevas es 0. Es decir, donde quiero obtener la cueva, la funci√≥n de las cuevas deber√≠a devolver 0, y donde la cueva no deber√≠a estar, la funci√≥n deber√≠a ser 1. En cuanto a la forma cuevas, quiero establecer un sistema de cuevas basado en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Multifractal Ridged de</a> 1 octava. <br><br><pre> {name = "cave_shape", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 1, frecuencia = 2},
</pre><br>  El resultado es algo como esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31c/bf0/297/31cbf02975f1852907bb3a0f24ffd43a.jpg"></div><br>  Si aplicamos la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Seleccionar</a> como una funci√≥n definida por partes, como lo hicimos con el gradiente de tierra, implement√°ndola de modo que la parte inferior del umbral de selecci√≥n sea 1 (no hay cueva), y la parte superior es 0 (hay una cueva), el resultado se ver√° m√°s o menos as√≠ : <br><br><pre> {name = "cave_shape", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 1, frecuencia = 2},
 {name = "cave_select", type = "select", low = 1, high = 0, control = "cave_shape", umbral = 0.8, ca√≠da = 0},
</pre><br>  Resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d8/55a/c47/1d855ac477dd48ba59d20ed30d89bde6.jpg"></div><br>  Por supuesto, se ve bastante suave, as√≠ que agrega un poco de ruido fractal para distorsionar el √°rea. <br><br><pre> {name = "cave_shape", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 1, frecuencia = 2},
 {name = "cave_select", type = "select", low = 1, high = 0, control = "cave_shape", umbral = 0.8, ca√≠da = 0},
 {name = "cave_perturb_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, frecuencia = 3},
 {name = "cave_perturb_scale", type = "scaleoffset", source = "cave_perturb_fractal", scale = 0.25, offset = 0},<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{name = "cave_perturb", type = "translateomain", source = "cave_select", tx = "cave_perturb_scale"},</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resultado: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ec/deb/4fa/0ecdeb4faf32eea11c05a7a76b7c6225.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto hace que las cuevas sean un poco ruidosas y que no sean tan suaves. </font><font style="vertical-align: inherit;">Veamos ahora qu√© sucede si aplicas las cuevas al relieve:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d34/974/278/d34974278435e239ad7eb9193adc9672.jpg"></div><br><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">Al</font></b><font style="vertical-align: inherit;"> experimentar con el valor </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">umbral</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , podemos hacer que las cuevas sean m√°s delgadas o m√°s gruesas. Pero lo principal que debemos intentar es asegurarnos de que las cuevas no carcoman esos enormes fragmentos del relieve superficial. Para hacer esto, podemos volver a la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highland_lowland_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que, como recordamos, es la √∫ltima funci√≥n de alivio que distorsiona el gradiente de la tierra. Lo que es √∫til en esta funci√≥n es que sigue siendo un gradiente, lo que aumenta el valor cuando la funci√≥n se profundiza en el suelo. Podemos usar el gradiente para debilitar la funci√≥n de las cuevas para que las cuevas aumenten a medida que se adentran en el suelo. Afortunadamente para nosotros, esta atenuaci√≥n se puede lograr simplemente multiplicando la salida de la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highland_lowland_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la salida de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_shape</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y luego pasa el resultado al resto de la cadena de funciones. A continuaci√≥n, haremos un cambio importante aqu√≠: agregue la funci√≥n </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cach√©</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La funci√≥n de almacenamiento en cach√© guarda el resultado de la funci√≥n para la coordenada entrante dada, y si la funci√≥n se llama repetidamente con la misma coordenada, devolver√° la copia en cach√© y no calcular√° el resultado nuevamente. Esto es √∫til en situaciones donde una funci√≥n compleja ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highland_lowland_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) en una cadena de funciones se llama varias veces. Sin un cach√©, la cadena completa de una funci√≥n compleja se recalcula con cada llamada. Para agregar el cach√©, primero debemos hacer los siguientes cambios:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{name = "highland_lowland_select", type = "select", low = "lowland_terrain", high = "highland_mountain_select", control = "terrenos_tipo_cach√©", umbral = 0.25, ca√≠da = 0.15},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{name = "highland_lowland_select_cache", type = "cache", source = "highland_lowland_select"},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{name = "ground_select", type = "select", low = 0, high = 1, umbral = 0.5, control = "highland_lowland_select_cache"},</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, agregamos Cache y luego redirigimos la entrada a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ground_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que se tomara del cach√© y no directamente de la funci√≥n. </font><font style="vertical-align: inherit;">Luego podemos cambiar el c√≥digo de las cuevas para agregar atenuaci√≥n:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{name = "cave_shape", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 1, frecuencia = 4},</font></font><font></font>
{name="cave_attenuate_bias", type="bias", source="highland_lowland_select_cache", bias=0.45},<font></font>
{name="cave_shape_attenuate", type="combiner", operation=anl.MULT, source_0="cave_shape", source_1="cave_attenuate_bias"},<font></font>
{name="cave_perturb_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=6, frequency=3},<font></font>
{name="cave_perturb_scale", type="scaleoffset", source="cave_perturb_fractal", scale=0.5, offset=0},<font></font>
{name="cave_perturb", type="translatedomain", source="cave_shape_attenuate", tx="cave_perturb_scale"},<font></font>
{name="cave_select", type="select", low=1, high=0, control="cave_perturb", threshold=0.48, falloff=0},<font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En primer lugar, agregamos la funci√≥n </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bias</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esto es por conveniencia, porque nos permite ajustar el intervalo de la funci√≥n de atenuaci√≥n de gradiente. Luego se </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agrega la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funci√≥n </font><b><font style="vertical-align: inherit;">cave_shape_attenuate</font></b><font style="vertical-align: inherit;"> , que es un </font><b><font style="vertical-align: inherit;">Combinador </font></b></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tipo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anl :: MULT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ella multiplica el gradiente por </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_shape</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Luego, el resultado de esta operaci√≥n se pasa a la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_perturb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El resultado se parece a esto:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f8/55d/fd3/8f855dfd376c5d8049a075d28066f72c.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vemos que m√°s cerca de la superficie de la tierra se han vuelto m√°s delgados. </font><font style="vertical-align: inherit;">(No preste atenci√≥n a la parte superior, esto es solo un artefacto de valores de gradiente negativos, no afecta a las cuevas terminadas. Si esto se convierte en un problema, digamos que si usamos esta funci√≥n para otra cosa, entonces podemos limitar el gradiente al intervalo (0, 1).) Es un poco dif√≠cil ver c√≥mo funciona esto en relaci√≥n con el terreno, as√≠ que avancemos y organicemos todo para ver qu√© sucede. </font><font style="vertical-align: inherit;">Aqu√≠ est√° toda la cadena de funciones que hemos creado hasta ahora.</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terraintree =
</font></font> {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "ground_gradient", type = "gradiente", x1 = 0, x2 = 0, y1 = 0, y2 = 1},</font></font><font></font>
	<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "lowland_shape_fractal", type = "fractal", fractaltype = anl.BILLOW, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 2, frecuencia = 0.25},</font></font><font></font>
	{name="lowland_autocorrect", type="autocorrect", source="lowland_shape_fractal", low=0, high=1},<font></font>
	{name="lowland_scale", type="scaleoffset", source="lowland_autocorrect", scale=0.125, offset=-0.45},<font></font>
	{name="lowland_y_scale", type="scaledomain", source="lowland_scale", scaley=0},<font></font>
	{name="lowland_terrain", type="translatedomain", source="ground_gradient", ty="lowland_y_scale"},<font></font>
	<font></font>
	{name="highland_shape_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=4, frequency=2},<font></font>
	{name="highland_autocorrect", type="autocorrect", source="highland_shape_fractal", low=-1, high=1},<font></font>
	{name="highland_scale", type="scaleoffset", source="highland_autocorrect", scale=0.25, offset=0},<font></font>
	{name="highland_y_scale", type="scaledomain", source="highland_scale", scaley=0},<font></font>
	{name="highland_terrain", type="translatedomain", source="ground_gradient", ty="highland_y_scale"},<font></font>
<font></font>
	{name="mountain_shape_fractal", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=8, frequency=1},<font></font>
	{name="mountain_autocorrect", type="autocorrect", source="mountain_shape_fractal", low=-1, high=1},<font></font>
	{name="mountain_scale", type="scaleoffset", source="mountain_autocorrect", scale=0.45, offset=0.15},<font></font>
	{name="mountain_y_scale", type="scaledomain", source="mountain_scale", scaley=0.25},<font></font>
	{name="mountain_terrain", type="translatedomain", source="ground_gradient", ty="mountain_y_scale"},<font></font>
<font></font>
	{name="terrain_type_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=3, frequency=0.125},<font></font>
	{name="terrain_autocorrect", type="autocorrect", source="terrain_type_fractal", low=0, high=1},<font></font>
	{name="terrain_type_y_scale", type="scaledomain", source="terrain_autocorrect", scaley=0},<font></font>
	{name="terrain_type_cache", type="cache", source="terrain_type_y_scale"},<font></font>
	{name="highland_mountain_select", type="select", low="highland_terrain", high="mountain_terrain", control="terrain_type_cache", threshold=0.55, falloff=0.2},<font></font>
	{name="highland_lowland_select", type="select", low="lowland_terrain", high="highland_mountain_select", control="terrain_type_cache", threshold=0.25, falloff=0.15},<font></font>
	{name="highland_lowland_select_cache", type="cache", source="highland_lowland_select"},<font></font>
	{name="ground_select", type="select", low=0, high=1, threshold=0.5, control="highland_lowland_select_cache"},<font></font>
	<font></font>
	{name="cave_shape", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
	{name="cave_attenuate_bias", type="bias", source="highland_lowland_select_cache", bias=0.45},<font></font>
	{name="cave_shape_attenuate", type="combiner", operation=anl.MULT, source_0="cave_shape", source_1="cave_attenuate_bias"},<font></font>
	{name="cave_perturb_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=6, frequency=3},<font></font>
	{name="cave_perturb_scale", type="scaleoffset", source="cave_perturb_fractal", scale=0.5, offset=0},<font></font>
	{name="cave_perturb", type="translatedomain", source="cave_shape_attenuate", tx="cave_perturb_scale"},<font></font>
	{name="cave_select", type="select", low=1, high=0, control="cave_perturb", threshold=0.48, falloff=0},<font></font>
	<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "ground_cave_multiply", type = "combiner", operation = anl.MULT, source_0 = "cave_select", source_1 = "ground_select"}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqu√≠ hay ejemplos de tarjetas aleatorias derivadas de esta funci√≥n: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f8/1a5/ca8/9f81a5ca8f1b739c03721b6a5ba280a5.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c86/5ec/b69/c865ecb69a1701a1b757535f289c6c0a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a82/332/1e3/a823321e389de00947e695424497f2e9.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora todo se ve bastante bien. Todas las cuevas son cavernas bastante grandes en las profundidades del subsuelo, pero m√°s cerca de la superficie generalmente se convierten en peque√±os t√∫neles. Esto ayuda a crear una atm√≥sfera de misterio. Al explorar la superficie, encontrar√°s una peque√±a entrada a la cueva. ¬øA d√≥nde va ella? ¬øQu√© tan profundo se extiende? No podemos saber esto, pero en el proceso de estudio comienza a expandirse, convirti√©ndose en un extenso sistema de cavernas llenas de oscuridad y peligros. Y bot√≠n, por supuesto. Siempre hay mucho bot√≠n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede cambiar este sistema de muchas maneras diferentes, obteniendo resultados diferentes. Podemos cambiar los par√°metros de umbral para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y los par√°metros para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_attenuate_bias</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o reemplazar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_attenuate_bias</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">otras funciones para hacer coincidir el intervalo de gradiente con otros valores que se adapten mejor a sus necesidades. Tambi√©n puede agregar otro fractal que distorsiona el sistema de cuevas a lo largo del eje Y para eliminar la posibilidad de t√∫neles anormalmente lisos a lo largo del eje X (causado por el hecho de que la forma de la cueva se distorsiona solo a lo largo del eje X). Tambi√©n puede agregar un nuevo fractal como fuente adicional de atenuaci√≥n, especificar una tercera fuente para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_shape_attenuate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que escala la atenuaci√≥n en funci√≥n de las regiones, de modo que las cuevas en algunas √°reas sean m√°s densas (por ejemplo, en las monta√±as), y con menos frecuencia o completamente ausentes en otras. Esta selecci√≥n regional se puede crear desde la funci√≥n del </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terreno_tipo_fractal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para saber d√≥nde se encuentran las zonas de monta√±a. </font><font style="vertical-align: inherit;">Todo se reduce a solo pensar en lo que desea, descubrir qu√© efecto tendr√°n las diferentes funciones en la salida y experimentar con los par√°metros hasta obtener el resultado deseado. </font><font style="vertical-align: inherit;">Esta no es una ciencia exacta y, a menudo, el efecto deseado se puede alcanzar de diferentes maneras.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Desventajas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este m√©todo de generaci√≥n de terreno tiene desventajas. </font><font style="vertical-align: inherit;">El proceso de generaci√≥n de ruido puede ser bastante lento. </font><font style="vertical-align: inherit;">Es importante reducir la cantidad de fractales, la cantidad de octavas de esos fractales que usa y otras operaciones lentas, si es posible. </font><font style="vertical-align: inherit;">Intente usar fractales varias veces y guarde en cach√© todas las funciones que se llaman varias veces. </font><font style="vertical-align: inherit;">En este ejemplo, utilic√© libremente fractales, creando uno para cada uno de los tres tipos de relieve. </font><font style="vertical-align: inherit;">Usando </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScaleOffset</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para cambiar los intervalos y tomando un fractal como base para todos ellos, ahorrar√≠a mucho tiempo de procesador. </font><font style="vertical-align: inherit;">En 2D, no todo es tan malo, pero cuando llegas a 3D e intentas comparar las cantidades de datos, el tiempo de procesamiento aumentar√° significativamente.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ir a 3D </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo esto es genial si creas un juego como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terraria</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">King Arthur's Gold</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero ¬øqu√© </font><font style="vertical-align: inherit;">pasa si </font><font style="vertical-align: inherit;">necesitas algo como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minecraft</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infiniminer?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? ¬øQu√© cambios necesitaremos hacer en la cadena de funciones? De hecho, no hay muchos. La funci√≥n que se muestra arriba funcionar√° casi sin modificaciones para el relieve 3D. Ser√° suficiente para que compare el volumen 3D utilizando las variaciones 3D del generador, y tambi√©n para comparar el eje Y con el eje vertical del volumen, y no con la regi√≥n 2D. Sin embargo, se requerir√° un cambio, a saber, una forma de realizar las cuevas. Como viste, Ridged Multifractal es ideal para un sistema de cuevas 2D, pero en 3D corta muchas conchas curvas, no t√∫neles, y su efecto resulta ser incorrecto. Es decir, en 3D es necesario especificar dos formas fractales de cuevas, ambas son ruido Multifractal Ridged de 1 octava, pero con semillas diferentes. Con Seleccionar, config√∫relos en 1 o 0 y multipl√≠quelos. Por lo tanto, en la intersecci√≥n de los fractales, aparecer√° una cueva,y todo lo dem√°s permanecer√° s√≥lido, y la apariencia de los t√∫neles se volver√° m√°s natural que usar un solo fractal.</font></font><br><br><pre>terraintree3d=
 {<font></font>
	{name="ground_gradient", type="gradient", x1=0, x2=0, y1=0, y2=1},<font></font>
	<font></font>
	{name="lowland_shape_fractal", type="fractal", fractaltype=anl.BILLOW, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=2, frequency=0.25},<font></font>
	{name="lowland_autocorrect", type="autocorrect", source="lowland_shape_fractal", low=0, high=1},<font></font>
	{name="lowland_scale", type="scaleoffset", source="lowland_autocorrect", scale=0.125, offset=-0.45},<font></font>
	{name="lowland_y_scale", type="scaledomain", source="lowland_scale", scaley=0},<font></font>
	{name="lowland_terrain", type="translatedomain", source="ground_gradient", ty="lowland_y_scale"},<font></font>
	<font></font>
	{name="highland_shape_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=4, frequency=2},<font></font>
	{name="highland_autocorrect", type="autocorrect", source="highland_shape_fractal", low=-1, high=1},<font></font>
	{name="highland_scale", type="scaleoffset", source="highland_autocorrect", scale=0.25, offset=0},<font></font>
	{name="highland_y_scale", type="scaledomain", source="highland_scale", scaley=0},<font></font>
	{name="highland_terrain", type="translatedomain", source="ground_gradient", ty="highland_y_scale"},<font></font>
<font></font>
	{name="mountain_shape_fractal", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=8, frequency=1},<font></font>
	{name="mountain_autocorrect", type="autocorrect", source="mountain_shape_fractal", low=-1, high=1},<font></font>
	{name="mountain_scale", type="scaleoffset", source="mountain_autocorrect", scale=0.45, offset=0.15},<font></font>
	{name="mountain_y_scale", type="scaledomain", source="mountain_scale", scaley=0.25},<font></font>
	{name="mountain_terrain", type="translatedomain", source="ground_gradient", ty="mountain_y_scale"},<font></font>
<font></font>
	{name="terrain_type_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=3, frequency=0.125},<font></font>
	{name="terrain_autocorrect", type="autocorrect", source="terrain_type_fractal", low=0, high=1},<font></font>
	{name="terrain_type_y_scale", type="scaledomain", source="terrain_autocorrect", scaley=0},<font></font>
	{name="terrain_type_cache", type="cache", source="terrain_type_y_scale"},<font></font>
	{name="highland_mountain_select", type="select", low="highland_terrain", high="mountain_terrain", control="terrain_type_cache", threshold=0.55, falloff=0.2},<font></font>
	{name="highland_lowland_select", type="select", low="lowland_terrain", high="highland_mountain_select", control="terrain_type_cache", threshold=0.25, falloff=0.15},<font></font>
	{name="highland_lowland_select_cache", type="cache", source="highland_lowland_select"},<font></font>
	{name="ground_select", type="select", low=0, high=1, threshold=0.5, control="highland_lowland_select_cache"},<font></font>
	<font></font>
	{name="cave_attenuate_bias", type="bias", source="highland_lowland_select_cache", bias=0.45},<font></font>
	{name="cave_shape1", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
	{name="cave_shape2", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
	{name="cave_shape_attenuate", type="combiner", operation=anl.MULT, source_0="cave_shape1", source_1="cave_attenuate_bias", source_2="cave_shape2"},             <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "cave_perturb_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, frecuencia = 3},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "cave_perturb_scale", type = "scaleoffset", source = "cave_perturb_fractal", scale = 0.5, offset = 0},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "cave_perturb", type = "translateomain", source = "cave_shape_attenuate", tx = "cave_perturb_scale"},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "cave_select", type = "select", low = 1, high = 0, control = "cave_perturb", umbral = 0.48, falloff = 0},</font></font><font></font>
	<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "ground_cave_multiply", type = "combiner", operation = anl.MULT, source_0 = "cave_select", source_1 = "ground_select"}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ejemplos de resultados: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/484/3fa/8e9/4843fa8e95e46162345f36edcf767fbe.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b91/671/848/b91671848dac9a42f371d549adf07181.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece que algunas de las configuraciones requieren ajuste. </font><font style="vertical-align: inherit;">Puede valer la pena reducir la atenuaci√≥n o hacer que las cuevas sean m√°s delgadas, reduciendo el n√∫mero de octavas en el fractal del relieve, para que el relieve se vuelva m√°s suave, etc. ... Repito, todo depende del resultado que se desee obtener.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472574/">https://habr.com/ru/post/472574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472562/index.html">Tendencias financieras: las grandes empresas necesitan cada vez m√°s profesionales de TI</a></li>
<li><a href="../472566/index.html">El infierno personal del escritor Fraerman, o el cuento del primer amor</a></li>
<li><a href="../472568/index.html">Despliegue Apache Ignite Zero: ¬øexactamente cero?</a></li>
<li><a href="../472570/index.html">Intel Xeon W Big Update</a></li>
<li><a href="../472572/index.html">DevOps y el caos: entrega de software en un mundo descentralizado</a></li>
<li><a href="../472576/index.html">XVI conferencia de desarrolladores de software libre o d√≥nde obtener contribuyentes gratuitos</a></li>
<li><a href="../472580/index.html">Gesti√≥n de servicios empresariales: por qu√© ampliar la gesti√≥n de servicios m√°s all√° de TI</a></li>
<li><a href="../472582/index.html">Historia de Internet: la computadora como dispositivo de comunicaci√≥n</a></li>
<li><a href="../472586/index.html">An√°lisis de altavoz: qu√© hay dentro y c√≥mo funciona</a></li>
<li><a href="../472588/index.html">Todo lo que quer√≠a saber sobre el p√©ndulo inverso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>