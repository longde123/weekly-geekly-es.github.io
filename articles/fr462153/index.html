<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👯 👐 🧤 Shaders de carte interactive Unity 👈🏼 🥘 🐾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce didacticiel concerne les cartes interactives et leur création dans Unity à l'aide de shaders. 

 Cet effet peut servir de base à des techniques plu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shaders de carte interactive Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462153/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/511/6a1/e02/5116a1e02debfaa58afe0cddf3b4c6c9.png" alt="image"></div><br>  Ce didacticiel concerne <strong>les cartes interactives</strong> et leur création dans Unity à l'aide de shaders. <br><br>  Cet effet peut servir de base à des techniques plus complexes, telles que les projections holographiques ou même une table de sable du film "Black Panther". <br><br>  Une inspiration pour ce tutoriel est le tweet publié par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Baran Kahyaoglu</a> , montrant un exemple de ce qu'il crée pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Mapbox</a> . <br><a name="habracut"></a><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1118609807844442112"></twitter-widget><blockquote class="twitter-tweet" data-lang="en_US" data-twitter-extracted-i1582359583439567046="true"><p lang="en" dir="ltr">  Rien de vraiment spécial cette fois, pas de magie shader / vfx, c'est juste une carte interactive (avec pan &amp; zoom) sur la même table / environnement. <br>  Il utilise le nouveau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">#Runity</a> HDRP, donc il a l'air très cool par rapport aux cartes top down ennuyeuses régulières.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">#gamedev</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">#madewithunity</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">#builtwithmapbox</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">#map</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pic.twitter.com/hUgZqfloUK</a> </p>  - Baran Kahyaoglu (@brnkhy) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">17 avril 2019</a> </blockquote><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1118610439049494540"></twitter-widget><blockquote class="twitter-tweet" data-lang="en_US" data-twitter-extracted-i1582359583439567046="true"><p lang="en" dir="ltr">  et même s'il n'y a rien de spécial à ce sujet, c'est tellement amusant de se déplacer parce qu'il a l'air bien. <br>  Il était difficile d'enregistrer en HD à cause du mouvement de la souris, mais en voici un de faible qualité.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pic.twitter.com/ileBzYwHO9</a> </p>  - Baran Kahyaoglu (@brnkhy) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">17 avril 2019</a> </blockquote><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  La scène (à l'exception de la carte) a été prise à partir de la démo du vaisseau spatial graphique à effet visuel Unity (voir ci-dessous), qui peut être téléchargée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">ici</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rqMcPZoEc3U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Partie 1. Décalage de sommet </h2><br><h2>  Anatomie de l'effet </h2><br>  La première chose que vous pouvez immédiatement remarquer est que les cartes géographiques sont <em>plates</em> : si elles sont utilisées comme textures, elles n'ont pas la tridimensionnalité qu'un véritable modèle 3D de la zone de carte correspondante aurait. <br><br>  Vous pouvez appliquer cette solution: créez un modèle 3D de la zone nécessaire dans le jeu, puis appliquez-y une texture de la carte.  Cela aidera à résoudre le problème, mais cela prend beaucoup de temps et ne permettra pas de réaliser l'effet de «défilement» de la vidéo Baran Kahyaoglu. <br><br>  De toute évidence, une approche plus technique est préférable.  Heureusement, les shaders peuvent être utilisés pour modifier la géométrie d'un modèle 3D.  Avec leur aide, vous pouvez transformer n'importe quel avion en vallées et montagnes de la région dont nous avons besoin. <br><br>  Dans ce tutoriel, nous utilisons une carte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">de Chillot</a> , Chilli, célèbre pour ses collines caractéristiques.  L'image ci-dessous montre la texture de la région tracée sur un maillage rond. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/b64/0a6/5a7b640a60ca2ce42c9d4ee3f5c95150.png" width="797" height="346"></div><br>  Bien que nous voyions des collines et des montagnes, elles sont encore complètement plates.  Cela détruit l'illusion du réalisme. <br><br><h2>  Extrusion de normales </h2><br>  La première étape pour utiliser des shaders pour changer la géométrie est une technique appelée <strong>extrusion normale</strong> .  Elle a besoin d' <strong>un modificateur de sommet</strong> : une fonction qui peut manipuler les sommets individuels d'un modèle 3D. <br><br>  La façon dont le modificateur de sommet est utilisé dépend du type de shader utilisé.  Dans ce didacticiel, nous allons modifier le <strong>Shader standard de surface</strong> - l'un des types de shaders que vous pouvez créer dans Unity. <br><br>  Il existe de nombreuses façons de manipuler les sommets d'un modèle 3D.  L'une des toutes premières méthodes décrites dans la plupart des didacticiels de vertex shader est l' <strong>extrusion de normales</strong> .  Elle consiste à repousser chaque sommet ( <em>extrusion</em> ), ce qui donne au modèle 3D un aspect plus gonflé.  «À l'extérieur» signifie que chaque sommet se déplace dans la direction de la normale. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/275/3e4/fe3/2753e4fe3502d77d46d7205e1ec81809.png"></div><br>  Pour les surfaces lisses, cela fonctionne très bien, mais dans les modèles avec de mauvaises connexions de vertex, cette méthode peut créer d'étranges artefacts.  Cet effet est bien expliqué dans l'un de mes premiers tutoriels: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Une introduction douce aux shaders</a> , où j'ai montré comment <strong>extruder</strong> et <strong>intruder un</strong> modèle 3D. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a8/668/0e5/5a86680e5ab92b536d4999e693aed8cb.gif" width="485" height="278"></div><br>  L'ajout de normales extrudées à un shader de surface est très facile.  Chaque shader de surface a une <code>#pragma</code> , qui est utilisée pour transmettre des informations et des commandes supplémentaires.  L'une de ces commandes est <code>vert</code> , ce qui signifie que la fonction <code>vert</code> sera utilisée pour traiter chaque sommet du modèle 3D. <br><br>  Le shader édité est le suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard fullforwardshadows addshadow vertex:vert ... float _Amount; ... void vert(inout appdata_base v) { v.vertex.xyz += v.normal * _Amount; }</span></span></code> </pre> <br>  Puisque nous <code>addshadow</code> la position des sommets, nous devons également utiliser <code>addshadow</code> si nous voulons que le modèle projette correctement des ombres sur lui-même. <br><br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce que appdata_base?</b> <div class="spoiler_text">  Comme vous pouvez le voir, nous avons ajouté une fonction de modificateur de sommets ( <code>vert</code> ), qui prend en paramètre une <em>structure</em> appelée <code>appdata_base</code> .  Cette structure stocke des informations sur chaque sommet individuel du modèle 3D.  Il contient non seulement <em>la position du sommet</em> ( <code>v.vertex</code> ), mais également d'autres champs, par exemple <em>, la direction normale</em> ( <code>v.normal</code> ) et <em>les informations de texture</em> associées au sommet ( <code>v.texcoord</code> ). <br><br>  Dans certains cas, cela ne suffit pas et nous pouvons avoir besoin d'autres propriétés, telles que la <em>couleur du sommet</em> ( <code>v.color</code> ) et la <em>direction tangente</em> ( <code>v.tangent</code> ).  Les modificateurs de sommet peuvent être spécifiés à l'aide d'une variété d'autres structures d' <code>appdata_tan</code> , y compris <code>appdata_tan</code> et <code>appdata_full</code> , qui fournissent plus d'informations au prix de faibles performances.  Vous pouvez en savoir plus sur <code>appdata</code> (et ses variantes) dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">wiki Unity3D</a> . </div></div><br><div class="spoiler">  <b class="spoiler_title">Comment les valeurs sont-elles renvoyées par vert?</b> <div class="spoiler_text">  La fonction supérieure n'a pas de valeur de retour.  Si vous connaissez le langage C #, vous devez savoir que les structures sont transmises par valeur, c'est-à-dire que lorsque <code>v.vertex</code> change <code>v.vertex</code> cela n'affecte que la copie de <code>v</code> , dont la portée est limitée par le corps de la fonction. <br><br>  Cependant, <code>v</code> également déclaré <code>inout</code> , ce qui signifie qu'il est utilisé à la fois pour l'entrée et la sortie.  Toute modification apportée change la variable elle-même, que nous transmettons à <code>vert</code> .  Les mots clés <code>inout</code> et <code>out</code> très souvent utilisés en infographie, et ils peuvent à peu près être corrélés avec <code>ref</code> et <code>out</code> en C #. </div></div><br><h2>  Extrusion de normales avec des textures </h2><br>  Le code que nous avons utilisé ci-dessus fonctionne correctement, mais il est loin de l'effet que nous voulons atteindre.  La raison en est que nous ne voulons pas extruder tous les sommets de la même quantité.  Nous voulons que la surface du modèle 3D corresponde aux vallées et montagnes de la région géographique correspondante.  Tout d'abord, nous devons en quelque sorte stocker et récupérer des informations sur la quantité de chaque point sur la carte qui est soulevée.  Nous voulons que l'extrusion soit influencée par la texture dans laquelle les hauteurs du paysage sont encodées.  Ces textures sont souvent appelées <strong>cartes de hauteur</strong> , mais souvent elles sont également appelées <strong>cartes de profondeur</strong> , selon le contexte.  Après avoir reçu des informations sur les hauteurs, nous pourrons modifier l'extrusion de l'avion en fonction de la carte des hauteurs.  Comme le montre le schéma, cela nous permettra de contrôler la montée et la descente des zones. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f3/223/118/0f32231186763ee73f27bde4a1d2c5bf.png"></div><br>  Il est assez simple de trouver une image satellite de la zone géographique qui vous intéresse et une carte d'élévation associée.  Voici la carte satellite de Mars (ci-dessus) et la carte d'altitude (ci-dessous) qui ont été utilisées dans ce tutoriel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b80/468/176/b804681769208dfc72ec69441d9f0986.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/266/f0c/b59/266f0cb59bb01a7f875d3323d526372a.png"></div><br>  J'ai parlé en détail du concept de la carte de profondeur dans une autre série de tutoriels intitulée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">"Photos 3D de Facebook de l'intérieur: shaders de parallaxe"</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction</a> en Habré]. <br><br>  Dans ce didacticiel, nous supposerons que la carte des hauteurs est stockée sous forme d'image en niveaux de gris, où le noir et le blanc correspondent à des hauteurs inférieures et supérieures.  Nous avons également besoin de ces valeurs pour une mise à l'échelle <em>linéaire</em> , c'est-à-dire que la différence de couleur, par exemple, à <code>0.1</code> correspond à une différence de hauteur entre <code>0</code> et <code>0.1</code> ou entre <code>0.9</code> et <code>1.0</code> .  Pour les cartes de profondeur, ce n'est pas toujours vrai, car beaucoup d'entre elles stockent des informations de profondeur à une <em>échelle logarithmique</em> . <br><br>  Pour échantillonner une texture, deux éléments d'information sont nécessaires: la texture elle-même et les <strong>coordonnées UV du</strong> point que nous voulons échantillonner.  Ce dernier est accessible via le champ <code>texcoord</code> , stocké dans la structure <code>appdata_base</code> .  Il s'agit de la coordonnée UV associée au sommet actuel en cours de traitement.  L'échantillonnage de texture dans une <em>fonction de surface</em> se fait à l'aide de <code>tex2D</code> , cependant lorsque nous sommes dans une <code> </code> , <code>tex2Dlod</code> est requis. <br><br>  Dans l'extrait de code ci-dessous, une texture appelée <code>_HeightMap</code> utilisée pour modifier la valeur d'extrusion effectuée pour chaque sommet: <br><br><pre> <code class="cpp hljs">sampler2D _HeightMap; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ fixed height = tex2Dlod(_HeightMap, float4(v.texcoord.xy, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += v.normal * height * _Amount; }</code> </pre> <br>  Pourquoi tex2D ne peut-il pas être utilisé comme fonction de sommet? <br>  Si vous regardez le code généré par Unity pour le Surface Shader standard, vous remarquerez qu'il contient déjà un exemple de la façon d'échantillonner des textures.  En particulier, il échantillonne la <em>texture principale</em> (appelée <code>_MainTex</code> ) dans une <em>fonction de surface</em> (appelée <code>surf</code> ) à l'aide de la fonction <code>tex2D</code> intégrée. <br><br>  Et en fait, <code>tex2D</code> utilisé pour échantillonner les pixels d'une texture, indépendamment de ce qui y est stocké, de sa couleur ou de sa hauteur.  Cependant, vous pouvez remarquer que <code>tex2D</code> ne peut pas être utilisé dans une fonction de sommet. <br><br>  La raison en est que <code>tex2D</code> <em>ne</em> lit <em>pas seulement les</em> pixels de la texture.  Elle décide également de la version de la texture à utiliser, en fonction de la distance à la caméra.  Cette technique est appelée <strong>mipmapping</strong> : elle vous permet d'avoir des versions plus petites d'une seule texture qui peuvent être utilisées automatiquement à différentes distances. <br><br>  Dans la fonction de surface, le shader sait déjà quelle <strong>texture MIP</strong> utiliser.  Ces informations peuvent ne pas encore être disponibles dans la fonction vertex, et par conséquent <code>tex2D</code> ne peut pas être utilisé en toute confiance.  Contrairement à cela, la fonction <code>tex2Dlod</code> peut recevoir deux paramètres supplémentaires, qui dans ce didacticiel peuvent avoir une valeur nulle. <br><br>  Le résultat est clairement visible dans les images ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/b64/0a6/5a7b640a60ca2ce42c9d4ee3f5c95150.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0b/dbf/dad/c0bdbfdadf38764dd3d75ffb69d07dea.png"></div><br>  Dans ce cas, une légère simplification peut être apportée.  Le code que nous avons examiné précédemment peut fonctionner avec n'importe quelle géométrie.  Cependant, nous pouvons supposer que la surface est absolument plate.  En fait, nous voulons vraiment appliquer cet effet au plan. <br><br>  Par conséquent, vous pouvez supprimer <code>v.normal</code> et le remplacer par <code>float3(0, 1, 0)</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ float3 normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); fixed height = tex2Dlod(_HeightMap, float4(v.texcoord.xy, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += normal * height * _Amount; }</code> </pre> <br>  Nous pourrions le faire car toutes les coordonnées dans <code>appdata_base</code> sont stockées dans <strong>l'espace modèle</strong> , c'est-à-dire qu'elles sont définies par rapport au centre et à l'orientation du modèle 3D.  La transition, la rotation et la mise à l'échelle avec <em>transformation</em> dans Unity modifient la position, la rotation et l'échelle de l'objet, mais n'affectent pas le modèle 3D d'origine. <br><br><h2>  Partie 2. Effet de défilement </h2><br>  Tout ce que nous avons fait ci-dessus fonctionne plutôt bien.  Avant de continuer, nous allons extraire le code nécessaire pour calculer la nouvelle hauteur de sommet dans une fonction <code>getVertex</code> distincte: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float4 vertex, float2 texcoord)</span></span></span><span class="hljs-function"> </span></span>{ float3 normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); fixed height = tex2Dlod(_HeightMap, float4(texcoord, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += normal * height * _Amount; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vertex; }</code> </pre> <br>  Ensuite, toute la fonction <code>vert</code> aura la forme: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ vertex = getVertex(v.vertex, v.texcoord.xy); }</code> </pre> <br>  Nous l'avons fait car ci-dessous, nous devons calculer la hauteur de plusieurs points.  En raison du fait que cette fonctionnalité sera dans sa propre fonction distincte, le code deviendra beaucoup plus simple. <br><br><h2>  Calcul des coordonnées UV </h2><br>  Cependant, cela nous amène à un autre problème.  La fonction <code>getVertex</code> dépend non seulement de la position du sommet actuel (v.vertex), mais aussi de ses coordonnées UV ( <code>v.texcoord</code> ). <br><br>  Lorsque nous voulons calculer le décalage de hauteur de sommet que la fonction <code>vert</code> traite actuellement, les deux éléments de données sont disponibles dans la structure <code>appdata_base</code> .  Cependant, que se passe-t-il si nous devons échantillonner la position d'un point voisin?  Dans ce cas, nous pouvons connaître la position xyz dans <strong>l'espace du modèle</strong> , mais nous n'avons pas accès à ses coordonnées UV. <br><br>  Cela signifie que le système existant est capable de calculer le décalage de hauteur uniquement pour le sommet actuel.  Une telle restriction ne nous permettra pas d'avancer, nous devons donc trouver une solution. <br><br>  Le moyen le plus simple est de trouver un moyen de calculer les coordonnées UV d'un objet 3D, en connaissant la position de son sommet.  C'est une tâche très difficile, et il existe plusieurs techniques pour la résoudre (l'une des plus populaires est la <strong>projection triplanaire</strong> ).  Mais dans ce cas particulier, nous n'avons pas besoin de faire correspondre UV et géométrie.  Si nous supposons que le shader sera toujours appliqué au maillage plat, la tâche devient triviale. <br><br>  Nous pouvons calculer <em>les coordonnées UV</em> (image inférieure) à partir des <em>positions des sommets</em> (image supérieure) du fait que les deux sont superposés linéairement sur un maillage plat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/147/614/a7a/147614a7a05ba08700aef85be89f3a53.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/ff8/c42/02fff8c42dae9fa7de4f7e9598843afe.png" width="359" height="210"></div><br>  Cela signifie que pour résoudre notre problème, nous devons transformer les <em>composantes XZ de</em> <em>la position du sommet</em> en <em>coordonnées UV</em> correspondantes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48a/607/6b0/48a6076b06650e1074dd5b0f2f7ed023.png" width="363" height="393"></div><br>  Cette procédure est appelée <strong>interpolation linéaire</strong> .  Il est discuté en détail sur mon site Web (par exemple: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">The Secrets Of Color Interpolation</a> ). <br><br>  Dans la plupart des cas, les valeurs UV sont comprises entre <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mn" id="MJXp-Span-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMAIN-30" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> 0 </script>  avant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mn" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMAIN-31" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> 1 </script>  ;  les coordonnées de chaque sommet, en revanche, sont potentiellement illimitées.  Du point de vue des mathématiques, pour la conversion de XZ en UV, nous n'avons besoin que de leurs valeurs limites: <br><br><ul><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-msubsup" id="MJXp-Span-6"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-8" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.153ex" height="2.419ex" viewBox="0 -780.1 2218.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-6E" x="1224" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-3"> X_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-12"><span class="MJXp-msubsup" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-15" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.409ex" height="2.419ex" viewBox="0 -780.1 2328.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-78" x="1408" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-4"> X_ {max} </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-19"><span class="MJXp-msubsup" id="MJXp-Span-20"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-22" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-25"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.816ex" height="2.419ex" viewBox="0 -780.1 2073.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-5A" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-6E" x="1224" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-5"> Z_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-26"><span class="MJXp-msubsup" id="MJXp-Span-27"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-29" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.072ex" height="2.419ex" viewBox="0 -780.1 2183.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-5A" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-78" x="1408" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-6"> Z_ {max} </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-33"><span class="MJXp-msubsup" id="MJXp-Span-34"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-36" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.816ex" height="2.419ex" viewBox="0 -780.1 2073.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-6E" x="1224" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-7"> U_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-40"><span class="MJXp-msubsup" id="MJXp-Span-41"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-42" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-43" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-44"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.072ex" height="2.419ex" viewBox="0 -780.1 2183.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-78" x="1408" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-8"> U_ {max} </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-47"><span class="MJXp-msubsup" id="MJXp-Span-48"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-50" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-53"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> V_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-54"><span class="MJXp-msubsup" id="MJXp-Span-55"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-57" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-60"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> V_ {max} </script></li></ul><br>  qui sont indiqués ci-dessous: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87a/520/05c/87a52005ccc02b02403068fd3e075864.png" width="359" height="210"></div><br>  Ces valeurs varient en fonction du maillage utilisé.  Sur le plan Unity, les <em>coordonnées UV</em> sont comprises entre <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-61"><span class="MJXp-mn" id="MJXp-Span-62"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> 0 </script>  avant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-63"><span class="MJXp-mn" id="MJXp-Span-64"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> 1 </script>  et les <em>coordonnées des sommets</em> sont comprises entre <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-65"><span class="MJXp-mo" id="MJXp-Span-66" style="margin-left: 0em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mn" id="MJXp-Span-67"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> -5 </script>  avant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-68"><span class="MJXp-mo" id="MJXp-Span-69" style="margin-left: 0em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-70"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> + 5 </script>  . <br><br>  Les équations pour convertir XZ en UV sont: <br><br>  (1) <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d2/e5c/a22/7d2e5ca229d8fc1c135aaa42e863fc9c.svg" alt="image"></div><br><br><div class="spoiler">  <b class="spoiler_title">Comment sont-ils affichés?</b> <div class="spoiler_text">  Si vous n'êtes pas familier avec le concept d'interpolation linéaire, ces équations peuvent sembler assez intimidantes. <br><br>  Cependant, ils sont affichés tout simplement.  Regardons juste un exemple. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-71"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-72">U</span></span></span><script type="math/tex" id="MathJax-Element-15"> U </script>  .  Nous avons deux intervalles: l'un a des valeurs de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-73"><span class="MJXp-msubsup" id="MJXp-Span-74"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-75" style="margin-right: 0.05em;">X</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-76" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-78">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-79">n</span></span></span></span></span><script type="math/tex" id="MathJax-Element-16"> X_ {min} </script>  avant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-80"><span class="MJXp-msubsup" id="MJXp-Span-81"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82" style="margin-right: 0.05em;">X</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-83" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-84">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-86">x</span></span></span></span></span><script type="math/tex" id="MathJax-Element-17"> X_ {max} </script>  un autre de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-87"><span class="MJXp-msubsup" id="MJXp-Span-88"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-89" style="margin-right: 0.05em;">U</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-90" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-91">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-92">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-93">n</span></span></span></span></span><script type="math/tex" id="MathJax-Element-18"> U_ {min} </script>  avant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-94"><span class="MJXp-msubsup" id="MJXp-Span-95"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-96" style="margin-right: 0.05em;">U</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-97" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-100">x</span></span></span></span></span><script type="math/tex" id="MathJax-Element-19"> U_ {max} </script>  .  Données entrantes pour les coordonnées <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-101"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-102">X</span></span></span><script type="math/tex" id="MathJax-Element-20"> X </script>  est la coordonnée du sommet en cours de traitement, et la sortie sera la coordonnée <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-103"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-104">U</span></span></span><script type="math/tex" id="MathJax-Element-21"> U </script>  utilisé pour échantillonner la texture. <br><br>  Nous devons maintenir la proportionnalité entre <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-105"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-106">X</span></span></span><script type="math/tex" id="MathJax-Element-22"> X </script>  et son intervalle, et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-107"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-108">U</span></span></span><script type="math/tex" id="MathJax-Element-23"> U </script>  et son intervalle.  Par exemple, si <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-109"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-110">X</span></span></span><script type="math/tex" id="MathJax-Element-24"> X </script>  compte alors 25% de son intervalle <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-111"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-112">U</span></span></span><script type="math/tex" id="MathJax-Element-25"> U </script>  comptera également pour 25% de son intervalle. <br><br>  Tout cela est illustré dans le diagramme suivant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/784/da1/22a784da18e327b20b872699a901f0ec.png" width="292" height="202"></div><br>  On peut en déduire que la proportion composée du segment rouge par rapport au rose doit être la même que la proportion entre le segment bleu et le bleu: <br><br>  (2) <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcc/9e1/49e/bcc9e149ea65e83dd70345dd92784788.png" height="39" width="232"></div><br>  Maintenant, nous pouvons transformer l'équation ci-dessus pour obtenir <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-113"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-114">U</span></span></span><script type="math/tex" id="MathJax-Element-26"> U </script>  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/737/266/0fe/7372660fe877b0780e4cebc97a6f22f2.png" height="85" width="388"></div><br>  et cette équation a exactement la même forme que celle montrée ci-dessus (1). </div></div><br>  Ces équations peuvent être implémentées dans le code comme suit: <br><br><pre> <code class="cpp hljs">float2 _VertexMin; float2 _VertexMax; float2 _UVMin; float2 _UVMax; <span class="hljs-function"><span class="hljs-function">float2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vertexToUV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float4 vertex)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (vertex.xz - _VertexMin) / (_VertexMax - _VertexMin) * (_UVMax - _UVMin) + _UVMin; }</code> </pre> <br>  Maintenant, nous pouvons appeler la fonction <code>getVertex</code> sans avoir à lui passer <code>v.texcoord</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float4 vertex)</span></span></span><span class="hljs-function"> </span></span>{ float3 normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); float2 texcoord = vertexToUV(vertex); fixed height = tex2Dlod(_HeightMap, float4(texcoord, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += normal * height * _Amount; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vertex; }</code> </pre> <br>  Alors la fonction entière <code>vert</code> prend la forme: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ v.vertex = getVertex(v.vertex); }</code> </pre> <br><h3>  Effet de défilement </h3><br>  Grâce au code que nous avons écrit, la carte entière est affichée sur le maillage.  Si nous voulons améliorer l'affichage, nous devons apporter des modifications. <br><br>  Formalisons un peu plus le code.  Premièrement, nous devrons peut-être zoomer sur une partie distincte de la carte, plutôt que de la regarder dans son ensemble. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b5/1c3/bcd/0b51c3bcd59365527d3659564768b01b.png" width="530" height="309"></div><br>  Cette zone peut être définie par deux valeurs: sa taille ( <code>_CropSize</code> ) et son emplacement sur la carte ( <code>_CropOffset</code> ), mesurés dans l' <em>espace des sommets</em> (de <code>_VertexMin</code> à <code>_VertexMax</code> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Cropping float2 _CropSize; float2 _CropOffset;</span></span></code> </pre> <br>  Après avoir reçu ces deux valeurs, nous pouvons à nouveau utiliser l'interpolation linéaire pour que <code>getVertex</code> appelé non pas pour la position actuelle du haut du modèle 3D, mais pour le point mis à l'échelle et transféré. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0c/620/418/c0c620418088c383addcaa54328fe0fc.png" width="529" height="589"></div><br>  Code pertinent: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ float2 croppedMin = _CropOffset; float2 croppedMax = croppedMin + _CropSize; <span class="hljs-comment"><span class="hljs-comment">// v.vertex.xz: [_VertexMin, _VertexMax] // cropped.xz : [croppedMin, croppedMax] float4 cropped = v.vertex; cropped.xz = (v.vertex.xz - _VertexMin) / (_VertexMax - _VertexMin) * (croppedMax - croppedMin) + croppedMin; v.vertex.y = getVertex(cropped); }</span></span></code> </pre> <br>  Si nous voulons faire défiler, il suffira de mettre à jour <code>_CropOffset</code> travers le script.  Pour cette raison, la zone de troncature se déplacera, faisant défiler le paysage. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MoveMap</span></span></span><span class="hljs-class"> :</span></span> MonoBehaviour { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Material Material; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 Speed; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 Offset; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CropOffsetID; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CropOffsetID = Shader.PropertyToID(<span class="hljs-string"><span class="hljs-string">"_CropOffset"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Material.SetVector(CropOffsetID, Speed * Time.time + Offset); } }</code> </pre> <br>  Pour que cela fonctionne, il est très important de définir le <strong>mode Wrap de</strong> toutes les textures sur <strong>Répéter</strong> .  Si cela n'est pas fait, nous ne pourrons pas boucler la texture. <br><br>  Pour l'effet zoom / zoom, il suffit de changer <code>_CropSize</code> . <br><br><h2>  Partie 3. Ombrage du terrain </h2><br><h2>  Ombrage plat </h2><br>  Tout le code que nous avons écrit fonctionne, mais a un sérieux problème.  L'ombrage du modèle est quelque peu étrange.  La surface est correctement courbée, mais réagit à la lumière comme si elle était plate. <br><br>  Cela se voit très clairement dans les images ci-dessous.  L'image du haut montre un shader existant;  le bas montre comment cela fonctionne réellement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0b/dbf/dad/c0bdbfdadf38764dd3d75ffb69d07dea.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/511/6a1/e02/5116a1e02debfaa58afe0cddf3b4c6c9.png"></div><br>  Résoudre ce problème peut être un grand défi.  Mais d'abord, nous devons déterminer quelle est l'erreur. <br><br>  L'opération d'extrusion normale a changé la géométrie générale du plan que nous avons utilisé initialement.  Cependant, Unity n'a modifié que la position des sommets, mais pas leurs directions normales.  <strong>La direction du</strong> sommet <strong>normal</strong> , comme son nom l'indique, est un vecteur de longueur unitaire ( <em>direction</em> ) indiquant la perpendiculaire à la surface.  <em>Les normales sont</em> nécessaires car elles jouent un rôle important dans l'ombrage d'un modèle 3D.  Ils sont utilisés par tous les shaders de surface pour calculer la manière dont la lumière doit être réfléchie par chaque triangle du modèle 3D.  Cela est généralement nécessaire pour améliorer la tridimensionnalité du modèle, par exemple, il fait rebondir la lumière sur une surface plane tout comme elle rebondirait sur une surface incurvée.  Cette astuce est souvent utilisée pour rendre les surfaces low-poly plus lisses qu'elles ne le sont réellement (voir ci-dessous). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6b/d7c/443/f6bd7c443381c1f0e133ee7b7bce05e1.png"></div><br>  Cependant, dans notre cas, c'est le contraire qui se produit.  La géométrie est courbe et lisse, mais comme toutes les normales sont dirigées vers le haut, la lumière est réfléchie par le modèle comme si elle était plate (voir ci-dessous): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/241/cde/323241cdef1b3a41604c579f4fdb509b.png"></div><br>  Vous pouvez en savoir plus sur le rôle des normales dans l'ombrage des objets dans l'article sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">mappage normal (Bump Mapping)</a> , où les cylindres identiques sont très différents, malgré le même modèle 3D, en raison de différentes méthodes de calcul des normales de sommet (voir ci-dessous). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b7/4fc/15f/1b74fc15f90516cc80b283953ef12373.png" width="315" height="243"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f93/544/d9c/f93544d9c95a70da71848897f0913676.png" width="347" height="254"></div><br>  Malheureusement, ni Unity ni le langage de création de shaders n'ont de solution intégrée pour recalculer automatiquement les normales.  Cela signifie que vous devez les modifier manuellement en fonction de la géométrie locale du modèle 3D. <br><br><h2>  Calcul normal </h2><br>  La seule façon de résoudre le problème de l'ombrage est de calculer manuellement les normales en fonction de la géométrie de la surface.  Une tâche similaire a été discutée dans un article de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Vertex Déplacement - Melting Shader Part 1</a> , où elle a été utilisée pour simuler la fusion de modèles 3D dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Cone Wars</a> . <br><br>  Bien que le code fini devra fonctionner en coordonnées 3D, limitons la tâche à seulement deux dimensions pour l'instant.  Imaginez que vous devez calculer la <strong>direction de la normale</strong> correspondant au point sur la courbe 2D (la grande flèche bleue dans le diagramme ci-dessous). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5a/405/6be/e5a4056be62b920d9721a84d7c050ee6.png" width="316" height="346"></div><br>  D'un point de vue géométrique, la <em>direction de la normale</em> (grosse flèche bleue) est un vecteur perpendiculaire à la <strong>tangente</strong> passant par le point qui nous intéresse (une fine ligne bleue).  <em>La tangente</em> peut être représentée comme une ligne située sur la courbure du modèle.  <strong>Un vecteur tangent</strong> est un <em>vecteur unitaire</em> qui repose sur une tangente. <br><br>  Cela signifie que pour calculer la normale, vous devez suivre deux étapes: premièrement, trouvez la ligne <em>tangente</em> au point souhaité;  puis calculez le vecteur perpendiculaire à celui-ci (qui sera la <em>direction</em> nécessaire <em>de la normale</em> ). <br><br><h3>  Calcul de la tangente </h3><br>  Pour obtenir la <em>normale,</em> nous devons d'abord calculer la <em>tangente</em> .  Il peut être approximé en échantillonnant un point à proximité et en l'utilisant pour construire une ligne près du sommet.  Plus la ligne est petite, plus la valeur est précise. <br><br>  Trois étapes sont nécessaires: <br><br><ul><li>  Étape 1. Déplacez une petite quantité sur une surface plane </li><li>  Étape 2. Calculez la hauteur du nouveau point. </li><li>  Étape 3. Utilisez la hauteur du point actuel pour calculer la tangente </li></ul><br>  Tout cela peut être vu dans l'image ci-dessous: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46f/bd3/7e8/46fbd37e868d16ff7ec6f1a164377018.png"></div><br>  Pour que cela fonctionne, nous devons calculer les hauteurs de deux points, pas d'un.  Heureusement, nous savons déjà comment procéder.  Dans la partie précédente du didacticiel, nous avons créé une fonction qui échantillonne la hauteur d'un paysage en fonction d'un point de maillage.  Nous l'avons appelé <code>getVertex</code> . <br><br>  Nous pouvons prendre la nouvelle valeur de sommet au point courant, puis à deux autres.  L'un sera pour la tangente, l'autre pour la tangente en deux points.  Avec leur aide, nous obtenons la normale.  Si le maillage d'origine utilisé pour créer l'effet est plat (et dans notre cas, il l'est), nous n'avons pas besoin d'accéder à <code>v.normal</code> et nous pouvons simplement utiliser <code>float3(0, 0, 1)</code> pour tangent et tangent à deux points, respectivement <code>float3(0, 0, 1)</code> et <code>float3(1, 0, 0)</code> .  Si nous voulions faire de même, mais, par exemple, pour une sphère, il serait beaucoup plus difficile de trouver deux points appropriés pour calculer la tangente et la tangente à deux points. <br><br><h3>  Illustrations vectorielles </h3><br>  Après avoir obtenu les vecteurs tangents et tangents appropriés à deux points, nous pouvons calculer la normale en utilisant une opération appelée <strong>produit vectoriel</strong> .  Il existe de nombreuses définitions et explications d'une œuvre vectorielle et de ce qu'elle fait. <br><br>  Un produit vectoriel reçoit deux vecteurs et renvoie un nouveau.  Si deux vecteurs initiaux étaient unitaires (leur longueur est égale à l'unité) et qu'ils sont situés à un angle de 90, alors le vecteur résultant sera situé à 90 degrés par rapport aux deux. <br><br>  Au début, cela peut être déroutant, mais graphiquement, il peut être représenté comme suit: le produit vectoriel de deux axes en crée un troisième.  C’est <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-115"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-116"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-118"><font style="vertical-align: inherit;">f </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119"><font style="vertical-align: inherit;">o </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-120"><font style="vertical-align: inherit;">i </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-121"><font style="vertical-align: inherit;">s </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-122"><font style="vertical-align: inherit;">Y </font></span><span class="MJXp-mo" id="MJXp-Span-123" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;">= </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-124"><font style="vertical-align: inherit;">Z</font></span></font><span class="MJXp-mtext" id="MJXp-Span-117">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-118"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-120"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-121"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-122"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-123" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-124"><font style="vertical-align: inherit;"></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-27"> X \ fois Y = Z </script>  mais aussi <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-125"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-126"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-128"><font style="vertical-align: inherit;">f </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-129"><font style="vertical-align: inherit;">o </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130"><font style="vertical-align: inherit;">i </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131"><font style="vertical-align: inherit;">s </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-132"><font style="vertical-align: inherit;">Z </font></span><span class="MJXp-mo" id="MJXp-Span-133" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;">= </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-134"><font style="vertical-align: inherit;">Y</font></span></font><span class="MJXp-mtext" id="MJXp-Span-127">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-128"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-129"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-132"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-133" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-134"><font style="vertical-align: inherit;"></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-28"> X \ fois Z = Y </script>  , et ainsi de suite. <br><br>  Si nous faisons un pas suffisamment petit (dans le code, c'est <code>offset</code> ), alors les vecteurs de la tangente et de la tangente à deux points seront à un angle de 90 degrés.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec le vecteur normal, ils forment trois axes perpendiculaires orientés le long de la surface du modèle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sachant cela, nous pouvons écrire tout le code nécessaire pour calculer et mettre à jour le vecteur normal.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ float3 bitangent = float3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); float3 tangent = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> offset = <span class="hljs-number"><span class="hljs-number">0.01</span></span>; float4 vertexBitangent = getVertex(v.vertex + float4(bitangent * offset, <span class="hljs-number"><span class="hljs-number">0</span></span>) ); float4 vertex = getVertex(v.vertex); float4 vertexTangent = getVertex(v.vertex + float4(tangent * offset, <span class="hljs-number"><span class="hljs-number">0</span></span>) ); float3 newBitangent = (vertexBitangent - vertex).xyz; float3 newTangent = (vertexTangent - vertex).xyz; v.normal = cross(newTangent, newBitangent); v.vertex.y = vertex.y; }</code> </pre> <br><h3>  Tout mettre ensemble </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant que tout fonctionne, nous pouvons retourner l'effet de défilement. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// v.vertex.xz: [_VertexMin, _VertexMax] // cropped.xz : [croppedMin, croppedMax] float2 croppedMin = _CropOffset; float2 croppedMax = croppedMin + _CropSize; float4 cropped = v.vertex; cropped.xz = (v.vertex.xz - _VertexMin) / (_VertexMax - _VertexMin) * (croppedMax - croppedMin) + croppedMin; float3 bitangent = float3(1, 0, 0); float3 normal = float3(0, 1, 0); float3 tangent = float3(0, 0, 1); float offset = 0.01; float4 vertexBitangent = getVertex(cropped + float4(bitangent * offset, 0) ); float4 vertex = getVertex(cropped); float4 vertexTangent = getVertex(cropped + float4(tangent * offset, 0) ); float3 newBitangent = (vertexBitangent - vertex).xyz; float3 newTangent = (vertexTangent - vertex).xyz; v.normal = cross(newTangent, newBitangent); v.vertex.y = vertex.y; v.texcoord = float4(vertexToUV(cropped), 0,0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et sur cela, notre effet est enfin terminé. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d9/b07/680/0d9b0768068b2329d53e22a71ff27dfb.gif" width="700" height="272"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Où aller ensuite </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce tutoriel peut devenir la base d'effets plus complexes, par exemple des projections holographiques ou même une copie de la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">table</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener"><font style="vertical-align: inherit;">sable</font></a><font style="vertical-align: inherit;"> du film "Black Panther".</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ecS1_-Y_uP8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Forfait Unity </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le package complet de ce tutoriel peut être téléchargé sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , il contient tous les actifs nécessaires pour jouer l'effet décrit.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462153/">https://habr.com/ru/post/fr462153/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462141/index.html">Panier pour un centre de données</a></li>
<li><a href="../fr462145/index.html">Pourquoi faut-il plusieurs jours pour se désinscrire?</a></li>
<li><a href="../fr462147/index.html">Utilisation de la navigation lors de la refactorisation d'un héritage de projet dans React Native</a></li>
<li><a href="../fr462149/index.html">Mode de restriction d'accès pour les accessoires sur les appareils iOS et comment le contourner</a></li>
<li><a href="../fr462151/index.html">5 principales distributions Kubernetes</a></li>
<li><a href="../fr462155/index.html">Travaillez avec Worker «comme vous le souhaitez», pas «autant que possible»</a></li>
<li><a href="../fr462159/index.html">Construire un système de reconnaissance faciale basé sur Golang et OpenCV</a></li>
<li><a href="../fr462161/index.html">Expérience d'installation d'Apache Airflow sur Windows 10</a></li>
<li><a href="../fr462163/index.html">Des technologies qui seront populaires en 2020</a></li>
<li><a href="../fr462165/index.html">Comment 25 personnes ont été amenées à travailler pour une société de jeux inexistante</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>