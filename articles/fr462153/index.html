<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëØ üëê üß§ Shaders de carte interactive Unity üëàüèº ü•ò üêæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce didacticiel concerne les cartes interactives et leur cr√©ation dans Unity √† l'aide de shaders. 

 Cet effet peut servir de base √† des techniques plu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shaders de carte interactive Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462153/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/511/6a1/e02/5116a1e02debfaa58afe0cddf3b4c6c9.png" alt="image"></div><br>  Ce didacticiel concerne <strong>les cartes interactives</strong> et leur cr√©ation dans Unity √† l'aide de shaders. <br><br>  Cet effet peut servir de base √† des techniques plus complexes, telles que les projections holographiques ou m√™me une table de sable du film "Black Panther". <br><br>  Une inspiration pour ce tutoriel est le tweet publi√© par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Baran Kahyaoglu</a> , montrant un exemple de ce qu'il cr√©e pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Mapbox</a> . <br><a name="habracut"></a><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1118609807844442112"></twitter-widget><blockquote class="twitter-tweet" data-lang="en_US" data-twitter-extracted-i1582359583439567046="true"><p lang="en" dir="ltr">  Rien de vraiment sp√©cial cette fois, pas de magie shader / vfx, c'est juste une carte interactive (avec pan &amp; zoom) sur la m√™me table / environnement. <br>  Il utilise le nouveau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">#Runity</a> HDRP, donc il a l'air tr√®s cool par rapport aux cartes top down ennuyeuses r√©guli√®res.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">#gamedev</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">#madewithunity</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">#builtwithmapbox</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">#map</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pic.twitter.com/hUgZqfloUK</a> </p>  - Baran Kahyaoglu (@brnkhy) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">17 avril 2019</a> </blockquote><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1118610439049494540"></twitter-widget><blockquote class="twitter-tweet" data-lang="en_US" data-twitter-extracted-i1582359583439567046="true"><p lang="en" dir="ltr">  et m√™me s'il n'y a rien de sp√©cial √† ce sujet, c'est tellement amusant de se d√©placer parce qu'il a l'air bien. <br>  Il √©tait difficile d'enregistrer en HD √† cause du mouvement de la souris, mais en voici un de faible qualit√©.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pic.twitter.com/ileBzYwHO9</a> </p>  - Baran Kahyaoglu (@brnkhy) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">17 avril 2019</a> </blockquote><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  La sc√®ne (√† l'exception de la carte) a √©t√© prise √† partir de la d√©mo du vaisseau spatial graphique √† effet visuel Unity (voir ci-dessous), qui peut √™tre t√©l√©charg√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">ici</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rqMcPZoEc3U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Partie 1. D√©calage de sommet </h2><br><h2>  Anatomie de l'effet </h2><br>  La premi√®re chose que vous pouvez imm√©diatement remarquer est que les cartes g√©ographiques sont <em>plates</em> : si elles sont utilis√©es comme textures, elles n'ont pas la tridimensionnalit√© qu'un v√©ritable mod√®le 3D de la zone de carte correspondante aurait. <br><br>  Vous pouvez appliquer cette solution: cr√©ez un mod√®le 3D de la zone n√©cessaire dans le jeu, puis appliquez-y une texture de la carte.  Cela aidera √† r√©soudre le probl√®me, mais cela prend beaucoup de temps et ne permettra pas de r√©aliser l'effet de ¬´d√©filement¬ª de la vid√©o Baran Kahyaoglu. <br><br>  De toute √©vidence, une approche plus technique est pr√©f√©rable.  Heureusement, les shaders peuvent √™tre utilis√©s pour modifier la g√©om√©trie d'un mod√®le 3D.  Avec leur aide, vous pouvez transformer n'importe quel avion en vall√©es et montagnes de la r√©gion dont nous avons besoin. <br><br>  Dans ce tutoriel, nous utilisons une carte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">de Chillot</a> , Chilli, c√©l√®bre pour ses collines caract√©ristiques.  L'image ci-dessous montre la texture de la r√©gion trac√©e sur un maillage rond. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/b64/0a6/5a7b640a60ca2ce42c9d4ee3f5c95150.png" width="797" height="346"></div><br>  Bien que nous voyions des collines et des montagnes, elles sont encore compl√®tement plates.  Cela d√©truit l'illusion du r√©alisme. <br><br><h2>  Extrusion de normales </h2><br>  La premi√®re √©tape pour utiliser des shaders pour changer la g√©om√©trie est une technique appel√©e <strong>extrusion normale</strong> .  Elle a besoin d' <strong>un modificateur de sommet</strong> : une fonction qui peut manipuler les sommets individuels d'un mod√®le 3D. <br><br>  La fa√ßon dont le modificateur de sommet est utilis√© d√©pend du type de shader utilis√©.  Dans ce didacticiel, nous allons modifier le <strong>Shader standard de surface</strong> - l'un des types de shaders que vous pouvez cr√©er dans Unity. <br><br>  Il existe de nombreuses fa√ßons de manipuler les sommets d'un mod√®le 3D.  L'une des toutes premi√®res m√©thodes d√©crites dans la plupart des didacticiels de vertex shader est l' <strong>extrusion de normales</strong> .  Elle consiste √† repousser chaque sommet ( <em>extrusion</em> ), ce qui donne au mod√®le 3D un aspect plus gonfl√©.  ¬´√Ä l'ext√©rieur¬ª signifie que chaque sommet se d√©place dans la direction de la normale. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/275/3e4/fe3/2753e4fe3502d77d46d7205e1ec81809.png"></div><br>  Pour les surfaces lisses, cela fonctionne tr√®s bien, mais dans les mod√®les avec de mauvaises connexions de vertex, cette m√©thode peut cr√©er d'√©tranges artefacts.  Cet effet est bien expliqu√© dans l'un de mes premiers tutoriels: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Une introduction douce aux shaders</a> , o√π j'ai montr√© comment <strong>extruder</strong> et <strong>intruder un</strong> mod√®le 3D. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a8/668/0e5/5a86680e5ab92b536d4999e693aed8cb.gif" width="485" height="278"></div><br>  L'ajout de normales extrud√©es √† un shader de surface est tr√®s facile.  Chaque shader de surface a une <code>#pragma</code> , qui est utilis√©e pour transmettre des informations et des commandes suppl√©mentaires.  L'une de ces commandes est <code>vert</code> , ce qui signifie que la fonction <code>vert</code> sera utilis√©e pour traiter chaque sommet du mod√®le 3D. <br><br>  Le shader √©dit√© est le suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard fullforwardshadows addshadow vertex:vert ... float _Amount; ... void vert(inout appdata_base v) { v.vertex.xyz += v.normal * _Amount; }</span></span></code> </pre> <br>  Puisque nous <code>addshadow</code> la position des sommets, nous devons √©galement utiliser <code>addshadow</code> si nous voulons que le mod√®le projette correctement des ombres sur lui-m√™me. <br><br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce que appdata_base?</b> <div class="spoiler_text">  Comme vous pouvez le voir, nous avons ajout√© une fonction de modificateur de sommets ( <code>vert</code> ), qui prend en param√®tre une <em>structure</em> appel√©e <code>appdata_base</code> .  Cette structure stocke des informations sur chaque sommet individuel du mod√®le 3D.  Il contient non seulement <em>la position du sommet</em> ( <code>v.vertex</code> ), mais √©galement d'autres champs, par exemple <em>, la direction normale</em> ( <code>v.normal</code> ) et <em>les informations de texture</em> associ√©es au sommet ( <code>v.texcoord</code> ). <br><br>  Dans certains cas, cela ne suffit pas et nous pouvons avoir besoin d'autres propri√©t√©s, telles que la <em>couleur du sommet</em> ( <code>v.color</code> ) et la <em>direction tangente</em> ( <code>v.tangent</code> ).  Les modificateurs de sommet peuvent √™tre sp√©cifi√©s √† l'aide d'une vari√©t√© d'autres structures d' <code>appdata_tan</code> , y compris <code>appdata_tan</code> et <code>appdata_full</code> , qui fournissent plus d'informations au prix de faibles performances.  Vous pouvez en savoir plus sur <code>appdata</code> (et ses variantes) dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">wiki Unity3D</a> . </div></div><br><div class="spoiler">  <b class="spoiler_title">Comment les valeurs sont-elles renvoy√©es par vert?</b> <div class="spoiler_text">  La fonction sup√©rieure n'a pas de valeur de retour.  Si vous connaissez le langage C #, vous devez savoir que les structures sont transmises par valeur, c'est-√†-dire que lorsque <code>v.vertex</code> change <code>v.vertex</code> cela n'affecte que la copie de <code>v</code> , dont la port√©e est limit√©e par le corps de la fonction. <br><br>  Cependant, <code>v</code> √©galement d√©clar√© <code>inout</code> , ce qui signifie qu'il est utilis√© √† la fois pour l'entr√©e et la sortie.  Toute modification apport√©e change la variable elle-m√™me, que nous transmettons √† <code>vert</code> .  Les mots cl√©s <code>inout</code> et <code>out</code> tr√®s souvent utilis√©s en infographie, et ils peuvent √† peu pr√®s √™tre corr√©l√©s avec <code>ref</code> et <code>out</code> en C #. </div></div><br><h2>  Extrusion de normales avec des textures </h2><br>  Le code que nous avons utilis√© ci-dessus fonctionne correctement, mais il est loin de l'effet que nous voulons atteindre.  La raison en est que nous ne voulons pas extruder tous les sommets de la m√™me quantit√©.  Nous voulons que la surface du mod√®le 3D corresponde aux vall√©es et montagnes de la r√©gion g√©ographique correspondante.  Tout d'abord, nous devons en quelque sorte stocker et r√©cup√©rer des informations sur la quantit√© de chaque point sur la carte qui est soulev√©e.  Nous voulons que l'extrusion soit influenc√©e par la texture dans laquelle les hauteurs du paysage sont encod√©es.  Ces textures sont souvent appel√©es <strong>cartes de hauteur</strong> , mais souvent elles sont √©galement appel√©es <strong>cartes de profondeur</strong> , selon le contexte.  Apr√®s avoir re√ßu des informations sur les hauteurs, nous pourrons modifier l'extrusion de l'avion en fonction de la carte des hauteurs.  Comme le montre le sch√©ma, cela nous permettra de contr√¥ler la mont√©e et la descente des zones. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f3/223/118/0f32231186763ee73f27bde4a1d2c5bf.png"></div><br>  Il est assez simple de trouver une image satellite de la zone g√©ographique qui vous int√©resse et une carte d'√©l√©vation associ√©e.  Voici la carte satellite de Mars (ci-dessus) et la carte d'altitude (ci-dessous) qui ont √©t√© utilis√©es dans ce tutoriel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b80/468/176/b804681769208dfc72ec69441d9f0986.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/266/f0c/b59/266f0cb59bb01a7f875d3323d526372a.png"></div><br>  J'ai parl√© en d√©tail du concept de la carte de profondeur dans une autre s√©rie de tutoriels intitul√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">"Photos 3D de Facebook de l'int√©rieur: shaders de parallaxe"</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction</a> en Habr√©]. <br><br>  Dans ce didacticiel, nous supposerons que la carte des hauteurs est stock√©e sous forme d'image en niveaux de gris, o√π le noir et le blanc correspondent √† des hauteurs inf√©rieures et sup√©rieures.  Nous avons √©galement besoin de ces valeurs pour une mise √† l'√©chelle <em>lin√©aire</em> , c'est-√†-dire que la diff√©rence de couleur, par exemple, √† <code>0.1</code> correspond √† une diff√©rence de hauteur entre <code>0</code> et <code>0.1</code> ou entre <code>0.9</code> et <code>1.0</code> .  Pour les cartes de profondeur, ce n'est pas toujours vrai, car beaucoup d'entre elles stockent des informations de profondeur √† une <em>√©chelle logarithmique</em> . <br><br>  Pour √©chantillonner une texture, deux √©l√©ments d'information sont n√©cessaires: la texture elle-m√™me et les <strong>coordonn√©es UV du</strong> point que nous voulons √©chantillonner.  Ce dernier est accessible via le champ <code>texcoord</code> , stock√© dans la structure <code>appdata_base</code> .  Il s'agit de la coordonn√©e UV associ√©e au sommet actuel en cours de traitement.  L'√©chantillonnage de texture dans une <em>fonction de surface</em> se fait √† l'aide de <code>tex2D</code> , cependant lorsque nous sommes dans une <code> </code> , <code>tex2Dlod</code> est requis. <br><br>  Dans l'extrait de code ci-dessous, une texture appel√©e <code>_HeightMap</code> utilis√©e pour modifier la valeur d'extrusion effectu√©e pour chaque sommet: <br><br><pre> <code class="cpp hljs">sampler2D _HeightMap; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ fixed height = tex2Dlod(_HeightMap, float4(v.texcoord.xy, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += v.normal * height * _Amount; }</code> </pre> <br>  Pourquoi tex2D ne peut-il pas √™tre utilis√© comme fonction de sommet? <br>  Si vous regardez le code g√©n√©r√© par Unity pour le Surface Shader standard, vous remarquerez qu'il contient d√©j√† un exemple de la fa√ßon d'√©chantillonner des textures.  En particulier, il √©chantillonne la <em>texture principale</em> (appel√©e <code>_MainTex</code> ) dans une <em>fonction de surface</em> (appel√©e <code>surf</code> ) √† l'aide de la fonction <code>tex2D</code> int√©gr√©e. <br><br>  Et en fait, <code>tex2D</code> utilis√© pour √©chantillonner les pixels d'une texture, ind√©pendamment de ce qui y est stock√©, de sa couleur ou de sa hauteur.  Cependant, vous pouvez remarquer que <code>tex2D</code> ne peut pas √™tre utilis√© dans une fonction de sommet. <br><br>  La raison en est que <code>tex2D</code> <em>ne</em> lit <em>pas seulement les</em> pixels de la texture.  Elle d√©cide √©galement de la version de la texture √† utiliser, en fonction de la distance √† la cam√©ra.  Cette technique est appel√©e <strong>mipmapping</strong> : elle vous permet d'avoir des versions plus petites d'une seule texture qui peuvent √™tre utilis√©es automatiquement √† diff√©rentes distances. <br><br>  Dans la fonction de surface, le shader sait d√©j√† quelle <strong>texture MIP</strong> utiliser.  Ces informations peuvent ne pas encore √™tre disponibles dans la fonction vertex, et par cons√©quent <code>tex2D</code> ne peut pas √™tre utilis√© en toute confiance.  Contrairement √† cela, la fonction <code>tex2Dlod</code> peut recevoir deux param√®tres suppl√©mentaires, qui dans ce didacticiel peuvent avoir une valeur nulle. <br><br>  Le r√©sultat est clairement visible dans les images ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/b64/0a6/5a7b640a60ca2ce42c9d4ee3f5c95150.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0b/dbf/dad/c0bdbfdadf38764dd3d75ffb69d07dea.png"></div><br>  Dans ce cas, une l√©g√®re simplification peut √™tre apport√©e.  Le code que nous avons examin√© pr√©c√©demment peut fonctionner avec n'importe quelle g√©om√©trie.  Cependant, nous pouvons supposer que la surface est absolument plate.  En fait, nous voulons vraiment appliquer cet effet au plan. <br><br>  Par cons√©quent, vous pouvez supprimer <code>v.normal</code> et le remplacer par <code>float3(0, 1, 0)</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ float3 normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); fixed height = tex2Dlod(_HeightMap, float4(v.texcoord.xy, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += normal * height * _Amount; }</code> </pre> <br>  Nous pourrions le faire car toutes les coordonn√©es dans <code>appdata_base</code> sont stock√©es dans <strong>l'espace mod√®le</strong> , c'est-√†-dire qu'elles sont d√©finies par rapport au centre et √† l'orientation du mod√®le 3D.  La transition, la rotation et la mise √† l'√©chelle avec <em>transformation</em> dans Unity modifient la position, la rotation et l'√©chelle de l'objet, mais n'affectent pas le mod√®le 3D d'origine. <br><br><h2>  Partie 2. Effet de d√©filement </h2><br>  Tout ce que nous avons fait ci-dessus fonctionne plut√¥t bien.  Avant de continuer, nous allons extraire le code n√©cessaire pour calculer la nouvelle hauteur de sommet dans une fonction <code>getVertex</code> distincte: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float4 vertex, float2 texcoord)</span></span></span><span class="hljs-function"> </span></span>{ float3 normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); fixed height = tex2Dlod(_HeightMap, float4(texcoord, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += normal * height * _Amount; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vertex; }</code> </pre> <br>  Ensuite, toute la fonction <code>vert</code> aura la forme: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ vertex = getVertex(v.vertex, v.texcoord.xy); }</code> </pre> <br>  Nous l'avons fait car ci-dessous, nous devons calculer la hauteur de plusieurs points.  En raison du fait que cette fonctionnalit√© sera dans sa propre fonction distincte, le code deviendra beaucoup plus simple. <br><br><h2>  Calcul des coordonn√©es UV </h2><br>  Cependant, cela nous am√®ne √† un autre probl√®me.  La fonction <code>getVertex</code> d√©pend non seulement de la position du sommet actuel (v.vertex), mais aussi de ses coordonn√©es UV ( <code>v.texcoord</code> ). <br><br>  Lorsque nous voulons calculer le d√©calage de hauteur de sommet que la fonction <code>vert</code> traite actuellement, les deux √©l√©ments de donn√©es sont disponibles dans la structure <code>appdata_base</code> .  Cependant, que se passe-t-il si nous devons √©chantillonner la position d'un point voisin?  Dans ce cas, nous pouvons conna√Ætre la position xyz dans <strong>l'espace du mod√®le</strong> , mais nous n'avons pas acc√®s √† ses coordonn√©es UV. <br><br>  Cela signifie que le syst√®me existant est capable de calculer le d√©calage de hauteur uniquement pour le sommet actuel.  Une telle restriction ne nous permettra pas d'avancer, nous devons donc trouver une solution. <br><br>  Le moyen le plus simple est de trouver un moyen de calculer les coordonn√©es UV d'un objet 3D, en connaissant la position de son sommet.  C'est une t√¢che tr√®s difficile, et il existe plusieurs techniques pour la r√©soudre (l'une des plus populaires est la <strong>projection triplanaire</strong> ).  Mais dans ce cas particulier, nous n'avons pas besoin de faire correspondre UV et g√©om√©trie.  Si nous supposons que le shader sera toujours appliqu√© au maillage plat, la t√¢che devient triviale. <br><br>  Nous pouvons calculer <em>les coordonn√©es UV</em> (image inf√©rieure) √† partir des <em>positions des sommets</em> (image sup√©rieure) du fait que les deux sont superpos√©s lin√©airement sur un maillage plat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/147/614/a7a/147614a7a05ba08700aef85be89f3a53.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/ff8/c42/02fff8c42dae9fa7de4f7e9598843afe.png" width="359" height="210"></div><br>  Cela signifie que pour r√©soudre notre probl√®me, nous devons transformer les <em>composantes XZ de</em> <em>la position du sommet</em> en <em>coordonn√©es UV</em> correspondantes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48a/607/6b0/48a6076b06650e1074dd5b0f2f7ed023.png" width="363" height="393"></div><br>  Cette proc√©dure est appel√©e <strong>interpolation lin√©aire</strong> .  Il est discut√© en d√©tail sur mon site Web (par exemple: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">The Secrets Of Color Interpolation</a> ). <br><br>  Dans la plupart des cas, les valeurs UV sont comprises entre <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mn" id="MJXp-Span-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMAIN-30" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> 0 </script>  avant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mn" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMAIN-31" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> 1 </script>  ;  les coordonn√©es de chaque sommet, en revanche, sont potentiellement illimit√©es.  Du point de vue des math√©matiques, pour la conversion de XZ en UV, nous n'avons besoin que de leurs valeurs limites: <br><br><ul><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-msubsup" id="MJXp-Span-6"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-8" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.153ex" height="2.419ex" viewBox="0 -780.1 2218.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-6E" x="1224" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-3"> X_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-12"><span class="MJXp-msubsup" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-15" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.409ex" height="2.419ex" viewBox="0 -780.1 2328.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-78" x="1408" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-4"> X_ {max} </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-19"><span class="MJXp-msubsup" id="MJXp-Span-20"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-22" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-25"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.816ex" height="2.419ex" viewBox="0 -780.1 2073.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-5A" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-6E" x="1224" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-5"> Z_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-26"><span class="MJXp-msubsup" id="MJXp-Span-27"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-29" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.072ex" height="2.419ex" viewBox="0 -780.1 2183.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-5A" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-78" x="1408" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-6"> Z_ {max} </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-33"><span class="MJXp-msubsup" id="MJXp-Span-34"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-36" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.816ex" height="2.419ex" viewBox="0 -780.1 2073.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-6E" x="1224" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-7"> U_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-40"><span class="MJXp-msubsup" id="MJXp-Span-41"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-42" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-43" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-44"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.072ex" height="2.419ex" viewBox="0 -780.1 2183.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhhzWyXXBIp5oT2BczXgNv9bDwKrxA#MJMATHI-78" x="1408" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-8"> U_ {max} </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-47"><span class="MJXp-msubsup" id="MJXp-Span-48"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-50" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-53"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> V_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-54"><span class="MJXp-msubsup" id="MJXp-Span-55"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-57" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-60"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> V_ {max} </script></li></ul><br>  qui sont indiqu√©s ci-dessous: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87a/520/05c/87a52005ccc02b02403068fd3e075864.png" width="359" height="210"></div><br>  Ces valeurs varient en fonction du maillage utilis√©.  Sur le plan Unity, les <em>coordonn√©es UV</em> sont comprises entre <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-61"><span class="MJXp-mn" id="MJXp-Span-62"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> 0 </script>  avant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-63"><span class="MJXp-mn" id="MJXp-Span-64"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> 1 </script>  et les <em>coordonn√©es des sommets</em> sont comprises entre <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-65"><span class="MJXp-mo" id="MJXp-Span-66" style="margin-left: 0em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mn" id="MJXp-Span-67"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> -5 </script>  avant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-68"><span class="MJXp-mo" id="MJXp-Span-69" style="margin-left: 0em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-70"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> + 5 </script>  . <br><br>  Les √©quations pour convertir XZ en UV sont: <br><br>  (1) <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d2/e5c/a22/7d2e5ca229d8fc1c135aaa42e863fc9c.svg" alt="image"></div><br><br><div class="spoiler">  <b class="spoiler_title">Comment sont-ils affich√©s?</b> <div class="spoiler_text">  Si vous n'√™tes pas familier avec le concept d'interpolation lin√©aire, ces √©quations peuvent sembler assez intimidantes. <br><br>  Cependant, ils sont affich√©s tout simplement.  Regardons juste un exemple. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-71"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-72">U</span></span></span><script type="math/tex" id="MathJax-Element-15"> U </script>  .  Nous avons deux intervalles: l'un a des valeurs de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-73"><span class="MJXp-msubsup" id="MJXp-Span-74"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-75" style="margin-right: 0.05em;">X</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-76" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-78">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-79">n</span></span></span></span></span><script type="math/tex" id="MathJax-Element-16"> X_ {min} </script>  avant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-80"><span class="MJXp-msubsup" id="MJXp-Span-81"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82" style="margin-right: 0.05em;">X</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-83" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-84">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-86">x</span></span></span></span></span><script type="math/tex" id="MathJax-Element-17"> X_ {max} </script>  un autre de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-87"><span class="MJXp-msubsup" id="MJXp-Span-88"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-89" style="margin-right: 0.05em;">U</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-90" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-91">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-92">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-93">n</span></span></span></span></span><script type="math/tex" id="MathJax-Element-18"> U_ {min} </script>  avant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-94"><span class="MJXp-msubsup" id="MJXp-Span-95"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-96" style="margin-right: 0.05em;">U</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-97" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-100">x</span></span></span></span></span><script type="math/tex" id="MathJax-Element-19"> U_ {max} </script>  .  Donn√©es entrantes pour les coordonn√©es <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-101"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-102">X</span></span></span><script type="math/tex" id="MathJax-Element-20"> X </script>  est la coordonn√©e du sommet en cours de traitement, et la sortie sera la coordonn√©e <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-103"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-104">U</span></span></span><script type="math/tex" id="MathJax-Element-21"> U </script>  utilis√© pour √©chantillonner la texture. <br><br>  Nous devons maintenir la proportionnalit√© entre <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-105"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-106">X</span></span></span><script type="math/tex" id="MathJax-Element-22"> X </script>  et son intervalle, et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-107"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-108">U</span></span></span><script type="math/tex" id="MathJax-Element-23"> U </script>  et son intervalle.  Par exemple, si <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-109"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-110">X</span></span></span><script type="math/tex" id="MathJax-Element-24"> X </script>  compte alors 25% de son intervalle <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-111"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-112">U</span></span></span><script type="math/tex" id="MathJax-Element-25"> U </script>  comptera √©galement pour 25% de son intervalle. <br><br>  Tout cela est illustr√© dans le diagramme suivant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/784/da1/22a784da18e327b20b872699a901f0ec.png" width="292" height="202"></div><br>  On peut en d√©duire que la proportion compos√©e du segment rouge par rapport au rose doit √™tre la m√™me que la proportion entre le segment bleu et le bleu: <br><br>  (2) <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcc/9e1/49e/bcc9e149ea65e83dd70345dd92784788.png" height="39" width="232"></div><br>  Maintenant, nous pouvons transformer l'√©quation ci-dessus pour obtenir <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-113"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-114">U</span></span></span><script type="math/tex" id="MathJax-Element-26"> U </script>  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/737/266/0fe/7372660fe877b0780e4cebc97a6f22f2.png" height="85" width="388"></div><br>  et cette √©quation a exactement la m√™me forme que celle montr√©e ci-dessus (1). </div></div><br>  Ces √©quations peuvent √™tre impl√©ment√©es dans le code comme suit: <br><br><pre> <code class="cpp hljs">float2 _VertexMin; float2 _VertexMax; float2 _UVMin; float2 _UVMax; <span class="hljs-function"><span class="hljs-function">float2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vertexToUV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float4 vertex)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (vertex.xz - _VertexMin) / (_VertexMax - _VertexMin) * (_UVMax - _UVMin) + _UVMin; }</code> </pre> <br>  Maintenant, nous pouvons appeler la fonction <code>getVertex</code> sans avoir √† lui passer <code>v.texcoord</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float4 vertex)</span></span></span><span class="hljs-function"> </span></span>{ float3 normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); float2 texcoord = vertexToUV(vertex); fixed height = tex2Dlod(_HeightMap, float4(texcoord, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += normal * height * _Amount; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vertex; }</code> </pre> <br>  Alors la fonction enti√®re <code>vert</code> prend la forme: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ v.vertex = getVertex(v.vertex); }</code> </pre> <br><h3>  Effet de d√©filement </h3><br>  Gr√¢ce au code que nous avons √©crit, la carte enti√®re est affich√©e sur le maillage.  Si nous voulons am√©liorer l'affichage, nous devons apporter des modifications. <br><br>  Formalisons un peu plus le code.  Premi√®rement, nous devrons peut-√™tre zoomer sur une partie distincte de la carte, plut√¥t que de la regarder dans son ensemble. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b5/1c3/bcd/0b51c3bcd59365527d3659564768b01b.png" width="530" height="309"></div><br>  Cette zone peut √™tre d√©finie par deux valeurs: sa taille ( <code>_CropSize</code> ) et son emplacement sur la carte ( <code>_CropOffset</code> ), mesur√©s dans l' <em>espace des sommets</em> (de <code>_VertexMin</code> √† <code>_VertexMax</code> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Cropping float2 _CropSize; float2 _CropOffset;</span></span></code> </pre> <br>  Apr√®s avoir re√ßu ces deux valeurs, nous pouvons √† nouveau utiliser l'interpolation lin√©aire pour que <code>getVertex</code> appel√© non pas pour la position actuelle du haut du mod√®le 3D, mais pour le point mis √† l'√©chelle et transf√©r√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0c/620/418/c0c620418088c383addcaa54328fe0fc.png" width="529" height="589"></div><br>  Code pertinent: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ float2 croppedMin = _CropOffset; float2 croppedMax = croppedMin + _CropSize; <span class="hljs-comment"><span class="hljs-comment">// v.vertex.xz: [_VertexMin, _VertexMax] // cropped.xz : [croppedMin, croppedMax] float4 cropped = v.vertex; cropped.xz = (v.vertex.xz - _VertexMin) / (_VertexMax - _VertexMin) * (croppedMax - croppedMin) + croppedMin; v.vertex.y = getVertex(cropped); }</span></span></code> </pre> <br>  Si nous voulons faire d√©filer, il suffira de mettre √† jour <code>_CropOffset</code> travers le script.  Pour cette raison, la zone de troncature se d√©placera, faisant d√©filer le paysage. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MoveMap</span></span></span><span class="hljs-class"> :</span></span> MonoBehaviour { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Material Material; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 Speed; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 Offset; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CropOffsetID; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CropOffsetID = Shader.PropertyToID(<span class="hljs-string"><span class="hljs-string">"_CropOffset"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Material.SetVector(CropOffsetID, Speed * Time.time + Offset); } }</code> </pre> <br>  Pour que cela fonctionne, il est tr√®s important de d√©finir le <strong>mode Wrap de</strong> toutes les textures sur <strong>R√©p√©ter</strong> .  Si cela n'est pas fait, nous ne pourrons pas boucler la texture. <br><br>  Pour l'effet zoom / zoom, il suffit de changer <code>_CropSize</code> . <br><br><h2>  Partie 3. Ombrage du terrain </h2><br><h2>  Ombrage plat </h2><br>  Tout le code que nous avons √©crit fonctionne, mais a un s√©rieux probl√®me.  L'ombrage du mod√®le est quelque peu √©trange.  La surface est correctement courb√©e, mais r√©agit √† la lumi√®re comme si elle √©tait plate. <br><br>  Cela se voit tr√®s clairement dans les images ci-dessous.  L'image du haut montre un shader existant;  le bas montre comment cela fonctionne r√©ellement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0b/dbf/dad/c0bdbfdadf38764dd3d75ffb69d07dea.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/511/6a1/e02/5116a1e02debfaa58afe0cddf3b4c6c9.png"></div><br>  R√©soudre ce probl√®me peut √™tre un grand d√©fi.  Mais d'abord, nous devons d√©terminer quelle est l'erreur. <br><br>  L'op√©ration d'extrusion normale a chang√© la g√©om√©trie g√©n√©rale du plan que nous avons utilis√© initialement.  Cependant, Unity n'a modifi√© que la position des sommets, mais pas leurs directions normales.  <strong>La direction du</strong> sommet <strong>normal</strong> , comme son nom l'indique, est un vecteur de longueur unitaire ( <em>direction</em> ) indiquant la perpendiculaire √† la surface.  <em>Les normales sont</em> n√©cessaires car elles jouent un r√¥le important dans l'ombrage d'un mod√®le 3D.  Ils sont utilis√©s par tous les shaders de surface pour calculer la mani√®re dont la lumi√®re doit √™tre r√©fl√©chie par chaque triangle du mod√®le 3D.  Cela est g√©n√©ralement n√©cessaire pour am√©liorer la tridimensionnalit√© du mod√®le, par exemple, il fait rebondir la lumi√®re sur une surface plane tout comme elle rebondirait sur une surface incurv√©e.  Cette astuce est souvent utilis√©e pour rendre les surfaces low-poly plus lisses qu'elles ne le sont r√©ellement (voir ci-dessous). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6b/d7c/443/f6bd7c443381c1f0e133ee7b7bce05e1.png"></div><br>  Cependant, dans notre cas, c'est le contraire qui se produit.  La g√©om√©trie est courbe et lisse, mais comme toutes les normales sont dirig√©es vers le haut, la lumi√®re est r√©fl√©chie par le mod√®le comme si elle √©tait plate (voir ci-dessous): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/241/cde/323241cdef1b3a41604c579f4fdb509b.png"></div><br>  Vous pouvez en savoir plus sur le r√¥le des normales dans l'ombrage des objets dans l'article sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">mappage normal (Bump Mapping)</a> , o√π les cylindres identiques sont tr√®s diff√©rents, malgr√© le m√™me mod√®le 3D, en raison de diff√©rentes m√©thodes de calcul des normales de sommet (voir ci-dessous). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b7/4fc/15f/1b74fc15f90516cc80b283953ef12373.png" width="315" height="243"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f93/544/d9c/f93544d9c95a70da71848897f0913676.png" width="347" height="254"></div><br>  Malheureusement, ni Unity ni le langage de cr√©ation de shaders n'ont de solution int√©gr√©e pour recalculer automatiquement les normales.  Cela signifie que vous devez les modifier manuellement en fonction de la g√©om√©trie locale du mod√®le 3D. <br><br><h2>  Calcul normal </h2><br>  La seule fa√ßon de r√©soudre le probl√®me de l'ombrage est de calculer manuellement les normales en fonction de la g√©om√©trie de la surface.  Une t√¢che similaire a √©t√© discut√©e dans un article de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Vertex D√©placement - Melting Shader Part 1</a> , o√π elle a √©t√© utilis√©e pour simuler la fusion de mod√®les 3D dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Cone Wars</a> . <br><br>  Bien que le code fini devra fonctionner en coordonn√©es 3D, limitons la t√¢che √† seulement deux dimensions pour l'instant.  Imaginez que vous devez calculer la <strong>direction de la normale</strong> correspondant au point sur la courbe 2D (la grande fl√®che bleue dans le diagramme ci-dessous). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5a/405/6be/e5a4056be62b920d9721a84d7c050ee6.png" width="316" height="346"></div><br>  D'un point de vue g√©om√©trique, la <em>direction de la normale</em> (grosse fl√®che bleue) est un vecteur perpendiculaire √† la <strong>tangente</strong> passant par le point qui nous int√©resse (une fine ligne bleue).  <em>La tangente</em> peut √™tre repr√©sent√©e comme une ligne situ√©e sur la courbure du mod√®le.  <strong>Un vecteur tangent</strong> est un <em>vecteur unitaire</em> qui repose sur une tangente. <br><br>  Cela signifie que pour calculer la normale, vous devez suivre deux √©tapes: premi√®rement, trouvez la ligne <em>tangente</em> au point souhait√©;  puis calculez le vecteur perpendiculaire √† celui-ci (qui sera la <em>direction</em> n√©cessaire <em>de la normale</em> ). <br><br><h3>  Calcul de la tangente </h3><br>  Pour obtenir la <em>normale,</em> nous devons d'abord calculer la <em>tangente</em> .  Il peut √™tre approxim√© en √©chantillonnant un point √† proximit√© et en l'utilisant pour construire une ligne pr√®s du sommet.  Plus la ligne est petite, plus la valeur est pr√©cise. <br><br>  Trois √©tapes sont n√©cessaires: <br><br><ul><li>  √âtape 1. D√©placez une petite quantit√© sur une surface plane </li><li>  √âtape 2. Calculez la hauteur du nouveau point. </li><li>  √âtape 3. Utilisez la hauteur du point actuel pour calculer la tangente </li></ul><br>  Tout cela peut √™tre vu dans l'image ci-dessous: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46f/bd3/7e8/46fbd37e868d16ff7ec6f1a164377018.png"></div><br>  Pour que cela fonctionne, nous devons calculer les hauteurs de deux points, pas d'un.  Heureusement, nous savons d√©j√† comment proc√©der.  Dans la partie pr√©c√©dente du didacticiel, nous avons cr√©√© une fonction qui √©chantillonne la hauteur d'un paysage en fonction d'un point de maillage.  Nous l'avons appel√© <code>getVertex</code> . <br><br>  Nous pouvons prendre la nouvelle valeur de sommet au point courant, puis √† deux autres.  L'un sera pour la tangente, l'autre pour la tangente en deux points.  Avec leur aide, nous obtenons la normale.  Si le maillage d'origine utilis√© pour cr√©er l'effet est plat (et dans notre cas, il l'est), nous n'avons pas besoin d'acc√©der √† <code>v.normal</code> et nous pouvons simplement utiliser <code>float3(0, 0, 1)</code> pour tangent et tangent √† deux points, respectivement <code>float3(0, 0, 1)</code> et <code>float3(1, 0, 0)</code> .  Si nous voulions faire de m√™me, mais, par exemple, pour une sph√®re, il serait beaucoup plus difficile de trouver deux points appropri√©s pour calculer la tangente et la tangente √† deux points. <br><br><h3>  Illustrations vectorielles </h3><br>  Apr√®s avoir obtenu les vecteurs tangents et tangents appropri√©s √† deux points, nous pouvons calculer la normale en utilisant une op√©ration appel√©e <strong>produit vectoriel</strong> .  Il existe de nombreuses d√©finitions et explications d'une ≈ìuvre vectorielle et de ce qu'elle fait. <br><br>  Un produit vectoriel re√ßoit deux vecteurs et renvoie un nouveau.  Si deux vecteurs initiaux √©taient unitaires (leur longueur est √©gale √† l'unit√©) et qu'ils sont situ√©s √† un angle de 90, alors le vecteur r√©sultant sera situ√© √† 90 degr√©s par rapport aux deux. <br><br>  Au d√©but, cela peut √™tre d√©routant, mais graphiquement, il peut √™tre repr√©sent√© comme suit: le produit vectoriel de deux axes en cr√©e un troisi√®me.  C‚Äôest <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-115"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-116"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-118"><font style="vertical-align: inherit;">f </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119"><font style="vertical-align: inherit;">o </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-120"><font style="vertical-align: inherit;">i </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-121"><font style="vertical-align: inherit;">s </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-122"><font style="vertical-align: inherit;">Y </font></span><span class="MJXp-mo" id="MJXp-Span-123" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;">= </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-124"><font style="vertical-align: inherit;">Z</font></span></font><span class="MJXp-mtext" id="MJXp-Span-117">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-118"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-120"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-121"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-122"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-123" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-124"><font style="vertical-align: inherit;"></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-27"> X \ fois Y = Z </script>  mais aussi <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-125"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-126"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-128"><font style="vertical-align: inherit;">f </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-129"><font style="vertical-align: inherit;">o </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130"><font style="vertical-align: inherit;">i </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131"><font style="vertical-align: inherit;">s </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-132"><font style="vertical-align: inherit;">Z </font></span><span class="MJXp-mo" id="MJXp-Span-133" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;">= </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-134"><font style="vertical-align: inherit;">Y</font></span></font><span class="MJXp-mtext" id="MJXp-Span-127">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-128"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-129"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-132"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-133" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-134"><font style="vertical-align: inherit;"></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-28"> X \ fois Z = Y </script>  , et ainsi de suite. <br><br>  Si nous faisons un pas suffisamment petit (dans le code, c'est <code>offset</code> ), alors les vecteurs de la tangente et de la tangente √† deux points seront √† un angle de 90 degr√©s.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec le vecteur normal, ils forment trois axes perpendiculaires orient√©s le long de la surface du mod√®le. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sachant cela, nous pouvons √©crire tout le code n√©cessaire pour calculer et mettre √† jour le vecteur normal.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ float3 bitangent = float3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); float3 tangent = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> offset = <span class="hljs-number"><span class="hljs-number">0.01</span></span>; float4 vertexBitangent = getVertex(v.vertex + float4(bitangent * offset, <span class="hljs-number"><span class="hljs-number">0</span></span>) ); float4 vertex = getVertex(v.vertex); float4 vertexTangent = getVertex(v.vertex + float4(tangent * offset, <span class="hljs-number"><span class="hljs-number">0</span></span>) ); float3 newBitangent = (vertexBitangent - vertex).xyz; float3 newTangent = (vertexTangent - vertex).xyz; v.normal = cross(newTangent, newBitangent); v.vertex.y = vertex.y; }</code> </pre> <br><h3>  Tout mettre ensemble </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant que tout fonctionne, nous pouvons retourner l'effet de d√©filement. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// v.vertex.xz: [_VertexMin, _VertexMax] // cropped.xz : [croppedMin, croppedMax] float2 croppedMin = _CropOffset; float2 croppedMax = croppedMin + _CropSize; float4 cropped = v.vertex; cropped.xz = (v.vertex.xz - _VertexMin) / (_VertexMax - _VertexMin) * (croppedMax - croppedMin) + croppedMin; float3 bitangent = float3(1, 0, 0); float3 normal = float3(0, 1, 0); float3 tangent = float3(0, 0, 1); float offset = 0.01; float4 vertexBitangent = getVertex(cropped + float4(bitangent * offset, 0) ); float4 vertex = getVertex(cropped); float4 vertexTangent = getVertex(cropped + float4(tangent * offset, 0) ); float3 newBitangent = (vertexBitangent - vertex).xyz; float3 newTangent = (vertexTangent - vertex).xyz; v.normal = cross(newTangent, newBitangent); v.vertex.y = vertex.y; v.texcoord = float4(vertexToUV(cropped), 0,0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et sur cela, notre effet est enfin termin√©. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d9/b07/680/0d9b0768068b2329d53e22a71ff27dfb.gif" width="700" height="272"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O√π aller ensuite </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce tutoriel peut devenir la base d'effets plus complexes, par exemple des projections holographiques ou m√™me une copie de la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">table</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener"><font style="vertical-align: inherit;">sable</font></a><font style="vertical-align: inherit;"> du film "Black Panther".</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ecS1_-Y_uP8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Forfait Unity </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le package complet de ce tutoriel peut √™tre t√©l√©charg√© sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , il contient tous les actifs n√©cessaires pour jouer l'effet d√©crit.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462153/">https://habr.com/ru/post/fr462153/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462141/index.html">Panier pour un centre de donn√©es</a></li>
<li><a href="../fr462145/index.html">Pourquoi faut-il plusieurs jours pour se d√©sinscrire?</a></li>
<li><a href="../fr462147/index.html">Utilisation de la navigation lors de la refactorisation d'un h√©ritage de projet dans React Native</a></li>
<li><a href="../fr462149/index.html">Mode de restriction d'acc√®s pour les accessoires sur les appareils iOS et comment le contourner</a></li>
<li><a href="../fr462151/index.html">5 principales distributions Kubernetes</a></li>
<li><a href="../fr462155/index.html">Travaillez avec Worker ¬´comme vous le souhaitez¬ª, pas ¬´autant que possible¬ª</a></li>
<li><a href="../fr462159/index.html">Construire un syst√®me de reconnaissance faciale bas√© sur Golang et OpenCV</a></li>
<li><a href="../fr462161/index.html">Exp√©rience d'installation d'Apache Airflow sur Windows 10</a></li>
<li><a href="../fr462163/index.html">Des technologies qui seront populaires en 2020</a></li>
<li><a href="../fr462165/index.html">Comment 25 personnes ont √©t√© amen√©es √† travailler pour une soci√©t√© de jeux inexistante</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>