<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüöí ‚ûó üë®üèø‚Äçüè´ WAL no PostgreSQL: 1. Cache do buffer üßíüèª üë©üèΩ‚Äçü§ù‚Äçüë©üèº üîï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A s√©rie anterior foi dedicada ao isolamento e √† multi-vers√£o do PostgreSQL, e hoje estamos iniciando uma nova - sobre o mecanismo de registro write-ah...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL no PostgreSQL: 1. Cache do buffer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/458186/">  A s√©rie anterior foi dedicada ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">isolamento e √† multi-vers√£o do</a> PostgreSQL, e hoje estamos iniciando uma nova - <strong>sobre o mecanismo de</strong> registro write-ahead.  Deixe-me lembr√°-lo de que o material √© baseado em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cursos de treinamento</a> administrativo que Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">pluzanov</a> e eu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">fazemos</a> , mas n√£o os repete literalmente e se destinam a uma leitura atenta e a experimenta√ß√µes independentes. <br><br>  Este ciclo consistir√° em quatro partes: <br><br><ul><li>  Cache de buffer (este artigo); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Di√°rio de pr√©-registro</a> - como √© organizado e como √© usado durante a recupera√ß√£o; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ponto de verifica√ß√£o</a> e grava√ß√£o em segundo plano - por que eles s√£o necess√°rios e como s√£o configurados; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ajuste de log</a> - n√≠veis e tarefas a serem resolvidos, confiabilidade e desempenho. </li></ul><br><h1>  Por que o di√°rio √© necess√°rio? </h1><br>  No processo, parte dos dados com os quais o DBMS lida √© armazenada na RAM e gravada no disco (ou outra m√≠dia n√£o vol√°til) de maneira diferida.  Quanto menos vezes isso acontece, menos entrada e sa√≠da e mais r√°pido o sistema funciona. <br><br>  Mas o que acontecer√° no caso de uma falha, por exemplo, quando a energia for desligada ou se ocorrer um erro no c√≥digo DBMS ou no sistema operacional?  Todo o conte√∫do da RAM ser√° perdido e apenas os dados gravados no disco permanecer√£o (com alguns tipos de falhas, o disco tamb√©m poder√° sofrer, mas nesse caso, apenas uma c√≥pia de backup ajudar√°).  Em princ√≠pio, a E / S pode ser organizada de forma que os dados no disco sejam sempre mantidos em um estado consistente, mas isso √© dif√≠cil e n√£o √© muito eficiente (tanto quanto eu sei, apenas o Firebird foi por esse caminho). <br><br>  Geralmente, incluindo o PostgreSQL, os dados gravados no disco s√£o inconsistentes e, ao se recuperar de uma falha, s√£o necess√°rias a√ß√µes especiais para restaurar a consist√™ncia.  O registro no di√°rio √© o pr√≥prio mecanismo que torna isso poss√≠vel. <br><a name="habracut"></a><br><h1>  Cache de buffer </h1><br>  Estranhamente, come√ßaremos a falar sobre registro no di√°rio com um cache de buffer.  O cache do buffer n√£o √© a √∫nica estrutura armazenada na RAM, mas uma das mais importantes e complexas.  Compreender o princ√≠pio de sua opera√ß√£o √© importante por si s√≥; al√©m disso, neste exemplo, vamos nos familiarizar com a forma como os dados s√£o trocados entre a RAM e o disco. <br><br>  O cache √© usado em todos os lugares nos sistemas de computa√ß√£o modernos; um processador sozinho pode contar tr√™s ou quatro n√≠veis de cache.  Em geral, qualquer cache √© necess√°rio para suavizar a diferen√ßa de desempenho entre os dois tipos de mem√≥ria, um dos quais √© relativamente r√°pido, mas n√£o √© suficiente para todos, e o outro √© relativamente lento, mas abundante.  Portanto, o cache do buffer suaviza a diferen√ßa entre o tempo de acesso √† RAM (nanossegundos) e ao disco (milissegundos). <br><br>  Observe que o sistema operacional tamb√©m possui um cache de disco que resolve o mesmo problema.  Portanto, o DBMS geralmente tenta evitar o armazenamento em cache duplo acessando o disco diretamente, ignorando o cache do SO.  Mas no caso do PostgreSQL, n√£o √© assim: todos os dados s√£o lidos e gravados usando opera√ß√µes comuns de arquivos. <br><br>  Al√©m disso, as matrizes de disco e at√© os pr√≥prios discos tamb√©m t√™m seu pr√≥prio cache.  Esse fato ainda √© √∫til para n√≥s quando chegamos √† quest√£o da confiabilidade. <br><br>  Mas voltando ao cache do buffer do DBMS. <br><br>  √â chamado assim porque √© uma matriz de <em>buffers</em> .  Cada buffer √© um local para uma p√°gina de dados (bloco), mais um cabe√ßalho.  O t√≠tulo, entre outras coisas, cont√©m: <br><br><ul><li>  localiza√ß√£o no disco da p√°gina no buffer (n√∫mero do arquivo e bloco); </li><li>  um sinal de que os dados na p√°gina foram alterados e, mais cedo ou mais tarde, devem ser gravados no disco (esse buffer √© chamado de <em>sujo</em> ); </li><li>  n√∫mero de chamadas para o buffer (contagem de uso); </li><li>  bandeira de fixar o buffer (contagem de pinos). </li></ul><br>  O cache do buffer est√° localizado na mem√≥ria compartilhada do servidor e √© acess√≠vel a todos os processos.  Para trabalhar com dados - leitura ou modifica√ß√£o, - processa p√°ginas de leitura no cache.  Enquanto a p√°gina est√° em cache, trabalhamos com ela na RAM e economizamos nos acessos ao disco. <br><br><img src="https://habrastorage.org/webt/1u/-j/fd/1u-jfdnjvzjwvrddgb7tbvohhge.png"><br><br>  Inicialmente, o cache cont√©m buffers vazios e todos eles est√£o vinculados √† lista de buffers livres.  O significado do ponteiro para a "pr√≥xima v√≠tima" ficar√° claro um pouco mais tarde.  Para encontrar rapidamente a p√°gina desejada no cache, uma tabela de hash √© usada. <br><br><h1>  P√°gina de pesquisa no cache </h1><br>  Quando um processo precisa ler uma p√°gina, ele primeiro tenta encontr√°-la no cache do buffer usando uma tabela de hash.  A chave de hash √© o n√∫mero do arquivo e o n√∫mero da p√°gina dentro do arquivo.  Na cesta correspondente da tabela de hash, o processo localiza o n√∫mero do buffer e verifica se ele realmente cont√©m a p√°gina desejada.  Como em qualquer tabela de hash, colis√µes s√£o poss√≠veis aqui;  nesse caso, o processo precisar√° verificar v√°rias p√°ginas. <br><br><blockquote>  O uso de uma tabela de hash √© criticado h√° muito tempo.  Essa estrutura permite encontrar rapidamente o buffer na p√°gina, mas √© completamente in√∫til se, por exemplo, voc√™ precisar encontrar todos os buffers ocupados por uma tabela espec√≠fica.  Mas ningu√©m prop√¥s um bom substituto ainda. <br></blockquote><br>  Se a p√°gina desejada for encontrada no cache, o processo deve "congelar" o buffer aumentando a contagem de pinos (v√°rios processos podem fazer isso simultaneamente).  Enquanto o buffer estiver fixo (o valor do contador for maior que zero), considera-se que o buffer √© usado e seu conte√∫do n√£o deve ser alterado "radicalmente".  Por exemplo, uma nova vers√£o da linha pode aparecer na p√°gina - isso n√£o incomoda ningu√©m devido √†s regras de vers√£o m√∫ltipla e visibilidade.  Mas outra p√°gina n√£o pode ser lida no buffer fixado. <br><br><h1>  Crowding out </h1><br>  Pode acontecer que a p√°gina necess√°ria n√£o seja encontrada no cache.  Nesse caso, ele deve ser lido do disco para algum buffer. <br><br>  Se ainda houver buffers livres no cache, o primeiro ser√° selecionado.  Por√©m, mais cedo ou mais tarde eles terminam (geralmente o tamanho do banco de dados √© maior que a mem√≥ria alocada para o cache) e, em seguida, voc√™ precisa escolher um dos buffers ocupados, for√ßar a p√°gina l√° e ler um novo no espa√ßo vago. <br><br>  O mecanismo de preemp√ß√£o √© baseado no fato de que cada vez que o buffer √© acessado, os processos aumentam a contagem de uso no cabe√ßalho do buffer.  Portanto, os buffers usados ‚Äã‚Äãcom menos frequ√™ncia do que outros t√™m um valor de contador mais baixo e s√£o bons candidatos √† exclus√£o. <br><br>  O algoritmo de varredura de rel√≥gio percorre todos os buffers (usando o ponteiro para a "pr√≥xima v√≠tima"), diminuindo a contagem de acessos em um.  Para exclus√£o, o primeiro buffer √© selecionado, o que: <br><br><ol><li>  tem um contador de acertos zero (contagem de uso), </li><li>  e n√£o fixo (contagem zero de pinos). </li></ol><br>  Voc√™ pode ver que, se todos os buffers tiverem um contador de zero diferente de zero, o algoritmo precisar√° fazer mais de um c√≠rculo, redefinindo os contadores, at√© que um deles finalmente chegue a zero.  Para evitar "c√≠rculos tortuosos", o valor m√°ximo do contador de visitas √© limitado a 5. Mas ainda assim, com um tamanho de cache de buffer grande, esse algoritmo pode causar uma sobrecarga significativa. <br><br>  Depois que o buffer √© encontrado, acontece o seguinte. <br><br>  O buffer √© fixado para mostrar outros processos que est√£o sendo usados.  Al√©m da corre√ß√£o, outros meios de bloqueio tamb√©m s√£o usados, mas falaremos mais sobre isso separadamente. <br><br>  Se o buffer estiver sujo, ou seja, ele cont√©m dados alterados, a p√°gina n√£o pode ser simplesmente descartada - primeiro ela precisa ser salva no disco.  Essa n√£o √© uma situa√ß√£o boa, pois o processo que est√° prestes a ler a p√°gina precisa aguardar a grava√ß√£o de dados "estrangeiros", mas esse efeito √© amenizado pelos processos de verifica√ß√£o e registro em segundo plano, que ser√£o discutidos mais adiante. <br><br>  Em seguida, uma nova p√°gina √© lida do disco no buffer selecionado.  O contador do n√∫mero de chamadas √© definido como um.  Al√©m disso, o link para a p√°gina carregada deve ser registrado na tabela de hash para que possa ser encontrado no futuro. <br><br>  Agora, o link para a ‚Äúpr√≥xima v√≠tima‚Äù aponta para o pr√≥ximo buffer, e o rec√©m carregado tem tempo para aumentar o contador de ocorr√™ncias at√© que o ponteiro passe por todo o cache do buffer e retorne novamente. <br><br><h1>  Com meus pr√≥prios olhos </h1><br>  Como √© habitual no PostgreSQL, h√° uma extens√£o que permite procurar dentro do cache do buffer. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_buffercache;</code> </pre> <br>  Crie uma tabela e insira uma linha nela. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> cacheme( id <span class="hljs-type"><span class="hljs-type">integer</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> cacheme <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  O que haver√° no cache do buffer?  No m√≠nimo, uma p√°gina deve aparecer nela com uma √∫nica linha adicionada.  Verificaremos isso com a seguinte consulta, na qual selecionamos apenas os buffers pertencentes √† nossa tabela (pelo n√∫mero do arquivo relfilenode) e decodificamos o n√∫mero da camada (relforknumber): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> bufferid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> relforknumber <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'fsm'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'vm'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> relfork, relblocknumber, isdirty, usagecount, pinning_backends <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'cacheme'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15735 | main | 0 | t | 1 | 0 (1 row)</code> </pre><br>  Ent√£o √© isso - existe uma p√°gina no buffer.  Est√° sujo (isdirty), o contador de ocorr√™ncias √© um (usagecount) e n√£o √© corrigido por nenhum processo (pinning_backends). <br><br>  Agora adicione outra linha e repita a consulta.  Para salvar cartas, inserimos uma linha em outra sess√£o e repetimos a solicita√ß√£o longa com o comando <code>\g</code> . <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> cacheme <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15735 | main | 0 | t | 2 | 0 (1 row)</code> </pre><br>  Nenhum novo buffer foi adicionado - a segunda linha coube na mesma p√°gina.  Observe que o contador de uso aumentou. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> cacheme;</code> </pre><pre> <code class="plaintext hljs">| id | ---- | 1 | 2 | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15735 | main | 0 | t | 3 | 0 (1 row)</code> </pre><br>  E depois de acessar a p√°gina para leitura, o contador tamb√©m aumenta. <br><br>  E se voc√™ limpar? <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> cacheme;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15731 | fsm | 1 | t | 1 | 0 15732 | fsm | 0 | t | 1 | 0 15733 | fsm | 2 | t | 2 | 0 15734 | vm | 0 | t | 2 | 0 15735 | main | 0 | t | 3 | 0 (5 rows)</code> </pre><br>  A limpeza criou um mapa de visibilidade (uma p√°gina) e um mapa de espa√ßo livre (tr√™s p√°ginas - o tamanho m√≠nimo deste mapa). <br><br>  Bem e assim por diante. <br><br><h1>  Configura√ß√£o de tamanho </h1><br>  O tamanho do cache √© definido pelo par√¢metro <em>shared_buffers</em> .  O valor padr√£o √© rid√≠culo 128 MB.  Este √© um dos par√¢metros que faz sentido aumentar imediatamente ap√≥s a instala√ß√£o do PostgreSQL. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> setting, unit <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_settings <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'shared_buffers'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> setting | unit ---------+------ 16384 | 8kB (1 row)</code> </pre><br>  Lembre-se de que alterar um par√¢metro requer uma reinicializa√ß√£o do servidor, pois toda a mem√≥ria cache necess√°ria √© alocada na inicializa√ß√£o do servidor. <br><br>  Por que raz√µes para escolher o valor apropriado? <br><br>  At√© o maior banco de dados possui um conjunto limitado de dados "quentes", com os quais o trabalho ativo √© realizado a cada momento.  Idealmente, esse conjunto deve ser colocado no cache do buffer (mais algum espa√ßo para dados "√∫nicos").  Se o tamanho do cache for menor, as p√°ginas usadas ativamente se espremer√£o constantemente, criando excesso de entrada e sa√≠da.  Mas aumentar o cache sem pensar tamb√©m est√° errado.  Com um tamanho grande, os custos indiretos de manuten√ß√£o aumentam e, al√©m disso, a RAM tamb√©m √© necess√°ria para outras necessidades. <br><br>  Assim, o tamanho ideal do cache do buffer ser√° diferente em diferentes sistemas: depende dos dados, do aplicativo e da carga.  Infelizmente, n√£o existe um significado m√°gico que sirva a todos igualmente bem. <br><br>  A recomenda√ß√£o padr√£o √© usar 1/4 da RAM como primeira aproxima√ß√£o (para Windows anterior ao PostgreSQL 10, era recomend√°vel escolher um tamanho menor). <br><br>  E ent√£o voc√™ precisa olhar para a situa√ß√£o.  √â melhor fazer um experimento: aumentar ou diminuir o tamanho do cache e comparar o desempenho do sistema.  Obviamente, para isso, √© necess√°rio ter uma bancada de testes e poder reproduzir a carga t√≠pica - no ambiente de produ√ß√£o, tais experimentos parecem prazeres duvidosos. <br><br><blockquote>  N√£o deixe de consultar o relat√≥rio de Nikolay Samokhvalov no PgConf-2019: "Uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">abordagem industrial para o</a> ajuste do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PostgreSQL: experimentos de banco de dados</a> " <br></blockquote><br>  Mas algumas informa√ß√µes sobre o que est√° acontecendo podem ser coletadas diretamente em um sistema ativo usando a mesma extens√£o pg_buffercache - o mais importante, observe o √¢ngulo certo. <br><br>  Por exemplo, voc√™ pode estudar a distribui√ß√£o de buffers de acordo com o grau de uso: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> usagecount, count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> usagecount <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> usagecount;</code> </pre><pre> <code class="plaintext hljs"> usagecount | count ------------+------- 1 | 221 2 | 869 3 | 29 4 | 12 5 | 564 | 14689 (6 rows)</code> </pre><br>  Nesse caso, muitos valores de contador vazios s√£o buffers livres.  N√£o √© surpresa para um sistema em que nada acontece. <br><br>  Voc√™ pode ver quanto das tabelas em nosso banco de dados s√£o armazenadas em cache e com que intensidade esses dados s√£o usados ‚Äã‚Äã(por uso ativo nesta consulta, queremos dizer buffers com um contador de uso superior a 3): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> c.relname, count(*) blocks, round( <span class="hljs-number"><span class="hljs-number">100.0</span></span> * <span class="hljs-number"><span class="hljs-number">8192</span></span> * count(*) / pg_table_size(c.oid) ) "% of rel", round( <span class="hljs-number"><span class="hljs-number">100.0</span></span> * <span class="hljs-number"><span class="hljs-number">8192</span></span> * count(*) <span class="hljs-keyword"><span class="hljs-keyword">FILTER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> b.usagecount &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) / pg_table_size(c.oid) ) "% hot" <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache b <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class c <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> pg_relation_filenode(c.oid) = b.relfilenode <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> b.reldatabase <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( <span class="hljs-number"><span class="hljs-number">0</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> datname = current_database()) ) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> b.usagecount <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> c.relname, c.oid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relname | blocks | % of rel | % hot ---------------------------+--------+----------+------- vac | 833 | 100 | 0 pg_proc | 71 | 85 | 37 pg_depend | 57 | 98 | 19 pg_attribute | 55 | 100 | 64 vac_s | 32 | 4 | 0 pg_statistic | 27 | 71 | 63 autovac | 22 | 100 | 95 pg_depend_reference_index | 19 | 48 | 35 pg_rewrite | 17 | 23 | 8 pg_class | 16 | 100 | 100 (10 rows)</code> </pre><br>  Aqui, por exemplo, pode-se ver que a tabela vac ocupa o maior lugar (n√≥s a usamos em um dos t√≥picos anteriores), mas ningu√©m a abordou por um longo tempo e ainda n√£o foi espremida simplesmente porque os buffers gratuitos ainda n√£o se esgotaram. <br><br>  Voc√™ pode criar outras se√ß√µes que fornecer√£o informa√ß√µes √∫teis para reflex√£o.  S√≥ √© necess√°rio considerar que esses pedidos: <br><br><ul><li>  deve ser repetido v√°rias vezes: os n√∫meros variam dentro de certos limites; </li><li>  n√£o √© necess√°rio execut√°-lo constantemente (como parte do monitoramento) devido ao fato de a extens√£o bloquear a opera√ß√£o com o cache do buffer por um curto per√≠odo de tempo. </li></ul><br>  E mais uma coisa.  N√£o devemos esquecer que o PostgreSQL trabalha com arquivos por meio de chamadas regulares ao sistema operacional e, portanto, h√° um cache duplo: as p√°ginas se enquadram no cache do buffer do DBMS e no cache do SO.  Portanto, a ‚Äúfalta‚Äù no cache do buffer nem sempre leva √† necessidade de E / S real.  Mas a estrat√©gia de excluir o sistema operacional √© diferente da estrat√©gia do DBMS: o sistema operacional n√£o sabe nada sobre o significado dos dados lidos. <br><br><h1>  Deslocamento de massa </h1><br>  Nas opera√ß√µes que executam leitura ou grava√ß√£o em massa de dados, existe o risco de deslocar rapidamente p√°ginas √∫teis do cache do buffer com dados "√∫nicos". <br><br>  Para impedir que isso aconte√ßa, os chamados <em>an√©is de buffer</em> s√£o usados ‚Äã‚Äãpara essas opera√ß√µes - uma pequena parte do cache do buffer √© alocada para cada opera√ß√£o.  A extrus√£o atua apenas dentro do anel, para que o restante dos dados do cache do buffer n√£o sofra. <br><br>  Para leitura seq√ºencial de tabelas grandes (cujo tamanho excede um quarto do cache do buffer), 32 p√°ginas s√£o alocadas.  Se outro processo tamb√©m precisar desses dados durante a leitura de uma tabela, ele n√£o come√ßar√° a ler a tabela primeiro, mas se conectar√° a um anel de buffer existente.  Ap√≥s a digitaliza√ß√£o, ele l√™ o in√≠cio "perdido" da tabela. <br><br>  Vamos conferir.  Para fazer isso, crie uma tabela para que uma linha ocupe uma p√°gina inteira - √© mais conveniente contar.  O tamanho padr√£o do cache do buffer √© 128 MB = 16384 p√°ginas de 8 KB.  Portanto, voc√™ precisa inserir mais de 4096 linhas de p√°gina na tabela. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> big( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALWAYS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">1000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor=<span class="hljs-number"><span class="hljs-number">10</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> big(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'FOO'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4096</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Vamos analisar a tabela. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> big; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 4097 (1 row)</code> </pre><br>  Agora temos que reiniciar o servidor para limpar o cache dos dados da tabela que a an√°lise leu. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Ap√≥s a reinicializa√ß√£o, leia a tabela inteira: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> big;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Aggregate (actual time=14.472..14.473 rows=1 loops=1) -&gt; Seq Scan on big (actual time=0.031..13.022 rows=4097 loops=1) Planning Time: 0.528 ms Execution Time: 14.590 ms (4 rows)</code> </pre><br>  E verifique se apenas 32 buffers est√£o ocupados por p√°ginas tabulares no cache do buffer: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 32 (1 row)</code> </pre><br>  Se a varredura seq√ºencial for proibida, a tabela ser√° lida por √≠ndice: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> big;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------------- Aggregate (actual time=50.300..50.301 rows=1 loops=1) -&gt; Index Only Scan using big_pkey on big (actual time=0.098..48.547 rows=4097 loops=1) Heap Fetches: 4097 Planning Time: 0.067 ms Execution Time: 50.340 ms (5 rows)</code> </pre><br>  Nesse caso, o anel do buffer n√£o √© usado e a tabela inteira aparece no cache do buffer (e quase todo o √≠ndice tamb√©m): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 4097 (1 row)</code> </pre><br>  De maneira semelhante, an√©is de buffer s√£o usados ‚Äã‚Äãpara o processo de limpeza (tamb√©m 32 p√°ginas) e para opera√ß√µes de grava√ß√£o em massa COPY IN e CREATE TABLE AS SELECT (geralmente 2048 p√°ginas, mas n√£o mais que 1/8 do cache total de buffer). <br><br><h1>  Tabelas tempor√°rias </h1><br>  Uma exce√ß√£o √† regra geral s√£o as tabelas tempor√°rias.  Como os dados tempor√°rios s√£o vis√≠veis para apenas um processo, eles n√£o t√™m nada a fazer no cache do buffer compartilhado.  Al√©m disso, os dados tempor√°rios existem apenas em uma √∫nica sess√£o, portanto, n√£o precisam ser protegidos contra falhas. <br><br>  Para dados tempor√°rios, um cache √© usado na mem√≥ria local do processo que possui a tabela.  Como esses dados est√£o dispon√≠veis para apenas um processo, eles n√£o precisam ser protegidos com bloqueios.  O cache local usa o algoritmo preemptivo usual. <br><br>  Diferentemente do cache geral do buffer, a mem√≥ria do cache local √© alocada conforme necess√°rio, porque tabelas tempor√°rias n√£o s√£o usadas em todas as sess√µes.  A quantidade m√°xima de mem√≥ria para tabelas tempor√°rias em uma sess√£o √© limitada pelo par√¢metro <em>temp_buffers</em> . <br><br><h1>  Aquecendo o cache </h1><br>  Ap√≥s reiniciar o servidor, algum tempo deve passar antes que o cache ‚Äúaque√ßa‚Äù - acumule dados reais usados ‚Äã‚Äãativamente.  √Äs vezes, pode ser √∫til ler imediatamente os dados de determinadas tabelas no cache, e uma extens√£o especial foi criada para isso: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_prewarm;</code> </pre><br>  Anteriormente, uma extens√£o podia ler apenas determinadas tabelas no cache do buffer (ou apenas no cache do SO).  Mas no PostgreSQL 11, ele foi capaz de salvar o status atual do cache em disco e restaur√°-lo ap√≥s a reinicializa√ß√£o do servidor.  Para tirar proveito disso, voc√™ precisa adicionar a biblioteca a <em>shared_preload_libraries</em> e reiniciar o servidor. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pg_prewarm'</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  O campo reiniciar, se o par√¢metro <em>pg_prewarm.autoprewarm</em> n√£o for alterado, o processo em segundo plano mestre do autoprewarm ser√° iniciado automaticamente, que uma vez em <em>pg_prewarm.autoprewarm_interval liberar√° a</em> lista de p√°ginas em cache no disco (n√£o se esque√ßa de levar em considera√ß√£o o novo processo ao definir <em>max_parallel_processes</em> ). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span>, setting, unit <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_settings <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'pg_prewarm%'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> name | setting | unit ---------------------------------+---------+------ pg_prewarm.autoprewarm | on | pg_prewarm.autoprewarm_interval | 300 | s (2 rows)</code> </pre><br><pre> <code class="plaintext hljs">postgres$ ps -o pid,command --ppid `head -n 1 /var/lib/postgresql/11/main/postmaster.pid` | grep prewarm</code> </pre><pre> <code class="plaintext hljs">10436 postgres: 11/main: autoprewarm master</code> </pre><br>  Agora n√£o h√° tabela grande no cache: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 0 (1 row)</code> </pre><br>  Se assumirmos que todo o seu conte√∫do √© muito importante, podemos l√™-lo no cache do buffer chamando a seguinte fun√ß√£o: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_prewarm(<span class="hljs-string"><span class="hljs-string">'big'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_prewarm ------------ 4097 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 4097 (1 row)</code> </pre><br>  A lista de p√°ginas √© despejada no arquivo autoprewarm.blocks.  Para v√™-lo, basta aguardar at√© que o processo mestre do acionamento autom√°tico seja executado pela primeira vez, mas iniciamos manualmente: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> autoprewarm_dump_now();</code> </pre><pre> <code class="plaintext hljs"> autoprewarm_dump_now ---------------------- 4340 (1 row)</code> </pre><br>  O n√∫mero de p√°ginas descartadas √© superior a 4097 - isso inclui as p√°ginas dos objetos de cat√°logo do sistema j√° lidos pelo servidor.  E aqui est√° o arquivo: <br><br><pre> <code class="plaintext hljs">postgres$ ls -l /var/lib/postgresql/11/main/autoprewarm.blocks</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 102078  29 15:51 /var/lib/postgresql/11/main/autoprewarm.blocks</code> </pre><br>  Agora reinicie o servidor novamente. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  E imediatamente ap√≥s o lan√ßamento, nossa tabela aparece novamente no cache. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 4097 (1 row)</code> </pre><br>  Isso fornece o mesmo processo mestre do disparador autom√°tico: ele l√™ o arquivo, divide as p√°ginas em bancos de dados, classifica-as (para que a leitura do disco seja o mais consistente poss√≠vel) e passa o trabalhador do disparador autom√°tico para o fluxo de trabalho individual para processamento. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para ser continuado</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458186/">https://habr.com/ru/post/pt458186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458168/index.html">Resumo de not√≠cias do aprendizado de m√°quina e da intelig√™ncia artificial de junho</a></li>
<li><a href="../pt458172/index.html">M√©todos para emparelhar conex√µes el√©tricas ao rastrear pares diferenciais em placas de circuito impresso</a></li>
<li><a href="../pt458176/index.html">A barreira dos exaflops ser√° superada em 2021</a></li>
<li><a href="../pt458180/index.html">Servidor DHCP de failover baseado em Kea</a></li>
<li><a href="../pt458182/index.html">Lemos o VKontakte atrav√©s do RSS</a></li>
<li><a href="../pt458188/index.html">Como eu fiz uma rede social em 2019</a></li>
<li><a href="../pt458202/index.html">Basta dar uma olhada no SObjectizer se voc√™ quiser usar atores ou CSP no seu projeto C ++</a></li>
<li><a href="../pt458204/index.html">Como avaliar o desempenho do armazenamento no Linux: benchmarking usando ferramentas abertas</a></li>
<li><a href="../pt458206/index.html">Texto sublime 3 para o layout do site. Personalize a apar√™ncia e instale plugins. Guia do Iniciante</a></li>
<li><a href="../pt458208/index.html">Eventos digitais em Moscou de 01 a 07 de julho</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>