<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐏 ↕️ 🎅🏻 使用Webpack收集梦想 🚚 📵 🆑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JS应用程序，站点和其他资源正在变得越来越复杂，并且构建工具是Web开发的现实。 捆绑软件可帮助打包，编译和组织库。 Webpack是可以完美定制以构建客户端应用程序的强大而灵活的开源工具之一。 

 Maxim Sosnov（ crazymax11 ） -N1.RU中的前端主管将Webpack引入...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用Webpack收集梦想</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433324/">  JS应用程序，站点和其他资源正在变得越来越复杂，并且构建工具是Web开发的现实。 捆绑软件可帮助打包，编译和组织库。  Webpack是可以完美定制以构建客户端应用程序的强大而灵活的开源工具之一。 <br><br>  Maxim Sosnov（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">crazymax11</a> ） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">-N1.RU中的</a>前端主管将Webpack引入了多个大型项目，这些大型项目以前具有自己的自定义构建，并为此贡献了多个项目。  Maxim知道如何使用Webpack构建理想的捆绑包，快速进行配置并对其进行配置，以使配置保持清洁，维护和模块化。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4ClK_0fxsVM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 解释与报告不同-它是proflink的改进版本。 在整个笔录中，复活节彩蛋散布在文章，插件，缩小词，选项，翻译者和说话者的言语证明上，而这些链接根本无法发表。 如果您收集了所有内容，则Webpack中的奖励级别将打开:-) <br><a name="habracut"></a><br><h2>  Webpack集成在典型项目中 </h2><br> 通常，实现过程如下：开发人员在某处阅读了有关Webpack的文章，决定连接它，开始构建它，以某种方式起作用，一切开始，并且有一段时间webpack-config起作用-六个月，一年，两年。 在当地，一切都很好-太阳，彩虹和蝴蝶。 然后真正的用户来了： <br><br>  <em>-从移动设备无法加载您的网站。</em> <em><br></em>  <em>-一切对我们都有效。</em>  <em>在当地，一切都很好！</em> <br><br> 以防万一，开发人员去分析所有内容，发现对于移动设备， <strong>捆绑包重7 MB，需要30秒才能加载</strong> 。 这并不适合任何人，开发人员开始寻找解决问题的方法-他可以连接装载程序或找到可以解决所有问题的魔术插件。 神奇地找到了这样的插件。 我们的开发人员转到webpack-config，尝试安装，但是代码行会干扰： <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.env.NODE_ENV === <span class="hljs-string"><span class="hljs-string">'production'</span></span>) { config.module.rules[<span class="hljs-number"><span class="hljs-number">7</span></span>].options.magic = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br> 该行的翻译如下：“如果将config组装用于生产，则采用第七条规则并在其中放置<code>magic = true</code>选项。” 开发人员不知道该怎么办以及如何解决。 在这种情况下，您需要一堆梦。 <br><br><h2> 如何收集一捆梦？ </h2><br> 首先，让我们定义它是什么。 首先，梦想捆绑包具有两个主要特征： <br><br><ul><li>  <strong>它有点重</strong> 。 重量越轻-用户越快获得有效的应用程序。 您不希望您的网站打开15秒钟。 </li><li> 用户<strong>只</strong>下载显示该站点当前页面所需的内容，而不下载更多内容！ </li></ul><br> 为了减小包的大小，必须首先评估其大小。 <br><br><h3> 评分捆绑包大小 </h3><br> 最受欢迎的解决方案是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WebpackBundleAnalyzer</a>插件。 它收集应用程序构建统计信息，并呈现一个交互式页面，您可以在其中查看每个模块的位置和重量。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/27a/803/6b9/27a8036b994a09b7371c567b6df6cd82.png" alt="图片"><br><br> 如果这还不够，您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">另一个插件</a>来构建<strong>依赖关系图</strong> 。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/900/24a/7c390024a9d902ca99e3d00c0d8081b3.png" alt="图片"><br><br> 或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">饼图</a> 。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/350/14a/ec4/35014aec45623d06972bca310b3f8edf.png" alt="图片"><br><br> 如果这还不够，并且您想将Webpack出售给营销人员，则可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">构建一个整个宇宙</a> ，其中每个点都是一个模块，就像宇宙中的星星一样。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45b/a6e/2d2/45ba6e2d2daff144c69df2a43e8ef53a.png" alt="图片"><br><br> 有很多工具可以评估捆绑软件的大小并对其进行监控。 例如，如果捆绑包过重<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，则Webpack配置</a>中有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个选项</a>可使组件崩溃。 如果有2个不同版本的npm软件包，例如Lodash 4.15和Lodash 4.14，则有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">重复的package-checker-webpack-plugin插件</a>将阻止您<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">构建</a>捆绑包。 <br><br><h3> 如何减少捆绑 </h3><br><ul><li> 最明显的是插入<strong>UglifyJS，</strong>以便它最小化JavaScript。 </li><li> 使用<strong>特殊的加载器和插件</strong>来压缩和优化特定资源。 例如， <strong>css的css-nano</strong>或优化SVG的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SVGO</a> 。 </li><li> 通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gzip / brotli插件</a>将所有文件直接压缩到Webpack。 </li><li> 其他工具。 </li></ul><br> 现在，我们将了解如何从捆绑中扔掉多余的东西。 <br><br><h3> 扔掉多余的 </h3><br> 在带有<strong>moment.js</strong>的流行示例中考虑这<strong>一点</strong> ： <code>import moment from 'moment'</code> 。 如果您使用一个空的应用程序，则将moment.js和<strong>ReactDOM</strong>导入其中，然后将其传递给<strong>WebpackBundleAnalyzer</strong> ，您将看到以下图片。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/105/e0f/833/105e0f8334a83c529077c693fda3d3de.png" alt="图片"><br><br> 事实证明，当您在日期中添加一天，一个小时，或者只是想使用moment.js将链接放在“ 15分钟内”时，您将连接整个<strong>230 KB的代码</strong> ！ 为什么会发生这种情况以及如何解决？ <br><br><h4> 此刻的语言环境加载 </h4><br>  moment.js中有一个用于设置语言环境的函数： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setLocale</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">locale</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> localePath = <span class="hljs-string"><span class="hljs-string">'locale/'</span></span> + locale + <span class="hljs-string"><span class="hljs-string">'.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentLocale = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(localePath); }</code> </pre><br> 从代码中可以看出，语言环境是沿着动态路径加载的，即 在运行时计算。  Webpack的行为巧妙，并尝试确保您的捆绑软件在代码执行期间不会崩溃：它会找到项目中所有可能的语言环境，并将其捆绑。 因此，该应用程序非常重。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a03/4cc/b3f/a034ccb3fc36dd03b916b0bc28acb057.png" alt="图片"><br><br> 解决方案非常简单-我们从Webpack中获取一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">标准插件</a> ，然后对它说：“如果您发现有人要下载很多语言环境，因为他们无法确定哪个语言环境，那么就选择俄语语言！” <br><br><img src="https://habrastorage.org/getpro/habr/post_images/587/fe6/e38/587fe6e38333e8b482fed615e3c00ee1.png" alt="图片"><br><br>  Webpack仅会使用俄语，而WebpackBundleAnalyzer将显示54 Kb，这已经轻松了200 Kb。 <br><br><h3> 消除死代码 </h3><br> 我们感兴趣的下一个优化是<strong>消除死代码</strong> 。 考虑下面的代码。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cond = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cond) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; someFunction(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre><br> 最终捆绑包中不需要此代码中的大多数行-具有条件的块也不会执行，返回后的函数也将不会执行。 您只需要离开就<code>return true</code> 。 这正是消除死代码的本质：构建工具检测到无法执行的代码并将其剪切。  UglifyJS有一个很好的功能，可以做到这一点。 <br><br> 现在，让我们继续进行更高级的Dead代码消除<strong>-Tree Shaking方法</strong> 。 <br><br><h3> 摇树 </h3><br> 假设我们有一个使用<strong>Lodash</strong>的应用程序。 我强烈怀疑有人会使用整个Lodash。 最有可能利用了诸如<strong>get</strong> ， <strong>IsEmpty</strong> ， <strong>unionBy</strong>之类的几个功能。 <br><br> 当我们进行树摇动时，我们希望Webpack“摇动”不必要的模块并将其丢弃，而我们只有必要的模块。 这是树在颤抖。 <br><br><h4>  Webpack中树抖动的工作原理 </h4><br> 假设您有这样的代码： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { a } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./a.js'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a);</code> </pre><br> 代码非常简单：从某个模块导入变量a并输出。 但是此模块中有两个变量： <strong>a</strong>和<strong>b</strong> 。 我们不需要变量<b>b</b> ，我们想将其删除。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br>  Webpack到达时，它将导入代码转换为以下代码： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(d[<span class="hljs-string"><span class="hljs-string">"a"</span></span>]);</code> </pre><br> 我们的<code>import</code>变成了<code>require</code> ，但是<code>console.log</code>没有改变。 <br><br>  Webpack依赖项转换为以下代码： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports[<span class="hljs-string"><span class="hljs-string">"a«] = a; /* unused harmony export b */ var b = 4;</span></span></code> </pre><br><br>  Webpack保留了变量<b>a</b>的导出，并删除了变量<b>b</b>的导出，但是保留了变量本身，并用特殊注释对其进行了标记。 在转换后的代码中，不使用变量<b>b</b> ，UglifyJS可以将其删除。 <br><br><blockquote> 仅当您具有某种代码缩减器（例如UglifyJS或<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">babel-</a></b> minify）时，Webpack摇树才会起作用。 </blockquote><br> 让我们考虑更有趣的情况-摇树不起作用。 <br><br><h4> 当摇树不起作用时 </h4><br> 案例1。您编写代码： <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.b = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br> 通过Webpack运行代码，并且保持不变。 这是因为仅当您使用ES6模块时，捆绑程序才会组织树摇动。 如果使用CommonJS模块，则摇树将不起作用。 <br><br> 案例2。使用ES6模块编写代码并命名为export。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br> 如果您的代码通过Babel运行，并且您未将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">modules</a>选项设置<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为false</a> ，那么Babel会将您的模块引入CommonJS，Webpack将再次无法执行Tree Shaking，因为它仅适用于ES6模块。 <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.b = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br> 因此，我们需要确保组装计划中没有人会渗透ES6模块。 <br><br> 案例3。假设我们有一个无用的类，什么也不做： <code>export class ShakeMe {}</code> 。 而且，我们仍然不使用它。 当Webpack进行导入和导出时，Babel会将类转换为一个函数，并且捆绑程序将注意未使用该函数： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* unused harmony e[port b */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ShakeMe = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShakeMe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ babelHelpers.classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ShakeMe); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ShakeMe; }();</code> </pre><br> 看起来一切都应该不错，但是如果我们仔细看一看，就会发现在此函数内部有一个全局变量<code>babelHelpers</code> ，从中可以调用某些函数。 这是一个<b>副作用</b> ：UglifyJS看到正在调用某些全局函数，并且不会剪切代码，因为担心某些事情会中断。 <br><br> 当您编写类并通过Babel运行它们时，它们永远不会被削减。 如何解决？ 有一个标准化的技巧-在函数之前添加注释<code>/*#__PURE__*/</code> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* unused harmony export b */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ShakeMe = <span class="hljs-comment"><span class="hljs-comment">/*#__PURE__*/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShakeMe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ babelHelpers.classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ShakeMe); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ShakeMe; }();</code> </pre><br> 然后，UglifyJS将相信下一个函数是纯净的。 幸运的是， <b><a href="">Babel 7</a></b>现在正在执行此操作，而在Babel 6中，到目前为止尚未删除任何内容。 <br><br><blockquote> 规则：如果您在某处有副作用，那么UglifyJS不会做任何事情。 </blockquote><br> 总结一下： <br><br><ul><li>  <b>对于npm以来的大多数库，树摇不适用于大多数库</b> ，因为它们全部来自CommonJS并由旧的Babel构建。 </li><li>  <b>对于那些已经为此准备好的库，</b>例如Lodash-es，Date-fns和您的代码或库， <b>树抖动</b>很可能<b>会充分起作用</b> 。 </li><li>  UglifyJS参与了程序集。 </li><li> 二手的ES6模块。 </li><li> 无副作用。 </li></ul><br> 我们找到了减轻重量的方法，现在让我们教它只加载必要的功能。 <br><br><h3> 我们仅加载必要的功能 </h3><br> 我们将这一部分分为两部分。 在第一部分中， <b>仅加载用户所需的代码</b> ：如果用户访问您网站的主页，则他不会加载个人帐户页面。 第二， <b>代码中的更改导致最小的资源重载</b> 。 <br><br><h4> 我们只加载必要的代码 </h4><br> 考虑一个虚构应用程序的结构。 它具有： <br><br><ul><li> 入口点-APP。 </li><li> 三页：主页，搜索和卡片。 </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/872/142/14e/87214214e5fc6514a1a72cb20f6be4b2.png" alt="图片"><br><br> 我们要解决的第一个问题是<b>发出通用代码</b> 。 让我们将红色代码表示为所有页面的通用代码，将绿色圆圈表示为主页面和搜索页面。 其余数字并不是特别重要。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/854/ec8/80f/854ec880feff7813d267ca834209db71.png" alt="图片"><br><br> 当用户从主页上进行搜索时，尽管他已经有了，但他将再次重新加载框和圈子。 理想情况下，我们希望看到这样的内容。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b75/290/36d/b7529036de4cf6923a279666d00ca297.png" alt="图片"><br><br> 很好的是，Webpack 4已经有一个内置插件可以为我们完成此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务-SplitChunksPlugin</a> 。 该插件取出应用程序代码或节点模块代码，这些代码由一个单独的块中的多个块使用，同时确保具有公共代码的块将大于30 Kb，并且要加载页面，您需要下载不超过5个块。 该策略是最佳的：加载太小的块是无利可图的，加载太多的块很<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://engineering.khanacademy.org/posts/js-packaging-">长，而且效率</a>甚至不及在http2上下载更少的块。 要在2个或3个版本的Webpack上重复此行为，我必须写20-30行具有未记录功能的行。 现在，这一问题正在一线解决。 <br><br><h4>  CSS外卖 </h4><br> 如果我们仍然在单独的文件中为每个块取出CSS，那就太好了。 为此，有一个现成的解决方案<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-Mini-Css-Extract-Plugin</a></b> 。 该插件仅出现在Webpack 4中，在此之前，还没有足够的解决方案来完成此任务-只有hack，痛苦和腿伤。 该插件<b>从异步块中删除了CSS，</b>并且是<b>专门为此任务</b>创建的，它可以完美执行。 <br><br><h4> 最小可能的资源重载 </h4><br> 我们将弄清楚如何确保在发布（例如）主页上的新促销块时，用户<b>能够重新加载代码的最小部分</b> 。 <br><br> 如果我们有版本控制，一切都会很好。 这里是版本N的主页，在发行了促销块之后-版本N +1。  Webpack提供了使用散列的开箱即用的类似机制。 在Webpack收集了所有资产（在本例中为app.js）之后，它将计算其内容哈希并将其添加到文件名中以获取app [哈希] .js。 这是我们需要的<b>版本控制</b> 。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd1/3f2/1a9/fd13f21a9daeddd3a1af9083b8134257.png" alt="图片"><br><br> 让我们检查一下它是如何工作的。 打开散列，在主页上进行更改，然后查看主页代码是否确实已更改，我们将看到两个文件已更改：main和app.js。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a2/bc0/b44/2a2bc0b447b7baf927ac729e28ace633.png" alt="图片"><br><br> 为什么会发生这种情况，因为这是不合逻辑的？ 要了解原因，让我们<b>看一下app.js。</b> 它包括三个部分： <br><br><ul><li> 申请代码 </li><li>  webpack运行时； </li><li> 链接到异步块。 </li></ul><br> 当我们更改main中的代码时，其内容和哈希会更改，这意味着<b>指向</b>它的<b>链接</b>在应用程序中也会更改。 该应用程序本身也将更改，需要重新启动。 解决此问题的方法是<b>将</b> app.js分为两个块：应用程序代码和webpack运行时以及到异步块的链接。  Webpack 4通过一个<b>runtimeChunk</b>选项为我们完成了所有工作，该选项重量很小<b>-gzip</b>少于2 KB。 为用户重新启动它实际上是毫无用处的。 仅使用以下一个选项启用RuntimeChunk： <br><br><pre> <code class="javascript hljs">optimization: { <span class="hljs-attr"><span class="hljs-attr">runtimeChunk</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br> 在Webpack 3和2中，我们将写5-6行，而不是一行。 这不多，但仍然是不必要的麻烦。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e4/125/5d8/6e41255d837ac2a5c4bb8a6e9b74f686.png" alt="图片"><br><br> 一切都很棒，我们学会了建立链接和运行时！ 让我们在main中编写一个新模块，释放它，然后-op！  -现在，一般而言，一切都会重新开始。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc7/8f6/a5f/cc78f6a5f6ffcd8b2da956d5463fefc8.png" alt="图片"><br><br> 为什么这样 让我们看看模块如何在webpack中工作。 <br><br><h4>  Webpack模块 </h4><br> 假设有代码添加模块<b>a</b> ， <b>b</b> ， <b>d</b>和<b>e</b> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'d'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span>;</code> </pre><br>  Webpack将导入转换为require：将<b>a</b> ， <b>b</b> ， <b>d</b>和<b>e</b>替换为require（0），require（1），require（2）和require（3）。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br> 想象一下经常发生的情况：您编写了一个新模块<code>import c from 'c';</code> 并将其粘贴到中间的某个位置： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'c'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'d'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span>;</code> </pre><br> 当Webpack处理所有内容时，它将新模块的导入转换为require（2）： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br> 模块<b>d</b>和<b>e</b>分别为2和3，将接收数字3和4-新的ID。 由此得出一个简单的结论：使用序列号作为id有点愚蠢，但是Webpack做到了。 <br><br><blockquote> 不要将序列号用作唯一ID </blockquote><br> 要解决此问题，有一个内置的Webpack解决方案<b>-HashedModuleIdsPlugin</b> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webpack.HashedModuleIdsPlugin({ <span class="hljs-attr"><span class="hljs-attr">hashFunction</span></span>: <span class="hljs-string"><span class="hljs-string">'md4′, hashDigest:'</span></span>base64′, <span class="hljs-attr"><span class="hljs-attr">hashDigestLength</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, }),</code> </pre><br> 此插件从文件的绝对路径使用4个字符的<b>md4哈希</b>代替数字ID。 有了它，我们的需求将变成这些： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'YmRl'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'N2Fl'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'OWE4′); var d = require('</span></span>NWQz<span class="hljs-string"><span class="hljs-string">'); var e = require('</span></span>YWVj<span class="hljs-string"><span class="hljs-string">');</span></span></code> </pre><br> 出现了字母，而不是数字。 当然，有一个隐藏的问题-这是<b>哈希</b>的<b>冲突</b> 。 我们偶然发现它，建议您使用8个字符而不是4个字符。正确配置散列后，一切将按照我们最初想要的方式工作。 <br><br> 现在，我们知道如何收集梦s。 <br><br><ul><li>  <b>缩小</b> 。 </li><li>  <b>使用代码拆分</b> 。 </li><li>  <b>设置哈希值</b> 。 </li></ul><br> 我们学会了收集，现在我们将继续努力。 <br><br><h2> 如何<b>快速</b>组装梦境捆绑包？ </h2><br> 在我们的N1.RU中，最大的应用程序包含10,000个模块，并且不进行优化就需要28分钟。 我们能够将组装速度加快到两分钟！ 我们是如何做到的？ 有3种方法可以加快任何计算速度，这三种方法均适用于Webpack。 <br><br><h3> 程序集并行化 </h3><br> 我们要做的第一件事是<b>并行化程序集</b> 。 为此，我们有： <br><br><ul><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HappyPackPlugin</a></b> ，它将您的装载程序包装在其他装载程序中，并接受包装在单独进程中的所有计算。 例如，这允许并行化Babel和node-sass。 </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">线程加载器</a></b> 。 执行与HappyPackPlugin大致相同的操作，仅不使用进程，而是使用线程池。 切换到单独的线程是一项代价高昂的操作，请谨慎使用它，并且仅当您要包装占用大量资源的繁重操作（例如babel或node-sass）时，才应谨慎使用。 例如，对于加载json，不需要并行化，因为它可以快速加载。 </li><li> 您最可能使用的插件和加载器已经具有<b>内置的并行化工具</b> -您只需要看一下即可。 例如，此选项在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UglifyJS中</a> 。 </li></ul><br><h3> 缓存构建结果 </h3><br>  <b>缓存程序集结果</b>是加速Webpack组装的最有效方法。 <br><br> 我们拥有的第一个解决方案是<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cache-loader</a></b> 。 这是一个装入程序链的装入程序，并将针对特定装入程序链构建特定文件的结果保存到文件系统中。 在捆绑软件的下一个组合中，如果此文件位于文件系统上并且已通过此链处理，则cache-loader将获取结果，并且不会调用其后的那些加载器，例如Babel-loader或node-sass。 <br><br> 该图显示了组装时间。 蓝条-100％的构建时间，没有缓存加载器，并且慢了7％。 这是因为缓存加载器会花费额外的时间将缓存保存到文件系统。 在第二次大会上，我们已经获得了可观的利润-大会的速度提高了2倍。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6bc/e73/210/6bce732104fda8263464528d91d1a8a1.png" alt="图片"><br><br> 第二种解决方案是更<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">复杂的-HardSourcePlugin</a></b> 。 主要区别在于：缓存加载器只是一个只能在带有代码或文件的加载器链中运行的加载器，而HardSourcePlugin几乎可以完全访问Webpack生态系统，可以与其他插件和加载器一起运行，并且扩展了生态系统以进行少量缓存。 上图显示，在第一次启动时，构建时间增加了37％，但是在第二次启动时使用所有缓存，我们加快了5倍。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb6/acf/d36/cb6acfd36adbaaadffd68af19889f960.png" alt="图片"><br><br> 最好的部分是您可以同时使用这两种解决方案，这是我们在N1.RU上所做的。 请注意，因为缓存存在问题，我将在稍后讨论。 <br><br> 您已经使用的插件/加载程序可能具有<b>内置的缓存机制</b> 。 例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">babel-loader具有</a>非常高效的缓存系统，但是由于某种原因，默认情况下它是关闭的。 相同的功能在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">awesome-typeScript-loader中</a> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UglifyJS</a>插件也具有缓存，效果很好。 他使我们加速了几分钟。 <br><br> 现在的问题。 <br><br><h4> 缓存问题 </h4><br><ul><li> 缓存可能<b>无法正确验证</b> 。 </li><li> 应用的解决方案可能<b>无法与连接的插件，加载器，您的代码或彼此结合使用</b> 。 在这方面，缓存加载器是一种简单且轻松的解决方案。 但是使用HardSourcePlugin时，您需要更加小心。 </li><li>  <b>如果一切都坏了，很难登场</b> 。 当缓存无法正常工作并且发生无法理解的错误时，将很难找出问题所在。 </li></ul><br><h3> 如何节省生产？ </h3><br> 加快流程的最后一种方法是不执行流程的任何部分。 让我们考虑一下如何节省生产成本？ 我们不能做什么？ 答案很简单- <b>我们无能为力</b> ！ 我们无权拒绝生产中的某些东西，但是我们可以在<b>dev中</b>节省很多。 <br><br> 节省什么： <br><br><ul><li>  <b>在</b>我们需要它们之前， <b>不要收集源地图</b> 。 </li><li>  <b>使用样式加载器，</b>而不是使用CSS移除和通过CSS加载器进行处理的酷方案。 样式加载器本身非常快，因为它使用css行并将其推入将该行插入样式标签的函数中。 </li><li>  <b>您只能在浏览器列表中保留您专门使用的浏览器-最有可能是最后一个镶边</b> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这将大大加速</a> 。 </li><li>  <b>完全放弃任何资源优化</b> ：从UglifyJS，css-nano，gzip / brotli。 </li></ul><br><blockquote> 构建加速是并行化，缓存和拒绝计算。 通过遵循这三个简单步骤，您可以大大加快速度。 </blockquote><br><h2> 如何配置webpack？ </h2><br> 我们已经弄清楚了如何组装梦想包以及如何快速组装它，现在我们将弄清楚如何配置Webpack，以免每次更改配置时都无法自拔。 <br><br><h3> 项目中的配置演变 </h3><br> 项目中的典型webpack-config路径以<b>简单的</b>配置开始。 首先，您只需插入Webpack，Babel-loader，sass-loader，一切都很好。 然后，出乎意料的是，某些<b>条件</b>出现<b>在process.env上</b> ，并插入了这些条件。 一，二，三，越来越多，直到添加了带有“魔术”选项的条件为止。 您了解一切都已经很糟糕了，最好只是<b>复制</b>用于开发和生产<b>的配置</b> ，并进行两次更正。 一切都会更加清晰。 如果您有一个想法：“这里有什么问题吗？”，那么唯一可行的建议是<b>保持配置井然有序</b> 。 我会告诉你我们如何做到的。 <br><br><h3> 保持配置顺序 </h3><br> 我们使用<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">webpack-merge</a></b>包。 这是一个npm软件包，用于将多个配置组合为一个。 如果您对默认的合并策略不满意，可以对其进行自定义。 <br><br><h3>     </h3><br>    4  : <br><br><ul><li> Loaders. </li><li> Plugins. </li><li> Presets. </li><li> Parts. </li></ul><br>    . <br><br><h4> Plugin/Loader </h4><br>  ,        ,       API,  ,      . <br><br> 看起来像这样： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  JSdoc * @param {Object} options * @see    */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPlugin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Plugin(options); };</code> </pre><br>  ,   ,   ,   .    ,       url-loader  : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * url-loader    file-loader.        * * @example * -   some-image.png.     url-loader,  url-loader    * 1.    ,  url-loader    base64  * 2. , url-loader    outputPath + name     ,     . *    some-image.png,     outputPath/images/some-image.12345678hash.png,  url-loader  * publicPath/images/some-image.12345678hash.png * * @param {string} prefix    * @param {number} limit    ,    * @return {Object} loader   * @see https://www.npmjs.com/package/url-loader */</span></span></code> </pre><br>     ,   ,  , ,    ,   ,     .  ,  ,   ,  ,   url-loader.    : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">urlLoader</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prefix = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'assets'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, limit = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-string"><span class="hljs-string">'url-loader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">options</span></span>: { limit, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-string">/[name].[hash].[ext]`</span></span> } }; };</code> </pre><br>         .    ,   Loader         . <br><br><h4> Preset </h4><br>    webpack.     ,      ,    ,   webpack,    .    —  ,  ,    scss-: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.scss$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">use</span></span>: [cssLoader, postCssLoader, scssLoader] }</code> </pre><br>     . <br><br><h4> Part </h4><br>  —  ,      .        ,       ,   .  ,       : <br><br><pre> <code class="javascript hljs">entry: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/Frontend/app.js'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">output</span></span>: { <span class="hljs-attr"><span class="hljs-attr">publicPath</span></span>: <span class="hljs-string"><span class="hljs-string">'/static/cabinet/app/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: path.resolve(<span class="hljs-string"><span class="hljs-string">'www/static/app'</span></span>) },</code> </pre><br>     : <br><br><ul><li> <b> </b> ,   ,   , json,     , , splitChunks. </li><li> <b>  dev</b> ,  ,    js/css     </li><li> <b>Part</b> ,   output, publicPath, entry-point    , ,    source map. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/7ee/20f/fa6/7ee20ffa6f453c35f11d92e3583d8caf.png" alt="图片"><br><br> <b>Webpack-merge</b>     .          ,     .  webpack-merge     3-7 ,    Babel-loader,            .    ,   . <br><br><h3>   </h3><br>  . <b>  </b> ,    . <b> </b> ,   webpack       —     . <b>  </b> ,  . <br><br>   ,    ! <br><br><blockquote>   —     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Frontend Conf</a> . ,    —  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> ,           ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Frontend Conf ++</a>  . <br><br>    -      ?    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FrontenConf ++</a> ,   27  28   . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a>  27 ,   15          .     — ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433324/">https://habr.com/ru/post/zh-CN433324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433308/index.html">将PBX配置传输到3CX PBX Express服务</a></li>
<li><a href="../zh-CN433316/index.html">设计摘要：入职，反馈，搜索想法和决策</a></li>
<li><a href="../zh-CN433318/index.html">垃圾收集（）</a></li>
<li><a href="../zh-CN433320/index.html">网格布局是现代布局的基础</a></li>
<li><a href="../zh-CN433322/index.html">JSON API-我们根据规范进行工作</a></li>
<li><a href="../zh-CN433326/index.html">代码质量</a></li>
<li><a href="../zh-CN433328/index.html">最好输掉一天</a></li>
<li><a href="../zh-CN433330/index.html">使用SAT解算器解决日语填字游戏</a></li>
<li><a href="../zh-CN433332/index.html">Azure Functions中的Python支持</a></li>
<li><a href="../zh-CN433334/index.html">WPF的XAML行为现已开放源代码</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>