<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÖüèΩ üßõüèº üë∂üèª Fastware ü§£ üíÆ üôãüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Andrei Alexandrescu √© uma verdadeira lenda viva. √â uma pessoa que fez uma contribui√ß√£o significativa para a hist√≥ria das linguagens de programa√ß√£o mod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fastware</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/425191/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Andrei Alexandrescu</a> √© uma verdadeira lenda viva.  √â uma pessoa que fez uma contribui√ß√£o significativa para a hist√≥ria das linguagens de programa√ß√£o modernas e das t√©cnicas generalizadas e de metaprograma√ß√£o.  Quantas c√≥pias foram quebradas nas discuss√µes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dos</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Padr√µes</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Modernos de Design</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Codifica√ß√£o</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C ++</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">101</a> (escritos com o Bras√£o Excepcional C ++ da Sutter) e em outros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">livros e artigos</a> .  Como co-autor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">da linguagem D</a> , ele teve a oportunidade n√£o apenas de teorizar, mas tamb√©m de tornar seu sonho realidade - e, o que √© caracter√≠stico, ele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">personificou</a> . <br><br>  Agora voc√™ est√° segurando em suas m√£os um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rio</a> da confer√™ncia DotNext 2018 Piter, que fala sobre modernas tecnologias de otimiza√ß√£o.  O que o .NET tem a ver com isso?  Este √© um relat√≥rio fundamental de uma pessoa que otimizou toda a sua vida.  Se o desempenho √© importante para voc√™, voc√™ precisa assistir (ou ler este artigo).  Bem-vindo ao gato! <br><br><img width="100%" src="https://habrastorage.org/webt/9_/mg/9m/9_mg9mjeeamxyknlbdqeg4ukoa4.jpeg"><br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZazBhE1IQd0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  A arte do benchmarking </h1><br>  Eu gostaria de discutir com voc√™ v√°rios t√≥picos relacionados ao benchmarking.  Para come√ßar, vamos repetir algumas coisas b√°sicas.  <b>A lei de Amdahl</b> faz parte dos cl√°ssicos da ci√™ncia da computa√ß√£o, √© usada principalmente na computa√ß√£o paralela, mas funciona em qualquer sistema complexo.  Se queremos melhorar o trabalho de um determinado sistema, precisamos come√ßar onde os principais problemas desse sistema est√£o concentrados.  A lei em si √© √≥bvia: se um componente √© 20% do sistema, a melhoria m√°xima no desempenho do sistema que pode ser alcan√ßada pela otimiza√ß√£o da opera√ß√£o de apenas esse componente √© de 20%.  Muitas vezes tenho que conhecer pessoas (√© claro, nossos leitores n√£o pertencem a elas) que fazem coisas como otimizar a an√°lise de linha de comando.  Essas opera√ß√µes levam os 10 primeiros microssegundos do seu programa e as pessoas analisam sua complexidade algor√≠tmica e ficam horrorizadas se o tempo for quadr√°tico. <br><br>  Como voc√™ provavelmente sabe, antes de iniciar a otimiza√ß√£o, √© necess√°rio criar um perfil do aplicativo e selecionar pontos de acesso.  Aqui deve ser dito sobre a <b>lei de Ladma</b> (este n√£o √© um sobrenome real, e Amdal, lido ao contr√°rio).  Voc√™ precisa concentrar seus esfor√ßos no componente que leva ao maior investimento de tempo.  Ele precisa ser movido para fora do aplicativo, realizar o trabalho necess√°rio, retornar e testar novamente.  O motivo pelo qual voc√™ precisa fazer isso √© que, muitas vezes, uma melhoria de desempenho de 20% √© o resultado de dez melhorias de 2%.  E na estrutura de um sistema grande, √© imposs√≠vel medir uma melhoria t√£o pequena.  Para isso, o componente deve ser testado em um conjunto de testes.  Uma melhoria de 20% no desempenho de um dos principais componentes do sistema pode significar uma melhoria de 5% para o sistema como um todo, e para algumas √°reas esse √© um excelente resultado.  N√£o se esque√ßa que as otimiza√ß√µes podem ter v√°rios efeitos globais; portanto, com base nos resultados do benchmarking seletivo, voc√™ deve ter muito cuidado ao tirar conclus√µes sobre a opera√ß√£o do sistema como um todo. <br><br>  Um erro que tenho certeza de que nossos leitores n√£o cometem, mas que geralmente √© bastante comum: as pessoas medem a velocidade da montagem de depura√ß√£o.  Isso nunca deve ser feito.  √â semelhante a ficar chateado por causa da baixa velocidade do caracol nas corridas: n√£o se destina a uma competi√ß√£o como essa, tem outros objetivos na vida.  Outro erro, um pouco menos √≥bvio: as pessoas medem primeiro o desempenho b√°sico do sistema e imediatamente depois realizam o benchmarking.  Mas depois de coletar a linha de base, muitos recursos s√£o aquecidos.  Por exemplo, os arquivos abertos s√£o armazenados em buffer e permanecem na mem√≥ria (pelo menos no Linux).  Assim, o segundo teste ser√° mais r√°pido apenas porque √© iniciado ap√≥s o primeiro.  Isso acontece mesmo com chamadas malloc.  Ap√≥s essas chamadas, o sistema n√£o retorna ao seu estado original, mesmo que sejam feitas chamadas de libera√ß√£o da mem√≥ria.  A configura√ß√£o interna, o armazenamento em cache e os recursos usados ‚Äã‚Äãpelo alocador de mem√≥ria permitem que as seguintes chamadas do malloc sejam executadas muito mais rapidamente.  Mesmo sem levar em considera√ß√£o o efeito do cache, o malloc lembra que, por exemplo, algumas fun√ß√µes alocam mem√≥ria para objetos de 4 kilobytes v√°rias vezes, o que significa que voc√™ precisa ter uma lista livre com um tamanho de elemento de 4 kilobytes.  Ou outro exemplo: as pesquisas de DNS s√£o armazenadas em cache para reutiliza√ß√£o ap√≥s a primeira consulta.  Se poss√≠vel, durante o benchmarking, voc√™ precisa reiniciar todo o processo todas as vezes, do in√≠cio ao fim. <br><br>  Por exemplo, para retornar completamente o sistema ao seu estado original, no caso de arquivos, eles precisam ser abertos em um disco separado, que, ap√≥s o final do teste, precisa ser removido (como eu entendo, isso pode ser feito no Windows).  A opera√ß√£o n√£o √© f√°cil, mas na maioria dos casos √© necess√°ria. <br><br>  Continuando a conversa sobre erros durante a otimiza√ß√£o, tive que lidar com esses casos quando os custos de impress√£o est√£o inclu√≠dos nos resultados do teste.  Existem erros de procedimento quando mais de uma coisa √© alterada antes de cada medi√ß√£o, o que viola os princ√≠pios mais b√°sicos de um experimento cient√≠fico, uma vez que n√£o est√° claro qual efeito voc√™ est√° medindo.  Outro erro grave √© quando alguns casos raros s√£o otimizados, o que leva √† pessimiza√ß√£o em outras situa√ß√µes. <br><br><img src="https://habrastorage.org/webt/rs/fj/lf/rsfjlfl8ndtxzczw96ur5jyeijo.jpeg"><br><br>  Aqui est√° um exemplo com estouro de pilha.  O autor geralmente classifica os dados j√° classificados e fica surpreso, porque a fun√ß√£o `is_sorted '√© obviamente muito mais r√°pida que a classifica√ß√£o`  Por que, ent√£o, em `classificar a primeira linha n√£o √©` se is_sorted retorna?  Voc√™ est√° otimizando um caso extremamente raro, dados completamente classificados e todos os outros que t√™m pelo menos um elemento n√£o classificado ter√£o que arcar com os custos dessa otimiza√ß√£o.  N√£o vale a pena fazer isso. <br><br>  Acho que n√£o preciso provar h√° muito tempo que as arquiteturas concorrentes de hoje s√£o extremamente complexas: mudan√ßa din√¢mica de frequ√™ncia, interrup√ß√£o por outros processos, virtualiza√ß√£o etc.  Portanto, √© quase imposs√≠vel obter o mesmo tempo ao medir, seus indicadores sempre tremer√£o.  Portanto, n√£o se deve confiar em coisas que parecem √≥bvias.  Digamos, pode parecer √≥bvio para n√≥s que menos instru√ß√µes significam c√≥digo mais r√°pido, e isso nem sempre √© verdade.  Tamb√©m pode parecer que o uso de dados armazenados sempre ser√° mais r√°pido do que executar novamente os c√°lculos; portanto, se voc√™ armazenar em cache os resultados, ficar√° bem.  Como no caso anterior, n√£o pode ser declarado inequivocamente, assim como o contr√°rio n√£o pode ser declarado incondicionalmente - tudo depende do contexto.  Obviamente, voc√™ deve ter apenas uma coisa: tudo precisa ser medido.  Se voc√™ medir tudo, obter√° melhores resultados do que especialistas com conhecimento que n√£o fazem medi√ß√µes. <br><br>  H√° v√°rias pr√°ticas razoavelmente confi√°veis, cuja discuss√£o pode levar a pensamentos interessantes.  Devemos come√ßar com o fato de que a matem√°tica n√£o o decepcionar√°.  Torna poss√≠vel mostrar que sistemas com velocidades diferentes podem ser equivalentes.  A matem√°tica fornece regras para mostrar a equival√™ncia de certas coisas e identificar algumas propriedades e, embora n√£o seja tendenciosa, n√£o importa quais coisas s√£o interessantes e quais n√£o s√£o.  Muitas pessoas pensam que a otimiza√ß√£o √© baseada no conhecimento do c√≥digo de m√°quina e no trabalho com bits, mas na verdade tem muita matem√°tica, porque voc√™ prova que um sistema mais r√°pido √© equivalente a um mais lento. <br><br>  Outra regra geral √© que os computadores adoram que as coisas sejam entediantes.  Voc√™ precisa se multiplicar por dois vetores, um bilh√£o de elementos em cada um?  Essa √© uma tarefa ideal para um computador, todo o equipamento nele √© especialmente afiado para esse tipo de tarefa.  Para analisar esses dados, com base neles, para criar uma express√£o regular - n√£o quero fazer isso.  Os computadores n√£o gostam de coisas como ramifica√ß√µes, depend√™ncias, chamadas indiretas, enfim - eles n√£o gostam de c√≥digo inteligente, gostam de c√≥digo chato.  Os computadores n√£o gostam de grava√ß√£o indireta - um problema complexo com o qual as pessoas envolvidas no ferro lutam h√° muito tempo e n√£o conseguem resolver. <br><br>  Outra regra √© que voc√™ deve dar prefer√™ncia √†s opera√ß√µes menos poderosas, em outras palavras, preferir adi√ß√£o √† multiplica√ß√£o e multiplica√ß√£o √† exponencia√ß√£o.  Novamente, a matem√°tica √© √∫til aqui. <br><br>  Finalmente, a √∫ltima regra - quanto menor, mais bonita.  O tamanho pequeno permite que os computadores realizem melhor suas vantagens, pois preferem que os dados e principalmente as instru√ß√µes estejam pr√≥ximos um do outro.  Os resultados de v√°rias medi√ß√µes da velocidade do aplicativo sempre ser√£o diferentes, voc√™ ter√° alguma distribui√ß√£o dos resultados.  Normalmente, apenas medimos a m√©dia desses poucos resultados.  Mas o problema √© que, devido √†s especificidades dos computadores, a m√©dia incluir√° muito ru√≠do.  Quando Bill Gates monta um √¥nibus, em m√©dia, todo passageiro em um √¥nibus √© um bilion√°rio.  Parece √≥timo, mas √© pouco conforto para um sem-teto andando no mesmo √¥nibus.  Uma situa√ß√£o semelhante ocorre com interrup√ß√µes: a opera√ß√£o de multiplica√ß√£o leva nanossegundos, mas quando voc√™ faz muitas medi√ß√µes dessas opera√ß√µes, uma delas inevitavelmente ter√° uma interrup√ß√£o de dois milissegundos.  A diferen√ßa √© de tr√™s ordens de magnitude e, no entanto, os desenvolvedores nem sempre levam isso em conta. <br><br>  Ent√£o, repito: o ru√≠do nos computadores √© sempre aditivo;  para as pessoas, pode parecer insignificante, mas, para as micro-marcas, √© significativo e a m√©dia aritm√©tica incluir√° muito ru√≠do.  Em vez da m√©dia, voc√™ precisa de um indicador que me√ßa apenas o tempo que voc√™ pode influenciar de alguma forma.  Se abordarmos essa quest√£o do ponto de vista da matem√°tica, veremos que precisamos encontrar um valor que corresponda ao maior n√∫mero de medi√ß√µes que fizemos.  Em outras palavras, precisamos de um mod.  Isso imediatamente nos leva ao problema: o que acontece se voc√™ usar o mod quicksort?  Se o algoritmo for probabil√≠stico ou se os dados forem aleat√≥rios, quase nunca haver√° uma moda.  A densidade dos valores ser√° quase a mesma em todo o espectro.  Nesse caso, simplesmente descartamos os 5% das maiores medi√ß√µes e depois assumimos o valor m√©dio - ou o m√°ximo, no √∫ltimo caso, teremos um limite que n√£o ser√° excedido em 95% dos casos.  Quase sempre haver√° um assunto no por√£o antigo com um modem lento, no qual cada p√°gina ser√° carregada por uma hora.  Puramente humanos, √© claro que simpatizamos com ele, mas n√£o podemos ajudar tecnicamente a todos - portanto, os 5% restantes dos casos devem ser negligenciados.  Em geral, ao resolver problemas de rede, geralmente focamos no percentil 95, porque √© imposs√≠vel focar no cent√©simo.  O percentil cent√©simo significar√° o resultado mais lento de todas as medi√ß√µes coletadas - isso n√£o √© informativo. <br><br><h1>  Substituir ramifica√ß√µes por aritm√©tica </h1><br>  Como, espero, ficou claro que a medi√ß√£o n√£o √© um problema f√°cil.  Vamos dar uma olhada em alguns exemplos e come√ßar tentando substituir ramifica√ß√£o por aritm√©tica.  Estamos falando de casos em que precisamos de uma declara√ß√£o if, mas us√°-la com muita frequ√™ncia √© indesej√°vel.  Em vez disso, integraremos o resultado da ramifica√ß√£o como um valor 0/1.  O c√≥digo parecer√° linear, o computador precisar√° apenas segui-lo do come√ßo ao fim, sem pensar em qual etapa voc√™ deve seguir. <br><br>  Vamos tentar resolver o seguinte problema: transfira os m√≠nimos de cada quartil da matriz para o primeiro quartil.  Em outras palavras, a matriz deve ser dividida em quatro partes e o valor m√≠nimo de cada parte deve ser colocado no in√≠cio da matriz. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = p.Length; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = n / <span class="hljs-number"><span class="hljs-number">4</span></span>, k = n / <span class="hljs-number"><span class="hljs-number">2</span></span>, l = <span class="hljs-number"><span class="hljs-number">3</span></span> * n / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; n / <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i, ++j, ++k, ++l) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = p[i] &lt;= p[j] ? i : j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[k] &lt; p[m]) m = k; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[l] &lt; p[m]) m = l; Swap(ref p[i], ref p[m]); } }</code> </pre> <br>  Acima est√° o c√≥digo b√°sico.  A prop√≥sito, posso relatar orgulhosamente que traduzi esses exemplos para C # e eles foram compilados com √™xito.  O c√≥digo em si √© bastante simples: `m recebe o √≠ndice do menor dos dois valores localizados nos √≠ndices` iej, e uma atribui√ß√£o semelhante √© repetida mais duas vezes, dependendo dos outros dois √≠ndices.  Finalmente, o valor no √≠ndice `m √© revertido no array com o valor no √≠ndice` i.  Como voc√™ pode ver, contornamos o array usando quatro vari√°veis ‚Äã‚Äãindutivas. <br><br>  O problema de testar esse algoritmo ser√° interessante e n√£o √≥bvio.  Precisamos test√°-lo n√£o em um conjunto de dados, mas em dados que podem surgir em v√°rios casos.  Por exemplo, em dados que parecem tubos de um √≥rg√£o: primeiro aumente e depois diminua;  em dados aleat√≥rios com uma distribui√ß√£o uniforme;  em um conjunto aleat√≥rio de zeros e uns - a partir de apenas dados aleat√≥rios aqui, a diferen√ßa √© que haver√° muitos valores duplicados;  em dados j√° classificados;  finalmente, nos dados obtidos por medi√ß√µes reais de algum fen√¥meno f√≠sico.  Essa ser√° uma abordagem s√©ria para medir a velocidade de um algoritmo, e geralmente √© aceita entre as pessoas que estudam algoritmos. <br><br>  Vamos tentar melhorar o c√≥digo que acabamos de conhecer. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = n / <span class="hljs-number"><span class="hljs-number">4</span></span>, k = n / <span class="hljs-number"><span class="hljs-number">2</span></span>, l = <span class="hljs-number"><span class="hljs-number">3</span></span> * n / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; q; ++i, ++j, ++k, ++l) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = p[i] &lt;= p[j] ? i : j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[k] &lt; p[m]) m = k; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[l] &lt; p[m]) m = l; Swap(ref p[i], ref p[m]); } }</code> </pre> <br>  Como primeira otimiza√ß√£o, tentaremos evitar repeti√ß√µes excessivas de opera√ß√µes; para isso, realizamos v√°rias opera√ß√µes de divis√£o do loop - dividindo `n por 2 e 4 e dividindo 3 *` n por 4. Mas ap√≥s essa otimiza√ß√£o, descobrimos que os c√°lculos n√£o eram para o principal problema: o c√≥digo n√£o se tornar√° mais r√°pido, embora seja mais compacto.  Na melhor das hip√≥teses, obteremos uma melhoria de meio por cento. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = q, k = <span class="hljs-number"><span class="hljs-number">2</span></span> * q, l = <span class="hljs-number"><span class="hljs-number">3</span></span> * q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; q; ++i, ++j, ++k, ++l) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = p[i] &lt;= p[j] ? i : j; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = p[k] &lt;= p[l] ? k : l; Swap(ref p[i], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  A segunda altera√ß√£o que faremos no c√≥digo √© reduzir as depend√™ncias.  Na vers√£o anterior do algoritmo, atribuir `m a`k ou` l depende do valor atribu√≠do √† linha de m acima.  Para reduzir o n√∫mero de `m depend√™ncias, calculamos separadamente` m0 e `m1 e depois os comparamos.  Quando realizei essa otimiza√ß√£o, esperava uma melhora significativa na velocidade do algoritmo, mas no final ele acabou sendo zero.  Mas, na minha opini√£o, √© importante manter o n√∫mero de depend√™ncias no m√≠nimo, por isso salvei o c√≥digo. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = p[i] &lt;= p[i + q] ? i : i + q; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = p[i + <span class="hljs-number"><span class="hljs-number">2</span></span> * q] &lt;= p[i + <span class="hljs-number"><span class="hljs-number">3</span></span> * q] ? i + <span class="hljs-number"><span class="hljs-number">2</span></span> * q : i + <span class="hljs-number"><span class="hljs-number">3</span></span> * q; Swap(ref p[i], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  Vamos agora tentar reduzir o n√∫mero de vari√°veis ‚Äã‚Äãindutivas de quatro para uma e calcularemos as tr√™s restantes aritmeticamente, pois elas est√£o em constante rela√ß√£o uma com a outra.  Isso √© bem simples: em vez de `k, teremos` i + q, em vez das outras duas vari√°veis ‚Äã‚Äã- `i + 2 * q e` i + 3 * q.  Eu tamb√©m tinha grandes esperan√ßas nessa otimiza√ß√£o, mas, como a anterior, ela n√£o deu nenhum resultado a tempo.  Isso prova novamente a import√¢ncia das medidas: sem elas, eu poderia me gabar de ter melhorado significativamente a opera√ß√£o do algoritmo e teria argumentos muito significativos. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>, q2 = q + q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = q; i &lt; q2: ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = p[i - q] &lt; p[i] ? i - q : i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = p[i + q2] &lt; p[i + q] ? i + q2 ? i + q; Swap(ref p[i - q], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  Como quarta tentativa, reestruturamos o ciclo para eliminar a multiplica√ß√£o por 3. Isso nos dar√° uma melhoria de 3%.  O resultado ainda n√£o √© impressionante.  Em seguida, tente se livrar dos operadores tern√°rios. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Returns: value if flag is true, 0 otherwise static int optional(bool flag, int value) { return -Convert.ToInt32(flag) &amp; value; }</span></span></code> </pre> <br>  Para fazer isso, eu gostaria de apresentar uma nova fun√ß√£o - `static int optional (sinalizador bool, valor int).  Ele converte o valor booleano de entrada em Int32, multiplica por -1 e o passa para o operador AND bit a bit, juntamente com o segundo valor de entrada.  Se o sinalizador de entrada for falso, em int32 ser√° 0 e, depois de todas as convers√µes na sa√≠da, obteremos 0. Se o sinalizador de entrada for verdadeiro, em int32 ser√° 1, quando multiplicado por -1, obtemos FFFFFFFF, que ap√≥s o bit "E" com qualquer n√∫mero dar√° esse segundo n√∫mero.  Observe que n√£o h√° nenhuma declara√ß√£o if em qualquer lugar, o c√≥digo √© sem ramifica√ß√£o, √© chato para um computador (embora pare√ßa complicado para n√≥s). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>, q2 = q + q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = q; i &lt; q2; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = i - optional(p[i - q] &lt;= p[i], q); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = i + q + optional(p[i + q2] &lt; p[i + q], q); Swap(ref p[i - q], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  Substituiremos os operadores tern√°rios por esta fun√ß√£o opcional, integraremos dentro do c√°lculo.  N√≥s o aplicamos duas vezes e, no terceiro caso, deixe o ponto de interroga√ß√£o.  Assim, em vez de quatro verifica√ß√µes neste ciclo, terei apenas uma. <br><br><img src="https://habrastorage.org/webt/qo/wp/--/qowp---fgvtqsgddipqokwb_k3o.jpeg"><br><br>  A partir dos resultados da medi√ß√£o que voc√™ v√™ no slide, fica claro o qu√£o importante era testar o algoritmo em v√°rios conjuntos de dados diferentes.  Em um conjunto, n√£o entender√≠amos nada.  Em dados aleat√≥rios e reais, temos acelera√ß√£o mais do que dupla, em tubos de √≥rg√£os e dados classificados, temos uma ligeira desacelera√ß√£o.  Isso se deve ao fato de que, no caso de dados classificados para o preditor de transi√ß√£o, n√£o haver√° surpresas, eles prever√£o com 100% de precis√£o.  No caso de tubos de √≥rg√£os, teremos uma previs√£o errada no meio do conjunto de dados - novamente, precis√£o muito alta.  Por outro lado, com dados aleat√≥rios, a diferen√ßa entre nossas duas abordagens ser√° enorme.  Substitu√≠mos todas as verifica√ß√µes imprevis√≠veis por uma l√≥gica simples.  Aqui voltamos a uma verdade simples: os computadores s√£o projetados para computa√ß√£o, como o nome indica (computa√ß√£o em computador).  Ramifica√ß√£o, exibi√ß√£o de imagens na tela - tudo isso com desempenho muito pior.  Executar "And" bit a bit para eles √© muito mais simples do que passar a instru√ß√£o if. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>, q2 = q + q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = i + optional(p[i + q] &lt; p[i], q); m += optional(p[i + q2] &lt; p[m], q); m += optional(p[i + q2 + q] &lt; p[m], q); Swap(ref p[i], ref p[m]); } }</code> </pre> <br>  Tendo finalmente alcan√ßado um resultado positivo da otimiza√ß√£o, tentaremos substituir o √∫ltimo operador tern√°rio por nossa fun√ß√£o `opcional.  Desta vez, o ganho de velocidade ser√° pequeno.  Para entender por que isso acontece, voc√™ precisa examinar o c√≥digo gerado.  Na vers√£o anterior do c√≥digo, onde o ponto de interroga√ß√£o ainda estava presente, o compilador j√° encontrou uma maneira de executar o c√≥digo sem ramifica√ß√£o.  E quando ele chega ao operador tern√°rio, ele j√° pode prever.  Substituir esta √∫ltima pe√ßa por `opcional resultar√° em um c√≥digo um pouco pior.  Portanto, repito, √© importante fazer medi√ß√µes sempre. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Returns: v1 if flag is true, v2 otherwise static int ifelse(bool flag, int v1, int v2) { return (-Convert.ToInt32(flag) &amp; v1) | ((Convert.ToInt32(flag) - 1) &amp; v2); }</span></span></code> </pre><br>  Outro recurso que eu gostaria de recomendar a voc√™ √© `ifelse without branches, que voc√™ v√™ agora na tela.  √â verdade que n√£o pude alcan√ßar as melhorias de desempenho em nosso exemplo.  Se 0 for passado como um sinalizador, a primeira linha ser√° 0;  no segundo, subtra√≠mos 1 de 0 no Int32 e obtemos FFFFFFFF, ap√≥s o qual esse valor √© passado para o "bit" bit a bit "And" junto com o argumento da fun√ß√£o `v2, que nos dar√° esse argumento sem altera√ß√µes;  finalmente, a primeira e a segunda linhas s√£o passadas para o ‚Äúbit‚Äù OR, que, novamente, nos dar√° `v2.  Se o sinalizador for 1, a primeira linha ser√° igual a `v1;  no segundo, subtra√≠mos 1 de 1 e obtemos 0, como resultado, a linha inteira ser√° 0 e 0 e `v1 no bit a bit 'OR' fornecer√£o` v1. <br><br>  Espero que esse `ifelse sem fun√ß√£o de ramifica√ß√£o interesse as pessoas envolvidas no back-end - por enquanto, por algum motivo, os compiladores modernos n√£o usam essa abordagem.  Com essas fun√ß√µes, voc√™ pode reorganizar os algoritmos para que os compiladores os entendam para voc√™, porque voc√™ √© mais inteligente e criativo do que seu compilador. <br><br><h1>  Interse√ß√£o de conjunto grande </h1><br>  Mude um pouco o assunto da nossa conversa e passe para a interse√ß√£o de grandes conjuntos.  At√© agora, estivemos conversando sobre operadores individuais, agora criaremos novos algoritmos, portanto precisaremos nos distrair dos detalhes e abrir nossa mente para uma perspectiva mais ampla.  Suponho que voc√™ esteja familiarizado com a classifica√ß√£o por mesclagem, multiplique dois vetores e procure por elementos comuns de dois vetores classificados.  Dois conjuntos classificados s√£o percorridos e, quando elementos iguais est√£o neles, isso √© considerado uma correspond√™ncia.  Se um dos dois elementos comparados for menor, ele ser√° alterado.  Esse algoritmo √© bastante simples, mas muito comum - provavelmente o mais usado no mundo.  √â usado em todas as consultas de v√°rias palavras, cada uma dessas consultas √© a interse√ß√£o de dois conjuntos.  Esse algoritmo, em particular, usa o Google e tamb√©m deve ser aplicado em todas as consultas ao banco de dados. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a1.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> || a2.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a1[i1] &lt; a2[i2]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++i1 == a1.Length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a2[i2] &lt; a1[i1]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++i2 == a2.Length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { t[i++] = a1[i1]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++i1 == a1.Length || ++i2 == a2.Length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>: } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre> <br>  D√™ uma olhada na implementa√ß√£o b√°sica deste algoritmo.  Se os dois conjuntos de entradas estiverem vazios, ent√£o, obviamente, retornamos 0. Em seguida, iniciamos um loop infinito, no qual, se houver uma correspond√™ncia, aumentamos o resultado em 1 e verificamos se o ciclo deve ser conclu√≠do.  Em vez de um loop infinito, pode-se usar a instru√ß√£o for e especificar a condi√ß√£o para encerrar o loop nela.  Mas isso significaria trabalho extra.  Na implementa√ß√£o que voc√™ v√™ no slide, no primeiro ramo, temos `if (a1 [i1] &lt;a2 [i2]), ap√≥s o qual h√° um aumento de` i1 em 1 e s√≥ podemos verificar `i1.  Da mesma forma, no segundo ramo, precisamos apenas checar `i2.  Ambos os valores precisam ser verificados apenas na terceira ramifica√ß√£o.  Se essa verifica√ß√£o estivesse no in√≠cio do ciclo, far√≠amos o trabalho extra. <br><br>  Vamos tentar melhorar essa implementa√ß√£o.  No momento, sua complexidade algor√≠tmica √© linear, dependendo de dois argumentos de entrada.  No aprendizado de m√°quina, muitas vezes √© preciso encontrar a interse√ß√£o de conjuntos que s√£o muito diferentes um do outro em tamanho ou em estat√≠stica.  Por exemplo, voc√™ tem um vetor de entrada longo e um vetor de recurso curto que voc√™ est√° verificando.  Em nosso c√≥digo, pode haver um milh√£o de registros em `a1 e mil em` a2.  Nesse caso, n√£o estamos prontos para executar um milh√£o de etapas para concluir esse algoritmo.  A maior carga aqui ser√° na seguinte linha de c√≥digo: `if (++ i1 == a1.length) break.  Pouco antes disso, ocorre uma compara√ß√£o e, nessa linha, h√° um incremento do valor;  isso, em ess√™ncia, √© uma pesquisa linear.  Repetimos um vetor longo em busca de elementos de um vetor curto.  Na pior das hip√≥teses, realizaremos muitas dessas pesquisas, movendo-se lentamente ao longo do vetor. <br><br>  Vamos tentar melhorar esse algoritmo.  Bem, se n√£o for pesquisa linear, ent√£o bin√°rio √© melhor, certo?  Vamos usar bin√°rio.  Sua vantagem √© que ele fornece o √≠ndice do maior dos elementos menores. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i1 != a1.Length; ++i1) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = Bsearch(a2, a1[i1]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == a2.Length) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; --m; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(a2[m] &lt; a1[i1])) t[i++] = a1[i1]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre><br>  O c√≥digo acima √© uma implementa√ß√£o do nosso algoritmo de busca bin√°ria.  Mas n√£o √© muito eficaz.  A pior situa√ß√£o aqui ser√° quando a pesquisa bin√°ria falhar√° sempre.  E surgir√° em cen√°rios bastante importantes - por exemplo, quando os dois conjuntos s√£o id√™nticos.  Voc√™, como um tolo, corta c√≠rculos com busca bin√°ria, enquanto apenas precisa passar pelo primeiro algoritmo linear.  Por que pesquisa bin√°ria, quando o item desejado - toda vez aqui, o primeiro da lista? <br><br>  Como fazer o algoritmo funcionar com sucesso em dados id√™nticos e diferentes?  A verifica√ß√£o de todos os dados ser√° muito cara para recursos.  Farei uma reserva de que n√£o se trata de dados completamente id√™nticos, mas de muito semelhantes, com estat√≠sticas semelhantes, os tamanhos tamb√©m podem variar.  Voc√™ pode verificar os seguintes itens.  A solu√ß√£o √≥bvia √© reduzir sua pesquisa.  Quando realizamos uma pesquisa bin√°ria, depois de encontrar algum elemento, n√£o estamos mais interessados ‚Äã‚Äãem elementos menores que ele, pois o segundo vetor tamb√©m √© classificado.  Assim, podemos reduzir sempre nossa √°rea de pesquisa, descartando todos os elementos menos do elemento encontrado. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i1 != a1.Length; ++i1) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = Bsearch(a2, i2, a2.Length, a1[i1]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == i2) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(a2[m - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; a1[i1])) t[i++] = a1[i1]; i2 = m + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre> <br>  Aqui est√° a implementa√ß√£o dessa abordagem.  Voc√™ v√™ que realizamos uma pesquisa bin√°ria a cada vez para uma parte da matriz original come√ßando com `i2 e terminando com` a2.length.  Como o `i2 aumentar√° a cada pesquisa, a √°rea de pesquisa ser√° reduzida. <br><br>  A pr√≥xima otimiza√ß√£o que eu gostaria de implementar aqui est√° relacionada ao algoritmo Galloping Search.  Em ess√™ncia, esta √© uma pesquisa bin√°ria com uma etapa diferente.  No caso da pesquisa bin√°ria, come√ßamos sempre do meio - mas vamos pensar que, quando procuramos um nome na lista telef√¥nica, n√£o o abrimos no meio?  Se o sobrenome de uma pessoa come√ßar, digamos, em "B", abriremos o livro mais perto do in√≠cio.  Esse princ√≠pio √© implementado em uma pesquisa galopante: come√ßamos a rastrear os dados na dire√ß√£o ascendente com um passo exponencialmente aumentado ap√≥s cada verifica√ß√£o: primeiro 1, depois 2 e depois 4. Isso nos d√° uma boa complexidade algor√≠tmica.  Se o passo crescesse linearmente, a complexidade seria quadr√°tica.  Quando pulamos o elemento que procuramos, realizamos uma pesquisa bin√°ria normal no segmento restante, que ser√° pequeno e n√£o afetar√° significativamente o tempo de execu√ß√£o do algoritmo.  Assim, combinamos todas as vantagens de ambas as abordagens.  Implementa√ß√£o de um algoritmo desse tipo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GBsearch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step = <span class="hljs-number"><span class="hljs-number">1</span></span>;; step *= <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt;= j) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i] &gt; v) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i + step &gt;= j) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Bsearch(a, i + <span class="hljs-number"><span class="hljs-number">1</span></span>, J, v); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i + step] &gt; v) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Bsearch(a, i + <span class="hljs-number"><span class="hljs-number">1</span></span>, i + step, v); i += step + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre> <br>  Agora, discutimos o dimensionamento, ou seja, tentamos encontrar a interse√ß√£o de mais de dois conjuntos.  Para cada pesquisa de v√°rias palavras, precisaremos encontrar a interse√ß√£o de v√°rios conjuntos.  Para fazer isso, podemos, por exemplo, comparar os dois primeiros conjuntos, depois sua interse√ß√£o com o terceiro e assim por diante.  Mas essa n√£o √© uma solu√ß√£o ideal.  Precisamos pegar os primeiros elementos de todos os conjuntos e encontrar o menor deles, que precisar√° ser movido.  Precisamos de uma estrutura de dados que permita encontrar o menor dos muitos elementos e tenha complexidade constante.  Essa estrutura de dados √© um monte.  Mas ser√° um grupo estranho, n√£o ser√° baseado em uma matriz f√≠sica.  Ser√° imagin√°rio, organizaremos nele apenas os primeiros elementos de nossos conjuntos.  Depois de encontrarmos o menor elemento na pilha, ainda podemos procurar todos os outros conjuntos. <br><br>  O trabalho sobre os t√≥picos que estamos discutindo na pr√°tica hoje tem uma forma artesanal.  Na pr√°tica, na maioria das vezes teremos v√°rios conjuntos, n√£o apenas dois, e muito trabalho foi escrito sobre esse t√≥pico.  O algoritmo cl√°ssico aqui √© o SVS, no qual agrupamos os conjuntos, pegamos os dois menores e escolhemos o menor como candidato.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui</a> voc√™ pode encontrar uma boa vis√£o geral sobre esse t√≥pico.  Os problemas associados aos conjuntos de interse√ß√£o, o produto escalar de vetores esparsos, a classifica√ß√£o por mesclagem e as formas de compara√ß√£o com a imagem ao longo do tempo est√£o se tornando cada vez mais interessantes.  O algoritmo que mostrei para voc√™ se estabeleceu como muito √∫til.  Obrigado pela aten√ß√£o. <br><br><blockquote>  Andrei Alexandrescu n√£o chegar√° ao DotNext 2018 em Moscou, mas Jeffrey Richter, Greg Young, Pavel Yosifovich e outros estar√£o l√°.  Os nomes dos palestrantes e os t√≥picos dos relat√≥rios podem ser encontrados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e os ingressos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Inscreva-se agora! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425191/">https://habr.com/ru/post/pt425191/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425175/index.html">Um pouco sobre placas de som com sintetizadores OPL2 / 3 FM para PC ...</a></li>
<li><a href="../pt425177/index.html">Aprenda t√°ticas, t√©cnicas e conhecimentos comuns do advers√°rio (ATT @ CK). T√°ticas corporativas. Parte 3</a></li>
<li><a href="../pt425179/index.html">As estrelas do YouTube come√ßam a esgotar-se no trabalho: "o apelo dos mais interessantes do trabalho desapareceu"</a></li>
<li><a href="../pt425181/index.html">Frankie Zapata para The Verge: "O combust√≠vel turbojato ajudar√° a derreter o ceticismo do concreto armado"</a></li>
<li><a href="../pt425187/index.html">PAC Intel com FPGA Stratix 10 SX - acelerador para grandes tarefas</a></li>
<li><a href="../pt425195/index.html">Listas em preto, branco e cinza protegem a seguran√ßa da empresa</a></li>
<li><a href="../pt425197/index.html">Estimativa de custos de um projeto de implementa√ß√£o de IDM - Como prever surpresas</a></li>
<li><a href="../pt425199/index.html">O que protege os compradores contra fraudes no pagamento sem contato</a></li>
<li><a href="../pt425203/index.html">Antiga vulnerabilidade UPnP de uma nova maneira</a></li>
<li><a href="../pt425205/index.html">Soft Skills em gerenciamento de projetos: conceito, objetivos e dicas para o uso bem-sucedido dos neg√≥cios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>