<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚼 🚇 👩🏾‍🤝‍👨🏿 Dagaz: Aus dem Nebel 👦🏼 🧒 👧🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All dies ist die Königin der Königin Mab. 
 Sie webt im Stall einer Mähne 
 Und die Haare werfen ein Gewirr nieder ... 

 William Shakespeare 

 Es wa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dagaz: Aus dem Nebel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422427/"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="Bild">  <b><i>All dies ist die Königin der Königin Mab.</i></b> <b><i><br></i></b>  <b><i>Sie webt im Stall einer Mähne</i></b> <b><i><br></i></b>  <b><i>Und die Haare werfen ein Gewirr nieder ...</i></b> <b><i><br><br></i></b>  <b><i>William Shakespeare</i></b> <br><br>  Es war eine lange <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Veröffentlichung</a> , aber es wurde viel getan.  Es wurde ein <a href="">Sitzungsmanager angezeigt</a> , mit dem Sie versehentlich ausgeführte Züge zurücksetzen können.  An einigen Stellen wurde Sounddesign hinzugefügt.  Und doch habe ich mir eine coole <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Möglichkeit</a> ausgedacht, mehrere alternative Optionen für die Erstplatzierung in einem Spiel zu finden.  Und vor allem - ich bin endlich mit unvollständigen Informationen zu den Spielen gekommen. <br><a name="habracut"></a><br>  Ich werde erklären, worum es geht.  Bei den üblichen Brettspielen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schach</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dame</a> haben die Spieler zu jeder Zeit im Spiel vollständige Informationen über die Position der Figuren (ihre eigenen und die des Gegners), die Regeln für das Verschieben der Figuren, die Ziele des Spiels usw.  Solche Spiele sind ziemlich gut studiert und fallen in die Kategorie " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spiele mit vollständigen Informationen</a> ".  Stellen Sie sich nun vor, dass einige dieser Informationen vor dem Player verborgen sind. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/1h/hd/xl/1hhdxlqk7btnosi-jpow5azj-xy.png"></a> </div><br>  Der Nebel des Krieges ist eine großartige Illustration des Themas.  Nach den Regeln des „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">blinden Schachs</a> “ können die Spieler nicht alle Teile des Feindes sehen, sondern nur diejenigen, die auf den Feldern platziert sind und mit einem Zug einer ihrer Teile erreicht werden können.  Ich habe diese Regel zwei Mal ergänzt: <br><br><ol><li>  Natürlich sieht der Spieler <b>seine</b> Figuren immer, aber anhand der Art und Weise, wie sie angezeigt werden - in normaler Form oder durchscheinend - kann er beurteilen, ob der Gegner sie sieht. </li><li>  Nur zu Dekorationszwecken habe ich „Wolken“ auf Bereiche gelegt, die derzeit unsichtbar sind. </li></ol><br>  Nachdem ich das allgemeine <a href="">Prinzip</a> beherrscht hatte, wurde ich ein wenig mitgerissen und machte eine große Anzahl von Spielen mit dem "Nebel des Krieges".  Zusätzlich zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schach selbst habe</a> ich "dunkle" Optionen für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Xiang</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Changi</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shatrange</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sittuyin</a> und viele andere Spiele.  Es gibt sogar eine " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blind Guns</a> "!  Alle diese Spiele haben eines gemeinsam: <br><br><div class="spoiler">  <b class="spoiler_title">Der Computer betrügt!</b> <div class="spoiler_text">  Ich habe nicht einmal versucht, Änderungen an den Algorithmen der Bots für diese Spiele vorzunehmen, da ich darauf gewettet habe, dass ungleiche Bedingungen ihr im Vergleich zu Menschen extrem schwaches Spiel zumindest teilweise ausgleichen.  Wie ich bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geschrieben</a> habe, ist die Entwicklung einer hochwertigen KI für Brettspiele eine sehr schwierige Aufgabe.  Natürlich haben die Regeln Ausnahmen.  Selbst bei einem sehr schwachen Spiel des Bots wird es für eine Person schwierig sein, ein ungewohntes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spiel</a> zu spielen, das buchstäblich mit Fallen vollgestopft ist.  Was können wir über seine "dunkle" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version</a> sagen? <br></div></div><br>  Im Allgemeinen ist dies jedoch kein sehr korrekter Ansatz.  Ich möchte einen Bot sehen, der genau mit den Daten seines Gegners umgehen kann - man.  Warum ist das wichtig?  Alles ist sehr einfach - durch die Art und Weise, wie der Bot spielt, ist es manchmal sehr leicht zu erraten, ob er Zugriff auf versteckte Informationen (Peeps) hat oder nicht.  Und natürlich ist es für eine Person viel interessanter, mit diesem Bot zu spielen, <b>der nicht</b> guckt (das Spielen mit einer anderen Person ist noch interessanter, aber das ist eine andere Geschichte). <br><br>  Und hier lohnt es sich, ein Spiel zu wählen, das sich geringfügig vom Schach unterscheidet (da ich nicht bereit bin, einen "ehrlichen" Bot zu entwickeln, der "blind" Schach spielt).  Es gibt viele solcher Spiele und es kann nicht gesagt werden, dass sie einfacher sind als Schach oder Dame.  Sie sind einfach anders und erfordern einen individuellen Ansatz. <br><br><div class="spoiler">  <b class="spoiler_title">Zum Beispiel</b> <div class="spoiler_text">  Es gibt ein Kinderspiel, mit dem ich noch keinen Bot entwickelt habe.  Es heißt "Dschungel" oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dou Shou Qi</a> .  Das Ziel des Spiels ist es, feindliches Gebiet zu durchdringen.  Jeder der Spieler hat eine „Höhle“ - ein zentrales Feld in der ersten Zeile.  Wenn eine der feindlichen Figuren das Versteck betritt, hat er gewonnen (Sie können das Versteck nicht mit Ihren eigenen Figuren besetzen). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l_/rz/cb/l_rzcbk0dmvj5ul8m1e4wdefrny.png"></div><br>  Die Zahlen sind nach Dienstalter geordnet.  Der Elefant schlägt alle Figuren, gefolgt von: Löwe, Tiger, Leopard, Hund, Wolf, Katze und Ratte.  Eine Ratte kann nur einen Elefanten und eine andere Ratte schlagen. Außerdem ist dies die einzige Figur, die sich im Wasser bewegen kann (in der Mitte des Bretts befinden sich zwei Reservoire).  Ein Tiger und ein Löwe können über Wasser springen, aber nur, wenn die Ratte das Wasser nicht blockiert.  Mit Ausnahme von Sprüngen bewegen sich alle Figuren auf die gleiche Weise - vertikal oder horizontal zu einem benachbarten Feld.  Das Versteck ist von Fallen umgeben.  Die Figur in der Falle ist für <b>jede</b> feindliche Figur anfällig. <br><br>  Wie Sie sehen können, sind die Regeln ziemlich einfach.  Was verhindert die Entwicklung eines Bots für dieses Spiel?  Zuallererst die langsamen Zahlen.  Wenn es Bedrohungen gibt, kann ich die Vorteile des Austauschs schätzen, aber für den größten Teil des Spiels laufen die Teile einfach über ziemlich lange Strecken nacheinander.  Ich kann es mir nicht leisten, das Spiel für eine große Anzahl von Zügen vorwärts anzusehen (aufgrund von Einschränkungen bei der Dauer der Berechnung des Zuges), wodurch die Änderungen außerhalb des Betrachtungshorizonts liegen und alle Züge für mich gleichwertig werden. <br></div></div><br>  Zunächst entschied ich mich für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BanQi</a> - Chinese Blind Chess.  Dies ist ein sehr originelles Spiel mit versteckten Informationen, ähnlich dem "Dschungel".  Für mich ist es wichtig, dass die Entwicklungen im Zusammenhang mit der Erstellung eines Bots für dieses Spiel in anderen Spielen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dou Shou Qi</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Luzhan Qi</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stratego</a> oder sogar (möglicherweise) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tafl verwendet werden können</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bG11at_PKxA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ich erzähle dir von den Regeln.  Das Spiel läuft auf der Hälfte des Bretts für "Chinesisches Schach" ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Xiang Qi</a> ), während das ursprüngliche Layout des Bretts keine Rolle spielt.  Die Stücke werden innerhalb der Zellen platziert (wie bei herkömmlichen) und nicht an den Schnittpunkten von Linien (wie beim chinesischen Schach).  Zu Beginn des Spiels werden alle Teile gründlich gemischt und verdeckt auf das Brett gelegt (da die traditionellen Stücke von Syants eine Art Fässer sind und ihre Anzahl mit der Anzahl der Felder auf der Hälfte des Bretts übereinstimmt, gibt es keine Schwierigkeit). <br><br>  Als nächstes wechseln die Spieler ihre Züge.  Durch Ausführen eines Zuges kann der Spieler jedes der geschlossenen Teile umdrehen oder ein zuvor geöffnetes Teil seiner Farbe bewegen.  Die Farben der Spieler werden vom ersten Zug an bestimmt.  Wenn das erste schwarze Stück geöffnet wird, spielt der Spieler, der es geöffnet hat, schwarz.  Alle Figuren im Spiel gehen den gleichen Weg (mit Ausnahme der „Kanone“ in der taiwanesischen Version, die ich später diskutieren werde) - auf einer benachbarten Zelle vertikal oder horizontal.  Die Möglichkeit der Aufnahme wird durch die Reihenfolge des Dienstalters der Figuren bestimmt: <br><br>  <b>Allgemein&gt; Berater&gt; Elefant&gt; Wagen&gt; Pferd&gt; Kanone&gt; Soldat</b> <br><br>  Ältere Figuren schlagen jünger oder gleich, mit einer Ausnahme: Ein Soldat schlägt den General (eine Art " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stein-Papier-Schere</a> ").  Es bleibt noch ein paar Worte über das taiwanesische BanQi zu sagen: <br><br><ol><li>  Im Gegensatz zur chinesischen Version kann in Taiwan BanQi ein General einen Soldaten nicht schlagen. </li><li>  Die Kanone bewegt sich gemäß den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XiangQi-</a> Regeln, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dh</a> zu einer beliebigen Anzahl von Feldern, die mit niedriger Geschwindigkeit orthogonal sind (wie ein Streitwagen), oder trifft eine feindliche Figur mit einem Sprung durch den "Wagen", wenn sie eine Angriffsbewegung ausführt. </li></ol><br>  Es gibt auch eine Hongkong-Version, die sich jedoch praktisch nicht von den Chinesen unterscheidet, außer dass die Reihenfolge des Dienstalters der Zahlen geändert wurde.  Ich beschloss, mich auf die taiwanesische Version der Regeln als die taktisch interessanteste zu konzentrieren. <br><br><div class="spoiler">  <b class="spoiler_title">Worauf sollte ich bei der Entwicklung eines Bots achten?</b> <div class="spoiler_text">  Erstens sieht das Spiel sehr einfach aus, ist es aber nicht.  Selbst wenn Sie die mit den taiwanesischen Waffen verbundenen Nuancen nicht berücksichtigen, sind die Kosten für die Zahlen nicht intuitiv.  Obwohl der "Berater" weniger Figuren schlagen kann als der "General", ist er der Hauptprotagonist im Spiel.  Erstens hat der Spieler zwei Berater.  Außerdem ist jedem Berater nur ein feindlicher General überlegen, während der General von bis zu fünf Soldaten angegriffen werden kann!  Aus dem gleichen Grund sind die Kosten eines Soldaten in einem Spiel höher als die Kosten eines Generals.  Am Ende kann er die stärkste Figur schlagen!  Die zweite wichtige Überlegung legt eines der "Canterbury" -Puzzles von Henry Dudeney nahe. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v9/jd/ax/v9jdaxvmdjxuvp-gw6sr9h7_i8a.png"></div><br>  Dies ist eher eine Scherzaufgabe als ein komplettes Rätsel.  Alle Figuren können vertikal oder horizontal zu einem benachbarten Feld gehen.  Weiß bewegt sich zuerst, während Weiß und Schwarz immer zwei Züge machen (in verschiedenen Teilen)!  Unter diesen Bedingungen kann der linke Trottel niemals den linken Esel fangen, und der rechte Trottel kann niemals den rechten fangen (Sie können es selbst überprüfen).  Natürlich kann der rechte Narr den linken Esel problemlos fangen.  Es geht nur um Parität! <br><br>  Dieses Problem gab mir einige Gedanken.  Erstens besteht die Aufgabe des Bots in Spielen wie BanQi oder DouShouQi darin, zunächst den kürzesten Weg zu finden.  Aus jedem der aktiven Teile (dem eigenen oder dem Gegner) müssen Bewegungsketten zu allen möglichen Zielen aufgebaut werden (einschließlich der eigenen Teile, um den möglichen Austausch zu berechnen).  Danach müssen die Ketten ausgewertet werden und die folgenden Optionen sind hier möglich. <br><br><ol><li>  Die angreifende Figur schlägt die angegriffene - eine profitable (Bonus-) Kette, die anhand der Kosten der angegriffenen Figur (abzüglich der Kosten der angreifenden Figur, wenn diese geschützt ist) unter Berücksichtigung der Länge der Kette geschätzt wird. </li><li>  Die angreifende Figur schlägt die angegriffene - keine profitable (Straf-) Kette, geschätzt durch den Wert der angreifenden Figur. </li><li>  Die Figuren schlagen sich gegenseitig (zum Beispiel sind sie gleich) - hier hängt alles von der Parität ab, die ungeraden Ketten sind vorteilhaft und die geraden sollten als Strafketten betrachtet werden (wenn es keine anderen Figuren auf dem Spielfeld gäbe, würde die Parität das Ergebnis des Spiels vollständig bestimmen). </li></ol><br>  Natürlich ist nicht alles so einfach.  Zumindest sollten Sie sich an den spezifischen Verlauf der Kanonen in Taiwans BanQi erinnern (für den „Dschungel“ gibt es noch mehr Sonderfälle), aber hier können Sie beginnen.  Mit einem vollständigen Satz ausgewerteter Ketten können Sie Bewegungen bewerten.  Die Kosten für den Umzug sollten sich aus den Kosten der Ketten (sowohl Bonus als auch Gratis) zusammensetzen, deren Länge sich verringert. <br></div></div><br>  Zunächst ist es wichtig zu verstehen, dass es unwahrscheinlich ist, dass hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Minimax-</a> Algorithmen effektiv eingesetzt werden können.  Bewegungen, die zuvor verborgene Teile aufdecken, ändern die Positionsschätzung zu radikal.  Ohne Informationen über versteckte Teile ist es fast unmöglich, eine Position zu sehen, die viele Schritte voraus ist.  Aber jede Wolke hat einen Silberstreifen, aber wir können viel komplexere (rechnerische) Heuristiken verwenden, um die Bewegungen selbst zu bewerten! <br><br>  Ich habe bereits <a href="">einen</a> Bot, der Bewegungen anhand ihrer Heuristik bewertet (für ein lustiges <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spiel</a> erforderlich).  Dies ist ein sehr einfacher Algorithmus.  Alle Züge werden in absteigender Reihenfolge nach Heuristik sortiert (Züge mit einem negativen heuristischen Wert werden im Allgemeinen verworfen), wonach sie der Reihe nach gescannt werden.  Wenn der nächste Zug zu einer Position führt, von der aus keine feindliche Reaktion zu einem sofortigen Sieg führt, hält der Bot dies für die beste.  Mit diesem Algorithmus können Sie sich nicht um die Positionsschätzung kümmern, sondern müssen über <a href="">Heuristiken</a> schwitzen. <br><br><div class="spoiler">  <b class="spoiler_title">Zunächst bauen wir Ketten</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getChains = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = board.getValue(board.player); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (player === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.chains)) { board.chains = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pieces = getGoals(design, board); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targets = getTargets(design, board, pieces); _.each(pieces.positions, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> goals = pieces; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!chinese &amp;&amp; (piece.type == <span class="hljs-number"><span class="hljs-number">12</span></span>)) { goals = targets; f = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> group = [ pos ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> level = []; level[pos] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; group.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.indexOf(goals.positions, group[i]) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  ... } if ((i &gt; 0) &amp;&amp; (board.getPiece(group[i]) !== null)) continue; _.each(design.allDirections(), function(dir) { p = design.navigate(board.player, group[i], dir); while (p !== null) { if (_.indexOf(group, p) &gt;= 0) break; group.push(p); level[p] = level[ group[i] ] + 1; if (f || (board.getPiece(p) !== null)) break; p = design.navigate(board.player, p, dir); } }); } }); } return board.chains; }</span></span></code> </pre> </div></div><br>  Natürlich speichere ich alle Zwischendaten im Spielzustand zwischen, um sie nicht mehrmals zu lesen.  Zusätzlich wird hier ein Trick verwendet, der bei der Berechnung verbundener Bereiche sehr nützlich ist.  Ich iteriere über das <b>Gruppenarray</b> und füge bei Bedarf zusätzliche Elemente in die Schleife ein.  Alle Schwierigkeiten sind mit Waffen verbunden.  Für sie sind die Ziele der Ketten nicht die Figuren selbst, sondern die Felder, von denen aus letztere angegriffen werden können. <br><br><div class="spoiler">  <b class="spoiler_title">Die Ketten werden genau wie gesagt ausgewertet</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getChainPrice = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board, attacker, attacking, len</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = board.getValue(board.player); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((player === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || (attacker == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || (attacking === <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attacker.player == attacking.player) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isAttacking = isAttacker(design, attacker.type, attacking.type); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isAttacked = isAttacker(design, attacking.type, attacker.type); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!chinese &amp;&amp; (attacker.type == <span class="hljs-number"><span class="hljs-number">12</span></span>)) { isAttacking = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; isAttacked = (attacking.type == attacker.type) &amp;&amp; (len == <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> price = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = (len % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attacker.player != player) f = !f; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAttacking) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAttacked) { price = f ? (len - design.price[attacker.type]) : (design.price[attacking.type] - len); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { price = design.price[attacking.type] - len; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f) price = (price / <span class="hljs-number"><span class="hljs-number">2</span></span>) | <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAttacked) { price = len - design.price[attacker.type]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price; }</code> </pre></div></div><br>  ... abhängig von der Länge und Parität der Kette sowie unter Berücksichtigung der Kosten der angreifenden und angegriffenen Figuren.  Aber das ist nur die halbe Miete!  Es ist notwendig, jede der möglichen Bewegungen unter Verwendung der konstruierten Ketten zu bewerten.  Ich führe eine weitere Zwischenstruktur ein - möchte die verfügbaren Daten aggregieren.  Die Bewertung des Kurses besteht aus der Bewertung von Wünschen, die erfüllt werden: <br><br><div class="spoiler">  <b class="spoiler_title">So etwas in der Art</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> addWish = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">board, comment, price, src, dst</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.wish[src])) { board.wish[src] = []; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(dst)) dst = src; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.wish[src][dst])) { board.wish[src][dst] = price; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { board.wish[src][dst] += price; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getWish = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.wish)) { ... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> board.wish; } Dagaz.AI.heuristic = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ai, design, board, move</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wish = getWish(design, board); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (move.isSimpleMove() &amp;&amp; !_.isUndefined(wish[ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ]) &amp;&amp; !_.isUndefined(wish[ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ][ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wish[ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ][ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre></div></div><br>  Was die <b>getWish-</b> Funktion <b>selbst betrifft</b> , beginnt hier die Magie (und dies ist der Ort, an dem ich höchstwahrscheinlich mehr als einmal gepflügt habe).  Zunächst teile ich die Bewertung von Zügen anhand offener Informationen und die Einführung neuer Teile in das Spiel.  Das ist nicht ganz richtig, aber bisher weiß ich einfach nicht, wie ich so unterschiedliche Meinungen in Einklang bringen kann.  Wenn aufgrund offener Informationen keine Wünsche gebildet wurden, versucht der Bot, neue Figuren zu öffnen (hier gibt es auch einige Tricks). <br><br><ol><li>  Wenn eine feindliche Kanone offen und von geschlossenen Figuren umgeben ist, ist es sinnvoll, eine der Figuren daneben zu öffnen, da es wahrscheinlich ist, dass sie die Waffe angreifen kann und die Waffe sie auf keinen Fall schlagen kann. </li><li>  Wenn eine andere Figur als eine Kanone geöffnet ist, können Sie versuchen, eine Figur zu öffnen, die sich durch den "Wagen" von dort befindet, da die Möglichkeit besteht, dass es sich um eine Kanone handelt. </li><li>  Wenn sich von der feindlichen Seite eine Angriffskette befindet, kann eines der Teile neben der Kette geöffnet werden, um den Angriff abzufangen. </li><li>  Wenn Sie die Figur nicht schützen können, können Sie die Figur daneben öffnen und versuchen, die Situation auf einen Austausch zu reduzieren. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Natürlich ist es nützlich, die Wahrscheinlichkeit des Öffnens einer bestimmten Figur zu bewerten.</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getShadow = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = board.getValue(board.player); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (player === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.shadow)) { board.shadow = []; _.each(design.allPositions(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (piece.type &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = piece.type + <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece.player != player) { value = -value; } board.shadow.push(value); } }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> board.shadow; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isFriend = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isPiece = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, x, y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x == y; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isAttacker = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, x, enemy</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x == <span class="hljs-number"><span class="hljs-number">13</span></span>) &amp;&amp; (enemy == <span class="hljs-number"><span class="hljs-number">7</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!chinese &amp;&amp; (x == <span class="hljs-number"><span class="hljs-number">7</span></span>) &amp;&amp; (enemy == <span class="hljs-number"><span class="hljs-number">13</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!chinese &amp;&amp; (x == <span class="hljs-number"><span class="hljs-number">12</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &lt;= enemy; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isDefender = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, x, enemy, friend</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isAttacker(design, x, enemy)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> design.price[friend] &lt;= design.price[enemy]; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> estimate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board, p, y, z</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shadow = getShadow(design, board); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shadow.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>; _.each(shadow, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p(design, x, y, z)) r++; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-number"><span class="hljs-number">100</span></span> * r) / shadow.length; }</code> </pre></div></div><br>  Der Spieler kann die Wahrscheinlichkeiten bewerten, indem er die Zahlen verfolgt, die das Spiel abgebrochen haben.  Im Prinzip kann der Bot dasselbe tun, aber es gibt einen einfacheren Weg - die noch nicht offenen Zahlen in großen Mengen zu betrachten und die Wahrscheinlichkeit des Öffnens der gewünschten anhand der gesammelten Informationen zu bewerten.  Darüber hinaus ist der Erfolg des ausgewählten Zuges nicht garantiert, aber wenn die Wahrscheinlichkeit eines günstigen Ergebnisses gering ist, wird der Zug überhaupt nicht ausgewählt. <br><br><div class="spoiler">  <b class="spoiler_title">Im Prinzip hat sich der Ansatz ausgezahlt, aber es gibt noch viel zu tun.</b> <div class="spoiler_text">  Während Defensivbewegungen nicht sehr gut sind.  Einige Figuren treffen tapfer auf den stärkeren Feind, anstatt vor ihm wegzulaufen (obwohl es in ihrem Fall in der Regel schon nutzlos ist, wegzulaufen).  Es gibt auch Schwierigkeiten, die Aktionen verschiedener Figuren zu koordinieren (dies kann nützlich sein, um die Überreste feindlicher Figuren zu „treiben“).  Der Ansatz selbst sieht sehr vielversprechend aus, aber die Heuristik muss noch berücksichtigt werden. <br><br>  Heuristiken, die auf „Ketten“ von Zügen basieren, können nicht nur in BanQi, sondern auch in vielen anderen Spielen nützlich sein, wobei „langsame“ Teile überwiegen (wenn nicht als definierendes Kriterium, dann zumindest für eine vorläufige Bewertung der Qualität von Zügen in komplexeren Algorithmen) am wenigsten).  Dieser Ansatz ist besonders bei Spielen gefragt, bei denen die Verwendung von Minimax-Algorithmen schwierig oder sogar unmöglich ist (wie zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yonin Shogi</a> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k_/x3/dq/k_x3dqvxu3swinw7qkgmvo__6km.png"></div><br>  Natürlich werde ich weiterhin an Spielen mit unvollständigen Informationen arbeiten.  Das Bild zeigt das philippinische " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spiel der Generäle</a> ", noch nicht fertig.  Dies ist das einfachste Spiel einer großen Familie, einschließlich Spiele wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LuzhanQi</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stratego</a> .  Und natürlich erwarte ich immer noch einen funktionierenden Bot für den " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dschungel</a> "! <br></div></div><br>  Und für diejenigen, die mich noch lesen, kann ich ein weiteres lustiges Puzzlespiel mit versteckten Informationen anbieten: <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/bm/aa/4p/bmaa4p2ctbqb_9k_oz1wjoulx9c.png"></a> </div><br>  Ich habe es in meiner Kindheit auf einem programmierbaren Taschenrechner namens Fox Hunt gespielt.  Acht Füchse sind zufällig auf dem Feld versteckt, die mit der „Poke-Methode“ gefunden werden müssen.  Wenn Sie einen leeren Bereich auswählen, wird die Gesamtzahl der Füchse in alle acht Richtungen angezeigt.  Es ist unmöglich zu verlieren, aber Sie können um die minimale Anzahl von Klicks konkurrieren.  Und wenn Sie mit Kopfhörern spielen, verringern Sie den Ton.  Vielleicht habe ich es mit Soundeffekten übertrieben. <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422427/">https://habr.com/ru/post/de422427/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422417/index.html">Slavik und GMT + 3 oder Nutzen für Menschen</a></li>
<li><a href="../de422419/index.html">Nicht ohne Panik in Go</a></li>
<li><a href="../de422421/index.html">Microsoft wird Skype radikal verbessern</a></li>
<li><a href="../de422423/index.html">Python und DataScience: Entdecken Sie die Leistungsfähigkeit der Numpy Universal Library</a></li>
<li><a href="../de422425/index.html">Ein Überblick über Nachbearbeitungsmethoden für FDM 3D-gedruckte Modelle</a></li>
<li><a href="../de422429/index.html">Wir beschleunigen den Prozess der Entwicklung komplexer Projekte. Ohne Chaos und Nerven</a></li>
<li><a href="../de422431/index.html">Japanische Feen zeigen Master-Slave-Trigger in neuem Manga auf digitaler Elektronik</a></li>
<li><a href="../de422433/index.html">Sonnenkollektoren und Asphaltstraßen. Symbiose der Technologie</a></li>
<li><a href="../de422435/index.html">Timer - Start</a></li>
<li><a href="../de422437/index.html">User Experience-Spiele sowie Website- und Anwendungsgeschwindigkeit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>