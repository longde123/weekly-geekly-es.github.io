<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾 😰 ☝🏽 Attraper les fuites de mémoire en C / C ++ 🎐 👎🏼 💪🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je vous salue, Khabrovchians! 


 Aujourd'hui, je veux ouvrir un peu de lumière sur la façon de gérer la fuite de mémoire en C ou C ++. 


 Il y a déj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Attraper les fuites de mémoire en C / C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480368/"><p><img src="https://habrastorage.org/webt/u4/5k/td/u45ktd0wvbjglbnusjeg-pwyrmq.jpeg"></p><br><p>  Je vous salue, Khabrovchians! </p><br><p>  Aujourd'hui, je veux ouvrir un peu de lumière sur la façon de gérer la fuite de mémoire en C ou C ++. </p><br><p> Il y a déjà deux articles sur Habré, à savoir: <a href="https://habr.com/ru/post/82514/">Nous traitons des fuites de mémoire (C ++ CRT)</a> et des <a href="https://habr.com/ru/post/113567/">fuites de mémoire en C ++: Visual Leak Detector</a> .  Cependant, je pense qu'elles ne sont pas suffisamment divulguées, ou que ces méthodes peuvent ne pas donner le résultat dont vous avez besoin, je voudrais donc faire dans la mesure du possible toutes les méthodes disponibles afin de vous faciliter la vie. </p><a name="habracut"></a><br><p>  <strong>Windows - développement</strong> <br>  Commençons par Windows, à savoir le développement pour Visual Studio, car la plupart des programmeurs novices écrivent spécifiquement pour cet IDE. </p><br><p><img src="https://habrastorage.org/webt/me/gj/vd/megjvd674_ifi-0fywxd_g3xefy.jpeg"></p><br><p>  Pour comprendre ce qui se passe, j'applique un vrai exemple: </p><br><div class="spoiler">  <b class="spoiler_title">Main.c</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">struct Student </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_student</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ControlMenu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ControlMenu(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowListMenu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kX)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> listMenu[COUNT_LIST_MENU][<span class="hljs-number"><span class="hljs-number">55</span></span>] = { {<span class="hljs-string"><span class="hljs-string">"Read students from file"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Input student and push"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Input student and push it back"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Input student and push it after student"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Delete last student"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Write students to file"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Find student"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Sort students"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Show list of students"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Exit"</span></span>} }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; COUNT_LIST_MENU; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == kX) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s"</span></span>, listMenu[i]); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" &lt;=\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s\n"</span></span>, listMenu[i]); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ControlMenu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListOfStudents</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kX = <span class="hljs-number"><span class="hljs-number">0</span></span>, key; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> = FALSE; ShowListMenu(kX); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { key = _getch(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (key) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">72</span></span>: <span class="hljs-comment"><span class="hljs-comment">//up { if (kX == 0) kX = COUNT_LIST_MENU-1; else kX--; }break; case 80: //down { if (kX == COUNT_LIST_MENU-1) kX = 0; else kX++; }break; case 13: { if (kX == 0) { int sizeStudents = 0; struct Student* students = (struct Student*)malloc(1 * sizeof(struct Student)); char* path = (char*)malloc(255 * sizeof(char)); printf("Put the path to file with students: "); scanf("%s", path); int size = 0; students = read_students(path, &amp;size); if (students == NULL) { printf("Can't open this file.\n"); } else { for (int i = 0; i &lt; size; i++) { if (i == 0) { list = init(students[i]); } else { list = add_new_elem_to_start(list, students[i]); } } } free(students); printf("\nPress any key to continue..."); getchar(); getchar(); free(path); } else if (kX == 1 || kX == 2 || kX == 3 || kX == 6) { struct Student student = create_student(); if (kX == 1) { if (list == NULL) { list = init(student); } else { list = add_new_elem_to_start(list, student); } printf("\nPress any key to continue..."); getchar(); getchar(); } else if (kX == 2) { if (list == NULL) { list = init(student); } else { list = add_new_elem_to_end(list, student); } printf("\nPress any key to continue..."); getchar(); getchar(); } else if (kX == 3) { if (list == NULL) { list = init(student); printf("The list was empty, so, list have been created.\n"); } else { int position; printf("Put the position: "); scanf("%d", &amp;position); list = add_new_elem_after_pos(list, student, position); } printf("\nPress any key to continue..."); getchar(); getchar(); } else { if (find_elem(list, student)) printf("Student exist"); else printf("Student doesn't exist"); printf("\nPress any key to continue..."); getchar(); getchar(); } } else if (kX == 4) { if (list == NULL) { printf("List is empty.\n"); } else { list = delete_elem(list); } printf("\nPress any key to continue..."); getchar(); getchar(); } else if (kX == 5) { char* path = (char*)malloc(255 * sizeof(char)); printf("Put the path to file with students: "); scanf("%s", path); if (write_students(list, path) == 0) { printf("Can't write"); printf("\nPress any key to continue..."); getchar(); getchar(); } free(path); } else if (kX == 7) { if (list == NULL) { printf("List is empty.\n"); } else { list = sort_list(list); } printf("\nThe list was successfully sorted"); printf("\nPress any key to continue..."); getchar(); getchar(); } else if (kX == 8) { system("cls"); show_list(list); printf("\nPress any key to continue..."); getchar(); getchar(); } else exit = TRUE; }break; case 27: { exit = TRUE; }break; } system("cls"); ShowListMenu(kX); } while (exit == FALSE); while (list != NULL) { list = delete_elem(list); } } struct Student create_student() { struct Student new_student; do { printf("Write the name of student\n"); scanf("%s", new_student.first_name); } while (strlen(new_student.first_name) == 0); do { printf("Write the last name of student\n"); scanf("%s", new_student.last_name); } while (strlen(new_student.last_name) == 0); do { printf("Write the patronyminc of student\n"); scanf("%s", new_student.patronyminc); } while (strlen(new_student.patronyminc) == 0); do { printf("Write the city of student\n"); scanf("%s", new_student.city); } while (strlen(new_student.city) == 0); do { printf("Write the district of student\n"); scanf("%s", new_student.disctrict); } while (strlen(new_student.disctrict) == 0); do { printf("Write the country of student\n"); scanf("%s", new_student.country); } while (strlen(new_student.country) == 0); do { printf("Write the phone number of student\n"); scanf("%s", new_student.phoneNumber); } while (strlen(new_student.phoneNumber) != 13); char* choose = (char*)malloc(255 * sizeof(char)); while (TRUE) { printf("Does student live in hostel? Y - yes, N - no\n"); scanf("%s", choose); if (strcmp(choose, "y") == 0 || strcmp(choose, "Y") == 0) { new_student.is_live_in_hostel = TRUE; break; } if (strcmp(choose, "n") == 0 || strcmp(choose, "n") == 0) { new_student.is_live_in_hostel = FALSE; break; } } while (TRUE) { printf("Does student get scholarship? Y - yes, N - no\n"); scanf("%s", choose); if (strcmp(choose, "y") == 0 || strcmp(choose, "Y") == 0) { new_student.is_live_in_hostel = TRUE; break; } if (strcmp(choose, "n") == 0 || strcmp(choose, "n") == 0) { new_student.is_live_in_hostel = FALSE; break; } } free(choose); for (int i = 0; i &lt; 3; i++) { char temp[10]; printf("Write the %d mark of ZNO\n", i + 1); scanf("%s", temp); new_student.mark_zno[i] = atof(temp); if (new_student.mark_zno[i] == 0) { i--; } } return new_student; }</span></span></code> </pre> </div></div><br><p>  Et il y a aussi <code>Student.h</code> et <code>Student.c</code> dans lesquels les structures et les fonctions sont déclarées. </p><br><p>  Il y a une tâche: démontrer l'absence de fuites de mémoire.  La première chose qui me vient à l'esprit est le CRT.  Ici, tout est assez simple. </p><br><p>  En haut du fichier où se trouve main, ajoutez ce morceau de code: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __CRTDBG_MAP_ALLOC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;crtdbg.h&gt; #define DEBUG_NEW new(_NORMAL_BLOCK, __FILE__, __LINE__) #define new DEBUG_NEW</span></span></span></span></code> </pre> <br><p>  Et avant de <code>return 0</code> vous devez enregistrer ceci: <code>_CrtDumpMemoryLeaks();</code>  . </p><br><p>  Par conséquent, en mode Debug, le studio affichera ceci: </p><br><pre> <code class="plaintext hljs">Detected memory leaks! Dumping objects -&gt; {79} normal block at 0x00A04410, 376 bytes long. Data: &lt; &gt; CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD Object dump complete.</code> </pre> <br><p>  Super!  Vous savez maintenant que vous avez une fuite de mémoire.  Maintenant, vous devez éliminer cela, il vous suffit donc de savoir où nous oublions d'effacer la mémoire.  Et là se pose un problème: où, en fait, cette mémoire a-t-elle été allouée? </p><br><p><img src="https://habrastorage.org/webt/y4/wb/tz/y4wbtze5lwwwph735qztx0kokaw.gif"></p><br><p>  Après avoir répété toutes les étapes, j'ai découvert que la mémoire est perdue quelque part ici: </p><br><pre> <code class="plaintext hljs">if (kX == 0) { int sizeStudents = 0; struct Student* students = (struct Student*)malloc(1 * sizeof(struct Student)); char* path = (char*)malloc(255 * sizeof(char)); printf("Put the path to file with students: "); scanf("%s", path); int size = 0; students = read_students(path, &amp;size); if (students == NULL) { printf("Can't open this file.\n"); } else { for (int i = 0; i &lt; size; i++) { if (i == 0) { list = init(students[i]); } else { list = add_new_elem_to_start(list, students[i]); } } } free(students); printf("\nPress any key to continue..."); getchar(); getchar(); free(path); }</code> </pre> <br><p>  Mais comment est-ce?  Suis-je en train de tout libérer?  Ou pas? </p><br><p>  Et ici, j'ai vraiment raté Valgrind, avec sa trace d'appel ... </p><br><p>  En conséquence, après 15 minutes de marche, j'ai trouvé un analogue de Valgrind - <strong>Visual Leak Detector</strong> .  Il s'agit d'une bibliothèque tierce, un wrapper sur CRT qui a promis de montrer le traçage!  Voilà ce dont j'ai besoin. </p><br><p>  Pour l'installer, vous devez aller dans le <a href="" rel="nofollow">référentiel</a> et trouver <code>vld-2.5.1-setup.exe</code> dans les actifs </p><br><p>  Certes, la dernière mise à jour date de Visual Studio 2015, mais elle fonctionne avec Visual Studio 2019. L'installation est standard, suivez simplement les instructions. </p><br><p>  Pour activer VLD, vous devez enregistrer <code>#include &lt;vld.h&gt;</code> . </p><br><p>  L'avantage de cet utilitaire est que vous ne pouvez pas l'exécuter en mode débogage (F5), car tout est affiché dans la console.  Au tout début, cela sera affiché: </p><br><pre> <code class="plaintext hljs">Visual Leak Detector read settings from: C:\Program Files (x86)\Visual Leak Detector\vld.ini Visual Leak Detector Version 2.5.1 installed.</code> </pre> <br><p>  Et voici ce qui se produira en cas de fuite de mémoire: </p><br><pre> <code class="plaintext hljs">WARNING: Visual Leak Detector detected memory leaks! ---------- Block 1 at 0x01405FD0: 376 bytes ---------- Leak Hash: 0x555D2B67, Count: 1, Total 376 bytes Call Stack (TID 8908): ucrtbased.dll!malloc() test.exe!0x00F41946() test.exe!0x00F42E1D() test.exe!0x00F44723() test.exe!0x00F44577() test.exe!0x00F4440D() test.exe!0x00F447A8() KERNEL32.DLL!BaseThreadInitThunk() + 0x19 bytes ntdll.dll!RtlGetAppContainerNamedObjectPath() + 0xED bytes ntdll.dll!RtlGetAppContainerNamedObjectPath() + 0xBD bytes Data: CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ Visual Leak Detector detected 1 memory leak (412 bytes). Largest number used: 3115 bytes. Total allocations: 3563 bytes. Visual Leak Detector is now exiting.</code> </pre> <br><p>  Ici, je vois la trace!  Alors, où sont les lignes de code?  Où sont les noms des fonctions? </p><br><p><img src="https://habrastorage.org/webt/dz/ui/q8/dzuiq8addahp5zcgp-p3nuarvqq.png"></p><br><p>  D'accord, la promesse a été tenue, mais ce n'est pas le résultat que je voulais. </p><br><p>  Il reste une option que j'ai trouvée dans Google: un instantané de la mémoire.  Cela se fait simplement: en mode débogage, lorsque vous arrivez à retourner 0, vous devez aller dans l'onglet "Utilisation de la mémoire" de l'outil de diagnostic et cliquer sur "Prendre un instantané".  Peut-être que cette fonctionnalité sera désactivée pour vous, comme dans la première capture d'écran.  Ensuite, vous devez activer et redémarrer le débogage. </p><br><div class="spoiler">  <b class="spoiler_title">Première capture d'écran</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/8y/e9/0p/8ye90pv8sqcl7ta-whe19khp5_a.jpeg"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Deuxième capture d'écran</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ez/ry/z6/ezryz6ugleg0jll99hb2pj65rmg.jpeg"></p></div></div><br><p>  Après avoir pris la photo, vous verrez une taille sous le tas.  Je pense que c'est la quantité de mémoire allouée pendant le programme.  Cliquez sur cette taille.  Nous aurons une fenêtre qui contiendra les objets qui sont stockés dans ce tas.  Pour voir des informations détaillées, vous devez sélectionner un objet et cliquer sur le bouton "Instances de représentation d'objets Foo". </p><br><div class="spoiler">  <b class="spoiler_title">Troisième capture d'écran</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/10/uh/ms/10uhmsb4afebqpruq1vlsnsp-mo.jpeg"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Quatrième capture d'écran</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/1j/9o/mt/1j9omtinhnzrgtfbvmxalgs90f0.jpeg"></p></div></div><br><p>  Oui!  C'est une victoire!  Trace complète avec localisation de l'appel!  C'est ce qui était à l'origine nécessaire. </p><br><p>  <strong>Linux - développement</strong> <br>  Voyons maintenant ce qui se passe sous Linux. <br><img src="https://habrastorage.org/webt/xj/zs/m8/xjzsm8buie-rrb4m66fristpsda.jpeg"><br>  Sous Linux, l'utilitaire valgrind existe.  Pour installer valgrind, vous devez enregistrer <code>sudo apt install valgrind</code> dans la console (pour la famille Debian). </p><br><p>  J'ai écrit un petit programme qui remplit un tableau dynamique, mais en même temps, la mémoire n'est pas effacée: </p><br><div class="spoiler">  <b class="spoiler_title">main.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;stdio.h&gt; #define N 10 int main() { int * mas = (int *)malloc(N * sizeof(int)); for(int i = 0; i &lt; N; i++) { *(mas+i) = i; printf("%d\t", *(mas+i)); } printf("\n"); return 0; }</span></span></span></span></code> </pre></div></div><br><p>  Après avoir compilé le programme en utilisant CLang, nous obtenons un fichier .out, que nous lançons à valgrind. </p><br><p>  Utilisation de la <code>valgrind ./a.out</code> .  Comment fonctionne valgrind, je pense qu'il est logique de le décrire dans un article séparé, et maintenant, comment le programme s'exécute, valgrind affichera ceci: </p><br><pre> <code class="plaintext hljs">==2342== HEAP SUMMARY: ==2342== in use at exit: 40 bytes in 1 blocks ==2342== total heap usage: 2 allocs, 1 frees, 1,064 bytes allocated ==2342== ==2342== Searching for pointers to 1 not-freed blocks ==2342== Checked 68,984 bytes ==2342== ==2342== LEAK SUMMARY: ==2342== definitely lost: 40 bytes in 1 blocks ==2342== indirectly lost: 0 bytes in 0 blocks ==2342== possibly lost: 0 bytes in 0 blocks ==2342== still reachable: 0 bytes in 0 blocks ==2342== suppressed: 0 bytes in 0 blocks ==2342== Rerun with --leak-check=full to see details of leaked memory ==2342== ==2342== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) ==2342== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</code> </pre> <br><p>  Ainsi, jusqu'à présent, valgrind montre combien de mémoire a été perdue.  Pour voir où la mémoire a été allouée, vous devez écrire <code>--leak-check=full</code> , puis, valgrind, en plus de ce qui précède, affichera ceci: </p><br><pre> <code class="plaintext hljs">==2348== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1 ==2348== at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==2348== by 0x40053A: main (in /home/hunterlan/Habr/a.out)</code> </pre> <br><p>  Bien sûr, aucune chaîne n'est spécifiée ici, mais une fonction a déjà été spécifiée, ce qui est une bonne nouvelle. </p><br><p>  Il existe des alternatives à valgrind, comme strace ou Dr.Memory, mais je ne les ai pas utilisées, et elles sont principalement utilisées lorsque valgrind est impuissant. </p><br><p>  <strong>Conclusions</strong> </p><br><p>  Je suis heureux d'avoir été confronté au problème de trouver une fuite de mémoire dans Visual Studio, car j'ai appris beaucoup de nouveaux outils, quand et comment les utiliser, et j'ai commencé à comprendre comment ces outils fonctionnent. </p><br><p>  Merci de votre attention, bonne écriture de code pour vous! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480368/">https://habr.com/ru/post/fr480368/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480354/index.html">Premiers pas avec les méthodes de tableau JavaScript .map (), .filter () et .reduce ()</a></li>
<li><a href="../fr480356/index.html">Conseils Python utiles que vous n'avez pas rencontrés</a></li>
<li><a href="../fr480358/index.html">Le prix caché des bibliothèques CSS-in-JS dans les applications React</a></li>
<li><a href="../fr480362/index.html">Aventures d'hexafluorure d'uranium appauvri allemand en Russie. Partie 1. Histoire et technologies d'enrichissement</a></li>
<li><a href="../fr480364/index.html">Métaphysique de l'injection de dépendance</a></li>
<li><a href="../fr480370/index.html">Conférence DEFCON 19. Les patrons aiment Excel, les pirates aussi</a></li>
<li><a href="../fr480374/index.html">Le DogBot de React Robotics poursuit sa révolution dans l'industrie de la construction</a></li>
<li><a href="../fr480376/index.html">Des jeux vidéo aux messages secrets: discutez des œufs de Pâques dans les disques vinyle</a></li>
<li><a href="../fr480378/index.html">14 projets open source pour pomper les compétences en science des données (facile, normal, difficile)</a></li>
<li><a href="../fr480386/index.html">Sauvegardes automatiques des équipements réseau et de leur stockage dans le système de contrôle de version</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>