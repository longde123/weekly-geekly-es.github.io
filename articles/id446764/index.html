<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛶 🎒 😃 Standar WASI: Luncurkan WebAssembly Beyond the Web 👩🏻‍🤝‍👨🏼 🙆🏽 👨🏿‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada tanggal 27 Maret, kami di Mozilla mengumumkan standarisasi WASI, antarmuka sistem WebAssembly (antarmuka sistem WebAssembly). 

 Mengapa: pengemb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Standar WASI: Luncurkan WebAssembly Beyond the Web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446764/">  Pada tanggal 27 Maret, kami di Mozilla mengumumkan standarisasi WASI, antarmuka sistem WebAssembly (antarmuka sistem WebAssembly). <br><br>  <b>Mengapa:</b> pengembang mulai menggunakan WebAssembly di luar browser, karena WASM menyediakan cara yang cepat, terukur, dan aman untuk menjalankan kode yang sama di semua mesin.  Tetapi kami belum memiliki dasar yang kuat untuk perkembangan semacam itu.  Di luar browser, Anda perlu beberapa cara untuk berkomunikasi dengan sistem, yaitu antarmuka sistem.  Tetapi platform WebAssembly belum memilikinya. <br><br>  <b>Apa:</b> WebAssembly adalah assembler untuk mesin konseptual dan bukan fisik.  Ini bekerja pada berbagai arsitektur, oleh karena itu, antarmuka sistem diperlukan untuk OS konseptual untuk bekerja pada sistem operasi yang berbeda. <br><br>  Inilah yang WASI adalah: itu adalah antarmuka sistem untuk platform WebAssembly. <br><a name="habracut"></a><br>  Kami berusaha keras untuk menciptakan antarmuka sistem yang akan menjadi pendamping sejati untuk WebAssembly dengan portabilitas dan keamanan maksimum. <br><br>  <b>Siapa:</b> Sebagai bagian dari tim pengembangan WebAssembly, kami mengorganisir subkelompok yang akan distandarisasi pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WASI</a> .  Kami telah mengumpulkan mitra yang tertarik dan mencari yang baru. <br><br>  Berikut adalah beberapa alasan mengapa kami, mitra, dan pendukung kami menganggap ini penting: <br><br>  <b>Sean White, Direktur R&amp;D Mozilla:</b> <br><blockquote>  "WebAssembly telah mengubah cara orang mengirimkan jenis konten menarik yang baru. Ini membantu pengembang dan pembuat konten.  Sejauh ini, semuanya telah bekerja melalui peramban, tetapi dengan WASI, lebih banyak pengguna dan lebih banyak perangkat di berbagai tempat akan mendapat manfaat dari WebAssembly. " </blockquote><br>  <b>Tyler McMullen, CTO Dengan Cepat:</b> <br><blockquote>  “Kami melihat WebAssembly sebagai platform untuk mengeksekusi kode dengan cepat dan aman di cloud tepi.  Terlepas dari lingkungan yang berbeda (tepi dan browser), terima kasih kepada WASI, Anda tidak perlu mem-port-kan kode ke setiap platform. " </blockquote><br>  <b>Miles Borins, CTO dari Komite Pengarah Node:</b> <br><blockquote>  “WebAssembly dapat memecahkan salah satu masalah terbesar Node: bagaimana mencapai kecepatan hampir asli dan menggunakan kembali kode yang ditulis dalam bahasa lain seperti C dan C ++, sambil tetap menjaga portabilitas dan keamanan.  Standarisasi WASI adalah langkah pertama menuju ini. " </blockquote><br>  <b>Lori Voss, salah satu pendiri npm:</b> <br><blockquote>  “Npm sangat bersemangat tentang kemampuan WebAssembly potensial dari ekosistem npm karena membuatnya lebih mudah untuk mendapatkan kode asli untuk dijalankan di aplikasi JavaScript sisi-server.  Kami menantikan hasil dari proses ini. " </blockquote><br>  Jadi ini acara besar! <br><br>  Saat ini ada tiga implementasi WASI: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wasmtime</a> , Mozilla WebAssembly runtime <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lucet</a> , Cepat runtime WebAssembly <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peramban polyfill</a> </li></ul><br>  Demonstrasi WASI dalam aksi: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ggtEJC0Jv8A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Selanjutnya, kita akan berbicara tentang proposal Mozilla tentang bagaimana antarmuka sistem ini seharusnya bekerja. <br><br><h1>  Apa itu antarmuka sistem? </h1><br>  Banyak yang mengatakan bahasa seperti C menyediakan akses langsung ke sumber daya sistem.  Tetapi ini tidak sepenuhnya benar.  Pada kebanyakan sistem, bahasa-bahasa ini tidak memiliki akses langsung ke hal-hal seperti membuka atau membuat file.  Kenapa tidak <br><br>  Karena sumber daya sistem ini - file, memori, dan koneksi jaringan - terlalu penting untuk stabilitas dan keamanan. <br><br>  Jika satu program secara tidak sengaja merusak sumber daya yang lain, itu dapat menyebabkan crash.  Lebih buruk lagi, jika suatu program (atau pengguna) secara khusus menyerang sumber daya orang lain, ia dapat mencuri data sensitif. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a5/18d/7df/5a518d7df32af2b475047a1fc7c73958.png"><br><br>  Oleh karena itu, Anda memerlukan cara untuk mengontrol program dan pengguna mana yang dapat mengakses sumber daya.  Untuk waktu yang lama, pengembang sistem menemukan cara untuk menyediakan kontrol seperti itu: cincin perlindungan. <br><br>  Dengan cincin perlindungan, OS pada dasarnya mengatur penghalang pelindung di sekitar sumber daya sistem.  Inilah intinya.  Hanya itu yang dapat melakukan operasi seperti membuat file, membuka file, atau membuka koneksi jaringan. <br><br>  Program pengguna dijalankan di luar kernel dalam apa yang disebut ruang pengguna.  Jika program ingin membuka file, ia harus meminta kernel. <br><br> <a href=""><img src="https://habrastorage.org/webt/1x/6e/vi/1x6evigsjy_wlsk1dk5gei1r5ky.png"></a> <br><br>  Di sinilah konsep panggilan sistem muncul.  Ketika suatu program perlu meminta kernel untuk beberapa operasi, itu mengirimkan panggilan sistem.  Kernel memeriksa pengguna yang menghubungi dan melihat apakah ia memiliki izin untuk mengakses file ini. <br><br>  Pada sebagian besar perangkat, satu-satunya cara untuk mengakses sumber daya sistem adalah melalui panggilan sistem. <br><br> <a href=""><img src="https://habrastorage.org/webt/td/1s/e7/td1se7jsbqiagsgy6nid_csyick.png"></a> <br><br>  Sistem operasi menyediakan akses ke panggilan sistem.  Tetapi jika setiap OS memiliki panggilan sistemnya sendiri, tidakkah mereka perlu menulis versi kode yang berbeda?  Untungnya tidak.  Masalahnya diselesaikan dengan menggunakan abstraksi. <br><br>  Sebagian besar bahasa memiliki perpustakaan standar.  Saat coding, programmer tidak perlu tahu sistem apa yang dia tulis.  Itu hanya menggunakan antarmuka.  Kemudian, saat mengkompilasi, rantai alat Anda memilih implementasi antarmuka mana yang akan digunakan untuk sistem mana.  Implementasi ini menggunakan fungsi dari API sistem operasi, jadi khusus untuk itu. <br><br>  Di sinilah konsep antarmuka sistem muncul.  Misalnya, jika Anda mengkompilasi <code>printf</code> untuk mesin Windows, itu akan menggunakan Windows API.  Jika dikompilasi untuk Mac atau Linux, ia menggunakan POSIX. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/587/cdc/5c0/587cdc5c03ff566a88a9794dc314fa72.png"><br><br>  Namun, ini menimbulkan masalah untuk WebAssembly.  Di sini kita tidak tahu OS mana yang mengoptimalkan program bahkan saat kompilasi.  Dengan demikian, Anda tidak dapat menggunakan antarmuka sistem dari salah satu OS di dalam penerapan pustaka standar di WebAssembly. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/443/c36/730/443c3673072b36942ff28f1992ad2095.png"></a> <br><br>  Saya sudah mengatakan bahwa WebAssembly adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">assembler untuk mesin konseptual</a> , bukan mesin nyata.  Demikian pula, WebAssembly membutuhkan antarmuka sistem untuk OS konseptual daripada nyata. <br><br>  Tetapi sudah ada runtime yang dapat menjalankan WebAssembly di luar browser, bahkan tanpa antarmuka sistem ini.  Bagaimana mereka melakukannya?  Ayo lihat. <br><br><h1>  Bagaimana cara kerja WebAssembly di luar browser? </h1><br>  Alat pertama untuk menghasilkan kode WebAssembly adalah Emscripten.  Ini mengemulasi di web antarmuka sistem OS tertentu - POSIX.  Ini berarti bahwa programmer dapat menggunakan fungsi-fungsi dari library C standar (libc). <br><br>  Untuk ini, Emscripten menggunakan implementasi libc-nya sendiri.  Ini dibagi menjadi dua bagian: yang pertama dikompilasi menjadi modul WebAssembly, dan yang lainnya diimplementasikan dalam kode JS-lem.  Lem JS ini mengirimkan panggilan ke browser yang berbicara dengan OS. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/971/a59/857/971a59857adc62742dde95b413cc613a.png"><br><br>  Sebagian besar kode WebAssembly awal dikompilasi dengan Emscripten.  Karenanya, ketika orang mulai ingin menjalankan WebAssembly tanpa browser, mereka mulai menjalankan kode Emscripten. <br><br>  Jadi dalam runtimes ini Anda harus membuat implementasi Anda sendiri untuk semua fungsi yang ada di kode JS-lem. <br><br>  Tapi ada masalah.  Antarmuka yang disediakan oleh kode lem JS belum dirancang sebagai antarmuka standar atau bahkan publik.  Misalnya, untuk memanggil suka <code>read</code> di API normal, kode lem JS menggunakan <code>_system3(which, varargs)</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/52e/2de/7a8/52e2de7a84456993baeb32b1852c8da5.png"><br><br>  Parameter pertama <code>which</code> merupakan bilangan bulat yang selalu cocok dengan angka dalam nama (dalam kasus kami 3). <br><br>  Parameter kedua, <code>varargs</code> mencantumkan argumen.  Ini disebut <code>varargs</code> karena kita dapat memiliki jumlah argumen yang berbeda.  Tapi WebAssembly tidak memungkinkan untuk meneruskan sejumlah variabel argumen ke suatu fungsi.  Oleh karena itu, mereka ditransmisikan melalui memori linier, yang tidak aman dan lebih lambat daripada melalui register. <br><br>  Untuk Emscripten di browser, ini normal.  Tapi sekarang runtimes melihat ini sebagai standar de facto, menerapkan versi JS lem mereka sendiri.  Mereka mengemulasi detail internal dari lapisan emulasi POSIX. <br><br>  Ini berarti bahwa mereka menerapkan kembali kode (misalnya, meneruskan argumen sebagai nilai tumpukan), yang masuk akal mengingat kendala Emscripten, tetapi tidak ada kendala seperti itu di lingkungan runtime ini. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/e31/181/541/e31181541c0b666d54e43d5c10756088.png"></a> <br><br>  Jika kita telah membangun ekosistem WebAssembly selama beberapa dekade yang akan datang, itu membutuhkan fondasi yang kuat, bukan kruk.  Ini berarti bahwa standar kami yang sebenarnya tidak bisa menjadi emulasi emulasi. <br><br>  Tetapi prinsip apa yang berlaku dalam kasus ini? <br><br><h1>  Prinsip apa yang harus dipatuhi oleh antarmuka sistem WebAssembly? </h1><br>  Dua prinsip dasar WebAssembly: <br><br><ul><li>  portabilitas <br></li><li>  keamanan </li></ul><br>  Kami melampaui browser, tetapi mempertahankan prinsip-prinsip utama ini. <br><br>  Namun, pendekatan POSIX dan sistem kontrol akses Unix tidak memberi kami hasil yang diinginkan.  Mari kita lihat apa masalahnya. <br><br><h3>  Portabilitas </h3><br>  POSIX menyediakan portabilitas kode sumber.  Anda dapat mengkompilasi kode sumber yang sama dengan versi libc yang berbeda untuk komputer yang berbeda. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/255/eb7/51f/255eb751f342075453a6a30ea9f5bd98.png"></a> <br><br>  Tapi WebAssembly harus melampaui itu.  Kita perlu mengkompilasi sekali untuk berjalan pada sejumlah sistem yang berbeda.  Kami membutuhkan binari portabel. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/07e/06d/94c/07e06d94c4aca3ab4f5599c0c9ac3e10.png"></a> <br><br>  Ini menyederhanakan distribusi kode. <br><br>  Misalnya, jika modul Node asli ditulis dalam WebAssembly, maka pengguna tidak perlu menjalankan node-gyp saat memasang aplikasi dengan modul asli, dan pengembang tidak perlu mengonfigurasi dan mendistribusikan puluhan file biner. <br><br><h3>  Keamanan </h3><br>  Ketika kode meminta sistem operasi untuk membuat input atau output, OS harus mengevaluasi keamanan operasi ini, biasanya menggunakan sistem kontrol akses berdasarkan kepemilikan dan grup. <br><br>  Misalnya, sebuah program meminta untuk membuka file.  Pengguna memiliki serangkaian file tertentu yang dapat diaksesnya. <br><br>  Ketika seorang pengguna memulai suatu program, program itu dimulai atas nama pengguna itu.  Jika pengguna memiliki akses ke file - apakah ia adalah pemiliknya, atau merupakan bagian dari grup yang memiliki akses ke file - maka program memiliki akses yang sama. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d93/8b9/b2a/d938b9b2af13c33b21ab11057331c413.png"></a> <br><br>  Ini melindungi pengguna dari satu sama lain, yang masuk akal di masa lalu, ketika banyak orang bekerja pada satu komputer dan administrator mengendalikan perangkat lunak.  Kemudian ancaman utama adalah pengguna lain melihat file Anda. <br><br>  Segalanya telah berubah.  Saat ini, sistem biasanya merupakan pengguna tunggal, tetapi menggunakan kode pihak ketiga yang keandalannya tidak diketahui.  Sekarang ancaman utama berasal dari kode yang Anda jalankan sendiri. <br><br>  Misalnya, untuk perpustakaan di aplikasi Anda, pengelola baru telah dimulai (seperti yang sering terjadi pada open source).  Dia mungkin seorang aktivis yang tulus ... atau pengganggu.  Dan jika ia memiliki akses ke sistem Anda - misalnya, kemampuan untuk membuka file apa pun dan mengirimkannya melalui jaringan - maka kode ini dapat menyebabkan kerusakan besar. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/948/478/dc2/948478dc22fbebc0db26d763782be7a0.png"></a> <br>  <i><font color="gray"><b>Aplikasi yang mencurigakan</b> : Saya bekerja untuk pengguna Bob.</font></i>  <i><font color="gray">Bolehkah saya membuka dompet Bitcoin-nya?</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray"><b>Inti</b> : Untuk Bob?</font></i>  <i><font color="gray">Tentu saja!</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray"><b>Aplikasi yang mencurigakan</b> : Hebat!</font></i>  <i><font color="gray">Bagaimana dengan konektivitas jaringan?</font></i> <br><br>  Inilah sebabnya mengapa menggunakan perpustakaan pihak ketiga berbahaya.  WebAssembly memberikan keamanan dengan cara yang berbeda - melalui kotak pasir.  Di sini, kode tidak dapat berbicara langsung ke OS.  Tetapi bagaimana cara mengakses sumber daya sistem?  Host (browser atau runtime wasm) berfungsi sebagai kode yang dapat digunakan oleh kode. <br><br>  Ini berarti bahwa host secara fungsional membatasi fungsionalitas program, tidak memungkinkan Anda untuk bertindak atas nama pengguna, menyebabkan panggilan sistem apa pun dengan hak pengguna penuh. <br><br>  Memiliki kotak pasir itu sendiri tidak membuat sistem aman - tuan rumah masih dapat mentransfer fungsionalitas penuh ke kotak pasir, dalam hal ini tidak memberikan perlindungan apa pun.  Tapi kotak pasir setidaknya memberikan peluang teoretis bagi penghuni untuk membangun sistem yang lebih aman. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/68f/bdc/2d7/68fbdc2d7bf44565e5923226bc2a9004.png"></a> <br>  <i><font color="gray"><b>WA</b> : Tolong, berikut adalah beberapa mainan yang aman untuk berinteraksi dengan OS (safe_write, safe_read).</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray"><b>Aplikasi mencurigakan</b> : Oh sial ... di mana akses saya ke jaringan?</font></i> <br><br>  Dalam antarmuka sistem apa pun, Anda harus mematuhi kedua prinsip ini.  Portabilitas membuat pengembangan dan distribusi perangkat lunak lebih mudah, dan alat untuk melindungi tuan rumah dan pengguna mutlak diperlukan. <br><br><h1>  Seperti apa tampilan antarmuka sistem itu? </h1><br>  Dengan dua prinsip utama ini, apa yang seharusnya menjadi antarmuka sistem WebAssembly? <br><br>  Ini akan kita temukan dalam proses standardisasi.  Namun, kami memiliki saran untuk memulai: <br><br><ul><li>  Membuat seperangkat antarmuka standar modular <br></li><li>  Mari kita mulai dengan standarisasi modul inti wasi-core. </li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2e1/597/a99/2e1597a9959ff7666a3e77db9d63f12d.png"><br><br>  Apa yang akan ada di wasi-core?  Ini adalah dasar-dasar yang dibutuhkan oleh semua program.  Modul ini akan mencakup sebagian besar fungsi POSIX, termasuk file, koneksi jaringan, jam dan angka acak. <br><br>  Banyak fungsi dasar akan membutuhkan pendekatan yang sangat mirip.  Misalnya, pendekatan berorientasi file POSIX disediakan dengan panggilan sistem buka, tutup, baca, dan tulis, dan yang lainnya adalah add-on dari atas. <br><br>  Tetapi wasi-core tidak mencakup semua fungsi POSIX.  Misalnya, konsep suatu proses tidak jelas masuk ke dalam WebAssembly.  Selain itu, jelas bahwa setiap engine WebAssembly harus mendukung operasi proses seperti <code>fork</code> .  Tetapi kami juga ingin membuat standardisasi <code>fork</code> mungkin. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9c9/771/11a/9c977111a2def0f6ae4d5b93b1592d91.png"></a> <br><br>  Bahasa seperti Rust akan menggunakan wasi-core secara langsung di perpustakaan standar mereka.  Misalnya, <code>open</code> dari Rust diterapkan ketika dikompilasi ke dalam WebAssembly dengan memanggil <code>__wasi_path_open</code> . <br><br>  Untuk C dan C ++, kami menciptakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wasi-sysroot</a> , yang mengimplementasikan libc dalam hal fungsi wasi-core. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/878/2a0/fa2/8782a0fa23e8d4890cb1964c896db84c.png"></a> <br><br>  Kami berharap kompiler seperti Dentang dapat berinteraksi dengan WASI API, dan rantai alat lengkap seperti Rust compiler dan Emscripten akan menggunakan WASI sebagai bagian dari implementasi sistem mereka. <br><br>  Bagaimana kode khusus menjalankan fungsi WASI ini? <br><br>  Runtime di mana kode dieksekusi melewati fungsi wasi-core, menempatkan objek di kotak pasir. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/371/e44/995/371e44995aa3c88a2c1886ceb27fab19.png"></a> <br><br>  Ini memberikan portabilitas, karena setiap host dapat memiliki implementasi wasi-core sendiri khusus untuk platformnya: dari runtime WebAssembly seperti Mozilla Wasmtime dan Fastly Lucet, ke Node atau bahkan browser. <br><br>  Ini juga menyediakan isolasi yang dapat diandalkan, karena host memilih berdasarkan perangkat lunak yang berfungsi untuk mentransfer ke kotak pasir, yaitu sistem yang harus diizinkan oleh panggilan sistem.  Ini keamanan. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/e0a/3a6/28b/e0a3a628b861e321db36d64a647bdfd7.png"></a> <br><br>  WASI meningkatkan dan memperluas keamanan dengan memperkenalkan konsep keamanan berbasis otorisasi ke dalam sistem. <br><br>  Biasanya, jika kode perlu membuka file, itu panggilan <code>open</code> dengan nama jalur di baris.  Kemudian, OS memeriksa apakah kode tersebut memiliki hak untuk tindakan semacam itu (berdasarkan hak pengguna yang meluncurkan program). <br><br>  Dalam kasus WASI, saat memanggil suatu fungsi untuk mengakses file, Anda harus memberikan deskripsi file yang izinnya dilampirkan untuk file itu sendiri atau untuk direktori yang berisi file. <br><br>  Dengan demikian, Anda tidak dapat memiliki kode yang secara tidak sengaja meminta Anda untuk membuka <code>/etc/passwd</code> .  Sebaliknya, kode hanya dapat bekerja dengan direktori sendiri. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/92f/b27/cb0/92fb27cb09092b74fd1ba46d661867c4.png"></a> <br><br>  Ini memungkinkan berbagai panggilan sistem untuk diselesaikan dengan aman ke kode yang terisolasi karena kemampuan panggilan sistem ini terbatas. <br><br>  Demikian juga di setiap modul.  Secara default, modul tidak memiliki akses ke deskriptor file.  Tetapi jika kode dalam satu modul memiliki deskriptor file, itu dapat meneruskannya ke fungsi yang disebut dalam modul lain.  Atau buat versi yang lebih terbatas dari deskriptor file untuk diteruskan ke fungsi lain. <br><br>  Dengan demikian, runtime meneruskan deskriptor file yang dapat digunakan aplikasi dalam kode tingkat atas, dan kemudian deskriptor file didistribusikan ke seluruh sistem sebagaimana diperlukan. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d80/cb2/f63/d80cb2f63dd1cfa855fc096f36e96ba1.png"></a> <br><br>  Ini membawa WebAssembly lebih dekat ke prinsip privilege paling rendah, di mana modul hanya mendapatkan akses ke set minimum sumber daya yang diperlukan untuk melakukan tugasnya. <br><br>  Konsep ini didasarkan pada keamanan berbasis hak istimewa, seperti di CloudABI dan Capsicum.  Salah satu masalah dengan sistem ini adalah portabilitas kode yang sulit.  Tetapi kami percaya bahwa masalah ini dapat diselesaikan. <br><br>  Jika kode sudah menggunakan <code>openat</code> dengan jalur file relatif, kompilasi kode hanya akan berfungsi. <br><br>  Jika kode menggunakan migrasi <code>open</code> dan gaya- <code>open</code> terlalu drastis, WASI akan memberikan solusi tambahan.  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libpreopen,</a> Anda membuat daftar path file yang aplikasi memiliki akses hukum.  Kemudian gunakan <code>open</code> , tetapi hanya dengan jalur ini. <br><br><h1>  Apa selanjutnya </h1><br>  Kami percaya wasi-core adalah awal yang baik.  Ini mempertahankan portabilitas dan keamanan WebAssembly, memberikan dasar yang kuat untuk ekosistem. <br><br>  Tetapi setelah standarisasi penuh wasi-core, masalah lain perlu diselesaikan, termasuk: <br><br><ul><li>  input-output tidak sinkron <br></li><li>  pemantauan file <br></li><li>  kunci file </li></ul><br>  Ini baru permulaan, jadi jika Anda punya ide, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libatkan</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446764/">https://habr.com/ru/post/id446764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446752/index.html">Layanan Tracing, OpenTracing dan Jaeger</a></li>
<li><a href="../id446754/index.html">Masa depan cloud</a></li>
<li><a href="../id446756/index.html">Senjata untuk VR - [RAILGUN TUTORIAL]</a></li>
<li><a href="../id446760/index.html">Topik di 3D Expo 2019: Pencetakan Logam 3D, Anton Sotov, Universitas Samara</a></li>
<li><a href="../id446762/index.html">6. Periksa Titik Memulai R80.20. Mulai di SmartConsole</a></li>
<li><a href="../id446768/index.html">Pengetikan nominal dalam TypeScript atau cara melindungi antarmuka Anda dari pengidentifikasi asing</a></li>
<li><a href="../id446770/index.html">12 trik JavaScript tidak ditemukan di sebagian besar tutorial</a></li>
<li><a href="../id446772/index.html">Jangan membuka port ke dunia - mereka akan menghancurkan Anda (risiko)</a></li>
<li><a href="../id446774/index.html">Desain Karakter Poli Rendah</a></li>
<li><a href="../id446776/index.html">Bukti Kerja Efektif</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>