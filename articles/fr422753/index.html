<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ΩüèΩ üë©üèª‚Äç‚öïÔ∏è üëêüèº Comprendre les partitions dans PostgreSQL 9 üêí ü¶Ü üöØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PostgreSQL 10 est sorti d√©but octobre 2017, il y a presque un an. 

 L'une des nouvelles ¬´fonctionnalit√©s¬ª les plus int√©ressantes est le partitionneme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comprendre les partitions dans PostgreSQL 9</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422753/"> PostgreSQL 10 est sorti d√©but octobre 2017, il y a presque un an. <br><br>  L'une des nouvelles ¬´fonctionnalit√©s¬ª les plus int√©ressantes est le partitionnement d√©claratif inconditionnel.  Mais que se passe-t-il si vous n'√™tes pas press√© de passer √† 10k?  Amazon, par exemple, n'est pas press√© et n'a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">introduit la prise en charge de PostgreSQL</a> 10 que dans les derniers jours de f√©vrier 2018. <br><br>  Ensuite, le bon vieux partitionnement par h√©ritage vient √† la rescousse.  Je suis l'architecte logiciel du d√©partement financier d'une soci√©t√© de taxi, donc tous les exemples seront li√©s au voyage d'une mani√®re ou d'une autre (nous laisserons les probl√®mes d'argent pour une autre fois). <br><br>  Depuis que nous avons commenc√© √† r√©√©crire notre syst√®me financier en 2015, lorsque je viens de rejoindre la soci√©t√©, il n'a √©t√© question d'aucune partition d√©clarative.  Ainsi, √† ce jour, la technique d√©crite ci-dessous a √©t√© utilis√©e avec succ√®s. <br><br>  La raison originale de la r√©daction de cet article √©tait que la plupart des exemples de partitionnement dans PostgreSQL que j'ai rencontr√©s √©taient tr√®s basiques.  Voici un tableau, voici une colonne que nous regardons, et peut-√™tre m√™me savoir √† l'avance quelles valeurs y sont.  Il semblerait que tout soit simple.  Mais la vraie vie fait ses propres ajustements. <br><a name="habracut"></a><br>  Dans notre cas, nous partitionnons les tables en deux colonnes, dont l'une contient les dates de voyage.  C'est ce cas que nous allons consid√©rer. <br><br>  Commen√ßons par ce √† quoi ressemble notre table: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> rides ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> bigserial <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>, tenant_id <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, ride_id <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">36</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, created_at <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, metadata jsonb <span class="hljs-comment"><span class="hljs-comment">-- Probably more columns and indexes coming here );</span></span></code> </pre> <br>  Pour chaque locataire, le tableau contient des millions de lignes par mois.  Heureusement, les donn√©es entre les locataires ne se recoupent jamais, et les demandes les plus difficiles se font au bout d'un ou deux mois. <br><br>  Pour ceux qui n'ont pas explor√© le fonctionnement des partitions PostgreSQL (chanceux d'Oracle, bonjour!), Je vais d√©crire bri√®vement le processus. <br><br>  Pour cela, PostgreSQL s'appuie sur deux de ses ¬´fonctionnalit√©s¬ª: la capacit√© d'h√©riter des tables, l'h√©ritage des tables et les conditions v√©rifi√©es. <br><br>  Commen√ßons par l'h√©ritage.  En utilisant le mot-cl√© INHERITS, nous indiquons que la table que nous cr√©ons h√©rite de tous les champs de la table h√©rit√©e.  Cela cr√©e √©galement une relation entre les deux tables: en faisant une requ√™te du parent, nous obtenons √©galement toutes les donn√©es des enfants. <br><br>  Les conditions v√©rifi√©es compl√®tent l'image en s'assurant que les donn√©es ne se croisent pas.  Ainsi, l'optimiseur PostgreSQL peut couper une partie des tables enfants en s'appuyant sur les donn√©es de la requ√™te. <br><br>  Le premier √©cueil de cette approche semble assez √©vident: toute demande doit contenir tenant_id.  Et n√©anmoins, si vous ne vous en souvenez pas constamment, t√¥t ou tard vous √©crirez vous-m√™me du SQL personnalis√© dans lequel vous oubliez de sp√©cifier ce tenant_id.  En cons√©quence - l'analyse de toutes les partitions et de la base de donn√©es qui ne fonctionne pas. <br><br>  Mais revenons √† ce que nous voulons r√©aliser.  Au niveau de l'application, j'aimerais la transparence - nous √©crivons toujours dans la m√™me table, et d√©j√† la base de donn√©es choisit o√π exactement placer ces donn√©es. <br><br>  Pour ce faire, nous utilisons la proc√©dure stock√©e suivante: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> insert_row() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> partition_env <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>; partition_date TIMESTAMP; partition_name TEXT; sql TEXT; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-comment"><span class="hljs-comment">-- construct partition name partition_env := lower(NEW.tenant_id); partition_date := date_trunc('month', NEW.created_at AT TIME ZONE 'UTC'); partition_name := format('%s_%s_%s', TG_TABLE_NAME, partition_env, to_char(partition_date, 'YYYY_MM')); -- create partition, if necessary IF NOT EXISTS(SELECT relname FROM pg_class WHERE relname = partition_name) THEN PERFORM create_new_partition(TG_TABLE_NAME, NEW.tenant_id, partition_date, partition_name); END IF; select format('INSERT INTO %s values ($1.*)', partition_name) into sql; -- Propagate insert EXECUTE sql USING NEW; RETURN NEW; -- RETURN NULL; if no ORM END; $BODY$ LANGUAGE plpgsql;</span></span></code> </pre> <br>  La premi√®re chose √† laquelle vous devez faire attention est l'utilisation de TG_TABLE_NAME.  Puisqu'il s'agit d'un d√©clencheur, PostgreSQL remplit un certain nombre de variables auxquelles nous pouvons acc√©der.  La liste compl√®te se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trouve ici</a> . <br><br>  Dans notre cas, nous voulons obtenir le nom parent de la table sur laquelle le d√©clencheur a fonctionn√©.  Dans notre cas, ce seront des balades.  Nous utilisons une approche similaire dans plusieurs microservices, et cette partie peut √™tre transf√©r√©e pratiquement sans modifications. <br><br>  <code>PERFORM</code> est utile si nous voulons appeler une fonction qui ne renvoie rien.  Typiquement, dans les exemples, ils essaient de mettre toute la logique dans une seule fonction, mais nous essayons d'√™tre prudents. <br><br>  <code>USING NEW</code> indique que dans cette requ√™te, nous utilisons les valeurs de la cha√Æne que nous avons essay√© d'ajouter. <br><br>  <code>$1.*</code> √©tendra toutes les valeurs de nouvelle ligne.  En fait, cela peut √™tre traduit en <code>NEW.*</code> .  Ce qui se traduit par <code>NEW.ID, NEW.TENANT_ID, ‚Ä¶</code> <br><br>  La proc√©dure suivante, que nous appelons avec <code>PERFORM</code> , cr√©era une nouvelle partition, si elle n'existe pas d√©j√†.  Cela se produira une fois par p√©riode pour chaque locataire. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> create_new_partition(parent_table_name <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, env <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, partition_date <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span>, partition_name <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VOID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-comment"><span class="hljs-comment">-- Notifying RAISE NOTICE 'A new % partition will be created: %', parent_table_name, partition_name; select format('CREATE TABLE IF NOT EXISTS %s (CHECK ( tenant_id = ''%s'' AND created_at AT TIME ZONE ''UTC'' &gt; ''%s'' AND created_at AT TIME ZONE ''UTC'' &lt;= ''%s'')) INHERITS (%I)', partition_name, env, partition_date, partition_date + interval '1 month', parent_table_name) into sql; -- New table, inherited from a master one EXECUTE sql; PERFORM index_partition(partition_name); END; $BODY$ LANGUAGE plpgsql;</span></span></code> </pre> <br>  Comme d√©crit pr√©c√©demment, nous utilisons <code>INHERITS</code> pour cr√©er une table similaire √† parent et <code>CHECK</code> pour d√©terminer quelles donn√©es doivent y aller. <br><br>  <code>RAISE NOTICE</code> imprime simplement une cha√Æne √† la console.  Si nous <code>INSERT</code> maintenant <code>INSERT</code> partir de psql, nous pouvons voir si la partition a √©t√© cr√©√©e. <br><br>  Nous avons un nouveau probl√®me.  <code>INHERITS</code> n'h√©rite pas des index.  Pour ce faire, nous avons deux solutions: <br><br>  Cr√©ez des index en utilisant l'h√©ritage: <br>  Utilisez <code>CREATE TABLE LIKE</code> puis <code>ALTER TABLE INHERITS</code> <br><br>  Ou cr√©ez des index de mani√®re proc√©durale: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> index_partition(partition_name <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VOID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-comment"><span class="hljs-comment">-- Ensure we have all the necessary indices in this partition; EXECUTE 'CREATE INDEX IF NOT EXISTS ' || partition_name || '_tenant_timezone_idx ON ' || partition_name || ' (tenant_id, timezone(''UTC''::text, created_at))'; -- More indexes here... END; $BODY$ LANGUAGE plpgsql;</span></span></code> </pre> <br>  Il est tr√®s important de ne pas oublier l'indexation des tables enfants, car m√™me apr√®s le partitionnement, chacune d'entre elles aura des millions de lignes.  Les index sur le parent ne sont pas n√©cessaires dans notre cas, car le parent restera toujours vide. <br><br>  Enfin, nous cr√©ons un d√©clencheur qui sera appel√© lors de la cr√©ation d'une nouvelle ligne: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> before_insert_row_trigger <span class="hljs-keyword"><span class="hljs-keyword">BEFORE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> rides <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EACH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROW</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> insert_row();</code> </pre> <br>  Il y a une autre subtilit√© √† laquelle on pr√™te rarement attention.  Le partitionnement est pr√©f√©rable dans les colonnes o√π les donn√©es ne changent jamais.  Dans notre cas, cela fonctionne: le trajet ne change jamais le tenant_id et created_at.  Si ce n'est pas le cas, PostreSQL ne nous renverra pas une partie des donn√©es.  Nous lui avons alors promis de V√âRIFIER que toutes les donn√©es √©taient valides. <br><br>  Il existe plusieurs solutions (sauf pour l'√©vidence - ne pas muter les donn√©es pour lesquelles nous partitionnons): <br><br>  Au lieu de <code>UPDATE</code> nous faisons toujours <code>DELETE+INSERT</code> au niveau de l'application <br>  Nous ajoutons un d√©clencheur de plus sur <code>UPDATE</code> qui transf√©rera les donn√©es vers la partition correcte <br><br>  Une autre mise en garde m√©rite d'√™tre examin√©e: comment indexer correctement les colonnes contenant des dates.  Si nous utilisons AT TIME ZONE dans les requ√™tes, il ne faut pas oublier qu'il s'agit en fait d'un appel de fonction.  Et cela signifie que notre index doit √™tre bas√© sur les fonctions.  J'ai oubli√©.  En cons√©quence, la base est √† nouveau morte de la charge. <br><br>  Le dernier aspect √† consid√©rer est la fa√ßon dont les partitions interagissent avec divers cadres ORM, que ce soit ActiveRecord dans Ruby ou GORM dans Go. <br><br>  Les partitions dans PostgreSQL reposent sur le fait que la table parent sera toujours vide.  Si vous n'utilisez pas ORM, vous pouvez revenir en toute s√©curit√© √† la premi√®re proc√©dure stock√©e et modifier RETOUR NOUVEAU;  sur RETOUR NULL;.  Ensuite, la ligne de la table parent ne sera tout simplement pas ajout√©e, ce qui est exactement ce que nous voulons. <br><br>  Mais le fait est que la plupart des ORM utilisent la clause RETURNING avec INSERT.  Si nous renvoyons NULL de notre d√©clencheur, l'ORM paniquera, croyant que la ligne n'a pas √©t√© ajout√©e.  Il est ajout√©, mais pas l√† o√π l'ORM regarde. <br><br>  Il existe plusieurs fa√ßons de contourner cela: <br><br><ul><li>  N'utilisez pas ORM pour INSERT </li><li>  Patch ORM (ce qui est parfois conseill√© dans le cas d'ActiveRecord) </li><li>  Ajoutez un autre d√©clencheur, qui supprimera la ligne du parent. </li></ul><br>  La derni√®re option n'est pas souhaitable, car pour chaque op√©ration, nous en effectuerons trois.  N√©anmoins, il est parfois in√©vitable, car nous le consid√©rerons s√©par√©ment: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> delete_parent_row() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> rides <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = NEW.ID; RETURN null; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; $BODY$ LANGUAGE plpgsql;</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> after_insert_row_trigger <span class="hljs-keyword"><span class="hljs-keyword">AFTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> rides <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EACH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROW</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> delete_parent_row();</code> </pre> <br>  La derni√®re chose que nous devons faire est de tester notre solution.  Pour ce faire, nous g√©n√©rons un certain nombre de lignes: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $script$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> year_start_epoch <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> := <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span>(epoch <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'20170101'</span></span>::timestamptz <span class="hljs-keyword"><span class="hljs-keyword">at</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-string"><span class="hljs-string">'UTC'</span></span>); delta bigint := extract(epoch from '20171231 23:59:59'::timestamptz at time zone 'UTC') - year_start_epoch; tenant varchar; tenants varchar[] := array['tenant_a', 'tenant_b', 'tenant_c', 'tenant_d']; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> FOREACH tenant <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ARRAY</span></span> tenants <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.100000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> rides (tenant_id, created_at, ride_id) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (tenant, to_timestamp(random() * delta + year_start_epoch) <span class="hljs-keyword"><span class="hljs-keyword">at</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-string"><span class="hljs-string">'UTC'</span></span>, i); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> $script$;</code> </pre> <br>  Et voyons comment se comporte la base de donn√©es: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rides <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tenant_id = <span class="hljs-string"><span class="hljs-string">'tenant_a'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> created_at <span class="hljs-keyword"><span class="hljs-keyword">AT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span> ZONE <span class="hljs-string"><span class="hljs-string">'UTC'</span></span> &gt; <span class="hljs-string"><span class="hljs-string">'20171102'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> created_at <span class="hljs-keyword"><span class="hljs-keyword">AT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span> ZONE <span class="hljs-string"><span class="hljs-string">'UTC'</span></span> &lt;= <span class="hljs-string"><span class="hljs-string">'20171103'</span></span>;</code> </pre> <br>  Si tout allait bien, nous devrions voir le r√©sultat suivant: <br><br><pre> <code class="sql hljs"> Append (cost=0.00..4803.76 rows=4 width=196) -&gt; Seq Scan on rides (cost=0.00..4795.46 rows=3 width=196) Filter: (((created_at)::timestamp without time zone &gt; '2017-11-02 00:00:00'::timestamp without time zone) AND ((created_at)::timestamp without time zone &lt;= '2017-11-03 00:00:00'::timestamp without time zone) AND ((tenant_id)::text = 'tenant_a'::text)) -&gt; Index Scan using rides_tenant_a_2017_11_tenant_timezone_idx on rides_tenant_a_2017_11 (cost=0.28..8.30 rows=1 width=196) Index Cond: (((tenant_id)::text = 'tenant_a'::text) AND ((created_at)::timestamp without time zone &gt; '2017-11-02 00:00:00'::timestamp without time zone) AND ((created_at)::timestamp without time zone &lt;= '2017-11-03 00:00:00'::timestamp without time zone)) (5 rows)</code> </pre> <br>  Malgr√© le fait que chaque locataire poss√®de des centaines de milliers de lignes, nous ne s√©lectionnons que dans la tranche de donn√©es souhait√©e.  Succ√®s! <br><br>  J'esp√®re que cet article √©tait int√©ressant pour ceux qui ne connaissaient pas encore ce qu'est le partitionnement et comment il est impl√©ment√© dans PostgreSQL.  Mais ceux pour qui ce sujet n'est plus nouveau ont n√©anmoins appris quelques astuces int√©ressantes. <br><br>  UPD: <br>  Comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">bigtrot l'a</a> correctement observ√©, toute cette magie de la rue ne fonctionnera pas si le param√®tre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CONSTRAINT_EXCLUSION</a> est d√©sactiv√©. <br><br>  Vous pouvez le v√©rifier en utilisant la commande <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">show</span></span> CONSTRAINT_EXCLUSION</code> </pre> <br><br>  Le param√®tre a trois valeurs: on, off et partition <br><br>  La configuration de partition est plus optimale si vous aimez soudainement utiliser CHECK CONSTRAINTS non seulement pour les partitions, mais aussi pour la normalisation des donn√©es. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr422753/">https://habr.com/ru/post/fr422753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr422739/index.html">Les centrales √©oliennes et solaires du Sahara contribueront √† am√©liorer le climat dans le d√©sert</a></li>
<li><a href="../fr422743/index.html">Comment le cerveau ressent le temps</a></li>
<li><a href="../fr422745/index.html">√âtoile de la connaissance captivante</a></li>
<li><a href="../fr422747/index.html">Position de prise en charge officielle du cryptage fort de l'IEEE</a></li>
<li><a href="../fr422751/index.html">10 outils de diagnostic SSL / TLS gratuits pour les webmasters</a></li>
<li><a href="../fr422755/index.html">Le portefeuille prot√©gera-t-il contre les affaissements cryptographiques?</a></li>
<li><a href="../fr422757/index.html">Pas de politique. Comment transformer durablement les manifestations de rue √† l'aide d'une application mobile?</a></li>
<li><a href="../fr422759/index.html">Carte interactive pour une application Web en quelques heures</a></li>
<li><a href="../fr422761/index.html">Quatre fa√ßons de l'√©cole d'analyse de donn√©es Yandex</a></li>
<li><a href="../fr422763/index.html">√âv√©nements num√©riques √† Moscou du 10 au 16 septembre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>