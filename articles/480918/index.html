<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📇 👱🏿 🚁 Apache Hadoop Code Quality: Production VS Test 🈺 🥛 🤜🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para obtener un código de producción de alta calidad, no basta con garantizar la máxima cobertura con las pruebas. Sin dudas, los excelentes resultado...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Hadoop Code Quality: Production VS Test</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/480918/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c48/f76/cf1/c48f76cf15c8138ce1d944918b1dcc07.png" alt="Figura 1"></div><br>  Para obtener un código de producción de alta calidad, no basta con garantizar la máxima cobertura con las pruebas.  Sin dudas, los excelentes resultados requieren que el código principal del proyecto y las pruebas funcionen juntos de manera eficiente.  Por lo tanto, las pruebas deben prestarse tanta atención como el código principal.  Una prueba decente es un factor clave de éxito, ya que detectará una regresión en la producción.  Echemos un vistazo a las advertencias del analizador estático PVS-Studio para ver la importancia del hecho de que los errores en las pruebas no son peores que los de producción.  El enfoque de hoy: Apache Hadoop. <br><a name="habracut"></a><br><h2>  Sobre el proyecto </h2><br>  Los que antes estaban interesados ​​en Big Data probablemente hayan escuchado o incluso trabajado con el proyecto <a href="https://hadoop.apache.org/">Apache Hadoop</a> .  En pocas palabras, Hadoop es un marco que se puede utilizar como base para construir sistemas de Big Data y trabajar con ellos. <br><br>  Hadoop consta de cuatro módulos principales, cada uno de ellos realiza una tarea específica requerida para un sistema de análisis de big data: <br><br><ul><li>  Hadoop común </li><li>  Mapreduce </li><li>  Sistema de archivos distribuidos de Hadoop </li><li>  Hilo </li></ul><br>  De todos modos, hay muchos materiales al respecto en Internet. <br><br><h2>  Sobre el cheque </h2><br>  Como se muestra en la documentación, PVS-Studio se puede integrar en el proyecto de varias maneras: <br><br><ul><li>  Usando el complemento maven; </li><li>  Usando el complemento gradle; </li><li>  Usando la gradle IntellJ IDEA; </li><li>  Usando directamente el analizador. </li></ul><br>  Hadoop se basa en el sistema de construcción maven, por lo tanto, no hubo obstáculos con el cheque. <br><br>  Después de integrar el script de la documentación y editar uno de los archivos pom.xml (había módulos en dependencias que no estaban disponibles), ¡comenzó el análisis! <br><br>  Después de completar el análisis, elegí las advertencias más interesantes y noté que tenía la misma cantidad de advertencias en el código de producción y en las pruebas.  Normalmente, no considero las advertencias del analizador, dadas para las pruebas.  Pero cuando los dividí, no pude dejar desatendidas las advertencias de 'pruebas'.  "¿Por qué no echarles un vistazo?", Pensé, porque los errores en las pruebas también podrían tener consecuencias adversas.  Pueden conducir a pruebas incorrectas o parciales, o incluso a mezclilla (existen solo para marcar la casilla, que siempre son verdes). <br><br>  Después de seleccionar las advertencias más interesantes, las dividí entre los siguientes grupos: producción, prueba y los cuatro módulos principales de Hadoop.  Y ahora me complace ofrecerle su atención la revisión de las advertencias del analizador. <br><br><h2>  Código de producción </h2><br><h3>  Hadoop común </h3><br>  <a href="https://www.viva64.com/en/w/v6033/">V6033</a> Ya se ha agregado un elemento con la misma clave 'KDC_BIND_ADDRESS'.  MiniKdc.java (163), MiniKdc.java (162) <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MiniKdc</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Set&lt;String&gt; PROPERTIES = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;String&gt;(); .... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { PROPERTIES.add(ORG_NAME); PROPERTIES.add(ORG_DOMAIN); PROPERTIES.add(KDC_BIND_ADDRESS); PROPERTIES.add(KDC_BIND_ADDRESS); <span class="hljs-comment"><span class="hljs-comment">// &lt;= PROPERTIES.add(KDC_PORT); PROPERTIES.add(INSTANCE); .... } .... }</span></span></code> </pre> <br>  El valor agregado dos veces en <i>HashSet</i> es un defecto muy común al verificar proyectos.  La segunda adición será realmente ignorada.  Espero que esta duplicación sea solo una tragedia innecesaria.  ¿Qué pasa si se pretende agregar otro valor? <br><br><h3>  Mapreduce </h3><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Se <a href="https://www.viva64.com/en/w/v6072/">encontraron</a> dos fragmentos de código similares.  Quizás, este es un error tipográfico y se debe usar la variable 'localFiles' en lugar de 'localArchives'.  LocalDistributedCacheManager.java (183), LocalDistributedCacheManager.java (178), LocalDistributedCacheManager.java (176), LocalDistributedCacheManager.java (181) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobConf conf, JobID jobId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Update the configuration object with localized data. if (!localArchives.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils .arrayToString(localArchives.toArray(new String[localArchives // &lt;= .size()]))); } if (!localFiles.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils .arrayToString(localFiles.toArray(new String[localArchives // &lt;= .size()]))); } .... }</span></span></code> </pre> <br>  El diagnóstico V6072 a veces arroja algunos hallazgos interesantes.  El propósito de este diagnóstico es detectar los mismos fragmentos de código de tipo resultado de copiar y pegar y el reemplazo de una o dos variables.  En este caso, algunas variables incluso se han dejado "sin cambios". <br><br>  El código anterior lo demuestra.  En el primer bloque se <i>usa la</i> variable <i>localArchives</i> , en el segundo fragmento similar: <i>localFiles</i> .  Si estudia este código con la debida diligencia, en lugar de ejecutarlo rápidamente, como sucede a menudo durante la revisión del código, notará el fragmento, donde el autor olvidó reemplazar la variable <i>localArchives</i> . <br><br>  Este error puede conducir al siguiente escenario: <br><br><ul><li>  Supongamos que tenemos <i>localArchives</i> (size = 4) y <i>localFiles</i> (size = 2); </li><li>  Al crear la matriz <i>localFiles.toArray (new String [localArchives.size ()])</i> , los últimos 2 elementos serán <i>nulos</i> (["pathToFile1", "pathToFile2", null, null]); </li><li>  Luego <i>org.apache.hadoop.util.StringUtils.arrayToString</i> devolverá la representación de cadena de nuestra matriz, en la que los últimos nombres de archivos se presentarán como "nulo" ("pathToFile1, pathToFile2, null, null" <i>)</i> ; </li><li>  Todo esto se pasará más allá y solo Dios sabe qué tipo de controles hay para tales casos =). </li></ul><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007 La</a> expresión 'children.size ()&gt; 0' siempre es verdadera.  Queue.java (347) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHierarchySameAs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Queue newState)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (children == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || children.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(children.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } .... }</code> </pre> <br>  Debido al hecho de que la cantidad de elementos se verifica para 0 por separado, la verificación adicional <i>children.size ()&gt; 0</i> siempre será verdadera. <br><br><h3>  HDFS </h3><br>  <a href="https://www.viva64.com/en/w/v6001/">V6001</a> Hay <a href="https://www.viva64.com/en/w/v6001/">subexpresiones</a> idénticas 'this.bucketSize' a la izquierda y a la derecha del operador '%'.  RollingWindow.java (79) <br><br><pre> <code class="java hljs"> RollingWindow(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> windowLenMs, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numBuckets) { buckets = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bucket[numBuckets]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numBuckets; i++) { buckets[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bucket(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.windowLenMs = windowLenMs; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bucketSize = windowLenMs / numBuckets; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bucketSize % bucketSize != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= throw new IllegalArgumentException( "The bucket size in the rolling window is not integer: windowLenMs= " + windowLenMs + " numBuckets= " + numBuckets); } }</span></span></code> </pre> <br>  Aquí el defecto es que la variable se divide por sí misma.  Como resultado, la verificación de multiplicidad siempre será exitosa y en caso de obtener entradas incorrectas ( <i>windowLenMs</i> , <i>numBuckets</i> ), la excepción nunca se lanzará. <br><br><h3>  Hilo </h3><br>  <a href="https://www.viva64.com/en/w/v6067/">V6067</a> Dos o más ramificaciones de casos realizan las mismas acciones.  TimelineEntityV2Converter.java (386), TimelineEntityV2Converter.java (389) <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ApplicationReport </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToApplicationReport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TimelineEntity entity)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (metrics != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vcoreSeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> memorySeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> preemptedVcoreSeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> preemptedMemorySeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (TimelineMetric metric : metrics) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (metric.getId()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_CPU_METRICS: vcoreSeconds = getAverageValue(metric.getValues().values()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_MEM_METRICS: memorySeconds = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS: preemptedVcoreSeconds = ....; <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS: preemptedVcoreSeconds = ....; // &lt;= break; default: // Should not happen.. break; } } .... } .... }</span></span></code> </pre> <br>  Los mismos fragmentos de código en dos ramas de <i>casos</i> .  ¡Está por todas partes!  En el número predominante de casos, esto no es un error real, sino solo una razón para pensar en la refactorización del <i>interruptor</i> .  Pero no para el caso en cuestión.  Los fragmentos de código repetidos establecen el valor de la variable <i>preemptedVcoreSeconds</i> .  Si observa detenidamente los nombres de todas las variables y constantes, probablemente concluirá que, en caso de que <i>metric.getId () == APP_MEM_PREEMPT_METRICS,</i> el valor debe establecerse para la variable <i>preemptedMemorySeconds</i> , no para <i>preemptedVcoreSeconds</i> .  En este sentido, después del operador 'switch', <i>preemptedMemorySeconds</i> siempre permanecerá 0, mientras que el valor de <i>preemptedVcoreSeconds</i> podría ser incorrecto. <br><br>  <a href="https://www.viva64.com/en/w/v6046/">V6046</a> Formato incorrecto.  Se espera un número diferente de elementos de formato.  Argumentos no utilizados: 2. AbstractSchedulerPlanFollower.java (186) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synchronizePlan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Plan plan, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shouldReplan)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setQueueEntitlement(planQueueName, ....); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (YarnException e) { LOG.warn(<span class="hljs-string"><span class="hljs-string">"Exception while trying to size reservation for plan: {}"</span></span>, currResId, planQueueName, e); } .... }</code> </pre> <br>  La variable <i>planQueueName</i> no se usa al iniciar sesión.  En este caso, se copia demasiado o la cadena de formato no está terminada.  Pero todavía culpo a la vieja copia y pegar, que en algunos casos es genial para dispararte en el pie. <br><br><h2>  Código de prueba </h2><br><h3>  Hadoop común </h3><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Se <a href="https://www.viva64.com/en/w/v6072/">encontraron</a> dos fragmentos de código similares.  Quizás, este es un error tipográfico y se debe usar la variable 'allSecretsB' en lugar de 'allSecretsA'.  TestZKSignerSecretProvider.java (316), TestZKSignerSecretProvider.java (309), TestZKSignerSecretProvider.java (306), TestZKSignerSecretProvider.java (313) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMultiple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> order)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ .... currentSecretA = secretProviderA.getCurrentSecret(); allSecretsA = secretProviderA.getAllSecrets(); Assert.assertArrayEquals(secretA2, currentSecretA); Assert.assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, allSecretsA.length); <span class="hljs-comment"><span class="hljs-comment">// &lt;= Assert.assertArrayEquals(secretA2, allSecretsA[0]); Assert.assertArrayEquals(secretA1, allSecretsA[1]); currentSecretB = secretProviderB.getCurrentSecret(); allSecretsB = secretProviderB.getAllSecrets(); Assert.assertArrayEquals(secretA2, currentSecretB); Assert.assertEquals(2, allSecretsA.length); // &lt;= Assert.assertArrayEquals(secretA2, allSecretsB[0]); Assert.assertArrayEquals(secretA1, allSecretsB[1]); .... }</span></span></code> </pre> <br>  Y de nuevo el V6072.  Mire detenidamente las variables <i>allSecretsA</i> y <i>allSecretsB</i> . <br><br>  <a href="https://www.viva64.com/en/w/v6043/">V6043</a> Considere inspeccionar el operador 'para'.  Los valores iniciales y finales del iterador son los mismos.  TestTFile.java (235) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPrepWithUnknownLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Scanner scanner, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = start; i &lt; start; i++) { String key = String.format(localFormatter, i); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] read = readKey(scanner); assertTrue(<span class="hljs-string"><span class="hljs-string">"keys not equal"</span></span>, Arrays.equals(key.getBytes(), read)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { read = readValue(scanner); assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ie) { <span class="hljs-comment"><span class="hljs-comment">// should have thrown exception } String value = "value" + key; read = readLongValue(scanner, value.getBytes().length); assertTrue("values nto equal", Arrays.equals(read, value.getBytes())); scanner.advance(); } return (start + n); }</span></span></code> </pre> <br>  ¿Una prueba que siempre es verde?  =).  Una parte del bucle, que es parte de la prueba en sí, nunca se ejecutará.  Esto se debe al hecho de que los valores de contador inicial y final son iguales en la instrucción <i>for</i> .  Como resultado, la condición <i>i &lt;start</i> se convertirá inmediatamente en falsa, lo que conducirá a dicho comportamiento.  Revisé el archivo de prueba y llegué a la conclusión de que en realidad <i>i &lt;(inicio + n)</i> tenía que escribirse en la condición de bucle. <br><br><h3>  Mapreduce </h3><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007 La</a> expresión 'byteAm &lt;0' siempre es falsa.  DataWriter.java (322) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">GenerateOutput </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeSegment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> byteAm, OutputStream out)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> headerLen = getHeaderLength(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byteAm &lt; headerLen) { <span class="hljs-comment"><span class="hljs-comment">// not enough bytes to write even the header return new GenerateOutput(0, 0); } // adjust for header length byteAm -= headerLen; if (byteAm &lt; 0) { // &lt;= byteAm = 0; } .... }</span></span></code> </pre> <br>  La condición <i>byteAm &lt;0</i> siempre es falsa.  Para resolverlo, demos otro vistazo al código de arriba.  Si la ejecución de la prueba alcanza la operación <i>byteAm - = headerLen</i> , significa que <i>byteAm&gt; = headerLen.</i>  Desde aquí, después de la resta, el <i>valor</i> byteAm nunca será negativo.  Eso es lo que tuvimos que demostrar. <br><br><h3>  HDFS </h3><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Se <a href="https://www.viva64.com/en/w/v6072/">encontraron</a> dos fragmentos de código similares.  Quizás, este es un error tipográfico y se debe usar la variable 'normalFile' en lugar de 'normalDir'.  TestWebHDFS.java (625), TestWebHDFS.java (615), TestWebHDFS.java (614), TestWebHDFS.java (624) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWebHdfsErasureCodingFiles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path normalDir = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(<span class="hljs-string"><span class="hljs-string">"/dir"</span></span>); dfs.mkdirs(normalDir); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path normalFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(normalDir, <span class="hljs-string"><span class="hljs-string">"file.log"</span></span>); .... <span class="hljs-comment"><span class="hljs-comment">// logic block #1 FileStatus expectedNormalDirStatus = dfs.getFileStatus(normalDir); FileStatus actualNormalDirStatus = webHdfs.getFileStatus(normalDir); // &lt;= Assert.assertEquals(expectedNormalDirStatus.isErasureCoded(), actualNormalDirStatus.isErasureCoded()); ContractTestUtils.assertNotErasureCoded(dfs, normalDir); assertTrue(normalDir + " should have erasure coding unset in " + ....); // logic block #2 FileStatus expectedNormalFileStatus = dfs.getFileStatus(normalFile); FileStatus actualNormalFileStatus = webHdfs.getFileStatus(normalDir); // &lt;= Assert.assertEquals(expectedNormalFileStatus.isErasureCoded(), actualNormalFileStatus.isErasureCoded()); ContractTestUtils.assertNotErasureCoded(dfs, normalFile); assertTrue( normalFile + " should have erasure coding unset in " + ....); }</span></span></code> </pre> <br>  Lo creas o no, ¡es V6072 nuevamente!  Simplemente siga las variables <i>normalDir</i> y <i>normalFile.</i> <br><br>  <a href="https://www.viva64.com/en/w/v6027/">V6027</a> Las variables se inicializan a través de la llamada a la misma función.  Probablemente sea un error o un código no optimizado.  TestDFSAdmin.java (883), TestDFSAdmin.java (879) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyNodesAndCorruptBlocks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numDn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numLiveDn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numCorruptBlocks, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numCorruptECBlockGroups, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DFSClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long highestPriorityLowRedundancyReplicatedBlocks, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long highestPriorityLowRedundancyECBlocks)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init vars */</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String expectedCorruptedECBlockGroupsStr = String.format( <span class="hljs-string"><span class="hljs-string">"Block groups with corrupt internal blocks: %d"</span></span>, numCorruptECBlockGroups); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String highestPriorityLowRedundancyReplicatedBlocksStr = String.format( <span class="hljs-string"><span class="hljs-string">"\tLow redundancy blocks with highest priority "</span></span> + <span class="hljs-string"><span class="hljs-string">"to recover: %d"</span></span>, highestPriorityLowRedundancyReplicatedBlocks); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String highestPriorityLowRedundancyECBlocksStr = String.format( <span class="hljs-string"><span class="hljs-string">"\tLow redundancy blocks with highest priority "</span></span> + <span class="hljs-string"><span class="hljs-string">"to recover: %d"</span></span>, highestPriorityLowRedundancyReplicatedBlocks); .... }</code> </pre> <br>  En este fragmento, las variables más <i>altasPriorityLowRedundancyReplicatedBlocksStr</i> y más <i>altasPriorityLowRedundancyECBlocksStr</i> se inicializan con los mismos valores.  A menudo debería ser así, pero este no es el caso.  Los nombres de las variables son largos y similares, por lo que no es sorprendente que el fragmento copiado no haya cambiado de ninguna manera.  Para solucionarlo, al inicializar la variable más <i>altaPriorityLowRedundancyECBlocksStr</i> , el autor tiene que usar el parámetro de entrada más <i>altoPriorityLowRedundancyECBlocks</i> .  Además, lo más probable es que todavía necesiten corregir la línea de formato. <br><br>  <a href="https://www.viva64.com/en/w/v6019/">V6019</a> Código inalcanzable detectado.  Es posible que haya un error presente.  TestReplaceDatanodeFailureReplication.java (222) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyFileContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., SlowWriter[] slowwriters)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ LOG.info(<span class="hljs-string"><span class="hljs-string">"Verify the file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; slowwriters.length; i++) { LOG.info(slowwriters[i].filepath + ....); FSDataInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { in = fs.open(slowwriters[i].filepath); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>, x;; j++) { x = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x) != -<span class="hljs-number"><span class="hljs-number">1</span></span>) { Assert.assertEquals(j, x); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { IOUtils.closeStream(in); } } }</code> </pre> <br>  El analizador se queja de que el contador <i>i ++</i> en el bucle no se puede cambiar.  Lo que significa que en el ciclo <i>for (int i = 0; i &lt;slowwriters.length; i ++) {....}</i> no se ejecutará más de una iteración.  Veamos por qué.  Entonces, en la primera iteración, vinculamos el hilo con el archivo que corresponde a los <i>escritores lentos [0]</i> para leer más.  A continuación, leemos el contenido del archivo a través del bucle <i>para (int j = 0, x ;; j ++):</i> <br><br><ul><li>  si leemos algo relevante, comparamos el byte de lectura con el valor actual del contador <i>j,</i> aunque <i>afirmar Equal</i> (si la verificación no es exitosa, fallamos en la prueba); </li><li>  si el archivo se verifica con éxito y llegamos al final del archivo (leemos -1), el método se cierra. </li></ul><br>  Por lo tanto, pase lo que pase durante la comprobación de los <i>escritores lentos [0]</i> , no se comprobarán los elementos posteriores.  Lo más probable es que se deba usar el <i>descanso</i> en lugar del <i>retorno.</i> <br><br><h3>  Hilo </h3><br>  <a href="https://www.viva64.com/en/w/v6019/">V6019</a> Código inalcanzable detectado.  Es posible que haya un error presente.  TestNodeManager.java (176) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCreationOfNodeLabelsProviderService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { Assert.fail(<span class="hljs-string"><span class="hljs-string">"Exception caught"</span></span>); e.printStackTrace(); } }</code> </pre> <br>  En esta situación, el método <i>Assert.fail</i> interrumpirá la prueba y stacktrace no se imprimirá en caso de una excepción.  Si el mensaje sobre la excepción capturada es suficiente aquí, es mejor eliminar la impresión de stacktrace para evitar confusiones.  Si es necesario imprimir, solo necesita intercambiarlos. <br><br>  Se han encontrado muchos fragmentos similares: <br><br><ul><li>  V6019 Código inalcanzable detectado.  Es posible que haya un error presente.  TestResourceTrackerService.java (928) </li><li>  V6019 Código inalcanzable detectado.  Es posible que haya un error presente.  TestResourceTrackerService.java (737) </li><li>  V6019 Código inalcanzable detectado.  Es posible que haya un error presente.  TestResourceTrackerService.java (685) </li><li>  .... </li></ul><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Se <a href="https://www.viva64.com/en/w/v6072/">encontraron</a> dos fragmentos de código similares.  Quizás, este es un error tipográfico y se debe usar la variable 'publicCache' en lugar de 'usercache'.  TestResourceLocalizationService.java (315), TestResourceLocalizationService.java (309), TestResourceLocalizationService.java (307), TestResourceLocalizationService.java (313) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testDirectoryCleanupOnNewlyCreatedStateStore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, URISyntaxException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// verify directory creation for (Path p : localDirs) { p = new Path((new URI(p.toString())).getPath()); // logic block #1 Path usercache = new Path(p, ContainerLocalizer.USERCACHE); verify(spylfs).rename(eq(usercache), any(Path.class), any()); // &lt;= verify(spylfs).mkdir(eq(usercache), ....); // logic block #2 Path publicCache = new Path(p, ContainerLocalizer.FILECACHE); verify(spylfs).rename(eq(usercache), any(Path.class), any()); // &lt;= verify(spylfs).mkdir(eq(publicCache), ....); .... } .... }</span></span></code> </pre> <br>  Y finalmente, V6072 nuevamente =).  Variables para ver el fragmento sospechoso: <i>usercache</i> y <i>publicCache</i> . <br><br><h2>  Conclusión </h2><br>  Cientos de miles de líneas de código están escritas en desarrollo.  El código de producción generalmente se mantiene limpio de errores, defectos y fallas (los desarrolladores prueban su código, el código se revisa, etc.).  Las pruebas son definitivamente inferiores en este sentido.  Los defectos en las pruebas pueden esconderse fácilmente detrás de una "marca verde".  Como probablemente haya obtenido de la revisión de advertencias de hoy, una prueba verde no siempre es una verificación exitosa. <br><br>  Esta vez, al verificar la base de código de Apache Hadoop, el análisis estático resultó ser muy necesario tanto en el código de producción como en las pruebas que también juegan un papel importante en el desarrollo. <br><br>  Entonces, si le importa su código y la calidad de las pruebas, le sugiero que fije su vista en el análisis estático.  Deje que <a href="https://www.viva64.com/en/pvs-studio-download/">PVS-Studio</a> sea ​​el primer competidor en esta empresa. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480918/">https://habr.com/ru/post/480918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480904/index.html">PHP Microservice Framework: entorno de desarrollo para Swoft</a></li>
<li><a href="../480906/index.html">Escribir un simple juego de pitón</a></li>
<li><a href="../480910/index.html">Cómo hacer una clase de prueba básica para las pruebas de selenio e inicializar a través de JUnit RuleChain</a></li>
<li><a href="../480912/index.html">Dap en acción. Escribiendo TodoMVC. Parte 1</a></li>
<li><a href="../480914/index.html">Microservicios para principiantes</a></li>
<li><a href="../480920/index.html">Prueba de interruptores TP-Link con PoE de largo alcance. Y un poco sobre actualizaciones de modelos antiguos</a></li>
<li><a href="../480922/index.html">Evgeny Usvitsky: "Todos en el mundo saben dónde obtener geodatos libremente, solo en OSM"</a></li>
<li><a href="../480924/index.html">Cómo y por qué los creadores del remake de MediEvil rediseñaron al jefe de culto del juego</a></li>
<li><a href="../480926/index.html">Teoría de la probabilidad para la representación físicamente precisa</a></li>
<li><a href="../480928/index.html">Apache Hadoop Code Quality: prueba de producción VS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>