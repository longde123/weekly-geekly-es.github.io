<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title> 别  Apache Hadoop Code Quality: Production VS Test   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para obtener un c贸digo de producci贸n de alta calidad, no basta con garantizar la m谩xima cobertura con las pruebas. Sin dudas, los excelentes resultado...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Hadoop Code Quality: Production VS Test</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/480918/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c48/f76/cf1/c48f76cf15c8138ce1d944918b1dcc07.png" alt="Figura 1"></div><br>  Para obtener un c贸digo de producci贸n de alta calidad, no basta con garantizar la m谩xima cobertura con las pruebas.  Sin dudas, los excelentes resultados requieren que el c贸digo principal del proyecto y las pruebas funcionen juntos de manera eficiente.  Por lo tanto, las pruebas deben prestarse tanta atenci贸n como el c贸digo principal.  Una prueba decente es un factor clave de 茅xito, ya que detectar谩 una regresi贸n en la producci贸n.  Echemos un vistazo a las advertencias del analizador est谩tico PVS-Studio para ver la importancia del hecho de que los errores en las pruebas no son peores que los de producci贸n.  El enfoque de hoy: Apache Hadoop. <br><a name="habracut"></a><br><h2>  Sobre el proyecto </h2><br>  Los que antes estaban interesados en Big Data probablemente hayan escuchado o incluso trabajado con el proyecto <a href="https://hadoop.apache.org/">Apache Hadoop</a> .  En pocas palabras, Hadoop es un marco que se puede utilizar como base para construir sistemas de Big Data y trabajar con ellos. <br><br>  Hadoop consta de cuatro m贸dulos principales, cada uno de ellos realiza una tarea espec铆fica requerida para un sistema de an谩lisis de big data: <br><br><ul><li>  Hadoop com煤n </li><li>  Mapreduce </li><li>  Sistema de archivos distribuidos de Hadoop </li><li>  Hilo </li></ul><br>  De todos modos, hay muchos materiales al respecto en Internet. <br><br><h2>  Sobre el cheque </h2><br>  Como se muestra en la documentaci贸n, PVS-Studio se puede integrar en el proyecto de varias maneras: <br><br><ul><li>  Usando el complemento maven; </li><li>  Usando el complemento gradle; </li><li>  Usando la gradle IntellJ IDEA; </li><li>  Usando directamente el analizador. </li></ul><br>  Hadoop se basa en el sistema de construcci贸n maven, por lo tanto, no hubo obst谩culos con el cheque. <br><br>  Despu茅s de integrar el script de la documentaci贸n y editar uno de los archivos pom.xml (hab铆a m贸dulos en dependencias que no estaban disponibles), 隆comenz贸 el an谩lisis! <br><br>  Despu茅s de completar el an谩lisis, eleg铆 las advertencias m谩s interesantes y not茅 que ten铆a la misma cantidad de advertencias en el c贸digo de producci贸n y en las pruebas.  Normalmente, no considero las advertencias del analizador, dadas para las pruebas.  Pero cuando los divid铆, no pude dejar desatendidas las advertencias de 'pruebas'.  "驴Por qu茅 no echarles un vistazo?", Pens茅, porque los errores en las pruebas tambi茅n podr铆an tener consecuencias adversas.  Pueden conducir a pruebas incorrectas o parciales, o incluso a mezclilla (existen solo para marcar la casilla, que siempre son verdes). <br><br>  Despu茅s de seleccionar las advertencias m谩s interesantes, las divid铆 entre los siguientes grupos: producci贸n, prueba y los cuatro m贸dulos principales de Hadoop.  Y ahora me complace ofrecerle su atenci贸n la revisi贸n de las advertencias del analizador. <br><br><h2>  C贸digo de producci贸n </h2><br><h3>  Hadoop com煤n </h3><br>  <a href="https://www.viva64.com/en/w/v6033/">V6033</a> Ya se ha agregado un elemento con la misma clave 'KDC_BIND_ADDRESS'.  MiniKdc.java (163), MiniKdc.java (162) <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MiniKdc</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Set&lt;String&gt; PROPERTIES = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;String&gt;(); .... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { PROPERTIES.add(ORG_NAME); PROPERTIES.add(ORG_DOMAIN); PROPERTIES.add(KDC_BIND_ADDRESS); PROPERTIES.add(KDC_BIND_ADDRESS); <span class="hljs-comment"><span class="hljs-comment">// &lt;= PROPERTIES.add(KDC_PORT); PROPERTIES.add(INSTANCE); .... } .... }</span></span></code> </pre> <br>  El valor agregado dos veces en <i>HashSet</i> es un defecto muy com煤n al verificar proyectos.  La segunda adici贸n ser谩 realmente ignorada.  Espero que esta duplicaci贸n sea solo una tragedia innecesaria.  驴Qu茅 pasa si se pretende agregar otro valor? <br><br><h3>  Mapreduce </h3><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Se <a href="https://www.viva64.com/en/w/v6072/">encontraron</a> dos fragmentos de c贸digo similares.  Quiz谩s, este es un error tipogr谩fico y se debe usar la variable 'localFiles' en lugar de 'localArchives'.  LocalDistributedCacheManager.java (183), LocalDistributedCacheManager.java (178), LocalDistributedCacheManager.java (176), LocalDistributedCacheManager.java (181) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobConf conf, JobID jobId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Update the configuration object with localized data. if (!localArchives.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils .arrayToString(localArchives.toArray(new String[localArchives // &lt;= .size()]))); } if (!localFiles.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils .arrayToString(localFiles.toArray(new String[localArchives // &lt;= .size()]))); } .... }</span></span></code> </pre> <br>  El diagn贸stico V6072 a veces arroja algunos hallazgos interesantes.  El prop贸sito de este diagn贸stico es detectar los mismos fragmentos de c贸digo de tipo resultado de copiar y pegar y el reemplazo de una o dos variables.  En este caso, algunas variables incluso se han dejado "sin cambios". <br><br>  El c贸digo anterior lo demuestra.  En el primer bloque se <i>usa la</i> variable <i>localArchives</i> , en el segundo fragmento similar: <i>localFiles</i> .  Si estudia este c贸digo con la debida diligencia, en lugar de ejecutarlo r谩pidamente, como sucede a menudo durante la revisi贸n del c贸digo, notar谩 el fragmento, donde el autor olvid贸 reemplazar la variable <i>localArchives</i> . <br><br>  Este error puede conducir al siguiente escenario: <br><br><ul><li>  Supongamos que tenemos <i>localArchives</i> (size = 4) y <i>localFiles</i> (size = 2); </li><li>  Al crear la matriz <i>localFiles.toArray (new String [localArchives.size ()])</i> , los 煤ltimos 2 elementos ser谩n <i>nulos</i> (["pathToFile1", "pathToFile2", null, null]); </li><li>  Luego <i>org.apache.hadoop.util.StringUtils.arrayToString</i> devolver谩 la representaci贸n de cadena de nuestra matriz, en la que los 煤ltimos nombres de archivos se presentar谩n como "nulo" ("pathToFile1, pathToFile2, null, null" <i>)</i> ; </li><li>  Todo esto se pasar谩 m谩s all谩 y solo Dios sabe qu茅 tipo de controles hay para tales casos =). </li></ul><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007 La</a> expresi贸n 'children.size ()&gt; 0' siempre es verdadera.  Queue.java (347) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHierarchySameAs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Queue newState)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (children == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || children.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(children.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } .... }</code> </pre> <br>  Debido al hecho de que la cantidad de elementos se verifica para 0 por separado, la verificaci贸n adicional <i>children.size ()&gt; 0</i> siempre ser谩 verdadera. <br><br><h3>  HDFS </h3><br>  <a href="https://www.viva64.com/en/w/v6001/">V6001</a> Hay <a href="https://www.viva64.com/en/w/v6001/">subexpresiones</a> id茅nticas 'this.bucketSize' a la izquierda y a la derecha del operador '%'.  RollingWindow.java (79) <br><br><pre> <code class="java hljs"> RollingWindow(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> windowLenMs, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numBuckets) { buckets = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bucket[numBuckets]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numBuckets; i++) { buckets[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bucket(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.windowLenMs = windowLenMs; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bucketSize = windowLenMs / numBuckets; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bucketSize % bucketSize != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= throw new IllegalArgumentException( "The bucket size in the rolling window is not integer: windowLenMs= " + windowLenMs + " numBuckets= " + numBuckets); } }</span></span></code> </pre> <br>  Aqu铆 el defecto es que la variable se divide por s铆 misma.  Como resultado, la verificaci贸n de multiplicidad siempre ser谩 exitosa y en caso de obtener entradas incorrectas ( <i>windowLenMs</i> , <i>numBuckets</i> ), la excepci贸n nunca se lanzar谩. <br><br><h3>  Hilo </h3><br>  <a href="https://www.viva64.com/en/w/v6067/">V6067</a> Dos o m谩s ramificaciones de casos realizan las mismas acciones.  TimelineEntityV2Converter.java (386), TimelineEntityV2Converter.java (389) <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ApplicationReport </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToApplicationReport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TimelineEntity entity)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (metrics != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vcoreSeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> memorySeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> preemptedVcoreSeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> preemptedMemorySeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (TimelineMetric metric : metrics) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (metric.getId()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_CPU_METRICS: vcoreSeconds = getAverageValue(metric.getValues().values()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_MEM_METRICS: memorySeconds = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS: preemptedVcoreSeconds = ....; <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS: preemptedVcoreSeconds = ....; // &lt;= break; default: // Should not happen.. break; } } .... } .... }</span></span></code> </pre> <br>  Los mismos fragmentos de c贸digo en dos ramas de <i>casos</i> .  隆Est谩 por todas partes!  En el n煤mero predominante de casos, esto no es un error real, sino solo una raz贸n para pensar en la refactorizaci贸n del <i>interruptor</i> .  Pero no para el caso en cuesti贸n.  Los fragmentos de c贸digo repetidos establecen el valor de la variable <i>preemptedVcoreSeconds</i> .  Si observa detenidamente los nombres de todas las variables y constantes, probablemente concluir谩 que, en caso de que <i>metric.getId () == APP_MEM_PREEMPT_METRICS,</i> el valor debe establecerse para la variable <i>preemptedMemorySeconds</i> , no para <i>preemptedVcoreSeconds</i> .  En este sentido, despu茅s del operador 'switch', <i>preemptedMemorySeconds</i> siempre permanecer谩 0, mientras que el valor de <i>preemptedVcoreSeconds</i> podr铆a ser incorrecto. <br><br>  <a href="https://www.viva64.com/en/w/v6046/">V6046</a> Formato incorrecto.  Se espera un n煤mero diferente de elementos de formato.  Argumentos no utilizados: 2. AbstractSchedulerPlanFollower.java (186) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synchronizePlan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Plan plan, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shouldReplan)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setQueueEntitlement(planQueueName, ....); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (YarnException e) { LOG.warn(<span class="hljs-string"><span class="hljs-string">"Exception while trying to size reservation for plan: {}"</span></span>, currResId, planQueueName, e); } .... }</code> </pre> <br>  La variable <i>planQueueName</i> no se usa al iniciar sesi贸n.  En este caso, se copia demasiado o la cadena de formato no est谩 terminada.  Pero todav铆a culpo a la vieja copia y pegar, que en algunos casos es genial para dispararte en el pie. <br><br><h2>  C贸digo de prueba </h2><br><h3>  Hadoop com煤n </h3><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Se <a href="https://www.viva64.com/en/w/v6072/">encontraron</a> dos fragmentos de c贸digo similares.  Quiz谩s, este es un error tipogr谩fico y se debe usar la variable 'allSecretsB' en lugar de 'allSecretsA'.  TestZKSignerSecretProvider.java (316), TestZKSignerSecretProvider.java (309), TestZKSignerSecretProvider.java (306), TestZKSignerSecretProvider.java (313) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMultiple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> order)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ .... currentSecretA = secretProviderA.getCurrentSecret(); allSecretsA = secretProviderA.getAllSecrets(); Assert.assertArrayEquals(secretA2, currentSecretA); Assert.assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, allSecretsA.length); <span class="hljs-comment"><span class="hljs-comment">// &lt;= Assert.assertArrayEquals(secretA2, allSecretsA[0]); Assert.assertArrayEquals(secretA1, allSecretsA[1]); currentSecretB = secretProviderB.getCurrentSecret(); allSecretsB = secretProviderB.getAllSecrets(); Assert.assertArrayEquals(secretA2, currentSecretB); Assert.assertEquals(2, allSecretsA.length); // &lt;= Assert.assertArrayEquals(secretA2, allSecretsB[0]); Assert.assertArrayEquals(secretA1, allSecretsB[1]); .... }</span></span></code> </pre> <br>  Y de nuevo el V6072.  Mire detenidamente las variables <i>allSecretsA</i> y <i>allSecretsB</i> . <br><br>  <a href="https://www.viva64.com/en/w/v6043/">V6043</a> Considere inspeccionar el operador 'para'.  Los valores iniciales y finales del iterador son los mismos.  TestTFile.java (235) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPrepWithUnknownLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Scanner scanner, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = start; i &lt; start; i++) { String key = String.format(localFormatter, i); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] read = readKey(scanner); assertTrue(<span class="hljs-string"><span class="hljs-string">"keys not equal"</span></span>, Arrays.equals(key.getBytes(), read)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { read = readValue(scanner); assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ie) { <span class="hljs-comment"><span class="hljs-comment">// should have thrown exception } String value = "value" + key; read = readLongValue(scanner, value.getBytes().length); assertTrue("values nto equal", Arrays.equals(read, value.getBytes())); scanner.advance(); } return (start + n); }</span></span></code> </pre> <br>  驴Una prueba que siempre es verde?  =).  Una parte del bucle, que es parte de la prueba en s铆, nunca se ejecutar谩.  Esto se debe al hecho de que los valores de contador inicial y final son iguales en la instrucci贸n <i>for</i> .  Como resultado, la condici贸n <i>i &lt;start</i> se convertir谩 inmediatamente en falsa, lo que conducir谩 a dicho comportamiento.  Revis茅 el archivo de prueba y llegu茅 a la conclusi贸n de que en realidad <i>i &lt;(inicio + n)</i> ten铆a que escribirse en la condici贸n de bucle. <br><br><h3>  Mapreduce </h3><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007 La</a> expresi贸n 'byteAm &lt;0' siempre es falsa.  DataWriter.java (322) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">GenerateOutput </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeSegment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> byteAm, OutputStream out)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> headerLen = getHeaderLength(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byteAm &lt; headerLen) { <span class="hljs-comment"><span class="hljs-comment">// not enough bytes to write even the header return new GenerateOutput(0, 0); } // adjust for header length byteAm -= headerLen; if (byteAm &lt; 0) { // &lt;= byteAm = 0; } .... }</span></span></code> </pre> <br>  La condici贸n <i>byteAm &lt;0</i> siempre es falsa.  Para resolverlo, demos otro vistazo al c贸digo de arriba.  Si la ejecuci贸n de la prueba alcanza la operaci贸n <i>byteAm - = headerLen</i> , significa que <i>byteAm&gt; = headerLen.</i>  Desde aqu铆, despu茅s de la resta, el <i>valor</i> byteAm nunca ser谩 negativo.  Eso es lo que tuvimos que demostrar. <br><br><h3>  HDFS </h3><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Se <a href="https://www.viva64.com/en/w/v6072/">encontraron</a> dos fragmentos de c贸digo similares.  Quiz谩s, este es un error tipogr谩fico y se debe usar la variable 'normalFile' en lugar de 'normalDir'.  TestWebHDFS.java (625), TestWebHDFS.java (615), TestWebHDFS.java (614), TestWebHDFS.java (624) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWebHdfsErasureCodingFiles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path normalDir = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(<span class="hljs-string"><span class="hljs-string">"/dir"</span></span>); dfs.mkdirs(normalDir); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path normalFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(normalDir, <span class="hljs-string"><span class="hljs-string">"file.log"</span></span>); .... <span class="hljs-comment"><span class="hljs-comment">// logic block #1 FileStatus expectedNormalDirStatus = dfs.getFileStatus(normalDir); FileStatus actualNormalDirStatus = webHdfs.getFileStatus(normalDir); // &lt;= Assert.assertEquals(expectedNormalDirStatus.isErasureCoded(), actualNormalDirStatus.isErasureCoded()); ContractTestUtils.assertNotErasureCoded(dfs, normalDir); assertTrue(normalDir + " should have erasure coding unset in " + ....); // logic block #2 FileStatus expectedNormalFileStatus = dfs.getFileStatus(normalFile); FileStatus actualNormalFileStatus = webHdfs.getFileStatus(normalDir); // &lt;= Assert.assertEquals(expectedNormalFileStatus.isErasureCoded(), actualNormalFileStatus.isErasureCoded()); ContractTestUtils.assertNotErasureCoded(dfs, normalFile); assertTrue( normalFile + " should have erasure coding unset in " + ....); }</span></span></code> </pre> <br>  Lo creas o no, 隆es V6072 nuevamente!  Simplemente siga las variables <i>normalDir</i> y <i>normalFile.</i> <br><br>  <a href="https://www.viva64.com/en/w/v6027/">V6027</a> Las variables se inicializan a trav茅s de la llamada a la misma funci贸n.  Probablemente sea un error o un c贸digo no optimizado.  TestDFSAdmin.java (883), TestDFSAdmin.java (879) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyNodesAndCorruptBlocks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numDn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numLiveDn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numCorruptBlocks, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numCorruptECBlockGroups, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DFSClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long highestPriorityLowRedundancyReplicatedBlocks, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long highestPriorityLowRedundancyECBlocks)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init vars */</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String expectedCorruptedECBlockGroupsStr = String.format( <span class="hljs-string"><span class="hljs-string">"Block groups with corrupt internal blocks: %d"</span></span>, numCorruptECBlockGroups); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String highestPriorityLowRedundancyReplicatedBlocksStr = String.format( <span class="hljs-string"><span class="hljs-string">"\tLow redundancy blocks with highest priority "</span></span> + <span class="hljs-string"><span class="hljs-string">"to recover: %d"</span></span>, highestPriorityLowRedundancyReplicatedBlocks); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String highestPriorityLowRedundancyECBlocksStr = String.format( <span class="hljs-string"><span class="hljs-string">"\tLow redundancy blocks with highest priority "</span></span> + <span class="hljs-string"><span class="hljs-string">"to recover: %d"</span></span>, highestPriorityLowRedundancyReplicatedBlocks); .... }</code> </pre> <br>  En este fragmento, las variables m谩s <i>altasPriorityLowRedundancyReplicatedBlocksStr</i> y m谩s <i>altasPriorityLowRedundancyECBlocksStr</i> se inicializan con los mismos valores.  A menudo deber铆a ser as铆, pero este no es el caso.  Los nombres de las variables son largos y similares, por lo que no es sorprendente que el fragmento copiado no haya cambiado de ninguna manera.  Para solucionarlo, al inicializar la variable m谩s <i>altaPriorityLowRedundancyECBlocksStr</i> , el autor tiene que usar el par谩metro de entrada m谩s <i>altoPriorityLowRedundancyECBlocks</i> .  Adem谩s, lo m谩s probable es que todav铆a necesiten corregir la l铆nea de formato. <br><br>  <a href="https://www.viva64.com/en/w/v6019/">V6019</a> C贸digo inalcanzable detectado.  Es posible que haya un error presente.  TestReplaceDatanodeFailureReplication.java (222) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyFileContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., SlowWriter[] slowwriters)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ LOG.info(<span class="hljs-string"><span class="hljs-string">"Verify the file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; slowwriters.length; i++) { LOG.info(slowwriters[i].filepath + ....); FSDataInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { in = fs.open(slowwriters[i].filepath); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>, x;; j++) { x = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x) != -<span class="hljs-number"><span class="hljs-number">1</span></span>) { Assert.assertEquals(j, x); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { IOUtils.closeStream(in); } } }</code> </pre> <br>  El analizador se queja de que el contador <i>i ++</i> en el bucle no se puede cambiar.  Lo que significa que en el ciclo <i>for (int i = 0; i &lt;slowwriters.length; i ++) {....}</i> no se ejecutar谩 m谩s de una iteraci贸n.  Veamos por qu茅.  Entonces, en la primera iteraci贸n, vinculamos el hilo con el archivo que corresponde a los <i>escritores lentos [0]</i> para leer m谩s.  A continuaci贸n, leemos el contenido del archivo a trav茅s del bucle <i>para (int j = 0, x ;; j ++):</i> <br><br><ul><li>  si leemos algo relevante, comparamos el byte de lectura con el valor actual del contador <i>j,</i> aunque <i>afirmar Equal</i> (si la verificaci贸n no es exitosa, fallamos en la prueba); </li><li>  si el archivo se verifica con 茅xito y llegamos al final del archivo (leemos -1), el m茅todo se cierra. </li></ul><br>  Por lo tanto, pase lo que pase durante la comprobaci贸n de los <i>escritores lentos [0]</i> , no se comprobar谩n los elementos posteriores.  Lo m谩s probable es que se deba usar el <i>descanso</i> en lugar del <i>retorno.</i> <br><br><h3>  Hilo </h3><br>  <a href="https://www.viva64.com/en/w/v6019/">V6019</a> C贸digo inalcanzable detectado.  Es posible que haya un error presente.  TestNodeManager.java (176) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCreationOfNodeLabelsProviderService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { Assert.fail(<span class="hljs-string"><span class="hljs-string">"Exception caught"</span></span>); e.printStackTrace(); } }</code> </pre> <br>  En esta situaci贸n, el m茅todo <i>Assert.fail</i> interrumpir谩 la prueba y stacktrace no se imprimir谩 en caso de una excepci贸n.  Si el mensaje sobre la excepci贸n capturada es suficiente aqu铆, es mejor eliminar la impresi贸n de stacktrace para evitar confusiones.  Si es necesario imprimir, solo necesita intercambiarlos. <br><br>  Se han encontrado muchos fragmentos similares: <br><br><ul><li>  V6019 C贸digo inalcanzable detectado.  Es posible que haya un error presente.  TestResourceTrackerService.java (928) </li><li>  V6019 C贸digo inalcanzable detectado.  Es posible que haya un error presente.  TestResourceTrackerService.java (737) </li><li>  V6019 C贸digo inalcanzable detectado.  Es posible que haya un error presente.  TestResourceTrackerService.java (685) </li><li>  .... </li></ul><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Se <a href="https://www.viva64.com/en/w/v6072/">encontraron</a> dos fragmentos de c贸digo similares.  Quiz谩s, este es un error tipogr谩fico y se debe usar la variable 'publicCache' en lugar de 'usercache'.  TestResourceLocalizationService.java (315), TestResourceLocalizationService.java (309), TestResourceLocalizationService.java (307), TestResourceLocalizationService.java (313) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testDirectoryCleanupOnNewlyCreatedStateStore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, URISyntaxException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// verify directory creation for (Path p : localDirs) { p = new Path((new URI(p.toString())).getPath()); // logic block #1 Path usercache = new Path(p, ContainerLocalizer.USERCACHE); verify(spylfs).rename(eq(usercache), any(Path.class), any()); // &lt;= verify(spylfs).mkdir(eq(usercache), ....); // logic block #2 Path publicCache = new Path(p, ContainerLocalizer.FILECACHE); verify(spylfs).rename(eq(usercache), any(Path.class), any()); // &lt;= verify(spylfs).mkdir(eq(publicCache), ....); .... } .... }</span></span></code> </pre> <br>  Y finalmente, V6072 nuevamente =).  Variables para ver el fragmento sospechoso: <i>usercache</i> y <i>publicCache</i> . <br><br><h2>  Conclusi贸n </h2><br>  Cientos de miles de l铆neas de c贸digo est谩n escritas en desarrollo.  El c贸digo de producci贸n generalmente se mantiene limpio de errores, defectos y fallas (los desarrolladores prueban su c贸digo, el c贸digo se revisa, etc.).  Las pruebas son definitivamente inferiores en este sentido.  Los defectos en las pruebas pueden esconderse f谩cilmente detr谩s de una "marca verde".  Como probablemente haya obtenido de la revisi贸n de advertencias de hoy, una prueba verde no siempre es una verificaci贸n exitosa. <br><br>  Esta vez, al verificar la base de c贸digo de Apache Hadoop, el an谩lisis est谩tico result贸 ser muy necesario tanto en el c贸digo de producci贸n como en las pruebas que tambi茅n juegan un papel importante en el desarrollo. <br><br>  Entonces, si le importa su c贸digo y la calidad de las pruebas, le sugiero que fije su vista en el an谩lisis est谩tico.  Deje que <a href="https://www.viva64.com/en/pvs-studio-download/">PVS-Studio</a> sea el primer competidor en esta empresa. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480918/">https://habr.com/ru/post/480918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480904/index.html">PHP Microservice Framework: entorno de desarrollo para Swoft</a></li>
<li><a href="../480906/index.html">Escribir un simple juego de pit贸n</a></li>
<li><a href="../480910/index.html">C贸mo hacer una clase de prueba b谩sica para las pruebas de selenio e inicializar a trav茅s de JUnit RuleChain</a></li>
<li><a href="../480912/index.html">Dap en acci贸n. Escribiendo TodoMVC. Parte 1</a></li>
<li><a href="../480914/index.html">Microservicios para principiantes</a></li>
<li><a href="../480920/index.html">Prueba de interruptores TP-Link con PoE de largo alcance. Y un poco sobre actualizaciones de modelos antiguos</a></li>
<li><a href="../480922/index.html">Evgeny Usvitsky: "Todos en el mundo saben d贸nde obtener geodatos libremente, solo en OSM"</a></li>
<li><a href="../480924/index.html">C贸mo y por qu茅 los creadores del remake de MediEvil redise帽aron al jefe de culto del juego</a></li>
<li><a href="../480926/index.html">Teor铆a de la probabilidad para la representaci贸n f铆sicamente precisa</a></li>
<li><a href="../480928/index.html">Apache Hadoop Code Quality: prueba de producci贸n VS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>