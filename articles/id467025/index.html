<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😦 🈵 🐾 Tentang model jaringan dalam game untuk pemula 👩🏼‍🤝‍👨🏻 🏞️ 🎎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selama dua minggu terakhir saya telah mengerjakan mesin jaringan untuk game saya. Sebelum itu, saya tidak tahu apa-apa tentang teknologi jaringan dala...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tentang model jaringan dalam game untuk pemula</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467025/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69e/de3/6bb/69ede36bb7e48411280ffad409751c0d.png" alt="gambar"></div><br>  Selama dua minggu terakhir saya telah mengerjakan mesin jaringan untuk game saya.  Sebelum itu, saya tidak tahu apa-apa tentang teknologi jaringan dalam permainan, jadi saya membaca banyak artikel dan melakukan banyak percobaan untuk memahami semua konsep dan dapat menulis mesin jaringan saya sendiri. <br><br>  Dalam panduan ini, saya ingin berbagi dengan Anda berbagai konsep yang perlu Anda pelajari sebelum menulis mesin gim Anda sendiri, serta sumber daya dan artikel terbaik untuk mempelajarinya. <br><br>  Secara umum, ada dua jenis utama arsitektur jaringan: peer-to-peer dan client-server.  Dalam arsitektur peer-to-peer (p2p), data ditransfer antara setiap pasangan pemain yang terhubung, dan dalam arsitektur client-server, data ditransmisikan hanya antara pemain dan server. <br><br>  Meskipun arsitektur peer-to-peer masih digunakan di beberapa game, standarnya adalah client-server: lebih mudah diimplementasikan, membutuhkan lebar saluran yang lebih kecil dan memfasilitasi perlindungan terhadap kecurangan.  Oleh karena itu, dalam panduan ini, kami akan fokus pada arsitektur client-server. <br><a name="habracut"></a><br>  Secara khusus, kami paling tertarik pada server otoriter: dalam sistem seperti itu, server selalu benar.  Sebagai contoh, jika seorang pemain berpikir bahwa ia berada di koordinat (10, 5), dan server mengatakan kepadanya bahwa ia berada di (5, 3), maka klien harus mengganti posisinya dengan posisinya yang ditransmisikan oleh server, dan bukan sebaliknya.  Menggunakan server otoriter membuat pengakuan curang lebih mudah. <br><br>  Ada tiga komponen utama untuk sistem jaringan game: <br><br><ul><li>  Transport Protocol: bagaimana data ditransfer antara klien dan server. </li><li>  Protokol aplikasi: apa yang ditransfer dari klien ke server dan dari server ke klien dan dalam format apa. </li><li>  Logika aplikasi: bagaimana data yang dikirimkan digunakan untuk memperbarui status klien dan server. </li></ul><br>  Sangat penting untuk memahami peran setiap bagian dan kesulitan yang terkait dengannya. <br><br><h1>  Protokol transportasi </h1><br>  Langkah pertama adalah memilih protokol untuk mengangkut data antara server dan klien.  Ada dua protokol Internet untuk ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TCP</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UDP</a> .  Tapi Anda bisa membuat protokol transport Anda sendiri berdasarkan salah satunya atau menggunakan perpustakaan tempat mereka digunakan. <br><br><h2>  Membandingkan TCP dan UDP </h2><br>  Baik TCP dan UDP berbasis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IP</a> .  IP memungkinkan Anda untuk mentransfer paket dari sumber ke penerima, tetapi tidak menjamin bahwa paket yang dikirim cepat atau lambat akan mencapai penerima, bahwa paket tersebut akan mencapai setidaknya satu kali dan urutan paket akan tiba dalam urutan yang benar.  Selain itu, paket mungkin hanya berisi ukuran data terbatas yang ditentukan oleh nilai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MTU</a> . <br><br>  UDP hanyalah lapisan tipis di atas IP.  Karena itu, ia memiliki keterbatasan yang sama.  Sebaliknya, TCP memiliki banyak fitur.  Ini menyediakan koneksi yang dapat diandalkan dan dipesan antara dua node dengan pengecekan kesalahan.  Oleh karena itu, TCP sangat nyaman dan digunakan di banyak protokol lain, misalnya, dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HTTP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FTP</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SMTP</a> .  Tetapi semua fitur ini ada harganya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>penundaan</em></a> . <br><br>  Untuk memahami mengapa fungsi-fungsi ini dapat menyebabkan penundaan, Anda perlu memahami cara kerja TCP.  Ketika node pengirim meneruskan paket ke node penerima, ia mengharapkan untuk menerima pengakuan (ACK).  Jika setelah waktu tertentu ia tidak menerimanya (karena paket atau konfirmasi hilang, atau karena alasan lain), maka ia mengirim ulang paket tersebut.  Selain itu, TCP memastikan bahwa paket diterima dalam urutan yang benar, oleh karena itu, sampai paket yang hilang diterima, semua paket lainnya tidak dapat diproses, bahkan jika mereka telah diterima oleh node penerima. <br><br>  Tapi seperti yang mungkin Anda pahami, penundaan dalam permainan multi pemain sangat penting, terutama dalam genre aktif seperti FPS.  Itulah sebabnya banyak game menggunakan UDP dengan protokol mereka sendiri. <br><br>  Protokol asli berbasis UDP bisa lebih efisien daripada TCP karena berbagai alasan.  Misalnya, ini mungkin menandai beberapa paket sebagai tepercaya dan yang lainnya tidak dipercaya.  Oleh karena itu, ia tidak peduli jika paket yang tidak dipercaya mencapai penerima.  Atau dapat memproses beberapa aliran data sehingga paket yang hilang dalam satu aliran tidak memperlambat aliran yang tersisa.  Misalnya, mungkin ada aliran untuk input pemain dan aliran lain untuk pesan obrolan.  Jika pesan obrolan yang bukan data penting hilang, itu tidak akan memperlambat input, yang mendesak.  Atau, protokol eksklusif dapat mengimplementasikan keandalan secara berbeda dari pada TCP agar lebih efisien dalam permainan video. <br><br>  Jadi, jika TCP benar-benar omong kosong, maka kita akan membuat protokol transport sendiri berdasarkan UDP? <br><br>  Semuanya sedikit lebih rumit.  Meskipun TCP hampir tidak optimal untuk sistem jaringan game, ia dapat bekerja dengan baik di game Anda dan menghemat waktu Anda yang berharga.  Misalnya, keterlambatan mungkin bukan masalah untuk gim berbasis giliran atau gim yang hanya bisa dimainkan di LAN, di mana ada penundaan dan kehilangan paket jauh lebih sedikit daripada di Internet. <br><br>  Banyak game yang sukses, termasuk World of Warcraft, Minecraft, dan Terraria, menggunakan TCP.  Namun, sebagian besar FPS menggunakan protokol berbasis UDP eksklusif, jadi kami akan membicarakannya lebih lanjut di bawah ini. <br><br>  Jika Anda memutuskan untuk menggunakan TCP, maka pastikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma Nagle</a> dinonaktifkan, karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendukung</a> paket sebelum mengirim, yang artinya meningkatkan penundaan. <br><br>  Untuk mempelajari lebih lanjut tentang perbedaan antara UDP dan TCP dalam konteks game multi-pemain, Anda dapat membaca artikel oleh Glenn Fiedler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20180823015049/"><em>UDP vs.</em></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20180823015049/"><em>TCP</em></a> <br><br><h2>  Protokol sendiri </h2><br>  Jadi, Anda ingin membuat protokol transport Anda sendiri, tetapi tidak tahu harus mulai dari mana?  Anda beruntung, karena Glenn Fiedler menulis dua artikel luar biasa tentang ini.  Anda akan menemukan banyak pikiran pintar di dalamnya. <br><br>  Artikel pertama, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20180823012240/"><em>Networking for Game Programmer</em></a> 2008, lebih sederhana dari yang kedua, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20180823014904/"><em>Building A Game Network Protocol</em></a> 2016.  Saya sarankan Anda mulai dengan yang lebih tua. <br><br>  Perlu diingat bahwa Glenn Fiedler adalah pendukung besar menggunakan protokol UDP sendiri.  Dan setelah membaca artikelnya, Anda pasti akan mendapatkan lebih dari pendapatnya bahwa TCP memiliki kelemahan serius dalam video game, dan Anda ingin menerapkan protokol Anda sendiri. <br><br>  Tetapi jika Anda baru mengenal jaringan, bantulah diri Anda sendiri dan gunakan TCP atau perpustakaan.  Untuk berhasil mengimplementasikan protokol transport Anda sendiri, Anda harus belajar banyak. <br><br><h2>  Perpustakaan jaringan </h2><br>  Jika Anda membutuhkan sesuatu yang lebih efisien daripada TCP, tetapi Anda tidak ingin repot dengan menerapkan protokol Anda sendiri dan masuk ke banyak detail, maka Anda dapat menggunakan perpustakaan jaringan.  Ada banyak dari mereka: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">yojimbo</a> Glenn Fiedler </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RakNet</a> , yang tidak lagi didukung, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cabang SLikeNet</a> tampaknya masih aktif. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ENet</a> adalah perpustakaan yang dibuat untuk FPS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cube</a> multi-pengguna </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Valve</a> 's <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GameNetworkingSockets</a> </li></ul><br>  Saya belum mencoba semuanya, tetapi saya lebih suka ENet, karena mudah digunakan dan dapat diandalkan.  Selain itu, ia memiliki dokumentasi yang jelas dan tutorial untuk pemula. <br><br><h2>  Protokol Transportasi: Kesimpulan </h2><br>  Untuk meringkas: ada dua protokol transport utama: TCP dan UDP.  TCP memiliki banyak fitur berguna: keandalan, pemesanan paket, deteksi kesalahan.  UDP tidak memiliki semua ini, tetapi TCP, pada dasarnya, telah meningkatkan penundaan yang tidak dapat diterima untuk beberapa game.  Artinya, untuk memastikan latensi rendah, Anda dapat membuat protokol berbasis UDP Anda sendiri atau menggunakan perpustakaan yang mengimplementasikan protokol transport UDP dan disesuaikan untuk permainan video multi-pemain. <br><br>  Pilihan antara TCP, UDP dan perpustakaan tergantung pada beberapa faktor.  Pertama, dari kebutuhan gim: apakah perlu latensi rendah?  Kedua, dari persyaratan protokol aplikasi: apakah perlu protokol yang dapat diandalkan?  Seperti yang akan kita lihat di bagian selanjutnya, Anda dapat membuat protokol aplikasi yang protokolnya tidak dapat diandalkan cukup cocok.  Akhirnya, Anda juga harus memperhitungkan pengalaman pengembang mesin jaringan. <br><br>  Saya punya dua tips: <br><br><ul><li>  Maksimalkan protokol transport dari sisa aplikasi sehingga dapat dengan mudah diganti tanpa menulis ulang seluruh kode. </li><li>  Jangan lakukan optimasi prematur.  Jika Anda bukan spesialis jaringan dan tidak yakin apakah Anda memerlukan protokol transport berbasis UDP Anda sendiri, Anda bisa mulai dengan TCP atau pustaka yang menyediakan keandalan, lalu menguji dan mengukur kinerja.  Jika Anda memiliki masalah dan Anda yakin bahwa alasannya ada pada protokol transport, maka mungkin sudah waktunya untuk membuat protokol transport Anda sendiri. </li></ul><br>  Di akhir bagian ini, saya sarankan Anda membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20190519135537/"><em>Pengantar</em></a> Brian Hook <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20190519135537/"><em>untuk Pemrograman Game Multi Pemain</em></a> , yang mencakup banyak topik yang dibahas di sini. <br><br><h1>  Protokol aplikasi </h1><br>  Sekarang kita dapat bertukar data antara klien dan server, kita perlu memutuskan data mana yang akan ditransfer dan dalam format apa. <br><br>  Skema klasik adalah bahwa klien mengirim input atau tindakan ke server, dan server mengirimkan status permainan saat ini kepada klien. <br><br>  Server tidak mengirim status yang lengkap, tetapi difilter dengan entitas yang berada di sebelah pemain.  Dia melakukan ini karena tiga alasan.  Pertama, keadaan keseluruhan mungkin terlalu besar untuk transmisi frekuensi tinggi.  Kedua, pelanggan terutama tertarik pada data visual dan audio, karena sebagian besar logika game disimulasikan pada server game.  Ketiga, dalam beberapa permainan pemain tidak perlu mengetahui data tertentu, misalnya, posisi lawan di ujung peta, karena kalau tidak, ia dapat mengendus paket dan tahu persis ke mana harus bergerak untuk membunuhnya. <br><br><h2>  Serialisasi </h2><br>  Langkah pertama adalah mengubah data yang ingin kami kirim (input atau status permainan) ke dalam format yang sesuai untuk transmisi.  Proses ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>serialisasi</em></a> . <br><br>  Pikiran segera terlintas dalam pikiran untuk menggunakan format yang dapat dibaca manusia, seperti JSON atau XML.  Tetapi itu akan benar-benar tidak efektif dan sia-sia akan menempati sebagian besar saluran. <br><br>  Sebagai gantinya, Anda disarankan untuk menggunakan format biner yang jauh lebih ringkas.  Artinya, paket hanya akan berisi beberapa byte.  Di sini Anda perlu mempertimbangkan masalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>urutan byte</em></a> , yang mungkin berbeda pada komputer yang berbeda. <br><br>  Anda dapat menggunakan perpustakaan untuk membuat serialisasi data, misalnya: <br><br><ul><li>  Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FlatBuffers</a> </li><li>  Sandstorm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cap'n Proto</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sereal oleh</a> Shane Grant dan Randolph Voorhees </li></ul><br>  Pastikan perpustakaan membuat arsip portabel dan mengurus urutan byte. <br><br>  Solusi independen mungkin implementasi independen, tidak terlalu rumit, terutama jika Anda menggunakan pendekatan berorientasi data dalam kode.  Selain itu, ini akan memungkinkan Anda untuk melakukan optimasi yang tidak selalu memungkinkan saat menggunakan perpustakaan. <br><br>  Glenn Fiedler telah menulis dua artikel tentang serialisasi: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20180823004533/"><em>Paket Membaca dan Menulis</em></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20180823015044/"><em>Strategi Serialisasi</em></a> . <br><br><h2>  Kompresi </h2><br>  Jumlah data yang ditransfer antara klien dan server dibatasi oleh bandwidth saluran.  Kompresi data memungkinkan Anda untuk mentransfer lebih banyak data di setiap foto, meningkatkan kecepatan refresh, atau hanya mengurangi persyaratan saluran. <br><br><h3>  Packing sedikit </h3><br>  Teknik pertama adalah pengepakan bit.  Ini terdiri dalam menggunakan persis jumlah bit yang diperlukan untuk menggambarkan nilai yang diinginkan.  Misalnya, jika Anda memiliki enumerasi yang dapat memiliki 16 nilai yang berbeda, maka alih-alih seluruh byte (8 bit), Anda hanya dapat menggunakan 4 bit. <br><br>  Glenn Fiedler menjelaskan cara mengimplementasikan ini di bagian kedua artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20180823004533/"><em>Paket Membaca dan Menulis</em></a> . <br><br>  Pengepakan bit bekerja sangat baik dengan pengambilan sampel, yang akan menjadi topik bagian selanjutnya. <br><br><h3>  Diskretisasi </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Diskretisasi</em></a> adalah teknik kompresi lossy yang hanya menggunakan subset dari nilai yang mungkin untuk mengkodekan nilai.  Cara termudah untuk menerapkan diskritisasi adalah dengan membulatkan angka floating point. <br><br>  Glenn Fiedler (lagi!) Menunjukkan cara menerapkan pengambilan sampel dalam praktiknya di artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20180823021121/">Snapshot Compression-nya</a> . <br><br><h3>  Algoritma kompresi </h3><br>  Teknik selanjutnya adalah algoritma kompresi lossless. <br><br>  Di sini, menurut pendapat saya, tiga algoritma paling menarik yang perlu Anda ketahui: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengodean Huffman</a> dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode</a> pra-komputasi yang sangat cepat dan dapat memberikan hasil yang baik.  Itu digunakan untuk mengompres paket di mesin jaringan Quake3. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">zlib</a> adalah algoritma kompresi tujuan umum yang tidak pernah meningkatkan jumlah data.  Seperti yang dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , telah digunakan dalam banyak aplikasi.  Mungkin berlebihan untuk memperbarui status.  Tetapi bisa berguna jika Anda perlu mengirim aset, teks panjang atau bantuan kepada klien dari server. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menyalin panjang seri</a> mungkin adalah algoritma kompresi paling sederhana, tetapi sangat efektif untuk tipe data tertentu, dan dapat digunakan sebagai langkah preproses sebelum zlib.  Ini sangat cocok untuk medan kompresi yang terdiri dari ubin atau voxel, di mana banyak elemen tetangga diulang. </li></ul><br><h3>  Kompresi Delta </h3><br>  Teknik kompresi terbaru adalah kompresi delta.  Itu terletak pada kenyataan bahwa hanya perbedaan antara kondisi permainan saat ini dan keadaan terakhir yang diterima oleh klien yang ditransmisikan. <br><br>  Ini pertama kali digunakan dalam mesin jaringan Quake3.  Berikut adalah dua artikel yang menjelaskan cara menggunakannya: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20190628180906/"><em>The Quake3 Networking Model oleh</em></a> Brian Hook </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Ulasan Kode Sumber Gempa 3: Model Jaringan</em></a> Fabien Sanglar [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan</a> artikel tentang Habré, lihat bagian "Model Jaringan"] </li></ul><br>  Glenn Fiedler juga menggunakannya di bagian kedua artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20180823021121/"><em>Snapshot Compression-nya</em></a> . <br><br><h2>  Enkripsi </h2><br>  Selain itu, Anda mungkin perlu mengenkripsi transfer informasi antara klien dan server.  Ada beberapa alasan untuk ini: <br><br><ul><li>  privasi / kerahasiaan: pesan hanya dapat dibaca oleh penerima, dan tidak ada orang lain yang mengendus jaringan yang dapat membacanya. </li><li>  otentikasi: seseorang yang ingin memainkan peran pemain harus tahu kuncinya. </li><li>  pencegahan kecurangan: akan jauh lebih sulit bagi pemain jahat untuk membuat paket kecurangan mereka sendiri, mereka harus memainkan skema enkripsi dan menemukan kuncinya (yang berubah pada setiap koneksi). </li></ul><br>  Saya sangat merekomendasikan menggunakan perpustakaan untuk ini.  Saya sarankan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libsodium</a> karena sangat sederhana dan memiliki tutorial yang bagus.  Yang menarik adalah tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertukaran kunci</a> , yang memungkinkan Anda untuk menghasilkan kunci baru dengan setiap koneksi baru. <br><br><h2>  Protokol Aplikasi: Kesimpulan </h2><br>  Kami akan mengakhiri dengan protokol aplikasi.  Saya percaya bahwa kompresi sepenuhnya opsional dan keputusan untuk menggunakannya hanya tergantung pada permainan dan bandwidth yang diperlukan.  Enkripsi, menurut pendapat saya, adalah wajib, tetapi dalam prototipe pertama yang dapat Anda lakukan tanpanya. <br><br><h1>  Logika aplikasi </h1><br>  Sekarang kami dapat memperbarui status di klien, tetapi kami mungkin mengalami masalah dengan penundaan.  Setelah masuk, pemain harus menunggu pembaruan status permainan dari server untuk melihat apa dampaknya pada dunia. <br><br>  Selain itu, di antara dua pembaruan negara, dunia ini sepenuhnya statis.  Jika refresh rate dari state-nya rendah, maka pergerakannya akan sangat berkedut. <br><br>  Ada beberapa teknik untuk mengurangi dampak dari masalah ini, dan di bagian selanjutnya saya akan membicarakannya. <br><br><h2>  Teknik Keterlambatan Penundaan </h2><br>  Semua teknik yang dijelaskan dalam bagian ini dibahas secara rinci dalam seri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Fast-Paced Multiplayer</em></a> oleh Gabriel Gambetta.  Saya sangat merekomendasikan membaca seri artikel yang luar biasa ini.  Ini juga memiliki demo interaktif yang memungkinkan Anda melihat bagaimana teknik ini bekerja dalam praktiknya. <br><br>  Teknik pertama adalah menerapkan input secara langsung, tanpa menunggu respons dari server.  Ini disebut <em>prediksi sisi klien</em> .  Namun, ketika klien menerima pembaruan dari server, ia harus memastikan bahwa perkiraannya benar.  Jika tidak demikian, maka ia hanya perlu mengubah statusnya sesuai yang diterima dari server, karena server tersebut otoriter.  Teknik ini pertama kali digunakan di Quake.  Anda dapat membaca lebih lanjut tentang hal ini di artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>ulasan kode mesin Quake Engine oleh</em></a> Fabien Sanglar [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan</a> ke dalam Habré]. <br><br>  Set kedua teknik digunakan untuk memuluskan pergerakan entitas lain antara dua pembaruan status.  Ada dua cara untuk mengatasi masalah ini: interpolasi dan ekstrapolasi.  Dalam kasus interpolasi, dua status terakhir diambil dan transisi dari satu ke yang lain ditunjukkan.  Kerugiannya adalah ia menyebabkan sebagian kecil dari keterlambatan, karena klien selalu melihat apa yang terjadi di masa lalu.  Ekstrapolasi memperkirakan di mana entitas sekarang harus didasarkan pada keadaan terakhir yang diterima oleh klien.  Kerugiannya adalah jika entitas benar-benar mengubah arah pergerakan, maka akan ada kesalahan besar antara perkiraan dan posisi nyata. <br><br>  Teknik terakhir yang paling canggih, yang hanya berguna dalam FPS adalah <em>kompensasi lag</em> .  Saat menggunakan kompensasi lag, server memperhitungkan penundaan klien akun saat menembak target.  Sebagai contoh, jika seorang pemain menyelesaikan headshot di layarnya, tetapi dalam kenyataannya tujuannya terletak di tempat lain karena keterlambatan, maka akan tidak jujur ​​untuk menolak pemain untuk membunuh karena penundaan.  Oleh karena itu, server memundurkan waktu kembali ke saat ketika pemain melepaskan tembakan untuk mensimulasikan apa yang dilihat pemain di layarnya dan memeriksa tabrakan antara tembakannya dan target. <br><br>  Glenn Fiedler (seperti biasa!) Menulis artikel tahun 2004 di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20180823005028/"><em>Network Physics (2004)</em></a> , yang meletakkan dasar untuk menyinkronkan simulasi fisika antara server dan klien.  Pada 2014, ia menulis seri baru artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20180823004853/"><em>Fisika Jaringan</em></a> yang menggambarkan teknik lain untuk menyinkronkan simulasi fisika. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada juga dua artikel di wiki Valve, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber Multiplayer Networking</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode Kompensasi Latensi di Klien / Server dalam Desain dan Optimasi Protokol dalam gim</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang membahas penundaan kompensasi.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pencegahan kecurangan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada dua teknik utama untuk mencegah kecurangan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama: mempersulit pengiriman paket berbahaya oleh penipu. </font><font style="vertical-align: inherit;">Seperti yang dinyatakan di atas, enkripsi adalah cara yang baik untuk mengimplementasikannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua: server otoriter hanya menerima perintah / input / tindakan. </font><font style="vertical-align: inherit;">Klien seharusnya tidak dapat mengubah status di server, kecuali dengan mengirim input. </font><font style="vertical-align: inherit;">Kemudian, setiap kali input diterima, server harus memeriksa validitas sebelum menggunakannya.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Logika Aplikasi: Kesimpulan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya menyarankan Anda menerapkan metode simulasi keterlambatan besar dan kecepatan refresh rendah agar dapat menguji perilaku permainan Anda dalam kondisi yang buruk, bahkan ketika klien dan server berjalan di komputer yang sama. </font><font style="vertical-align: inherit;">Ini akan sangat menyederhanakan implementasi teknik smooth smoothing.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sumber daya bermanfaat lainnya </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika Anda ingin menjelajahi sumber daya lain pada model jaringan, Anda dapat menemukannya di sini: </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20190328001900/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog Glenn Fiedler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - layak membaca seluruh blognya, ia memiliki banyak artikel bagus. </font><font style="vertical-align: inherit;">Semua artikel tentang teknologi jaringan dikumpulkan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20180823014743/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awesome Game Networking</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oleh M. Fatih MAR adalah daftar rinci artikel dan video di mesin jaringan video game.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wiki sabreddita r / gamedev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> juga memiliki banyak link yang berguna.</font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467025/">https://habr.com/ru/post/id467025/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467015/index.html">JWT: Digital Signature Attack VS MAC Attack</a></li>
<li><a href="../id467017/index.html">Apa itu HED / MRSD dan untuk apa ini?</a></li>
<li><a href="../id467019/index.html">Merancang dasbor untuk situs web analitik e-commerce Bagian 3: Saluran SEO</a></li>
<li><a href="../id467021/index.html">Bagaimana Robot Nurani berkomunikasi dengan pelanggan</a></li>
<li><a href="../id467023/index.html">Kami membuat plugin di Grafana untuk memantau k8: sudah ada di toko Grafana resmi</a></li>
<li><a href="../id467029/index.html">Grigory Petrov: bekerja dengan jaringan di Ruby</a></li>
<li><a href="../id467033/index.html">Pilihan makalah teknis keren dari Chaos Communication Camp 2019</a></li>
<li><a href="../id467035/index.html">Merancang dasbor untuk situs web analitik e-commerce Bagian 4: Saluran Youtube</a></li>
<li><a href="../id467037/index.html">Anjak piutang: cara mendapatkan uang untuk kursi</a></li>
<li><a href="../id467039/index.html">Cara melakukan tinjauan kode</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>