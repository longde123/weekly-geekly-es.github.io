<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤²ğŸ¾ ğŸ•ºğŸ½ ğŸ¤­ Logika berfikir spin-off 2: beberapa algoritma rantai ğŸ‘¨ğŸ½â€ğŸ’» ğŸˆ‚ï¸ ğŸ§‘â€ğŸ¤â€ğŸ§‘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tantangan:
 pisahkan urutan kejadian yang sering diulang menjadi rantai terpisah di mana tidak akan ada yang berlebihan.
 Tugas ini memiliki banyak so...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Logika berfikir spin-off 2: beberapa algoritma rantai</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/388725/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tantangan:</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pisahkan urutan kejadian yang sering diulang menjadi rantai terpisah di mana tidak akan ada yang berlebihan.</font></font><br>
<a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tugas ini memiliki banyak solusi. "Baking" yang sering digunakan - hubungan yang sering digunakan diperbaiki, sementara yang lain melemah. Di final, Anda harus mendapatkan rantai di mana peristiwa yang paling sering diulang memiliki ikatan yang kuat. Solusi ini memiliki banyak kekurangan, di antaranya - kecepatan rendah. Tetapi kami memiliki gelombang identifikasi dari Redozubov, kami dapat menggunakan algoritma lain yang dapat membentuk rantai baru setelah pengulangan pertama. Mari kita mulai dengan yang sederhana. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catatan terakhir</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode untuk merekam semua peristiwa dalam rantai memori dijelaskan. </font><font style="vertical-align: inherit;">Biarkan sistem pernah membaca kata "peluruhan", dan di waktu lain - kata "air terjun". </font><font style="vertical-align: inherit;">Dua kata ini memiliki bagian yang sama - akhir dari tiga huruf. </font><font style="vertical-align: inherit;">Menurut kondisi masalah, perlu untuk menyoroti rantai "pad". </font><font style="vertical-align: inherit;">Rantai ini tidak memiliki prasyarat, yaitu, dengan mudah mengenali input yang sesuai.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu solusi</font></font></h2><br>
<img src="https://habrastorage.org/files/e2d/fed/f56/e2dfedf56cab44f5b147eabedaa9d22f.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami membagi tugas menjadi dua: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) menemukan dua rangkaian peristiwa yang serupa (Anda perlu memahami bahwa kira-kira dua kata ini mengandung urutan yang sama) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) memilihnya dalam rantai yang terpisah ("pad")</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita mulai dengan bagian 2. Kami menyulitkan neurocluster dengan stempel waktu, yang menyimpan semua peristiwa dalam rantai memori, seperti yang ditunjukkan dalam gambar. Berkat bagian pengenal (arah koneksi naik dari atribut ke cap waktu umum), subtugas 1 akan diselesaikan - untuk menemukan posisi dengan atribut umum, dan berkat rantai memori dengan tautan ke bawah, subtugas 2 akan dipecahkan. Solusi untuk subtugas 2 adalah ini: kita akan mulai mengingat dua kata pada saat yang sama di mana mereka memiliki kesamaan. Artinya, sistem akan mengirimkan aktivasi oleh neuron yang sesuai dengan surat-surat itu. Jika huruf ditemukan dalam kedua kata, maka harus diingat. Untuk melakukan ini, biarkan ingatan terjadi dengan setengah kekuatan. Jika ambang aktivasi neuron adalah T, maka rantai memori harus mengirim 0,5 T potensial aksi. Maka ambang aktivasi hanya akan terlampaui jikaketika gejala bertemu di kedua rantai. Setelah ini, gejalanya menjadi diaktifkan. Kemudian Anda dapat menggunakan algoritme menghafal yang biasa dengan kode dari artikel sebelumnya - hippocampus akan membuat rantai memori, menugaskannya tanda-tanda yang umum untuk kedua rantai. Kami mengurangi solusi ke solusi sebelumnya.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam ENS (NS alami), "setengah aktivasi" dapat dicapai dengan memvariasikan waktu pengiriman (jumlah lonjakan yang tiba), jumlah neurotransmitter, atau mungkin dengan menggunakan koneksi penghambat (untuk mengubah 1T menjadi 0,5T).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Subtask 1 agak lebih rumit, karena seharusnya bekerja dengan pengenalan fuzzy. </font><font style="vertical-align: inherit;">Artinya, bahkan jika hanya ada beberapa tanda umum dalam rantai yang hilang di suatu tempat di tengah rantai, Anda harus tetap memperhatikan situasi ini. </font><font style="vertical-align: inherit;">Biarkan saya mengingatkan Anda bahwa, secara relatif, neuron dapat dalam tiga mode - istirahat, mengirim sinyal tunggal, dan mode aktivasi frekuensi tinggi. </font><font style="vertical-align: inherit;">Dapat diterima bahwa "pengakuan penuh" mengarah ke transisi neuron ke mode aktivasi frekuensi tinggi, dan pengakuan fuzzy mengarah ke transmisi sinyal tunggal. </font><font style="vertical-align: inherit;">Atau kita dapat berasumsi bahwa akan ada neuron khusus dalam neurocluster, beberapa di antaranya hanya akan bekerja dengan kebetulan dan pengakuan percaya diri, dan neuron lain akan bekerja jika hanya sebagian dari fitur yang dikenali. </font><font style="vertical-align: inherit;">Ada banyak solusi, yang utama adalah entah bagaimana memperhatikan tampilan aktivasi pada cluster yang diinginkan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kapan melakukannya</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pertanyaannya adalah jam berapa untuk melakukan pencarian seperti itu. Ada beberapa pendekatan: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) mode tidur khusus - lebih tepatnya, "tidur lambat". Sistem melewati semua peristiwa yang dipelajari dalam sehari, dan mencari kecocokan dengan ingatan lainnya. Dalam hal ini, sistem menggunakan memori - mengirim dalam rantai menurun, kemudian memberikan waktu bagi neuron tanda untuk mengirim sinyal yang sudah "naik" ke memori lain. Setelah itu ia merangkum dan mencari ingatan-ingatan yang memiliki jumlah total aktivasi terbesar. Lalu ia memilih salah satu dari tempat-tempat ini dan meluncurkan subtugas 2 - â€œpilih rantaiâ€.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) tanpa rejimen tidur khusus. </font><font style="vertical-align: inherit;">Sistem dapat melakukan pencarian dengan cepat, selama persepsi - dan seperti apa situasi saat ini? </font><font style="vertical-align: inherit;">Sebenarnya, pencarian terjadi secara otomatis selama pemikiran normal karena pengiriman sinyal oleh neuron, sistem hanya dapat memperhatikan ingatan yang memiliki banyak kesamaan dengan situasi saat ini, dan jika perlu, jalankan analisis - pilih sub-rantai umum.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritma serupa</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algoritma ini tampak sederhana, tetapi mereka mengandung banyak seluk-beluk, bahkan lebih dari pada algoritma pengurutan cepat, yang, seperti yang Anda tahu, tidak dapat ditulis untuk waktu yang lama tanpa kesalahan.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tugas ini mirip dengan tugas yang diketahui, misalnya, mencari urutan DNA umum. Hanya DNA pada setiap langkah yang hanya dapat memiliki satu nukleotida, dan dalam jaringan saraf untuk setiap stempel waktu dapat terdapat jumlah karakter yang berubah-ubah. Oleh karena itu, tugas ini adalah kasus yang lebih umum dibandingkan dengan pencarian DNA. Jika Anda mencoba mentransfer algoritme yang ada dan menyelesaikan masalah "celah" seperti itu, tanpa jaringan saraf, dengan memanipulasi daftar tanda, maka kepala Anda mulai berputar - semua daftar pertandingan bersarang ini, daftar urutan pertandingan, daftar urutan pertandingan, pertanyaan lain. Memecahkan masalah ini dengan mengirimkan aktivasi ke neuron jauh lebih sederhana - neuron sudah ada, mereka melakukan semuanya secara otomatis, ingatan mereka sudah dialokasikan, tidak ada daftar yang diperlukan, itu tetap hanya untuk menganalisis beberapa neuron dan menjalankan algoritma yang diperlukan.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya memanggil mode subtugas 1 dan 2 dengan masing-masing satu dan dua rantai utama. </font><font style="vertical-align: inherit;">Yaitu, "berapa banyak neuron turun aktif dalam rantai memori mengirim sinyal dalam upaya untuk menyoroti kecocokan." </font><font style="vertical-align: inherit;">Jika hanya ada satu rantai yang ditarik kembali seperti itu, maka ia sedang mencari kandidat kedua untuk verifikasi. </font><font style="vertical-align: inherit;">Dan jika kandidat telah ditemukan, maka Anda dapat mengaktifkannya dan mulai menyorot tanda-tanda. </font><font style="vertical-align: inherit;">Nama-nama tersebut - "1 atau 2 rantai terkemuka" - akan memungkinkan untuk merujuk pada algoritma ini dengan nama, daripada "subtask 1 atau 2". </font><font style="vertical-align: inherit;">Mode dengan satu rantai utama juga bisa disebut "mode pencarian kebetulan", dan 2 rantai utama dapat disebut mode menyoroti kebetulan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cari yang cocok ...</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(1 , 1 rantai terkemuka) dapat dilakukan dengan cara-cara berikut: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) melihat semua kenangan yang bertemu sepanjang hari secara linear. Transisi ke mode ini untuk keperluan debugging dapat dilakukan sebagai berikut: karakter Unicode khusus atau kata khusus dimasukkan ke dalam set uji data input untuk JST, setelah membaca, JST akan beralih ke mode "tidur lambat" dan mulai mencari kecocokan. Artinya adalah ini - mereka mengisi JST dengan data nyata, meluncurkan algoritma debugging untuk menemukan generalisasi.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) untuk menggunakan bukan pencarian linear, tetapi untuk memulai analisis dengan situasi yang paling menarik - dengan mereka yang memiliki warna emosional terbesar. Optimasi ini diperlukan, karena algoritma ini sangat rakus. Pada tikus, tampaknya ingatan akan apa yang terjadi hanya sekitar 10 kali lebih cepat dari pada siang hari. Tidur membutuhkan waktu lebih sedikit daripada bangun. Jadi, dengan distribusi waktu yang merata di semua ingatan, setiap ingatan dapat dikelola untuk membandingkan hanya beberapa situasi yang serupa, yang sebagian besar akan menjadi sampah dan kebetulan yang tidak penting. Oleh karena itu, penting untuk berkonsentrasi pada yang paling penting, dan mulai bekerja dengannya. Kita dapat mengatakan bahwa algoritma menambahkan satu langkah lagi - 0 rantai utama, pada langkah ini sistem harus memilih peristiwa berikutnya dalam memori dengan kepentingan maksimum,dan meneruskannya ke langkah berikutnya - jadikan itu rantai utama untuk menemukan kecocokan.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3) dimungkinkan untuk membuat serif dari saat terjaga - pra-membuat koneksi ke tempat-tempat paling menarik yang perlu dibandingkan di malam hari. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rantai yang dipilih dengan kebetulan kebetulan diingat, tetapi di masa depan mereka dapat dilupakan jika kepentingannya memudar seiring waktu.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lupa</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lupa menyebabkan neurocluster dihapus - operasi removeNC, kebalikan dari operasi newNC. </font><font style="vertical-align: inherit;">Dalam ENS, neuron tidak akan pergi ke mana pun, mereka tidak akan mati, koneksi mereka hanya akan melemah sedemikian rupa sehingga mereka tidak akan lagi bereaksi terhadap tanda-tanda mereka, dan akan siap menyesuaikan kembali untuk mengingat kombinasi lain. </font><font style="vertical-align: inherit;">Dalam model kami, neuron semacam itu tidak perlu disimpan, mereka dapat segera dihapus - ini akan mempercepat operasi JST, mengurangi konsumsi memori, dan menyederhanakan debugging. </font><font style="vertical-align: inherit;">Ini memungkinkan Anda untuk mengurangi kebutuhan konsumsi memori dengan urutan besarnya.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paralelisasi</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk melakukan transisi dari mode 1  ke 2 , pada awalnya saya mencoba membuat neuron kontrol yang menghasilkan pengalihan sinyal, analisis, dan perubahan mode. Tapi kemudian saya menemukan pekerjaan ini terlalu rendah dan mulai menulis kode C ++ imperatif - kode seperti "berjalan melalui semua cluster, menganalisisnya, pilih yang Anda butuhkan, pikirkan apakah akan mengubah mode operasi".</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertanyaan tentang kinerja sistem seperti itu: jika Anda membuat perangkat keras neuron, Anda dapat memparalelasinya (ya, setidaknya pada kartu video). Kemudian kode dengan mengendalikan neuron dan koneksi di dalam cluster dengan mudah dan otomatis diparalelkan (ini hanya paket aktivasi yang diparalelkan sesuai dengan kondisi tugas), tetapi kode C ++ yang penting harus diparalelisasi setiap kali secara independen. Oleh karena itu, untuk jaringan saraf single-threaded kecil, lebih mudah untuk menulis kode C ++, dan untuk JST paralel besar-besaran, lebih baik untuk mentransfer pekerjaan ini di dalam JST itu sendiri ke pundak neuron dan koneksi di antara mereka. Kita tidak boleh lupa bahwa "cycle through all neuron" atau "cycle through all neuroclusters" dalam C ++ dari sudut pandang perangkat keras JST adalah O (1), satu langkah pengiriman aktivasi. Karena itu bisa dilihatbaik 1VTs dan 2VTs (rantai terkemuka) untuk JST paralel yang ideal memiliki kompleksitas komputasi yang sama.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lanjutan: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peramalan primitif di JST</font></font></a></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id388725/">https://habr.com/ru/post/id388725/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id388711/index.html">Otomatisasi penerangan plot di desa atau langkah pertama ke rumah pintar</a></li>
<li><a href="../id388713/index.html">Periode ketujuh dari tabel periodik sekarang diisi, dan ini secara resmi</a></li>
<li><a href="../id388715/index.html">Dalam versi baru Android N Google akan beralih ke OpenJDK</a></li>
<li><a href="../id388719/index.html">Logika pemikiran - spin-off</a></li>
<li><a href="../id388723/index.html">Meninggal Peter Naur, salah satu pencipta Algol dan notasi BNF</a></li>
<li><a href="../id388727/index.html">Pengembang implan yang dapat mengembalikan fungsionalitas ke anggota tubuh yang lumpuh menerima $ 16 juta</a></li>
<li><a href="../id388729/index.html">M5BAT - pendekatan baru untuk penyimpanan energi industri</a></li>
<li><a href="../id388731/index.html">7 foto sains terbaik tahun 2015 menurut Wired</a></li>
<li><a href="../id388733/index.html">Luncurkan Windows 95 di Nintendo 3DS? Ya itu mungkin</a></li>
<li><a href="../id388735/index.html">Kembali ke dasar: permintaan untuk kaset audio meningkat secara signifikan pada tahun 2015</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>