<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úã ü§úüèø üíÆ Rendimiento de front-end: an√°lisis de m√©tricas importantes üôåüèª ‚ö±Ô∏è üà∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Por lo general, el rendimiento se entiende como el n√∫mero de operaciones para un determinado intervalo de tiempo, y cuantas m√°s, mejor. Pero tal defin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rendimiento de front-end: an√°lisis de m√©tricas importantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/454920/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ou/4k/ny/ou4knymbtseyhgwt9_zcalajm4s.png"></div>  Por lo general, el rendimiento se entiende como el n√∫mero de operaciones para un determinado intervalo de tiempo, y cuantas m√°s, mejor.  Pero tal definici√≥n, y el enfoque en su conjunto, tienen poca aplicabilidad al front-end, porque cada usuario tendr√° su propio "front-end".  De eso es de lo que quiero hablar, de lo que est√° sucediendo "all√≠", con el usuario, del otro lado, en realidad, y no en su MacBook superior. <br><br>  Adem√°s de esto, tratar√© de considerar brevemente las reglas generales para optimizar el c√≥digo y algunos errores a los que vale la pena prestarles atenci√≥n.  Tambi√©n le contar√© acerca de una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramienta</a> que ayuda no solo en la creaci√≥n de perfiles, sino que tambi√©n incluye una serie de m√©tricas b√°sicas sobre el rendimiento de su aplicaci√≥n (y espero que lea esta publicaci√≥n hasta el final). <br><a name="habracut"></a><br>  En primer lugar, determinaremos qu√© es el rendimiento de front-end y luego pasaremos a c√≥mo medirlo.  Entonces, como dije, no mediremos algunas operaciones por segundo, necesitamos datos reales que puedan responder a la pregunta de qu√© sucede exactamente con nuestro proyecto en cada etapa de su trabajo.  Para hacer esto, necesitamos el siguiente conjunto de m√©tricas: <br><br><ul><li>  velocidad de descarga; </li><li>  tiempo de primer renderizado e interactividad (Time To Interactive); </li><li>  velocidad de reacci√≥n a las acciones del usuario; </li><li>  FPS para desplazamiento y animaciones; </li><li>  inicializaci√≥n de la aplicaci√≥n; </li><li>  si tiene un SPA, entonces necesita medir el tiempo dedicado a cambiar entre rutas; </li><li>  consumo de memoria y tr√°fico; </li><li>  y ... suficiente por ahora. </li></ul><br>  Todas estas son m√©tricas b√°sicas, sin las cuales es imposible entender qu√© est√° sucediendo exactamente en el front-end.  Y no solo en la parte frontal, sino en realidad, con el usuario final.  Pero para comenzar a recopilar estas m√©tricas, primero debe aprender a medirlas, as√≠ que recordemos qu√© m√©todos existen para el an√°lisis de rendimiento. <br><br>  Lo primero para comenzar es, por supuesto, la API de rendimiento.  A saber, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">performance.timing</a> , a trav√©s del cual puede averiguar cu√°nto tiempo le llev√≥ a un usuario abrir su proyecto.  Pero la API de rendimiento cubre solo una parte de la m√©trica, el resto deber√° ser medido por nosotros mismos, y para esto tenemos las siguientes herramientas: <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  <sub>Pros</sub> </th><th>  <sub>Contras</sub> </th></tr><tr><td>  <sub>console.time ('etiqueta')</sub> </td><td>  <sub>Funciona fuera de la caja.</sub> <sub><br><br></sub>  <sub>Se muestra en la consola.</sub> <sub><br><br></sub>  <sub>Aparece en DevTools -&gt; Rendimiento -&gt; Tiempo de usuario.</sub> </td><td> El resultado solo est√° en DevTools, no hay forma de enviarlo al servidor (es decir, no hay forma de obtener un valor para an√°lisis adicionales). <br><br>  Requiere <code>console.timeEnd</code> con la <code>label</code> original. <br><br>  Sin codificaci√≥n de color. <br><br>  Sin agrupaci√≥n (algo as√≠ como <code>groupEnd</code> / <code>groupEnd</code> ). </td></tr><tr><td>  performance.now () </td><td>  Control total sobre el principio y el final. <br><br>  Puedes enviar al servidor. <br><br></td><td>  No hay pantalla en la consola. <br><br>  No hay visualizaci√≥n en DevTools -&gt; Rendimiento -&gt; Tiempo de usuario. <br><br>  Necesita arrastrar la variable "inicio". <br><br>  Sin agrupaci√≥n </td></tr><tr><td>  rendimiento.marca / medida </td><td>  Control total sobre el principio y el final. <br><br>  Puedes enviar al servidor. <br><br>  Aparece en DevTools -&gt; Rendimiento -&gt; Tiempo de usuario. </td><td>  No hay pantalla en la consola. <br><br>  Para medir algo, debe establecer tres etiquetas √∫nicas y llamar a dos m√©todos, pero en el buen sentido tambi√©n necesita <code>performance.clearMarks</code> y <code>performance.clearMeasures</code> , lo que hace que su uso sea extremadamente inconveniente. <br><br>  Sin agrupaci√≥n </td></tr></tbody></table></div>  En ese momento, me di cuenta de que necesita ver una herramienta que combine las ventajas de lo anterior y, si es posible, no tenga inconvenientes.  Entonces estaba <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PerfKeeper</a> . <br><br><br><h2>  Perfkeeper </h2><ul><li>  Control total sobre el principio y el final. </li><li>  Puedes enviar al servidor. </li><li>  Se muestra en la consola. </li><li>  Admite DevTools -&gt; Rendimiento -&gt; Tiempo de usuario. </li><li>  Hay una agrupaci√≥n. </li><li>  Hay una codificaci√≥n de colores (as√≠ como unidades de medida, es decir, puede medir no solo el tiempo). </li><li>  Soporta extensiones. </li></ul><br>  Ahora no pintar√© la API aqu√≠, no escrib√≠ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> para esto, y el art√≠culo no trata sobre eso, pero continuar√© sobre c√≥mo recopilar m√©tricas. <br><br><br><h2>  Velocidad de descarga de la p√°gina </h2>  Como ya dije, puede encontrar la velocidad de descarga desde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">performance.timing</a> , que le permitir√° descubrir el ciclo completo desde el inicio de la carga de la p√°gina (tiempo para resolver DNS, instalar HTTP Handshake, procesar la solicitud) hasta la carga de la p√°gina completa (DomReady y OnLoad): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eaf/320/48c/eaf32048c515e0a77ebeaa63e862def4.png"><br><br>  Como resultado, debe obtener el siguiente conjunto de m√©tricas: <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/051/23d/b6a/05123db6af6359cc9f364b939f22fbcf.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/0d7/297/cdb/0d7297cdbd0c28f16849706a72bc54b5.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/6c0/ddc/21b/6c0ddc21b01640151d9e48b0018f2190.png"></td></tr></tbody></table></div>  <i>Un ejemplo de la extensi√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">navegaci√≥n</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Pero esto no es suficiente, solo obtuvimos los valores b√°sicos y a√∫n no sabemos qu√© es exactamente lo que tom√≥ tanto tiempo.  Y para averiguarlo, tambi√©n debe completar las m√©tricas HTML. <br><br>  Como ya dije, mostrar√© ejemplos usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PerfKeeper</a> , por lo que lo primero que debe hacer es en l√≠nea en <code>&lt;hed/&gt;</code> PerfKeeper (2.5 Kb) y m√°s: <img src="https://habrastorage.org/getpro/habr/post_images/dc8/a62/0b1/dc8a620b1d143b6fd2d328fed332e6ee.png"><br><br>  Como resultado, ver√° tanta belleza en la consola: <br><img src="https://habrastorage.org/getpro/habr/post_images/463/655/c0c/463655c0c0b6d5c23f0edb0828a4040b.png" width="350"><br><br>  Este es un m√©todo cl√°sico de medici√≥n del abuelo, 100% funciona.  Pero el mundo no se detiene, y para mediciones m√°s precisas ahora tenemos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API de temporizaci√≥n de recursos</a> (y si los recursos est√°n en un dominio separado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Timing-Allow-Origin</a> para ayudarlo). <br><br>  Y aqu√≠ vale la pena hablar de los errores cl√°sicos durante la carga inicial de la p√°gina, a saber: <br><br><ul><li>  falta de GZip y HTTP / 2 (s√≠, esto todav√≠a es com√∫n); </li><li>  uso irrazonable de fuentes (a veces una fuente est√° conectada solo por un encabezado o incluso un n√∫mero de tel√©fono en el pie de p√°gina 0_o); </li><li>  Los paquetes CSS / JS son demasiado gen√©ricos. </li></ul><br>  Formas de optimizar la carga de la p√°gina: <br><br><ul><li>  use Brotli (o incluso SDCH) en lugar de GZip, habilite HTTP / 2; </li><li>  Recopile solo el CSS necesario (cr√≠tico) y no se olvide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CSSO</a> ; </li><li>  minimice el tama√±o del paquete JS separando el paquete CORE m√≠nimo y cargue el resto bajo demanda, es decir  asincr√≥nicamente </li><li>  cargar JS y CSS en modo sin bloqueo, creando din√°micamente <code>/&gt;  &lt;sript src="..."/&gt;</code> , idealmente cargue JS despu√©s del contenido principal; </li><li>  use SVG en lugar de PNG, y si se combina con JS, eliminar√° el XML redundante (por ejemplo, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">font-awesome</a> ); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">use carga diferida</a> para im√°genes e iframes (adem√°s de esto, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">soporte nativo</a> aparecer√° en el futuro cercano). </li></ul><br><br><h2>  Primer tiempo de renderizado e interactividad (TTI) </h2>  La siguiente etapa despu√©s de la carga es el momento en que el usuario vio el resultado y la interfaz entr√≥ en modo interactivo.  Para esto necesitamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Performance Paint Timing</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PerformanceObserver</a> . <br><br>  El primero es simple, llamamos <code>performance.getEntriesByType('paint')</code> y obtenemos dos m√©tricas: <br><br><ul><li>  first-paint: la primera representaci√≥n; </li><li>  first-contentful-paint - y el primer render completo. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/ef7/230/acb/ef7230acbfdcace32596ce157bb00706.png" width="350"><br>  <i>Un ejemplo de la extensi√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pintura</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Pero con la pr√≥xima m√©trica, Time To Interactive, es un poco m√°s interesante.  No hay una forma exacta de determinar cu√°ndo su aplicaci√≥n se volvi√≥ interactiva, es decir  accesible para el usuario, pero esto puede entenderse indirectamente por la ausencia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tareas largas</a> : <br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// TTI let ttiLastEntry: PerformanceEntry | undefined; let ttiPerfObserver: PerformanceObserver; try { ttiPerfObserver = new PerformanceObserver((list) =&gt; { ttiLastEntry = list.getEntries().pop(); }); ttiPerfObserver.observe({ entryTypes: ['longtask'], }); } catch (_) {} domReady(() =&gt; { // TTI Check if (ttiPerfObserver) { let tti: number; const check = () =&gt; { if (ttiLastEntry) { tti = ttiLastEntry.startTime + ttiLastEntry.duration; if (now() - tti &gt;= options.ttiDelay) { //  logntask  ,  , //     ;] send('tti', 'value', 0, tti); ttiPerfObserver.disconnect(); } else { setTimeout(check, options.ttiDelay); } } else if (tti) { send('tti', 'value', 0, tti); ttiPerfObserver.disconnect(); } else { //   logntask,         , //  ,       DOMReady! tti = now(); setTimeout(check, 500); } } //   check(); } });</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/a03/dcb/6e1/a03dcb6e138ee982ab4cd90a2c1b7f09.png" width="350"><br>  <i>Un ejemplo de la extensi√≥n de rendimiento para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Adem√°s de estas m√©tricas b√°sicas, tambi√©n se necesita la m√©trica de preparaci√≥n de su aplicaci√≥n, es decir,  en alg√∫n lugar de su c√≥digo deber√≠a ser as√≠: <pre> <code class="javascript hljs">Import { system } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@perf-tools/keeper'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applicationBoot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Application(el, data); <span class="hljs-comment"><span class="hljs-comment">//     app.ready(() =&gt; { system.add('application-ready', 0, system.perf.now()); // Ô∏èapplication-ready: 3074.000ms }); return app; }</span></span></code> </pre> <br><br><h2>  Tasa de respuesta a las acciones del usuario. </h2>  Hay un campo enorme para las m√©tricas y son muy individuales, por lo que hablar√© sobre dos b√°sicas que son adecuadas para cualquier proyecto, a saber: <br><br>  <b>primer evento</b> : la hora del primer evento, por ejemplo, el primer clic (dividiendo d√≥nde pinch√≥ el usuario), esta m√©trica es especialmente relevante para todo tipo de resultados de b√∫squeda, una lista de productos, noticias, etc.  Con √©l, puede controlar c√≥mo el tiempo de reacci√≥n y el flujo de usuario de sus acciones (cambios en: dise√±o / nuevas caracter√≠sticas / optimizaciones, etc.) cambian <img src="https://habrastorage.org/getpro/habr/post_images/31a/f2c/e7e/31af2ce7e1ed48f7bfc4cacc6a6ddb0e.png" width="350"><br>  <i>Un ejemplo de la extensi√≥n de rendimiento para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  <b>latencia</b> : retraso al procesar algunos eventos, por ejemplo: <code>click</code> , <code>input</code> , <code>submit</code> , <code>scroll</code> , etc. <br><br>  Para medir el retraso, simplemente cuelgue el controlador de eventos en la <code>window</code> con <code>capture = true</code> y use <code>requestAnimationFrame</code> calcular la diferencia, este ser√° el retraso: <pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(eventType, ({target}) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = now(); requestAnimationFrame(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> latency = now() - start; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (latency &gt;= minLatency) { <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶. } }); }, true);</span></span></code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e68/e3e/07d/e68e3e07d64825c3f07175625d477283.png" width="350"><br>  <i>Un ejemplo de la extensi√≥n de rendimiento para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@ perf-tools / keeper</a> trabajando cuando se calcula un n√∫mero de Fibonacci con un clic.</i> <br><br><br><h2>  FPS al desplazarse y animar </h2>  Esta es la m√©trica m√°s interesante, generalmente se mide a trav√©s de <code>requestAnimationFrame</code> , y si necesita hacer una medici√≥n FPS constante, entonces el cl√°sico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FPSMeter</a> lo har√° (aunque es demasiado optimista).  Pero no funciona en absoluto si necesita medir la suavidad del desplazamiento de la p√°gina, porque  Necesita un calentamiento.  Y luego me encontr√© con una forma muy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interesante</a> . <br><br>  Ingeniosamente, de hecho, simplemente creamos un div transparente (1x1px), le agregamos <code>transition: left 300ms linear</code> 300 ms <code>transition: left 300ms linear</code> y lo ejecutamos de una esquina a otra, y mientras se anima, a trav√©s de <code>requestAnimationFrame</code> verificamos su izquierda real, y si la nueva longitud difiere de la anterior, luego aumente el n√∫mero de cuadros renderizados (de lo contrario, tenemos una reducci√≥n de FPS). <br><br>  Y eso no es todo, si usa FF, entonces simplemente hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mozPaintCount</a> , que es responsable de la cantidad de cuadros procesados, es decir  recordamos "HACER", y en el <code>transitionend</code> calculamos la diferencia. <br><br>  Total, sin ning√∫n calentamiento, sabemos con certeza si el navegador redibuj√≥ el marco o no. <br><br>  Pronto prometen una API normal: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://wicg.github.io/frame-timing/</a> <div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/5c9/17b/d15/5c917bd15c349dd2101e10ce687294c5.png" width="350"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/964/4cc/6bb/9644cc6bb9c21671b5c7c7e34b596ff8.png" width="350"></td></tr></tbody></table></div>  <i>Un ejemplo de la extensi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fps</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Optimizaci√≥n de desplazamiento: <br><br><ul><li>  lo m√°s simple es no hacer nada en el desplazamiento, o retrasar la ejecuci√≥n a trav√©s de <code>requestAnimationFrame</code> , o incluso <code>requestIdleCallback</code> ; </li><li>  utilice con mucho cuidado <code>pointer-events: none</code> , activarlo y desactivarlo puede tener el efecto contrario, por lo que es mejor realizar un experimento A / B utilizando <code>pointer-events</code> y sin √©l; </li><li>  no se olvide de las listas virtualizadas, casi todos los motores de View ahora tienen dichos componentes, pero nuevamente, tenga cuidado, los elementos de dicha lista deben ser lo m√°s simples posible, o use "dummies" que ser√°n reemplazados por elementos reales despu√©s de completar el desplazamiento.  Si escribe una lista virtualizada usted mismo, no use HTML interno y no se olvide del reciclaje DOM (esto es cuando no crea elementos DOM para cada estornudo, sino que los reutiliza). </li></ul><br><br><h2>  Inicializaci√≥n de la aplicaci√≥n </h2>  Solo hay una regla: detalles para que pueda responder exactamente qu√© tiempo ha consumido exactamente desde la inicializaci√≥n de la aplicaci√≥n hasta el lanzamiento final.  Como resultado, debe obtener al menos las siguientes m√©tricas: <br><br><ul><li>  cu√°nto tiempo llev√≥ resolver cada adicci√≥n; </li><li>  tiempo para recibir y preparar datos para la aplicaci√≥n; </li><li>  Aplicaci√≥n de renderizado con detalles por bloques. </li></ul><br>  Es decir  en la salida, debe obtener esas m√©tricas mediante las cuales puede realizar un seguimiento exacto de la fase en la que se realiza su reducci√≥n. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de trabajo</b> <div class="spoiler_text">  <b>Consola</b> <img src="https://habrastorage.org/getpro/habr/post_images/678/c35/91f/678c3591fc9c9d1b46481a67be2d4551.png"><br><br>  <b>Tiempo de usuario</b> <img src="https://habrastorage.org/getpro/habr/post_images/b1e/67e/8c4/b1e67e8c408d8ad929ee6e404889a593.png"></div></div><br><br><br><h2>  Si tiene SPA, debe medir el tiempo de enrutamiento </h2>  En primer lugar, debe haber una m√©trica general para evaluar el rendimiento (tiempo de tr√°nsito en la ruta) en su conjunto, pero tambi√©n es necesario tener una m√©trica para cada ruta (por ejemplo, tenemos una "Lista de hilos", "Lectura de un hilo", "B√∫squeda", etc. d.), la m√©trica en s√≠ misma debe dividirse en m√©tricas: <br><br><ul><li>  Recepci√≥n de datos (con un desglose de cu√°les) <ul><li>  Procesamiento </li><li>  Actualizaci√≥n </li></ul></li><li>  Renderizar <ul><li>  Aplicaci√≥n total </li><li>  Bloques (por ejemplo, con nosotros, ser√°: "Columna izquierda" (tambi√©n conocida como "Lista de carpetas"), "Barra de b√∫squeda inteligente", "Lista de letras" y similares) </li></ul></li></ul><br>  Sin todo esto, es imposible entender d√≥nde comienzan los problemas, por lo que tenemos muchos m√≥dulos listos para usar (por ejemplo, el mismo m√≥dulo para XHR tiene <code>startTime</code> y <code>endTime</code> , que se registran autom√°ticamente). <br><br>  Pero estas m√©tricas no son suficientes para evaluar adecuadamente lo que est√° sucediendo.  Son demasiado generales porque  estamos hablando de SPA, entonces definitivamente tiene alg√∫n tipo de cach√© de tiempo de ejecuci√≥n (para no volver al servidor si ya ha estado all√≠), por lo que nuestras m√©tricas se dividen en enrutamiento con y sin cach√©.  A√∫n as√≠, espec√≠ficamente en nuestro caso, dividimos la m√©trica por el n√∫mero de entidades que contiene.  En otras palabras, no puede agregar la vista "Hilo" con 1, 5, 10 o m√°s de 100 letras en una m√©trica, por lo que si tiene alguna lista mostrada, debe seleccionar puntos de interrupci√≥n y separar a√∫n m√°s la m√©trica. <br><br><br><h2>  Memoria y consumo de tr√°fico </h2>  <b>Comencemos con la memoria</b> .  Y aqu√≠ estamos esperando una gran decepci√≥n.  Por el momento solo hay memoria no estandarizada (solo Chrome) performance, que da n√∫meros rid√≠culamente bajos.  Pero a√∫n deben medirse y observar c√≥mo la aplicaci√≥n "fluye" con el tiempo: <div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/985/6f9/3f0/9856f93f0823ac906bd1938f2cf1f11c.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/983/1bf/437/9831bf437924eb2ecf577f897d934e45.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/c08/e33/577/c08e335770d4fa05b70d8d653ae1b38f.png"></td></tr></tbody></table></div>  <i>Un ejemplo de la extensi√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">memoria</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@ perf-tools / keeper</a></i> <br><br>  <b>Tr√°fico</b>  Para contar el tr√°fico, necesitar√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Timing-Allow-Origin</a> (si los recursos se encuentran en un dominio separado) y la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API de sincronizaci√≥n de recursos</a> , esto ayudar√° no solo a calcular el tr√°fico, sino tambi√©n a detallarlo: <br><br><ul><li>  qu√© protocolo se utiliza (HTTP / 1, HTTP / 2, etc.); </li><li>  tipos de recursos cargados; </li><li>  cu√°nto tiempo llev√≥ descargarlos; </li><li>  tama√±o, adem√°s, puede comprender si el recurso se carga en la red o se toma del cach√©. </li></ul><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/c65/c03/c66/c65c03c660ea8d6bb70ee6597d643245.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/aa3/ba4/973/aa3ba4973933bebafe516ed63e779700.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/35a/a87/d0d/35aa87d0d53ca31ea88ad249bacd057a.png"></td></tr></tbody></table></div>  <i>Un ejemplo de la extensi√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recursos</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  ¬øQu√© da cuenta del tr√°fico? <br><br><ul><li>  Lo m√°s importante es que le permite ver la imagen real, y no como es habitual con CSS + JS y m√°s all√° de eso, c√≥mo esta "imagen" cambia con el tiempo. </li><li>  Luego puede analizar qu√© se carga exactamente, dividir los recursos en grupos, etc. </li><li>  Qu√© tan bien funciona el almacenamiento en cach√© para usted. </li><li>  ¬øHay alguna anomal√≠a, por ejemplo, despu√©s de 15 minutos de operaci√≥n, por ejemplo, el c√≥digo entr√≥ en recursi√≥n y carga algunos recursos sin cesar, monitorear el tr√°fico ayudar√° en esto? </li></ul><br>  Bueno, un informe de actualizaci√≥n de mi colega <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Igor Druzhinin</a> sobre este tema: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Evaluar la calidad de la aplicaci√≥n - monitorear el consumo de tr√°fico</a> <br><br><br><h2>  Anal√≠tica </h2>  Configuramos las m√©tricas, ¬øy luego qu√©?  Y luego necesitan ser enviados a alguna parte.  Y aqu√≠, ya sea que recoja algo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">grafito de usted</a> o, para empezar, puede usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Google Analytics</a> o similar para la agregaci√≥n de datos para beneficio personal. <br><br>  Y no olvide, no es suficiente obtener un gr√°fico, para todas las m√©tricas importantes debe haber percentiles que le permitan comprender, por ejemplo, qu√© porcentaje de la audiencia est√° cargando el proyecto para &lt;1s, &lt;2s, &lt;3s, &lt;5s, 5s +, etc. <br><br><br><h2>  Escribir un c√≥digo de alto rendimiento </h2>  Al principio quer√≠a escribir algo significativo aqu√≠, dicen que use WebWorker, no olvide <code>requestIdleCallback</code> o algo ex√≥tico, por ejemplo, a trav√©s de Runtime Cache a trav√©s de las pesta√±as del navegador con SharedWorker o ServiceWorker (que no es solo sobre el almacenamiento en cach√©, si es que).  Pero todo esto es muy abstracto y muchos temas son imposibles, as√≠ que solo escribe lo siguiente: <br><br><ol><li>  Inicialmente cubra su c√≥digo con m√©tricas que medir√°n su rendimiento. </li><li>  No creas los puntos de referencia con jsperf.  La gran mayor√≠a de ellos est√°n mal escritos y simplemente fuera de contexto.  El mejor punto de referencia es la m√©trica real del proyecto, seg√∫n la cual ver√° el efecto de sus acciones. </li><li>  Recuerde sobre la percepci√≥n de productividad, o m√°s bien la Ley Weber-Fechner.  Es decir, si comenz√≥ la optimizaci√≥n, no despliegue los cambios hasta que mejore al menos en un 20%, de lo contrario, los usuarios simplemente no lo notar√°n.  La ley tambi√©n funciona en la direcci√≥n opuesta. </li><li>  Los asiduos del miedo, especialmente los generados.  No solo pueden colgar el navegador, sino tambi√©n obtener XSS, por lo que en nuestro correo est√° prohibido analizar HTML us√°ndolos, solo a trav√©s de un bypass DOM. </li><li>  No necesita usar matrices para ingresar un valor en uno u otro grupo, para esto hay un <code>object</code> o <code>Set</code> (por ejemplo, <code>successSteps.includes(currentStep)</code> necesario en <code>successSteps.hasOwnProperty(currentStep)</code> ), O (1) es todo. </li><li>  La expresi√≥n "La optimizaci√≥n prematura es la ra√≠z de todos los males" no se trata de escribir lo que quieras.  Si sabes la mejor manera, escribe de manera √≥ptima. </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">Escribir√© un par de p√°rrafos sobre el c√≥digo y su optimizaci√≥n.</b> <div class="spoiler_text">  <b>DOM</b>  Muy a menudo escucho "El problema en el DOM"; esto, por supuesto, es cierto, pero dado que casi todos ahora tienen una abstracci√≥n al respecto.  Es ella quien se convierte en el cuello de botella, o m√°s bien su c√≥digo, que es responsable de la formaci√≥n de la vista y la l√≥gica empresarial. <br><br>  Pero si hablamos del DOM, por ejemplo, en lugar de eliminar un fragmento del DOM, es mejor ocultarlo o quitarlo.  Si a√∫n necesita eliminar, realice esta operaci√≥n en <code>requestIdleCallback</code> (si es posible), o divida el proceso de destrucci√≥n en dos fases: s√≠ncrona y as√≠ncrona. <br><br>  Har√© una reserva de inmediato, use este enfoque con prudencia, de lo contrario puede dispararle a la rodilla. <br><br>  Tambi√©n utilizamos otra t√©cnica interesante en las listas, por ejemplo, la "Lista de hilos".  La esencia de la t√©cnica es que, en lugar de una "Lista" global y actualizar sus datos, generamos una "Lista de subprocesos" para cada "Carpeta".  Como resultado, cuando el usuario navega entre las "Carpetas", una lista se elimina del DOM (no se elimina) y la otra se actualiza parcial o totalmente.  Y no todo, como es el caso de la "Lista √önica". <br><br>  Todo esto da una respuesta instant√°nea a las acciones del usuario. <br><br>  <b>Matem√°ticas</b>  Eliminamos f√°cilmente todas las matem√°ticas en Worker o WebAssembly, esto ha estado funcionando durante mucho tiempo. <br><br>  <b>Transpilers</b> .  Oh, muchos ni siquiera piensan que el c√≥digo que escriben pasa por el transpilador.  S√≠, ellos saben de √©l, pero eso es todo.  Pero en qu√© se convierte ya no les importa.  De hecho, en DevTools ven el resultado del mapa fuente. <br><br>  Por lo tanto, estudie las herramientas que usa, por ejemplo, la misma babel en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">patio de recreo</a> tiene la oportunidad de ver en qu√© genera el c√≥digo dependiendo de los ajustes preestablecidos seleccionados, solo mire el mismo <code>yeild</code> , <code>await</code> o no. <br><br>  <b>Las sutilezas de la lengua</b> .  Incluso menos personas saben sobre el monomorfismo del c√≥digo, o cursi por qu√© el enlace es lento y ... ¬°finalmente usas <code>handleEvent</code> ! <br><br>  <b>Datos y prekreshing</b> .  Menos solicitudes, m√°s almacenamiento en cach√©.  Adem√°s, muy a menudo usamos la t√©cnica de "previsi√≥n", esto es cuando en el fondo cargamos datos.  Por ejemplo, despu√©s de representar la "Lista de hilos", comenzamos a cargar N hilos no le√≠dos en la "Carpeta" actual, de modo que cuando hace clic en ellos, el usuario cambia inmediatamente a "Leer" en lugar de otro "cargador".  Utilizamos una t√©cnica similar no solo para datos, sino tambi√©n para JS.  Por ejemplo, "Escribir una carta" es un gran paquete (debido al editor), y no todas las personas escriben cartas a la vez, por lo que lo cargamos en segundo plano, despu√©s de que se inicializa la aplicaci√≥n. <br><br>  <b>Louders</b>  No s√© por qu√©, pero no vi art√≠culos que ense√±en c√≥mo no hacer un cargador, sino que hice una presentaci√≥n del "futuro" React, en el que se dedic√≥ mucho tiempo a este problema en el marco de Suspenso.  Pero, despu√©s de todo, la aplicaci√≥n ideal es sin cargadores, hemos estado tratando durante mucho tiempo en el Correo para mostrarla solo en situaciones de emergencia. <br><br>  En general, tenemos una pol√≠tica de este tipo, no hay datos, no hay vista, no hay nada para dibujar una semi-interfaz, primero cargamos los datos y solo luego "dibujamos".  Es por eso que usamos la "previsi√≥n" de d√≥nde ir√° el usuario y cargamos estos datos para que el usuario no vea el cargador.  Adem√°s, nuestra capa de datos, que es persistente, ayuda mucho en esta tarea.  Si solicit√≥ "Thread" en alg√∫n lugar de un lugar, la pr√≥xima vez que solicite desde otro o el mismo lugar, no habr√° ninguna solicitud, tomaremos datos de Runtime Cache (m√°s precisamente, un enlace a los datos).  Y as√≠, en todo, las colecciones de hilos tambi√©n son solo enlaces a datos. <br><br>  Pero si a√∫n decide hacer un cargador, no olvide las reglas b√°sicas que har√°n que su cargador sea menos molesto: <ul><li>  no es necesario mostrar el cargador de inmediato, al momento de enviar la solicitud, debe haber un retraso de al menos 300-500 ms antes del espect√°culo; </li><li>  Despu√©s de recibir los datos, no necesita eliminar bruscamente el cargador, aqu√≠ nuevamente deber√≠a haber un retraso. </li></ul><br>  Estas reglas simples son necesarias para que el cargador aparezca solo en solicitudes pesadas y no "parpadee" al finalizar.  Pero lo m√°s importante, el mejor cargador es un cargador que no apareci√≥. </div></div><br><br>  Gracias por su atenci√≥n, eso es todo, medir, analizar y usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PerfKeeper</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplo en vivo</a> ), as√≠ como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi github</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">twitter</a> , en caso de preguntas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/454920/">https://habr.com/ru/post/454920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454904/index.html">Samsung lanza curso gratuito en l√≠nea de red neuronal de visi√≥n por computadora</a></li>
<li><a href="../454912/index.html">La fortaleza enana Tarn Adams habla sobre el desarrollo del juego</a></li>
<li><a href="../454914/index.html">Usamos Yii2. Estamos escribiendo otro CMS o un intento de acelerar significativamente el desarrollo con una sobrecarga m√≠nima</a></li>
<li><a href="../454916/index.html">Arquitectura de red neuronal para implementar el algoritmo RL con la capacidad de establecer acciones simult√°neas</a></li>
<li><a href="../454918/index.html">C√≥mo combinar los respaldos de dos minoristas en SAP en 12 horas</a></li>
<li><a href="../454922/index.html">Historias sobre clientes extranjeros y sus caracter√≠sticas de trabajo en Rusia despu√©s de la Ley de DP</a></li>
<li><a href="../454924/index.html">Configuraci√≥n de autenticaci√≥n en Veeam Backup para Microsoft Office 365 v3</a></li>
<li><a href="../454926/index.html">Todo lo que sab√≠as sobre word2vec no es cierto</a></li>
<li><a href="../454930/index.html">Recolecci√≥n de basura en V8: como funciona el nuevo Orinoco GC</a></li>
<li><a href="../454932/index.html">Inversiones y software: 5 terminales comerciales para operar en bolsa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>