<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔔 👩🏻‍🎓 📇 Ulasan keras untuk TensorFlow 🏗️ 🧑🏽 🎛️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terjemahan panduan ikhtisar dari Tensorflow.org. Panduan ini akan memberi Anda dasar-dasar untuk memulai dengan Keras. Membaca membutuhkan waktu 10 me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ulasan keras untuk TensorFlow</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482126/"><img src="https://habrastorage.org/webt/wz/o5/gm/wzo5gmjyybfdr1ea_lwtrhsjzvw.jpeg"><br><br>  Terjemahan panduan ikhtisar dari Tensorflow.org.  Panduan ini akan memberi Anda dasar-dasar untuk memulai dengan Keras.  Membaca membutuhkan waktu 10 menit. <br><a name="habracut"></a><br><h2>  Impor tf.keras </h2><br>  <code>tf.keras</code> adalah implementasi dari spesifikasi TensorFlow Keras API.  Ini adalah API tingkat tinggi untuk model pengembangan dan pelatihan yang mencakup dukungan kelas satu untuk fungsionalitas spesifik TensorFlow seperti <i>eksekusi yang cepat</i> , jaringan pipa <code>tf.data</code> , dan <i>Estimator</i> .  <code>tf.keras</code> mempermudah penggunaan TensorFlow tanpa mengorbankan fleksibilitas dan kinerja. <br><br>  Untuk memulai, impor <code>tf.keras</code> sebagai bagian dari pengaturan TensorFlow Anda: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> absolute_import, division, print_function, unicode_literals <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tf <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> keras</code> </pre> <br>  <code>tf.keras</code> dapat menjalankan kode Keras-kompatibel apa pun, tetapi perlu diingat: <br><br><ul><li>  Versi <code>tf.keras</code> dalam rilis TensorFlow terbaru mungkin berbeda dari versi <code>keras</code> terbaru di PyPI.  Lihat <code>tf.keras.__version__</code> . </li><li>  Saat Anda menyimpan bobot model, <code>tf.keras</code> melakukan ini secara default dalam format pos pemeriksaan.  Lewati <code>save_format='h5'</code> untuk menggunakan HDF5 (atau tambahkan ekstensi <code>.h5</code> ke <code>.h5</code> file). </li></ul><br><h2>  Bangun model yang sederhana </h2><br><h3>  Model berurutan </h3><br>  Di Keras, Anda mengumpulkan <i>lapisan</i> untuk membangun <i>model</i> .  Model adalah grafik layer (biasanya).  Jenis model yang paling umum adalah lapisan tumpukan: <code>tf.keras.Sequential</code> . Model yang sama. <br><br>  Kami membangun jaringan yang sepenuhnya terhubung sederhana (mis., Multilayer perceptron): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tensorflow.keras <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> layers model = tf.keras.Sequential() <span class="hljs-comment"><span class="hljs-comment">#       64 : model.add(layers.Dense(64, activation='relu')) #   : model.add(layers.Dense(64, activation='relu')) #   softmax  10 : model.add(layers.Dense(10, activation='softmax'))</span></span></code> </pre> <br><h3>  Kustomisasi layer </h3><br>  Banyak varietas lapisan <code>tf.keras.layers</code> .  Sebagian besar dari mereka menggunakan konstruktor argumen umum: <br><br><ul><li>  <code>activation</code> : Mengatur fungsi aktivasi untuk layer.  Parameter ini menentukan nama fungsi bawaan atau objek yang dipanggil.  Parameter tidak memiliki nilai default. </li><li>  <code>kernel_initializer</code> dan <code>bias_initializer</code> : Skema inisialisasi yang membuat bobot lapisan (inti dan shift).  Parameter ini bisa berupa nama atau objek yang dipanggil.  <code>"Glorot uniform"</code> default adalah <code>"Glorot uniform"</code> . </li><li>  <code>kernel_regularizer</code> dan <code>bias_regularizer</code> : Skema <code>bias_regularizer</code> ditambahkan ke bobot layer (core dan shift), seperti regularisasi L1 atau L2.  Secara default, regularisasi tidak diatur. </li></ul><br>  Contoh instance dari lapisan `tf.keras.layers.Dense` menggunakan argumen konstruktor: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    : layers.Dense(64, activation='sigmoid') # : layers.Dense(64, activation=tf.keras.activations.sigmoid) #     L1   0.01    : layers.Dense(64, kernel_regularizer=tf.keras.regularizers.l1(0.01)) #     L2   0.01    : layers.Dense(64, bias_regularizer=tf.keras.regularizers.l2(0.01)) #        : layers.Dense(64, kernel_initializer='orthogonal') #        2.0: layers.Dense(64, bias_initializer=tf.keras.initializers.Constant(2.0))</span></span></code> </pre> <br><h2>  Pelatihan dan penilaian </h2><br><h3>  Pengaturan pelatihan </h3><br>  Setelah model dibangun, konfigurasikan proses pembelajaran dengan memanggil metode <code>compile</code> : <br><br><pre> <code class="python hljs">model = tf.keras.Sequential([ <span class="hljs-comment"><span class="hljs-comment">#     64   : layers.Dense(64, activation='relu', input_shape=(32,)), #  : layers.Dense(64, activation='relu'), #   softmax  10 : layers.Dense(10, activation='softmax')]) model.compile(optimizer=tf.keras.optimizers.Adam(0.01), loss='categorical_crossentropy', metrics=['accuracy'])</span></span></code> </pre> <br>  <code>tf.keras.Model.compile</code> menerima tiga argumen penting: <br><br><ul><li>  <code>optimizer</code> : Objek ini mendefinisikan prosedur pelatihan.  Lewati instance optimizer dari modul <code>tf.keras.optimizers</code> , seperti <code>tf.keras.optimizers.Adam</code> atau <code>tf.keras.optimizers.SGD</code> .  Jika Anda hanya ingin menggunakan opsi default, Anda juga dapat menentukan pengoptimal dengan kata kunci seperti <code>'adam'</code> atau <code>'sgd'</code> . </li><li>  <code>loss</code> : Ini adalah fungsi yang diminimalkan dalam proses pembelajaran.  Di antara variasi umum adalah kesalahan standar ( <code>mse</code> ), <code>categorical_crossentropy</code> , <code>binary_crossentropy</code> .  Fungsi kerugian ditentukan berdasarkan nama atau dengan melewatkan objek yang dipanggil dari modul <code>tf.keras.losses</code> . </li><li>  <code>metrics</code> : Digunakan untuk memantau pelatihan.  Ini adalah nama string atau objek yang dipanggil dari modul <code>tf.keras.metrics</code> . </li><li>  Selain itu, untuk memastikan bahwa model dilatih dan dievaluasi dengan penuh semangat, periksa apakah Anda memberikan parameter <code>run_eagerly=True</code> ke kompiler </li></ul><br>  Selanjutnya, kita akan melihat beberapa contoh konfigurasi model untuk pelatihan: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       . model.compile(optimizer=tf.keras.optimizers.Adam(0.01), loss='mse', # mean squared error metrics=['mae']) # mean absolute error #     . model.compile(optimizer=tf.keras.optimizers.RMSprop(0.01), loss=tf.keras.losses.CategoricalCrossentropy(), metrics=[tf.keras.metrics.CategoricalAccuracy()])</span></span></code> </pre> <br><h3>  Belajar dari NumPy Data </h3><br>  Untuk kumpulan data yang lebih kecil, gunakan array memori NumPy untuk melatih dan mengevaluasi model.  Model ini "terlatih" tentang data pelatihan menggunakan metode `fit`: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np data = np.random.random((<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>)) labels = np.random.random((<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) model.fit(data, labels, epochs=<span class="hljs-number"><span class="hljs-number">10</span></span>, batch_size=<span class="hljs-number"><span class="hljs-number">32</span></span>)</code> </pre> <br>  <code>tf.keras.Model.fit</code> mengambil tiga argumen penting: <br><br><ul><li>  <code>epochs</code> : Belajar dipecah menjadi * zaman *.  Era adalah satu iterasi atas semua data input (ini dilakukan dalam batch kecil). </li><li>  <code>batch_size</code> : Saat mentransmisikan data NumPy, model memecah data menjadi blok yang lebih kecil (batch) dan beralih ke blok ini selama pelatihan.  Angka ini menunjukkan ukuran setiap blok data.  Ingat bahwa blok terakhir mungkin lebih kecil jika jumlah total catatan tidak dibagi dengan ukuran kumpulan. </li><li>  <code>validation_data</code> : Saat membuat prototipe model, Anda ingin melacak kinerjanya dengan mudah pada data validasi.  Melewati tuple input data dan label dengan argumen ini memungkinkan model untuk menampilkan nilai-nilai dari fungsi yang hilang dan metrik dalam mode output untuk data yang dikirim pada akhir setiap era. </li></ul><br>  Berikut ini contoh menggunakan <code>validation_data</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np data = np.random.random((<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>)) labels = np.random.random((<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) val_data = np.random.random((<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>)) val_labels = np.random.random((<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) model.fit(data, labels, epochs=<span class="hljs-number"><span class="hljs-number">10</span></span>, batch_size=<span class="hljs-number"><span class="hljs-number">32</span></span>, validation_data=(val_data, val_labels))</code> </pre> <br><h3>  Pelatihan menggunakan dataset tf.data </h3><br>  Gunakan API Kumpulan Data untuk skala database besar atau pelatihan di beberapa perangkat.  Lewati instance dari `tf.data.Dataset` ke metode <code>fit</code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    : dataset = tf.data.Dataset.from_tensor_slices((data, labels)) dataset = dataset.batch(32) model.fit(dataset, epochs=10)</span></span></code> </pre> <br>  Karena <code>Dataset</code> menyediakan data dalam batch, kode ini tidak memerlukan argumen <code>batch_size</code> . <br><br>  Kumpulan data juga dapat digunakan untuk memvalidasi: <br><br><pre> <code class="python hljs">dataset = tf.data.Dataset.from_tensor_slices((data, labels)) dataset = dataset.batch(<span class="hljs-number"><span class="hljs-number">32</span></span>) val_dataset = tf.data.Dataset.from_tensor_slices((val_data, val_labels)) val_dataset = val_dataset.batch(<span class="hljs-number"><span class="hljs-number">32</span></span>) model.fit(dataset, epochs=<span class="hljs-number"><span class="hljs-number">10</span></span>, validation_data=val_dataset)</code> </pre> <br><h3>  Penilaian dan prediksi </h3><br>  Metode <code>tf.keras.Model.evaluate</code> dan <code>tf.keras.Model.predict</code> dapat menggunakan data NumPy dan <code>tf.data.Dataset</code> . <br><br>  Ini adalah bagaimana Anda dapat <i>memperkirakan</i> kerugian dalam mode keluaran dan metrik untuk data yang disediakan: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   Numpy data = np.random.random((1000, 32)) labels = np.random.random((1000, 10)) model.evaluate(data, labels, batch_size=32) #   dataset = tf.data.Dataset.from_tensor_slices((data, labels)) dataset = dataset.batch(32) model.evaluate(dataset)</span></span></code> </pre> <br>  Dan di sini adalah bagaimana <i>memprediksi</i> output level terakhir dalam mode output untuk data yang disediakan dalam bentuk array NumPy: <br><br><h2>  Membangun model yang kompleks </h2><br><h3>  API Fungsional </h3><br>  Model <code>tf.keras.Sequential</code> adalah tumpukan lapisan sederhana yang Anda tidak dapat membayangkan model yang sewenang-wenang.  Gunakan API fungsional Keras untuk membangun topologi model yang kompleks, seperti: <br><br><ul><li>  Model Input Berganda </li><li>  Model dengan banyak keluaran, </li><li>  Model dengan lapisan umum (lapisan yang sama disebut beberapa kali), </li><li>  Model dengan aliran data yang tidak konsisten (mis., Hubungan residual). </li></ul><br>  Membangun model dengan API fungsional berfungsi sebagai berikut: <br><br><ol><li>  Contoh layer dapat dipanggil dan mengembalikan tensor. </li><li>  Input dan output tensor digunakan untuk menentukan instance dari <code>tf.keras.Model</code> </li><li>  Model ini dilatih seperti model `Sequential`. </li></ol><br>  Contoh berikut menggunakan API fungsional untuk membangun jaringan yang sederhana dan terhubung sepenuhnya: <br><br><pre> <code class="python hljs">inputs = tf.keras.Input(shape=(<span class="hljs-number"><span class="hljs-number">32</span></span>,)) <span class="hljs-comment"><span class="hljs-comment">#    #        . x = layers.Dense(64, activation='relu')(inputs) x = layers.Dense(64, activation='relu')(x) predictions = layers.Dense(10, activation='softmax')(x)</span></span></code> </pre> <br>  Buat instance model dengan input dan output ini. <br><br><pre> <code class="python hljs">model = tf.keras.Model(inputs=inputs, outputs=predictions) <span class="hljs-comment"><span class="hljs-comment">#     . model.compile(optimizer=tf.keras.optimizers.RMSprop(0.001), loss='categorical_crossentropy', metrics=['accuracy']) #   5  model.fit(data, labels, batch_size=32, epochs=5)</span></span></code> </pre> <br><h3>  Model Subklasifikasi </h3><br>  Buat model yang sepenuhnya dapat disesuaikan menggunakan subclassing <code>tf.keras.Model</code> dan <code>tf.keras.Model</code> distribusi langsung Anda sendiri.  Buat layer dalam metode <code>__init__</code> dan atur sebagai atribut dari instance kelas.  Tetapkan propagasi langsung dalam metode <code>call</code> . <br><br>  Subkelas model sangat berguna ketika eksekusi yang diinginkan diaktifkan, karena memungkinkan Anda untuk menulis distribusi langsung secara imperatif. <br><br>  Catatan: jika Anda ingin model Anda <i>selalu</i> dieksekusi secara imperatif, Anda dapat mengatur <code>dynamic=True</code> ketika Anda memanggil <code>super</code> constructor. <br><blockquote>  Poin kunci: Gunakan API yang benar untuk bekerja.  Meskipun subklas model memberikan fleksibilitas, Anda harus membayarnya dengan kompleksitas yang lebih besar dan potensi kesalahan kustom yang lebih besar.  Jika memungkinkan, pilih API fungsional. </blockquote>  Contoh berikut menunjukkan model tf.keras.Model subclass menggunakan distribusi langsung kustom, yang tidak diharuskan imperatif: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModel</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(tf.keras.Model)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, num_classes=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> super(MyModel, self).__init__(name=<span class="hljs-string"><span class="hljs-string">'my_model'</span></span>) self.num_classes = num_classes <span class="hljs-comment"><span class="hljs-comment">#    . self.dense_1 = layers.Dense(32, activation='relu') self.dense_2 = layers.Dense(num_classes, activation='sigmoid') def call(self, inputs): #     , #      ( `__init__`). x = self.dense_1(inputs) return self.dense_2(x)</span></span></code> </pre> <br>  Buat instance dari kelas model baru: <br><br><pre> <code class="python hljs">model = MyModel(num_classes=<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-comment"><span class="hljs-comment">#     . model.compile(optimizer=tf.keras.optimizers.RMSprop(0.001), loss='categorical_crossentropy', metrics=['accuracy']) #   5 . model.fit(data, labels, batch_size=32, epochs=5)</span></span></code> </pre> <br><h3>  Lapisan khusus </h3><br>  Buat layer kustom dengan <code>tf.keras.layers.Layer</code> dan mengimplementasikan metode berikut: <br><br><ul><li>  <code>__init__</code> : Secara opsional tentukan sublayers yang akan digunakan dalam lapisan ini. </li><li>  * <code>build</code> : Buat layer weight.  Tambahkan bobot menggunakan metode <code>add_weight</code> </li><li>  <code>call</code> : Tentukan distribusi langsung. </li><li>  Secara opsional, layer dapat diserialisasi dengan menerapkan metode <code>get_config</code> dan metode <code>from_config</code> . </li></ul><br>  Di bawah ini adalah contoh dari lapisan pengguna yang mengalikan matriks ( <code>matmul</code> ) diumpankan ke input dengan matriks kernel: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyLayer</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(layers.Layer)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, output_dim, **kwargs)</span></span></span><span class="hljs-function">:</span></span> self.output_dim = output_dim super(MyLayer, self).__init__(**kwargs) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, input_shape)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#       . self.kernel = self.add_weight(name='kernel', shape=(input_shape[1], self.output_dim), initializer='uniform', trainable=True) def call(self, inputs): return tf.matmul(inputs, self.kernel) def get_config(self): base_config = super(MyLayer, self).get_config() base_config['output_dim'] = self.output_dim return base_config @classmethod def from_config(cls, config): return cls(**config)</span></span></code> </pre><br>  Buat model menggunakan lapisan khusus Anda: <br><br><pre> <code class="python hljs">model = tf.keras.Sequential([ MyLayer(<span class="hljs-number"><span class="hljs-number">10</span></span>), layers.Activation(<span class="hljs-string"><span class="hljs-string">'softmax'</span></span>)]) <span class="hljs-comment"><span class="hljs-comment">#      model.compile(optimizer=tf.keras.optimizers.RMSprop(0.001), loss='categorical_crossentropy', metrics=['accuracy']) #   5 . model.fit(data, labels, batch_size=32, epochs=5)</span></span></code> </pre> <br><h2>  Kolbeki </h2><br>  Kolbek adalah objek yang ditransfer ke model untuk menyesuaikan dan memperluas perilakunya selama pelatihan.  Anda dapat menulis panggilan balik sendiri atau menggunakan <code>tf.keras.callbacks</code> yang meliputi: <br><br>  <code>tf.keras.callbacks.ModelCheckpoint</code> : Menyimpan breakpoints model secara berkala. <br>  <code>tf.keras.callbacks.LearningRateScheduler</code> : Secara dinamis mengubah langkah pembelajaran. <br>  <code>tf.keras.callbacks.EarlyStopping</code> : Menghentikan pelatihan saat hasil validasi berhenti membaik. <br>  <code>tf.keras.callbacks.TensorBoard:</code> Memantau Penggunaan Model Perilaku <br>  Papan tarik <br><br>  Untuk menggunakan <code>tf.keras.callbacks.Callback</code> , berikan kepada metode model <code>fit</code> : <br><br><pre> <code class="python hljs">callbacks = [ <span class="hljs-comment"><span class="hljs-comment">#    `val_loss`     2  tf.keras.callbacks.EarlyStopping(patience=2, monitor='val_loss'), #   TensorBoard   `./logs` directory tf.keras.callbacks.TensorBoard(log_dir='./logs') ] model.fit(data, labels, batch_size=32, epochs=5, callbacks=callbacks, validation_data=(val_data, val_labels))</span></span></code> </pre> <br><h2>  Menyimpan dan Memulihkan </h2><br><h3>  Hanya menyimpan nilai bobot </h3><br>  Simpan dan muat bobot model menggunakan <code>tf.keras.Model.save_weights</code> : <br><br><pre> <code class="python hljs">model = tf.keras.Sequential([ layers.Dense(<span class="hljs-number"><span class="hljs-number">64</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>, input_shape=(<span class="hljs-number"><span class="hljs-number">32</span></span>,)), layers.Dense(<span class="hljs-number"><span class="hljs-number">10</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'softmax'</span></span>)]) model.compile(optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.001</span></span>), loss=<span class="hljs-string"><span class="hljs-string">'categorical_crossentropy'</span></span>, metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span></span>])</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     TensorFlow Checkpoint model.save_weights('./weights/my_model') #    #        . model.load_weights('./weights/my_model')</span></span></code> </pre> <br>  Secara default, bobot model disimpan dalam format pos pemeriksaan TensorFlow.  Berat juga dapat disimpan dalam format Keras HDF5 (nilai default untuk implementasi universal Keras): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     HDF5 model.save_weights('my_model.h5', save_format='h5') #    model.load_weights('my_model.h5')</span></span></code> </pre> <br><h3>  Menyimpan hanya konfigurasi model </h3><br>  Konfigurasi model dapat disimpan - ini membuat serialisasi arsitektur model tanpa bobot.  Konfigurasi yang disimpan dapat memulihkan dan menginisialisasi model yang sama, bahkan tanpa kode yang menentukan model aslinya.  Keras mendukung format serialisasi JSON dan YAML: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     JSON json_string = model.to_json() json_string</span></span></code> </pre> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pprint pprint.pprint(json.loads(json_string))</code> </pre> <br>  Memulihkan model (diinisialisasi ulang) dari JSON: <br><br><pre> <code class="python hljs">fresh_model = tf.keras.models.model_from_json(json_string)</code> </pre><br>  Serializing model ke YAML memerlukan instalasi `pyyaml` <i>sebelum mengimpor TensorFlow</i> : <br><br><pre> <code class="python hljs">yaml_string = model.to_yaml() print(yaml_string)</code> </pre> <br>  Memulihkan model dari YAML: <br><br><pre> <code class="python hljs">fresh_model = tf.keras.models.model_from_yaml(yaml_string)</code> </pre> <br><blockquote>  Catatan: model subclass tidak berseri, karena arsitekturnya ditentukan oleh kode Python di tubuh metode `call`. </blockquote><br><h3>  Menyimpan seluruh model dalam satu file </h3><br>  Seluruh model dapat disimpan ke file yang berisi nilai bobot, konfigurasi model, dan bahkan konfigurasi pengoptimal.  Ini akan memungkinkan Anda untuk mengatur breakpoint model dan melanjutkan pelatihan nanti dari posisi yang persis sama bahkan tanpa akses ke kode sumber. <br><br><pre> <code class="plaintext hljs">#    model = tf.keras.Sequential([ layers.Dense(10, activation='softmax', input_shape=(32,)), layers.Dense(10, activation='softmax') ]) model.compile(optimizer='rmsprop', loss='categorical_crossentropy', metrics=['accuracy']) model.fit(data, labels, batch_size=32, epochs=5) #      HDF5 model.save('my_model.h5') #         . model = tf.keras.models.load_model('my_model.h5')</code> </pre> <br><h2>  Eksekusi yang bersemangat </h2><br>  Eksekusi yang cepat adalah lingkungan pemrograman yang sangat penting yang segera menjalankan operasi.  Ini tidak diperlukan untuk Keras, tetapi didukung oleh <code>tf.keras</code> dan berguna untuk memeriksa program dan debugging Anda. <br><br>  Semua model pembangunan API `tf.keras` kompatibel dengan eksekusi yang cepat.  Meskipun `Sequential` dan API fungsional dapat digunakan, eksekusi yang cepat sangat berguna ketika <i>mensubklasifikasikan model</i> dan membangun <i>lapisan khusus</i> - API ini mengharuskan Anda untuk menulis distribusi langsung dalam bentuk kode (alih-alih API yang membuat model dengan merakit lapisan yang ada). <br><br><h2>  Distribusi </h2><br><h3>  Banyak GPU </h3><br>  model <code>tf.keras</code> dapat dijalankan pada banyak GPU menggunakan <code>tf.distribute.Strategy</code> .  API ini menyediakan pembelajaran terdistribusi di beberapa GPU dengan sedikit atau tanpa perubahan kode yang ada. <br><br>  Saat ini, <code>tf.distribute.MirroredStrategy</code> satu <code>tf.distribute.MirroredStrategy</code> satunya strategi distribusi yang didukung.  <code>MirroredStrategy</code> mereplikasi grafik dengan <br>  pembelajaran sinkron menggunakan semua-mengurangi pada satu mesin.  Untuk menggunakan ` <code>distribute.Strategy</code> , <code>.scope()</code> instalasi pengoptimal, desain, dan kompilasi model <code>.scope()</code> <code>Strategy</code> <code>.scope()</code> `, lalu latih model tersebut. <br><br>  Contoh berikut mendistribusikan <code>tf.keras.Model</code> antara beberapa GPU pada mesin yang sama. <br><br>  Pertama, kami mendefinisikan model dalam area strategi terdistribusi: <br><br><pre> <code class="python hljs">strategy = tf.distribute.MirroredStrategy() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> strategy.scope(): model = tf.keras.Sequential() model.add(layers.Dense(<span class="hljs-number"><span class="hljs-number">16</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>, input_shape=(<span class="hljs-number"><span class="hljs-number">10</span></span>,))) model.add(layers.Dense(<span class="hljs-number"><span class="hljs-number">1</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'sigmoid'</span></span>)) optimizer = tf.keras.optimizers.SGD(<span class="hljs-number"><span class="hljs-number">0.2</span></span>) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'binary_crossentropy'</span></span>, optimizer=optimizer) model.summary()</code> </pre> <br>  Kemudian kami melatih model pada data seperti biasa: <br><br><pre> <code class="python hljs">x = np.random.random((<span class="hljs-number"><span class="hljs-number">1024</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) y = np.random.randint(<span class="hljs-number"><span class="hljs-number">2</span></span>, size=(<span class="hljs-number"><span class="hljs-number">1024</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) x = tf.cast(x, tf.float32) dataset = tf.data.Dataset.from_tensor_slices((x, y)) dataset = dataset.shuffle(buffer_size=<span class="hljs-number"><span class="hljs-number">1024</span></span>).batch(<span class="hljs-number"><span class="hljs-number">32</span></span>) model.fit(dataset, epochs=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  <i>Setelah verifikasi, terjemahan juga akan muncul di Tensorflow.org.</i>  <i>Jika Anda ingin berpartisipasi dalam terjemahan dokumentasi situs web Tensorflow.org ke dalam bahasa Rusia, silakan hubungi secara pribadi atau komentar.</i>  <i>Setiap koreksi atau komentar sangat dihargai.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482126/">https://habr.com/ru/post/id482126/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482102/index.html">Habr T&J 2019: hasil tahun ini</a></li>
<li><a href="../id482104/index.html">Bagaimana menghadapi kebiasaan orang yang diprogram</a></li>
<li><a href="../id482108/index.html">Kecerdasan yang tenang. Metode untuk mengidentifikasi potensi kerentanan WEB</a></li>
<li><a href="../id482110/index.html">Linux berjalan di kartu bisnis saya</a></li>
<li><a href="../id482114/index.html">Kirim email menggunakan asyncio dan aiohttp dari aplikasi Django</a></li>
<li><a href="../id482128/index.html">gReebok terdeteksi. Dermatovenerolog sendiri</a></li>
<li><a href="../id482130/index.html">Penugasan skala besar hak untuk pengguna domain dari hutan yang berbeda</a></li>
<li><a href="../id482132/index.html">Salinan Tesla Cybertruck ditemukan di Moskow. Ini adalah ... Rusia LADA Samara</a></li>
<li><a href="../id482134/index.html">Perbandingan hibrida atau apa yang diharapkan pemilik headphone Meze Rumania untuk 84 990 dan 239 990 rubel</a></li>
<li><a href="../id482136/index.html">Bagaimana proyek monobrand bisa masuk ke TOP dengan mengalahkan agregator dan layanan internal mesin pencari?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>