<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕓 ✝️ 🚜 "Alice, ayo pergi ke frontend!" 😁 👨‍🚒 💦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Asisten suara bukan masa depan yang jauh, tetapi kenyataan. Alexa, Siri, Google Now, Alice dibangun menjadi speaker pintar, jam tangan, dan telepon. M...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Alice, ayo pergi ke frontend!"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/468545/">  Asisten suara bukan masa depan yang jauh, tetapi kenyataan.  Alexa, Siri, Google Now, Alice dibangun menjadi speaker pintar, jam tangan, dan telepon.  Mereka secara bertahap mengubah cara kami berinteraksi dengan aplikasi dan perangkat.  Melalui asisten Anda dapat mengetahui ramalan cuaca, membeli tiket pesawat, memesan taksi, mendengarkan musik dan menyalakan ketel di dapur, berbaring di sofa di ruangan lain. <br><br><img src="https://habrastorage.org/webt/mr/sw/35/mrsw35dh1qjeefkk8eb1f1ffvj0.jpeg"><br><br>  Siri atau Alexa sebagian besar berbicara bahasa Inggris kepada pengguna, jadi di Rusia mereka tidak sepopuler Alice dari Yandex.  Untuk pengembang, Alice juga lebih nyaman: penciptanya memiliki blog, memposting alat yang nyaman di GitHub dan membantu membangun asisten di perangkat baru. <br><br>  <b>Nikita Dubko</b> (@dark_mefody di Twitter) adalah pengembang antarmuka Yandex, penyelenggara pertemuan MinskCSS dan MinskJS dan editor berita dalam standar Web.  Nikita tidak bekerja di Yandex.Dialogs dan tidak berafiliasi dengan Yandex.Alisa dengan cara apa pun.  Tetapi dia tertarik untuk memahami bagaimana Alice bekerja, jadi dia mencoba menerapkan keterampilannya untuk Web dan menyiapkan laporan tentang ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FrontendConf</a> RIT ++.  Dalam menguraikan laporan Nikita, kami mempertimbangkan apa yang dapat dibawa oleh asisten suara dan membangun keterampilan yang tepat dalam proses membaca materi ini. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yjTH8-O3CMA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Bot </h2><br>  Mari kita mulai dengan sejarah bot.  Pada tahun 1966, bot <b>Eliza</b> muncul, berpura-pura menjadi seorang terapis.  Itu mungkin untuk berkomunikasi dengannya, dan beberapa bahkan percaya bahwa orang yang hidup menjawab mereka.  Pada 1995, bot <b>ALICE</b> keluar.  - jangan bingung dengan Alice.  Bot mampu menyamar sebagai orang sungguhan.  Sampai hari ini terletak di Open Source dan sedang diselesaikan.  Sayangnya, ALICE tidak lulus dari Tes Turing, tetapi ini tidak menghentikannya untuk menyesatkan orang. <br><br>  Pada tahun 2006, IBM menempatkan basis pengetahuan yang sangat besar dan kecerdasan canggih di bot - begitulah <b>IBM Watson</b> muncul.  Ini adalah cluster komputasi besar yang dapat memproses pidato bahasa Inggris dan memberikan beberapa fakta. <br><br>  Pada 2016, Microsoft melakukan percobaan.  Dia menciptakan bot <b>Tay</b> , yang diluncurkannya di Twitter.  Di sana, bot belajar menggunakan microblog berdasarkan bagaimana pelanggan hidup berinteraksi dengannya.  Akibatnya, Tay menjadi rasis dan misoginis.  Sekarang ini adalah akun tertutup.  Moral: jangan biarkan anak-anak di Twitter, dia bisa mengajar yang buruk. <br><br>  Tapi ini semua bot yang tidak bisa Anda komunikasikan untuk keuntungan Anda sendiri.  Pada 2015, "berguna" muncul di Telegram.  Bot ada di program lain, tetapi Telegram membuat splash.  Dimungkinkan untuk membuat bot yang bermanfaat yang akan memberikan informasi, menghasilkan konten, mengelola publik - kemungkinannya besar, dan APInya sederhana.  Bot telah menambahkan gambar, tombol, tooltips - antarmuka interaksi telah muncul. <br><br>  Secara bertahap, gagasan itu menyebar ke hampir semua pengirim pesan instan: Facebook, Viber, VKontakte, WhatsApp, dan aplikasi lainnya.  Sekarang bot adalah tren, mereka ada di mana-mana.  Ada layanan yang memungkinkan Anda untuk menulis API segera untuk semua platform. <br><br><h2>  Asisten suara </h2><br>  Perkembangan berjalan paralel dengan bot, tetapi kami akan menganggap bahwa era asisten datang kemudian. <br><br>  Pada 9 Agustus 2011, <b>Siri</b> muncul.  Awalnya, itu adalah proyek independen di mana Apple melihat sesuatu yang menarik, jadi saya membelinya.  Ini adalah asisten suara populer tertua yang ada di dalam OS.  Setahun kemudian, Google dengan cepat menyusul Apple dengan mengintegrasikan asisten suara <b>Google Now</b> ke dalam sistem operasinya. <br><br>  Setelah 2 tahun, Microsoft merilis <b>Microsoft Cortana</b> .  Tetapi tidak jelas mengapa - pasar seluler untuk asisten suara, tampaknya, mereka sudah ketinggalan.  Perusahaan mencoba untuk mengintegrasikan asisten suara ke dalam sistem desktop, ketika sudah ada perjuangan untuk pasar perangkat yang berbeda.  <b>Amazon Alexa</b> keluar sedikit kemudian tahun itu. <br><br><img src="https://habrastorage.org/webt/un/cw/eh/uncwehkki7vgcfyeh7148omczd4.jpeg"><br><br>  Asisten telah berevolusi.  Selain sistem perangkat lunak yang tahu cara bekerja dengan suara, speaker muncul dengan asisten.  Menurut statistik, pada awal 2019, setiap keluarga ketiga di Amerika Serikat memiliki kolom yang cerdas.  Ini adalah pasar besar di mana Anda dapat berinvestasi. <br><br>  Tetapi ada masalah - asisten asing memiliki bahasa yang buruk dengan Rusia.  Para asisten dipenjara dalam bahasa Inggris dan memahaminya dengan baik, tetapi ketika berkomunikasi dalam bahasa Rusia, kesulitan penerjemahan muncul.  Bahasa berbeda dan memerlukan pendekatan berbeda untuk pemrosesan bahasa alami. <br><br><h2>  Alice </h2><br>  Alice dirilis dalam versi beta terbuka pada 10 Oktober 2017.  Ini dipenjara karena bahasa Rusia dan ini adalah keuntungan yang sangat besar.  Alice mengerti bahasa Inggris, tetapi lebih buruk. <br><br><blockquote>  Misi Alice adalah untuk membantu pengguna berbahasa Rusia. </blockquote><br>  Yandex adalah perusahaan besar dan mampu menanamkan Alice di semua aplikasi yang entah bagaimana bisa berbicara. <br><br><ul><li>  Yandex.Browser. <br></li><li>  Yandex.Navigator. <br></li><li>  Stasiun Yandex. <br></li><li>  Yandex. Telepon. <br></li><li>  Yandex. Otomatis. <br></li><li>  Yandex. Berkendara. <br></li></ul><br>  Integrasi berjalan sangat baik sehingga produsen pihak ketiga juga memutuskan untuk membangun Alice. <br><br><img src="https://habrastorage.org/webt/tc/na/aa/tcnaaauucjom0ojuvb6jpgdjzge.jpeg"><br><br>  Selama 2 tahun pengembangan asisten, ia diintegrasikan ke dalam banyak layanan dan keterampilan baru ditambahkan.  Dia tahu cara memainkan musik, mengenali gambar, mencari informasi di Yandex dan bekerja dengan rumah pintar. <br><br><h3>  Kenapa begitu populer? </h3><br>  <b>Lebih mudah ketika tangan sibuk</b> .  Saya sedang menyiapkan makan malam dan ingin menyalakan musik.  Pergi ke keran, cuci tangan, keringkan, buka aplikasi, temukan trek yang diinginkan - untuk waktu yang lama.  Lebih cepat dan lebih mudah untuk memberikan perintah suara. <br><br>  <b>Kemalasan</b> .  Saya berbaring di sofa di bawah selimut kotak-kotak dan saya tidak ingin bangun untuk pergi ke suatu tempat untuk menyalakan speaker.  Jika Anda malas, maka secara penuh. <br><br>  <b>Pasar besar adalah aplikasi untuk anak-anak</b> .  Anak-anak kecil belum tahu cara membaca, menulis, dan mencetak, tetapi mereka berbicara dan memahami ucapan.  Karena itu, anak-anak mengagumi Alice dan suka berkomunikasi dengannya.  Orang tua juga puas - tidak perlu mencari apa yang harus dilakukan dengan anak.  Yang menarik, Alice memahami anak-anak berkat jaringan saraf yang terlatih dengan baik. <br><br>  <b>Ketersediaan</b>  Orang tunanetra merasa nyaman bekerja dengan asisten suara - saat antarmuka tidak terlihat, Anda dapat mendengarnya dan memberikannya perintah. <br><br>  <b>Suara lebih cepat</b> .  Rata-rata orang, bukan pengembang, mencetak rata-rata 30 kata per menit, dan mengatakan 120. Per menit, 4 kali lebih banyak informasi ditransmisikan dengan suara. <br><br>  <b>Masa depan</b>  Film fantastis dan prediksi futuristik menunjukkan bahwa masa depan adalah dengan antarmuka suara.  Penulis naskah berpikir bahwa mungkin kontrol suara akan menjadi cara utama untuk berinteraksi dengan antarmuka di mana gambar tidak begitu penting. <br><br>  Menurut statistik, 35 juta orang menggunakan Alisa per bulan.  Omong-omong, populasi Belarus adalah 9.475.600 orang.  Artinya, sekitar 3,5 Belarus menggunakan Alice setiap bulan. <br><br>  Asisten suara menaklukkan pasar.  Menurut perkiraan, pada 2021 akan tumbuh sekitar 2 kali lipat.  Popularitas hari ini tidak akan berhenti, tetapi akan terus tumbuh.  Semakin banyak pengembang menyadari bahwa mereka perlu berinvestasi di bidang ini. <br><br><h3>  Keterampilan Pengembang </h3><br>  Sangat bagus ketika perusahaan berinvestasi dalam asisten suara.  Mereka memahami bagaimana mereka dapat diintegrasikan dengan layanan mereka.  Tetapi pengembang juga ingin berpartisipasi dalam hal ini, dan perusahaan itu sendiri menguntungkan. <br><br>  Alexa memiliki Keterampilan Alexa.  Menurut metode interaksi yang didokumentasikan, dia mengerti apa yang ditulis pengembang untuknya.  Google meluncurkan Tindakan - kemampuan untuk mengintegrasikan sesuatu sendiri ke dalam asisten suara. <br><br>  Alice juga memiliki keterampilan - kemampuan bagi pengembang untuk mengimplementasikan sesuatu pihak ketiga. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/682/cba/758/682cba758b31f41d75d55aca324645b1.jpg"><br><br>  Pada saat yang sama, ada katalog alternatif keterampilan, bukan dari Yandex, yang didukung oleh komunitas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/445/c87/9a5/445c879a5d44b7da9f49f185826cbdbe.jpg"><br><br>  Ada laporan bagus tentang cara membuat aplikasi suara.  Misalnya, <b>Pavel Guy</b> berbicara di AppsConf 2018 dengan tema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Membuat aplikasi suara menggunakan contoh Bantuan Google"</a> .  Penggemar terlibat aktif dalam pengembangan aplikasi suara.  Salah satu contohnya adalah permainan visual yang diaktifkan suara yang ditulis oleh Ivan Golubev. <br><br>  Alice populer, meskipun pada dasarnya semua yang dia lakukan berada di antara suara dan teks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/804/0fb/c3e/8040fbc3e31afcbee27651b7a77a2426.jpg"><br><br>  Alice tahu cara mendengarkan suara dan mengubahnya menjadi teks sesuai dengan algoritmanya, membuat jawaban, dan menyuarakannya.  Tampaknya ini tidak cukup, tetapi ini adalah tugas yang sangat sulit.  Banyak orang berusaha memastikan bahwa Alice terdengar alami, dengan benar dikenali, memahami aksen, dan ucapan anak-anak.  Yandex menyediakan sesuatu seperti proxy yang melewati segalanya dengan sendirinya.  Pikiran yang menakjubkan bekerja sehingga Anda dapat menggunakan hasil pekerjaan mereka. <br><br>  Keahlian Alice - Yandex.Dialogs - memiliki satu keterbatasan.  Waktu yang dibutuhkan API untuk merespons tidak boleh melebihi 1,5 detik.  Dan ini logis, karena jika jawabannya hang - mengapa menunggu? <br><br><blockquote>  Apakah benar-benar penting untuk bertanya apa jika Anda masih belum mendapatkan jawaban? </blockquote><br>  Ketika kami menerima informasi dengan telinga kami, jeda dirasakan oleh otak lebih lama dari jeda serupa di antarmuka visual.  Misalnya, loader, pemintal - segala sesuatu yang ingin kita tambahkan ke antarmuka mengalihkan pengguna dari menunggu.  Pertimbangkan semuanya bekerja dengan cepat. <br><br><h2>  Waktu untuk demo </h2><br>  Semuanya dijelaskan secara rinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> Yandex.Dialog dan selalu terbaru.  Saya tidak akan mengulangi lagi.  Saya akan memberi tahu Anda apa yang menarik bagi saya dan menunjukkan cara cepat membuat demo, yang saya habiskan hanya satu malam. <br><br>  Mari kita mulai dengan ide.  Ada banyak keterampilan, ada katalog, tetapi saya tidak menemukan apa yang penting bagi saya - ini adalah kalender acara di front-end.  Bayangkan bangun di pagi hari: “Saya akan pergi ke pertemuan hari ini.  Alice!  Adakah sesuatu yang menarik di sana? ”, Dan Alice menjawab Anda, terlebih lagi, dengan benar dan mempertimbangkan lokasi Anda. <br><br>  Jika Anda terlibat dalam menyelenggarakan konferensi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bergabunglah di GitHub</a> .  Anda dapat membawa acara dan rapat di sana, belajar tentang banyak acara di front-end di dunia dari satu kalender. <br><br>  Saya mengambil teknologi terkenal yang ada di tangan: Node.js dan Express.  Masih Heroku, karena gratis.  Aplikasi itu sendiri sederhana: ini adalah server di Node.js, aplikasi Express.  Angkat saja server pada beberapa port dan dengarkan permintaan. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> express <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { router } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'routes'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express(); app.use(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, router); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> port = process.env.PORT || <span class="hljs-number"><span class="hljs-number">8000</span></span>; app.listen(port, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Server started on :${port}'</span></span>); });</code> </pre> <br>  Saya mengambil keuntungan dari kenyataan bahwa semuanya sudah dikonfigurasi dalam kalender standar Web, dan dari sejumlah besar file kecil ada satu file ICS yang dapat diunduh.  Mengapa saya harus mengambil sendiri? <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// services/vendors/web-standards.js import axios from 'axios'; const axioslnstance = axios.create({ baseURL: 'https://web-standards.ru/' , }); export function getRemoteCal() { return axioslnstance.get('calendar.ics'); }</span></span></code> </pre> <br>  Pastikan semuanya bekerja dengan cepat. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Router } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wst <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'services/vendors/web-standards'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = Router(); router.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) </span></span>{ wst .getRemoteCal() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">vendorResponse</span></span></span><span class="hljs-function"> =&gt;</span></span> parseCalendar(vendorResponse.data)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">events</span></span></span><span class="hljs-function"> =&gt;</span></span> { res.json({ events }); }) .catch(next); });</code> </pre> <br>  Gunakan metode GET untuk tes.  Keterampilan bekerja dengan metode POST, sehingga metode GET dapat dilakukan secara eksklusif untuk debugging.  Saya telah menerapkan metode seperti itu.  Semua yang dia lakukan adalah mengunduh ICS yang sama, mengurai dan mengeluarkannya dalam bentuk JSON. <br><br>  Saya membuat demo dengan cepat, jadi saya mengambil perpustakaan node-ical siap pakai: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ical <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'node-ical'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseCalendar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { ical.parseICS(str, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { reject(err); } resolve(data); }); }); }</code> </pre> <br>  Dia tahu cara mem-parsing format ICS.  Pada output itu menghasilkan lembaran seperti: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"2018-10-04-f rontendconf@https://web-standards.ru/"</span></span>: { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"VEVENT"</span></span>, <span class="hljs-string"><span class="hljs-string">"params"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"uid"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-10-04-f rontendconf@https://web-standards.ru/"</span></span>, <span class="hljs-string"><span class="hljs-string">"sequence"</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"dtstamp"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-05-25T21:23:50.000Z"</span></span>, <span class="hljs-string"><span class="hljs-string">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-10-04T00:00:00.000Z"</span></span>, <span class="hljs-string"><span class="hljs-string">"datetype"</span></span>: <span class="hljs-string"><span class="hljs-string">"date"</span></span>, <span class="hljs-string"><span class="hljs-string">"end"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-10-06T00:00:00.000Z"</span></span>, <span class="hljs-string"><span class="hljs-string">"MICROSOFT-CDO-ALLDAYEVENT"</span></span>: <span class="hljs-string"><span class="hljs-string">"TRUE"</span></span>, <span class="hljs-string"><span class="hljs-string">"MICROSOFT-MSNCALENDAR-ALLDAYEVENT"</span></span>: <span class="hljs-string"><span class="hljs-string">"TRUE"</span></span>, <span class="hljs-string"><span class="hljs-string">"summary"</span></span>: <span class="hljs-string"><span class="hljs-string">"FrontendConf"</span></span>, <span class="hljs-string"><span class="hljs-string">"location"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://frontendconf.ru/moscow/2018"</span></span> } }</code> </pre> <br>  Untuk memilah dan memberikan informasi yang diperlukan kepada pengguna keterampilan, cukup mengetahui waktu awal dan akhir acara, nama, tautan, dan, yang penting, kota.  Saya ingin keterampilan untuk mencari acara di kota. <br><br><h3>  Format input </h3><br>  Bagaimana Yandex.Dialog mengembalikan informasi?  Kolom atau asisten suara yang dibangun di dalam aplikasi seluler mendengarkan Anda, dan server Yandex memproses apa yang mereka dengar dan mengirim objek sebagai respons: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"meta"</span></span>: { … }, <span class="hljs-string"><span class="hljs-string">"request”: { … }, "</span></span>session<span class="hljs-string"><span class="hljs-string">": { … }, "</span></span>version<span class="hljs-string"><span class="hljs-string">": "</span></span><span class="hljs-number"><span class="hljs-number">1.0</span></span><span class="hljs-string"><span class="hljs-string">" }</span></span></code> </pre> <br>  Objek berisi meta-informasi, informasi tentang permintaan, sesi saat ini dan versi API jika tiba-tiba diperbarui - keterampilan tidak boleh rusak. <br><br>  Ada banyak <b>informasi</b> berguna dalam <b>informasi meta</b> . <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"meta"</span></span>: { <span class="hljs-string"><span class="hljs-string">"locale"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru-RU"</span></span>, <span class="hljs-string"><span class="hljs-string">"timezone"</span></span>: <span class="hljs-string"><span class="hljs-string">"Europe/Moscow"</span></span>, <span class="hljs-string"><span class="hljs-string">"client_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru.yandex.searchplugin/5.80…”, "</span></span>interfaces<span class="hljs-string"><span class="hljs-string">": { "</span></span>screen<span class="hljs-string"><span class="hljs-string">": {} } } }</span></span></code> </pre> <br>  " <b>Lokal</b> " - digunakan untuk memahami wilayah pengguna. <br><br>  " <b>Zona Waktu</b> " dapat digunakan untuk bekerja secara kompeten dengan waktu dan lebih akurat menentukan lokasi pengguna. <br><br>  " <b>Antarmuka</b> " - informasi tentang ketersediaan layar.  Jika tidak ada layar, Anda harus memikirkan bagaimana pengguna akan melihat gambar jika Anda memberikannya dalam jawaban.  Jika ada layar, kami mengambil informasi tentang itu. <br><br>  Format permintaan <b>sederhana</b> : <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"request"</span></span>: { <span class="hljs-string"><span class="hljs-string">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">"      16"</span></span>, <span class="hljs-string"><span class="hljs-string">"original_utterance"</span></span>: <span class="hljs-string"><span class="hljs-string">"     , 16"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"SimpleUtterance"</span></span>, <span class="hljs-string"><span class="hljs-string">"nlu"</span></span>: { <span class="hljs-string"><span class="hljs-string">"tokens"</span></span>: [ <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"16"</span></span>], <span class="hljs-string"><span class="hljs-string">"entities"</span></span>: [...] } } }</code> </pre> <br>  Ini memberikan apa yang dikatakan pengguna, tipe permintaan dan <b>NLU - Unit berbahasa alami</b> .  Inilah keajaiban yang dilakukan platform Yandex.Dialog.  Dia memecah seluruh kalimat yang dia kenali menjadi token - kata.  Ada juga entitas di sana yang akan kita bicarakan nanti.  Menggunakan token sudah cukup untuk memulai. <br><br>  Kami mendapat kata-kata ini, dan apa yang harus dilakukan dengan mereka?  Pengguna telah mengatakan sesuatu, tetapi ia dapat mengucapkan kata-kata dalam urutan yang berbeda, menggunakan partikel "tidak", yang mengubah segalanya secara dramatis, atau bahkan mengatakan "pagi" daripada "pagi".  Jika pengguna juga berbicara bahasa Belarusia, maka akan ada "tas", bukan pagi.  Sebuah proyek besar akan membutuhkan bantuan ahli bahasa untuk mengembangkan keterampilan yang memahami segalanya.  Tetapi saya melakukan tugas sederhana, jadi saya melakukannya tanpa bantuan pihak luar. <br><br><h2>  Bisakah komputer berbicara seperti orang? </h2><br>  Ini adalah pertanyaan filosofis yang coba dijawab oleh tes Turing.  Tes memungkinkan dengan probabilitas tertentu untuk menentukan bahwa kecerdasan buatan dapat menyamar sebagai seseorang.  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hadiah Loebner</a> untuk menerima program mana yang bersaing dalam melewati tes Turing.  Keputusan itu dibuat oleh majelis hakim.  Untuk mendapatkan hadiah, Anda perlu menipu 33% dari juri atau lebih.  Hanya pada tahun 2014, bot <b>Zhenya Gustman</b> dari St. Petersburg akhirnya menipu komisi. <br><br><pre> <code class="plaintext hljs">[15:46:05] Dudge: My favourite music is contemporary Dazz, what do you prefer? [15:46:14] Eugene: To be short I'll only say that I HATE Britnie [sic] Spears. All other music is OK compared to her. [15:47:06] Dudge: do you like to play any musical instruments [15:47:23] Eugene: I'm tone deaf, but my guinea pig likes to squeal Beethoven's Ode to Doy every morning. I suspect our neighbors want to cut his throat ... Could you tell me about your job, by the way? [15:48:02] Dudge: Guinea pig? Are you an animal lover [15:48:08] Eugene: Yeah. A nice little guinea pig. Not some annoying chatter bot.</code> </pre> <br>  Pada tahun 2019, tidak ada yang benar-benar berubah - masih sulit untuk menipu seseorang.  Tapi kami secara bertahap bergerak menuju ini. <br><br><h2>  Script bekerja </h2><br>  Keahlian yang baik membutuhkan kasus penggunaan yang menarik.  Saya menyarankan satu buku yang layak dibaca - "Merancang Antarmuka Pengguna Suara: Prinsip-Prinsip Pengalaman Percakapan".  Mengagumkan tentang penulisan skrip untuk antarmuka suara dan menjaga perhatian pengguna sangat mengagumkan.  Saya tidak melihat buku itu dalam bahasa Inggris, tetapi buku itu dibaca dengan mudah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/871/3e1/222/8713e12220b6ce7a65563775dc2b49f2.jpg"><br><br>  Hal pertama untuk mulai mengembangkan keterampilan adalah salam. <br><br><blockquote>  “Selagi kamu memikirkan apa yang harus dikatakan, lakukan curtsy!  Ini menghemat waktu. " </blockquote><br>  Saat skill menyala, Anda perlu menahan pengguna dari detik pertama, dan untuk ini Anda perlu menjelaskan cara menggunakan skill.  Bayangkan bahwa pengguna meluncurkan skill dan ada keheningan.  Bagaimana Anda tahu jika suatu keterampilan bekerja sama sekali?  Berikan instruksi kepada pengguna, seperti tombol di layar. <br><br><h3>  Dialog yang mudah </h3><br>  Tanda-tanda dialog mudah.  Daftar ini diciptakan oleh Ivan Golubev, dan saya sangat suka kata-katanya. <br><br><ul><li>  <b>L</b> pribadi. <br></li><li>  Alami. <br></li><li>  Fleksibel <br></li><li>  Ontext. <br></li><li>  <b>Dan</b> bernasib baik. <br></li><li>  Singkat <b>J.</b> <br></li></ul><br>  <b>Pribadi</b> berarti bot harus memiliki karakter.  Jika Anda berbicara dengan Alice, Anda akan mengerti bahwa dia memiliki karakter - para pengembang mengurus ini.  Karena itu, bot Anda untuk organikitas harus memiliki "kepribadian".  Berikan frasa dengan setidaknya satu suara, gunakan konstruksi verbal yang sama.  Ini membantu mempertahankan pengguna. <br><br>  <b>Alami</b> .  Jika permintaan pengguna sederhana, maka jawabannya harus sama.  Selama komunikasi dengan bot, pengguna harus memahami apa yang harus dilakukan selanjutnya. <br><br>  <b>Fleksibel</b>  Bersiaplah untuk apa pun.  Ada banyak sinonim dalam bahasa Rusia.  Pengguna dapat mengalihkan perhatian dari kolom dan mentransfer percakapan ke lawan bicara, dan kemudian kembali ke kolom.  Semua ini sulit ditangani.  Tetapi jika Anda ingin membuat bot dengan baik, maka Anda harus melakukannya.  Perlu diingat bahwa beberapa persen dari non-pengakuan masih akan terjadi.  Bersiaplah untuk ini - sarankan opsi. <br><br>  <b>Kontekstual</b> - bot, idealnya, harus mengingat apa yang terjadi sebelumnya.  Maka pembicaraan akan menjadi hidup. <br><br>  <i>- Alice, seperti apa cuaca hari ini?</i> <br>  <i>- Hari ini di Distrik dari +11 hingga +20, berawan, dengan cerah.</i> <br>  <i>- Dan besok?</i> <br>  <i>- Besok di Distrik dari +14 hingga +27, berawan, dengan cerah.</i> <br><br>  Bayangkan bot Anda tidak tahu cara menyimpan konteks.  Apa artinya baginya permintaan "dan besok?"  Jika Anda tahu bagaimana menjaga konteks seperti Alice, maka Anda dapat menggunakan hasil sebelumnya untuk meningkatkan jawaban dalam keterampilan. <br><br>  <b>Proaktif</b> .  Jika pengguna tumpul, bot akan menanyakannya: "Klik tombol ini!", "Lihat, saya punya gambar untuk Anda!", "Ikuti tautannya."  Bot harus memberi tahu Anda cara bekerja dengannya. <br><br>  Bot harus <b>pendek</b> .  Ketika seseorang berbicara untuk waktu yang lama, sulit baginya untuk menjaga perhatian audiens.  Ini bahkan lebih rumit dengan bot - tidak sayang untuk itu, itu tidak hidup.  Untuk menarik perhatian, Anda perlu membangun percakapan dengan menarik atau singkat dan singkat.  Ini akan membantu “Menulis.  Potong itu. "  Saat Anda mulai mengembangkan bot, baca buku ini. <br><br><h3>  Basis data </h3><br>  Saat mengembangkan bot yang kompleks, Anda tidak dapat melakukannya tanpa basis data.  Demo saya tidak menggunakan database, itu sederhana.  Tetapi jika Anda mengacaukan beberapa basis data, Anda dapat menggunakan informasi tentang sesi pengguna, setidaknya untuk menyimpan konteksnya. <br><br>  Ada nuansa: Yandex.Dialogs tidak memberikan informasi pribadi pengguna, misalnya, nama, lokasi.  Tetapi informasi ini dapat ditanyakan dari pengguna, disimpan dan ditautkan ke ID sesi tertentu, yang Yandex.Dialogs kirimkan dalam permintaan. <br><br><h3>  Mesin negara </h3><br>  Menyebutkan skenario yang kompleks, orang tidak bisa tidak mengingat mesin negara.  Mekanisme ini telah lama dan sangat baik digunakan untuk pemrograman mikrokontroler, dan kadang-kadang ujung depan.  Mesin keadaan sesuai untuk skenario: ada keadaan dari mana kita beralih ke keadaan lain untuk frasa tertentu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/914/9bb/e4d/9149bbe4d192a9d9e4ee0a42dc315044.jpg"><br><br>  Jangan berlebihan.  Anda bisa terbawa suasana dan membuat mesin negara yang besar, yang akan sulit dipecahkan - mempertahankan kode seperti itu sulit.  Lebih mudah untuk menulis satu skrip yang terdiri dari sub-skrip kecil. <br><br><h3>  Tidak jelas  Tentukan </h3><br>  Jangan pernah berkata, "Ulangi, tolong."  Apa yang dilakukan seseorang ketika diminta mengulangi?  Dia berbicara lebih keras.  Jika pengguna meneriaki keahlian Anda, pengakuan tidak akan meningkat.  Ajukan pertanyaan klarifikasi.  Jika salah satu bagian dari dialog pengguna dikenali dan ada sesuatu yang hilang, periksa blok yang hilang. <br><br>  Pengenalan teks adalah tugas yang paling sulit dalam mengembangkan bot, jadi terkadang klarifikasi tidak membantu.  Dalam situasi yang tidak dapat dipahami, solusi terbaik adalah mengumpulkan segala sesuatu di satu tempat, mencatat, dan kemudian menganalisis dan menggunakannya di masa depan.  Misalnya, jika pengguna mengatakan hal-hal yang aneh dan tidak dapat dipahami. <br><br>  <i>“Itu mendidih.</i>  <i>Creamy Shore</i> <i><br></i>  <i>Mengejek nav.</i> <i><br></i>  <i>Dan dengusan mendengus.</i> <i><br></i>  <i>Seperti mumi dalam gerakan. ”</i> <br><br>  Pengguna secara tak terduga dapat menggunakan beberapa neologisme, yang artinya sesuatu, dan itu perlu diproses entah bagaimana.  Akibatnya, persentase pengakuan turun.  Jangan khawatir - masuk, pelajari dan tingkatkan bot Anda. <br><br><h3>  Hentikan kata </h3><br>  Pasti ada sesuatu untuk menghentikan keterampilan ketika Anda ingin keluar dari itu.  Alice tahu bagaimana berhenti setelah frasa: "Alice, itu sudah cukup!"  atau "Alice, berhenti!"  Tetapi pengguna biasanya tidak membaca instruksi.  Karena itu, setidaknya tanggapi kata "Stop" dan kembalikan kontrol ke Alice. <br><br>  Sekarang mari kita lihat kodenya. <br><br><h2>  Waktu untuk demo </h2><br>  Saya ingin menerapkan frasa berikut. <br><br><ul><li>  Acara mendatang di kota. <br></li><li>  Nama kota: "peristiwa di Moskow", "acara di Minsk", "St. Petersburg" untuk menunjukkan peristiwa yang ditemukan di sana. <br></li><li>  Stop words: "Stop," "Cukup."  "Terima kasih" jika pengguna mengakhiri percakapan dengan kata ini.  Tapi idealnya, ahli bahasa diperlukan di sini. <br></li></ul><br>  Untuk "acara mendatang" frasa apa pun cocok.  Saya membuat bot malas, dan ketika dia tidak mengerti apa yang mereka katakan, dia memberikan informasi tentang tiga peristiwa berikutnya. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"request"</span></span>: { <span class="hljs-string"><span class="hljs-string">"nlu"</span></span>: { <span class="hljs-string"><span class="hljs-string">"entities"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"tokens"</span></span>: { <span class="hljs-string"><span class="hljs-string">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"YANDEX.GEO"</span></span>, <span class="hljs-string"><span class="hljs-string">"value"</span></span>: { <span class="hljs-string"><span class="hljs-string">"house_number"</span></span>: <span class="hljs-string"><span class="hljs-string">"16"</span></span>, <span class="hljs-string"><span class="hljs-string">"street"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">"city"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } ] } } }</code> </pre> <br>  Yandex secara bertahap meningkatkan platform Yandex.Dialogs dan mengeluarkan entitas yang telah dapat dikenali.  Misalnya, dia tahu cara mendapatkan alamat dari sebuah teks, mengurutkannya di beberapa bagian: kota, negara, jalan, rumah.  Dia juga tahu bagaimana mengenali angka dan tanggal, baik mutlak maupun relatif.  Dia akan mengerti bahwa kata "Besok" adalah tanggal hari ini, yang ditambahkan. <br><br><h3>  Balas ke pengguna </h3><br>  Anda harus entah bagaimana menanggapi pengguna Anda.  Seluruh skill adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">209 baris</a> dengan baris kosong terakhir.  Tidak ada yang rumit - bekerja untuk malam hari. <br><br>  Yang Anda lakukan hanyalah memproses permintaan POST dan mendapatkan "permintaan". <br><br><pre> <code class="javascript hljs">router.post(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, (req/ res, next) ⇒ { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request = req.body;</code> </pre> <br>  Selanjutnya, saya tidak terlalu menyulitkan mesin negara, tetapi berjalan sesuai prioritas.  Jika pengguna ingin mempelajari cara menggunakan bot, maka ini adalah peluncuran pertama atau permintaan bantuan.  Karena itu, siapkan dia "EmptyResponse" - inilah yang saya sebut. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needHelp(request.request)) { res.json(prepareEmptyResponse(request)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  Fungsi needHelp sederhana. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needHelp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req.nlu.token.length ≤ <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; req.nlu.tokens.includes(<span class="hljs-string"><span class="hljs-string">''</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req.nlu.token.length = <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; req.type ≠ <span class="hljs-string"><span class="hljs-string">'ButtonPressed'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Ketika kami memiliki nol token, maka kami berada di awal permintaan.  Pengguna baru saja memulai keterampilan atau tidak meminta apa pun.  Anda perlu memeriksa bahwa tokennya nol dan ini bukan tombol - ketika Anda mengklik tombolnya, pengguna juga tidak mengatakan apa-apa.  Saat pengguna meminta bantuan, kami membaca token dan mencari kata "Bantuan".  Logikanya sederhana. <br><br>  Jika pengguna ingin berhenti. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needToStop(request.request)) { res.json(prepareStopResponse(request)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  Jadi kami mencari semacam stop word di dalam. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needStop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stopWords = [<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> req.nlu.token.length ≤ <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; stopWords.some(w ⇒ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> req.nlu.token.includes(w)); }</code> </pre> <br>  Dalam semua jawaban, Anda harus mengembalikan informasi yang Yandex.Dialog kirimkan tentang sesi tersebut.  Dia harus entah bagaimana mencocokkan jawaban Anda dan permintaan pengguna. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StopResponse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { session, version } = req; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">response</span></span>: { <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">' .  !'</span></span>, <span class="hljs-attr"><span class="hljs-attr">end_session</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }, session, version, }; }</code> </pre> <br>  Oleh karena itu, apa yang Anda dapatkan dalam variabel "sesi" dan "versi", kembali, dan semuanya akan baik-baik saja.  Sudah dalam jawaban Anda dapat memberikan beberapa teks untuk Alice untuk mengucapkannya, dan lulus "akhir sesi: benar".  Ini artinya kita mengakhiri sesi skill dan mentransfer kontrol ke Alice. <br><br>  Saat kamu memanggil skill, Alice mati.  Semua yang dia dengarkan adalah kata-kata penghenti, dan Anda sepenuhnya mengendalikan proses bekerja dengan keterampilan.  Karena itu, Anda perlu mengembalikan kontrol. <br><br>  Dengan permintaan kosong lebih menarik. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">"response"</span></span>: { <span class="hljs-string"><span class="hljs-string">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">'!        -  .'</span></span>, <span class="hljs-string"><span class="hljs-string">"tts"</span></span>: <span class="hljs-string"><span class="hljs-string">'!        -  .'</span></span>, <span class="hljs-attr"><span class="hljs-attr">buttons</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: {} hide: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'  '</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: { <span class="hljs-attr"><span class="hljs-attr">city</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, } hide: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }, ], <span class="hljs-attr"><span class="hljs-attr">end_session</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }, session, version, };</code> </pre> <br>  Ada bidang <b>TTS</b> ( <b>Teks Ke Pidato</b> ) - <b>kontrol suara</b> .  Ini adalah format sederhana yang memungkinkan Anda membaca teks dengan berbagai cara.  Misalnya, kata "multidisiplin" memiliki dua tekanan dalam bahasa Rusia - satu primer, sekunder kedua.  Tugasnya adalah Alice dapat mengucapkan kata ini dengan benar.  Anda dapat mematahkannya dengan spasi: <br><br><pre> <code class="plaintext hljs">+ +</code> </pre> <br>  Dia akan mengerti dia sebagai dua.  Aksen plus disorot. <br><br>  Ada jeda dalam pidato - Anda memberi tanda baca, yang dipisahkan oleh spasi.  Jadi, Anda dapat membuat jeda dramatis: <br><br><pre> <code class="plaintext hljs"> — - - - - - - - - + </code> </pre> <br>  Saya sudah bicara tentang <b>tombol</b> .  Mereka penting jika Anda tidak berkomunikasi dengan kolom, tetapi dengan aplikasi seluler Yandex, misalnya. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"response"</span></span>: { <span class="hljs-string"><span class="hljs-string">"buttons"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Frontend Conf"</span></span>, <span class="hljs-string"><span class="hljs-string">"payload"</span></span>: {}, <span class="hljs-string"><span class="hljs-string">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://frontendconf.ru/moscow-rit/2019"</span></span> , <span class="hljs-string"><span class="hljs-string">"hide"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } ] } }</code> </pre> <br>  Tombol juga merupakan petunjuk untuk frasa yang Anda rasakan dalam keterampilan Anda.  Keahlian bekerja di aplikasi Yandex - Anda berkomunikasi dengan antarmuka.  Jika Anda ingin memberikan beberapa informasi - berikan tautan, pengguna mengkliknya.  Anda juga dapat menambahkan tombol untuk ini. <br><br>  Ada bidang “muatan” di mana Anda dapat menambahkan data.  Mereka kemudian akan kembali dengan "permintaan" - Anda akan tahu, misalnya, bagaimana menandai tombol ini. <br><br>  Anda dapat memilih <b>suara</b> yang akan dibicarakan oleh keahlian Anda. <br><br><ul><li>  <b>Alice</b> adalah suara standar <b>Alice</b> .  Dioptimalkan untuk interaksi singkat. <br></li><li>  Oksana - suara Yandex.Navigator. <br></li><li>  Jane <br></li><li>  Zahar. <br></li><li>  Ermil. <br></li><li>  <b>Erkan Yavas</b> - untuk teks panjang.  Awalnya dibuat untuk membaca berita. <br></li></ul><br>  Untuk <b>menyelesaikan keterampilan</b> , cukup kembalikan "end_session: true". <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"response"</span></span>: { <span class="hljs-string"><span class="hljs-string">"end_session"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> <br><h3>  Apa yang terjadi dengan demo </h3><br>  Pertama, saya filter berdasarkan tanggal. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filterByDate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">events</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> events.filter(event ⇒ { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> current = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getTime(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(event.start).getTime(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (start &gt; current) || (event.end &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(event.end).getTime() &gt; current &amp;&amp; start ≤ current); }); }</code> </pre> <br>  Logikanya sederhana: dalam semua peristiwa yang saya parsing dari kalender, saya mengambil yang akan terjadi di masa depan, atau mereka pergi sekarang.  Mungkin aneh untuk bertanya tentang peristiwa masa lalu - keterampilannya bukan tentang itu. <br><br>  Selanjutnya, pemfilteran di tempatnya adalah tentang semua itu. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filterByPlace</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">events, req</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cities = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoEntities = req.nlu.entities.filter(e ⇒ e.type = <span class="hljs-string"><span class="hljs-string">'YANDEX.GEO'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req.payload &amp;&amp; req.payload.city) cities.add(req.payload.city); geoEntities.forEach(e ⇒ { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> city = e.value.city &amp;&amp; e.value.city.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (city &amp;&amp; !cities.has(city)) { cities.add(city); } });</code> </pre> <br>  Di "entitas" Anda dapat menemukan entitas YANDEX.GEO, yang menyaring lokasi.  Jika entitas memiliki kota, tambahkan ke set kami.  Selanjutnya, logikanya juga sederhana.  Kami mencari kota ini di token, dan jika ada, kami mencari apa yang diinginkan pengguna.  Jika tidak, kami mencari di semua "lokasi" dan "acara" yang kami miliki. <br><br>  Misalkan Yandex tidak mengenali bahwa itu adalah YANDEX.GEO, tetapi pengguna tersebut menamai kota tersebut - ia yakin ada sesuatu yang terjadi di sana.  Kami menelusuri semua kota di "acara" dan mencari yang sama di token.  Ternyata perbandingan lintas array.  Bukan cara yang paling produktif, tentu saja, tetapi apa itu.  Itu seluruh keterampilan! <br><br>  Tolong jangan dimarahi saya untuk kode - saya menulis dengan cepat.  Semuanya primitif di sana, tetapi cobalah untuk menggunakannya atau hanya bermain-main. <br><br><h3>  Terbitkan Keterampilan </h3><br>  Buka halaman Yandex.Dialogs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/38e/4d1/ca6/38e4d1ca6e2f548fea625649f85c834f.jpg"><br><br>  Pilih keahlian dalam Alice.  Tekan tombol "Buat dialog" dan Anda akan masuk ke formulir yang harus Anda isi dengan data Anda. <br><br><ul><li>  <b>Nama</b> itulah yang akan ada dalam dialog. <br></li><li>  <b>Nama aktivasi</b> .  Jika Anda memilih nama aktivasi "Kalender Standar Web" melalui tanda hubung, maka Alice tidak mengenalinya - dia tidak mendengar tanda hubung.  Kami mengucapkan kata-kata tanpa tanda hubung, dan aktivasi tidak akan berfungsi.  Untuk mendapatkan uang, atur nama menjadi "Kalender Standar Web". <br></li><li>  <b>Frasa aktivasi</b> untuk meluncurkan skill.  Jika ini adalah permainan, maka "Ayo mainkan sesuatu," "Tanya seseorang."  Set ini terbatas, tetapi ini karena frasa seperti itu adalah aktivasi untuk Alice.  Dia harus mengerti bahwa inilah saatnya untuk mempelajari keterampilan. <br></li><li>  <b>URL Webhook</b> - alamat yang sama tempat Alice akan mengirim permintaan POST. <br></li><li>  <b>Suara itu</b> .  Standarnya adalah Oksana.  Karena itu, banyak di katalog suaranya, bukan Alice. <br></li><li>  <b>Apakah perangkat dengan layar diperlukan?</b>  Jika ada gambar, Anda akan dibatasi untuk menggunakan keterampilan - pada kolom pengguna tidak akan dapat meluncurkannya. <br></li><li>  <b>Keterampilan pribadi</b> adalah bidang penting bagi pengembang.  Jika Anda tidak siap memposting keterampilan di depan umum, jika hanya karena itu mentah, maka kami tidak menunjukkannya di katalog, membatasi privasi.  Keterampilan pribadi dimoderasi dengan cepat - dalam beberapa jam.  Keterampilan seperti itu tidak perlu diuji secara menyeluruh - cukup untuk mencocokkan nama aktivasi.  Karena pengguna tidak akan menemukan mereka di katalog, mereka lebih loyal kepada mereka. <br></li><li>  <b>Catatan untuk moderator</b> .  Saya meminta moderator untuk membantu: "Saya benar-benar membutuhkan keterampilan untuk demo di konferensi!"  - dan saya berhasil melewati moderasi dengan cepat. <br></li><li>  <b>Hak cipta</b> .  Jika Anda, tidak bekerja di bank bersyarat, memutuskan untuk membuat keterampilan untuk itu, Anda perlu membuktikan bahwa Anda memiliki hak untuk melakukannya.  Tiba-tiba mereka akan mendatangimu?  Dan mereka pasti akan datang, dan melalui distributor, yaitu Yandex, yang tidak memerlukan masalah tambahan. </li></ul><br>  Selesai - kirim keterampilan untuk moderasi, dan Anda dapat menguji. <br><br><h2>  Pengujian </h2><br>  Saya menulis server Express dangkal.   API,    .   , , «alice-tester» —      ,   . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> assert = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'assert'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> User = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'alice-tester'</span></span>); it(<span class="hljs-string"><span class="hljs-string">'should show help'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">'http://localhost:3000'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> user.enter(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> user.say(<span class="hljs-string"><span class="hljs-string">'  ?'</span></span>); assert.equal(user.response.text, <span class="hljs-string"><span class="hljs-string">'    .'</span></span>); assert.equal(user.response.tts, <span class="hljs-string"><span class="hljs-string">'    +.'</span></span>); assert.deepEqual(user.response.buttons, [{<span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">hide</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}]); }]);</code> </pre><br>       .,     «». <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ee/4ea/71f/2ee4ea71f971a916074c47ffc3434ef0.jpg"><br><br>  ,   ,      .   ,     : , ,     .   ,   —    ,    .    Postman —  . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> .</a> .   Just AI.   ,   ,          . <br><br>  <b> </b> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dialogs.home.popstas.ru</a>  URL, ,  localhost.    ,     debug.    ,      localhost. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d8a/2d0/706/d8a2d07069f511e397d6a77f8bf4fd0b.jpg"><br><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b> </b></a> .  —    .    URL  ,    -       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/243/89a/f0b/24389af0bfe571fc85a0b937e0a64406.jpg"><br><br><blockquote>     —     . </blockquote><br> ,    , ,  . <br><br>  —    <b> </b> .  ,    ,    ,   ,  ,    . - -           . <br><br><h2>    </h2><br>         <b>Dialogflow</b> ,     Google Now. ,    —  ,     — . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/471/fe9/b76/471fe9b76fd59e898ed4dae0a455733a.jpg"><br><br>    ,      .      .   ,         .     ,    . <br><br>   Google Dialogflow  .,  <b>Dialogflower</b> .          Alexa,   Google Now,   . —   API,      . <br><br>   ,     . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aimyloqic</a> —    .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zenbot</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tortu</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alfa.Bot</a> —  ,   . ! <br><br><h2>     </h2><br> <b>   FAQ</b> .    ,     .    ,      ,  . <br><br> <b></b> .   ,  ,     ,     .    —   ,    .     ,      .    ,    . <br><br>    <b>IFTTT</b> ,      —     Trello.    —    API.         ,  ,     .        , IFTT —     . <br><br>    <b>  </b> .      ,  .   . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1b4/a25/418/1b4a25418eaaf223dfb8e0744404b7a0.jpg"><br><br> ,  «»     . <br><br>         .     Xiaomi    .  .       . ,    Arduino - --- ,  ,   : «,  -  2000!»       — ! <br><br>     ,     : «,  !» —   !        . ,       . <br><br><h2>      </h2><br> <b>  </b> . ,    ,   :  ,   .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> .</a> .       .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    .</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub-</a>     .,   .     —   . <br><br> <b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Telegram- .</a></b> .    —    .    ,        .        .    . <br><br> <b>  </b> .       ,      .  - ,        .          , .   .   ,     . ,    : , -,    ,        .  , ,        .   : « ,    ?» ,      ,  ,       . <br><br> <b></b> —    ,       .     . <br><br> .   —  .     ,   ,      . ,       . <br><br><blockquote>     ,     ,   - ,      ! <br></blockquote><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> —     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> —   .     .   —   — ! <br><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FrontendConf 2019</a>      « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CSS —  </a> ».      —      .  ,     FrontendConf 2019  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . ,     ,     ,      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a>  . <br><br>      .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ,       . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468545/">https://habr.com/ru/post/id468545/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468533/index.html">Menumpang di DevOps dengan Express 42</a></li>
<li><a href="../id468535/index.html">Tidak perlu log?</a></li>
<li><a href="../id468537/index.html">Dasar-dasar DevOps. Masuk ke proyek dari awal</a></li>
<li><a href="../id468541/index.html">Seret - & - Jatuhkan komponen untuk pengguna tunanetra? Apakah kamu bercanda?</a></li>
<li><a href="../id468543/index.html">FrontendConf Komite Program Hari Kerja. Wawancara dengan Sergey Popov</a></li>
<li><a href="../id468547/index.html">Berbicara Bahasa Inggris, CSS, Kisi dan Aksesibilitas di FrontendConf</a></li>
<li><a href="../id468549/index.html">Terikat GPU. Cara mentransfer semuanya ke kartu video dan sedikit lagi. Animasi</a></li>
<li><a href="../id468553/index.html">Manajemen parameter dalam aplikasi bisnis mirip dengan sistem kontrol versi</a></li>
<li><a href="../id468555/index.html">Pengantar majelis deterministik dalam C / C ++. Bagian 2</a></li>
<li><a href="../id468557/index.html">WEB 3.0 - pendekatan kedua ke proyektil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>