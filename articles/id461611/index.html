<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤šğŸ¾ ğŸ“— ğŸ‘©â€ğŸ¤ Penerapan Cache Verilog ğŸ ğŸ’¡ â†–ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini membahas implementasi RAM paling sederhana di Verilog. 

 Sebelum melanjutkan dengan parsing kode, Anda disarankan untuk mempelajari sinta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penerapan Cache Verilog</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461611/"> Artikel ini membahas implementasi RAM paling sederhana di Verilog. <br><br>  Sebelum melanjutkan dengan parsing kode, Anda disarankan untuk mempelajari sintaks dasar Verilog. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini Anda dapat menemukan materi pelatihan</a> . <br><a name="habracut"></a><br><h3>  RAM </h3><br><h4>  Langkah 1: mendeklarasikan modul dengan sinyal input / output yang sesuai </h4><br><pre><code class="plaintext hljs">module ram ( input [word_size - 1:0] data, input [word_size - 1:0] addr, input wr, input clk, output response, output [word_size - 1:0] out ); parameter word_size = 32;</code> </pre> <br><ul><li>  <b>data</b> - data untuk ditulis. </li><li>  <b>addr</b> - address ke memori dalam RAM. </li><li>  <b>wr</b> - status (baca / tulis). </li><li>  <b>CLK</b> - sistem siklus jam. </li><li>  <b>response</b> - readiness of RAM (1 - jika RAM memproses permintaan baca / tulis, 0 - jika tidak). </li><li>  <b>keluar</b> - data dibaca dari RAM. </li></ul><br>  Implementasi ini diintegrasikan ke dalam Altera Max 10 FPGA, yang memiliki arsitektur 32-bit, dan oleh karena itu ukuran untuk data dan alamat (word_size) adalah 32 bit. <br><br><h4>  Langkah 2: mendeklarasikan register di dalam modul </h4><br>  Deklarasi array untuk menyimpan data: <br><br><pre> <code class="plaintext hljs">parameter size = 1&lt;&lt;32; reg [word_size-1:0] ram [size-1:0];</code> </pre><br>  Kita juga perlu menyimpan parameter input sebelumnya untuk melacak perubahannya di blok selalu: <br><br><pre> <code class="plaintext hljs">reg [word_size-1:0] data_reg; reg [word_size-1:0] addr_reg; reg wr_reg;</code> </pre><br>  Dan dua register terakhir untuk memperbarui sinyal output setelah perhitungan di blok selalu: <br><br><pre> <code class="plaintext hljs">reg [word_size-1:0] out_reg; reg response_reg;</code> </pre><br>  Kami menginisialisasi register: <br><br><pre> <code class="plaintext hljs">initial begin response_reg = 1; data_reg = 0; addr_reg = 0; wr_reg = 0; end</code> </pre><br><h4>  Langkah 3: menerapkan logika selalu dari blok </h4><br><pre> <code class="plaintext hljs">always @(negedge clk) begin if ((data != data_reg) || (addr%size != addr_reg)|| (wr != wr_reg)) begin response_reg = 0; data_reg = data; addr_reg = addr%size; wr_reg = wr; end else begin if (response_reg == 0) begin if (wr) ram[addr] = data; else out_reg = ram[addr]; response_reg = 1; end end end</code> </pre><br>  Blokir selalu dipicu oleh negedje, mis.  saat ini jam bergerak dari 1 ke 0. Ini dilakukan untuk menyinkronkan RAM dengan cache dengan benar.  Jika tidak, mungkin ada kasus ketika RAM tidak memiliki waktu untuk mengatur ulang status siap dari 1 ke 0 dan pada jam berikutnya, cache memutuskan bahwa RAM telah berhasil memproses permintaannya, yang pada dasarnya salah. <br><br>  Logika algoritma selalu blok adalah sebagai berikut: jika data diperbarui, setel ulang status kesiapan ke 0 dan tulis / baca data, jika tulis / baca selesai, perbarui status kesiapan ke 1. <br><br>  Pada akhirnya, tambahkan bagian kode berikut: <br><br><pre> <code class="plaintext hljs">assign out = out_reg; assign response = response_reg;</code> </pre><br>  Jenis sinyal keluaran modul kami adalah kawat.  Satu-satunya cara untuk mengubah sinyal dari jenis ini adalah penugasan jangka panjang, yang dilarang di dalam blok selalu.  Untuk alasan ini, blok selalu menggunakan register, yang selanjutnya ditugaskan untuk sinyal output. <br><br><h3>  Cache pemetaan langsung </h3><br>  Cache pemetaan langsung adalah salah satu jenis cache yang paling sederhana.  Dalam implementasi ini, cache terdiri dari n elemen, dan RAM secara kondisional dibagi menjadi blok-blok oleh n, maka elemen ke-i dalam cache berhubungan dengan semua elemen k-ke dalam RAM yang memenuhi kondisi i = k% n. <br><br>  Gambar di bawah ini menunjukkan cache ukuran 4 dan RAM ukuran 16. <br><br><img src="https://habrastorage.org/webt/k9/a-/_4/k9a-_4tdp2uqa6jmzqtcx7p5tfm.png"><br><br>  Setiap elemen cache berisi informasi berikut: <br><br><ul><li>  <b>bit validity</b> - apakah informasi dalam cache relevan atau tidak. </li><li>  <b>tag</b> adalah nomor blok dalam RAM tempat elemen ini berada. </li><li>  <b>data</b> - informasi yang kami tulis / baca. </li></ul><br>  Ketika diminta untuk membaca, cache membagi alamat input menjadi dua bagian - tag dan indeks.  Ukuran indeks adalah log (n), di mana n adalah ukuran cache. <br><br><h4>  Langkah 1: mendeklarasikan modul dengan sinyal input / output yang sesuai </h4><br><pre> <code class="plaintext hljs">module direct_mapping_cache ( input [word_size-1:0] data, input [word_size-1:0] addr, input wr, input clk, output response, output is_missrate, output [word_size-1:0] out ); parameter word_size = 32;</code> </pre><br>  Deklarasi modul cache identik dengan RAM, dengan pengecualian sinyal output baru is_missrate.  Output ini menyimpan informasi tentang apakah permintaan baca terakhir salah. <br><br><h4>  Langkah 2: mendeklarasikan register dan RAM </h4><br>  Sebelum mendeklarasikan register, kami menentukan ukuran cache dan indeks: <br><br><pre> <code class="plaintext hljs">parameter size = 64; parameter index_size = 6;</code> </pre><br>  Selanjutnya, kita mendeklarasikan sebuah array di mana data yang kita tulis dan baca akan disimpan: <br><br><pre> <code class="plaintext hljs">reg [word_size-1:0] data_array [size-1:0];</code> </pre><br>  Kami juga perlu menyimpan bit dan tag validitas untuk setiap item dalam cache: <br><br><pre> <code class="plaintext hljs">reg validity_array [size-1:0]; reg [word_size-index_size-1:0] tag_array [size-1:0]; reg [index_size-1:0] index_array [size-1:0];</code> </pre><br>  Register dimana alamat input akan dibagi: <br><br><pre> <code class="plaintext hljs">reg [word_size-index_size-1:0] tag; reg [index_size-1:0] index;</code> </pre><br>  Register yang menyimpan nilai input pada jam sebelumnya (untuk melacak perubahan pada data input): <br><br><pre> <code class="plaintext hljs">reg [word_size-1:0] data_reg; reg [word_size-1:0] addr_reg; reg wr_reg;</code> </pre><br>  Register untuk memperbarui sinyal output setelah perhitungan di blok selalu: <br><br><pre> <code class="plaintext hljs">reg response_reg; reg is_missrate_reg; reg [word_size-1:0] out_reg;</code> </pre><br>  Nilai Input untuk RAM: <br><br><pre> <code class="plaintext hljs">reg [word_size-1:0] ram_data; reg [word_size-1:0] ram_addr; reg ram_wr;</code> </pre><br>  Nilai Output untuk RAM: <br><br><pre> <code class="plaintext hljs">wire ram_response; wire [word_size-1:0] ram_out;</code> </pre><br>  Mendeklarasikan modul RAM dan menghubungkan sinyal input dan output: <br><br><pre> <code class="plaintext hljs">ram ram( .data(ram_data), .addr(ram_addr), .wr(ram_wr), .clk(clk), .response(ram_response), .out(ram_out));</code> </pre><br>  Daftar inisialisasi: <br><br><pre> <code class="plaintext hljs">initial integer i initial begin data_reg = 0; addr_reg = 0; wr_reg = 0; for (i = 0; i &lt; size; i=i+1) begin data_array[i] = 0; tag_array[i] = 0; validity_array[i] = 0; end end</code> </pre><br><h4>  Langkah 3: menerapkan logika selalu dari blok </h4><br>  Untuk mulai dengan, untuk setiap jam kami memiliki dua negara - data input diubah atau tidak diubah.  Berdasarkan ini, kami memiliki kondisi berikut: <br><br><pre> <code class="plaintext hljs">always @(posedge clk) begin if (data_reg != data || addr_reg != addr || wr_reg != wr) begin end // 1:    else begin // 2:     end end</code> </pre><br>  <b>Blok 1.</b> Jika input data diubah, hal pertama yang kami lakukan adalah mengatur ulang status kesiapan ke 0: <br><br><pre> <code class="plaintext hljs">response_reg = 0;</code> </pre><br>  Selanjutnya, kami memperbarui register yang menyimpan nilai input jam sebelumnya: <br><br><pre> <code class="plaintext hljs">data_reg = data; addr_reg = addr; wr_reg = wr;</code> </pre><br>  Kami memecah alamat input menjadi tag dan indeks: <br><br><pre> <code class="plaintext hljs">tag = addr &gt;&gt; index_size; index = addr;</code> </pre><br>  Untuk menghitung tag, pergeseran bitwise ke kanan digunakan, untuk indeks, cukup dengan menetapkannya saja, karena  Bit tambahan dari alamat tidak diperhitungkan. <br><br>  Langkah selanjutnya adalah memilih antara menulis dan membaca: <br><br><pre> <code class="plaintext hljs">if (wr) begin //  data_array[index] = data; tag_array[index] = tag; validity_array[index] = 1; ram_data = data; ram_addr = addr; ram_wr = wr; end else begin //  if ((validity_array[index]) &amp;&amp; (tag == tag_array[index])) begin //    is_missrate_reg = 0; out_reg = data_array[index]; response_reg = 1; end else begin //     is_missrate_reg = 1; ram_data = data; ram_addr = addr; ram_wr = wr; end end</code> </pre><br>  Dalam hal perekaman, kami awalnya memodifikasi data dalam cache, kemudian memperbarui data input untuk RAM.  Dalam hal membaca, kami memeriksa keberadaan elemen ini di cache dan, jika ada, tuliskan ke out_reg, jika tidak, kita beralih ke RAM. <br><br>  <b>Blok 2.</b> Jika data belum diubah sejak jam sebelumnya dieksekusi, maka kita memiliki kode berikut: <br><br><pre> <code class="plaintext hljs">if ((ram_response) &amp;&amp; (!response_reg)) begin if (wr == 0) begin validity_array [index] = 1; data_array [index] = ram_out; tag_array[index] = tag; out_reg = ram_out; end response_reg = 1; end</code> </pre><br>  Di sini kita menunggu penyelesaian akses ke RAM (jika tidak ada akses, ram_response adalah 1), perbarui data jika ada perintah baca dan atur kesiapan cache ke 1. <br><br>  Dan terakhir, perbarui nilai-nilai output: <br><br><pre> <code class="plaintext hljs">assign out = out_reg; assign is_missrate = is_missrate_reg; assign response = response_reg;</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461611/">https://habr.com/ru/post/id461611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461593/index.html">API di F #. Modul Aplikasi Berbasis Peran Akses</a></li>
<li><a href="../id461595/index.html">Dari teori ke praktek: bagaimana mahasiswa fakultas fotonics dan optoinformatika belajar dan bekerja</a></li>
<li><a href="../id461601/index.html">Apa yang harus diketahui oleh pendiri non-teknis tentang pengembangan perangkat lunak</a></li>
<li><a href="../id461605/index.html">Menciptakan Tower Defense in Unity: Ballistics</a></li>
<li><a href="../id461607/index.html">Cara Kerja Adapter Video Apple Lightning</a></li>
<li><a href="../id461613/index.html">Studi tentang self-discharge baterai</a></li>
<li><a href="../id461615/index.html">4 dosa mematikan headphone TWS: mengapa True Wireless masih tidak berantakan?</a></li>
<li><a href="../id461617/index.html">Teori Startup yang Sukses</a></li>
<li><a href="../id461621/index.html">Apakah sulit untuk menulis program VHDL pertama Anda?</a></li>
<li><a href="../id461623/index.html">Bagaimana kami membuat mesin dan game di dalamnya selama satu setengah tahun</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>