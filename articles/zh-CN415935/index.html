<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏆 ✌🏻 🤹🏾 插入排序 💃 👩🏽‍🎨 🛀🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="插入排序的一般本质如下： 



1. 遍历数组未排序部分中的元素。 
2. 每个元素都应在应放置的位置插入数组的排序部分。 
 原则上，这就是您需要了解的有关按插入排序的全部信息。 也就是说，插入排序始终将数组分为两部分-排序和未排序。 从未排序的部分检索任何项目。 由于数组的另一部分已排序，因此...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>插入排序</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415935/"><div style="text-align:center;"><img width="700" height="288" src="https://habrastorage.org/webt/ha/sk/1-/hask1-5bxk5ncdv33awxot2alcq.png"></div><br><br> 插入排序的一般本质如下： <br><br><ol><li> 遍历数组未排序部分中的元素。 </li><li>每个元素都应在应放置的位置插入数组的排序部分。 </li></ol><br><a name="habracut"></a>  <s>原则上，这就是您需要了解的有关按插入排序的全部信息。</s> 也就是说，插入排序始终将数组分为两部分-排序和未排序。 从未排序的部分检索任何项目。 由于数组的另一部分已排序，因此您可以快速为此提取的元素在此数组中找到您的位置。 必要时将元素插入，结果是数组的排序部分增加，而未排序部分减少。 仅此而已。 各种插入件均以此原理工作。 <br><br> 这种方法的最弱点是将元素插入数组的排序部分。 实际上，这并不容易，完成该步骤无需您花什么技巧。 <br><br><h2> 简单的插入排序 </h2><br><img width="684" height="95" src="https://habrastorage.org/webt/x4/nz/uu/x4nzuuiuosxzaj2y88ewj-vu9zo.gif"><br><br> 我们从左到右遍历数组，然后依次处理每个元素。 在下一个元素的左侧，随着过程的进行，我们增加了数组的排序部分，在右侧，增加了未排序部分的缓慢蒸发。 在数组的排序部分中，搜索下一个元素的插入点。 元素本身被发送到缓冲区，结果是一个空单元格出现在数组中-这使您可以移动元素并释放插入点。 <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insertion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(data)): j = i - <span class="hljs-number"><span class="hljs-number">1</span></span> key = data[i] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> data[j] &gt; key <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>: data[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = data[j] j -= <span class="hljs-number"><span class="hljs-number">1</span></span> data[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = key <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br> 以简单的插入为例，大多数（但不是全部！）按插入进行排序的主要优势都具有示范性，即对几乎有序数组的快速处理： <br><br><img width="684" height="95" src="https://habrastorage.org/webt/qq/6e/ud/qq6eudehsux_10xmkh1b-x1sata.gif"><br><br> 在这种情况下，即使是最原始的排序插入实现，也可能会在某些快速排序上（包括在大型数组上）超过超优化算法。 <br><br> 此类的主要思想使此操作变得容易-将元素从数组的未排序部分转移到已排序部分。 当相似大小的数据非常接近时，插入点通常位于已排序部分的边缘附近，这使您可以以最小的开销进行插入。 <br><br> 没有什么比插入排序更好地处理几乎有序的数组了。 当您在某个地方遇到信息时，按插入进行排序的最佳时间复杂度是<nobr>O（ <b>n</b> ）</nobr> ，那么您很可能是指具有几乎有序数组的情况。 <br><br><h2> 按简单的二进制搜索插入排序 </h2><br><img width="684" height="96" src="https://habrastorage.org/webt/ni/rs/nv/nirsnv-0nl-tntp5fecd21-4eiu.gif"><br><br> 由于插入位置是在数组的排序部分中搜索的，因此使用二进制搜索的想法很明显。 另一件事是，对插入位置的搜索对于算法的时间复杂度不是至关重要的（主要的资源消耗者是将元素插入到找到的位置本身的阶段），因此此优化几乎没有作用。 <br><br> 在几乎排序的数组的情况下，二进制搜索可能会更慢，因为它从已排序部分的中间开始，这很可能会离插入点太远（并且如果数据存在，从元素位置到插入点执行常规搜索的步骤将更少在整个数组中排序）。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insertion_binary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(data)): key = data[i] lo, hi = <span class="hljs-number"><span class="hljs-number">0</span></span>, i - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> lo &lt; hi: mid = lo + (hi - lo) // <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key &lt; data[mid]: hi = mid <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: lo = mid + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(i, lo + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>): data[j] = data[j - <span class="hljs-number"><span class="hljs-number">1</span></span>] data[lo] = key <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br> 为了辩护二进制搜索，我注意到他可以说其他单词通过插入进行排序的有效性中的最后一个单词。 特别是由于他，诸如图书管理员排序和纸牌排序之类的算法达到了平均时间复杂度<nobr>O（ <b>n</b> log <b>n</b> ）</nobr> 。 但是稍后。 <br><br><h2> 通过简单插入对进行排序 </h2><br> 简单插入的修改，由Oracle Corporation的秘密实验室开发。 这种排序是JDK的一部分，也是Dual-Pivot Quicksort的一部分。 它用于对小数组（最多47个元素）进行排序，并对大数组的小区域进行排序。 <br><br><img width="684" height="95" src="https://habrastorage.org/webt/fi/iv/q6/fiivq621vdspxj9bxxq0pqe3jne.gif"><br><br> 不会立即将两个相邻元素发送到缓冲区。 首先，插入该对中较大的元素，然后紧接着将简单的插入方法应用于该对中较小的元素。 <br><br> 它有什么作用？ 节省处理一对较小物品的费用。 对他而言，仅在数组的排序部分上执行对插入点和插入本身的搜索，该部分不包括用于处理该对中较大元素的排序区域。 这之所以成为可能，是因为在外循环的一次遍历中，一个又一个立即处理较大和较小的元素。 <br><br> 这不会影响平均时间复杂度（它仍然保持等于<nobr>O（ <b>n <sup>2</sup></b> ）），</nobr>但是，成对的插入要比普通插入快一点。 <br><br> 我举例说明了Python中的算法，但在这里给出了Java的原始源（为了可读性而修改）： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = left; ++left &lt;= right; k = ++left) { <span class="hljs-comment"><span class="hljs-comment">//   ́  //     int a1 = a[k], a2 = a[left]; if (a1 &lt; a2) { a2 = a1; a1 = a[left]; } //     while (a1 &lt; a[--k]) { a[k + 2] = a[k]; } a[++k + 1] = a1; //     while (a2 &lt; a[--k]) { a[k + 1] = a[k]; } a[k + 1] = a2; } // ,       //       int last = a[right]; while (last &lt; a[--right]) { a[right + 1] = a[right]; } a[right + 1] = last;</span></span></code> </pre> <br><br><h2> 贝壳排序 </h2><br><img width="684" height="95" src="https://habrastorage.org/webt/ig/rb/aa/igrbaajcuoxuj4q-l-38x0qsoq4.gif"><br><br> 该算法在确定阵列的哪一部分被视为已排序方面具有非常机智的方法。 在简单插入中，所有内容都很简单：从当前元素开始，左侧的所有内容都已排序，右侧的所有内容尚未排序。 与简单插入不同，Shell排序不会尝试立即在元素左侧形成数组的严格排序部分。 它在元素左侧创建数组的<em>几乎排序的</em>部分，并且足够快地完成它。 <br><br>  Shell排序将当前元素扔到缓冲区中，并将其与数组的左侧进行比较。 如果在左侧找到较大的元素，则会将其向右移动，为插入留出空间。 但是同时，它并不占据整个左侧部分，而只是占据其中的一部分元素，这些元素之间彼此隔开一定的距离。 这样的系统使您可以将元素快速插入到应放置元素的数组区域中。 <br><br> 随着主循环的每次迭代，此距离逐渐减小，并且当它等于1时，此时Shell排序将变成具有简单插入的经典排序，并提供给几乎已排序的数组处理。 几乎排序的数组排序可快速插入到完全排序的转换中。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> inc = len(data) // <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> inc: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, el <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(data): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &gt;= inc <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> data[i - inc] &gt; el: data[i] = data[i - inc] i -= inc data[i] = el inc = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> inc == <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> int(inc * <span class="hljs-number"><span class="hljs-number">5.0</span></span> / <span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br> 按照类似原理进行梳状排序可改善气泡排序，因此<nobr>O（ <b>n <sup>2</sup></b> ）</nobr>的算法的时间复杂度立即上升到<nobr>O（ <b>n</b> log <b>n</b> ）</nobr> 。  Shell，壳牌没有设法重复这一壮举-最佳时间复杂度达到<nobr>O（ <b>n</b> log <sup>2</sup> <b>n</b> ）</nobr> 。 <br><br> 关于分类Shell的文章已经写了好几篇，所以我们不会因信息过多而继续前进。 <br><br><h2> 树分类 </h2><br><img width="570" height="277" src="https://habrastorage.org/webt/uo/6e/d8/uo6ed8lcpyvdpg9fzfwsye2pnuu.gif"><br><br> 由于增加了内存，使用树进行排序可以快速解决将另一个元素添加到数组的排序部分的问题。 此外，二叉树充当数组的排序部分。 遍历元素时，实际上是在动态地形成一棵树。 <br><br> 首先将元素与根进行比较，然后根据以下原理将其与更多的嵌套节点进行比较：如果元素小于节点，则我们沿着左边的分支向下移动，如果不小于，则沿着右边的分支。 然后可以轻松地规避通过这样的规则构造的树，以便从具有较低值的节点移动到具有较大值的节点（从而使所有元素按升序排列）。 <br><br> 此处解决了通过插入进行排序的主要障碍（将元素插入到数组排序部分中的位置中的成本），构造工作非常迅速。 无论如何，要释放插入点，就不必像先前的算法那样缓慢移动元素的商队。 看来这里是最好的分类插入。 但是有一个问题。 <br><br> 如上面的动画三段所示，当您获得一棵美丽的对称圣诞树（所谓的完美平衡树）时，插入会很快发生，因为在这种情况下，该树的嵌套级别最低。 但是很少从随机数组中获得平衡的（或至少接近该结构）结构。 而且这棵树很可能会是不完美且不平衡的-会出现扭曲，地平线上乱七八糟和水平过多的情况。 <br><br>  <em>值从1到10的随机数组。按此顺序的元素将生成不平衡的二叉树：</em> <br><br><img width="564" height="384" src="https://habrastorage.org/webt/io/mj/25/iomj25xs6mtppplwt02gdgmbsiq.png"><br><br> 一棵树不足以建造，它仍然需要被规避。 失衡越多-树遍历算法越容易滑动。 正如星星所说，随机阵列既可以产生丑陋的障碍（更有可能），又可以产生树状的分形。 <br><br>  <em>元素的值相同，但是顺序不同。</em>  <em>生成一个平衡的二叉树：</em> <br><br><img height="311" src="https://habrastorage.org/webt/sc/k8/_y/sck8_y-fbutnw-ulr6bg1rg4nbg.png"><br><img align="left" width="218" height="90" src="https://habrastorage.org/webt/ah/eu/wi/aheuwi2kiu2l361frutx_qpvawq.png"><br clear="right">  <em>在美丽的樱花上</em> <em><br></em>  <em>花瓣不足：</em> <em><br></em>  <em>一棵几十个的二叉树。</em> <br><br> 不平衡树的问题通过倒排排序解决，倒排排序使用一种特殊的二叉搜索树-展开树。 这是一棵奇妙的变压器树，它在每次操作后都以平衡状态重建。 关于它，将另作文章。 到那时，我将为Tree Sort和Splay sort准备Python实现。 <br><br> 好吧，好吧，我们简要地介绍了最受欢迎的排序插件。 我们都从学校知道简单的插入，shell和二叉树。 现在考虑这个类别的其他代表，但没有那么广为人知。 <br><br>  <b>Wiki / Wiki-</b> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">插入</a> ，</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Shell</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Shell</a> ，</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">树</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">树</a></nobr> <br><br><h3> 系列文章： </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Excel应用程序AlgoLab.xlsm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">交换排序</a> </li><li>  <b>插入排序</b> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">图书管理员排序</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">纸牌排序</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">排序“河内塔”</a> </li><li> 年轻表排序 </li><li> 反转排序 </li><li> 插入排序比较 </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">按选择排序</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">合并排序</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">按分布排序</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">混合排序</a> </li></ul><br> 谁使用AlgoLab-我建议更新文件。 我向该应用程序添加了简单的二进制搜索插入和成对插入。 他还完全重写了Shell的可视化效果（在以前的版本中没有什么需要理解的），并且在将元素插入二叉树时向父分支添加了突出显示。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN415935/">https://habr.com/ru/post/zh-CN415935/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN415923/index.html">Unity慢吗？ 小心LINQ</a></li>
<li><a href="../zh-CN415925/index.html">万事达获得专利的匿名区块链技术</a></li>
<li><a href="../zh-CN415927/index.html">工业灯Breeze 50</a></li>
<li><a href="../zh-CN415929/index.html">人工智能架构优化：竞赛开始</a></li>
<li><a href="../zh-CN415933/index.html">如何构建自己动手的IIoT架构</a></li>
<li><a href="../zh-CN415937/index.html">日本私人火箭MOMO-2在发射台爆炸</a></li>
<li><a href="../zh-CN415939/index.html">使用Spark GraphX进行分布式图形处理</a></li>
<li><a href="../zh-CN415941/index.html">我们如何尝试找出条形码却一无所知</a></li>
<li><a href="../zh-CN415943/index.html">“游戏开发和娱乐理论”：Raff Coster著作的重点</a></li>
<li><a href="../zh-CN415945/index.html">带有Aliexpress的新中文PLC：Wecon LX3VP / LX3VE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>