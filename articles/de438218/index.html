<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèª üôâ üö¢ OpenSceneGraph: Ereignisbehandlung üëô üë®üèΩ‚Äçü§ù‚Äçüë®üèº üòç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Eine der Eigenschaften der C ++ - Sprache, f√ºr die sie h√§ufig kritisiert wird, ist das Fehlen eines Mechanismus zur Ereignisverarbeitung ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Ereignisbehandlung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438218/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="Bild"><br><h1>  Einf√ºhrung </h1><br>  Eine der Eigenschaften der C ++ - Sprache, f√ºr die sie h√§ufig kritisiert wird, ist das Fehlen eines Mechanismus zur Ereignisverarbeitung im Standard.  In der Zwischenzeit ist dieser Mechanismus eine der Hauptmethoden f√ºr die Interaktion einiger Softwarekomponenten mit anderen Softwarekomponenten und Hardware und wird auf der Ebene eines bestimmten Betriebssystems implementiert.  Nat√ºrlich hat jede Plattform ihre eigenen Nuancen bei der Implementierung des beschriebenen Mechanismus. <br><br>  In Verbindung mit all dem muss bei der Entwicklung in C ++ die Ereignisverarbeitung auf die eine oder andere Weise implementiert werden, die mithilfe von Bibliotheken und Frameworks von Drittanbietern gel√∂st wird.  Das bekannte Qt-Framework bietet einen Signal- und Slot-Mechanismus zum Organisieren der Interaktion von Klassen, die von QObject geerbt wurden.  Die Implementierung von Ereignissen ist auch in der Boost-Bibliothek vorhanden.  Und nat√ºrlich k√∂nnte die OpenSceneGraph-Engine nicht auf ein eigenes ‚ÄûFahrrad‚Äú verzichten, dessen Anwendung im Artikel erl√§utert wird. <br><a name="habracut"></a><br>  OSG ist eine abstrakte Grafikbibliothek.  Einerseits abstrahiert es von der OpenGL-Prozedurschnittstelle und bietet dem Entwickler eine Reihe von Klassen, die die gesamte Mechanik der OpneGL-API kapseln.  Andererseits abstrahiert es auch von einer bestimmten grafischen Benutzeroberfl√§che, da die Implementierungsans√§tze f√ºr verschiedene Plattformen unterschiedlich sind und Funktionen sogar innerhalb derselben Plattform aufweisen (z. B. MFC, Qt, .Net f√ºr Windows). <br><br>  Unabh√§ngig von der Plattform wird aus Sicht der Anwendung die Interaktion des Benutzers mit der grafischen Oberfl√§che darauf reduziert, Elemente einer Folge von Ereignissen zu generieren, die dann innerhalb der Anwendung verarbeitet werden.  Die meisten grafischen Frameworks verwenden diesen Ansatz, aber selbst innerhalb derselben Plattform sind sie leider nicht miteinander kompatibel. <br><br>  Aus diesem Grund bietet OSG eine eigene Basisoberfl√§che f√ºr die Verarbeitung von Widget-Widget-Ereignissen und Benutzereingaben basierend auf der Klasse osgGA :: GUIEventHandler.  Dieser Handler kann durch Aufrufen der Methode addEventHandler () an den Viewer angeh√§ngt und durch die Methode removeEventHandler () entfernt werden.  Nat√ºrlich sollte die konkrete Handlerklasse von der osgGA :: GUIEventHandler-Klasse geerbt und die handle () -Methode darin neu definiert werden.  Diese Methode akzeptiert zwei Argumente: osgGA :: GUIEventAdapter, der die Warteschlange der Ereignisse aus der GUI enth√§lt, und osg :: GUIActionAdepter, die f√ºr das Feedback verwendet werden.  Typisch in der Definition ist ein solches Design <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdepter &amp;aa)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        }</span></span></code> </pre> <br>  Mit dem Parameter osgGA :: GUIActionAdapter kann der Entwickler die GUI auffordern, als Reaktion auf das Ereignis Ma√ünahmen zu ergreifen.  In den meisten F√§llen ist ein Betrachter von diesem Parameter betroffen, dessen Zeiger durch dynamische Zeigerkonvertierung erhalten werden kann <br><br><pre> <code class="cpp hljs">osgViewer::Viewer* viewer = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osgViewer::Viewer *&gt;(&amp;aa);</code> </pre><br><h1>  1. Behandlung von Tastatur- und Mausereignissen </h1><br>  Die Klasse osgGA :: GUIEventAdapter () verwaltet alle von OSG unterst√ºtzten Ereignistypen und stellt Daten zum Festlegen und Abrufen ihrer Parameter bereit.  Die Methode getEventType () gibt das aktuelle GUI-Ereignis zur√ºck, das in der Ereigniswarteschlange enthalten ist.  Jedes Mal, wenn Sie die handle () -Methode des Handlers √ºberschreiben, sollten Sie beim Aufrufen dieser Methoden diesen Getter verwenden, um das Ereignis zu empfangen und seinen Typ zu bestimmen. <br><br>  In der folgenden Tabelle werden alle verf√ºgbaren Ereignisse beschrieben. <br><br><table><thead><tr><th>  Ereignistyp </th><th>  Beschreibung </th><th>  Methoden zum Abrufen von Ereignisdaten </th></tr></thead><tbody><tr><td>  PUSH / RELEASE / DOUBLECLICK </td><td>  Klicken / Loslassen und Doppelklicken mit der Maus </td><td>  getX (), getY () - Ermittelt die Cursorposition.  getButton () - Code der gedr√ºckten Taste (LEFT_MOUSE_BUTTON, RIGHT_MOUSE_BUTTON, MIDDLE_MOUSE_BUTTON </td></tr><tr><td>  Scrol </td><td>  Scrolling Mausrad (e) </td><td>  getScrollingMotion () - gibt SCROOL_UP, SCROLL_DOWN, SCROLL_LEFT, SCROLL_RIGHT zur√ºck </td></tr><tr><td>  DRAG </td><td>  Maus ziehen </td><td>  getX (), getY () - Cursorposition;  getButtonMask () - Werte √§hnlich wie getButton () </td></tr><tr><td>  BEWEGEN </td><td>  Maus bewegen </td><td>  getX (), getY () - Cursorposition </td></tr><tr><td>  KEYDOWN / KEYUP </td><td>  Dr√ºcken / Loslassen einer Taste auf einer Tastatur </td><td>  getKey () - ASCII-Code der gedr√ºckten Taste oder der Wert des Key_Symbol-Enumerators (z. B. KEY_BackSpace) </td></tr><tr><td>  RAHMEN </td><td>  Ereignis, das beim Rendern eines Frames generiert wird </td><td>  keine Eingabe </td></tr><tr><td>  USER </td><td>  Benutzerdefiniertes Ereignis </td><td>  getUserDataPointer () - gibt einen Zeiger auf einen Benutzerdatenpuffer zur√ºck (der Puffer wird von einem intelligenten Zeiger gesteuert) </td></tr></tbody></table><br>  Es gibt auch eine getModKeyMask () -Methode zum Abrufen von Informationen √ºber die gedr√ºckte Modifizierertaste (gibt Werte der Form MODKEY_CTRL, MODKEY_SHIFT, MODKEY_ALT usw. zur√ºck), mit der Sie Tastenkombinationen verarbeiten k√∂nnen, die Modifikatoren verwenden <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ea.getModKeyMask() == osgGA::GUIEventAdapter::MODKEY_CTRL) { <span class="hljs-comment"><span class="hljs-comment">//    Ctrl }</span></span></code> </pre><br>  Beachten Sie, dass Setter-Methoden wie setX (), setY (), setEventType () usw.  Wird im handle () - Handler nicht verwendet.  Sie werden vom grafischen OSG-Fenstersystem auf niedriger Ebene aufgerufen, um das Ereignis in die Warteschlange zu stellen. <br><br><h1>  2. Wir steuern die Cessna √ºber die Tastatur </h1><br>  Wir wissen bereits, wie Szenenobjekte durch die osg :: MatrixTransform-Klassen transformiert werden.  Wir haben verschiedene Arten von Animationen mit den Klassen osg :: AnimationPath und osg :: Animation untersucht.  F√ºr die Interaktivit√§t einer Anwendung (z. B. eines Spiels) reichen Animation und Transformationen jedoch eindeutig nicht aus.  Der n√§chste Schritt besteht darin, die Position von Objekten auf der B√ºhne √ºber Benutzereingabeger√§te zu steuern.  Versuchen wir, das Management an unserer geliebten Cessna zu befestigen. <br><br><div class="spoiler">  <b class="spoiler_title">Tastaturbeispiel</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgGA/GUIEventHandler&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class ModelController : public osgGA::GUIEventHandler { public: ModelController( osg::MatrixTransform *node ) : _model(node) {} virtual bool handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa); protected: osg::ref_ptr&lt;osg::MatrixTransform&gt; _model; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ bool ModelController::handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { (void) aa; if (!_model.valid()) return false; osg::Matrix matrix = _model-&gt;getMatrix(); switch (ea.getEventType()) { case osgGA::GUIEventAdapter::KEYDOWN: switch (ea.getKey()) { case 'a': case 'A': matrix *= osg::Matrix::rotate(-0.1, osg::Z_AXIS); break; case 'd': case 'D': matrix *= osg::Matrix::rotate( 0.1, osg::Z_AXIS); break; case 'w': case 'W': matrix *= osg::Matrix::rotate(-0.1, osg::X_AXIS); break; case 's': case 'S': matrix *= osg::Matrix::rotate( 0.1, osg::X_AXIS); break; default: break; } _model-&gt;setMatrix(matrix); break; default: break; } return true; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; mt = new osg::MatrixTransform; mt-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(mt.get()); osg::ref_ptr&lt;ModelController&gt; mcontrol = new ModelController(mt.get()); osgViewer::Viewer viewer; viewer.addEventHandler(mcontrol.get()); viewer.getCamera()-&gt;setViewMatrixAsLookAt( osg::Vec3(0.0f, -100.0f, 0.0f), osg::Vec3(), osg::Z_AXIS ); viewer.getCamera()-&gt;setAllowEventFocus(false); viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Um dieses Problem zu l√∂sen, schreiben wir eine Klasse f√ºr Eingabeereignishandler <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelController</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osgGA::GUIEventHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ModelController( osg::MatrixTransform *node ) : _model(node) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: osg::ref_ptr&lt;osg::MatrixTransform&gt; _model; };</code> </pre><br>  Beim Erstellen dieser Klasse als Parameter wird ein Zeiger auf den Transformationsknoten √ºbergeben, auf den im Handler reagiert wird.  Die handle () - Handlermethode selbst wird wie folgt neu definiert <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ModelController::handle(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) aa; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_model.valid()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; osg::Matrix matrix = _model-&gt;getMatrix(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ea.getEventType()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> osgGA::GUIEventAdapter::KEYDOWN: <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ea.getKey()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span>: matrix *= osg::Matrix::rotate(<span class="hljs-number"><span class="hljs-number">-0.1</span></span>, osg::Z_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'d'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'D'</span></span>: matrix *= osg::Matrix::rotate( <span class="hljs-number"><span class="hljs-number">0.1</span></span>, osg::Z_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'w'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'W'</span></span>: matrix *= osg::Matrix::rotate(<span class="hljs-number"><span class="hljs-number">-0.1</span></span>, osg::X_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'s'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'S'</span></span>: matrix *= osg::Matrix::rotate( <span class="hljs-number"><span class="hljs-number">0.1</span></span>, osg::X_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } _model-&gt;setMatrix(matrix); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Unter den wesentlichen Details seiner Implementierung sollte beachtet werden, dass wir zuerst die Transformationsmatrix von dem Knoten erhalten m√ºssen, den wir steuern <br><br><pre> <code class="cpp hljs">osg::Matrix matrix = _model-&gt;getMatrix();</code> </pre><br>  Als n√§chstes analysieren zwei verschachtelte switch () -Anweisungen die Art des Ereignisses (Tastenanschlag) und den Code der gedr√ºckten Taste.  Abh√§ngig vom Code der gedr√ºckten Taste wird die aktuelle Transformationsmatrix mit einer zus√§tzlichen Rotationsmatrix um die entsprechende Achse multipliziert <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span>: matrix *= osg::Matrix::rotate(<span class="hljs-number"><span class="hljs-number">-0.1</span></span>, osg::Z_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br>  - Drehen Sie die Ebene mit einem Gierwinkel von -0,1 Bogenma√ü, wenn Sie die Taste "A" dr√ºcken. <br><br>  Vergessen Sie nach der Verarbeitung der Tastenanschl√§ge nicht, eine neue Transformationsmatrix auf den Transformationsknoten anzuwenden <br><br><pre> <code class="cpp hljs">_model-&gt;setMatrix(matrix);</code> </pre><br>  Laden Sie in der Funktion main () das Flugzeugmodell und erstellen Sie einen √ºbergeordneten Transformationsknoten daf√ºr. F√ºgen Sie den resultierenden Untergraphen zum Stammknoten der Szene hinzu <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>); osg::ref_ptr&lt;osg::MatrixTransform&gt; mt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; mt-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(mt.get());</code> </pre><br>  Erstellen und initialisieren Sie den Benutzereingabehandler <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;ModelController&gt; mcontrol = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ModelController(mt.get());</code> </pre><br>  Erstellen Sie einen Viewer, indem Sie unseren Handler hinzuf√ºgen <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.addEventHandler(mcontrol.get());</code> </pre><br>  Richten Sie die Kameraansichtsmatrix ein <br><br><pre> <code class="cpp hljs">viewer.getCamera()-&gt;setViewMatrixAsLookAt( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-100.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), osg::Vec3(), osg::Z_AXIS );</code> </pre><br>  Verbieten Sie der Kamera, Ereignisse von Eingabeger√§ten zu empfangen <br><br><pre> <code class="cpp hljs">viewer.getCamera()-&gt;setAllowEventFocus(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br>  Wenn dies nicht erfolgt, f√§ngt der an der Kamera h√§ngende Handler standardm√§√üig alle Benutzereingaben ab und st√∂rt unseren Handler.  Wir setzen die Szenendaten auf den Viewer und f√ºhren sie aus <br><br><pre> <code class="cpp hljs">viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  Nachdem wir das Programm gestartet haben, k√∂nnen wir die Ausrichtung des Flugzeugs im Weltraum durch Dr√ºcken der Tasten A, D, W und S steuern. <br><br><img src="https://habrastorage.org/webt/a0/gu/od/a0guoddsokpfkthvefo07tfn1h4.gif"><br><br>  Eine interessante Frage ist, was die handle () -Methode beim Beenden zur√ºckgeben soll.  Wenn true zur√ºckgegeben wird, geben wir OSG an, dann haben wir bereits Eingabeereignisse verarbeitet und eine weitere Verarbeitung ist nicht erforderlich.  In den meisten F√§llen passt dieses Verhalten nicht zu uns. Daher empfiehlt es sich, false vom Handler zur√ºckzugeben, um die Verarbeitung von Ereignissen durch andere Handler nicht zu unterbrechen, wenn diese an andere Knoten in der Szene angeh√§ngt sind. <br><br><h1>  3. Verwendung von Besuchern in der Ereignisverarbeitung </h1><br>  √Ñhnlich wie es beim Durchlaufen eines Szenendiagramms beim Aktualisieren implementiert wird, unterst√ºtzt OSG R√ºckrufe zur Behandlung von Ereignissen, die Knoten und geometrischen Objekten zugeordnet werden k√∂nnen.  Dazu werden Aufrufe von setEventCallback () und addEventCallback () verwendet, die als Parameter einen Zeiger auf das untergeordnete osg :: NodeCallback verwenden.  Um Ereignisse im Operator operator () zu empfangen, k√∂nnen wir den an den Site-Besucher √ºbergebenen Zeiger in einen Zeiger auf osgGA :: EventVisitor konvertieren, beispielsweise wie folgt <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgGA/EventVisitor&gt; ... void operator()( osg::Node *node, osg::NodeVisitor *nv ) { std::list&lt;osg::ref_ptr&lt;osgGA::GUIEventAdapter&gt;&gt; events; osgGA::EventVisitor *ev = dynamic_cast&lt;osgGA::EventVisitor *&gt;(nv); if (ev) { events = ev-&gt;getEvents(); //       } }</span></span></span></span></code> </pre><br><h1>  4. Erstellung und Verarbeitung von benutzerdefinierten Ereignissen </h1><br>  OSG verwendet eine interne Ereigniswarteschlange (FIFO).  Ereignisse am Anfang der Warteschlange werden verarbeitet und daraus gel√∂scht.  Neu generierte Ereignisse werden am Ende der Warteschlange platziert.  Die handle () -Methode jedes Ereignishandlers wird so oft ausgef√ºhrt, wie sich Ereignisse in der Warteschlange befinden.  Die Ereigniswarteschlange wird von der Klasse osgGA :: EventQueue beschrieben, mit der Sie unter anderem jederzeit ein Ereignis in die Warteschlange stellen k√∂nnen, indem Sie die Methode addEvent () aufrufen.  Das Argument f√ºr diese Methode ist ein Zeiger auf osgGA :: GUIEventAdapter, der mit setEventType () -Methoden usw. auf ein bestimmtes Verhalten festgelegt werden kann. <br><br>  Eine der Methoden der osgGA :: EventQueue-Klasse ist userEvent (), mit der ein Benutzerereignis festgelegt wird, indem es Benutzerdaten zugeordnet wird, auf die ein Zeiger als Parameter √ºbergeben wird.  Diese Daten k√∂nnen verwendet werden, um jedes benutzerdefinierte Ereignis darzustellen. <br><br>  Eigene Instanz der Ereigniswarteschlange kann nicht erstellt werden.  Diese Instanz wurde bereits erstellt und an die Viewer-Instanz angeh√§ngt, sodass Sie nur einen Zeiger auf diesen Singleton erhalten k√∂nnen <br><br><pre> <code class="cpp hljs">viewer.getEventQueue()-&gt;userEvent(data);</code> </pre><br>  Benutzerdaten sind ein Objekt des Erben von osg :: Referenced, dh Sie k√∂nnen einen intelligenten Zeiger darauf erstellen. <br><br>  Wenn ein benutzerdefiniertes Ereignis empfangen wird, kann der Entwickler Daten daraus extrahieren, indem er die Methode getUserData () aufruft und sie nach eigenem Ermessen verarbeitet. <br><br><h1>  5. Implementierung des Benutzer-Timers </h1><br>  Viele Bibliotheken und Frameworks, die die GUI implementieren, bieten einen Klassenentwickler zum Implementieren von Timern, die nach einem bestimmten Zeitintervall ein Ereignis generieren.  OSG enth√§lt keine regul√§ren Mittel zum Implementieren von Timern. Versuchen wir daher, eine Art Timer selbst zu implementieren, indem wir √ºber die Schnittstelle benutzerdefinierte Ereignisse erstellen. <br><br>  Worauf k√∂nnen wir uns bei der L√∂sung dieses Problems verlassen?  F√ºr ein bestimmtes periodisches Ereignis, das vom Render st√§ndig generiert wird, z. B. in FRAME, das Ereignis des Zeichnens des n√§chsten Frames.  Daf√ºr verwenden wir das gleiche Beispiel mit dem Umschalten des Cessna-Modells von normal auf brennend. <br><br><div class="spoiler">  <b class="spoiler_title">Timer Beispiel</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgGA/GUIEventHandler&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;iostream&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ struct TimerInfo : public osg::Referenced { TimerInfo(unsigned int c) : _count(c) {} unsigned int _count; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class TimerHandler : public osgGA::GUIEventHandler { public: TimerHandler(osg::Switch *sw, unsigned int interval = 1000) : _switch(sw) , _count(0) , _startTime(0.0) , _interval(interval) , _time(0) { } virtual bool handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa); protected: osg::ref_ptr&lt;osg::Switch&gt; _switch; unsigned int _count; double _startTime; unsigned int _interval; unsigned int _time; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ bool TimerHandler::handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { switch (ea.getEventType()) { case osgGA::GUIEventAdapter::FRAME: { osgViewer::Viewer *viewer = dynamic_cast&lt;osgViewer::Viewer *&gt;(&amp;aa); if (!viewer) break; double time = viewer-&gt;getFrameStamp()-&gt;getReferenceTime(); unsigned int delta = static_cast&lt;unsigned int&gt;( (time - _startTime) * 1000.0); _startTime = time; if ( (_count &gt;= _interval) || (_time == 0) ) { viewer-&gt;getEventQueue()-&gt;userEvent(new TimerInfo(_time)); _count = 0; } _count += delta; _time += delta; break; } case osgGA::GUIEventAdapter::USER: if (_switch.valid()) { const TimerInfo *ti = dynamic_cast&lt;const TimerInfo *&gt;(ea.getUserData()); std::cout &lt;&lt; "Timer event at: " &lt;&lt; ti-&gt;_count &lt;&lt; std::endl; _switch-&gt;setValue(0, !_switch-&gt;getValue(0)); _switch-&gt;setValue(1, !_switch-&gt;getValue(1)); } break; default: break; } return false; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;osg::Switch&gt; root = new osg::Switch; root-&gt;addChild(model1.get(), true); root-&gt;addChild(model2.get(), false); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); viewer.addEventHandler(new TimerHandler(root.get(), 1000)); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Lassen Sie uns zun√§chst das Format der in der Benutzernachricht gesendeten Daten bestimmen und diese als Struktur definieren <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TimerInfo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::Referenced { TimerInfo(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c) : _count(c) {} <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count; };</code> </pre><br>  Der Parameter _count enth√§lt die ganzzahlige Anzahl von Millisekunden, die seit dem Start des Programms bis zum n√§chsten Timer-Ereignis vergangen sind.  Die Struktur erbt von der Klasse osg :: Referenced, sodass sie √ºber intelligente OSG-Zeiger gesteuert werden kann.  Erstellen Sie nun einen Ereignishandler <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TimerHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osgGA::GUIEventHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TimerHandler(osg::Switch *sw, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> interval = <span class="hljs-number"><span class="hljs-number">1000</span></span>) : _switch(sw) , _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) , _startTime(<span class="hljs-number"><span class="hljs-number">0.0</span></span>) , _interval(interval) , _time(<span class="hljs-number"><span class="hljs-number">0</span></span>) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: osg::ref_ptr&lt;osg::Switch&gt; _switch; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> _startTime; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _interval; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _time; };</code> </pre><br>  Dieser Handler hat mehrere spezifische gesch√ºtzte Mitglieder.  Die Variable _switch gibt einen Knoten an, der Flugzeugmodelle wechselt.  _count - Der relative Countdown der seit der letzten Generation des Timer-Ereignisses verstrichenen Zeit dient zum Z√§hlen der Zeitintervalle.  _startTime - eine tempor√§re Variable zum Speichern des vorherigen Countdowns, die vom Viewer ausgef√ºhrt wird;  _time - Die Gesamtbetriebszeit des Programms in Millisekunden.  Der Klassenkonstruktor akzeptiert einen Schaltknoten als Parameter und optional das erforderliche Zeitintervall f√ºr den Betrieb des Schaltzeitgebers. <br><br>  In dieser Klasse √ºberschreiben wir die handle () -Methode <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> TimerHandler::handle(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ea.getEventType()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> osgGA::GUIEventAdapter::FRAME: { osgViewer::Viewer *viewer = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osgViewer::Viewer *&gt;(&amp;aa); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!viewer) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> time = viewer-&gt;getFrameStamp()-&gt;getReferenceTime(); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( (time - _startTime) * <span class="hljs-number"><span class="hljs-number">1000.0</span></span>); _startTime = time; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (_count &gt;= _interval) || (_time == <span class="hljs-number"><span class="hljs-number">0</span></span>) ) { viewer-&gt;getEventQueue()-&gt;userEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimerInfo(_time)); _count = <span class="hljs-number"><span class="hljs-number">0</span></span>; } _count += delta; _time += delta; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> osgGA::GUIEventAdapter::USER: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_switch.valid()) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TimerInfo *ti = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TimerInfo *&gt;(ea.getUserData()); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Timer event at: "</span></span> &lt;&lt; ti-&gt;_count &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _switch-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !_switch-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); _switch-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !_switch-&gt;getValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Hier analysieren wir die Art der empfangenen Nachricht.  Wenn es sich um FRAME handelt, werden die folgenden Aktionen ausgef√ºhrt: <br><ol><li>  Holen Sie sich einen Zeiger auf den Betrachter <br></li></ol><br><pre> <code class="cpp hljs">osgViewer::Viewer *viewer = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osgViewer::Viewer *&gt;(&amp;aa);</code> </pre><br><ol><li>  Lesen Sie nach Erhalt des richtigen Zeigers die seit dem Start des Programms verstrichene Zeit ab <br></li></ol><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> time = viewer-&gt;getFrameStamp()-&gt;getReferenceTime();</code> </pre><br>  Berechnen Sie den Zeitaufwand f√ºr das Rendern eines Frames in Millisekunden <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( (time - _startTime) * <span class="hljs-number"><span class="hljs-number">1000.0</span></span>);</code> </pre><br>  und erinnere dich an die aktuelle Zeitz√§hlung <br><br><pre> <code class="cpp hljs">_startTime = time;</code> </pre><br>  Wenn der Wert des Z√§hlers _count das erforderliche Zeitintervall √ºberschritten hat (oder dies der erste Aufruf ist, wenn _time noch Null ist), stellen wir die Benutzernachricht in die Warteschlange und √ºbergeben in der obigen Struktur die Programmzeit in Millisekunden.  Der Z√§hler _count wird auf Null zur√ºckgesetzt <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (_count &gt;= _interval) || (_time == <span class="hljs-number"><span class="hljs-number">0</span></span>) ) { viewer-&gt;getEventQueue()-&gt;userEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimerInfo(_time)); _count = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Unabh√§ngig vom Wert von _count m√ºssen wir ihn und _time um die Verz√∂gerung erh√∂hen, die zum Zeichnen eines Frames erforderlich ist <br><br><pre> <code class="cpp hljs">_count += delta; _time += delta;</code> </pre><br>  Auf diese Weise wird das Timer-Ereignis generiert.  Die Ereignisbehandlung wird wie folgt implementiert <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> osgGA::GUIEventAdapter::USER: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_switch.valid()) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TimerInfo *ti = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TimerInfo *&gt;(ea.getUserData()); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Timer event at: "</span></span> &lt;&lt; ti-&gt;_count &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _switch-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !_switch-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); _switch-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !_switch-&gt;getValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br>  Hier √ºberpr√ºfen wir die G√ºltigkeit des Zeigers auf den Vermittlungsknoten, subtrahieren die Daten vom Ereignis, das von der TimerInfo-Struktur f√ºhrt, zeigen den Inhalt der Struktur auf dem Bildschirm an und wechseln den Zustand des Knotens. <br><br>  Der Code in der Funktion main () √§hnelt dem Code in den beiden vorherigen Schaltbeispielen, mit dem Unterschied, dass wir in diesem Fall einen Ereignishandler an den Viewer h√§ngen <br><br><pre> <code class="cpp hljs">viewer.addEventHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimerHandler(root.get(), <span class="hljs-number"><span class="hljs-number">1000</span></span>));</code> </pre><br>  √úbergeben des Zeigers an den Wurzelknoten und des erforderlichen Schaltintervalls in Millisekunden an den Handlerkonstruktor.  Wenn Sie das Beispiel ausf√ºhren, werden Sie sehen, dass die Modelle im Abstand von einer Sekunde wechseln, und in der Konsole finden wir die Ausgabe der Zeiten, zu denen der Wechsel stattgefunden hat <br><br><pre> <code class="plaintext hljs">Timer event at: 0 Timer event at: 1000 Timer event at: 2009 Timer event at: 3017 Timer event at: 4025 Timer event at: 5033</code> </pre><br>  Ein benutzerdefiniertes Ereignis kann jederzeit w√§hrend der Ausf√ºhrung des Programms generiert werden, und zwar nicht nur beim Empfang des FRAME-Ereignisses. Dies bietet einen sehr flexiblen Mechanismus f√ºr den Datenaustausch zwischen Teilen des Programms und erm√∂glicht die Verarbeitung von Signalen von nicht standardm√§√üigen Eingabeger√§ten wie z. B. Joysticks oder VR-Handschuhen. <br><br>  <i>Fortsetzung folgt...</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438218/">https://habr.com/ru/post/de438218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438204/index.html">Schnelles Compiler-Ger√§t. Teil 1</a></li>
<li><a href="../de438206/index.html">26 Empfehlungen f√ºr die Verwendung des var-Typs in Java</a></li>
<li><a href="../de438210/index.html">Zivilisation der Quellen, 2/5</a></li>
<li><a href="../de438212/index.html">Proof of Concept: Die √úberpr√ºfung der ML-Implementierung ist die Kerze wert</a></li>
<li><a href="../de438214/index.html">US-Tech-Startups werden 2019 neuen staatlichen Kontrollen ausgesetzt sein</a></li>
<li><a href="../de438224/index.html">Regierungsviertel. Pilot</a></li>
<li><a href="../de438226/index.html">Fehlerbehebung bei der Installation von .NET Framework 3.5 unter Windows 8 in einem Netzwerk mit WSUS</a></li>
<li><a href="../de438228/index.html">Haben Sie transparente Videobrillen mit HDMI und USB-C bestellt? Treffen Sie: Epson Moverio BT-35E</a></li>
<li><a href="../de438230/index.html">√úbersetzung ‚ÄûBereiten Sie Ihre Anwendungen auf 64-Bit-Anforderungen vor‚Äú</a></li>
<li><a href="../de438234/index.html">Februar IT Events Digest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>