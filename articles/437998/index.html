<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèª ü¶ç üëì Fil√≥sofos gastron√≥micos "modernos" en C ++ a trav√©s de actores y CSP üõ¥ üç∏ üë®‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace alg√∫n tiempo, un enlace al art√≠culo "Fil√≥sofos de la comida moderna" se extendi√≥ sobre recursos como Reddit y HackerNews. El art√≠culo es interesa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fil√≥sofos gastron√≥micos "modernos" en C ++ a trav√©s de actores y CSP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437998/"><p>  Hace alg√∫n tiempo, un enlace al art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">"Fil√≥sofos de la comida moderna" se</a> extendi√≥ sobre recursos como Reddit y HackerNews.  El art√≠culo es interesante, muestra varias soluciones a esta tarea conocida, implementada en C ++ moderno utilizando un enfoque basado en tareas.  Si alguien a√∫n no ha le√≠do este art√≠culo, entonces tiene sentido pasar tiempo y leerlo. </p><br><p>  Sin embargo, no puedo decir que las soluciones presentadas en el art√≠culo me parecieron simples y comprensibles.  Esto probablemente se deba al uso de tareas.  Demasiados de ellos son creados y enviados a trav√©s de una variedad de despachadores / serializadores.  Por lo tanto, no siempre est√° claro d√≥nde, cu√°ndo y qu√© tareas se realizan. </p><br><p>  Adem√°s, el enfoque basado en tareas no es el √∫nico posible para resolver tales problemas.  ¬øPor qu√© no ver c√≥mo se resuelve la tarea de los "fil√≥sofos gastron√≥micos" a trav√©s de los modelos de actores y CSP? </p><br><p>  Por lo tanto, trat√© de buscar e implementar varias soluciones a este problema usando Actors y CSP.  El c√≥digo para estas soluciones se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">en el repositorio en GitHub</a> .  Y debajo del cortador, explicaciones y explicaciones, para que cualquiera que est√© interesado, sea bienvenido. </p><a name="habracut"></a><br><h1 id="neskolko-obschih-slov">  Algunas palabras comunes </h1><br><p>  No ten√≠a el objetivo de repetir exactamente las decisiones que se muestran en el mismo art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">"Fil√≥sofos de la cocina moderna"</a> , especialmente porque fundamentalmente no me gusta una cosa importante: de hecho, el fil√≥sofo no hace nada en esas decisiones.  √âl solo dice "Quiero comer", y luego alguien le da tenedores m√°gicamente o dice "ahora no funcionar√°". </p><br><p>  Est√° claro por qu√© el autor recurri√≥ a tal comportamiento: permite el uso de la misma implementaci√≥n del "fil√≥sofo" junto con diferentes implementaciones de los "protocolos".  Sin embargo, me parece personalmente que es m√°s interesante cuando el "fil√≥sofo" trata de tomar un tap√≥n primero, luego otro.  Y cuando el "fil√≥sofo" se ve obligado a manejar intentos fallidos de capturar los tenedores. </p><br><p>  Precisamente estas realizaciones de la tarea de los "fil√≥sofos gastron√≥micos" fueron las que intent√© hacer.  Al mismo tiempo, algunas soluciones utilizaron los mismos enfoques que en el art√≠culo mencionado (por ejemplo, implementado por los protocolos ForkLevelPhilosopherProtocol y WaiterFair). </p><br><p>  Constru√≠ mis decisiones sobre la base de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SObjectizer</a> , que es poco probable que sorprenda a quienes leyeron mis art√≠culos antes.  Si alguien a√∫n no ha o√≠do hablar de SObjectizer, en pocas palabras: este es uno de los pocos "marcos de actores" de OpenSource en vivo y en desarrollo para C ++ ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">CAF</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">QP / C ++</a> tambi√©n se pueden mencionar entre otros).  Espero que los ejemplos anteriores con mis comentarios sean lo suficientemente claros incluso para aquellos que no est√°n familiarizados con SObjectizer.  Si no, estar√© encantado de responder preguntas en los comentarios. </p><br><h1 id="resheniya-na-baze-aktorov">  Soluciones de actores </h1><br><p>  Comenzaremos la discusi√≥n de las soluciones implementadas con aquellas basadas en los actores.  Primero, considere la implementaci√≥n de la soluci√≥n Edsger Dijkstra, luego pase a otras soluciones y vea c√≥mo difiere el comportamiento de cada una de ellas. </p><br><h2 id="reshenie-deykstry">  La decisi√≥n de Dijkstra </h2><br><p>  Edsger Dijkstra, no solo formul√≥ la tarea de "comer phylophos" (Tony Hoar expres√≥ su formulaci√≥n utilizando "tenedores" y "spaghetti"), sino que tambi√©n propuso una soluci√≥n muy simple y hermosa.  A saber: los fil√≥sofos solo deben agarrar los tenedores para aumentar el n√∫mero de tenedores, y si el fil√≥sofo logr√≥ tomar el primer tenedor, entonces no lo soltar√° hasta que reciba el segundo tenedor. </p><br><p>  Por ejemplo, si un fil√≥sofo necesita usar tenedores con los n√∫meros 5 y 6, entonces un fil√≥sofo primero debe tomar un tenedor del n√∫mero 5. Solo entonces puede tomar un tenedor del n√∫mero 6. Por lo tanto, si los tenedores con n√∫meros m√°s bajos est√°n a la izquierda de los fil√≥sofos, entonces el fil√≥sofo debe primero tome el tenedor izquierdo y solo entonces puede tomar el tenedor derecho. </p><br><p>  El √∫ltimo fil√≥sofo de la lista, que tiene que lidiar con los tenedores en los n√∫meros (N-1) y 0, hace lo contrario: primero toma el tenedor derecho con el n√∫mero 0, y luego el tenedor izquierdo con el n√∫mero (N-1). </p><br><p>  Para implementar este enfoque, se requerir√°n dos tipos de actores: uno para los tenedores y otro para los fil√≥sofos.  Si el fil√≥sofo quiere comer, env√≠a un mensaje al actor tenedor correspondiente para capturar el tenedor, y el actor tenedor responde con un mensaje de respuesta. </p><br><p>  El c√≥digo para implementar este enfoque se puede ver <a href="" rel="nofollow">aqu√≠</a> . </p><br><h3 id="soobscheniya">  Mensajes </h3><br><p>  Antes de hablar sobre actores, debe mirar los mensajes que los actores intercambiar√°n: </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">take_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_who; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_philosopher_index; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">taken_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">put_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {};</code> </pre> <br><p>  Cuando el actor-fil√≥sofo quiere desconectarse, env√≠a el mensaje <code>take_t</code> al <code>take_t</code> fork, y el actor fork responde con el mensaje <code>taken_t</code> .  Cuando el actor-fil√≥sofo termina de comer y quiere volver a poner los tenedores sobre la mesa, env√≠a mensajes put_t a los tenedores <code>put_t</code> . </p><br><p>  En el mensaje <code>take_t</code> , el campo <code>take_t</code> denota el buz√≥n (tambi√©n conocido como mbox) del actor fil√≥sofo.  Se debe enviar un mensaje de respuesta <code>taken_t</code> a este <code>taken_t</code> .  El segundo campo de <code>take_t</code> no se usa en este ejemplo, lo necesitaremos cuando lleguemos a las implementaciones de waiter_with_queue y waiter_with_timestamps. </p><br><h3 id="aktor-vilka">  Tenedor actor </h3><br><p>  Ahora podemos ver qu√© es un actor tenedor.  Aqu√≠ est√° su c√≥digo: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     'free'. this &gt;&gt;= st_free; //   'free'    . st_free .event( [this]( mhood_t&lt;take_t&gt; cmd ) { this &gt;&gt;= st_taken; so_5::send&lt; taken_t &gt;( cmd-&gt;m_who ); } ); //   'taken'   . st_taken .event( [this]( mhood_t&lt;take_t&gt; cmd ) { //     . m_queue.push( cmd-&gt;m_who ); } ) .event( [this]( mhood_t&lt;put_t&gt; ) { if( m_queue.empty() ) //     . this &gt;&gt;= st_free; else { //      . const auto who = m_queue.front(); m_queue.pop(); so_5::send&lt; taken_t &gt;( who ); } } ); } private : //    . const state_t st_free{ this, "free" }; const state_t st_taken{ this, "taken" }; //   . std::queue&lt; so_5::mbox_t &gt; m_queue; };</span></span></code> </pre> <br><p>  Cada actor en SObjectizer debe derivarse de la clase base <code>agent_t</code> .  Lo que vemos aqu√≠ para el tipo <code>fork_t</code> . </p><br><p>  El m√©todo <code>so_define_agent()</code> se reemplaza en la clase <code>so_define_agent()</code> .  Este es un m√©todo especial, el SObjectizer lo llama autom√°ticamente al registrar un nuevo agente.  En el m√©todo <code>so_define_agent()</code> , el <code>so_define_agent()</code> est√° "configurado" para trabajar en SObjectizer: el estado de inicio cambia, los mensajes necesarios se suscriben. </p><br><p>  Cada actor en SObjectizer es una m√°quina de estados con estados (incluso si un actor usa solo un estado predeterminado).  El actor <code>fork_t</code> tiene dos estados: <em>libre</em> y <em>tomado</em> .  Cuando un actor est√° en estado <em>libre</em> , el fil√≥sofo puede "capturar" el tap√≥n.  Y despu√©s de capturar el "tenedor", el actor <code>fork_t</code> deber√≠a pasar al estado <em>tomado</em> .  Dentro de la clase <code>fork_t</code> estados est√°n representados por instancias de <code>st_free</code> y <code>st_taken</code> tipo especial <code>state_t</code> . </p><br><p>  Los estados le permiten procesar los mensajes entrantes de diferentes maneras.  Por ejemplo, en el estado <em>libre</em> , el agente responde solo a <code>take_t</code> y esta reacci√≥n es muy simple: el estado del actor cambia y la respuesta <code>taken_t</code> : </p><br><pre> <code class="cpp hljs">st_free .event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_taken; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( cmd-&gt;m_who ); } );</code> </pre> <br><p>  Mientras que todos los dem√°s mensajes, incluido <code>put_t</code> en estado <em>libre</em> , simplemente se ignoran. </p><br><p>  En el estado <em>tomado</em> , el actor procesa dos mensajes, e incluso el mensaje <code>take_t</code> procesa de manera diferente: </p><br><pre> <code class="cpp hljs">st_taken .event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { m_queue.push( cmd-&gt;m_who ); } ) .event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span>&gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_queue.empty() ) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_free; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> who = m_queue.front(); m_queue.pop(); so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( who ); } } );</code> </pre> <br><p>  El controlador para <code>put_t</code> m√°s interesante <code>put_t</code> : si la cola de los fil√≥sofos en espera est√° vac√≠a, entonces podemos volver a <em>liberar</em> , pero si no est√° vac√≠a, entonces el primero de ellos debe enviarse <code>taken_t</code> . </p><br><h3 id="aktor-filosof">  Actor fil√≥sofo </h3><br><p>  <a href="" rel="nofollow">El c√≥digo del actor-fil√≥sofo es</a> mucho m√°s voluminoso, por lo que no lo dar√© aqu√≠ por completo.  Discutiremos solo los fragmentos m√°s significativos. </p><br><p>  Un actor-fil√≥sofo tiene un poco m√°s de estados: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_thinking{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"thinking.normal"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_wait_left{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"wait_left"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_wait_right{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"wait_right"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_eating{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"eating"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_done{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"done"</span></span> };</code> </pre> <br><p>  El actor comienza su trabajo en un estado de <em>pensamiento</em> , luego cambia a <em>wait_left</em> , luego a <em>wait_right</em> , luego a <em>comer</em> .  De <em>comer, un</em> actor puede volver a <em>pensar</em> o puede <em>hacerlo</em> si el fil√≥sofo ha comido todo lo que deber√≠a haber comido. </p><br><p>  El diagrama de estado para un actor-fil√≥sofo se puede representar de la siguiente manera: </p><br><p><img src="https://habrastorage.org/webt/ir/j0/sm/irj0smrzaedcsud20y71aynfqb4.png" alt="imagen"></p><br><p>  La l√≥gica del comportamiento del actor se describe en la implementaci√≥n de su m√©todo <code>so_define_agent()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   thinking     stop_thinking. st_thinking .event( [=]( mhood_t&lt;stop_thinking_t&gt; ) { //    . this &gt;&gt;= st_wait_left; so_5::send&lt; take_t &gt;( m_left_fork, so_direct_mbox(), m_index ); } ); //        taken. st_wait_left .event( [=]( mhood_t&lt;taken_t&gt; ) { //     .   . this &gt;&gt;= st_wait_right; so_5::send&lt; take_t &gt;( m_right_fork, so_direct_mbox(), m_index ); } ); //    ,    taken. st_wait_right .event( [=]( mhood_t&lt;taken_t&gt; ) { //    ,  . this &gt;&gt;= st_eating; } ); //      stop_eating. st_eating // 'stop_eating'        'eating'. .on_enter( [=] { so_5::send_delayed&lt; stop_eating_t &gt;( *this, eat_pause() ); } ) .event( [=]( mhood_t&lt;stop_eating_t&gt; ) { //      . so_5::send&lt; put_t &gt;( m_right_fork ); so_5::send&lt; put_t &gt;( m_left_fork ); //     . ++m_meals_eaten; if( m_meals_count == m_meals_eaten ) this &gt;&gt;= st_done; //  ,  ,  . else think(); } ); st_done .on_enter( [=] { //   ,   . completion_watcher_t::done( so_environment(), m_index ); } ); }</span></span></code> </pre> <br><p>  Quiz√°s el √∫nico punto que debe enfatizarse particularmente es el enfoque para imitar los procesos de "pensar" y "comer".  No hay <code>this_thread::sleep_for</code> en el c√≥digo del actor ni ninguna otra forma de bloquear el hilo de trabajo actual.  En cambio, se utilizan mensajes pendientes.  Por ejemplo, cuando un actor entra en el estado de <em>comer</em> , se env√≠a un mensaje de <code>stop_eating_t</code> pendiente.  Este mensaje se entrega al temporizador SObjectizer y el temporizador entrega el mensaje al actor cuando llega el momento. </p><br><p>  El uso de mensajes retrasados ‚Äã‚Äãle permite ejecutar a todos los actores en el contexto de un solo hilo de trabajo.  En t√©rminos generales, un hilo lee los mensajes de alguna cola y tira del siguiente manejador de mensajes del actor receptor correspondiente.  M√°s adelante se discutir√° m√°s sobre los contextos de trabajo para los actores. </p><br><h3 id="rezultaty">  Resultados </h3><br><p>  Los resultados de esta implementaci√≥n pueden verse de la siguiente manera (un peque√±o fragmento): </p><br><pre> <code class="plaintext hljs"> Socrates: tttttttttttLRRRRRRRRRRRRRREEEEEEEttttttttLRRRRRRRRRRRRRREEEEEEEEEEEEE Plato: ttttttttttEEEEEEEEEEEEEEEEttttttttttRRRRRREEEEEEEEEEEEEEttttttttttLLL Aristotle: ttttEEEEEtttttttttttLLLLLLRRRREEEEEEEEEEEEttttttttttttLLEEEEEEEEEEEEE Descartes: tttttLLLLRRRRRRRREEEEEEEEEEEEEtttLLLLLLLLLRRRRREEEEEEttttttttttLLLLLL Spinoza: ttttEEEEEEEEEEEEEttttttttttLLLRRRREEEEEEEEEEEEEttttttttttRRRREEEEEEtt Kant: ttttttttttLLLLLLLRREEEEEEEEEEEEEEEttttttttttLLLEEEEEEEEEEEEEEtttttttt Schopenhauer: ttttttEEEEEEEEEEEEEttttttLLLLLLLLLEEEEEEEEEttttttttLLLLLLLLLLRRRRRRRR Nietzsche: tttttttttLLLLLLLLLLEEEEEEEEEEEEEttttttttLLLEEEEEEEEEttttttttRRRRRRRRE Wittgenstein: ttttEEEEEEEEEEtttttLLLLLLLLLLLLLEEEEEEEEEttttttttttttRRRREEEEEEEEEEEt Heidegger: tttttttttttLLLEEEEEEEEEEEEEEtttttttLLLLLLREEEEEEEEEEEEEEEtttLLLLLLLLR Sartre: tttEEEEEEEEEttttLLLLLLLLLLLLRRRRREEEEEEEEEtttttttLLLLLLLLRRRRRRRRRRRR</code> </pre> <br><p>  Lea esto de la siguiente manera: </p><br><ul><li>  <code>t</code> denota que el fil√≥sofo est√° "pensando"; </li><li>  <code>L</code> significa que el fil√≥sofo espera capturar la bifurcaci√≥n izquierda (est√° en el estado <em>wait_left</em> ); </li><li>  <code>R</code> significa que el fil√≥sofo espera capturar la bifurcaci√≥n correcta (est√° en el estado <em>wait_right</em> ); </li><li>  <code>E</code> significa que el fil√≥sofo "come". </li></ul><br><p>  Podemos ver que S√≥crates puede tomar el tenedor a la izquierda solo despu√©s de que Sartre lo regala.  Despu√©s de lo cual S√≥crates esperar√° hasta que Plat√≥n libere el tenedor correcto.  Solo despu√©s de esto, S√≥crates podr√° comer. </p><br><h2 id="prostoe-reshenie-bez-arbitra-oficianta">  Una decisi√≥n simple sin un √°rbitro (camarero) </h2><br><p>  Si analizamos el resultado de la decisi√≥n de Dijkstra, veremos que los fil√≥sofos pasan mucho tiempo esperando la captura de tenedores.  Lo que no es bueno, porque  Este tiempo tambi√©n se puede dedicar a la reflexi√≥n.  No es por nada que hay una opini√≥n de que si piensas con el est√≥mago vac√≠o, puedes obtener resultados mucho m√°s interesantes e inesperados;) </p><br><p>  Veamos la soluci√≥n m√°s simple en la que el fil√≥sofo devuelve el primer tenedor capturado si no puede capturar el segundo (en el art√≠culo "Fil√≥sofos de la gastronom√≠a moderna" mencionado anteriormente, esta soluci√≥n es implementada por ForkLevelPhilosopherProtocol). </p><br><p>  El c√≥digo fuente de esta implementaci√≥n se puede ver <a href="" rel="nofollow">aqu√≠</a> , y el c√≥digo del actor fil√≥sofo correspondiente <a href="" rel="nofollow">aqu√≠</a> . </p><br><h3 id="soobscheniya-1">  Mensajes </h3><br><p>  Esta soluci√≥n utiliza casi el mismo conjunto de mensajes: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">take_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_who; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_philosopher_index; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">busy_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">taken_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">put_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {};</code> </pre> <br><p>  La √∫nica diferencia es la presencia de la se√±al <code>busy_t</code> .  El tenedor-actor env√≠a esta se√±al en respuesta al fil√≥sofo-actor si el tenedor ya est√° capturado por otro fil√≥sofo. </p><br><h3 id="aktor-vilka-1">  Tenedor actor </h3><br><p>  El actor tenedor en esta soluci√≥n es a√∫n m√°s simple que en la soluci√≥n de Dijkstra: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>( ctx ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_free; st_free.event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_taken; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( cmd-&gt;m_who ); } ); st_taken.event( []( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span> &gt;( cmd-&gt;m_who ); } ) .just_switch_to&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( st_free ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_free{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_taken{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }; };</code> </pre> <br><p>  Aqu√≠ ni siquiera necesitamos mantener la cola de los fil√≥sofos que esperan. </p><br><h3 id="aktor-filosof-1">  Actor fil√≥sofo </h3><br><p>  El fil√≥sofo-actor en esta implementaci√≥n es similar al de la soluci√≥n de Dijkstra, pero aqu√≠ el fil√≥sofo-actor tambi√©n tiene que procesar <code>busy_t</code> , por lo que el diagrama de estado se ve as√≠: </p><br><p><img src="https://habrastorage.org/webt/xa/ek/c8/xaekc8xbxewoj1e7myao4le6jn0.png" alt="imagen"></p><br><p>  Del mismo modo, toda la l√≥gica de un actor-fil√≥sofo se define en <code>so_define_agent()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ st_thinking .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">stop_thinking_t</span></span> &gt;( [=] { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_wait_left; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span> &gt;( m_left_fork, so_direct_mbox(), m_index ); } ); st_wait_left .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( [=] { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_wait_right; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span> &gt;( m_right_fork, so_direct_mbox(), m_index ); } ) .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span> &gt;( [=] { think( st_hungry_thinking ); } ); st_wait_right .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( [=] { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_eating; } ) .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span> &gt;( [=] { so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( m_left_fork ); think( st_hungry_thinking ); } ); st_eating .on_enter( [=] { so_5::send_delayed&lt; <span class="hljs-keyword"><span class="hljs-keyword">stop_eating_t</span></span> &gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, eat_pause() ); } ) .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">stop_eating_t</span></span> &gt;( [=] { so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( m_right_fork ); so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( m_left_fork ); ++m_meals_eaten; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_meals_count == m_meals_eaten ) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_done; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> think( st_normal_thinking ); } ); st_done .on_enter( [=] { <span class="hljs-keyword"><span class="hljs-keyword">completion_watcher_t</span></span>::done( so_environment(), m_index ); } ); }</code> </pre> <br><p>  En general, este es casi el mismo c√≥digo que en la soluci√≥n de Dijkstra, a excepci√≥n de un par de controladores para <code>busy_t</code> . </p><br><h3 id="rezultaty-1">  Resultados </h3><br><p>  Los resultados del trabajo se ven diferentes: </p><br><pre> <code class="plaintext hljs"> Socrates: tttttttttL..R.....EEEEEEEEEEEEttttttttttR...LL..EEEEEEEttEEEEEE Plato: ttttEEEEEEEEEEEttttttL.....L..EEEEEEEEEEEEEEEttttttttttL....L.... Aristotle: ttttttttttttL..LR.EEEEEEtttttttttttL..L....L....R.....EEEEEEEEE Descartes: ttttttttttEEEEEEEEttttttttttttEEEEEEEEttttEEEEEEEEEEEttttttL..L.. Spinoza: ttttttttttL.....L...EEEEEEtttttttttL.L......L....L..L...R...R...E Kant: tttttttEEEEEEEttttttttL.L.....EEEEEEEEttttttttR...R..R..EEEEEtttt Schopenhauer: tttR..R..L.....EEEEEEEttttttR.....L...EEEEEEEEEEEEEEEEttttttttttt Nietzsche: tttEEEEEEEEEEtttttttttEEEEEEEEEEEEEEEttttL....L...L..L....EEEEEEE Wittgenstein: tttttL.L..L.....RR....L.....L....L...EEEEEEEEEEEEEEEtttttttttL. Heidegger: ttttR..R......EEEEEEEEEEEEEttttttttttR..L...L...L..L...EEEEtttttt Sartre: tttEEEEEEEtttttttL..L...L....R.EEEEEEEtttttEEEEtttttttR.....R..R.</code> </pre> <br><p>  Aqu√≠ vemos un nuevo s√≠mbolo, lo que significa que el actor-fil√≥sofo est√° en "pensamientos hambrientos". </p><br><p>  Incluso en este breve fragmento, uno puede ver que hay largos per√≠odos de tiempo durante los cuales el fil√≥sofo no puede comer.  Esto se debe a que esta soluci√≥n est√° protegida del problema de punto muerto, pero no tiene protecci√≥n contra el hambre. </p><br><h2 id="reshenie-s-oficiantom-i-ocheredyu">  La decisi√≥n con el camarero y la cola. </h2><br><p>  La soluci√≥n m√°s simple que se muestra arriba sin un √°rbitro no protege contra el hambre.  El art√≠culo "Fil√≥sofos gastron√≥micos modernos" mencionado anteriormente contiene una soluci√≥n al problema del ayuno en forma de un protocolo WaiterFair.  La conclusi√≥n es que hay un √°rbitro (camarero), al que recurren los fil√≥sofos cuando quieren comer.  Y el camarero tiene una cola de solicitudes de fil√≥sofos.  Y el fil√≥sofo obtiene los tenedores solo si ambos tenedores est√°n libres ahora, y no hay ninguno de los vecinos del fil√≥sofo que recurri√≥ al camarero en la cola. </p><br><p>  Echemos un vistazo a c√≥mo podr√≠a verse esta misma soluci√≥n en los actores. </p><br><p>  El c√≥digo fuente de esta implementaci√≥n se puede encontrar <a href="" rel="nofollow">aqu√≠</a> . </p><br><h3 id="tryuk">  Truco </h3><br><p>  La forma m√°s f√°cil ser√≠a introducir un nuevo conjunto de mensajes a trav√©s del cual los fil√≥sofos pudieran comunicarse con el camarero.  Pero quer√≠a guardar no solo el conjunto de mensajes ya existente (es decir, <code>taken_t</code> , <code>busy_t</code> , <code>put_t</code> , <code>put_t</code> ).  Tambi√©n quer√≠a que se utilizara el mismo actor-fil√≥sofo que en la soluci√≥n anterior.  Por lo tanto, tuve que resolver un problema complicado: c√≥mo hacer que el actor-fil√≥sofo se comunique con el √∫nico actor-camarero, pero al mismo tiempo pens√© que interact√∫a directamente con los tenedores de actores (que ya no est√°n). </p><br><p>  Este problema se resolvi√≥ mediante un simple truco: un actor-camarero crea un conjunto de mbox-s, enlaces a los fil√≥sofos-actores como enlaces a mbox-s de tenedores.  Al mismo tiempo, el actor-camarero se suscribe a los mensajes de todos estos mboxes (que se implementa f√°cilmente en SObjectizer, porque SObjectizer es una implementaci√≥n de no solo / tantos modelos de actores, sino que tambi√©n Pub / Sub es compatible de f√°brica) . </p><br><p>  En c√≥digo, se parece a esto: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">waiter_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">waiter_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> forks_count ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx) } , m_fork_states( forks_count, <span class="hljs-keyword"><span class="hljs-keyword">fork_state_t</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">free</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">//  mbox-   "" m_fork_mboxes.reserve( forks_count ); for( std::size_t i{}; i != forks_count; ++i ) m_fork_mboxes.push_back( so_environment().create_mbox() ); } ... void so_define_agent() override { //      "". for( std::size_t i{}; i != m_fork_mboxes.size(); ++i ) { //     .   . //          //    . so_subscribe( fork_mbox( i ) ) .event( [i, this]( mhood_t&lt;take_t&gt; cmd ) { on_take_fork( std::move(cmd), i ); } ) .event( [i, this]( mhood_t&lt;put_t&gt; cmd ) { on_put_fork( std::move(cmd), i ); } ); } } private : ... //     "". std::vector&lt; so_5::mbox_t &gt; m_fork_mboxes;</span></span></code> </pre> <br><p>  Es decir  Primero, cree un vector de mbox-s para "bifurcaciones" inexistentes, luego suscr√≠base a cada una de ellas.  S√≠, nos suscribimos para saber a qu√© enchufe en particular se refiere la solicitud. </p><br><p>  El controlador real para la <code>on_take_fork()</code> entrante <code>on_take_fork()</code> es el m√©todo <code>on_take_fork()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_take_fork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">take_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; cmd, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fork_index )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,       //    . if( fork_index == cmd-&gt;m_philosopher_index ) handle_take_left_fork( std::move(cmd), fork_index ); else handle_take_right_fork( std::move(cmd), fork_index ); }</span></span></code> </pre> <br><p>  Por cierto, fue aqu√≠ donde necesit√°bamos el segundo campo del mensaje <code>take_t</code> . </p><br><p>  Entonces, en <code>on_take_fork()</code> tenemos la solicitud original y el √≠ndice de la bifurcaci√≥n a la que se refiere la solicitud.  Por lo tanto, podemos determinar si el fil√≥sofo pide un tenedor izquierdo o uno derecho.  Y, en consecuencia, podemos procesarlos de manera diferente (y tenemos que procesarlos de manera diferente). </p><br><p>  Dado que el fil√≥sofo siempre pregunta primero por la bifurcaci√≥n izquierda, entonces necesitamos hacer todas las verificaciones necesarias en este mismo momento.  Y podemos encontrarnos en una de las siguientes situaciones: </p><br><ol><li>  Ambos tenedores son gratuitos y se pueden entregar al fil√≥sofo que envi√≥ la solicitud.  En este caso, <code>taken_t</code> fil√≥sofo y marcamos la bifurcaci√≥n derecha como reservada para que nadie m√°s pueda tomarla. </li><li>  Los tenedores no se pueden dar al fil√≥sofo.  No importa por qu√©  Tal vez algunos de ellos est√°n ocupados en este momento.  O en l√≠nea es uno de los vecinos del fil√≥sofo.  De todos modos, ponemos al fil√≥sofo que envi√≥ la solicitud en la cola, despu√©s de lo cual le <code>busy_t</code> . </li></ol><br><p>  Gracias a esta l√≥gica de trabajo, el fil√≥sofo que recibi√≥ <code>taken_t</code> para la bifurcaci√≥n izquierda puede enviar de forma segura una solicitud <code>take_t</code> para la bifurcaci√≥n derecha.  Esta solicitud ser√° satisfecha de inmediato, ya que  el tenedor ya est√° reservado para este fil√≥sofo. </p><br><h3 id="rezultaty-2">  Resultados </h3><br><p>  Si ejecuta la soluci√≥n resultante, puede ver algo como: </p><br><pre> <code class="plaintext hljs"> Socrates: tttttttttttL....EEEEEEEEEEEEEEttttttttttL...L...EEEEEEEEEEEEEtttttL. Plato: tttttttttttL....L..L..L...L...EEEEEEEEEEEEEtttttL.....L....L.....EEE Aristotle: tttttttttL.....EEEEEEEEEttttttttttL.....L.....EEEEEEEEEEEtttL....LL Descartes: ttEEEEEEEEEEtttttttL.L..EEEEEEEEEEEEtttL..L....L....L.....EEEEEEEEEE Spinoza: tttttttttL.....EEEEEEEEEttttttttttL.....L.....EEEEEEEEEEEtttL....LL Kant: ttEEEEEEEEEEEEEtttttttL...L.....L.....EEEEEttttL....L...L..L...EEEEE Schopenhauer: ttttL...L.....L.EEEEEEEEEEEEEEEEEtttttttttttL..L...L..EEEEEEEttttttt Nietzsche: tttttttttttL....L..L..L...L...L.....L....EEEEEEEEEEEEttL.....L...L.. Wittgenstein: tttttttttL....L...L....L....L...EEEEEEEttttL......L.....L.....EEEEEE Heidegger: ttttttL..L...L.....EEEEEEEEEEEEtttttL...L..L.....EEEEEEEEEEEttttttL. Sartre: ttEEEEEEEEEEEEEttttttttL.....L...EEEEEEEEEEEEttttttttttttL.....EEEEE</code> </pre> <br><p>  Puedes prestar atenci√≥n a la falta de caracteres <code>R</code>  Esto se debe a que las fallas o expectativas no pueden ocurrir en una solicitud de bifurcaci√≥n correcta. </p><br><h2 id="esche-odno-reshenie-s-ispolzovaniem-arbitra-oficianta">  Otra decisi√≥n usando un √°rbitro (camarero) </h2><br><p>  En algunos casos, la soluci√≥n waiter_with_queue anterior puede mostrar resultados similares a este: </p><br><pre> <code class="plaintext hljs"> Socrates: tttttEEEEEEEEEEEEEEtttL.....LL...L....EEEEEEEEEttttttttttL....L.....EE Plato: tttttL..L..L....LL...EEEEEEEEEEEEEEEttttttttttttL.....EEEEEEEEEttttttt Aristotle: tttttttttttL..L...L.....L.....L....L.....EEEEEEEEEEEEtttttttttttL....L.. Descartes: ttttttttttEEEEEEEEEEttttttL.....L....L..L.....L.....L..L...L..EEEEEEEEtt Spinoza: tttttttttttL..L...L.....L.....L....L.....L..L..L....EEEEEEEEEEtttttttttt Kant: tttttttttL....L....L...L...L....L..L...EEEEEEEEEEEttttttttttL...L......E Schopenhauer: ttttttL....L..L...L...LL...L...EEEEEtttttL....L...L.....EEEEEEEEEttttt Nietzsche: tttttL..L..L....EEEEEEEEEEEEEttttttttttttEEEEEEEEEEEEEEEttttttttttttL... Wittgenstein: tttEEEEEEEEEEEEtttL....L....L..EEEEEEEEEtttttL..L..L....EEEEEEEEEEEEEEEE Heidegger: tttttttttL...L..EEEEEEEEttttL..L.....L...EEEEEEEEEtttL.L..L...L....L...L Sartre: ttttttttttL..L....L...L.EEEEEEEEEEEtttttL...L..L....EEEEEEEEEEtttttttttt</code> </pre> <br><p>  Puede ver la presencia de per√≠odos de tiempo suficientemente largos cuando los fil√≥sofos no pueden comer, incluso a pesar de la presencia de tenedores gratuitos.  Por ejemplo, las horquillas izquierda y derecha de Kant son gratuitas durante mucho tiempo, pero Kant no puede tomarlas, porque  sus vecinos ya est√°n esperando en la fila.  Que est√°n esperando a sus vecinos.  Quienes esperan a sus vecinos, etc. </p><br><p>  Por lo tanto, la implementaci√≥n de waiter_with_queue discutida anteriormente protege contra la inanici√≥n en el sentido de que tarde o temprano el fil√≥sofo comer√°.  Esto est√° garantizado para √©l.  Pero los per√≠odos de ayuno pueden ser bastante largos.  Y la utilizaci√≥n de recursos puede no ser √≥ptima a veces. </p><br><p>  Para resolver este problema, implement√© otra soluci√≥n, waiter_with_timestamp (su c√≥digo se puede encontrar <a href="" rel="nofollow">aqu√≠</a> ).  En lugar de hacer cola, priorizan las solicitudes de los fil√≥sofos teniendo en cuenta el momento de su ayuno.  Cuanto m√°s tiempo pase el fil√≥sofo hambriento, m√°s prioridad tendr√° su solicitud. </p><br><p>  No consideraremos el c√≥digo para esta soluci√≥n, porque  en general, lo principal es el mismo truco con un conjunto de mboxes para "bifurcaciones" inexistentes, que ya discutimos en la conversaci√≥n sobre la implementaci√≥n de waiter_with_queue. </p><br><h2 id="neskolko-detaley-realizacii-na-kotorye-hotelos-by-obratit-vnimanie">  Algunos detalles de implementaci√≥n a los que me gustar√≠a llamar la atenci√≥n </h2><br><p>  Hay varios detalles en las implementaciones basadas en los actores a los que me gustar√≠a prestar atenci√≥n, porque  Estos detalles demuestran caracter√≠sticas interesantes de SObjectizer. </p><br><h3 id="rabochiy-kontekst-dlya-aktorov">  Contexto laboral para actores </h3><br><p>  En las implementaciones consideradas, todos los actores principales ( <code>fork_t</code> , <code>philosopher_t</code> , <code>waiter_t</code> ) trabajaron en el contexto de un hilo de trabajo com√∫n.  Lo que no significa en absoluto que en SObjectizer todos los actores trabajen en un solo hilo.  En SObjectizer, puede vincular actores a diferentes contextos, que se pueden ver, por ejemplo, en el c√≥digo de la funci√≥n <code>run_simulation()</code> en la soluci√≥n no_waiter_simple. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de simulaci√≥n de ejecuci√≥n de no_waiter_simple</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_simulation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">names_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; names )</span></span></span><span class="hljs-function"> </span></span>{ env.introduce_coop( [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop ) { coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names, <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span>::trace_step() ); coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">completion_watcher_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = names.size(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * &gt; forks( count, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != count; ++i ) forks[ i ] = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span> &gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != count; ++i ) coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span> &gt;( i, forks[ i ]-&gt;so_direct_mbox(), forks[ (i + <span class="hljs-number"><span class="hljs-number">1</span></span>) % count ]-&gt;so_direct_mbox(), default_meals_count ); }); }</code> </pre> </div></div><br><p>  En esta funci√≥n, <code>completion_watcher_t</code> actores adicionales de los tipos <code>trace_maker_t</code> y <code>completion_watcher_t</code> .  Trabajar√°n en contextos de trabajo individuales.  Para hacer esto, se <code>one_thread</code> dos instancias del despachador del tipo <code>one_thread</code> y los actores est√°n vinculados a estas instancias de despachadores.  Lo que significa que estos actores trabajar√°n como <em>objetos activos</em> : cada uno tendr√° su propio hilo de trabajo. </p><br><p>  SObjectizer proporciona un conjunto de varios despachadores diferentes que se pueden usar directamente.  En este caso, el desarrollador puede crear en su aplicaci√≥n tantas instancias de despachadores como necesite el desarrollador. </p><br><p>    ,        ,       . ,      <code>fork_t</code>     ,   <code>philosopher_t</code>   . </p><br><div class="spoiler"> <b class="spoiler_title"> run_simulation  no_waiter_simple_tp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_simulation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">names_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; names )</span></span></span><span class="hljs-function"> </span></span>{ env.introduce_coop( [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop ) { coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names, <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span>::trace_step() ); coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">completion_watcher_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = names.size(); <span class="hljs-comment"><span class="hljs-comment">//     thread_pool-. so_5::disp::thread_pool::bind_params_t bind_params; bind_params.fifo( so_5::disp::thread_pool::fifo_t::individual ); std::vector&lt; so_5::agent_t * &gt; forks( count, nullptr ); //     -. auto fork_disp = so_5::disp::thread_pool::create_private_disp( env, 3u //  . ); for( std::size_t i{}; i != count; ++i ) //      . forks[ i ] = coop.make_agent_with_binder&lt; fork_t &gt;( fork_disp-&gt;binder( bind_params ) ); //     -. auto philosopher_disp = so_5::disp::thread_pool::create_private_disp( env, 6u //  . ); for( std::size_t i{}; i != count; ++i ) coop.make_agent_with_binder&lt; philosopher_t &gt;( philosopher_disp-&gt;binder( bind_params ), i, forks[ i ]-&gt;so_direct_mbox(), forks[ (i + 1) % count ]-&gt;so_direct_mbox(), default_meals_count ); }); }</span></span></code> </pre> </div></div><br><p>            <code>fork_t</code>  <code>philosopher_t</code> . </p><br><h3 id="trassirovka-smeny-sostoyaniy-aktorov">     </h3><br><p>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Modern dining philosophers</a>    ,     , : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doEat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ eventLog_.startActivity(ActivityType::eat); wait(randBetween(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>)); eventLog_.endActivity(ActivityType::eat);</code> </pre> <br><p>          SObjectizer   .  ,   , .  ¬øPor qu√©? </p><br><p>   ,   SObjectizer-   :   .       <code>agent_state_listener_t</code> .     ,  SObjectizer        . </p><br><p>        <code>greedy_philosopher_t</code>  <code>philosopher_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>(...) ... { so_add_destroyable_listener( <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>::make( so_environment(), index ) ); }</code> </pre> <br><p>  <code>state_watcher_t</code> ‚Äî       . </p><br><div class="spoiler"> <b class="spoiler_title"> state_watcher_t</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state_watcher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_state_listener_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_mbox; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_index; <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> mbox, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_state_listener_unique_ptr_t</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span>::make_mbox(env), index } }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">agent_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">state_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; state )</span></span></span><span class="hljs-function"> override</span></span>; };</code> </pre> </div></div><br><p>   <code>state_watcher_t</code>    SObjectizer   <code>changed()</code>    .    <code>state_watcher_t::changed</code>      -. </p><br><div class="spoiler"> <b class="spoiler_title">  state_watcher_t::changed</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>::changed( so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> &amp; state ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> detect_label = []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; name ) {...}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> state_label = detect_label( state.query_name() ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-string"><span class="hljs-string">'?'</span></span> == state_label ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; so_5::send&lt; trace::<span class="hljs-keyword"><span class="hljs-keyword">state_changed_t</span></span> &gt;( m_mbox, m_index, state_label ); }</code> </pre> </div></div><br><h1 id="resheniya-na-baze-csp">    CSP </h1><br><p>     ,     .       (no_waiter_dijkstra, no_waiter_simple, waiter_with_timestamps)     <code>std::thread</code>  SObjectizer- mchain- (,  ,  CSP- ). ,  ,  CSP-        (   <code>take_t</code> , <code>taken_t</code> , <code>busy_t</code> , <code>put_t</code> ). </p><br><p>  CSP-  ""   .   ,         <code>std::thread</code> . </p><br><h2 id="reshenie-deykstry-1">   </h2><br><p>       <a href="" rel="nofollow"></a> . </p><br><h3 id="nit-dlya-vilki">    </h3><br><p>         :       +    <code>take_t</code>  <code>put_t</code> .    <code>fork_process</code>  : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fork_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fork_ch )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  :   . bool taken = false; //   . std::queue&lt; so_5::mbox_t &gt; wait_queue; //        . so_5::receive( so_5::from( fork_ch ), [&amp;]( so_5::mhood_t&lt;take_t&gt; cmd ) { if( taken ) //  ,     . wait_queue.push( cmd-&gt;m_who ); else { //    . taken = true; so_5::send&lt; taken_t &gt;( cmd-&gt;m_who ); } }, [&amp;]( so_5::mhood_t&lt;put_t&gt; ) { if( wait_queue.empty() ) taken = false; //     . else { //       . const auto who = wait_queue.front(); wait_queue.pop(); so_5::send&lt; taken_t &gt;( who ); } } ); }</span></span></code> </pre> <br><p>   <code>fork_process</code>   :  ,   -   . </p><br><p>    <code>fork_process</code> ‚Äî  ""       ,     .        <code>receive()</code> : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( fork_ch ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) {...}, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span>&gt; ) {...} );</code> </pre> <br><p>  SObjectizer-     <code>receive()</code>       .           .      .   ,      .   ,    . </p><br><p>      -.           <code>fork_t</code>     . ,  ,  . </p><br><h3 id="nit-dlya-filosofa">    </h3><br><p>       <code>philosopher_process</code> .      ,        . </p><br><div class="spoiler"> <b class="spoiler_title">  philosopher_process</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">oid </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">philosopher_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">trace_maker_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; tracer, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> control_ch, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> philosopher_index, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left_fork, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right_fork, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meals_count )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> meals_eaten{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span> pause_generator; <span class="hljs-comment"><span class="hljs-comment">//         . auto self_ch = so_5::create_mchain( control_ch-&gt;environment() ); while( meals_eaten &lt; meals_count ) { tracer.thinking_started( philosopher_index, thinking_type_t::normal ); //    . std::this_thread::sleep_for( pause_generator.think_pause( thinking_type_t::normal ) ); //    . tracer.take_left_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( left_fork, self_ch-&gt;as_mbox(), philosopher_index ); //  ,  . so_5::receive( so_5::from( self_ch ).handle_n( 1u ), [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { //   ,   . tracer.take_right_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( right_fork, self_ch-&gt;as_mbox(), philosopher_index ); //  ,  . so_5::receive( so_5::from( self_ch ).handle_n( 1u ), [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { //    .  . tracer.eating_started( philosopher_index ); //     . std::this_thread::sleep_for( pause_generator.eat_pause() ); //     . ++meals_eaten; //     . so_5::send&lt; put_t &gt;( right_fork ); } ); //     . so_5::send&lt; put_t &gt;( left_fork ); } ); } //   ,   . tracer.philosopher_done( philosopher_index ); so_5::send&lt; philosopher_done_t &gt;( control_ch, philosopher_index ); }</span></span></code> </pre> </div></div><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">philosopher_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">trace_maker_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; tracer, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> control_ch, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> philosopher_index, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left_fork, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right_fork, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meals_count )</span></span></span></span></code> </pre> <br><p>         . </p><br><p>     SObjectizer- ,             ,       Actor-.         : </p><br><pre> <code class="cpp hljs">tracer.thinking_started( philosopher_index, <span class="hljs-keyword"><span class="hljs-keyword">thinking_type_t</span></span>::normal );</code> </pre> <br><p>   <code>tracer</code>      ,     . </p><br><p>  <code>control_ch</code>  ,       <code>philosopher_done_t</code>  ,    ,   .            . </p><br><p>  <code>left_fork</code>  <code>right_fork</code>      .        <code>take_t</code>  <code>put_t</code> .    ,     <code>mbox_t</code>  <code>mchain_t</code> ? </p><br><p>   !       ,    .    ,  mchain ‚Äî  -   mbox-,    mchain-     <code>mbox_t</code> . </p><br><p>    ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> meals_eaten{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span> pause_generator; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> self_ch = so_5::create_mchain( control_ch-&gt;environment() );</code> </pre> <br><p>     ‚Äî  <code>self_ch</code> .    ,         . </p><br><p>           .  Es decir       ,     . </p><br><p>  ,        ,       <code>this_thread::sleep_for</code>   . </p><br><p>       ,      : </p><br><pre> <code class="cpp hljs">so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span> &gt;( left_fork, self_ch-&gt;as_mbox(), philosopher_index );</code> </pre> <br><p>       <code>take_t</code> .       <code>mbox_t</code> ,   <code>self_ch</code>   <code>mchain_t</code> .              <code>as_mbox()</code> . </p><br><p>     <code>receive()</code> : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) {...} );</code> </pre> <br><p>         <code>taken_t</code>    .      .  ,         . </p><br><p>  -   ,       <code>philosopher_process</code> .        <code>receive()</code>      : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) { ... so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) {...} ); ... } );</code> </pre> <br><p>           -  . </p><br><h3 id="funkciya-zapuska-simulyacii">    </h3><br><p>             <code>run_simulation()</code> ,         .      CSP-  <code>run_simulation()</code>   .     ,       ,       (      ). </p><br><div class="spoiler"> <b class="spoiler_title">   run_simulation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_simulation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">names_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; names )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> table_size = names.size(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> join_all = []( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread&gt; &amp; threads ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; t : threads ) t.join(); }; <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span> tracer{ env, names, <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span>::trace_step() }; <span class="hljs-comment"><span class="hljs-comment">//  . std::vector&lt; so_5::mchain_t &gt; fork_chains; std::vector&lt; std::thread &gt; fork_threads( table_size ); for( std::size_t i{}; i != table_size; ++i ) { //     . fork_chains.emplace_back( so_5::create_mchain(env) ); //     . fork_threads[ i ] = std::thread{ fork_process, fork_chains.back() }; } //      . auto control_ch = so_5::create_mchain( env ); //  . const auto philosopher_maker = [&amp;](auto index, auto left_fork_idx, auto right_fork_idx) { return std::thread{ philosopher_process, std::ref(tracer), control_ch, index, fork_chains[ left_fork_idx ]-&gt;as_mbox(), fork_chains[ right_fork_idx ]-&gt;as_mbox(), default_meals_count }; }; std::vector&lt; std::thread &gt; philosopher_threads( table_size ); for( std::size_t i{}; i != table_size - 1u; ++i ) { //      . philosopher_threads[ i ] = philosopher_maker( i, i, i+1u ); } //        . philosopher_threads[ table_size - 1u ] = philosopher_maker( table_size - 1u, table_size - 1u, 0u ); //     . so_5::receive( so_5::from( control_ch ).handle_n( table_size ), [&amp;names]( so_5::mhood_t&lt;philosopher_done_t&gt; cmd ) { fmt::print( "{}: done\n", names[ cmd-&gt;m_philosopher_index ] ); } ); //     . join_all( philosopher_threads ); //     . for( auto &amp; ch : fork_chains ) so_5::close_drop_content( ch ); //       . join_all( fork_threads ); //  . tracer.done(); //   SObjectizer. env.stop(); }</span></span></code> </pre> </div></div><br><p>  ,    <code>run_simulation()</code>   - .      . </p><br><p>      .        : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; so_5::<span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> &gt; fork_chains; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread &gt; fork_threads( table_size ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != table_size; ++i ) { fork_chains.emplace_back( so_5::create_mchain(env) ); fork_threads[ i ] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread{ fork_process, fork_chains.back() }; }</code> </pre> <br><p>       ,   ,    .         .      ,    <code>join</code>  . </p><br><p>                , ..      <code>join</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread &gt; philosopher_threads( table_size ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span>; ++i ) { philosopher_threads[ i ] = philosopher_maker( i, i, i+<span class="hljs-number"><span class="hljs-number">1u</span></span> ); } philosopher_threads[ table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span> ] = philosopher_maker( table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span>, table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span>, <span class="hljs-number"><span class="hljs-number">0u</span></span> );</code> </pre> <br><p>          .        : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( control_ch ).handle_n( table_size ), [&amp;names]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_done_t</span></span>&gt; cmd ) { fmt::print( <span class="hljs-string"><span class="hljs-string">"{}: done\n"</span></span>, names[ cmd-&gt;m_philosopher_index ] ); } );</code> </pre> <br><p>   <code>receive()</code>      <code>table_size</code>   <code>philosopher_done_t</code> . </p><br><p>      <code>philosopher_done_t</code>    . </p><br><p>  <code>join</code>     : </p><br><pre> <code class="cpp hljs">join_all( philosopher_threads );</code> </pre> <br><p>     <code>join</code>    .    <code>join</code> , ..    .        <code>receive()</code>     .              <code>join</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; ch : fork_chains ) so_5::close_drop_content( ch ); join_all( fork_threads );</code> </pre> <br><p>          . </p><br><h4 id="neskolko-slov-o-noexcept">    noexcept </h4><br><p> ,   <code>run_simulation</code>        ,      <em>noexcept</em> .   ,    exception-safety     .            ‚Äî     . </p><br><p>   <code>run_simulation</code>       ? </p><br><p>  ,                .    - exception-safety      ,    .  -  ,            : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != table_size; ++i ) { fork_chains.emplace_back( so_5::create_mchain(env) ); fork_threads[ i ] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread{ fork_process, fork_chains.back() }; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( ... ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != fork_chains.size(); ++i ) { so_5::close_drop_content( fork_chains[ i ] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fork_threads[ i ].joinable() ) fork_threads[ i ].join(); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; }</code> </pre> <br><p>  ,     .  Porque         ,       .    -   : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork_threads_stuff_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; so_5::<span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> &gt; m_fork_chains; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread &gt; m_fork_threads; <span class="hljs-keyword"><span class="hljs-keyword">fork_threads_stuff_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> table_size ) : m_fork_threads( table_size ) {} ~<span class="hljs-keyword"><span class="hljs-keyword">fork_threads_stuff_t</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != m_fork_chains.size(); ++i ) { so_5::close_drop_content( m_fork_chains[ i ] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_fork_threads[ i ].joinable() ) m_fork_threads[ i ].join(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != m_fork_threads.size(); ++i ) { m_fork_chains.emplace_back( so_5::create_mchain(env) ); m_fork_threads[ i ] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread{ fork_process, m_fork_chains.back() }; } } } fork_threads_stuff{ table_size }; <span class="hljs-comment"><span class="hljs-comment">//   . fork_threads_stuff.run(); //     . //       fork_threads_stuff.</span></span></code> </pre> <br><p>     ,           (, Boost- ScopeExit-, GSL- finally()   ). </p><br><p>         .       . </p><br><p> ,        exception-safety  <code>run_simulation()</code> ,   <code>run_simulation()</code>   ,    .      ,          -.       exception-safety  <code>run_simulation()</code>     <em>noexcept</em> ,     <code>std::terminate</code>    . ,          . </p><br><p>   ,   ,       ,       ,   .    ,     <code>join</code> ,            <code>join</code> .         . </p><br><h2 id="prostoe-reshenie-bez-ispolzovaniya-arbitra-oficianta">      () </h2><br><p>    ,   CSP-          ,   . </p><br><p>       <a href="" rel="nofollow"></a> . </p><br><h3 id="nit-dlya-vilki-1">    </h3><br><p>      <code>fork_process</code> ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fork_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fork_ch )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  :   . bool taken = false; //      . so_5::receive( so_5::from( fork_ch ), [&amp;]( so_5::mhood_t&lt;take_t&gt; cmd ) { if( taken ) so_5::send&lt; busy_t &gt;( cmd-&gt;m_who ); else { taken = true; so_5::send&lt; taken_t &gt;( cmd-&gt;m_who ); } }, [&amp;]( so_5::mhood_t&lt;put_t&gt; ) { if( taken ) taken = false; } ); }</span></span></code> </pre> <br><p>  ,   <code>fork_process</code> ,      (      ,      ). </p><br><h3 id="nit-dlya-filosofa-1">    </h3><br><p>      <code>philosopher_process</code> ,    ,      . </p><br><div class="spoiler"> <b class="spoiler_title">  philosopher_process</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">philosopher_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">trace_maker_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; tracer, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> control_ch, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> philosopher_index, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left_fork, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right_fork, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meals_count )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> meals_eaten{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//       . thinking_type_t thinking_type{ thinking_type_t::normal }; random_pause_generator_t pause_generator; //      . auto self_ch = so_5::create_mchain( control_ch-&gt;environment() ); while( meals_eaten &lt; meals_count ) { tracer.thinking_started( philosopher_index, thinking_type ); //    . std::this_thread::sleep_for( pause_generator.think_pause( thinking_type ) ); //  ,     . thinking_type = thinking_type_t::hungry; //    . tracer.take_left_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( left_fork, self_ch-&gt;as_mbox(), philosopher_index ); //  ,  . so_5::receive( so_5::from( self_ch ).handle_n( 1u ), []( so_5::mhood_t&lt;busy_t&gt; ) { /*     */ }, [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { //   ,   . tracer.take_right_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( right_fork, self_ch-&gt;as_mbox(), philosopher_index ); //  ,  . so_5::receive( so_5::from( self_ch ).handle_n( 1u ), []( so_5::mhood_t&lt;busy_t&gt; ) { /*     */ }, [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { //    ,  . tracer.eating_started( philosopher_index ); //     . std::this_thread::sleep_for( pause_generator.eat_pause() ); //     . ++meals_eaten; //      . so_5::send&lt; put_t &gt;( right_fork ); //        "normal". thinking_type = thinking_type_t::normal; } ); //       . so_5::send&lt; put_t &gt;( left_fork ); } ); } //    . tracer.philosopher_done( philosopher_index ); so_5::send&lt; philosopher_done_t &gt;( control_ch, philosopher_index ); }</span></span></code> </pre> </div></div><br><p>  -  <code>philosopher_process</code>     <code>philosopher_process</code>   .     . </p><br><p> -,   <code>thinking_type</code> .    ,      ,     ,      "" . </p><br><p> -,     <code>busy_t</code> .       <code>receive()</code> : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span>&gt; ) { <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> }, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) { ... so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span>&gt; ) { <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> }, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) {...} );</code> </pre> <br><p> ,   <code>busy_t</code> ,   ,           <code>receive()</code> ,       <code>receive()</code> .    <code>busy_t</code>    .      , ..    <code>receive()</code>   <code>busy_t</code>  .     <code>receive()</code>        <code>busy_t</code> . </p><br><h2 id="reshenie-s-oficiantom-i-vremennymi-otmetkami">       </h2><br><p>   CSP-     ,       .            ():    waiter_with_queue,      ,      waiter_with_timestamps.         :    mbox-   ,  mbox-  ,    mbox-  . </p><br><p>      CSP-  ,        <code>philosopher_process</code>   no_waiter_simple.       mchain-           ,  ? </p><br><p>  , . </p><br><p>   mchain-  .   ,       mchain-. </p><br><p>  SObjectizer-   <code>select()</code> ,    , ,    : </p><br><pre> <code class="cpp hljs">so_5::select( so_5::from_all(), case_(ch1, one_handler_1, one_handler_2, one_handler_3, ...), case_(ch2, two_handler_1, two_handler_2, two_handler_3, ...), ...);</code> </pre> <br><p>   <code>select()</code> ,            -.       " "        .   CSP-           . </p><br><p>     . </p><br><p> ,   ,     <code>take_t</code>  <code>put_t</code>      .     -   .         <code>take_t</code>  <code>put_t</code> ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extended_take_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_who; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_philosopher_index; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_fork_index; <span class="hljs-keyword"><span class="hljs-keyword">extended_take_t</span></span>( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> who, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> philosopher_index, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> fork_index ) : m_who{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(who) } , m_philosopher_index{ philosopher_index } , m_fork_index{ fork_index } {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extended_put_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_fork_index; <span class="hljs-keyword"><span class="hljs-keyword">extended_put_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> fork_index ) : m_fork_index{ fork_index } {} };</code> </pre> <br><blockquote>  ,       <code>so_5::message_t</code> ,         (     ).         ,      SObjectizer- . </blockquote><p>    ,         .       <code>take_t</code>  <code>put_t</code> ,    <code>extended_take_t</code>  <code>extended_put_t</code> ,    . </p><br><p>      mbox.   :) </p><br><div class="spoiler"> <b class="spoiler_title">  mbox-</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wrapping_mbox_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::extra::mboxes::proxy::<span class="hljs-keyword"><span class="hljs-keyword">simple_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base_type_t</span></span> = so_5::extra::mboxes::proxy::<span class="hljs-keyword"><span class="hljs-keyword">simple_t</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    . const so_5::mbox_t m_target; //  ,      . const std::size_t m_fork_index; //    . static std::type_index original_take_type; static std::type_index original_put_type; public : wrapping_mbox_t( const so_5::mbox_t &amp; target, std::size_t fork_index ) : base_type_t{ target } , m_target{ target } , m_fork_index{ fork_index } {} //    so_5::abstract_message_box_t   . //       . void do_deliver_message( const std::type_index &amp; msg_type, const so_5::message_ref_t &amp; message, unsigned int overlimit_reaction_deep ) const override { if( original_take_type == msg_type ) { //     . const auto &amp; original_msg = so_5::message_payload_type&lt;::take_t&gt;:: payload_reference( *message ); //     . so_5::send&lt; extended_take_t &gt;( m_target, original_msg.m_who, original_msg.m_philosopher_index, m_fork_index ); } else if( original_put_type == msg_type ) { //     . so_5::send&lt; extended_put_t &gt;( m_target, m_fork_index ); } else base_type_t::do_deliver_message( msg_type, message, overlimit_reaction_deep ); } //       wrapping_mbox_t. static auto make( const so_5::mbox_t &amp; target, std::size_t fork_index ) { return so_5::mbox_t{ new wrapping_mbox_t{ target, fork_index } }; } }; std::type_index wrapping_mbox_t::original_take_type{ typeid(::take_t) }; std::type_index wrapping_mbox_t::original_put_type{ typeid(::put_t) };</span></span></code> </pre> </div></div><br><p>        mbox-:    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">so_5_extra</a>  ,        .           <code>so_5::abstract_message_box_t</code>      . </p><br><p>     ,    <code>wrapping_mbox_t</code> .          ,       .      wrapping_mbox,          mchain .   <code>waiter_process</code> ,      ,      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waiter_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> waiter_ch, details::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">waiter_logic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; logic )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        . so_5::receive( so_5::from( waiter_ch ), [&amp;]( so_5::mhood_t&lt;details::extended_take_t&gt; cmd ) { logic.on_take_fork( std::move(cmd) ); }, [&amp;]( so_5::mhood_t&lt;details::extended_put_t&gt; cmd ) { logic.on_put_fork( std::move(cmd) ); } ); }</span></span></code> </pre> <br><p>  ,               ,      .      waiter_with_timestamps <a href="" rel="nofollow"></a> . </p><br><p>       : "      <code>philosopher_process</code>  mbox-?"  ,    waiter_with_timestamps    mbox,   mchain. </p><br><p>  ,       mchain.       , ..  so_5_extra        mchain- (    ).          mbox-  mchain-. </p><br><h1 id="zaklyuchenie">  Conclusi√≥n </h1><br><p> , ,  ,          CSP .       ,     .   ,  ,     . ,  -   . </p><br><p>     ,   SObjectizer-.    ,         ""  SObjectizer ‚Äî  5.6,     5.5.        ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"></a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"></a> ). -   ,    SO-5.6   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"></a> (      ). </p><br><p>     ,          ! </p><br><p>  PS.  ""      ,       .        C++14. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437998/">https://habr.com/ru/post/437998/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437988/index.html">Tutorial de React, Parte 12: Taller, Fase 3 Aplicaci√≥n TODO</a></li>
<li><a href="../437990/index.html">Tutorial React Parte 13: Componentes basados ‚Äã‚Äãen clases</a></li>
<li><a href="../437992/index.html">Microservicios Versiones en sistemas de integraci√≥n continua y despliegue Estudio de caso de CI / CD usando TFS</a></li>
<li><a href="../437994/index.html">Orde√±o autom√°tico e invernaderos autom√°ticos: c√≥mo funciona una peque√±a granja de alta tecnolog√≠a</a></li>
<li><a href="../437996/index.html">SITIS CTF: c√≥mo el sello ayud√≥ a CTF a ganar</a></li>
<li><a href="../438000/index.html">√âxito y fracaso en la creaci√≥n de su proyecto (inicio)</a></li>
<li><a href="../438002/index.html">Configurar proxy inverso para Nextcloud y ONLYOFFICE</a></li>
<li><a href="../438004/index.html">Electr√≥nica Apple o Soul: desaf√≠os y liderazgo para los auriculares inal√°mbricos de fitness</a></li>
<li><a href="../438006/index.html">Small Business CRM: secretos para una implementaci√≥n exitosa</a></li>
<li><a href="../438008/index.html">Configuraci√≥n de equipos inteligentes Zyxel en modos independientes y en la nube</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>