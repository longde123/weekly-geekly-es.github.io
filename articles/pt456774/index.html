<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🚒 🌨️ 🎅🏾 O que sinto falta em Java depois de trabalhar com Kotlin / Scala 🤚🏼 ⏰ 🛠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, ouço frequentemente que o Java se tornou uma linguagem obsoleta na qual é difícil criar grandes aplicativos suportados. Em geral, não co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O que sinto falta em Java depois de trabalhar com Kotlin / Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/456774/">  Recentemente, ouço frequentemente que o Java se tornou uma linguagem obsoleta na qual é difícil criar grandes aplicativos suportados.  Em geral, não concordo com este ponto de vista.  Na minha opinião, o idioma ainda é adequado para escrever aplicativos rápidos e bem organizados.  No entanto, admito, também acontece que, ao escrever código todos os dias, às vezes você pensa: "quão bem isso seria decidido a partir dessa outra linguagem".  Neste artigo, eu queria compartilhar minha dor e experiência.  Veremos alguns problemas de Java e como eles podem ser resolvidos no Kotlin / Scala.  Se você tem um sentimento semelhante ou está apenas se perguntando o que outras línguas podem oferecer, pergunto a você em cat. <br><br><img src="https://habrastorage.org/webt/gs/ur/yw/gsurywchgpevsavhgdjdaw1_sw4.jpeg"><br><a name="habracut"></a><br><h3>  Estendendo Classes Existentes </h3><br>  Às vezes acontece que é necessário expandir uma classe existente sem alterar seu conteúdo interno.  Ou seja, depois de criar a classe, nós a complementamos com outras classes.  Considere um pequeno exemplo.  Suponha que tenhamos uma classe que é um ponto no espaço bidimensional.  Em locais diferentes em nosso código, precisamos serializá-lo em Json e XML. <br><br><div class="spoiler">  <b class="spoiler_title">Vamos ver como ele pode parecer em Java usando o padrão Visitor</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DotDemo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dot</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = y; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Visitor visitor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visitor.visit(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Visitor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dot dot)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonVisitor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Visitor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dot dot)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> String .format(<span class="hljs-string"><span class="hljs-string">""</span></span> + <span class="hljs-string"><span class="hljs-string">"{"</span></span> + <span class="hljs-string"><span class="hljs-string">"\"x\"=%d, "</span></span> + <span class="hljs-string"><span class="hljs-string">"\"y\"=%d "</span></span> + <span class="hljs-string"><span class="hljs-string">"}"</span></span>, dot.getX(), dot.getY()); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XMLVisitor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Visitor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dot dot)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;dot&gt;"</span></span> + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" &lt;x&gt;"</span></span> + dot.getX() + <span class="hljs-string"><span class="hljs-string">"&lt;/x&gt;"</span></span> + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" &lt;y&gt;"</span></span> + dot.getY() + <span class="hljs-string"><span class="hljs-string">"&lt;/y&gt;"</span></span> + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"&lt;/dot&gt;"</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Dot dot = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dot(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"-------- JSON -----------"</span></span>); System.out.println(dot.accept(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonVisitor())); System.out.println(<span class="hljs-string"><span class="hljs-string">"-------- XML ------------"</span></span>); System.out.println(dot.accept(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLVisitor())); } }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mais sobre o padrão e seu uso</a> <br></div></div><br>  Parece bastante volumoso, certo?  É possível resolver esse problema de maneira mais elegante com a ajuda de ferramentas de linguagem?  Scala e Kotlin assentem positivamente.  Isso é obtido usando o mecanismo de extensão do método.  Vamos ver como fica. <br><br><div class="spoiler">  <b class="spoiler_title">Extensões em Kotlin</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dot</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) <span class="hljs-comment"><span class="hljs-comment">//      fun Dot.convertToJson(): String = "{\"x\"=$x, \"y\"=$y}" fun Dot.convertToXml(): String = """&lt;dot&gt; &lt;x&gt;$x&lt;/x&gt; &lt;y&gt;$y&lt;/y&gt; &lt;/dot&gt;""" fun main() { val dot = Dot(1, 2) println("-------- JSON -----------") println(dot.convertToJson()) println("-------- XML -----------") println(dot.convertToXml()) }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Extensões em Scala</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DotDemo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// val is default case class Dot(x: Int, y: Int) implicit class DotConverters(dot: Dot) { def convertToJson(): String = s"""{"x"=${dot.x}, "y"=${dot.y}}""" def convertToXml(): String = s"""&lt;dot&gt; &lt;x&gt;${dot.x}&lt;/x&gt; &lt;y&gt;${dot.y}&lt;/y&gt; &lt;/dot&gt;""" } val dot = Dot(1, 2) println("-------- JSON -----------") println(dot.convertToJson()) println("-------- XML -----------") println(dot.convertToXml()) }</span></span></code> </pre><br></div></div><br>  Parece muito melhor.  Às vezes, isso realmente não é suficiente com mapeamento abundante e outras transformações. <br><br><h3>  Cadeia de computação multithread </h3><br>  Agora todo mundo está falando sobre computação assíncrona e as proibições de bloquear threads de execução.  Vamos imaginar o seguinte problema: temos várias fontes de números, onde a primeira apenas retorna o número, a segunda - retorna a resposta após o cálculo da primeira.  Como resultado, devemos retornar uma string com dois números. <br><br><div class="spoiler">  <b class="spoiler_title">Esquematicamente, isso pode ser representado da seguinte maneira</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/sl/en/2s/slen2s9wvmnlguh2sh1nh8435au.png"><br></div></div><br>  Vamos tentar resolver o problema em Java primeiro <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo Java</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CompletableFuture&lt;Optional&lt;String&gt;&gt; calcResultOfTwoServices ( Supplier&lt;Optional&lt;Integer&gt;&gt; getResultFromFirstService, Function&lt;Integer, Optional&lt;Integer&gt;&gt; getResultFromSecondService ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CompletableFuture .supplyAsync(getResultFromFirstService) .thenApplyAsync(firstResultOptional -&gt; firstResultOptional.flatMap(first -&gt; getResultFromSecondService.apply(first).map(second -&gt; first + <span class="hljs-string"><span class="hljs-string">" "</span></span> + second ) ) ); }</code> </pre> <br></div></div><br>  Neste exemplo, nosso número é agrupado em Opcional para controlar o resultado.  Além disso, todas as ações são executadas no CompletableFuture para um trabalho conveniente com threads.  A ação principal ocorre no método thenApplyAsync.  Neste método, obtemos opcional como argumento.  Em seguida, o flatMap é chamado para controlar o contexto.  Se o Opcional recebido retornar como Opcional.empty, não iremos para o segundo serviço. <br><br>  O total que recebemos?  Usando os recursos CompletableFuture e Optional com flatMap e map, conseguimos resolver o problema.  Embora, na minha opinião, a solução não pareça a maneira mais elegante: antes de entender qual é o problema, você precisa ler o código.  E o que aconteceria com duas ou mais fontes de dados? <br><br>  A linguagem poderia de alguma forma nos ajudar a resolver o problema.  E, novamente, vire para Scala.  Veja como você pode resolvê-lo com as ferramentas Scala. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de Scala</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcResultOfTwoServices</span></span></span></span>(getResultFromFirstService: <span class="hljs-type"><span class="hljs-type">Unit</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>], getResultFromSecondService: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>]) = <span class="hljs-type"><span class="hljs-type">Future</span></span> { getResultFromFirstService() }.flatMap { firsResultOption =&gt; <span class="hljs-type"><span class="hljs-type">Future</span></span> { firsResultOption.flatMap(first =&gt; getResultFromSecondService(first).map(second =&gt; <span class="hljs-string"><span class="hljs-string">s"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$second</span></span></span><span class="hljs-string">"</span></span> ) )} }</code> </pre> <br></div></div><br>  Parece familiar.  E isso não é coincidência.  Ele usa a biblioteca scala.concurrent, que é principalmente um wrapper sobre java.concurrent.  Bem, com o que mais Scala pode nos ajudar?  O fato é que cadeias do formato flatMap, ..., map podem ser representadas como uma sequência para. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo da segunda versão no Scala</b> <div class="spoiler_text"><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcResultOfTwoServices</span></span></span></span>(getResultFromFirstService: <span class="hljs-type"><span class="hljs-type">Unit</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>], getResultFromSecondService: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>]) = <span class="hljs-type"><span class="hljs-type">Future</span></span> { getResultFromFirstService() }.flatMap { firstResultOption =&gt; <span class="hljs-type"><span class="hljs-type">Future</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { first &lt;- firstResultOption second &lt;- getResultFromSecondService(first) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">s"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$second</span></span></span><span class="hljs-string">"</span></span> } }</code> </pre> <br></div></div><br>  Melhorou, mas vamos tentar mudar nosso código novamente.  Conecte a biblioteca de gatos. <br><br><div class="spoiler">  <b class="spoiler_title">Terceira versão do exemplo Scala</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.instances.future._ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcResultOfTwoServices</span></span></span></span>(getResultFromFirstService: <span class="hljs-type"><span class="hljs-type">Unit</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>], getResultFromSecondService: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>]): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]] = (<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { first &lt;- <span class="hljs-type"><span class="hljs-type">OptionT</span></span>(<span class="hljs-type"><span class="hljs-type">Future</span></span> { getResultFromFirstService() }) second &lt;- <span class="hljs-type"><span class="hljs-type">OptionT</span></span>(<span class="hljs-type"><span class="hljs-type">Future</span></span> { getResultFromSecondService(first) }) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">s"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$second</span></span></span><span class="hljs-string">"</span></span>).value</code> </pre> <br></div></div><br>  Agora não é tão importante o que OptionT significa.  Eu só quero mostrar o quão simples e curta essa operação pode ser. <br><br>  Mas e Kotlin?  Vamos tentar fazer algo semelhante nas corotinas. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de Kotlin</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = async { withContext(Dispatchers.Default) { getResultFromFirstService() }?.let { first -&gt; withContext(Dispatchers.Default) { getResultFromSecondService(first) }?.let { second -&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$second</span></span></span><span class="hljs-string">"</span></span> } } }</code> </pre> <br></div></div><br>  Este código tem suas próprias peculiaridades.  Primeiro, ele usa o mecanismo Kotlin da corutina.  As tarefas dentro do assíncrono são executadas em um pool de threads especial (não no ForkJoin) com um mecanismo de roubo de trabalho.  Em segundo lugar, esse código requer um contexto especial, do qual são usadas palavras-chave como assíncrono e withContext. <br><br>  Se você gostou do Scala Future, mas escreve no Kotlin, pode prestar atenção a invólucros Scala semelhantes.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Digite tal.</a> <br><br><h4>  Trabalhar com fluxos </h4><br>  Para mostrar o problema com mais detalhes acima, vamos tentar expandir o exemplo anterior: passamos às ferramentas de programação Java mais populares - <i>Reactor</i> , no Scala - <i>fs2</i> . <br><br>  Considere a leitura linha a linha de 3 arquivos em um fluxo e tente encontrar correspondências lá. <br>  Aqui está a maneira mais fácil de fazer isso com o Reactor em Java. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de reator em Java</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Flux&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glueFiles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String filename1, String filename2, String filename3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getLinesOfFile(filename1).flatMap(lineFromFirstFile -&gt; getLinesOfFile(filename2) .filter(line -&gt; line.equals(lineFromFirstFile)) .flatMap(lineFromSecondFile -&gt; getLinesOfFile(filename3) .filter(line -&gt; line.equals(lineFromSecondFile)) .map(lineFromThirdFile -&gt; lineFromThirdFile ) ) ); }</code> </pre> <br></div></div><br>  Não é a maneira mais ideal, mas indicativa.  Não é difícil adivinhar que, com mais lógica e acesso a recursos de terceiros, a complexidade do código aumentará.  Vamos ver a alternativa de açúcar de sintaxe para compreensão. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de fs2 no Scala</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-function">def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findUniqueLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename1: String, filename2: String, filename3: String)</span></span></span><span class="hljs-function">: Stream[IO, String] </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { lineFromFirstFile &lt;- readFile(filename1) lineFromSecondFile &lt;- readFile(filename2).filter(_.equals(lineFromFirstFile)) result &lt;- readFile(filename3).filter(_.equals(lineFromSecondFile)) } yield result</code> </pre> <br></div></div><br>  Parece que não há muitas mudanças, mas parece muito melhor. <br><br><h4>  Separando a lógica de negócios com upperKind e implícita </h4><br>  Vamos em frente e ver de que outra forma podemos melhorar nosso código.  Quero avisar que a próxima parte pode não ser imediatamente compreensível.  Quero mostrar as possibilidades e deixar o método de implementação fora dos colchetes por enquanto.  Uma explicação detalhada requer pelo menos um artigo separado.  Se houver um desejo / comentários - seguirei os comentários para responder às perguntas e escreverei a segunda parte com uma descrição mais detalhada :) <br><br>  Então, imagine um mundo em que possamos definir a lógica de negócios, independentemente dos efeitos técnicos que possam surgir durante o desenvolvimento.  Por exemplo, podemos fazer com que cada solicitação subsequente a um DBMS ou a um serviço de terceiros seja executada em um encadeamento separado.  Nos testes de unidade, precisamos fazer um mok estúpido no qual nada acontece.  E assim por diante <br><br>  Talvez algumas pessoas pensem no mecanismo de BPM, mas hoje não é sobre ele.  Acontece que esse problema pode ser resolvido com a ajuda de alguns padrões de programação funcional e suporte a idiomas.  Em um lugar, podemos descrever a lógica assim. <br><br><div class="spoiler">  <b class="spoiler_title">Em um lugar, podemos descrever a lógica como esta</b> <div class="spoiler_text"><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCatHappy</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>[_]: <span class="hljs-type"><span class="hljs-type">Monad</span></span>: <span class="hljs-type"><span class="hljs-type">CatClinicClient</span></span>](): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">Unit</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { catId &lt;- <span class="hljs-type"><span class="hljs-type">CatClinicClient</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>].getHungryCat memberId &lt;- <span class="hljs-type"><span class="hljs-type">CatClinicClient</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>].getFreeMember _ &lt;- <span class="hljs-type"><span class="hljs-type">CatClinicClient</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>].feedCatByFreeMember(catId, memberId) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> ()</code> </pre> <br></div></div><br>  Aqui F [_] (lido como "ef com um buraco") significa um tipo sobre um tipo (às vezes é chamado de espécie na literatura russa).  Pode ser Lista, Conjunto, Opção, Futuro, etc.  Tudo isso é um contêiner de um tipo diferente. <br><br>  Em seguida, apenas mudamos o contexto da execução do código.  Por exemplo, para o ambiente de prod, podemos fazer algo assim. <br><br><div class="spoiler">  <b class="spoiler_title">Como será o código de combate?</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RealCatClinicClient</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CatClinicClient</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Future</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHungryCat</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Future</span></span> { <span class="hljs-type"><span class="hljs-type">Thread</span></span>.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-comment"><span class="hljs-comment">// doing some calls to db (waiting 1 second) 40 } override def getFreeMember: Future[Int] = Future { Thread.sleep(1000) // doing some calls to db (waiting 1 second) 2 } override def feedCatByFreeMember(catId: Int, memberId: Int): Future[Unit] = Future { Thread.sleep(1000) // happy cat (waiting 1 second) println("so testy!") // Don't do like that. It is just for debug } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Como o código de teste pode ser</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockCatClinicClient</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CatClinicClient</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHungryCat</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Id</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFreeMember</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Id</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">feedCatByFreeMember</span></span></span></span>(catId: <span class="hljs-type"><span class="hljs-type">Int</span></span>, memberId: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Id</span></span>[<span class="hljs-type"><span class="hljs-type">Unit</span></span>] = { println(<span class="hljs-string"><span class="hljs-string">"so testy!"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Don't do like that. It is just for debug } }</span></span></code> </pre> <br></div></div><br>  Nossa lógica de negócios agora não depende de quais estruturas, clientes-http e servidores que usamos.  A qualquer momento, podemos mudar o contexto e a ferramenta mudará. <br><br>  Isso é conseguido por recursos como upperKind e implícito.  Vamos considerar o primeiro e, para isso, retornaremos ao Java. <br><br><div class="spoiler">  <b class="spoiler_title">Vejamos o código</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calcer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> CompletableFuture&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCalc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre><br></div></div><br>  Quantas maneiras de retornar o resultado?  Bastante.  Podemos subtrair, adicionar, trocar e muito mais.  Agora imagine que recebemos requisitos claros.  Precisamos adicionar o primeiro número ao segundo.  De quantas maneiras podemos fazer isso?  <s>se você se esforçar e se refinar muito ...</s> em geral, apenas um. <br><br><div class="spoiler">  <b class="spoiler_title">Aqui está ele</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calcer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> CompletableFuture&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCalc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CompletableFuture.supplyAsync(() -&gt; x + y); } }</code> </pre> <br></div></div><br>  Mas e se a chamada para esse método estiver oculta e quisermos testar em um ambiente de thread único?  Ou, se quisermos alterar a implementação da classe removendo / substituindo CompletableFuture.  Infelizmente, em Java, somos impotentes e precisamos alterar a API do método.  Dê uma olhada na alternativa em Scala. <br><br><div class="spoiler">  <b class="spoiler_title">Considere a característica</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calcer</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_]] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCulc</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">Int</span></span>, y: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] }</code> </pre><br></div></div><br>  Criamos traços (o analógico mais próximo é a interface em Java) sem especificar o tipo de contêiner do nosso valor inteiro. <br><br>  Além disso, podemos simplesmente criar várias implementações, se necessário. <br><br><div class="spoiler">  <b class="spoiler_title">Assim</b> <div class="spoiler_text"><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> futureCalcer: <span class="hljs-type"><span class="hljs-type">Calcer</span></span>[<span class="hljs-type"><span class="hljs-type">Future</span></span>] = (x, y) =&gt; <span class="hljs-type"><span class="hljs-type">Future</span></span> {x + y} <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> optionCalcer: <span class="hljs-type"><span class="hljs-type">Calcer</span></span>[<span class="hljs-type"><span class="hljs-type">Option</span></span>] = (x, y) =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>(x + y)</code> </pre><br></div></div><br>  Além disso, existe uma coisa interessante como implícita.  Ele permite que você crie o contexto de nosso ambiente e selecione implicitamente a implementação da característica com base nela. <br><br><div class="spoiler">  <b class="spoiler_title">Assim</b> <div class="spoiler_text"><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">userCalcer</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>[_]](<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> calcer: <span class="hljs-type"><span class="hljs-type">Calcer</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>]): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = calcer.getCulc(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doItInFutureContext</span></span></span></span>(): <span class="hljs-type"><span class="hljs-type">Unit</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> futureCalcer: <span class="hljs-type"><span class="hljs-type">Calcer</span></span>[<span class="hljs-type"><span class="hljs-type">Future</span></span>] = (x, y) =&gt; <span class="hljs-type"><span class="hljs-type">Future</span></span> {x + y} println(userCalcer) } doItInFutureContext() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doItInOptionContext</span></span></span></span>(): <span class="hljs-type"><span class="hljs-type">Unit</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> optionCalcer: <span class="hljs-type"><span class="hljs-type">Calcer</span></span>[<span class="hljs-type"><span class="hljs-type">Option</span></span>] = (x, y) =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>(x + y) println(userCalcer) } doItInOptionContext()</code> </pre> <br></div></div><br>  Implícito simplificado antes de val - adicionar uma variável ao ambiente atual e implícito como argumento a uma função significa retirar a variável do ambiente.  Isso lembra um fechamento implícito. <br><br>  De maneira agregada, podemos criar um ambiente de combate e teste de forma bastante concisa sem usar bibliotecas de terceiros. <br><div class="spoiler">  <b class="spoiler_title">Mas e o kotlin</b> <div class="spoiler_text">  De maneira semelhante, podemos fazer no kotlin: <br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, y: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: T } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> FutureCalculator : Calculator&lt;CompletableFuture&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, y: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = CompletableFuture.supplyAsync { x + y } } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> OptionalCalculator : Calculator&lt;Optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, y: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = Optional.of(x + y) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Calculator</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useCalculator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = eval(<span class="hljs-number"><span class="hljs-number">1</span></span>, y) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { with (FutureCalculator) { println(useCalculator(<span class="hljs-number"><span class="hljs-number">2</span></span>)) } with (OptionalCalculator) { println(useCalculator(<span class="hljs-number"><span class="hljs-number">2</span></span>)) } }</code> </pre> <br>  Aqui também definimos o contexto de execução do nosso código, mas, diferentemente do Scala, sinalizamos isso explicitamente. <br>  Obrigado ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Beholder</a> pelo exemplo. <br></div></div><br><br><h4>  Conclusão </h4><br>  Em geral, essas não são todas as minhas dores.  Há mais.  Eu acho que cada desenvolvedor tem o seu.  Por mim, percebi que o principal é entender o que é realmente necessário para o benefício do projeto.  Por exemplo, na minha opinião, se tivermos um serviço de descanso que funciona como um tipo de adaptador com um monte de mapeamento e lógica simples, toda a funcionalidade acima não será muito útil.  Spring Boot + Java / Kotlin é perfeito para essas tarefas.  Existem outros casos com um grande número de integrações e agregação de algumas informações.  Para tais tarefas, na minha opinião, a última opção parece muito boa.  Em geral, é legal se você pode escolher uma ferramenta com base em uma tarefa. <br><br>  Recursos úteis: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Link para todos os exemplos completos acima</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mais sobre Corotin em Kotlin</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um bom livro introdutório sobre programação funcional em Scala</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt456774/">https://habr.com/ru/post/pt456774/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt456760/index.html">Crowdsourcing no ML Boot Camp. Consideramos mIOU sem fotos para uma nova tarefa de Odnoklassniki</a></li>
<li><a href="../pt456762/index.html">De Witcher 3 a Cyberpunk: a evolução do CD Projekt Quest Design</a></li>
<li><a href="../pt456768/index.html">4 dificuldades em localizar jogos para celular usando o Fishing Clash como exemplo - tradução</a></li>
<li><a href="../pt456770/index.html">Corrida armamentista</a></li>
<li><a href="../pt456772/index.html">Fusões e Aquisições para equipes de projeto: como gerenciar dados e processos do projeto de maneira eficaz?</a></li>
<li><a href="../pt456780/index.html">9 maneiras de aumentar a eficiência do desenvolvedor de aplicativos móveis</a></li>
<li><a href="../pt456782/index.html">Projeto orientado a modelo - como não repetir Chernobyl</a></li>
<li><a href="../pt456790/index.html">Resumo de notícias do PostgreSQL. Edição No.16</a></li>
<li><a href="../pt456792/index.html">Implantar o Kubernetes Cluster no OpenStack com o Kubespray</a></li>
<li><a href="../pt456794/index.html">Arquitetura da interface do usuário da Web: um passado de madeira, um presente estranho e um futuro brilhante</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>