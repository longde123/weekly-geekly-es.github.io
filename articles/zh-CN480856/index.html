<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🔧 👋🏾 🌛 乔达 试图以声明方式进行 💲 🕞 🈂️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="每当我需要坐下来创建一个新的应用程序时，我都会陷入困境。 我急于选择这段时间来选择哪个库或框架。 我上一次在X库上编写代码，但是现在Y框架已经长大并移交了，仍然有一个很棒的UI Kit Z，并且以前的项目还剩下很多工作。 


 从某种意义上说，我意识到框架并不重要-我需要什么，我可以在任何一个框架...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>乔达 试图以声明方式进行</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480856/"><p> 每当我需要坐下来创建一个新的应用程序时，我都会陷入困境。 我急于选择这段时间来选择哪个库或框架。 我上一次在X库上编写代码，但是现在Y框架已经长大并移交了，仍然有一个很棒的UI Kit Z，并且以前的项目还剩下很多工作。 </p><br><p> 从某种意义上说，我意识到框架并不重要-我需要什么，我可以在任何一个框架上进行。 在这里看来您应该很高兴，在github上放满星星，然后冷静下来。 但是同样，不断出现一种不可抗拒的愿望，去做自己的东西，自己的自行车。 那好 有关此主题的一些一般想法和名为Chorda的框架正在削减您的时间。 </p><a name="habracut"></a><br><p> 实际上，麻烦不是别人的决定是不好的还是无效的。 不行 问题是，别人的决定使我们以可能对我们不方便的方式进行思考。 但是等等。  “不便便便”是什么意思，这甚至会影响发展吗？ 回想一下，实际上有DX之类的东西-一套既定的个人习惯和普遍接受的惯例。 从这里我们可以说，当我们自己的DX与库或框架作者的DX重合时，这对我们来说很方便。 当它们分开时，非常不适，烦躁并寻找新事物。 </p><br><h3 id="nemnozhko-istorii"> 一点历史 </h3><br><p> 在为企业应用程序开发UI时，您将面对大量的用户表单。 有一天，一个绝妙的想法突然浮现在脑海：为什么我每次都可以简单地列出JSON中的字段并将结果结构提供给生成器时创建一个Web表单？ 而且，尽管这种方法在血腥的企业世界中效果不是很好（为什么，这是一次单独的对话），但是从命令式样式转换为声明式样式的想法通常也不错。 大量的Web表单，页面甚至整个站点的生成器都可以在Web上轻松找到，这证明了这一点。 </p><br><p> 因此，在某些时候，由于过渡到声明性，我对改进我的代码并不陌生。 但是，一旦我们不仅需要标准的html元素，而且还需要复杂的交互式小部件组件，我们就无法使用简单的生成器。 快速增加了对代码可重用性，可集成性，可扩展性等的要求。 用声明性API开发自己的组件库很快就到了。 </p><br><p> 但是在这里，幸福并没有发生。 最好的情况可能反映出我的同事的意见，该同事将使用创建的库。 他在文档中查看了这些示例，并说：“该库很酷。漂亮，动态。但是，我现在如何从这一切中创建一个应用程序？” 他是对的。 事实证明，制作一个组件与将多个组件组合在一起并使它们无缝工作并不相同。 </p><br><p> 从那时起，已经过去了很多时间。 当我再次被汇聚思想和发展的渴望所吸引时，我决定采取一些不同的行动，而不是自下而上，而是自上而下。 </p><br><h3 id="upravlenie-prilozheniem--upravlenie-sostoyaniyami"> 应用程序管理==状态管理 </h3><br><p> 我更习惯将应用程序视为具有某些克隆状态集的有限状态机。 应用程序的工作是从一个状态到另一种状态的过渡集，其中更改模型会导致创建新版本的视图。 将来<strong>，</strong>我将一些与其唯一表示形式相关的固定<strong>数据</strong> （对象，数组，原始类型等）称为<strong>文档</strong> 。 </p><br><p> 有一个明显的问题-对于模型的许多值，有必要描述文档的许多选项。 这里通常使用两种方法： </p><br><ol><li> 模板。 我们使用我们最喜欢的标记语言，并用分支和循环指令对其进行补充。 </li><li> 功能介绍 我们在函数中以最喜欢的编程语言描述分支和循环。 </li></ol><br><p> 通常，这两种方法都声明为声明性的。 第一个被认为是声明性的，因为尽管它虽然略微扩展，但却基于标记语言的规则。 第二个-因为它着重于功能的组成，其中许多功能充当规则。 值得注意的是，现在模板和函数之间没有明确的界限。 </p><br><p> 一方面，我喜欢模板，但另一方面，我想以某种方式使用javascript的功能。 例如，如下所示： </p><br><pre><code class="javascript hljs">createFromConfig({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Alice'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">tag</span></span>: <span class="hljs-string"><span class="hljs-string">'div'</span></span>, <span class="hljs-attr"><span class="hljs-attr">class</span></span>: <span class="hljs-string"><span class="hljs-string">'clickable box'</span></span>, <span class="hljs-attr"><span class="hljs-attr">onClick</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Click'</span></span>) } })</code> </pre> <br><p> 结果是描述整个一个特定<strong>状态</strong>的JS配置。 为了描述许多状态，有必要实现此配置的可扩展性。 使一组选项可扩展的最便捷方法是什么？ 我们这里不会发明任何东西-重载选项已经存在很长时间了。 在其带有Option API的Vue示例中可以看到它的工作方式。 但是，与同一个Vue不同，我想知道是否可以用相同的方式描述完整状态，包括数据和文档。 </p><br><h3 id="struktura-prilozheniya-i-deklarativnost"> 应用程序结构和声明性 </h3><br><blockquote>  “组件”一词变得含糊不清，尤其是在所谓的 功能组件。 在继续进行应用程序的结构时，我将组件称为<strong>结构元素</strong> 。 </blockquote><p> 很快，我得出的结论是，结构元素（组件）不是文档元素，而是某些实体，该实体： </p><br><ol><li> 结合数据和文档（绑定和事件） </li><li> 与其他类似实体连接（树形结构） </li></ol><br><p> 正如我之前指出的，如果您将应用程序视为一组状态，那么对于这些​​状态，您必须具有描述方法。 而且，有必要找到一种这样的方法，使其不包含“虚假”命令式运算符。 我们正在谈论引入模板的那些非常辅助的元素- <em>#if</em> ， <em>#</em> <em>elsif</em> ， <em>v-for</em>等。 我想很多人已经知道了解决方案-必须将逻辑转移到模型，在表示层保留一个API，该API允许您通过简单的数据类型来控制结构元素。 </p><br><p> 通过管理层，我了解可变性和周期性的存在。 </p><br><h4 id="variativnost-if-else"> 可变性（如果为其他） </h4><br><p> 让我们看看如何使用Chorda中的卡片组件示例控制显示选项： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isHeaderOnly = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> card = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Html({ <span class="hljs-attr"><span class="hljs-attr">$header</span></span>: { <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> }, <span class="hljs-attr"><span class="hljs-attr">$footer</span></span>: { <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> }, <span class="hljs-attr"><span class="hljs-attr">components</span></span>: {<span class="hljs-attr"><span class="hljs-attr">header</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">footer</span></span>: !isHeaderOnly} <span class="hljs-comment"><span class="hljs-comment">//    })</span></span></code> </pre> <br><p> 通过设置<em>组件</em>选项的值，您可以控制显示的组件。 而且，在将<em>组件</em>与反应性存储链接时，我们将获得结构化数据管理。 有一个警告-对象用作值，并且其中的键没有排序，这对<em>组件</em>施加了一些限制。 </p><br><h4 id="ciklichnost-for"> 周期（用于） </h4><br><p> 处理仅在运行时知道数量的数据将需要遍历列表。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> drinks = [<span class="hljs-string"><span class="hljs-string">'Coffee'</span></span>, <span class="hljs-string"><span class="hljs-string">'Tea'</span></span>, <span class="hljs-string"><span class="hljs-string">'Milk'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> html = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Html({ <span class="hljs-attr"><span class="hljs-attr">html</span></span>: <span class="hljs-string"><span class="hljs-string">'ul'</span></span>, <span class="hljs-attr"><span class="hljs-attr">css</span></span>: <span class="hljs-string"><span class="hljs-string">'list'</span></span>, <span class="hljs-attr"><span class="hljs-attr">defaultItem</span></span>: { <span class="hljs-attr"><span class="hljs-attr">html</span></span>: <span class="hljs-string"><span class="hljs-string">'li'</span></span>, <span class="hljs-attr"><span class="hljs-attr">css</span></span>: <span class="hljs-string"><span class="hljs-string">'list-item'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">items</span></span>: drinks })</code> </pre> <br><p>  <em>items</em>选项的值分别是Array，我们得到一组有序的组件。 与<em>组件</em>绑定一样，将<em>项目</em>绑定到存储将控制权转移到数据。 </p><br><p> 结构元素在树层次结构中相互连接。 如果我们结合前面的示例，则要在卡的主体中显示列表，我们将得到以下内容： </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const state = { struct: { header: true, footer: false, }, drinks: ['Coffee', 'Tea', 'Milk'] } //  const card = new Html({ $header: { /*  */ }, $content: { html: 'ul', css: 'list', defaultItem: { html: 'li', css: 'list-item' }, items: state.drinks }, $footer: { /*  */ }, components: state.struct })</span></span></code> </pre> <br><p> 大约以此方式，创建了应用程序的数据结构。 拥有两种类型的生成器就足够了-基于对象和基于数组。 仍然只有了解如何将结构元素转换为文档。 </p><br><h3 id="kogda-vse-uzhe-pridumano-za-nas"> 当一切都已经为我们发明 </h3><br><p> 总的来说，我赞成文档呈现系统应在浏览器级别（尽管至少是相同的VDOM）实现的事实。 我们的任务只是将其小心地连接到组件树。 毕竟，无论库的速度增长了多少，浏览器还是拥有更多。 </p><br><p> 老实说，我有时会尝试使用渲染功能，但是一段时间后我放弃了，因为我的绘制速度无法比VanillaJS快（可悲！）。 现在，使用VDOM进行渲染已经成为一种时尚，而且其实现甚至可能很多。 因此，再加上虚拟树的另一种实现，我决定不将其添加到github的存钱罐中-仅使用下一个框架就足够了。 </p><br><p> 最初，在Chorda中创建了用于Maquette库的适配器以进行渲染，但是一旦“来自现实世界”的任务开始出现，事实证明在React上放置一个抽屉更为实用。 例如，在这种情况下，您可以简单地使用现有的React DevTools，而不能编写自己的工具。 </p><br><p> 要将VDOM与结构元素连接，您需要诸如<strong>layout之</strong>类的东西。 可以将其称为结构元素的文档功能。 重要的是纯函数。 </p><br><p> 考虑一个带有标题，主体和地下室的卡的示例。 前面已经提到过，这些组件是无序的，即 如果我们在操作过程中开始打开/关闭组件，则它们将以新的顺序每次出现。 让我们看看如何通过布局解决此问题： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">orderedByKeyLayout</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">h, type, props, components</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h(type, props, components.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a.key - b.key).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> c.render())) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> html = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Html({ <span class="hljs-attr"><span class="hljs-attr">$header</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">$content</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">$footer</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">layout</span></span>: orderedByKeyLayout <span class="hljs-comment"><span class="hljs-comment">//     })</span></span></code> </pre> <br><p> 该布局允许您配置所谓的 与组件关联的宿主元素及其子元素（ <em>项目</em>和<em>组件</em> ）。 通常，标准布局也是足够的，但是在某些情况下，布局需要存在包装元素（例如，用于网格）或分配特殊类，而我们不希望将其带到组件级别。 </p><br><h3 id="schepotka-reaktivnosti"> 少量反应 </h3><br><p> 声明并绘制了组件的结构后，我们获得了与一个特定数据集相对应的状态。 接下来，我们需要描述许多数据集及其对变化的反应。 </p><br><p> 在处理数据时，我不喜欢两件事： </p><br><ul><li> 免疫力。 跟踪更改的一件好事是为穷人提供版本控制，该版本在原始对象和扁平对象上非常有用。 但是，一旦结构变得更加复杂并且投资数量增加，就很难保持复杂对象的免疫力。 </li><li> 换人。 如果将某些对象放入数据仓库中，那么当我索要它时，我可以返回该对象的副本或通常具有与其结构相似性的另一个对象或代理。 </li></ul><br><p> 我想拥有一个行为不可变的存储库，但其中包含可变数据，该数据还可以保持链接的持久性。 在理想情况下，它看起来像这样：我创建一个存储库，向其中写入一个空对象，开始从应用程序表单输入数据，然后单击“提交”按钮后，我得到具有填充属性的相同对象（链接相同！）。 我将这种情况称为理想情况，因为这种情况很少会发生，即存储模型与展示模型匹配。 </p><br><p> 需要解决的另一个任务是将数据从存储传递到结构元素。 同样，我们不会发明任何东西，而是使用连接到公共<strong>上下文的方法</strong> 。 就Chorda而言，我们无法访问上下文本身，而只能访问其显示（称为<strong>scope）</strong> 。 此外，组件的范围是其子组件的上下文。 这种方法允许您在我们应用程序的任何级别上缩小，扩展或替换相关数据，并且这些更改将被隔离。 </p><br><p> 上下文数据如何在组件树中分布的一个示例： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> html = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Html({ <span class="hljs-comment"><span class="hljs-comment">//     scope: { drink: 'Coffee' }, $component1: { scope: { cups: 2 }, $content: { $myDrink: { //      ,    drinkChanged: function (v) { //    drink   text this.opt('text', v) } }, $numCups: { cupsChanged: function (v) { this.opt('text', v + ' cups') } } } }, $component2: { scope: { drink: 'Tea' //      drink }, drinkChanged: function (v) { //    drink   text this.opt('text', v) } } }) //    // &lt;div&gt; // &lt;div&gt; // &lt;div&gt; // &lt;div&gt;Coffee&lt;/div&gt; // &lt;div&gt;2 cups&lt;/div&gt; // &lt;/div&gt; // &lt;/div&gt; // &lt;div&gt;Tea&lt;/div&gt; // &lt;/div&gt;</span></span></code> </pre><br><p> 最难理解的时刻是每个组件都有自己的上下文，而不是我们在使用模板时通常会在结构的最顶层声明的上下文。 </p><br><h3 id="chto-tam-bylo-naschet-peregruzki-opciy"> 期权超载呢？ </h3><br><p> 当然，您会遇到一种情况，即组件很大，因此有必要在内部深处的某个地方更改小的嵌套组件。 他们说，造粒和成分应对此有所帮助。 而且，必须立即设计组件和体系结构。 如果大型组件不是您自己的，而是属于另一个团队甚至一个独立社区开发的图书馆的一部分，那么情况将变得非常可悲。 即使他们不是最初计划的，也可以轻松地对基础组件进行更改怎么办？ </p><br><p> 通常，库中的组件被设计为类，然后它们可以用作创建新组件的基础。 但是这里隐藏了一个我从未喜欢过的小功能：有时我们创建一个类只是将其应用在一个地方。 真奇怪 例如，我习惯于使用类进行输入，在对象组之间建立关系，而不是使用它们来解决分解问题。 </p><br><p> 让我们看看类如何在Chorda中与配置一起工作。 </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      class Card extends Html { config () { return { css: 'box', $header: {}, $content: {}, $footer: {} } } } const html = new Html({ css: 'panel', $card: { as: Card, $header: { //       title $title: { css: 'title', text: 'Card title' } } } })</span></span></code> </pre> <br><p> 我喜欢此选项，而不是创建一个仅会使用一次的特殊TitleedCard类。 而且，如果您需要包括一部分选项，则可以使用杂质机制。 好吧，没有人取消Object.assign。 </p><br><p> 在乔达语中，一类实质上是用于配置的容器，并扮演一种特殊杂质的角色。 </p><br><h3 id="pochemu-esche-odin-freymvork"> 为什么要使用另一个框架？ </h3><br><p> 我重申，我认为该框架更多是关于思维和经验的方式，而不是技术。 我的习惯和DX在JS中要求声明性，而在其他解决方案中找不到。 但是，一项功能的实施带来了新的功能，不久之后，它们就不再适合专用库的框架。 </p><br><p> 目前，Chorda正在积极开发中。 主要方向已经可见，但是细节在不断变化。 </p><br><p> 感谢您阅读到最后。 我很乐意评论。 </p><br><h3 id="gde-mozhno-posmotret"> 我在哪里可以看到？ </h3><br><p>  <a href="https://eliace.github.io/chorda-docs/">该文件</a> </p><br><p>  <a href="https://github.com/eliace/chorda/tree/master/packages/chorda-core">GitHub来源</a> </p><br><p>  <a href="https://codepen.io/collection/DkGzvo">CodePen示例</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN480856/">https://habr.com/ru/post/zh-CN480856/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN480836/index.html">使用着色器替换游戏中的调色板</a></li>
<li><a href="../zh-CN480838/index.html">SQL查询速度很快。 第一部分</a></li>
<li><a href="../zh-CN480840/index.html">水声系统的网络攻击：神话与现实</a></li>
<li><a href="../zh-CN480848/index.html">适用于6至10岁的初学者电子工程师的套件和构造器。 商店里有什么</a></li>
<li><a href="../zh-CN480852/index.html">Vaadin和Spring Boot上的快速Web应用开发</a></li>
<li><a href="../zh-CN480858/index.html">在浏览器中启动Linux-jor1k模拟器将提供帮助（内置的Monkey Island，Doom和Frontier Elite II）</a></li>
<li><a href="../zh-CN480860/index.html">防锈理论</a></li>
<li><a href="../zh-CN480866/index.html">Web开发的新时代或“一切已存在”</a></li>
<li><a href="../zh-CN480870/index.html">十年结果</a></li>
<li><a href="../zh-CN480872/index.html">英特尔关闭了六个月前的安全漏洞</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>