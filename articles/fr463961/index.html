<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëáüèΩ üë©üèΩ‚Äçüöí üôçüèª Propre mappeur ou un peu sur ExpressionTrees üçô üôçüèº üßóüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, nous allons parler de la fa√ßon d'√©crire votre AutoMapper . Oui, je voudrais vraiment vous en parler, mais je ne peux pas. Le fait est que...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Propre mappeur ou un peu sur ExpressionTrees</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463961/"><img src="https://habrastorage.org/webt/ry/x_/sj/ryx_sj0phsfsrlfz1tcxy2_8izs.jpeg" alt="image"><br><br>  Aujourd'hui, nous allons parler de la fa√ßon d'√©crire votre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AutoMapper</a> .  Oui, je voudrais vraiment vous en parler, mais je ne peux pas.  Le fait est que ces solutions sont tr√®s importantes, ont des ant√©c√©dents d'essais et d'erreurs et ont √©galement parcouru un long chemin vers l'application.  Je ne peux que comprendre comment cela fonctionne, donner un point de d√©part √† ceux qui voudraient comprendre le m√©canisme de travail des ¬´cartographes¬ª.  Vous pourriez m√™me dire que nous allons √©crire notre v√©lo. <br><a name="habracut"></a><br><h3>  Clause de non-responsabilit√© </h3><br>  Je vous rappelle encore une fois: nous allons √©crire un mappeur primitif.  Si vous d√©cidez soudainement de le modifier et de l'utiliser dans la prod - ne le faites pas.  Prenez une solution toute faite qui conna√Æt la pile de probl√®mes dans ce domaine et <i>sait d√©j√† comment</i> les r√©soudre.  Il existe plusieurs raisons plus ou moins importantes d'√©crire et d'utiliser votre mappeur de v√©lo: <br><br><ul><li>  Besoin d'une personnalisation sp√©ciale. </li><li> Vous avez besoin de performances maximales dans vos conditions et vous √™tes pr√™t √† remplir les c√¥nes. </li><li>  Vous voulez comprendre le fonctionnement du mappeur. </li><li>  Vous aimez juste faire du v√©lo. </li></ul><br><h3>  Comment appelle-t-on le ¬´mappeur¬ª? </h3><br>  Il s'agit du sous-syst√®me charg√© de prendre un objet et de le convertir (copier ses valeurs) en un autre.  Une t√¢che typique consiste √† convertir un DTO en objet de couche m√©tier.  Le mappeur le plus primitif ¬´parcourt¬ª les propri√©t√©s de la source de donn√©es et les compare avec les propri√©t√©s du type de donn√©es qui seront sorties.  Apr√®s la correspondance, les valeurs sont extraites de la source et √©crites dans l'objet, qui sera le r√©sultat de la conversion.  Quelque part en cours de route, il sera tr√®s probablement encore n√©cessaire de cr√©er ce ¬´r√©sultat¬ª. <br><br>  Pour le consommateur, le mappeur est un service qui fournit l'interface suivante: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IMapper</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">TOut</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">TOut </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Map</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  J'insiste: c'est l'interface la plus primitive qui, de mon point de vue, est commode pour l'explication.  En r√©alit√©, nous aurons probablement affaire √† un mappeur plus sp√©cifique (IMapper &lt;TIn, TOut&gt;) ou √† une fa√ßade plus g√©n√©rale (IMapper), qui s√©lectionnera elle-m√™me un mappeur sp√©cifique pour les types sp√©cifi√©s d'objets d'entr√©e-sortie. <br><br><h3>  Impl√©mentation na√Øve </h3><br>  Remarque: m√™me l'impl√©mentation na√Øve de mapper n√©cessite des connaissances de base de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Reflection</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ExpressionTrees</a> .  Si vous n'avez pas suivi les liens ou entendu parler de ces technologies - faites-le, lisez-le.  Je promets que le monde ne sera plus jamais le m√™me. <br><br>  Cependant, nous √©crivons votre propre mappeur.  Pour commencer, obtenons toutes les propri√©t√©s ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PropertyInfo</a> ) du type de donn√©es qui seront sorties (ci-apr√®s je l'appellerai <b>TOut</b> ).  C'est assez simple: nous connaissons le type, puisque nous √©crivons l'impl√©mentation d'une classe g√©n√©rique param√©tr√©e avec le type TOut.  Ensuite, en utilisant une instance de la classe Type, nous obtenons toutes ses propri√©t√©s. <br><br><pre> <code class="cs hljs">Type outType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TOut); PropertyInfo[] outProperties = outType.GetProperties();</code> </pre><br>  Lors de l'obtention des propri√©t√©s, j'omet les fonctionnalit√©s.  Par exemple, certains d'entre eux peuvent √™tre sans fonction de d√©finition, certains peuvent √™tre marqu√©s comme ignor√©s par l'attribut, certains peuvent avoir un acc√®s sp√©cial.  Nous envisageons l'option la plus simple. <br><br>  Nous allons plus loin.  Ce serait bien de pouvoir cr√©er une instance de type TOut, c'est-√†-dire l'objet m√™me dans lequel on "mappe" l'objet entrant.  En C #, il existe plusieurs fa√ßons de proc√©der.  Par exemple, nous pouvons le faire: System.Activator.CreateInstance ().  Ou m√™me juste un nouveau TOut (), mais pour cela, vous devez cr√©er une restriction pour TOut, ce que vous ne voudriez pas faire dans l'interface g√©n√©ralis√©e.  Cependant, nous savons tous les deux quelque chose sur ExpressionTrees, ce qui signifie que nous pouvons le faire comme ceci: <br><br><pre> <code class="cs hljs">ConstructorInfo outConstructor = outType.GetConstructor(Array.Empty&lt;Type&gt;()); Func&lt;TOut&gt; activator = outConstructor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">$"Default constructor for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{outType.Name}</span></span></span><span class="hljs-string"> not found"</span></span>) : Expression.Lambda&lt;Func&lt;TOut&gt;&gt;(Expression.New(outConstructor)).Compile();</code> </pre><br>  Pourquoi  Parce que nous savons qu'une instance de la classe Type peut donner des informations sur les constructeurs dont elle dispose - cela est tr√®s pratique lorsque nous d√©cidons de d√©velopper notre mappeur afin de transmettre toutes les donn√©es au constructeur.  De plus, nous en avons appris un peu plus sur ExpressionTrees, √† savoir qu'ils permettent √† la plaque de cr√©er et de compiler du code, qui peut ensuite √™tre r√©utilis√©.  Dans ce cas, c'est une fonction qui ressemble en fait √† () =&gt; new TOut (). <br><br>  Vous devez maintenant √©crire la m√©thode du mappeur principal, qui copiera les valeurs.  Nous allons suivre le chemin le plus simple: parcourir les propri√©t√©s de l'objet qui nous est parvenu √† l'entr√©e et rechercher les propri√©t√©s du m√™me nom parmi les propri√©t√©s de l'objet sortant.  Si trouv√© - copie, sinon - continuez. <br><br><pre> <code class="cs hljs">TOut outInstance = _activator(); PropertyInfo[] sourceProperties = source.GetType().GetProperties(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sourceProperties.Length; i++) { PropertyInfo sourceProperty = sourceProperties[i]; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName = sourceProperty.Name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_outProperties.TryGetValue(propertyName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> PropertyInfo outProperty)) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sourceValue = sourceProperty.GetValue(source); outProperty.SetValue(outInstance, sourceValue); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outInstance;</code> </pre><br>  Ainsi, nous avons enti√®rement form√© la classe <a href="">BasicMapper</a> .  Vous pouvez vous familiariser avec ses tests <a href="">ici</a> .  Veuillez noter que la source peut √™tre soit un objet d'un type particulier, soit un objet anonyme. <br><br><h3>  Performance et boxe </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La r√©flexion est</a> grande, mais lente.  De plus, son utilisation fr√©quente augmente le trafic m√©moire, ce qui signifie qu'il charge le GC, ce qui signifie qu'il ralentit encore plus l'application.  Par exemple, nous venons d'utiliser les m√©thodes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PropertyInfo.SetValue</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PropertyInfo.GetValue</a> .  La m√©thode GetValue renvoie un objet dans lequel une certaine valeur est encapsul√©e (boxe).  Cela signifie que nous avons re√ßu une allocation √† partir de z√©ro. <br><br>  Les mappeurs sont g√©n√©ralement situ√©s l√† o√π vous devez transformer un objet en un autre ... Non, pas un, mais de nombreux objets.  Par exemple, lorsque nous prenons quelque chose dans la base de donn√©es.  Dans cet endroit, je voudrais voir des performances normales et ne pas perdre de m√©moire sur une op√©ration √©l√©mentaire. <br><br>  Que pouvons-nous faire?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ExpressionTrees</a> nous aidera √† nouveau.  Le fait est que .NET vous permet de cr√©er et de compiler du code "√† la vol√©e": nous le d√©crivons dans la repr√©sentation de l'objet, disons quoi et o√π nous allons l'utiliser ... et le compilons.  Presque pas de magie. <br><br><h3>  Mappeur compil√© </h3><br>  En fait, tout est relativement simple: nous avons d√©j√† fait de nouvelles avec Expression.New (ConstructorInfo).  Vous avez probablement remarqu√© que la m√©thode statique New s'appelle exactement de la m√™me mani√®re que l'op√©rateur.  Le fait est que presque toute la syntaxe C # se refl√®te sous la forme de m√©thodes statiques de la classe Expression.  Si quelque chose manque, cela signifie que vous recherchez le soi-disant  "Sucre syntaxique." <br><br>  Voici quelques op√©rations que nous utiliserons dans notre mappeur: <br><br><ul><li>  D√©claration de variable - Expression.Variable (Type, cha√Æne).  L'argument Type indique quel type de variable sera cr√©√©, et cha√Æne est le nom de la variable. </li><li>  Affectation - Expression.Assign (Expression, Expression).  Le premier argument est ce que nous attribuons, et le deuxi√®me argument est ce que nous attribuons. </li><li>  L'acc√®s √† la propri√©t√© d'un objet est Expression.Property (Expression, PropertyInfo).  Expression est le propri√©taire de la propri√©t√© et PropertyInfo est la repr√©sentation objet de la propri√©t√© obtenue via Reflection. </li></ul><br>  Gr√¢ce √† ces connaissances, nous pouvons cr√©er des variables, acc√©der aux propri√©t√©s des objets et attribuer des valeurs aux propri√©t√©s des objets.  Tr√®s probablement, nous comprenons √©galement que ExpressionTree doit √™tre compil√© en un d√©l√©gu√© de la forme <b>Func &lt;objet, TOut&gt;</b> .  Le plan est le suivant: nous obtenons une variable qui contient les donn√©es d'entr√©e, cr√©ons une instance de type TOut et cr√©ons des expressions qui affectent une propri√©t√© √† une autre. <br><br>  Malheureusement, le code n'est pas tr√®s compact, donc je vous sugg√®re de jeter un ≈ìil √† l'impl√©mentation de <a href="">CompiledMapper</a> tout de suite.  Je n'ai apport√© ici que des points cl√©s. <br><br>  Tout d'abord, nous cr√©ons une repr√©sentation objet du param√®tre de notre fonction.  Puisqu'il prend un objet en entr√©e, l'objet sera un param√®tre. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parameter = Expression.Parameter(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>), <span class="hljs-string"><span class="hljs-string">"source"</span></span>);</code> </pre><br>  Ensuite, nous cr√©ons deux variables et une liste d'expressions dans lesquelles nous ajouterons s√©quentiellement des expressions d'affectation.  L'ordre est important, car c'est ainsi que les commandes seront ex√©cut√©es lorsque nous appellerons la m√©thode compil√©e.  Par exemple, nous ne pouvons pas affecter une valeur √† une variable qui n'a pas encore √©t√© d√©clar√©e. <br><br>  De plus, de la m√™me mani√®re que dans le cas d'une impl√©mentation na√Øve, nous parcourons la liste des propri√©t√©s de type et essayons de les faire correspondre par leur nom.  Cependant, au lieu d'affecter imm√©diatement des valeurs, nous cr√©ons des expressions pour extraire des valeurs et attribuer des valeurs pour chaque propri√©t√© associ√©e. <br><br><pre> <code class="cs hljs">Expression sourceValue = Expression.Property(sourceInstance, sourceProperty); Expression outValue = Expression.Property(outInstance, outProperty); expressions.Add(Expression.Assign(outValue, sourceValue));</code> </pre><br>  Un point important: apr√®s avoir cr√©√© toutes les op√©rations d'affectation, nous devons retourner le r√©sultat de la fonction.  Pour ce faire, la derni√®re expression de la liste doit √™tre Expression, contenant l'instance de la classe que nous avons cr√©√©e.  J'ai laiss√© un commentaire √† c√¥t√© de cette ligne.  Pourquoi le comportement correspondant au mot cl√© return dans ExpressionTree ressemble-t-il √† cela?  Je crains que ce soit un probl√®me distinct.  Maintenant, je pense que c'est facile √† retenir. <br><br>  Eh bien, √† la toute fin, nous devons compiler toutes les expressions que nous avons construites.  Qu'est-ce qui nous int√©resse ici?  La variable body contient le "corps" de la fonction.  Les ¬´fonctions normales¬ª ont un corps, non?  Eh bien, que nous enfermons entre accolades.  Ainsi, Expression.Block est exactement cela.  √âtant donn√© que les accolades sont √©galement une port√©e, nous devons passer les variables qui y seront utilis√©es - dans notre cas sourceInstance et outInstance. <br><br><pre> <code class="cpp hljs">var body = Expression.Block(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {sourceInstance, outInstance}, expressions); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Expression.Lambda&lt;Func&lt;object, TOut&gt;&gt;(body, parameter).Compile();</code> </pre><br>  En sortie, on obtient Func &lt;objet, TOut&gt;, c'est-√†-dire  une fonction qui peut convertir des donn√©es d'un objet √† un autre.  Pourquoi de telles difficult√©s, demandez-vous?  Je vous rappelle que, premi√®rement, nous voulions √©viter la boxe lors de la copie des valeurs ValueType, et deuxi√®mement, nous voulions abandonner les m√©thodes PropertyInfo.GetValue et PropertyInfo.SetValue, car elles sont quelque peu lentes. <br><br>  Pourquoi pas la boxe?  Parce que le ExpressionTree compil√© est un v√©ritable IL, et pour l'ex√©cution, il ressemble (presque) √† votre code.  Pourquoi le ¬´mappeur compil√©¬ª est-il plus rapide?  Encore une fois: parce que c'est tout simplement IL.  Soit dit en passant, nous pouvons facilement confirmer la vitesse en utilisant la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BenchmarkDotNet</a> , et le benchmark lui-m√™me peut √™tre consult√© <a href="">ici</a> . <br><div class="scrollable-table"><table><thead><tr><th>  La m√©thode </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th><th>  Ratio </th><th>  Allou√© </th></tr></thead><tbody><tr><td>  AutoMapper </td><td>  1291,6 nous </td><td>  3.3173 us </td><td>  3.1030 us </td><td>  1,00 </td><td>  312,5 KB </td></tr><tr><td>  Velo_BasicMapper </td><td>  11 987,0 us </td><td>  33.8389 us </td><td>  28.2570 us </td><td>  9.28 </td><td>  3437,5 KB </td></tr><tr><td>  Velo_CompiledMapper </td><td>  341,3 nous </td><td>  2.8230 us </td><td>  2.6407 us </td><td>  0,26 </td><td>  312,5 KB </td></tr></tbody></table></div><br>  Dans la colonne Ratio, ¬´CompiledMapper¬ª (CompiledMapper) a montr√© un tr√®s bon r√©sultat, m√™me par rapport √† AutoMapper (c'est la ligne de base, c'est-√†-dire 1).  Cependant, ne nous r√©jouissons pas: AutoMapper a des capacit√©s nettement sup√©rieures par rapport √† notre v√©lo.  Avec cette plaque, je voulais juste montrer que ExpressionTrees est beaucoup plus rapide que ¬´l'approche de r√©flexion classique¬ª. <br><br><h3>  R√©sum√© </h3><br>  J'esp√®re avoir pu montrer que l'√©criture de votre mappeur est assez simple.  Reflection et ExpressionTrees sont des outils tr√®s puissants que les d√©veloppeurs utilisent pour r√©soudre de nombreuses t√¢ches diff√©rentes.  Injection de d√©pendances, s√©rialisation / d√©s√©rialisation, r√©f√©rentiels CRUD, cr√©ation de requ√™tes SQL, utilisation d'autres langages comme scripts pour les applications .NET - tout cela se fait √† l'aide de Reflection, Reflection.Emit et ExpressionTrees. <br><br>  Et le mappeur?  Mapper est un excellent exemple o√π vous pouvez apprendre tout cela. <br><br>  PS: Si vous vouliez plus d'ExpressionTrees, je vous sugg√®re de lire comment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">faire votre convertisseur JSON en</a> utilisant cette technologie. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr463961/">https://habr.com/ru/post/fr463961/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr463943/index.html">Les m√©saventures de la licorne noire</a></li>
<li><a href="../fr463951/index.html">c.tech: Cassandra Meetup # 2</a></li>
<li><a href="../fr463953/index.html">Impl√©mentation du mod√®le de conception de commande dans Unity</a></li>
<li><a href="../fr463955/index.html">Comment d√©velopper un concept de changement de plateforme IP? Instructions d'utilisation</a></li>
<li><a href="../fr463957/index.html">Comment d√©ployer une liste d'entrevues √† lien unique</a></li>
<li><a href="../fr463963/index.html">Reconnaissance faciale sur un chantier de construction</a></li>
<li><a href="../fr463965/index.html">Application de composition dans LaTeX</a></li>
<li><a href="../fr463969/index.html">Telegram Family Budget</a></li>
<li><a href="../fr463971/index.html">Pentester Notes: Cas de chasse</a></li>
<li><a href="../fr463975/index.html">Environnement moderne pour les applications natives React</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>