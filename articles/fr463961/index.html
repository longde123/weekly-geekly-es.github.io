<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏽 👩🏽‍🚒 🙍🏻 Propre mappeur ou un peu sur ExpressionTrees 🍙 🙍🏼 🧗🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, nous allons parler de la façon d'écrire votre AutoMapper . Oui, je voudrais vraiment vous en parler, mais je ne peux pas. Le fait est que...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Propre mappeur ou un peu sur ExpressionTrees</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463961/"><img src="https://habrastorage.org/webt/ry/x_/sj/ryx_sj0phsfsrlfz1tcxy2_8izs.jpeg" alt="image"><br><br>  Aujourd'hui, nous allons parler de la façon d'écrire votre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AutoMapper</a> .  Oui, je voudrais vraiment vous en parler, mais je ne peux pas.  Le fait est que ces solutions sont très importantes, ont des antécédents d'essais et d'erreurs et ont également parcouru un long chemin vers l'application.  Je ne peux que comprendre comment cela fonctionne, donner un point de départ à ceux qui voudraient comprendre le mécanisme de travail des «cartographes».  Vous pourriez même dire que nous allons écrire notre vélo. <br><a name="habracut"></a><br><h3>  Clause de non-responsabilité </h3><br>  Je vous rappelle encore une fois: nous allons écrire un mappeur primitif.  Si vous décidez soudainement de le modifier et de l'utiliser dans la prod - ne le faites pas.  Prenez une solution toute faite qui connaît la pile de problèmes dans ce domaine et <i>sait déjà comment</i> les résoudre.  Il existe plusieurs raisons plus ou moins importantes d'écrire et d'utiliser votre mappeur de vélo: <br><br><ul><li>  Besoin d'une personnalisation spéciale. </li><li> Vous avez besoin de performances maximales dans vos conditions et vous êtes prêt à remplir les cônes. </li><li>  Vous voulez comprendre le fonctionnement du mappeur. </li><li>  Vous aimez juste faire du vélo. </li></ul><br><h3>  Comment appelle-t-on le «mappeur»? </h3><br>  Il s'agit du sous-système chargé de prendre un objet et de le convertir (copier ses valeurs) en un autre.  Une tâche typique consiste à convertir un DTO en objet de couche métier.  Le mappeur le plus primitif «parcourt» les propriétés de la source de données et les compare avec les propriétés du type de données qui seront sorties.  Après la correspondance, les valeurs sont extraites de la source et écrites dans l'objet, qui sera le résultat de la conversion.  Quelque part en cours de route, il sera très probablement encore nécessaire de créer ce «résultat». <br><br>  Pour le consommateur, le mappeur est un service qui fournit l'interface suivante: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IMapper</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">TOut</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">TOut </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Map</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  J'insiste: c'est l'interface la plus primitive qui, de mon point de vue, est commode pour l'explication.  En réalité, nous aurons probablement affaire à un mappeur plus spécifique (IMapper &lt;TIn, TOut&gt;) ou à une façade plus générale (IMapper), qui sélectionnera elle-même un mappeur spécifique pour les types spécifiés d'objets d'entrée-sortie. <br><br><h3>  Implémentation naïve </h3><br>  Remarque: même l'implémentation naïve de mapper nécessite des connaissances de base de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Reflection</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ExpressionTrees</a> .  Si vous n'avez pas suivi les liens ou entendu parler de ces technologies - faites-le, lisez-le.  Je promets que le monde ne sera plus jamais le même. <br><br>  Cependant, nous écrivons votre propre mappeur.  Pour commencer, obtenons toutes les propriétés ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PropertyInfo</a> ) du type de données qui seront sorties (ci-après je l'appellerai <b>TOut</b> ).  C'est assez simple: nous connaissons le type, puisque nous écrivons l'implémentation d'une classe générique paramétrée avec le type TOut.  Ensuite, en utilisant une instance de la classe Type, nous obtenons toutes ses propriétés. <br><br><pre> <code class="cs hljs">Type outType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TOut); PropertyInfo[] outProperties = outType.GetProperties();</code> </pre><br>  Lors de l'obtention des propriétés, j'omet les fonctionnalités.  Par exemple, certains d'entre eux peuvent être sans fonction de définition, certains peuvent être marqués comme ignorés par l'attribut, certains peuvent avoir un accès spécial.  Nous envisageons l'option la plus simple. <br><br>  Nous allons plus loin.  Ce serait bien de pouvoir créer une instance de type TOut, c'est-à-dire l'objet même dans lequel on "mappe" l'objet entrant.  En C #, il existe plusieurs façons de procéder.  Par exemple, nous pouvons le faire: System.Activator.CreateInstance ().  Ou même juste un nouveau TOut (), mais pour cela, vous devez créer une restriction pour TOut, ce que vous ne voudriez pas faire dans l'interface généralisée.  Cependant, nous savons tous les deux quelque chose sur ExpressionTrees, ce qui signifie que nous pouvons le faire comme ceci: <br><br><pre> <code class="cs hljs">ConstructorInfo outConstructor = outType.GetConstructor(Array.Empty&lt;Type&gt;()); Func&lt;TOut&gt; activator = outConstructor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">$"Default constructor for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{outType.Name}</span></span></span><span class="hljs-string"> not found"</span></span>) : Expression.Lambda&lt;Func&lt;TOut&gt;&gt;(Expression.New(outConstructor)).Compile();</code> </pre><br>  Pourquoi  Parce que nous savons qu'une instance de la classe Type peut donner des informations sur les constructeurs dont elle dispose - cela est très pratique lorsque nous décidons de développer notre mappeur afin de transmettre toutes les données au constructeur.  De plus, nous en avons appris un peu plus sur ExpressionTrees, à savoir qu'ils permettent à la plaque de créer et de compiler du code, qui peut ensuite être réutilisé.  Dans ce cas, c'est une fonction qui ressemble en fait à () =&gt; new TOut (). <br><br>  Vous devez maintenant écrire la méthode du mappeur principal, qui copiera les valeurs.  Nous allons suivre le chemin le plus simple: parcourir les propriétés de l'objet qui nous est parvenu à l'entrée et rechercher les propriétés du même nom parmi les propriétés de l'objet sortant.  Si trouvé - copie, sinon - continuez. <br><br><pre> <code class="cs hljs">TOut outInstance = _activator(); PropertyInfo[] sourceProperties = source.GetType().GetProperties(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sourceProperties.Length; i++) { PropertyInfo sourceProperty = sourceProperties[i]; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName = sourceProperty.Name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_outProperties.TryGetValue(propertyName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> PropertyInfo outProperty)) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sourceValue = sourceProperty.GetValue(source); outProperty.SetValue(outInstance, sourceValue); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outInstance;</code> </pre><br>  Ainsi, nous avons entièrement formé la classe <a href="">BasicMapper</a> .  Vous pouvez vous familiariser avec ses tests <a href="">ici</a> .  Veuillez noter que la source peut être soit un objet d'un type particulier, soit un objet anonyme. <br><br><h3>  Performance et boxe </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La réflexion est</a> grande, mais lente.  De plus, son utilisation fréquente augmente le trafic mémoire, ce qui signifie qu'il charge le GC, ce qui signifie qu'il ralentit encore plus l'application.  Par exemple, nous venons d'utiliser les méthodes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PropertyInfo.SetValue</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PropertyInfo.GetValue</a> .  La méthode GetValue renvoie un objet dans lequel une certaine valeur est encapsulée (boxe).  Cela signifie que nous avons reçu une allocation à partir de zéro. <br><br>  Les mappeurs sont généralement situés là où vous devez transformer un objet en un autre ... Non, pas un, mais de nombreux objets.  Par exemple, lorsque nous prenons quelque chose dans la base de données.  Dans cet endroit, je voudrais voir des performances normales et ne pas perdre de mémoire sur une opération élémentaire. <br><br>  Que pouvons-nous faire?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ExpressionTrees</a> nous aidera à nouveau.  Le fait est que .NET vous permet de créer et de compiler du code "à la volée": nous le décrivons dans la représentation de l'objet, disons quoi et où nous allons l'utiliser ... et le compilons.  Presque pas de magie. <br><br><h3>  Mappeur compilé </h3><br>  En fait, tout est relativement simple: nous avons déjà fait de nouvelles avec Expression.New (ConstructorInfo).  Vous avez probablement remarqué que la méthode statique New s'appelle exactement de la même manière que l'opérateur.  Le fait est que presque toute la syntaxe C # se reflète sous la forme de méthodes statiques de la classe Expression.  Si quelque chose manque, cela signifie que vous recherchez le soi-disant  "Sucre syntaxique." <br><br>  Voici quelques opérations que nous utiliserons dans notre mappeur: <br><br><ul><li>  Déclaration de variable - Expression.Variable (Type, chaîne).  L'argument Type indique quel type de variable sera créé, et chaîne est le nom de la variable. </li><li>  Affectation - Expression.Assign (Expression, Expression).  Le premier argument est ce que nous attribuons, et le deuxième argument est ce que nous attribuons. </li><li>  L'accès à la propriété d'un objet est Expression.Property (Expression, PropertyInfo).  Expression est le propriétaire de la propriété et PropertyInfo est la représentation objet de la propriété obtenue via Reflection. </li></ul><br>  Grâce à ces connaissances, nous pouvons créer des variables, accéder aux propriétés des objets et attribuer des valeurs aux propriétés des objets.  Très probablement, nous comprenons également que ExpressionTree doit être compilé en un délégué de la forme <b>Func &lt;objet, TOut&gt;</b> .  Le plan est le suivant: nous obtenons une variable qui contient les données d'entrée, créons une instance de type TOut et créons des expressions qui affectent une propriété à une autre. <br><br>  Malheureusement, le code n'est pas très compact, donc je vous suggère de jeter un œil à l'implémentation de <a href="">CompiledMapper</a> tout de suite.  Je n'ai apporté ici que des points clés. <br><br>  Tout d'abord, nous créons une représentation objet du paramètre de notre fonction.  Puisqu'il prend un objet en entrée, l'objet sera un paramètre. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parameter = Expression.Parameter(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>), <span class="hljs-string"><span class="hljs-string">"source"</span></span>);</code> </pre><br>  Ensuite, nous créons deux variables et une liste d'expressions dans lesquelles nous ajouterons séquentiellement des expressions d'affectation.  L'ordre est important, car c'est ainsi que les commandes seront exécutées lorsque nous appellerons la méthode compilée.  Par exemple, nous ne pouvons pas affecter une valeur à une variable qui n'a pas encore été déclarée. <br><br>  De plus, de la même manière que dans le cas d'une implémentation naïve, nous parcourons la liste des propriétés de type et essayons de les faire correspondre par leur nom.  Cependant, au lieu d'affecter immédiatement des valeurs, nous créons des expressions pour extraire des valeurs et attribuer des valeurs pour chaque propriété associée. <br><br><pre> <code class="cs hljs">Expression sourceValue = Expression.Property(sourceInstance, sourceProperty); Expression outValue = Expression.Property(outInstance, outProperty); expressions.Add(Expression.Assign(outValue, sourceValue));</code> </pre><br>  Un point important: après avoir créé toutes les opérations d'affectation, nous devons retourner le résultat de la fonction.  Pour ce faire, la dernière expression de la liste doit être Expression, contenant l'instance de la classe que nous avons créée.  J'ai laissé un commentaire à côté de cette ligne.  Pourquoi le comportement correspondant au mot clé return dans ExpressionTree ressemble-t-il à cela?  Je crains que ce soit un problème distinct.  Maintenant, je pense que c'est facile à retenir. <br><br>  Eh bien, à la toute fin, nous devons compiler toutes les expressions que nous avons construites.  Qu'est-ce qui nous intéresse ici?  La variable body contient le "corps" de la fonction.  Les «fonctions normales» ont un corps, non?  Eh bien, que nous enfermons entre accolades.  Ainsi, Expression.Block est exactement cela.  Étant donné que les accolades sont également une portée, nous devons passer les variables qui y seront utilisées - dans notre cas sourceInstance et outInstance. <br><br><pre> <code class="cpp hljs">var body = Expression.Block(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {sourceInstance, outInstance}, expressions); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Expression.Lambda&lt;Func&lt;object, TOut&gt;&gt;(body, parameter).Compile();</code> </pre><br>  En sortie, on obtient Func &lt;objet, TOut&gt;, c'est-à-dire  une fonction qui peut convertir des données d'un objet à un autre.  Pourquoi de telles difficultés, demandez-vous?  Je vous rappelle que, premièrement, nous voulions éviter la boxe lors de la copie des valeurs ValueType, et deuxièmement, nous voulions abandonner les méthodes PropertyInfo.GetValue et PropertyInfo.SetValue, car elles sont quelque peu lentes. <br><br>  Pourquoi pas la boxe?  Parce que le ExpressionTree compilé est un véritable IL, et pour l'exécution, il ressemble (presque) à votre code.  Pourquoi le «mappeur compilé» est-il plus rapide?  Encore une fois: parce que c'est tout simplement IL.  Soit dit en passant, nous pouvons facilement confirmer la vitesse en utilisant la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BenchmarkDotNet</a> , et le benchmark lui-même peut être consulté <a href="">ici</a> . <br><div class="scrollable-table"><table><thead><tr><th>  La méthode </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th><th>  Ratio </th><th>  Alloué </th></tr></thead><tbody><tr><td>  AutoMapper </td><td>  1291,6 nous </td><td>  3.3173 us </td><td>  3.1030 us </td><td>  1,00 </td><td>  312,5 KB </td></tr><tr><td>  Velo_BasicMapper </td><td>  11 987,0 us </td><td>  33.8389 us </td><td>  28.2570 us </td><td>  9.28 </td><td>  3437,5 KB </td></tr><tr><td>  Velo_CompiledMapper </td><td>  341,3 nous </td><td>  2.8230 us </td><td>  2.6407 us </td><td>  0,26 </td><td>  312,5 KB </td></tr></tbody></table></div><br>  Dans la colonne Ratio, «CompiledMapper» (CompiledMapper) a montré un très bon résultat, même par rapport à AutoMapper (c'est la ligne de base, c'est-à-dire 1).  Cependant, ne nous réjouissons pas: AutoMapper a des capacités nettement supérieures par rapport à notre vélo.  Avec cette plaque, je voulais juste montrer que ExpressionTrees est beaucoup plus rapide que «l'approche de réflexion classique». <br><br><h3>  Résumé </h3><br>  J'espère avoir pu montrer que l'écriture de votre mappeur est assez simple.  Reflection et ExpressionTrees sont des outils très puissants que les développeurs utilisent pour résoudre de nombreuses tâches différentes.  Injection de dépendances, sérialisation / désérialisation, référentiels CRUD, création de requêtes SQL, utilisation d'autres langages comme scripts pour les applications .NET - tout cela se fait à l'aide de Reflection, Reflection.Emit et ExpressionTrees. <br><br>  Et le mappeur?  Mapper est un excellent exemple où vous pouvez apprendre tout cela. <br><br>  PS: Si vous vouliez plus d'ExpressionTrees, je vous suggère de lire comment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">faire votre convertisseur JSON en</a> utilisant cette technologie. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr463961/">https://habr.com/ru/post/fr463961/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr463943/index.html">Les mésaventures de la licorne noire</a></li>
<li><a href="../fr463951/index.html">c.tech: Cassandra Meetup # 2</a></li>
<li><a href="../fr463953/index.html">Implémentation du modèle de conception de commande dans Unity</a></li>
<li><a href="../fr463955/index.html">Comment développer un concept de changement de plateforme IP? Instructions d'utilisation</a></li>
<li><a href="../fr463957/index.html">Comment déployer une liste d'entrevues à lien unique</a></li>
<li><a href="../fr463963/index.html">Reconnaissance faciale sur un chantier de construction</a></li>
<li><a href="../fr463965/index.html">Application de composition dans LaTeX</a></li>
<li><a href="../fr463969/index.html">Telegram Family Budget</a></li>
<li><a href="../fr463971/index.html">Pentester Notes: Cas de chasse</a></li>
<li><a href="../fr463975/index.html">Environnement moderne pour les applications natives React</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>