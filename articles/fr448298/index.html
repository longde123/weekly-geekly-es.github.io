<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤦🏾 🍍 👴🏾 GLTF et GLB Basics, Partie 2 👎🏾 🏵️ 🏇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article est une continuation des bases des formats GLTF et GLB. Vous pouvez trouver la première partie de l'article ici . Dans la première partie,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GLTF et GLB Basics, Partie 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448298/"><p>  Cet article est une continuation des bases des formats GLTF et GLB.  Vous pouvez trouver la première partie de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Dans la première partie, nous avons examiné avec vous pourquoi le format était initialement prévu, ainsi que les artefacts et leurs attributs du format GLTF tels que Scene, Node, Buffer, BufferView, Accessor et Mesh.  Dans cet article, nous considérerons le matériau, la texture, les animations, l'habillage, l'appareil photo et terminerons également la création d'un fichier GLTF valide minimal. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/cd6/f00/cb9/cd6f00cb95fe2f43b6a765ec8b216301.jpg" alt="image"><br><h2 id="material-i-texture">  Matériau et texture </h2><br><p> Les matériaux et les textures sont inextricablement liés au maillage.  Si nécessaire, le maillage peut être animé.  Le matériau stocke des informations sur la façon dont le modèle sera rendu par le moteur.  GLTF définit les matériaux à l'aide d'un ensemble commun de paramètres basés sur le rendu physique (PBR).  Le modèle PBR vous permet de créer un affichage «physiquement correct» de l'objet dans différentes conditions d'éclairage, car le modèle d'ombrage doit fonctionner avec les propriétés de surface «physiques».  Il existe plusieurs façons de décrire PBR.  Le modèle le plus courant est le modèle de rugosité métallique, utilisé par défaut dans GLTF.  Vous pouvez également utiliser le modèle spéculaire-glosiness, mais uniquement avec une extension distincte (extension).  Les principaux attributs du matériau sont les suivants: </p><br><ol><li>  <strong>nom</strong> est le nom du maillage. </li><li>  <strong>baseColorFactor / baseColorTexture</strong> - stocke les informations de couleur.  Dans le cas de l'attribut Factor, les informations sont stockées dans une valeur numérique pour RGBA, dans le cas de Texture, le lien vers la texture est stocké dans l'objet textures. </li><li>  <strong>metallicFactor</strong> - stocke les informations métalliques </li><li>  <strong>roughnessFactor</strong> - stocke des informations sur la rugosité </li><li>  <strong>doubleSided</strong> - true ou false (la valeur par défaut) et indique si le maillage sera rendu des deux côtés ou uniquement du côté "avant". <a name="habracut"></a><br><pre><code class="json hljs"><span class="hljs-string"><span class="hljs-string">"materials"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"pbrMetallicRoughness"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"baseColorTexture"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"index"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"metallicFactor"</span></span>: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"roughnessFactor"</span></span>: <span class="hljs-number"><span class="hljs-number">0.800000011920929</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Nightshade_MAT"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"doubleSided"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } ],</code> </pre> </li></ol><br><p>  Métallique ou le sens de «métallicité».  Ce paramètre décrit à quel point il est fortement réfléchissant, comme le vrai métal, c'est-à-dire  la quantité de lumière réfléchie par la surface.  La valeur est mesurée de 0 à 1, où 0 est un diélectrique et 1 est un métal pur. </p><br><p>  Rugosité ou «rugosité».  Cet attribut indique le degré de «rugosité» de la surface, affectant ainsi la diffusion de la lumière de la surface.  Mesurée de 0 à 1, où 0 est parfaitement plat et 1 est une surface complètement rugueuse qui ne réfléchit qu'une petite quantité de lumière. </p><br><p>  <strong>Texture</strong> - un objet qui stocke des textures (textures).  Ces cartes donnent un modèle réaliste.  Grâce à eux, vous pouvez désigner l'apparence du modèle, pour donner diverses propriétés telles que la métallicité, la rugosité, la gradation naturelle de l'environnement et même les propriétés de la lueur.  Les textures sont décrites par trois tableaux de haut niveau: textures, échantillonneurs, images.  L'objet Textures utilise des index pour référencer les instances d'échantillonneur et d'image.  L’objet le plus important est l’image, car  C'est lui qui stocke les informations de localisation de la carte.  Dans les textures, il est décrit par le mot source.  L'image peut être située quelque part sur le disque dur (par exemple, «uri»: «duckCM.png») ou encodée en GLTF («bufferView»: 14, «mimeType»: «image / jpeg»).  Samplers est un objet qui définit les paramètres de filtrage et d'encapsulation correspondant aux types GL. </p><br><p>  Dans notre exemple de triangle, il n'y a pas de textures, mais je donnerai JSON d'autres modèles avec lesquels j'ai travaillé.  Dans cet exemple, les textures ont été écrites dans le tampon, elles sont donc également lues à partir du tampon à l'aide de BufferView: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"textures"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"sampler"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-string"><span class="hljs-string">"images"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"bufferView"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"mimeType"</span></span>: <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span> } ],</code> </pre> <br><h2 id="animations">  Des animations </h2><br><p>  GLTF prend en charge les animations cibles articulées, dépouillées et morph à l'aide d'images clés.  Les informations de ces trames sont stockées dans des tampons et se réfèrent à des animations utilisant des accesseurs.  GLTF 2.0 définit uniquement le magasin d'animations, il ne définit donc aucun comportement d'exécution spécifique, tel que l'ordre de lecture, la lecture automatique, les boucles, l'affichage de la chronologie, etc. Toutes les animations sont stockées dans le tableau Animations et elles sont définies comme un ensemble canaux (attribut de canal), ainsi qu'un ensemble d'échantillons qui sont déterminés par des accesseurs qui traitent les informations sur les images clés et la méthode d'interpolation (attribut échantillons) </p><br><p>  Les principaux attributs de l'objet Animations sont les suivants: </p><br><ol><li>  <strong>nom</strong> - nom de l'animation (le cas échéant) </li><li>  <strong>canal</strong> - un tableau qui connecte les valeurs de sortie des images clés de l'animation à un nœud spécifique de la hiérarchie. </li><li>  <strong>sampler</strong> est un attribut qui fait référence à Accessor, qui traite les images clés du tampon. </li><li>  <strong>la cible</strong> est un objet qui détermine quel nœud (objet Node) doit être animé à l'aide de l'attribut de nœud, et également quelle propriété du nœud doit être animée à l'aide de l'attribut de chemin - traduction, rotation, échelle, poids, etc.  Les attributs non animés conservent leurs valeurs lors des animations.  Si le nœud n'est pas défini, l'attribut channel doit être omis. </li><li>  <strong>échantillonneurs</strong> - définit les paires d'entrée et de sortie: un ensemble de valeurs scalaires à virgule flottante représentant le temps linéaire en secondes.  Toutes les valeurs (entrée / sortie) sont stockées dans le tampon et sont accessibles via des accesseurs.  L'attribut d'interpolation stocke la valeur d'interpolation entre les clés. </li></ol><br><p>  Il n'y a pas d'animations dans le GLTF le plus simple.  Un exemple est tiré d'un autre fichier: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"animations"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Animate all properties of one node with different samplers"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"channels"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"sampler"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"node"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"rotation"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"sampler"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"node"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"scale"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"sampler"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"node"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"translation"</span></span> } } ], <span class="hljs-attr"><span class="hljs-attr">"samplers"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">"interpolation"</span></span>: <span class="hljs-string"><span class="hljs-string">"LINEAR"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"output"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">"interpolation"</span></span>: <span class="hljs-string"><span class="hljs-string">"LINEAR"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"output"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">"interpolation"</span></span>: <span class="hljs-string"><span class="hljs-string">"LINEAR"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"output"</span></span>: <span class="hljs-number"><span class="hljs-number">7</span></span> } ] },</code> </pre> <br><h2 id="skin">  La peau </h2><br><p>  Les informations de skinning, également connues sous le nom de skinning, aka animation osseuse, sont stockées dans le tableau des skins.  Chaque habillage est défini à l'aide de l'attribut inverseBindMatrices, qui fait référence à l'accesseur avec des données IBM (matrice de liaison inverse).  Ces données sont utilisées pour transférer les coordonnées dans le même espace que chaque articulation, ainsi que l'attribut du tableau des articulations, qui répertorie les indices des nœuds utilisés comme articulations pour l'animation d'habillage.  L'ordre des connexions est déterminé dans le tableau skin.joints et doit correspondre à l'ordre des données de inverseBindMatrices.  L'attribut squelette pointe vers un objet Node qui est la racine commune de la hiérarchie des articulations, ou le nœud parent direct ou indirect d'une racine commune. </p><br><p>  Un exemple d'utilisation de l'objet skin (pas dans l'exemple du triangle): </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"skins"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"skin_0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"inverseBindMatrices"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"joints"</span></span>: [ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"skeleton"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ]</code> </pre> <br><p>  Les principaux attributs: </p><br><ol><li>  <strong>name</strong> - skinning name </li><li>  <strong>inverseBindMatrices</strong> - indique le numéro d' <strong>accès</strong> qui stocke des informations sur la matrice de liaison inverse </li><li>  <strong>joints</strong> - indique le numéro de l'accesseur stockant des informations sur les joints </li><li>  <strong>squelette</strong> - indique le numéro de l'accesseur qui a stocké des informations sur la "racine" <br>  articulation / articulation avec laquelle le squelette du modèle commence </li></ol><br><h2 id="camera">  Appareil photo </h2><br><p>  La caméra détermine la matrice de projection, qui est obtenue en transformant la «vue» en coordonnées du clip.  Si c'est plus simple, les caméras déterminent l'aspect visuel (angle de vue, direction du «look», etc.) que l'utilisateur voit lors du chargement du modèle. </p><br><p>  La projection peut être «Perspective» et «Orthogonale».  Les caméras sont contenues dans des nœuds et peuvent avoir des transformations.  Les caméras sont fixées dans des objets Node et peuvent donc avoir des transformations.  La caméra est définie de manière à ce que l'axe local + X soit dirigé vers la droite, l'objectif regarde dans la direction de l'axe local -Z et le haut de la caméra est aligné avec l'axe local + Y.  Si la transformation n'est pas spécifiée, la caméra est à l'origine.  Les caméras sont stockées dans le réseau de caméras.  Chacun d'eux définit un attribut de type qui attribue un type de projection (perspective ou orthogonale), ainsi que des attributs tels que perspective ou orthographique, qui stockent déjà des informations plus détaillées.  Selon la présence de l'attribut zfar, les caméras avec le type de perspective peuvent utiliser une projection finie ou infinie. </p><br><p>  Un exemple de caméra en JSON avec une perspective de type.  Non pertinent pour un exemple de fichier GLTF minimal correct (triangle): </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"cameras"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Infinite perspective camera"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"perspective"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"perspective"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"aspectRatio"</span></span>: <span class="hljs-number"><span class="hljs-number">1.5</span></span>, <span class="hljs-attr"><span class="hljs-attr">"yfov"</span></span>: <span class="hljs-number"><span class="hljs-number">0.660593</span></span>, <span class="hljs-attr"><span class="hljs-attr">"znear"</span></span>: <span class="hljs-number"><span class="hljs-number">0.01</span></span> } } ]</code> </pre> <br><p>  Les principaux attributs de l'objet Camera: </p><br><ol><li>  <strong>name</strong> - skinning name </li><li>  <strong>type</strong> - type de caméra, perspective ou orthographique. </li><li>  <strong>perspective / orthographique</strong> - attribut contenant les détails de la valeur de type correspondante </li><li>  <strong>aspectRatio</strong> - Rapport hauteur / largeur (fov). </li><li>  <strong>yfov</strong> - <strong>angle de</strong> champ de vision vertical (fov) en radians </li><li>  <strong>zfar</strong> - distance par rapport au plan de <strong>délimitation</strong> éloigné </li><li>  <strong>znear</strong> - distance par rapport au plan de détourage proche </li><li>  <strong>extras</strong> - données spécifiques à l'application </li></ol><br><h2 id="minimalnyy-validnyy-gltf-fayl">  Fichier GLTF valide minimum </h2><br><p>  Au début de l'article, j'ai écrit que nous collecterons un fichier GLTF minimal qui contiendra 1 triangle.  Le JSON tamponné peut être trouvé ci-dessous.  Copiez-le simplement dans un fichier texte, changez le format de fichier en .gtlf.  Pour afficher un élément 3D dans un fichier, vous pouvez utiliser n'importe quel visualiseur prenant en charge GLTF, mais j'utilise personnellement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"scenes"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"nodes"</span></span> : [ <span class="hljs-number"><span class="hljs-number">0</span></span> ] } ], <span class="hljs-attr"><span class="hljs-attr">"nodes"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"mesh"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"meshes"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"primitives"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"attributes"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"POSITION"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"indices"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> } ] } ], <span class="hljs-attr"><span class="hljs-attr">"buffers"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"uri"</span></span> : <span class="hljs-string"><span class="hljs-string">"data:application/octet-stream;base64,AAABAAIAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAA="</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">44</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"bufferViews"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span> : <span class="hljs-number"><span class="hljs-number">34963</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">36</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span> : <span class="hljs-number"><span class="hljs-number">34962</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"accessors"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"bufferView"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"componentType"</span></span> : <span class="hljs-number"><span class="hljs-number">5123</span></span>, <span class="hljs-attr"><span class="hljs-attr">"count"</span></span> : <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"SCALAR"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max"</span></span> : [ <span class="hljs-number"><span class="hljs-number">2</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"min"</span></span> : [ <span class="hljs-number"><span class="hljs-number">0</span></span> ] }, { <span class="hljs-attr"><span class="hljs-attr">"bufferView"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"componentType"</span></span> : <span class="hljs-number"><span class="hljs-number">5126</span></span>, <span class="hljs-attr"><span class="hljs-attr">"count"</span></span> : <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"VEC3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max"</span></span> : [ <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"min"</span></span> : [ <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span> ] } ], <span class="hljs-attr"><span class="hljs-attr">"asset"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"version"</span></span> : <span class="hljs-string"><span class="hljs-string">"2.0"</span></span> } }</code> </pre> <br><h2 id="chto-v-itoge">  Quel est le résultat? </h2><br><p>  En conclusion, je tiens à noter la popularité croissante des formats GLTF et GLB, de nombreuses entreprises l'utilisent déjà activement et certaines s'efforcent déjà activement de le faire.  La facilité de son utilisation sur le réseau social Facebook (publications 3D et, plus récemment, 3D Photos), l'utilisation active de GLB dans Oculus Home, ainsi qu'un certain nombre d'innovations annoncées lors du GDC 2019 contribuent grandement à la popularisation du format. Légèreté, vitesse de rendu rapide, la facilité d'utilisation, la promotion du groupe Khronos et la standardisation du format sont les principaux avantages qui, j'en suis sûr, finiront par faire leur travail pour le promouvoir davantage! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448298/">https://habr.com/ru/post/fr448298/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448288/index.html">Utilisation de C ++ et de modèles avec un nombre variable d'arguments lors de la programmation de microcontrôleurs</a></li>
<li><a href="../fr448290/index.html">L'impression 3D dans le cadre du concept révolutionnaire Shipyard 4.0</a></li>
<li><a href="../fr448292/index.html">Ouvrez l'API pour accepter les transferts p2p</a></li>
<li><a href="../fr448294/index.html">La loi sur l'isolement du Runet est adoptée par la Douma d'Etat en trois lectures</a></li>
<li><a href="../fr448296/index.html">Freelance et Finance: 5 façons de s'entendre entre un client et un freelance</a></li>
<li><a href="../fr448300/index.html">Mailto de la conférence: CLOUD - sur les nuages ​​et autour</a></li>
<li><a href="../fr448302/index.html">Une vulnérabilité dans les filtres AdBlock et uBlock permet d'exécuter du code arbitraire côté utilisateur</a></li>
<li><a href="../fr448304/index.html">Le livre "Vue.js en action"</a></li>
<li><a href="../fr448308/index.html">Data Science Digest (avril 2019)</a></li>
<li><a href="../fr448310/index.html">Écrire un bot de télégramme en python à l'aide de la bibliothèque de telebot partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>