<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👗 🙍🏻 👼🏽 Direct3D vs OpenGL: eine Geschichte der Konfrontation 🕴🏿 🤶🏻 👨🏼‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bis heute wird im Internet darüber diskutiert, welche Grafik-API besser ist: Direct3D oder OpenGL? Trotz ihrer religiösen Natur bringen solche verbale...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Direct3D vs OpenGL: eine Geschichte der Konfrontation</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/397309/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bis heute wird im Internet darüber diskutiert, welche Grafik-API besser ist: Direct3D oder OpenGL? </font><font style="vertical-align: inherit;">Trotz ihrer religiösen Natur bringen solche verbalen Schlachten nützliche Ergebnisse in Form guter historischer Rückblicke auf die Entwicklung hardwarebeschleunigter Grafiken. </font></font><br>
<br>
<img src="https://habrastorage.org/files/f78/9d2/a4c/f789d2a4cdde4ca399d39c74950faad8.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Zweck dieses Beitrags ist es, eine dieser </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Exkursionen in die Geschichte</font></a><font style="vertical-align: inherit;"> zu übersetzen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geschrieben von Jason L. McKesson als Antwort auf die Frage "Warum bevorzugen Spieleentwickler Windows?" </font><font style="vertical-align: inherit;">Es ist unwahrscheinlich, dass dieser Text die gestellte Frage beantwortet, aber er beschreibt die Entwicklungsgeschichte und die Konfrontation der beiden beliebtesten Grafik-APIs auf sehr farbenfrohe und ziemlich detaillierte Weise, sodass ich das Markup des Autors in der Übersetzung beibehalten habe. </font><font style="vertical-align: inherit;">Der Text wurde Mitte 2011 verfasst und umfasst einen Zeitraum, der kurz vor dem Aufkommen von Direct3D und bis zum Zeitpunkt des Schreibens beginnt. </font><font style="vertical-align: inherit;">Der Autor des Originaltextes ist ein erfahrener Spieleentwickler, ein aktiver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teilnehmer an</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> StackOverflow und der Schöpfer eines umfangreichen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lehrbuchs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> über moderne 3D-Grafikprogrammierung. </font><font style="vertical-align: inherit;">Also lasst uns Jason das Wort erteilen.</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorwort</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir beginnen, möchte ich sagen, dass ich mehr über OpenGL als über Direct3D weiß. </font><font style="vertical-align: inherit;">In meinem Leben habe ich keine einzige Codezeile in D3D geschrieben, aber ich habe OpenGL-Handbücher geschrieben. </font><font style="vertical-align: inherit;">Aber worüber ich sprechen möchte, ist keine Frage von Vorurteilen, sondern von Geschichte.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Geburt eines Konflikts</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einmal, Anfang der 90er Jahre, sah sich Microsoft um. Sie haben gesehen, dass </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SNES</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sega Genesis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sehr cool sind, man kann viele Actionspiele spielen und all das. Und sie sahen die Dos. Die Entwickler schrieben Dosovskie-Spiele als Konsole: nah am Eisen. Im Gegensatz zu Konsolen, bei denen der Entwickler wusste, welche Art von Hardware der Benutzer haben würde, mussten dos-Entwickler jedoch unter vielen Konfigurationen schreiben. Und das ist viel komplizierter als es scheint. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Microsoft hatte jedoch ein größeres Problem: Windows. Sie sehen, Windows wollte die Hardware im Gegensatz zu DOS vollständig besitzen, was Entwicklern erlaubte, alles zu tun. Der Besitz von Eisen ist für die Wechselwirkung zwischen Anwendungen erforderlich. Aber diese Art der Interaktion ist genau das, was sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hassen.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spieleentwickler, weil es wertvolle Ressourcen verbraucht, die sie für alle möglichen coolen Dinge verwenden könnten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Spieleentwicklung unter Windows voranzutreiben, benötigte Microsoft eine einheitliche API, die auf niedriger Ebene verfügbar war, unter Windows ohne Leistungseinbußen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktionierte und mit verschiedener Hardware kompatibel war</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Eine einzige API für Grafik-, Sound- und Eingabegeräte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So wurde DirectX geboren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige Monate später erschienen 3D-Beschleuniger. Und Microsoft geriet in Schwierigkeiten. Tatsache ist, dass DirectDraw, eine Grafikkomponente von DirectX, nur mit 2D-Grafiken arbeitete: Es ordnete Grafikspeicher zu und führte schnelle Bitoperationen zwischen verschiedenen Speichersektoren durch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher kaufte Microsoft Software von Drittanbietern und verwandelte sie in Direct3D Version 3. Er wurde gescholten</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">absolut</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alles. Und es gab einen Grund: Das Lesen des Codes auf D3D v3 sah aus wie eine Entschlüsselung der Schriftsprache einer ausgestorbenen alten Zivilisation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der alte John Carmack von Id Software sah sich diese Schande an, sagte "Ja, es ging ..." und beschloss, mit einer anderen API zu schreiben: OpenGL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die andere Seite dieser verwirrenden Geschichte war jedoch, dass Microsoft mit SGI zusammengearbeitet hat, um OpenGL für Windows zu implementieren. Die Idee war, Entwickler typischer GL-Anwendungen für Workstations zu gewinnen: CAD, Modellierungssysteme und dergleichen. Die Spiele waren das Letzte, was sie dachten. Dies betraf hauptsächlich Windows NT, aber Microsoft entschied sich, OpenGL auch zu Windows 95 hinzuzufügen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um Entwickler von Software für Workstations unter Windows anzulocken, hat Microsoft beschlossen, sie mit Zugriff auf neue 3D-Beschleuniger zu bestechen. Sie implementierten ein Protokoll für installierte Client-Treiber: Eine Grafikkarte könnte die OpenGL-Software von Microsoft durch ihre Hardware-Implementierung ersetzen. Der Code verwendete automatisch Hardware OpenGL, falls verfügbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In jenen Tagen hatten Consumer-Grafikkarten jedoch keine OpenGL-Unterstützung. Dies hinderte Carmack nicht daran, Quake auf einer SGI-Workstation auf OpenGL zu portieren. In der Readme-Datei von GLQuake können Sie Folgendes lesen:</font></font><br>
<blockquote>, glquake     OpenGL,    texture objects.          ,   ,  ,     .      -  ,          .<br>
<br>
   ( 1997),     opengl ,   glquake   ,     intergraph realizm. 3dlabs    ,           .     3dlabs   glint  permedia    NT     ,      glquake    3dlabs.<br>
<br>
3dfx  opengl32.dll,      glquake,      opengl.  opengl-      ,       «  glquake».</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies war die Geburt der miniGL-Treiber. </font><font style="vertical-align: inherit;">Sie entwickelten sich schließlich zu vollwertigen OpenGL-Implementierungen, sobald die Hardware leistungsfähig genug wurde, um diese Funktionalität in der Hardware zu unterstützen. </font><font style="vertical-align: inherit;">nVidia war das erste Unternehmen, das eine vollständige Implementierung von OpenGL anbot. </font><font style="vertical-align: inherit;">Andere Anbieter waren immer noch langsam, was einer der Gründe für den Übergang zu Direct3D war, der von einer größeren Auswahl an Geräten unterstützt wurde. </font><font style="vertical-align: inherit;">Am Ende blieben nur nVidia und ATI (jetzt AMD) übrig, und beide hatten gute OpenGL-Implementierungen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Morgendämmerung von OpenGL</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Teilnehmer sind also definiert: Direct3D gegen OpenGL. Dies ist wirklich eine erstaunliche Geschichte, wenn man bedenkt, wie schlecht die D3D v3 war. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das OpenGL Architectural Review Board (ARB) ist die Organisation, die für die Wartung und Entwicklung von OpenGL verantwortlich ist. Sie geben viele Erweiterungen frei, enthalten ein Repository mit Erweiterungen und erstellen neue Versionen der API. ARB ist ein Komitee, das sich aus einer großen Anzahl von Akteuren der Computergrafikindustrie und einigen Betriebssystemherstellern zusammensetzt. Apple und Microsoft waren zu unterschiedlichen Zeiten auch Mitglieder von ARB.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3Dfx betritt die Szene mit seinem Voodoo2. Dies ist die erste Grafikkarte, mit der Sie Multitexturing durchführen können, die zuvor in OpenGL nicht bereitgestellt wurde. Während 3Dfx stark gegen OpenGL war, war nVidia, der nächste Hersteller des Multitexturing-Chips (TNT1), verrückt nach OpenGL. Dann veröffentlichte ARB die Erweiterung GL_ARB_multitexture, die den Zugriff auf mehrere Texturen ermöglichte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Zwischenzeit wird Direct3D v5 angezeigt. Jetzt ist D3D wirklich eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API geworden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , kein Unsinn. Was ist das Problem? In Abwesenheit von Multitexturing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ups</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies verursachte jedoch keine derartigen Unannehmlichkeiten, da fast niemand mehrere Texturen verwendete. Multitexturing beeinträchtigt die Leistung fast nicht, und in vielen Fällen ist der Unterschied vor dem Hintergrund von Multi-Pass unsichtbar. Und natürlich lieben Spieleentwickler ihre Spiele sehr, wenn sie sicher auf der alten Hardware arbeiten, die keine Unterstützung für mehrere Texturen bietet. Daher wurden viele Spiele ohne diese Hardware veröffentlicht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D3D atmete erleichtert auf.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Zeit verging und nVidia brachte die GeForce 256 auf den Markt (nicht zu verwechseln mit der allerersten GeForce GT-250) und stoppte den Kampf auf dem Grafikkartenmarkt für die nächsten zwei Jahre. Der Hauptwettbewerbsvorteil dieses Boards war die Fähigkeit, Scheitelpunkte und Beleuchtung (Transformation &amp; Beleuchtung, T &amp; L) in Hardware zu transformieren. Aber das ist nicht alles: nVidia OpenGL so sehr geliebt , </font><font style="vertical-align: inherit;">dass ihr T &amp; L-Engine tatsächlich </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gewesen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OpenGL. Fast buchstäblich! Soweit ich weiß, haben einige ihrer Register </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direkt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> numerische Werte von Variablen vom Typ GLenum erhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Direct3D v6 kommt heraus. Schließlich kamen mehrere Texturen rechtzeitig an ... aber ohne die Hardware-T &amp; L. OpenGL </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gab eine T &amp; L-Pipeline, die jedoch vor GeForce 256 in Software implementiert war. </font><font style="vertical-align: inherit;">Für nVidia erwies es sich daher als recht einfach, die Softwareimplementierung in eine Hardwarelösung umzuwandeln. </font><font style="vertical-align: inherit;">In D3D erschien Hardware T &amp; L nur in der siebten Version.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Morgendämmerung des Shader-Zeitalters, OpenGL im Dunkeln</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann kam GeForce 3. Gleichzeitig passierten viele interessante Dinge. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Microsoft entschied, dass sie nicht mehr zu spät kommen würden. Anstatt zu prüfen, was nVidia tun wird, und ihre Entwicklung bereits post-factum zu kopieren, traf Microsoft daher eine erstaunliche Entscheidung: Gehen Sie und sprechen Sie. Und sie verliebten sich und bekamen eine gemeinsame kleine Konsole. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die laute Scheidung ereignete sich später, aber das ist eine ganz andere Geschichte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für den PC-Markt bedeutete dies, dass GeForce 3 gleichzeitig mit D3D v8 herauskam und es leicht zu erkennen ist, wie sich GeForce 3 auf die D3D v8-Shader auswirkte. Die Pixel-Shader von Shader Model 1.0 waren </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stark geschärft für nVidia-Geräte. Es wurde kein einziger Versuch unternommen, nVidia von Eisen zu abstrahieren. Für das Shader-Modell 1.0 wurde die GeForce 3 entwickelt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als ATI mit seiner Radeon 8500 in das Grafik-Performance-Rennen einstieg, gab es ein Problem. Die Radeon 8500-Pixel-Pipeline erwies sich als leistungsstärker als die nVidia. Aus diesem Grund hat Microsoft das Shader Model 1.1 veröffentlicht, für das der 8500 im Grunde genommen </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
gedacht ist. Es klingt nach einer D3D-Niederlage, aber Erfolg und Misserfolg sind relative Begriffe. Tatsächlich </font><font style="vertical-align: inherit;">erwartete OpenGL </font><font style="vertical-align: inherit;">einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">epischen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehler. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NVidia mochte OpenGL sehr und nach der Veröffentlichung von GeForce 3 veröffentlichten sie eine ganze Reihe von Erweiterungen für OpenGL. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proprietär</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweiterungen, die nur auf nVidia funktionierten. Als das 8500-Board erschien, konnte es natürlich keines von ihnen verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf D3D 8 können Sie also mindestens SM 1.0-Shader ausführen. Natürlich musste ich neue Shader schreiben, um die ganze Coolness des 8500 nutzen zu können, aber der Code </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktionierte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zumindest </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shadern auf der OpenGL Radeon 8500, hatte ATI einige Erweiterungen zu OpenGL zu entwickeln. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proprietäre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erweiterungen, die nur mit ATI funktionierten. Damit Entwickler erklären konnten, dass sie Shader an ihre Engine angeschraubt hatten, mussten sie separaten Code für nVidia und separaten Code für ATI schreiben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie fragen sich vielleicht: "Und wo war das ARB-Komitee, das OpenGL flott unterstützen sollte?" Und dort landeten viele Komitees: Sie saßen und waren dumm. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass ich oben ARB_multitexture erwähnt habe, da diese Erweiterung stark in die gesamte Situation involviert ist. Einem externen Beobachter schien es, dass ARB die Idee von Shadern generell vermeiden möchte. Sie entschieden, dass, wenn sie einer festen Pipeline genügend Konfigurierbarkeit verleihen, diese in ihren Fähigkeiten einer programmierbaren Shader-Pipeline entspricht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ARB hat nacheinander Erweiterungen veröffentlicht. Jede Erweiterung mit den Worten "textur_env" im Namen war ein Versuch, dieses alternde Design zu reparieren. Schauen Sie sich die Liste der Erweiterungen an: </font><i><font style="vertical-align: inherit;">Acht</font></i><font style="vertical-align: inherit;"> solcher Erweiterungen wurden veröffentlicht</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teile, und viele von ihnen wurden in die Kernfunktionalität von OpenGL übersetzt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu dieser Zeit war Microsoft Teil von ARB und ließ es nur für die Veröffentlichung von D3D 9 übrig. Vielleicht hat Microsoft OpenGL auf irgendeine Weise sabotiert. Persönlich bezweifle ich diese Theorie aus zwei Gründen. Erstens müssten sie die Unterstützung anderer Mitglieder des Ausschusses sicherstellen, da jedes Mitglied nur eine Stimme hat. Zweitens, und was noch wichtiger ist, brauchte das Komitee nicht die Hilfe von Microsoft, um alles zu vermasseln, was wir später sehen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen erwachte ARB, höchstwahrscheinlich unter dem Druck von ATI und nVidia (beide sind aktive Teilnehmer), schließlich und führte Assembler-Shader in den Standard ein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Willst du eine noch verrücktere Geschichte? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hardware T &amp; L. Dies ist, was OpenGL </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ursprünglich hatte.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Um die höchstmögliche T &amp; L-Leistung der Hardware zu erzielen, müssen Sie Vertex-Daten auf der GPU speichern. Dennoch ist die GPU der Hauptverbraucher von Vertex-Daten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In D3D v7 führte Microsoft das Konzept der Vertex-Puffer ein, die Speicherblöcke in der GPU zuweisen und dort Vertex-Daten platzieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Möchten Sie wissen, wann gleichwertige Funktionen in OpenGL verfügbar sind? Ja, nVidia hat als größter OpenGL-Fan seine Erweiterung zum Speichern von Vertex-Arrays auf der GPU bereits zum Zeitpunkt der Veröffentlichung von GeForce 256 veröffentlicht. Aber wann hat ARB solche Funktionen eingeführt? </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwei Jahre später.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es war </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">danach</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie es Vertex- und Fragment-Shader (Pixel in Bezug auf D3D) genehmigt hat. </font><font style="vertical-align: inherit;">ARB brauchte so viel Zeit, um eine plattformübergreifende Lösung zum Speichern von Vertex-Daten im GPU-Speicher zu entwickeln. </font><font style="vertical-align: inherit;">Und das ist , </font><font style="vertical-align: inherit;">was </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie brauchen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um Hardware-T &amp; L maximale Kapazität erreicht hat.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Sprache, um sie alle zu töten</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpenGL ist also seit einiger Zeit kaputt. In der GPU gab es keine plattformübergreifenden Shader und keinen hardwareunabhängigen Vertex-Speicher, während D3D-Benutzer beides genossen. Könnte es noch schlimmer werden? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Man könnte sagen, dass es könnte. Treffen Sie: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3D Labs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie fragen: Wer sind sie? Sie sind eine tote Firma, die ich für den wahren Killer von OpenGL halte. Natürlich machte das allgemeine Versagen des Komitees OpenGL anfällig, während es D3D in Stücke reißen sollte. Aber meiner Meinung nach ist 3D Labs vielleicht der einzige Grund für die aktuelle Marktposition von OpenGL. Was haben sie dafür getan? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie entwickelten eine Shader-Sprache für OpenGL.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3D Labs war eine aussterbende Firma. Ihre teuren GPUs wurden durch den ständig wachsenden Druck von nVidia aus dem Workstation-Markt verdrängt. Und im Gegensatz zu nVidia wurden 3D Labs nicht auf dem Verbrauchermarkt eingeführt. Der Sieg von nVidia würde für 3D Labs den Tod bedeuten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was letztendlich passiert ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um in einer Welt über Wasser zu sein, in der ihre Produkte nicht benötigt wurden, zeigten sich 3D Labs auf der Spieleentwicklerkonferenz mit einer Präsentation dessen, was sie "OpenGL 2.0" nannten. Es war eine OpenGL-API, die von Grund auf neu geschrieben wurde. Und das machte Sinn, denn damals war die OpenGL-API voller Müll (der jedoch bis heute dort bleibt). Schauen Sie sich zumindest an, wie esoterisch das Laden und Binden von Texturen erfolgt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Teil ihres Vorschlags war die Shader-Sprache. Ja, das ist er. Im Gegensatz zu den vorhandenen plattformübergreifenden Erweiterungen war ihre Shader-Sprache jedoch "High Level" (C ist ein High Level für die Shader-Sprache). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gleichzeitig arbeitete Microsoft an einer eigenen Shader-Sprache. Was sie, einschließlich all ihrer kollektiven Vorstellungskraft, als ... High Level Shader Language (HLSL) bezeichneten. Ihre Herangehensweise an die Sprache war jedoch grundlegend anders.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das größte Problem bei 3D Labs war, dass es einbettbar war. Microsoft hat seine eigene Sprache vollständig bestimmt. Sie veröffentlichten einen Compiler, der Assembly-Code für SM 2.0-Shader (oder höher) generierte, der wiederum an D3D weitergeleitet werden konnte. In den Tagen von D3D v9 hat HLSL D3D nie direkt berührt. Er war eine gute, aber optionale Abstraktion. Der Entwickler hatte immer die Möglichkeit, den Compiler-Auspuff für maximale Leistung zu optimieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3D Labs </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hatte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nichts davon. Sie geben dem Treiber eine C-ähnliche Sprache und es wird ein Shader erstellt. Das ist alles Kein Assembler-Shader, nichts, was etwas anderem zugeführt werden kann. Nur ein OpenGL-Objekt, das einen Shader darstellt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für OpenGL-Benutzer bedeutete dies, dass sie den Launen von OpenGL-Entwicklern ausgesetzt waren, die gerade gelernt hatten, Assembler-ähnliche Sprachen zu kompilieren. OpenGL Shader Language Compiler (GLSL) toben über Fehler. Um die Sache noch schlimmer zu machen: Wenn Sie den Shader dazu bringen konnten, auf verschiedenen Plattformen korrekt zu kompilieren (was an sich schon eine große Leistung war), unterlag er immer noch </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimierern</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jener Zeit, die nicht so optimal waren, wie sie sein konnten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies war ein großer, aber nicht der einzige Nachteil von GLSL. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> davon entfernt, der einzige zu sein.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In D3D können Sie wie in den alten OpenGL-Assembler-Sprachen Vertex- und Fragment-Shader auf jede mögliche Weise mischen und anpassen. Sie können jeden Vertex-Shader mit jedem kompatiblen Fragment-Shader verwenden, wenn diese über dieselbe Schnittstelle interagieren. Darüber hinaus war sogar eine gewisse Inkompatibilität zulässig: Beispielsweise konnte der Vertex-Shader einen Wert ausgeben, der vom Fragment-Shader nicht verwendet wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In GLSL gab es nichts Vergleichbares. Der Scheitelpunkt und die Fragment-Shader verschmolzen zu einem sogenannten "Software-Objekt" von 3D Labs. Für die gemeinsame Verwendung mehrerer Vertex- und Fragment-Shader in verschiedenen Kombinationen war es daher erforderlich, mehrere Programmobjekte zu erstellen. Dies verursachte das zweitgrößte Problem.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3D Labs hielten sie für die klügsten. Sie nahmen C / C ++ als Grundlage für das GLSL-Kompilierungsmodell. In diesem Fall nehmen Sie eine C-Datei und kompilieren sie in eine Objektdatei. Nehmen Sie dann mehrere Objektdateien und komponieren Sie sie zu einem Programm. So kompiliert GLSL: Zuerst kompilieren Sie einen Vertex- oder Fragment-Shader in ein Shader-Objekt, fügen diese Objekte dann in ein Programmobjekt ein und fügen sie schließlich zu einem Programm zusammen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Theoretisch konnten so coole Dinge wie "Bibliotheks" -Shader angezeigt werden, die Code enthalten, der vom Haupt-Shader aufgerufen wird. In der Praxis führte dies dazu, dass Shader </font><i><font style="vertical-align: inherit;">zweimal</font></i><font style="vertical-align: inherit;"> kompiliert wurden</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Einmal in der Kompilierungsphase und ein zweites Mal in der Kompilierungsphase. Insbesondere der Compiler von nVidia war dafür bekannt. Es wurde kein Zwischenobjektcode generiert. Er hat zu Beginn kompiliert, das Ergebnis verworfen und im Stadium der Kompilierung erneut kompiliert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Vertex-Shader an zwei verschiedene Fragment-Shader anzuhängen, war es daher erforderlich, viel mehr als in D3D zu kompilieren. Insbesondere wenn man bedenkt, dass die gesamte Kompilierung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offline</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erfolgt und nicht bevor das Programm direkt ausgeführt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GLSL hatte andere Probleme. Vielleicht wäre es falsch, 3D Labs die Schuld an allen Fehlern zu geben, da ARB am Ende die Sprache der Shader in OpenGL genehmigt und aufgenommen hat (aber nichts anderes aus den Vorschlägen von 3DLabs). Die ursprüngliche Idee war jedoch immer noch für 3D Labs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt das Traurigste: 3D Labs hatten </font><font style="vertical-align: inherit;">(meistens) </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . GLSL ist zu diesem Zeitpunkt keine Vektorsprache wie HLSL. Dies geschah, weil die Hardware von 3D Labs skalar war (wie die moderne Hardware von nVidia) und sie bei der Wahl der Richtung, der viele Gerätehersteller später folgten, völlig richtig waren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie hatten Recht mit der Wahl des Kompilierungsmodells für die "Hochsprache". Sogar D3D kam endlich dazu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem ist, dass 3D Labs zur falschen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> richtig </font><i><font style="vertical-align: inherit;">waren</font></i><font style="vertical-align: inherit;"> . Und bei dem Versuch, vorzeitig in die Zukunft zu gelangen, bei dem Versuch, für die Zukunft gerüstet zu sein, legen sie die Gegenwart beiseite. Es sieht aus wie die T &amp; L-Funktionalität in OpenGL, die schon immer darin enthalten war. Außer die OpenGL T &amp; L-Pipeline war </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nützlich</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und vor dem Aufkommen von Hardware T &amp; L war GLSL eine Belastung, bevor der Rest der Welt ihn einholte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GLSL ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jetzt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine gute Sprache </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber was war damals? </font><font style="vertical-align: inherit;">Er war schrecklich. </font><font style="vertical-align: inherit;">Und OpenGL litt darunter.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf dem Weg zur Apotheose</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich unterstütze die Ansicht, dass 3D Labs OpenGL einen tödlichen Schlag versetzt hat, aber der letzte Nagel im Sarg wurde von ARB selbst erzielt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie haben diese Geschichte vielleicht gehört. In den Tagen von OpenGL 2.1 hatte OpenGL große Probleme. Er hatte eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menge</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kompatibilität. Die API war nicht mehr einfach zu bedienen. Eines kann auf fünf verschiedene Arten geschehen, und es ist nicht klar, welches schneller ist. Sie könnten OpenGL mit einfachen Tutorials „lernen“, aber Sie haben OpenGL nicht gelernt, das echte Grafikleistung und -leistung bietet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ARB beschloss, einen weiteren Versuch zu unternehmen, OpenGL zu erfinden. Es war wie "OpenGL 2.0" von 3D Labs, aber besser, weil ARB hinter diesem Versuch stand. Sie nannten es "Longs Peak".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist so schlimm daran, ein wenig Zeit damit zu verbringen, die API zu verbessern? Die schlechte Nachricht ist, dass Microsoft in einer ziemlich prekären Lage ist. Dies war die Zeit für ein Upgrade auf Vista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Vista hat Microsoft beschlossen, überfällige Änderungen an Grafiktreibern vorzunehmen. Sie zwangen die Treiber, sich zur Virtualisierung des Grafikspeichers und vieler anderer an das Betriebssystem zu wenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können lange über die Vorzüge dieses Ansatzes streiten und darüber, ob dies überhaupt möglich war, aber die Tatsache bleibt: Microsoft hat D3D 10 nur für Vista und höher entwickelt. Selbst auf einer </font><font style="vertical-align: inherit;">D3D- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kompatiblen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hardware war es unmöglich, eine D3D-Anwendung ohne Vista auszuführen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie erinnern sich vielleicht, dass Vista ... sagen wir, es hat nicht sehr gut funktioniert. Wir hatten also ein gemächliches Betriebssystem, eine neue API, die nur auf diesem Betriebssystem funktioniert, und eine neue Generation von Hardware, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diese API und dieses Betriebssystem benötigt, um mehr als nur die Leistung der vorherigen Generation zu übertreffen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entwickler </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">könnten jedoch</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D3D 10-Level-Funktionen über OpenGL verwenden. Das heißt, sie könnten, wenn ARB nicht damit beschäftigt wäre, an Long Peaks zu arbeiten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ARB hat gut anderthalb bis zwei Jahre an der Verbesserung der API gearbeitet. Als OpenGL 3.0 veröffentlicht wurde, war der Übergang zu Vista beendet, Windows 7 war auf dem Weg und Spieleentwickler kümmerten sich nicht mehr um die Funktionalität der D3D 10-Version. Am Ende funktionierte die Ausrüstung für D3D 10 perfekt mit Anwendungen auf D3D 9. Mit der zunehmenden Portierung von PC auf Konsole (oder mit dem Übergang von PC-Entwicklern zum Konsolenmarkt) benötigten Entwickler immer weniger die Funktionalität von D3D 10. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Entwickler auch unter Windows XP auf diese Funktionalität zugreifen könnten, könnte die Entwicklung von OpenGL eine lebensspendende Belastung für Lebendigkeit darstellen. Aber ARB hat diese Gelegenheit verpasst. Möchten Sie wissen, was das Schlimmste ist? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ARB </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fehlgeschlagen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erfinden Sie die API von Grund auf neu, obwohl Sie zwei kostbare Jahre damit verbracht haben, dies zu tun. </font><font style="vertical-align: inherit;">Daher gaben sie den Status Quo zurück und fügten nur einen Mechanismus hinzu, um die Funktionalität für veraltet zu erklären. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen verpasste ARB nicht nur die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wichtigsten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gelegenheiten, sondern versäumte es auch, die Arbeit zu erledigen, die sie zu dieser Unterlassung führte. </font><font style="vertical-align: inherit;">Es war ein epischer Fehlschlag in alle Richtungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist die Geschichte der Konfrontation zwischen OpenGL und Direct3D. </font><font style="vertical-align: inherit;">Die Geschichte verpasster Gelegenheiten, größter Dummheit, absichtlicher Rücksichtslosigkeit und banaler Absurditäten.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de397309/">https://habr.com/ru/post/de397309/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de397299/index.html">Leckeres Huhn</a></li>
<li><a href="../de397301/index.html">Der Höhepunkt des Programms: Lenovo YOGA Book auf der IFA 2016</a></li>
<li><a href="../de397303/index.html">Erweiterung der Bakterienfront der Antibiotika-Arena: Ein spektakuläres Experiment an der Harvard Medical School</a></li>
<li><a href="../de397305/index.html">Wie japanische Bauern Gurken mit Deep Learning und TensorFlow sortierten</a></li>
<li><a href="../de397307/index.html">Vortrag "Unsichtbare Schwierigkeiten der Raumfahrttechnik"</a></li>
<li><a href="../de397311/index.html">Bestätigte die Existenz von Kryovulkanen auf Ceres</a></li>
<li><a href="../de397313/index.html">Fügen Sie einfach Wasser hinzu. Ein kleines Additiv H₂O erhöht die Leistung des Verbrennungsmotors und spart Kraftstoff</a></li>
<li><a href="../de397315/index.html">Automatische Treppenbeleuchtung</a></li>
<li><a href="../de397317/index.html">Werksüberholt: Wir kaufen Elektronik günstig und mit Garantie</a></li>
<li><a href="../de397319/index.html">Internet der Dinge: LoRa vs. UNB. Teil 2: Geschäft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>