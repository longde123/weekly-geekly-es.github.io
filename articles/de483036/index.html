<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽🏿 🎦 🌵 n-Queens Completion Problem - linearer Lösungsalgorithmus 👩🏿‍⚕️ ↩️ 🚭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ericgrig 



 Vorwort 
 Ich möchte das Vorwort mit Dankesworten an zwei wundervolle Programmierer aus Odessa beginnen: Andrei Kiper (Lohica) und Timur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>n-Queens Completion Problem - linearer Lösungsalgorithmus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483036/">  Ericgrig <br><p><br></p><h4>  Vorwort </h4><br>  Ich möchte das Vorwort mit Dankesworten an zwei wundervolle Programmierer aus Odessa beginnen: Andrei Kiper (Lohica) und Timur Giorgadze (Luxoft), um meine Ergebnisse in der Anfangsphase der Studie unabhängig zu verifizieren. <br><br><ol><li>  Der Artikel "Linearer Algorithmus zur Lösung des n-Queens-Abschlussproblems" wurde zu Beginn des ersten Tages des Jahres 2020 in <a href="https://arxiv.org/pdf/1912.05935.pdf">(arXiv.org)</a> veröffentlicht.  Ursprünglich war der Artikel in russischer Sprache verfasst, daher wird hier die grundlegende Präsentation vorgestellt und dort die Übersetzung. </li><li>  Diese Aufgabe und einige andere der vielen NP-Komplettsätze (die Aufgabe, Boolesche Formeln (3-SAT) zu erfüllen, die Aufgabe, die maximale Clique oder eine Clique einer bestimmten Größe zu finden ...) zu unterschiedlichen Zeiten waren in meinem Interesse.  Ich suchte nach einer algorithmischen Lösung, die auf verschiedenen Computerexperimenten basierte, aber es gab keinen konkreten Erfolg.  Es war wie ein Mensch, der zu lernen versuchte, wie man an einem Arm auf der horizontalen Stange fit wird.  Es gibt kein Ergebnis, aber jedes Mal gibt es die Hoffnung, dass alles bald klappt.  Das letzte Mal, als ich mich entschied, länger bei der n-Queens-Abschlussaufgabe zu bleiben (als eines der Familienmitglieder) und zu versuchen, etwas zu tun.  Es ist angebracht, sich an den wunderbaren Odessa-Witz zu erinnern: "In einem überfüllten Bus, der abends auf einer holprigen Straße in die Vororte zurückkehrt, ist eine Frauenstimme zu hören - Mann, wenn Sie mich völlig überfallen haben, dann tun Sie wenigstens etwas." </li><li>  Das Studium dauerte lange genug - fast eineinhalb Jahre.  Dies liegt zum einen daran, dass andere Aufgaben im Forschungsprozess berücksichtigt wurden, zum anderen gab es auf dem Weg schwierige Fragen, ohne die wir nicht weiterkommen könnten.  Ich werde einige von ihnen auflisten: <br><br><ul><li>  Es gibt n Zeilen in der Entscheidungsmatrix. In welcher Reihenfolge sollte der Zeilenindex ausgewählt werden, wenn die Anzahl der Möglichkeiten für eine solche Auswahl n beträgt! </li><li>  Wenn eine Reihe erstellt wird, sollte die verbleibende freie Position in dieser Reihe ausgewählt werden, da die Anzahl der Möglichkeiten für eine solche Auswahl so groß ist, dass sie als „enger Verwandter“ der Unendlichkeit angesehen werden kann (z. B. die Anzahl der Möglichkeiten, eine freie Position in allen Reihen für ein Schachbrett der Größe 100 auszuwählen x 100 ist ungefähr 10 <sup>124</sup> ) </li><li>  Zusammen bilden diese beiden Indikatoren einen Zustandsraum (einen Auswahlraum).  Es sieht so aus, als gäbe es riesige Möglichkeiten, Sie können wählen, was Sie wollen.  Hinter jeder spezifischen Auswahl bei jedem Schritt steht jedoch ein anderes Problem - die Einschränkung der Auswahl in allen nachfolgenden Schritten.  Darüber hinaus ist dies in den letzten Phasen der Problemlösung besonders heikel.  Wir können sagen, dass die Entscheidungsmatrix "rachsüchtig" ist.  Alle „unbewussten Fehler“, die Sie bei der Auswahl in den vorherigen Phasen gemacht haben, werden „akkumuliert“. Am Ende der Entscheidung zeigt sich dies in der Tatsache, dass in den Zeilen, in denen Sie die Königin platzieren sollten, keine leeren Positionen mehr vorhanden sind und der Suchzweig zum Stillstand kommt .  Hier, wie bei Zhvanetsky: "Ein falscher Zug, und Sie sind schwanger." </li><li>  Wenn der Zweig der Suche nach einer Lösung zum Stillstand kommt, haben wir die Möglichkeit, zu einigen der vorherigen Positionen zurückzukehren (Back Tracking), so dass wir von dieser Position aus wieder mit der Bildung des Zweigs der Suche nach einer Lösung beginnen.  Dies ist eine natürliche „Eigenschaft“ nicht deterministischer Probleme.  Die Frage ist, welche der vorherigen Ebenen zurückgegeben werden sollen.  Dies ist das gleiche offene Problem wie die Frage der Auswahl des Zeilenindex oder der Auswahl einer freien Position in dieser Zeile. </li><li>  Schließlich sollte ein Problem in Bezug auf die Geschwindigkeit des Algorithmus festgestellt werden.  Es wäre traurig, wenn es kein Ziel gäbe, schnell laufende Algorithmen zu entwickeln.  Bei der Modellierung war es nicht möglich, einen Algorithmus zu entwickeln, der in allen Bereichen der Problemlösung schnell und effizient funktioniert.  Ich musste drei Algorithmen entwickeln.  Sie übertragen die Ergebnisse wie ein Schlagstock aufeinander.  Einer von ihnen arbeitet sehr schnell, aber unhöflich, der andere - im Gegenteil, arbeitet langsam, aber effizient.  Jeder von ihnen arbeitet in der „Zone ihrer Verantwortung“. </li></ul></li><li>  Der Zweck der Studie bestand zunächst nur darin, zumindest eine Lösung zu finden.  Ich musste viel herausfinden, bevor die erste Lösung entwickelt wurde.  Es dauerte mehr als vier Monate.  Es war möglich dort anzuhalten, das Ziel wurde erreicht - na ja, okay.  Es schien mir jedoch, dass nicht alle Möglichkeiten einer algorithmischen Lösung dieses Problems ausgeschöpft waren.  Natürlich bestand der Wunsch, den entwickelten Algorithmus so zu verbessern, dass die zeitliche Komplexität des Algorithmus linear-O (n) war.  Als eine solche lineare Lösung gefunden wurde, gab es "einen weiteren Wunsch" - die Anzahl der Fälle zu reduzieren, in denen das Back Tracking (BT) -Verfahren bei der Bildung des Lösungssuchzweigs verwendet wurde.  Es war ein "unverschämter" Wunsch, die Aufgabe von nicht deterministisch auf bedingt determiniert (so weit wie möglich) zu übertragen.  Es hat lange gedauert, aber das Ziel wurde beispielsweise im Bereich der Schachbrettgrößenwerte n = (320, ..., 22500) erreicht, die Anzahl der Fälle, in denen das BT-Verfahren nie angewendet wird, beträgt mehr als 50%.  Es stellt sich heraus, dass in 50% der Fälle, in denen das Programm gestartet wird, der Algorithmus „absichtlich“ eine Lösung bildet und niemals „stolpert“.  (Ich erinnere mich an das Märchen über den Goldfisch und dachte über diese beiden Wünsche nach ...) </li><li>  Beim Vergleich der Veröffentlichungen, die ich während der Recherche kennenlernen durfte, kam ich zu dem Ergebnis, dass dieses Problem und andere Probleme dieser Art nicht auf der Grundlage eines rigorosen mathematischen Ansatzes gelöst werden können, d. H. Nur auf der Grundlage von Definitionen, Lemmasätzen und Theoremsätzen.  In dem Artikel gibt es eine "philosophische Bemerkung" dazu.  Ich bin mir sicher, dass viele Probleme aus den vielen NP-Complete nur auf der Basis algorithmischer Mathematik mit Hilfe von Computersimulationen gelöst werden können.  Eine solche Schlussfolgerung bedeutet nicht, die Mathematik einzuschränken, sondern vielmehr, die Fähigkeiten der Mathematik durch die Entwicklung algorithmischer mathematischer Methoden zu erweitern.  Für jede Familie von Problemen müssen Sie Ihren eigenen angemessenen mathematischen Ansatz verwenden.  (Warum sollte man einen Doktoranden beauftragen, ein Problem aus der NP-Complete-Familie zu lösen, ohne algorithmische Mathematik und Computermodellierungsmethoden anzuwenden, wenn bekannt ist, dass aus einem solchen Unterfangen eigentlich nichts wird?) </li><li>  Jeder Algorithmus (Programm) hat eine einfache Eigenschaft - entweder funktioniert er oder nicht!  Ich möchte die Mitglieder unserer Habro-Community ansprechen, die einen Computer mit Matlab in der Barrierefreiheit installiert haben.  Ich möchte Sie bitten, die Funktionsweise des in Betracht gezogenen Algorithmus zur Lösung des <i>n-Queens-Abschlussproblems</i> zu testen.  Dies dauert nur 5-10 Minuten.  Um den Algorithmus zu testen, müssen Sie einige einfache Schritte ausführen: <br><br><ul><li>  Generiere eine zufällige Komposition aus <i>k</i> Königinnen und überprüfe die Korrektheit dieser Komposition. </li><li>  Vervollständigen Sie diese Zusammensetzung auf der Grundlage des vorgeschlagenen Entscheidungsalgorithmus zu einer vollständigen Lösung.  Oder das Programm muss entscheiden, dass diese Zusammensetzung keine Lösung hat. </li><li>  Überprüfen Sie die Richtigkeit der durch die Konfiguration erhaltenen Lösung. </li></ul><br><br>  Sie müssen für solche Tests keinen Code schreiben.  Zusätzlich zum Hauptprogramm habe ich zwei weitere Programme in der Matlab-Sprache vorbereitet: <br><br>  1. <i>Generarion_k_Queens_Composition</i> - Erzeugung einer zufälligen Komposition der Größe <i>k</i> für ein beliebiges Schachbrett der Größe <i>nxn</i> <br><br>  2. <i>Completion_k_Queens_Composition.m</i> - Vervollständigen einer beliebigen Komposition bis zu einer vollständigen Entscheidung oder Entscheiden, dass diese Komposition keine Lösung hat ( <b>Hauptprogramm</b> ). <br><br>  3. <i>Validation_n_Queens_Solution.m</i> - Überprüfung der Richtigkeit der Lösung des <i>n-Queens-Problems</i> oder der Richtigkeit der Zusammensetzung von <i>k</i> Königinnen. <br><br>  Sie arbeiten sehr schnell.  Zum Beispiel für ein Schachbrett mit einer Größe von <i>1000 x 1000</i> Zellen, die Gesamtzeit, die durchschnittlich benötigt wird, um eine beliebige Zusammensetzung zu erzeugen (0,0015 s), diese Zusammensetzung zu vervollständigen (0,0622 s) und die Richtigkeit der erhaltenen Lösung zu überprüfen (0,0003 s). 0,1 Sekunden nicht überschreitet.  (Ausgenommen die Zeit, die zum Herunterladen der Daten oder Speichern der Ergebnisse benötigt wird.) <br><br>  Schicken Sie mir eine E-Mail (ericgrig@gmail.com), wenn Sie die Möglichkeit haben, einem Freund zu helfen, sende ich Ihnen diese drei Programme umgehend zu.  Ich bin allen Kollegen dankbar, die den Algorithmus objektiv testen und ihre Meinung in der Diskussion äußern können. </li><li>  Ich habe den Quellcode des Programms mit detaillierten Kommentaren erstellt, die hoffentlich bald auf Habré veröffentlicht werden.  Ich denke, dass diejenigen, die an der Lösung komplexer Probleme aus der <i>NP-Complete-</i> Familie interessiert sind, etwas Interessantes für sich finden. </li><li>  Ich möchte noch einmal an die Mitglieder der Habr-Gemeinschaft appellieren, aber aus einem anderen Grund.  Hier in Marseille (Frankreich) wird das Team der <i>France Fold Group gebildet</i> , mit dem Algorithmen zur Vorhersage der physikochemischen Eigenschaften von Verbindungen mit hohem Molekulargewicht erforscht und entwickelt werden sollen.  Ich denke, es ist nicht wert zu sagen, dass dies eine ziemlich schwierige Aufgabe mit einer langen Geschichte ist und dass ernsthafte Teams in verschiedenen Ländern an diesem Problem arbeiten, einschließlich des <i>Khasabis-</i> Teams von <i>Deep Mind</i> (Sie können den Artikel auf Habré <a href="https://habr.com/ru/post/431948/">(habr.com_Folding) sehen)</a> . Ziel ist es, ein starkes Team zu bilden, das keine Angst vor der Lösung komplexer Probleme hat. Die Form der Organisation der gemeinsamen Arbeit ist verteilt. Jedes Teammitglied lebt in seiner Stadt und arbeitet in seiner Freizeit an dem Projekt. Wir brauchen Programmierer und Forscher (Physiker, Chemiker, Mathematiker, Biologen). ) usw.  osto "rücksichtslose" Programmierer- (squared). Schreiben Sie mir, wenn Sie es interessant finden, die oben ist meine E-Mail. Ausführlicher kann ich im Antwortschreiben erzählen. </li></ol><br>  Das Vorwort zum Artikel war genauso lang wie der Artikel.  Das Format der Familienpräsentation auf Habré ermöglicht es mir, meine Gedanken freier auszudrücken, aber gemessen an der Größe habe ich es ziemlich frei ausgenutzt.  Ich wollte kurz schreiben, aber "es stellte sich heraus wie immer." <br><br>  PS Ich dachte, dass die Mitglieder der Habr-Community interessiert wären, auf welche Schwierigkeiten ich stieß, wenn ich die Ergebnisse der Studie veröffentlichen wollte.  Als der Artikel erstellt wurde, habe ich ihn gemäß den Anforderungen des Journal of Artificial Intelligence Research (JAIR) in das .tex-Format umformatiert und dorthin gesendet.  Früher gab es Veröffentlichungen zu einem ähnlichen Thema.  Besonders hervorzuheben ist der Artikel <i>C. Gent, I.-P.</i>  <i>Jefferson und P. Nightingale (2017)</i> <a href="https://jair.org/index.php/jair/article/view/11079/26262">(Komplexität der Fertigstellung von n-Königinnen)</a> , in denen die Autoren bewiesen haben, dass das betreffende Problem zum NP-Complete-Set gehört, und über die Schwierigkeiten bei der Lösung dieses Problems sprachen.  In den Schlussfolgerungen schreiben die Autoren: „Für jeden, der die Regeln des Schachs versteht, kann die n-Queens-Vervollständigung eines der natürlichsten NP-Complete-Probleme von allen sein.“ ( <i>Für jeden, der die Regeln des Schachs versteht, kann die n-Queens-Vervollständigungsaufgabe eine von ihnen werden die natürlichsten NP-Complete Aufgaben</i> ). <br><br>  Nach 10 Tagen erhielt ich eine Absage von JAIR mit dem Wortlaut: "Der Artikel entspricht nicht dem Format der Zeitschrift."  Ich habe den Artikel nicht einmal in Betracht gezogen.  Mit einer solchen Antwort habe ich nicht gerechnet.  Ich dachte, wenn eine Zeitschrift Artikel veröffentlicht, in denen die Autoren zu dem Schluss kommen, dass es sehr schwierig ist, ein bestimmtes Problem zu lösen, und keine konkrete Lösung liefert, wird der Artikel, der einen effektiven Lösungsalgorithmus liefert, mit Sicherheit zur Prüfung angenommen.  Die Redaktion hatte jedoch eine eigene Meinung zu diesem Thema.  (Ich glaube, dass dort kompetente Spezialisten arbeiten, und höchstwahrscheinlich wurden sie durch den „unverschämten“ Titel des Artikels und alles, was dort steht, in Frage gestellt. Wir dachten, „es liegt höchstwahrscheinlich ein Fehler vor und schickten mich vorsichtig weg, bezogen auf das Format "). <br><br>  Ich musste mich für eine andere von Experten begutachtete periodische wissenschaftliche Veröffentlichung zu relevanten Themen entscheiden.  Hier bin ich mit der harten Realität konfrontiert.  Fakt ist, dass ungefähr 80% aller Zeitschriften bezahlt werden: Entweder muss ich einen anständigen Betrag an die Zeitschrift zahlen, damit der Artikel für alle Leser frei verfügbar ist, oder sie müssen den Artikel als Geschenk "in the bow" geben und sie werden jeden in Rechnung stellen, der möchte diese Studie kennenlernen.  Und die erste und die zweite Option sind für mich grundsätzlich inakzeptabel.  Ich fühlte mich gut mit dieser Art des Verlagsschlägers, als ich versuchte, mich mit einigen Veröffentlichungen vertraut zu machen. <br><br>  Die nächste Zeitschrift, die sich zum Prinzip des freien Zugangs zu Informationen bekennt, war <i>das SMAI Journal of Computational Mathematics</i> .  Sie weigerten sich auch mit dem gleichen Wortlaut, wenn auch viel schneller - in zwei Tagen. <br><br>  Dann wurde eine Zeitschrift ausgewählt: <i>Diskrete Mathematik und Theoretische Informatik</i> .  Hier sind die Anforderungen einfach: Zuerst müssen Sie den Artikel in arXiv.org veröffentlichen und erst danach müssen Sie den Artikel zur Prüfung registrieren.  Okay, wir werden die Regeln befolgen - ich habe einen Artikel in <i>arXiv.org</i> eingereicht.  Sie schrieben mir, dass sie den Artikel in 8 Stunden veröffentlichen würden.  Dies geschah jedoch nicht nach 8 Stunden, nicht nach 8 Tagen.  Der Artikel wurde von den Mentoren „festgehalten“ und erst nach 9 Tagen veröffentlicht.  Es gab keine Beschwerden in Form und Inhalt des Artikels.  Ich denke, wie im Fall von JAIR hatten Mentoren Zweifel an der Möglichkeit, "dies zu tun und darüber zu schreiben".  Einige Zeit später wurde der Artikel nach Korrektur technischer Fehler aktualisiert und in seiner endgültigen Form in der Neujahrsnacht veröffentlicht. <br><br>  Ich muss im Detail darauf eingehen, um zu zeigen, dass es zum Zeitpunkt der Veröffentlichung der Forschungsergebnisse Probleme geben kann, die sich nicht logisch erklären lassen. <br><br>  Das Folgende ist ein Artikel, dessen Übersetzung ins Englische unter <a href="https://arxiv.org/pdf/1912.05935.pdf">(arXiv.org) veröffentlicht wurde</a> . <br><br><h3>  1. Einleitung </h3><br>  Unter den verschiedenen Möglichkeiten, das <i>n-Queens-Problem</i> zu formulieren, nimmt <i>die</i> betreffende <i>n-Queens-Completion-</i> Aufgabe aufgrund ihrer Komplexität eine Sonderstellung ein.  In ihrer Arbeit <a href="https://jair.org/index.php/jair/article/view/11079/26262">(Gent at all (2017))</a> zeigte sich, dass das <i>n-Queens Completion-Problem</i> zur Menge <i>NP-Complete gehört</i> ( <i>zeigte, dass n-Queens Completion sowohl NP-Complete als auch # P-Complete ist</i> ).  Es wird davon ausgegangen, dass die Lösung dieses Problems uns den Weg zur Lösung einiger anderer Probleme aus dem Satz von <i>NP-Complete ebnen kann</i> . <br><br>  Das Problem wird wie folgt formuliert.  Es gibt eine Komposition von <i>k</i> Königinnen, die gleichmäßig auf einem Schachbrett der Größe <i>nxn verteilt sind</i> .  Es muss nachgewiesen werden, dass diese Zusammensetzung zu einer vollständigen Lösung vervollständigt werden kann, und es muss mindestens eine Lösung angegeben werden, oder es muss nachgewiesen werden, dass eine solche Lösung nicht existiert.  Mit Konsistenz ist hier eine Zusammensetzung von <i>k</i> Königinnen gemeint, für die drei Bedingungen des Problems erfüllt sind: In jeder Reihe, jeder Spalte und auch auf der linken und rechten Diagonale, die durch die Zelle gehen, in der sich die Königin befindet, befindet sich nicht mehr als eine Königin.  Das Problem in dieser Form wurde erstmals von <i>Nauk (1850)</i> formuliert. <br><br>  <b>1.1 Definitionen</b> <br><br>  Im Folgenden werden wir die Größe der Seite des Schachbretts mit dem Symbol <i>n bezeichnen</i> .  Eine Lösung wird als vollständig bezeichnet, wenn alle <i>n</i> Königinnen konsistent auf einem Schachbrett platziert sind.  Bei allen anderen Lösungen wird die Komposition aufgerufen, wenn die Anzahl <i>k der</i> korrekt platzierten Königinnen kleiner als <i>n ist</i> .  Wir bezeichnen eine Zusammensetzung von <i>k</i> Königinnen als positiv, wenn sie vor einer vollständigen Lösung abgeschlossen werden kann.  Dementsprechend wird eine Zusammensetzung, die erst mit einer vollständigen Lösung abgeschlossen werden kann, als negativ bezeichnet.  Als Analogie zu einem "Schachbrett" der Größe <i>nxn betrachten</i> wir auch eine "Lösungsmatrix" der Größe <i>nxn</i> .  Als Beispiel werden alle zur Lösung des Problems entwickelten Algorithmen in der Matlab-Sprache dargestellt. <br><br>  Die Studie wurde auf der Basis einer Computersimulation (Computersimulation) durchgeführt.  Um diese oder jene Hypothese zu testen, führten wir Rechnerexperimente in einem weiten Bereich von Werten <i>n</i> = (10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 500, 800, 1000, 3000, 5000, 10000, 30 000, 50 000, 80 000, 10 <sup>5</sup> , 3 · 10 <sup>5</sup> , 5 · 10 <sup>5</sup> , 10 <sup>6</sup> , 3 · 10 <sup>6</sup> , 5 · 10 <sup>6</sup> , 10 <sup>7</sup> , 3 · 10 <sup>7</sup> , 5 · 10 <sup>7</sup> , 8 * 10 <sup>7</sup> , 10 <sup>8</sup> ) und in Abhängigkeit von dem Wert von <i>n</i> wurden ausreichend große Proben zur Analyse erzeugt.  Wir bezeichnen eine solche Liste als " <i>Basisliste von n Werten</i> " für die Durchführung von Computerexperimenten.  Alle Berechnungen wurden auf einem normalen Computer durchgeführt.  Zum Zeitpunkt der Montage (Anfang 2013) war die Konfiguration recht erfolgreich: <i>CPU - Intel Core i7-3820, 3,60 GH, RAM-32,0 GB, GPU-NVIDIA GeForse GTX 550 Ti, Festplattengerät - ATA Intel SSD, SCSI, OS- 64-Bit-Betriebssystem Windows 7 Professional</i> .  Wir nennen dieses Kit einfach - <i>Desktop-13</i> . <br><br><h3>  2. Datenaufbereitung </h3><br>  Der Algorithmus beginnt mit dem Lesen einer Datei, die ein eindimensionales Array von Daten zur Verteilung einer beliebigen Zusammensetzung von <i>k</i> Königinnen enthält.  Es wird davon ausgegangen, dass die Daten auf folgende Weise aufbereitet werden.  Es gebe ein Array mit Nullen <i>Q (i) = 0, i = (1, ..., n)</i> , wobei die Indizes der Zellen dieses Arrays den Zeilenindizes der Lösungsmatrix entsprechen.  Befindet sich in einer beliebigen Zeile <i>i</i> der Lösungsmatrix eine Dame in Position <i>j</i> , so wird die Zuordnung <i>Q (i) = j</i> durchgeführt.  Somit ist die Zusammensetzungsgröße <i>k</i> gleich der Anzahl von Nicht-Null-Zellen des Arrays <i>Q.</i>  (Zum Beispiel bedeutet <i>Q = (0, 0, 5, 0, 4, 0, 0, 3, 0, 0)</i> , dass wir eine Zusammensetzung von <i>k = 3</i> Königinnen auf der Matrix <i>n = 10 betrachten</i> , wobei sich die Königinnen in der 3. befinden. 5. und 8. Zeile in den Positionen: 5, 4, 3). <br><br><h3>  3. Algorithmus zur Überprüfung der Richtigkeit des n-Queens-Lösungsproblems </h3><br>  Für die Forschung brauchen wir einen Algorithmus, mit dem wir in kurzer Zeit die Richtigkeit der Lösung des <i>n-Queens-Problems</i> bestimmen können.  Die Position der Königinnen in jeder Reihe und jeder Spalte ist einfach zu steuern.  Die Frage betrifft diagonale Grenzen.  Wir könnten einen effektiven Algorithmus für eine solche Abrechnung entwickeln, wenn wir jede Zelle der Lösungsmatrix einer bestimmten Zelle eines bestimmten Kontrollvektors zuordnen könnten, der den Einfluss diagonaler Beschränkungen auf die betreffende Zelle eindeutig charakterisieren würde.  Dann kann basierend darauf, ob die Zelle des Steuervektors frei oder besetzt ist, beurteilt werden, ob die entsprechende Zelle der Entscheidungsmatrix frei oder geschlossen ist.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine solche Idee wurde zuerst von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sosic &amp; Gu (1990) verwendet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die Anzahl der Konfliktsituationen zwischen verschiedenen Positionen von Königinnen zu berücksichtigen und zu akkumulieren. Wir verwenden eine ähnliche Idee in dem unten dargestellten Algorithmus, jedoch nur, um zu berücksichtigen, ob die Zelle der Lösungsmatrix frei oder belegt ist. Abbildung 1 zeigt als Beispiel ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 x 8-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schachbrett, </font><font style="vertical-align: inherit;">über dem sich eine Folge von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen </font><font style="vertical-align: inherit;">befindet </font><font style="vertical-align: inherit;">.</font></font><br><br><img src="https://habrastorage.org/webt/sx/0f/ws/sx0fwsydzdsy954rtlqpdwwigqg.png"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Ein Demo-Beispiel für die Entsprechung der diagonalen Projektionen der Matrixzellen zu den entsprechenden Zellen der Kontrollfelder </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 8) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrachten Sie die ersten 15 Zellen als Elemente des Kontrollvektors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die Projektionen aller linken Diagonalen von irgendeiner Zelle der Lösungsmatrix fallen in eine der Zellen des Kontrollvektors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tatsächlich befinden sich alle derartigen Vorsprünge innerhalb von zwei parallelen Liniensegmenten, von denen eines die Matrixzelle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(8.1)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit der ersten Zelle des Vektors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und das zweite </font><font style="vertical-align: inherit;">die Matrixzelle </font><font style="vertical-align: inherit;">(1.8) mit der 15. Zelle des Steuervektors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 verbindet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir geben eine ähnliche Definition für die rechten diagonalen Projektionen. Verschieben Sie dazu die Referenz von Zelle 1 nach Zelle 9 nach rechts und betrachten Sie die Folge von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen als Elemente des Kontrollvektors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (in der Abbildung sind dies Zellen vom 9. bis zum 24.) Projektionen aller rechten Diagonalen von einer beliebigen Zelle der Matrix Die Lösungen fallen in eine der Zellen dieses Kontrollvektors, beginnend von der 2. bis zur 16. Zelle (in der Abbildung vom 10. bis zum 24.). Hierbei liegen alle derartigen Vorsprünge zwischen zwei parallelen Liniensegmenten - dem Segment, das die Zelle (8, 8) der Lösungsmatrix mit der Zelle 16 des Vektors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Zelle 24 in der Figur) verbindet, und dem Segment, das die Zelle (1,1) der Lösungsmatrix mit der Zelle verbindet 2 Steuervektoren </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Zelle 10 in der Figur). Die Projektionen aller Zellen der Lösungsmatrix, die auf derselben linken Diagonale liegen, fallen jeweils in dieselbe Zelle des linken Kontrollvektors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die Projektionen aller Zellen der Lösungsmatrix, die auf derselben rechten Diagonale liegen, fallen in </font><font style="vertical-align: inherit;">dieselbe Zelle </font><font style="vertical-align: inherit;">Zelle des rechten Kontrollvektors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Somit ermöglichen diese beiden Steuervektoren </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die vollständige Kontrolle aller diagonalen Hemmungen für jede Zelle der Entscheidungsmatrix. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist wichtig anzumerken, dass die Idee, diagonale Projektionen auf Zellen von Steuervektoren zu verwenden, um zu bestimmen, ob eine Zelle einer Lösungsmatrix mit Koordinaten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> frei oder besetzt ist, </font><font style="vertical-align: inherit;">auch später in implementiert wurde</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richards (1997)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es bietet einen der schnellsten rekursiven Suchalgorithmen für alle Lösungen, basierend auf Operationen mit einer Bitmaske. Ein wichtiger Unterschied besteht darin, dass der angegebene Algorithmus für die sequentielle Suche aller Lösungen ab der ersten Zeile der Lösungsmatrix nach unten oder ab der letzten Zeile der Matrix nach oben ausgelegt ist. Der von uns vorgeschlagene Algorithmus basiert auf der Bedingung, dass die Wahl der Nummer jeder Zeile für den Ort der Königin willkürlich sein muss. Für den betrachteten Algorithmus ist dies von grundlegender Bedeutung. Beachten Sie, dass die obige Abbildung 1 in Analogie zu dem aufgebaut ist, was in diesem Artikel veröffentlicht wird. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Programm, um zu überprüfen, ob eine gegebene Lösung des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens-Problems</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> korrekt ist oder ob eine gegebene Zusammensetzung aus </font><i><font style="vertical-align: inherit;">k</font></i><font style="vertical-align: inherit;"> wahr ist</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queens ist wie folgt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Um diagonale Hemmungen zu steuern, erstellen Sie zwei Arrays </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (1: n2)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (1: n2)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wobei n2 = 2 * n ist, und ein Array </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B (1: n)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die Belegung der Spalten der Lösungsmatrix zu steuern. Setzen Sie diese drei Arrays außer Kraft. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Wir führen den Zähler der Anzahl der korrekt installierten Königinnen ein ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">totPos = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Ausgehend von der ersten Zeile werden in einem Zyklus konsequent alle Positionen der Königinnen berücksichtigt. Wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q (i)&gt; 0 ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dann </font><font style="vertical-align: inherit;">bilden </font><i><font style="vertical-align: inherit;">wir</font></i><font style="vertical-align: inherit;"> basierend auf dem Index der Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und dem Index der Position der Königin in dieser Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j = Q (i)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die entsprechenden Indizes für die Steuerfelder </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (t)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r = n + j - i </font></font></i> <br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t = j + i</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3. Wenn alle Bedingungen ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r) = 0, D2 (t) = 0, B (j) = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">erfüllt sind </font><font style="vertical-align: inherit;">, bedeutet dies, dass die Zelle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( i, j) ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> frei und fällt nicht in die Projektionszone von diagonalen Beschränkungen, die von zuvor festgelegten Königinnen gebildet werden. Die Position der Königin in dieser Position ist korrekt. Wenn mindestens eine dieser Bedingungen nicht erfüllt ist, ist die Wahl einer solchen Position jeweils falsch, und die Entscheidung ist falsch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Wenn die Lösung korrekt ist, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erhöhen Sie</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den Zähler der Anzahl der korrekt installierten Königinnen ( </font><i><font style="vertical-align: inherit;">totPos = totPos + 1</font></i><font style="vertical-align: inherit;"> ) und schließen Sie die entsprechenden Zellen der Kontrollfelder: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(D1 (r) = 1, D2 (t) = 1, B (j) = 1)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Also schließen wir alle Zellen in der Spalte</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die Zellen der Lösungsmatrix, die sich entlang der linken und rechten Diagonalen befinden, die sich in der Zelle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schneiden </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Wiederholen Sie den Überprüfungsvorgang für alle verbleibenden Positionen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielleicht ist dies einer der schnellsten Algorithmen zur Bewertung der Richtigkeit der Lösung des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens-Problems</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die Überprüfungszeit von einer Million Positionen für die Matrix der Lösungen 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> x 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desktop-13</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beträgt 0,175 Sekunden, was ungefähr der Zeit entspricht, in der die Eingabetaste gedrückt wurde. </font><font style="vertical-align: inherit;">Offensichtlich ist dieser Algorithmus in Bezug auf die Zählzeit in Bezug auf </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> linear </font><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4. Beschreibung des Algorithmus zur Lösung des Problems </font></font></h3><br>  <b>Der General</b> .  <i>Das n-Queens-Vervollständigungsproblem</i> ist ein klassisches nicht deterministisches Problem.  Die Hauptschwierigkeit seiner Lösung hängt mit dem Problem der Auswahl des Zeilenindex und des Positionsindex in dieser Zeile zusammen, wenn der Zustandsraum sehr groß ist.  Bei der Suche nach allen möglichen Lösungen tritt ein solches Problem nicht auf.  Wir müssen alle gültigen Suchzweige im Zustandsraum berücksichtigen, und die Reihenfolge, in der sie berücksichtigt werden, spielt keine Rolle.  Wenn jedoch eine beliebige Zusammensetzung von <i>k</i> Königinnen bis zu einer vollständigen Lösung vervollständigt werden muss, benötigen wir in diesem Fall einen Algorithmus zum Auswählen von Zeilen- und Spaltenindizes, der die vorhandene Zusammensetzung angemessen wahrnimmt und zu einer Lösung führt, die schneller als andere ist.  In diesem Projekt haben wir die Frage der Wahl auf der Grundlage der folgenden allgemeinen Position entschieden: <i>Wenn wir keine Bedingungen formulieren können, die einer Zeile oder einer Position in dieser Zeile den Vorrang vor anderen geben, verwenden wir einen Zufallsauswahlalgorithmus auf der Grundlage von gleichmäßig verteilte Zufallszahlen</i> .  Eine ähnliche Zufallsauswahlmethode zur Lösung von Problemen, bei denen der Zustandsraum sehr groß ist, ist ganz natürlich.  Eine der Ausgaben der Reihe Proceedings of a <i>DIMACS Workshop (1999)</i> widmete sich ganz der Verwendung der Zufallsauswahl bei der Entwicklung von Algorithmen zur Lösung komplexer Probleme.  Die korrekte Implementierung des Zufallsauswahlalgorithmus kann eine ziemlich produktive Lösung sein, obwohl dies eine notwendige, aber nicht ausreichende Bedingung für die Vervollständigung der Lösung ist.  <i>Sosic und Gu (1990) verwenden</i> als eine der ersten Studien einen Zufallsauswahlalgorithmus zur Lösung des <i>n-Queens-Problems</i> .  Der untersuchte Algorithmus basiert auf einer relativ einfachen und prägnanten Idee.  Es gebe eine Folge von Zahlen von <i>1</i> bis <i>n</i> , die zufällig neu angeordnet werden.  Eine solche Menge von Zahlen hat eine wichtige Eigenschaft.  Es besteht darin, dass unabhängig davon, wie diese Zahlen auf verschiedene Zeilen der Lösungsmatrix verteilt sind, wie die Positionen der Königin (eine Zahl pro Zeile), die ersten beiden Regeln in der Aussage des Problems immer erfüllt sind: Jede Zeile und jede Spalte haben keine mehr als eine Königin.  Es wird jedoch nur ein Teil der so erhaltenen Positionen frei von diagonalen Beschränkungen sein.  Der andere Teil befindet sich in einem Konflikt mit zuvor eingerichteten Königinnen.  Um aus dieser Situation herauszukommen, verwendeten die Autoren die Methode, gegensätzliche Positionen zu vergleichen und auszutauschen, um eine vollständige Lösung zu erhalten.  In unserem vorgeschlagenen Algorithmus sind Konfliktsituationen unmöglich, da bei jedem Schritt zur Lösung des Problems die Königin nur dann in die Zelle der betreffenden Leitung installiert wird, wenn die Zelle frei ist. <br><br>  <b>4.1 Auswählen eines Modells für die Rückverfolgung (BT)</b> <br><br>  Beim Finden einer Lösung für ein Problem kann eine Situation auftreten, in der eine sequentielle Lösungskette zu einer Sackgasse führt.  Dies ist eine „genetische“ Eigenschaft nicht deterministischer Probleme.  In diesem Fall müssen Sie zu einem der vorherigen Schritte zurückkehren, den Status der Aufgabe gemäß dieser Ebene wiederherstellen und die Suche nach einer Lösung von dieser Position aus erneut starten.  Die Frage ist, welches der vorherigen Level zurückgegeben werden soll und wie viele solcher Level es sein sollen (mit Level meinen wir einen bestimmten Schritt bei der Lösung des Problems mit einer bestimmten Anzahl korrekt installierter Königinnen).  Offensichtlich ist die Auswahl einer Lösungsebene zum Zurückgehen genauso relevant wie die Auswahl eines Zeilenindex oder eines Positionsindex in dieser Zeile.  Unabhängig von der Vorgehensweise zur Lösung dieses Problems ist es daher erforderlich, zunächst die Anzahl der Grundstufen für die Rückkehr sowie den Mechanismus und die Bedingungen für die Rückkehr zu einer dieser Stufen zu bestimmen.  In unserem vorgeschlagenen Algorithmus unterteilen wir die Lösungsmatrix in drei Grundebenen.  Dies sind die Rückgabestellen.  Wenn aufgrund der Lösung ein Deadlock auftritt, kehren wir abhängig von den Parametern der Aufgabe zu einer dieser drei grundlegenden Ebenen zurück.  Die erste Basisebene ( <i>baseLevel1</i> ) entspricht dem Zustand, in dem die Datenüberprüfung der betreffenden Zusammensetzung abgeschlossen ist.  Dies ist der Beginn des Programms.  Die Werte der folgenden zwei Basisebenen ( <i>baseLevel2</i> und <i>baseLevel3</i> ) hängen von der Größe der Matrix <i>n ab</i> .  Die empirische Abhängigkeit dieser Grundwerte von der Größe der Lösungsmatrix wurde anhand einer Vielzahl von Rechnerexperimenten ermittelt.  Zur genaueren Darstellung dieser Abhängigkeit haben wir das gesamte betrachtete Intervall von 7 bis 10 <sup>8</sup> in zwei Teile geteilt.  Sei <i>u = log (n)</i> , dann wenn <i>n &lt;30 000</i> , dann <br><br>  <i>baseLevel2 = n - rund (12.749568 * u3 - 46.535838 * u2 + 120.011829 * u - 89.600272)</i> <br>  <i>baseLevel3 = n - rund (9.717958 * u3 - 46.144187 * u2 + 101.296409 * u - 50.669273)</i> <br><br>  ansonsten <br><br>  <i>baseLevel2 = n - rund (-0,886344 * u3 + 56,136743 * u2 + 146,486415 * u + 227,967782)</i> <br>  <i>baseLevel3 = n - round (14.959815 * u3 - 253.661725 * u2 + 1584.713376 * u - 3060.691342)</i> <br><br>  <b>4.2 Blockstruktur</b> <br><br>  Der Algorithmus ist in Form einer Folge von <i>fünf Ereignisblöcken aufgebaut</i> , wobei jedes Ereignis der Ausführung eines bestimmten Teils der Lösung des Problems zugeordnet ist.  Die Verarbeitungsalgorithmen in jedem Block unterscheiden sich voneinander.  Nur drei der fünf Blöcke dienen zur Bildung einer sequentiellen Lösungskette, und die verbleibenden zwei Blöcke sind vorbereitend.  Die Wahl der Blocknummer, ab der die Berechnungen beginnen, hängt vom Wert von <i>n</i> und von den Ergebnissen des Vergleichs der Zusammensetzungsgröße <i>k</i> mit den Werten von <i>baseLeve2</i> und <i>baseLevel3 ab</i> .  Eine Ausnahme bildet das Intervall der Werte <i>n = (7, ..., 99)</i> , das aufgrund der Besonderheiten des Algorithmusverhaltens in diesem Abschnitt als "turbulente Zone" bezeichnet werden kann.  Für die Werte <i>n = (7, ..., 49)</i> beginnen die Berechnungen unabhängig von der Größe der Zusammensetzung nach der Eingabe und Überwachung der Daten ab dem 4. Block.  Für Werte <i>n = (50, ..., 99)</i> beginnen die Berechnungen je nach Größe der Komposition entweder ab dem zweiten Block oder ab dem vierten.  Wie oben erwähnt, werden bei jedem Schritt zur Lösung des Problems nur die Positionen in der Linie berücksichtigt, die nicht in die von den zuvor eingerichteten Königinnen geschaffene Beschränkungszone fallen.  Es sind diese Positionen, <i>die als frei bezeichnet werden</i> . <br>  Beschreiben wir kurz, welche Berechnungen in jedem dieser fünf Programmblöcke durchgeführt werden. <br><br>  <b>4.3 Beginn des Algorithmus</b> <br><br>  Die Daten werden eingegeben und die Zusammensetzung auf Richtigkeit überprüft.  Bei jedem Überprüfungsschritt werden die Zellen der Steuerfelder geändert.  Die Anzahl der korrekt installierten Königinnen wird gezählt.  Wenn die Komposition keine Fehler enthält, wird die Lösung fortgesetzt, andernfalls wird eine Fehlermeldung angezeigt.  Nach Abschluss der Überprüfung werden Kopien der Haupt-Arrays für deren Wiederverwendung auf dieser Ebene erstellt.  Danach wird die Steuerung auf <i>Block 1 übertragen</i> . <br><br>  <b>4.4 Block 1</b> <br><br>  Der Beginn der Bildung des Suchzweigs.  Wir betrachten <i>k</i> Damen auf einem Schachbrett als Startposition.  Es ist erforderlich, diese Komposition fortzusetzen und die Damen auf ein Schachbrett zu <i>legen,</i> bis ihre Gesamtzahl gleich <i>baseLevel2 ist</i> .  Der hier verwendete Algorithmus heißt <i>randSet &amp; randSet</i> .  Dies liegt an der Tatsache, dass wir hier ständig zwei zufällige Listen von Indizes vergleichen, um Paare zu suchen, die frei von den entsprechenden diagonalen Beschränkungen sind.  Dazu werden folgende Aktionen ausgeführt: <br><br>  a) Es werden zwei Listen gebildet: eine Liste freier Zeilenindizes und eine Liste freier Spaltenindizes; <br><br>  b) zufällige Neuordnung von Zahlen in jeder dieser Listen; <br><br>  c) In einer Schleife wird jedes aufeinanderfolgende Wertepaar <i>(i, j)</i> , bei dem Index <i>(i)</i> aus der Liste der freien Zeilenindizes und Index <i>(j)</i> aus der Liste der freien Spaltenindizes ausgewählt wird, als mögliche Königinposition betrachtet und geprüft, ob dies der Fall ist Position im Projektionsbereich von diagonalen Ausnahmen. <br><br>  Wenn die Regel der diagonalen Ausnahmen nicht verletzt wird, gilt die Position als korrekt und die Dame wird an diese Position gesetzt.  Danach wird der Zähler um die Anzahl der korrekt installierten Königinnen erhöht und die entsprechenden Zellen der Steuerfelder werden geändert.  Fällt die Position <i>(i, j)</i> in die Zone der diagonalen Beschränkungen, die durch die zuvor festgelegten Königinnen gebildet werden, so ändert sich nichts und der Übergang zur Berücksichtigung des nächsten Wertepaares findet statt. <br><br>  Wenn der Vergleichszyklus aller Paare der Liste abgeschlossen ist, wird basierend auf den verbleibenden Indizes, die sich in der diagonalen Ausschlusszone befinden, erneut eine Liste der Indizes der verbleibenden freien Zeilen und freien Spalten gebildet, und dieser Vorgang wird wiederholt, bis die Gesamtzahl der korrekt platzierten Königinnen <i>(totPos )</i> wird nicht gleich dem Grenzwert von <i>baseLevel2 sein</i> oder diesen überschreiten.  Sobald diese Bedingung erfüllt ist, wird die Steuerung auf <i>Block 2 übertragen</i> .  Wenn sich als Ergebnis der Suche nach einer Lösung herausstellt, dass aus der gesamten Liste der Indizes der verbleibenden freien Zeilen und freien Spalten keines der Paare für die Position der Königin geeignet ist, werden in diesem Fall die ursprünglichen Werte der Steuerfelder basierend auf zuvor erzeugten Kopien wiederhergestellt , und die Steuerung wird zum erneuten Zählen an den Anfang von <i>Block 1 übertragen</i> . <br><br>  <b>4.5 Block 2</b> <br><br>  Dieser Block dient als Vorbereitungsstufe für den Übergang zu <i>Block-3</i> .  Auf dieser Ebene ist die Anzahl der verbleibenden freien Leitungen ( <i>freeRows</i> ) deutlich geringer als <i>n</i> .  Auf diese Weise können Sie Ereignisse von der ursprünglichen Matrix der Größe <i>nxn</i> auf eine Matrix der kleineren Größe <i>L übertragen (1: freeRows, 1: freeRows)</i> .  Darüber hinaus werden basierend auf Informationen über die verbleibenden freien Zeilen und freien Spalten in der ursprünglichen Lösungsmatrix Nullen in die entsprechenden Zellen des Arrays <i>L geschrieben</i> , was anzeigt, dass diese Zellen frei sind.  Bei diesem <i>"Projektions"</i> -Übergang bleibt die Entsprechung der Zeilen- und Spaltenindizes der neuen Matrix mit den entsprechenden Indizes der ursprünglichen Matrix erhalten.  Es ist wichtig anzumerken, dass, obwohl sich bei der Lösung dieses Problems alle Ereignisse auf der ursprünglichen Matrix der Größe <i>nxn</i> entfalten und eine solche Matrix der Hauptaktionsbereich ist, <i>diese Matrix</i> in <i>Wirklichkeit nicht erstellt</i> wird und nur Kontrollfelder zur Berücksichtigung der Zeilenindizes <i>A (1: n)</i> und Spalten <i>B (1: n)</i> dieser Matrix. <br><br>  In diesem Block werden neben dem L-Array auch zwei Arbeits-Arrays <i>rAr (1: freeRows)</i> und <i>tAr (1: freeRows)</i> gebildet, um die entsprechenden Indizes der Steuer-Arrays <i>D1</i> und <i>D2</i> <i>abzuspeichern</i> .  Dies liegt an der Tatsache, dass wir, wenn wir die nächste Dame in der Zelle <i>(i, j) der</i> anfänglichen Matrix der Größe <i>nxn installieren</i> , danach die Zellen des Arrays <i>L</i> ausschließen müssen, die in die Projektionszone der diagonalen Ausnahmen des ursprünglichen "großen" Arrays fallen.  Da die Steuerung von diagonalen Beschränkungen nur innerhalb der ursprünglichen Matrix der Größe <i>nxn ausgeführt wird</i> , können <i>wir</i> durch das Vorhandensein von Arbeitsarrays <i>rAr</i> und <i>tAr</i> die Korrespondenz aufrechterhalten und verbotene Zellen in die Grenzen von Array L übersetzen. Dies vereinfacht die Abrechnung ausgeschlossener Positionen erheblich. <br>  Nach Abschluss der Vorarbeiten in diesem Block werden Kopien der Haupt-Arrays zur Wiederverwendung auf dieser Ebene erstellt, und die Steuerung wird an <i>Block 3 übertragen</i> . <br><br>  <b>4.6 Block 3</b> <br><br>  In diesem Block wird die Bildung des Lösungssuchzweigs auf der Grundlage der im vorherigen Block vorbereiteten Daten fortgesetzt.  Die Anzahl der Zeilen, in denen die <i>Damen</i> richtig eingestellt sind, ist gleich oder größer als <i>baseLevel-2</i> .  Sie müssen mit der Auswahl fortfahren, bis die Anzahl der installierten Königinnen gleich <i>baseLevel-3 ist</i> .  Hier verwenden wir den <i>Rand &amp; Rand-</i> Lösungssuchalgorithmus, d.h.  Um die Position einer Dame zu bilden, werden anstelle einer Liste freier Indizes nur zwei Indizes verwendet, ein zufälliger Indexwert einer freien Zeile und ein zufälliger Indexwert einer freien Position in dieser Zeile.  Dieser Vorgang wird zyklisch wiederholt, bis die Gesamtzahl der platzierten Königinnen dem Wert von <i>baseLevel-3 entspricht</i> .  Sobald diese Bedingung erfüllt ist, wird die Steuerung auf <i>Block 4 übertragen</i> .  Wenn sich als Ergebnis von Berechnungen herausstellt, dass der Suchzweig eine Sackgasse ist, wird dieser Abschnitt der Suchzweigbildung geschlossen und kehrt zum Anfang von <i>Block 3 zurück</i> , von wo aus die Berechnungen erneut wiederholt werden.  Hierzu werden die Anfangswerte aller Control Arrays wiederhergestellt. <br><br>  <b>4.7 Block 4</b> <br><br>  In diesem Block werden Daten für die Übertragung der Steuerung an <i>Block 5</i> vorbereitet.  In diesem Schritt ist die Anzahl der freien Leitungen ( <i>nRow</i> ) nach Abschluss der Prozedur in <i>Block-3</i> noch geringer geworden.  Daher ist es auch vorteilhaft, Ereignisse von einem größeren Array in ein kleineres Array zu übersetzen.  Dieser Ansatz gibt uns die Möglichkeit, die erforderlichen Eigenschaften für die verbleibenden Leitungen, die wir in dieser Phase benötigen, schnell zu bestimmen.  Von besonderer Bedeutung ist die Tatsache, dass es auf der Basis eines solchen Arrays möglich ist, die Aussichten des Suchzweigs für viele weitere Schritte vorherzusagen, ohne die Berechnungen abschließen zu müssen.  Der Zustand ist recht einfach.  Wenn sich herausstellt, dass es unter den verbleibenden freien Zeilen eine Zeile gibt, in der keine freie Position vorhanden ist, wird der betreffende Suchzweig geschlossen und die Steuerung auf einen der Blöcke der unteren Ebene übertragen.  Die hier durchgeführten vorbereitenden Maßnahmen ähneln weitgehend denen in <i>Block 2</i> .  Basierend auf den ursprünglichen Indizes freier Zeilen und freier Spalten wird ein neues zweidimensionales Array gebildet, dessen Nullwerte freien Positionen in der ursprünglichen Lösungsmatrix entsprechen.  Außerdem wird in diesem Block ein spezielles Array <i>E (1: nRow, 1: nRow)</i> erstellt, anhand dessen Sie die Anzahl der freien Positionen in den verbleibenden freien Zeilen bestimmen können, die geschlossen werden, wenn Sie die Position <i>(i, j)</i> auswählen <i>,</i> in die die Dame gesetzt werden soll Quellmatrix.  Vor dem Übertragen der Steuerung auf <i>Block 5</i> werden die folgenden Aktionen ausgeführt: <br><br>  a) die Anzahl der offenen Stellen in allen verbleibenden Zeilen wird bestimmt, <br><br>  b) ein Array der Summe der freien Positionen für die betrachteten Linien in aufsteigender Reihenfolge sortiert wird, <br><br>  c) wenn alle verbleibenden freien Linien freie Positionen haben (d. h. der Minimalwert in dieser Rangliste ist von 0 verschieden), wird die Steuerung zu Block 5 übertragen. <br><br>  Wenn sich herausstellt, dass in einer der verbleibenden Zeilen keine freie Position vorhanden ist, werden die erforderlichen Arrays basierend auf den gespeicherten Kopien wiederhergestellt, und die Steuerung wird abhängig von den Parametern der Aufgabe auf eine der Basisebenen übertragen. <br><br>  d) Sicherungskopien aller Steuerfelder für diese 4. Ebene werden erstellt. <br><br>  <b>4.8 Block 5</b> <br><br>  Diese Phase ist abgeschlossen, und hier wird die Bildung des Suchzweigs „ausgewogener“ und „rationaler“ durchgeführt.  Dies ist die "letzte Meile", es bleiben nur noch wenige freie Leitungen.  Gleichzeitig ist dies der schwierigste Teil.  Alle Fehler, die möglicherweise in den vorherigen Phasen der Bildung des Zweigs der Suche nach einer Lösung begangen wurden, werden hier zusammengefasst angezeigt - in Form des Fehlens einer freien Position in der Zeile. <br><br>  Der Algorithmus dieses Blocks wird auf der Basis von zwei verschachtelten Schleifen ausgeführt, in denen die dritte Schleife ausgeführt wird.  Ein Merkmal des dritten Zyklus ist, dass er wiederholt werden kann, ohne die Parameter von zwei externen Zyklen zu ändern.  Dies passiert, wenn der generierte Suchzweig blockiert ist.  Die Anzahl solcher Wiederholungen überschreitet nicht den Grenzwert von <i>repeatBound</i> , dessen optimaler Wert auf der Basis von Computerexperimenten ermittelt wurde. <br><br>  Der äußere Schleifenindex ist mit einer sequentiellen Auswahl von Zeilenindizes verbunden, die nach Berechnungen auf der dritten Basisebene frei blieben.  Dies geschieht auf der Grundlage einer zuvor nach der Anzahl der freien Positionen in der Zeile geordneten Liste von Zeilen.  Die Auswahl beginnt mit einer Zeile mit einer Mindestanzahl von freien Positionen und wird dann in nachfolgenden Schritten in aufsteigender Reihenfolge durchgeführt.  Innerhalb dieses Zyklus wird ein zweiter Zyklus gebildet, dessen Index die Indizes aller freien Positionen in der betreffenden Zeile durchläuft.  Der Zweck des ersten Zyklus besteht nur darin, den Index einer der freien Zeilen auf dieser Ebene auszuwählen.  Dementsprechend besteht der Zweck des zweiten Zyklus darin, nur eine freie Position innerhalb der betrachteten Linie auszuwählen.  Diese Aktionen finden nur auf der dritten Grundstufe statt.  Nach dieser Auswahl wird die Anzahl der installierten Königinnen erhöht und die entsprechenden Zellen aller Steuerfelder werden geändert.  Ferner wird die Steuerung innerhalb eines verschachtelten (dritten) Zyklus übertragen, dessen Aktivitätszone bereits alle verbleibenden freien Leitungen enthält.  Innerhalb dieses Zyklus werden die Auswahl des Zeilenindex und die Auswahl einer freien Position in dieser Zeile basierend auf den folgenden Regeln durchgeführt: <br><br>  a) <b>Wählen Sie eine freie Leitung</b> .  Alle verbleibenden freien Zeilen werden berücksichtigt, und die Anzahl der freien Positionen wird in jeder Zeile bestimmt.  Die Zeile wird ausgewählt, für die die Anzahl der freien Positionen minimal ist.  Dies minimiert die Risiken, die mit der Möglichkeit verbunden sind, die letzten vakanten Positionen in einigen der verbleibenden Linien, für die der Staat minimal und kritisch in Bezug auf die Anzahl der vakanten Positionen ist <b>, auszuschließen</b> ( <b>Mindestrisikoregel</b> ).  Im Übrigen beginnt der Index des ersten Zyklus in diesem fünften Block mit einer sequentiellen Auswahl von Zeilen mit einem Mindestwert für die Anzahl der freien Positionen in einer Zeile.  Wenn sich in einem Schritt herausstellt, dass die beiden Zeilen die gleiche Mindestanzahl an freien Positionen haben, wird der Index einer der beiden Positionen, die in der Rangliste an erster Stelle stehen, zufällig ausgewählt.  Wenn die Anzahl der Zeilen mit der gleichen Mindestanzahl an freien Positionen mehr als zwei beträgt, wird der Index einer der drei Positionen, die an erster Stelle in der Rangliste aufgeführt sind, zufällig ausgewählt. <br><br>  b) <b>Auswahl einer freien Position in einer Reihe</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus der Liste aller vakanten Positionen in der betreffenden Zeile wird eine ausgewählt, die den vakanten Positionen in allen verbleibenden Zeilen nur minimalen Schaden zufügt. Dies geschieht auf der Grundlage des zuvor gebildeten Arrays E. Mit "minimaler Beschädigung" ist die Auswahl einer solchen Position in einer bestimmten Zeile gemeint, die die geringste Menge an freien Positionen in allen verbleibenden Zeilen ausschließt ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel für minimale Beschädigung)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Wenn sich herausstellt, dass zwei oder mehr freie Positionen in einer Reihe gemäß dem Schadenskriterium die gleichen Mindestwerte aufweisen, wird der Index einer der beiden Positionen, die zuerst in der Liste aufgeführt sind, zufällig ausgewählt. Wenn Sie eine Position auswählen, die die Mindestanzahl an freien Positionen in den verbleibenden Zeilen ausschließt, wird der mit der Position der Königin in dieser Position verbundene „Schaden“ minimiert. Die Verwendung dieser beiden Regeln ermöglicht eine rationellere Ressourcennutzung bei jedem Schritt der Bildung eines Suchzweigs. Dies verringert das Risiko erheblich und erhöht die Wahrscheinlichkeit, eine beliebige Zusammensetzung zu einer vollständigen Lösung zu wählen, wenn die fragliche Zusammensetzung eine Lösung aufweist. Wenn sich bei einem Lösungsschritt herausstellt, dass in einer der verbleibenden zu berücksichtigenden Zeilen keine offenen Stellen vorhanden sind, wird dieser Suchzweig geschlossen. In diesem Fall,Auf der Grundlage von Sicherungen werden alle Steuerfelder wiederhergestellt, und wenn der Zähler für die Anzahl der Wiederholungen den Grenzwert nicht überschreitet</font></font><i>repeatBound</i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann wird, ohne die Indizes des ersten und des zweiten externen Zyklus zu ändern, die Arbeit des dritten verschachtelten Zyklus erneut wiederholt. Dies ist darauf zurückzuführen, dass wir in Fällen, in denen die Mindestwerte der relevanten Kriterien übereinstimmten, eine zufällige Auswahl getroffen haben. Durch die Neugestaltung des Suchzweigs unter den gleichen Bedingungen wie auf der Basisebene können die auf dieser Ebene vorhandenen „Startressourcen“ effizienter genutzt werden. Die Anzahl der wiederholten Starts des dritten verschachtelten Zyklus ist begrenzt, und wenn der Grenzwert überschritten wird, wird der Betrieb dieses Zyklus unterbrochen. Danach werden die Werte der Steuerfelder wiederhergestellt, und die Steuerung wird in den Zyklus der dritten Basisebene übertragen, um zum nächsten Indexwert zu gelangen. Diese Prozedur wird zyklisch wiederholt, bis eine vollständige Lösung erhalten wird, oder es stellt sich heraus, dassdass wir alle freien Zeilen und alle freien Positionen in diesen Zeilen auf dieser Basisebene verwendet haben. In diesem Fall kehrt man in Abhängigkeit von der Gesamtzahl der wiederholten Berechnungen auf verschiedenen Basisebenen und unter Berücksichtigung der Größe der Entscheidungsmatrix und der Größe der Zusammensetzung zu einer der niedrigeren Ebenen für wiederholte Berechnungen zurück, oder es wird beurteilt, dass die fragliche Zusammensetzung nicht sein kann ausgerüstet, um Lösung zu vervollständigen. In dem Programm wird, um die Gesamtzeit der Rechnung zu begrenzen, das Verfahren akzeptiertoder es wird entschieden, dass die fragliche Komposition erst nach einer vollständigen Entscheidung vervollständigt werden kann. In dem Programm wird, um die Gesamtzeit der Rechnung zu begrenzen, das Verfahren akzeptiertoder es wird entschieden, dass die fragliche Komposition erst nach einer vollständigen Entscheidung vervollständigt werden kann. In dem Programm wird, um die Gesamtzeit der Rechnung zu begrenzen, das Verfahren akzeptiert</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Rückverfolgung kann</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , unabhängig davon, auf welche der vorherigen Ebenen die Rückgabe erfolgt, nur bis zu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">totSimBound-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeiten durchgeführt werden. </font><font style="vertical-align: inherit;">Dieser Grenzwert wird auf der Grundlage von Berechnungsexperimenten für verschiedene Werte von n ausgewählt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Analyse der Wirksamkeit von Auswahlalgorithmen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Effizienz des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Algorithmus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Um die Fähigkeiten dieses Algorithmus zu analysieren, wurde ein Computerexperiment durchgeführt, das darin bestand </font><font style="vertical-align: inherit;">, Königinnen in der Lösungsmatrix </font><font style="vertical-align: inherit;">basierend auf dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modell </font><font style="vertical-align: inherit;">zu platzieren, solange diese Möglichkeit besteht. Sobald der Suchzweig eine Sackgasse erreichte oder eine vollständige Lösung erhalten wurde, wurden die Zusammensetzungsgröße, die Lösungszeit festgelegt und der Test erneut wiederholt. Computerexperimente wurden für die gesamte Basisliste von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werten durchgeführt </font><font style="vertical-align: inherit;">. Die Anzahl der wiederholten Tests für die Werte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (30, 40, ..., 90, 100, 200, 300, 500, 800, 1000)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> betrug </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Million</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , für die übrigen Werte die Anzahl der Tests mit zunehmendem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Analyse der Ergebnisse von Computerexperimenten erlaubt es uns, die folgenden Schlussfolgerungen zu ziehen: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Als Ergebnis nur des ersten Zyklus der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Prozedur sind</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> durchschnittlich etwa 60% aller Königinnen korrekt platziert. Für </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100 beträgt die Anzahl der korrekt platzierten Königinnen 60,05%. Mit zunehmendem Wert von n nimmt dieser Wert allmählich ab und für n = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beträgt er 59,97%. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Das Histogramm der Verteilung der Längenwerte der erhaltenen Zusammensetzungen hat unabhängig von der Größe der Entscheidungsmatrix </font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;"> die gleiche Form</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Darüber hinaus haben sie alle ein charakteristisches Merkmal - die linke Seite der Verteilung (zum Modalwert) unterscheidet sich von der rechten Seite. Abbildung 2 zeigt als Beispiel das entsprechende Histogramm für</font></font><br><br><img src="https://habrastorage.org/webt/fu/h3/xy/fuh3xyqsx5ro7zx8ru7b66fliy8.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Ein Histogramm der Verteilung von Lösungen unterschiedlicher Länge für das randSet &amp; randSet-Modell ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100, Stichprobengröße = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100. Es scheint, dass das Histogramm aus der Häufigkeitsverteilung von zwei verschiedenen Ereignissen gewonnen wird, da die Häufigkeit des Auftretens von Ereignissen im linken und rechten Teil der Verteilung unterschiedlich ist. Um diese Verteilung zu beschreiben, ist es am wahrscheinlichsten, zwei Funktionen der Dichte der Normalverteilung zu verwenden, von denen eine das Intervall bis zum Modalwert und die andere - das Intervall nach dem Modalwert - abdeckt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) Der Durchschnittswert der Anzahl der Königinnen ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), die in der auf diesem Algorithmus basierenden Entscheidungsmatrix festgelegt werden können, steigt mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wie aus Fig. 3 ersichtlich ist, wo ein Graph der Abhängigkeit des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean / n-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verhältnisses </font><font style="vertical-align: inherit;">von der Matrixgröße </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dargestellt ist </font><font style="vertical-align: inherit;">, nimmt dieses Verhältnis mit einer Zunahme der Matrixgröße zu. Zum Beispiel</font></font><br><img src="https://habrastorage.org/webt/wi/5b/kr/wi5bkrcaftlplvllyxfmek0lycg.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Die Abhängigkeit des Verhältnisses </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean / n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vom Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für verschiedene Größen der Lösungsmatrix. Das Modell ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der Durchschnittswert der Länge der Lösung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn für eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100x100-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Matrix der </font><font style="vertical-align: inherit;">Positionsauswahlalgorithmus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "ohne anzuhalten" erlaubt, Königinnen auf durchschnittlich 89 Zeilen zu platzieren, </font><font style="vertical-align: inherit;">erhöht sich </font><font style="vertical-align: inherit;">für eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000x1000-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Matrix </font><font style="vertical-align: inherit;">die Anzahl solcher Zeilen im Durchschnitt auf 967. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d) Basierend auf dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Algorithmus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> können Sie den vollständigen </font><i><font style="vertical-align: inherit;">Wert</font></i><font style="vertical-align: inherit;"> erhalten Als Lösung ist die „Produktivität“ dieses Ansatzes jedoch äußerst gering. Wie aus Figur 4 ersichtlich ist, z</font></font><br><br><img src="https://habrastorage.org/webt/7w/gt/jg/7wgtjgp2ria3lxqff4ouw9zqzpw.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Die Abnahme der Wahrscheinlichkeit, im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Modell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine vollständige Lösung zu </font><i><font style="vertical-align: inherit;">erhalten,</font></i><font style="vertical-align: inherit;"> mit einer Zunahme von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei Werten von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 7 beträgt die Wahrscheinlichkeit, eine vollständige Lösung zu erhalten, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,057</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ferner nimmt mit einer Zunahme von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wahrscheinlichkeit, eine vollständige Lösung zu erhalten, schnell ab und nähert sich asymptotisch Null. Beginnend mit den Werten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 48, ist </font><font style="vertical-align: inherit;">die Wahrscheinlichkeit eine Komplettlösung in der Größenordnung von 10 zu </font><font style="vertical-align: inherit;">erhalten </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nach dem Schwellenwert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 70 wurde für die nachfolgenden Werte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keine einzige vollständige Lösung erhalten (mit einer Anzahl von Tests von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einer Million</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e) Modell</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bilden sehr </font><i><font style="vertical-align: inherit;">schnell Suchzweige</font></i><font style="vertical-align: inherit;"> . Für </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1000 beträgt die durchschnittliche Zeit zum Erhalten der Zusammensetzung 0,0015 Sekunden. Die durchschnittliche Länge von Kompositionen beträgt 967. Dementsprechend beträgt </font><sup><font style="vertical-align: inherit;">die</font></sup><font style="vertical-align: inherit;"> durchschnittliche Zeit </font><font style="vertical-align: inherit;">für </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2,6754 Sekunden bei einer durchschnittlichen Länge von Kompositionen von 999793. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f) Mit Ausnahme eines kleinen Intervalls </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;= 70, zu dem das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Modell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in sehr seltenen Fällen führen kann vollständige lösung, in allen anderen fällen endet der entscheidungszweig mit der bildung einer negativen zusammensetzung, die erst mit einer vollständigen lösung abgeschlossen werden kann. Also der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet Algorithmus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es hat einen wichtigen Vorteil - die hohe Geschwindigkeit der Bildung des Suchzweigs und ein wesentlicher Nachteil besteht darin, dass dieser Algorithmus zur Bildung von Zusammensetzungen führt, wenn die Größe der Zusammensetzung einen bestimmten Schwellenwert überschreitet, der erst zu einer vollständigen Lösung abgeschlossen werden kann. Um diesen Nachteil zu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beseitigen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , stoppen wir die Bildung des </font><i><font style="vertical-align: inherit;">Suchzweigs,</font></i><font style="vertical-align: inherit;"> wenn der Schwellenwert </font><i><font style="vertical-align: inherit;">baseLevel-2 erreicht ist</font></i><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Effizienz des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rand &amp; Rand-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithmus </font><font style="vertical-align: inherit;">. Um die Fähigkeiten des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rand &amp; Rand-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithmus zu bestimmen </font><font style="vertical-align: inherit;">, wurde eine ziemlich detaillierte Computersimulation für eine Grundliste von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werten durchgeführt </font><font style="vertical-align: inherit;">. Wie beim </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet Modell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In den meisten Fällen betrug die Anzahl der erneuten Tests </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Million</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Bei anderen Werten verringerte sich die Anzahl der Tests allmählich von 100.000 auf 100. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beide Algorithmen basieren auf dem Prinzip der Zufallsauswahl. Daher ist zu erwarten, dass die hier gezogenen Schlussfolgerungen im Wesentlichen mit den für das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Modell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> formulierten </font><i><font style="vertical-align: inherit;">Schlussfolgerungen übereinstimmen</font></i><font style="vertical-align: inherit;"> . Es gibt jedoch einen grundlegenden Unterschied zwischen ihnen und er besteht aus Folgendem: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modell </font><font style="vertical-align: inherit;">funktioniert nicht so "hart" wie das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Modell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn wir von einem „Index rationaler Nutzung der </font><i><font style="vertical-align: inherit;">gebotenen</font></i><font style="vertical-align: inherit;"> Möglichkeiten“ sprechen, dem </font><i><font style="vertical-align: inherit;">rand &amp; rand-</font></i><font style="vertical-align: inherit;"> Modell</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei jedem Schritt werden Ressourcen rationeller eingesetzt. Dies führt dazu, dass beispielsweise bei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 30 die Wahrscheinlichkeit, in diesem Modell eine vollständige Lösung von 0,00170 zu erhalten, 15-mal größer ist als der ähnliche Wert von 0,00011 für das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Modell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Außerdem </font><font style="vertical-align: inherit;">bleibt </font><font style="vertical-align: inherit;">hier bis zum Schwellwert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 370 die Wahrscheinlichkeit bestehen, in einer Million Tests mindestens eine vollständige Lösung zu erhalten. Nach diesem Schwellenwert wurde für nachfolgende Werte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit einer Anzahl von Tests von einer Million </font><font style="vertical-align: inherit;">keine vollständige Lösung </font><font style="vertical-align: inherit;">auf der Basis des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rand &amp; Rand-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modells erhalten </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Dieser Algorithmus ist viel langsamer als der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithmus randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn für</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1000, um eine Komposition der Größe 967 zu generieren. Die durchschnittliche Zeit, um eine Komposition zu erhalten, beträgt 0,0497 Sekunden. Dies sind 33 Sekunden mehr als der entsprechende Wert von 0,0015 für das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet- und randSet-Modell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Grund für die Unterschiede zwischen zwei im Wesentlichen ähnlichen Methoden der Zufallsauswahl liegt darin, dass im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Modell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur Beschleunigung der Berechnungen nicht bei jedem Schritt eine Zufallsauswahl aus der verbleibenden Liste durchgeführt wird. Stattdessen wird ein Indexpaar nacheinander aus zwei Listen ausgewählt, deren Elemente nach dem Zufallsprinzip neu angeordnet wurden. Eine solche Auswahl ist nicht in vollem Umfang zufällig, passt jedoch gut zur Logik des Problems und ermöglicht es Ihnen, schnell zu zählen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zur visuellen Demonstration der Funktionsweise des </font><i><font style="vertical-align: inherit;">rand &amp; rand-</font></i><font style="vertical-align: inherit;"> Algorithmus</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wurde folgendes Experiment durchgeführt: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Für ein Schachbrett der Größe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100x100</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach jedem Schritt der Position der Königin in einer beliebigen Zeile wurde die Anzahl der freien Positionen in jeder der verbleibenden freien Zeilen bestimmt. So erhielten wir nach jedem Schritt der Problemlösung eine Liste der freien Zeilen und eine entsprechende Liste der Anzahl der freien Positionen in diesen Zeilen. Dies ermöglichte es, ein Diagramm zu erstellen, in dem die Indizes der Spalten der fraglichen Matrix entlang der Abszissenachse und die Anzahl der verbleibenden freien Positionen entlang der Ordinatenachse aufgetragen sind. Zum Vergleich wurden die Berechnungen auch für das Modell der sequentiellen Positionsauswahl durchgeführt. Mit sequentieller Auswahl ist das Folgende gemeint. Es wird die erste Zeile berücksichtigt, in der die erste freie Position in der Liste ausgewählt wird. Dann wird die zweite Zeile berücksichtigt, in der auch die erste freie Position in der Liste usw. ausgewählt wird. In den Abbildungen 5 und 6</font></font><br><br><img src="https://habrastorage.org/webt/y1/b5/vc/y1b5vcf2es-tsqteleekwvp5dly.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Reduzieren Sie die Anzahl der freien Positionen in den verbleibenden freien Linien nach der Platzierung der Königinnen. Sequenziell regelmäßige Positionsauswahl. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ergebnisse, die den betrachteten Modellen entsprechen, werden vorgestellt. Zur Verdeutlichung zeigt das Diagramm die Ergebnisse erst nach den Schritten (10, 40, 60). Für das Modell der sequentiellen Auswahl von Positionen ist die letzte die Grafik nach dem 62. Schritt, da der Suchzweig aufgrund des Fehlens einer freien Position in der 63. Zeile endet. Andererseits wird im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modell </font><font style="vertical-align: inherit;">die letzte Grafik nach dem 70. Schritt des Platzierens der Königin dargestellt, obwohl hier die durchschnittliche Anzahl der korrekt platzierten Königinnen 89 erreicht, was 26 Schritte mehr ist als im sequentiellen Modell. Eine seltsame Ansicht der Graphen im </font><i><font style="vertical-align: inherit;">rand &amp; rand-</font></i><font style="vertical-align: inherit;"> Modell</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aufgrund der Tatsache, dass der Zeilenindex zufällig aus den verbleibenden freien Zeilen ausgewählt wird und sie daher zufällig in der Lösungsmatrix verstreut sind. Ein Vergleich dieser beiden Zahlen zeigt, dass im sequentiellen Modell der Positionsauswahl der Variabilitätsbereich der Anzahl der freien Positionen höher ist als im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modell </font><font style="vertical-align: inherit;">. Dies liegt an der Tatsache, dass bei regelmäßiger Auswahl diagonale Beschränkungen freie Positionen in den verbleibenden Zeilen ungleichmäßig ausschließen, was dazu führt, dass in einigen Zeilen die Rate der Verringerung der Anzahl freier Positionen höher ist als in anderen Zeilen.</font></font><br><br><img src="https://habrastorage.org/webt/9y/mn/m6/9ymnm6wo_jsazg8_u474pjngke8.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Reduzieren Sie die Anzahl der freien Positionen in den verbleibenden freien Linien nach der Platzierung der Königinnen. Das Positionierungsmodell ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Gegensatz dazu werden bei zufälliger Auswahl des freien Zeilenindex und des freien Spaltenindex die Positionen der Dame gleichmäßig über den "Bereich" der Entscheidungsmatrix verteilt, wodurch die "durchschnittliche" Verringerungsrate der Anzahl freier Positionen in den verbleibenden Zeilen verringert wird. Unter Berücksichtigung der Funktionen des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithmus </font><font style="vertical-align: inherit;">wird dieser im Programm verwendet, um die Bildung des Lösungssuchzweigs </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fortzusetzen,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bis die </font><i><font style="vertical-align: inherit;">baseLevel-3-</font></i><font style="vertical-align: inherit;"> Ebene </font><i><font style="vertical-align: inherit;">erreicht ist</font></i><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist zu beachten, dass auch wenn die Auswahlalgorithmen ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet, rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) nicht so effektiv wäre, müssten wir bei der Entwicklung des Algorithmus noch eine andere Zufallsauswahlmethode anwenden. Dies ist auf die Aussage des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens-Completion-Problems zurückzuführen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn wir uns vorstellen, dass es einen bestimmten optimalen Algorithmus gibt, der das Problem löst, dann erhält ein solcher Algorithmus am Eingang immer eine bestimmte zufällige Menge von Zeilen- und Spaltenindizes. Jedes Mal wird es einen neuen zufälligen Satz von Zeilen- und Spaltenindizes aus einer Vielzahl von Möglichkeiten geben. Um den Algorithmus in einer solchen Vielfalt von Zufallszusammensetzungen "aufnehmen" zu können, muss der Algorithmus selbst auf der Basis einer Zufallsauswahl aufgebaut werden. Matching sollte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie ein Schlüssel zum Schloss sein</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Konstruieren wir den Algorithmus nach diesem Prinzip, so ergibt sich eine beliebige konsistente Zusammensetzung aus</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Königinnen werden als Ausgangsposition im Entscheidungssuchzyklus betrachtet. </font><font style="vertical-align: inherit;">Außerdem wird das Ziel nur darin bestehen, den Zweig der Suche nach einer Lösung fortzusetzen, bis eine Lösung für eine gegebene Zusammensetzung gefunden wird, oder es wird bewiesen, dass eine solche Lösung nicht existiert.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Ein Beispiel für die Verwendung der Minimalrisikoregel (n = 100) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Anfangsphase der Lösungsfindung ist die Auswahl des Index der freien Zeile oder des Index der Position in dieser Zeile nicht schwerwiegend, wenn die Anzahl der freien Positionen in den Zeilen nicht kritisch ist. Wenn jedoch in der letzten Phase die Anzahl der freien Positionen in einigen Zeilen 1 oder 2 beträgt, sollten Sie in diesem Fall einen anderen Auswahlalgorithmus auswählen. Auf dieser Ebene </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktionieren</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Zufallsauswahlalgorithmen </font><i><font style="vertical-align: inherit;">randSet &amp; randSet</font></i><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht mehr. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Grund, warum Zufallsauswahlalgorithmen nicht funktionieren, kann anhand des folgenden einfachen Beispiels erklärt werden. Lassen Sie in einem Schritt das Problem für einen beliebigen Wert von n in den verbleibenden Zeilen </font><i><font style="vertical-align: inherit;">i </font></i><i><sub><font style="vertical-align: inherit;">1</font></sub></i><i><font style="vertical-align: inherit;"> , i </font></i><i><sub><font style="vertical-align: inherit;">2</font></sub></i><i><font style="vertical-align: inherit;"> , ..., i </font></i><i><sub><font style="vertical-align: inherit;">k</font></sub></i><font style="vertical-align: inherit;"> lösen</font></font><i><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anzahl der offenen Stellen (in Klammern angegeben) beträgt: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (1), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (2), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (4), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (5), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (3), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (4)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usw. Wenn Sie nach dem Zufallsprinzip eine Zeile auswählen, jedoch nicht die Zeile i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in der nur eine freie Position vorhanden ist, kann dies zu einer Risikosituation führen, wenn diagonale Verbote in Bezug auf die Position der Dame in der ausgewählten Zeile zur Schließung der einzigen freien Position in der Zeile führen können </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , was die Lösung zum Stillstand bringt. Von allen Zeilen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am anfälligsten und empfindlichsten für die Auswahl des Zeilenindex ist Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In solchen Situationen sollten Sie zuerst die Zeile auswählen, deren Status am kritischsten ist und ein Risiko für die Lösung des Problems darstellt. In der letzten Phase der Problemlösung muss daher bei jedem Schritt die Position der Linie auf der Grundlage eines einfachen Algorithmus mit minimalem Risiko ausgewählt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrachten wir der Klarheit halber als Beispiel für eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100 x 100-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Matrix </font><font style="vertical-align: inherit;">die letzte Stufe bei der Bildung einer echten Lösung nach dem 88. Schritt. Bis zum Abschluss der Aufgabe blieben 12 freie Zeilen, für die jeweils die Anzahl der freien Positionen gefunden wurde (die Zeilen sind in aufsteigender Reihenfolge der Anzahl der freien Positionen angeordnet):</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt 89 - 25 (1), 12 (2), 22 (2), 82 (2), 88 (2), 7 (3), 64 (3), 3 (4), 76 (4), 91 (4), 4 (5), 96 (5)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - gibt den Index einer freien Zeile und in Klammern die Anzahl der freien Positionen in dieser Zeile an. Gemäß der minimalen Risikoregel wird im 89. Schritt der Problemlösung die Zeile 25 ausgewählt und die eine freie Position, die sich darin befindet. Als Ergebnis der Nachzählung haben wir noch 11 freie Zeilen: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt-90 - 7 (2), 12 (2), 22 (2), 82 (2), 88 (2), 3 (3), 64 (3), 76 (3), 4 (4), 91 (4), 96 (4).</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen können, ist die Anzahl der freien Positionen in den ersten fünf Zeilen gleich und gleich 2. Daher wird der Index einer der ersten drei Zeilen zufällig ausgewählt. </font><font style="vertical-align: inherit;">In diesem Fall wurde die 12. Reihe ausgewählt und die Position der beiden verbleibenden in dieser Reihe, was zu minimalem Schaden führt. </font><font style="vertical-align: inherit;">So haben wir im 91. Schritt der Lösungsbildung 10 freie Linien: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt-91 - 22 (1), 3 (2), 7 (2), 82 (2), 88 (2), 64 (3) 76 (3), 91 (3), 4 (4), 96 (4)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In diesem Schritt wird Zeile 22 ausgewählt und die eine freie Position, die sich darin befindet. </font><font style="vertical-align: inherit;">In ähnlicher Weise wurde die folgende Abfolge von Entscheidungen getroffen (Tabelle 1). </font><font style="vertical-align: inherit;">Die Indizes der ausgewählten Zeilen sind fett gedruckt.</font></font><br><div class="scrollable-table"><table><caption> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabelle 1. Demonstration der Verwendung der Mindestrisikoregel ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100).</font></font></b> <br></caption><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schritt </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th></tr><tr><td>  89 </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25 (1)</font></font></b> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12 (2) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 22 (2) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 82 (2) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7 (3) </font></font></td><td> 64(3) </td><td> 3(4) </td><td> 76(4) </td><td> 91(4) </td><td> 4(5) </td><td> 96(5) </td></tr><tr><td>  90 </td><td> 7(2) </td><td> <b>12(2)</b> </td><td> 22(2) </td><td> 82(2) </td><td> 3(3) </td><td> 64(3) </td><td> 76(3) </td><td> 4(4) </td><td> 91(4) </td><td> 96(4) </td><td></td></tr><tr><td>  91 </td><td> <b>22(1)</b> </td><td> 3(2) </td><td> 7(2) </td><td> 82(2) </td><td> 64(3) </td><td> 76(3) </td><td> 91(3) </td><td> 4(4) </td><td> 96(4) </td><td></td><td></td></tr><tr><td>  92 </td><td> <b>88(1)</b> </td><td> 3(2) </td><td> 7(2) </td><td> 82(2) </td><td> 91(2) </td><td> 64(3) </td><td> 76(3) </td><td> 4(4) </td><td> 96(4) </td><td></td><td></td></tr><tr><td>  93 </td><td> <b>3(1)</b> </td><td> 7(2) </td><td> 76(2) </td><td> 82(2) </td><td> 91(2) </td><td> 4(3) </td><td> 64(3) </td><td> 96(4) </td><td></td><td></td><td></td></tr><tr><td>  94 </td><td> <b>76(1)</b> </td><td> 4(2) </td><td> 7(2) </td><td> 82(2) </td><td> 91(2) </td><td> 64(3) </td><td> 96(4) </td><td></td><td></td><td></td><td></td></tr><tr><td>  95 </td><td> <b>91(1)</b> </td><td> 7(2) </td><td> 82(2) </td><td> 64(3) </td><td> 96(3) </td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  96 </td><td> <b>4(1)</b> </td><td> 82(1) </td><td> 7(2) </td><td> 64(3) </td><td> 96(3) </td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  97 </td><td> <b>7(1)</b> </td><td> 82(1) </td><td> 64(2) </td><td> 96(3) </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  98 </td><td> <b>82(1)</b> </td><td> 64(2) </td><td> 96(2) </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  99 </td><td> 64(1) </td><td> <b>96(1)</b> </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  100 </td><td> <b>64(1)</b> </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem speziellen Beispiel gab es in 11 von 12 Fällen eine Situation, in der in der Liste der verbleibenden freien Zeilen mindestens eine Zeile vorhanden war, in der nur eine freie Position vorhanden war. Wenn wir nicht die Mindestrisikoregel anwenden, können wir nicht bis zum Ende kommen. Da ein „falscher Zug“ bei der Auswahl eines Index einer freien Zeile zu einer Zerstörung der einzigen freien Position führen würde, die sich in einer der verbleibenden freien Zeilen befand. Dies ist der Grund, warum die </font><font style="vertical-align: inherit;">Lösung in den letzten Phasen in eine Sackgasse </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gerät</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wenn nur der Algorithmus </font><i><font style="vertical-align: inherit;">randSet x randSet</font></i><font style="vertical-align: inherit;"> oder </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand x rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet wird </font><font style="vertical-align: inherit;">, um eine vollständige Lösung zu erhalten.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist zu beachten, dass der Minimalrisiko-Algorithmus eine einfache alltägliche Bedeutung hat und häufig bei der Entscheidungsfindung verwendet wird. </font><font style="vertical-align: inherit;">Zum Beispiel operiert der Arzt zuallererst den Patienten, dessen Zustand für das Leben am kritischsten ist, ebenso wie der Landwirt während einer schweren Dürre, der versucht, die Ernte zu retten, zuerst die Bereiche wässerte, die sich in dem kritischsten Zustand befinden ...</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Analyse der Effizienz des Algorithmus </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Effizienz des Algorithmus für verschiedene Werte von n zu bewerten, wurde ein relativ langwieriges (in Bezug auf die Gesamtzeit) Rechenexperiment durchgeführt. Anfänglich wurde ein ziemlich schneller Algorithmus entwickelt, um Arrays von Lösungen nQueens Problem für einen beliebigen Wert von n zu erzeugen. Basierend auf diesem Programm wurden dann große Stichproben von Lösungen für eine Grundliste von n Werten gebildet. Die Größen der erhaltenen Proben von nQueens Problemlösungen für verschiedene Werte von n waren gleich: (10) - 1000, (20, 30, ..., 90, 100, 200, 300, 500, 800, 1000, 3000, 5000, 10.000) - -10000, (30000, 50000, 80000) - 5000, (105, 3 * 105) - 3000, (5 * 105, 8 * 105, 106) - 1000, (3 * 106) - 300, ( 5 * 106) - 200, (10 * 106) - 100, (30 * 106) - 50, (50 * 106) - 30, (80 * 106, 100 * 106) - 20. Hier ist in Klammern eine Liste von n Werten angegeben, und ein doppelter Strich gibt die Stichprobengröße der erhaltenen Lösungen an.Danach wurden zufällige Zusammensetzungen beliebiger Größe auf der Basis jeder Probe von Lösungen gebildet. Beispielsweise wurden für jede von 10.000 Lösungen für n = 1000 100 zufällige Zusammensetzungen beliebiger Größe gebildet. Das Ergebnis war eine Probe von einer Million Songs. Da jede Zusammensetzung beliebiger Größe, die auf der Grundlage einer vorhandenen Lösung gebildet wird, mindestens einmal bis zu einer vollständigen Lösung vervollständigt werden kann, bestand die Aufgabe darin, jede Zusammensetzung von der erzeugten Probe bis zu einer vollständigen Lösung auf der Grundlage des Lösungsalgorithmus für das n-Queens-Vervollständigungsproblem zu vervollständigen . Da im betrachteten Algorithmus bei jedem Schritt die korrekte Platzierung der Dame auf dem Schachbrett überprüft wird, kann dies hier grundsätzlich nicht der Fall seinAuf der Basis jeder Probe von Lösungen wurden zufällige Zusammensetzungen beliebiger Größe gebildet. Beispielsweise wurden für jede von 10.000 Lösungen für n = 1000 100 zufällige Zusammensetzungen beliebiger Größe gebildet. Das Ergebnis war eine Probe von einer Million Songs. Da jede Zusammensetzung beliebiger Größe, die auf der Grundlage einer vorhandenen Lösung gebildet wird, mindestens einmal bis zu einer vollständigen Lösung vervollständigt werden kann, bestand die Aufgabe darin, jede Zusammensetzung von der erzeugten Probe bis zu einer vollständigen Lösung auf der Grundlage des Lösungsalgorithmus für das n-Queens-Vervollständigungsproblem zu vervollständigen . Da im betrachteten Algorithmus bei jedem Schritt die korrekte Platzierung der Dame auf dem Schachbrett überprüft wird, kann dies hier grundsätzlich nicht der Fall seinAuf der Basis jeder Probe von Lösungen wurden zufällige Zusammensetzungen beliebiger Größe gebildet. Beispielsweise wurden für jede von 10.000 Lösungen für n = 1000 100 zufällige Zusammensetzungen beliebiger Größe gebildet. Das Ergebnis war eine Probe von einer Million Songs. Da jede Zusammensetzung beliebiger Größe, die auf der Grundlage einer vorhandenen Lösung gebildet wird, mindestens einmal bis zu einer vollständigen Lösung vervollständigt werden kann, bestand die Aufgabe darin, jede Zusammensetzung von der erzeugten Probe bis zu einer vollständigen Lösung auf der Grundlage des Lösungsalgorithmus für das n-Queens-Vervollständigungsproblem zu vervollständigen . Da im betrachteten Algorithmus bei jedem Schritt die korrekte Platzierung der Dame auf dem Schachbrett überprüft wird, kann dies hier grundsätzlich nicht der Fall seinEs wurden 100 zufällige Zusammensetzungen beliebiger Größe gebildet. Das Ergebnis war eine Probe von einer Million Songs. Da jede Zusammensetzung beliebiger Größe, die auf der Grundlage einer vorhandenen Lösung gebildet wird, mindestens einmal bis zu einer vollständigen Lösung vervollständigt werden kann, bestand die Aufgabe darin, jede Zusammensetzung von der erzeugten Probe bis zu einer vollständigen Lösung auf der Grundlage des Lösungsalgorithmus für das n-Queens-Vervollständigungsproblem zu vervollständigen . Da im betrachteten Algorithmus bei jedem Schritt die korrekte Platzierung der Dame auf dem Schachbrett überprüft wird, kann dies hier grundsätzlich nicht der Fall seinEs wurden 100 zufällige Zusammensetzungen beliebiger Größe gebildet. Das Ergebnis war eine Probe von einer Million Songs. Da jede Zusammensetzung beliebiger Größe, die auf der Grundlage einer vorhandenen Lösung gebildet wird, mindestens einmal bis zu einer vollständigen Lösung vervollständigt werden kann, bestand die Aufgabe darin, jede Zusammensetzung von der erzeugten Probe bis zu einer vollständigen Lösung auf der Grundlage des Lösungsalgorithmus für das n-Queens-Vervollständigungsproblem zu vervollständigen . Da im betrachteten Algorithmus bei jedem Schritt die korrekte Platzierung der Dame auf dem Schachbrett überprüft wird, kann dies hier grundsätzlich nicht der Fall seindann bestand die Aufgabe darin, jede Komposition von der generierten Stichprobe, basierend auf dem Lösungsalgorithmus für das n-Queens-Abschlussproblem, zu einer vollständigen Lösung zu vervollständigen. Da im betrachteten Algorithmus bei jedem Schritt die korrekte Platzierung der Dame auf dem Schachbrett überprüft wird, kann dies hier grundsätzlich nicht der Fall seinAnschließend bestand die Aufgabe darin, jede Komposition von der generierten Stichprobe auf der Grundlage des Lösungsalgorithmus für das n-Queens-Abschlussproblem zu einer vollständigen Lösung zu vervollständigen. Da im betrachteten Algorithmus bei jedem Schritt die korrekte Platzierung der Dame auf dem Schachbrett überprüft wird, kann dies hier grundsätzlich nicht der Fall sein</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falsch positive</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entscheidungen (d. H. Falsche Entscheidungen, die wir fälschlicherweise für richtig halten). Es kann jedoch auch zu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsch-negativen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lösungen kommen - für den Fall, dass eine auf der Basis der vorhandenen Lösung gebildete Zusammensetzung vom Programm erst vervollständigt wird, wenn die Lösung vollständig ist (obwohl wir wissen, dass alle Zusammensetzungen eine Lösung haben). Bei der Durchführung eines Computerexperiments in einem derart großen Bereich von n Werten haben wir uns folgende Ziele gesetzt: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Bestimmung der zeitlichen Komplexität des Algorithmus, </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Bestimmung der Wahrscheinlichkeit von falsch negativen Lösungen für verschiedene Werte von n, </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) Bestimmung der Häufigkeit, mit der das Back Tracking-Verfahren angewendet wird verschiedene Werte von n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ergebnisse eines solchen Berechnungsexperiments sind in Tabelle 2 dargestellt.</font></font><br><div class="scrollable-table"><table><caption> <b> 2.         n.</b> <br> <i>n</i> –   ; <i>m</i> –   ; t <sub>mean</sub> , t <sub>min</sub> , t <sub>max</sub> – ,     ; t90 <sub>mean</sub> –   ,    10%    ; FalseNeg( FalseNegative) –  ,      ; <i>t <sub>row</sub> = t <sub>mean</sub> *10 <sup>6</sup> / n</i> ,   10 <sup>6</sup>   ,            <i>nxn</i> . <br></caption><tbody><tr><th>  n </th><th> m </th><th> t <sub>mean</sub> </th><th> t90 <sub>mean</sub> </th><th> t <sub>min</sub> </th><th> t <sub>max</sub> </th><th> FalseNeg </th><th> t <sub>row</sub> </th></tr><tr><td>  10 </td><td>  5000 </td><td> <b>0.001010</b> </td><td> 0.000532 </td><td> 0.000168 </td><td> 0.080673 </td><td>  2 </td><td> 1.0102 </td></tr><tr><td>  20 </td><td>  10 <sup>5</sup> </td><td> <b>0.003589</b> </td><td> 0.001809 </td><td> 0.000197 </td><td> 0.363096 </td><td>  5 </td><td> 1.7945 </td></tr><tr><td>  30 </td><td>  10 <sup>5</sup> </td><td> <b>0.008025</b> </td><td> 0.003793 </td><td> 0.000244 </td><td> 0.495716 </td><td>  10 </td><td> 2.6752 </td></tr><tr><td>  40 </td><td>  10 <sup>5</sup> </td><td> <b>0.014323</b> </td><td> 0.009127 </td><td> 0.000252 </td><td> 0.965817 </td><td>  7 </td><td> 3.5807 </td></tr><tr><td>  50 </td><td>  10 <sup>5</sup> </td><td> <b>0.005357</b> </td><td> 0.003589 </td><td> 0.000313 </td><td> 0.441711 </td><td>  9 </td><td> 10.7146 </td></tr><tr><td>  60 </td><td>  10 <sup>5</sup> </td><td> <b>0.005991</b> </td><td> 0.004103 </td><td> 0.000340 </td><td> 0.013738 </td><td>  10 </td><td> 9.9852 </td></tr><tr><td>  70 </td><td>  10 <sup>5</sup> </td><td> <b>0.006533</b> </td><td> 0.004566 </td><td> 0.000368 </td><td> 0.583897 </td><td>  8 </td><td> 9.3328 </td></tr><tr><td>  80 </td><td>  10 <sup>5</sup> </td><td> <b>0.006975</b> </td><td> 0.004987 </td><td> 0.000394 </td><td> 0.635676 </td><td>  7 </td><td> 8.7187 </td></tr><tr><td>  90 </td><td>  10 <sup>5</sup> </td><td> <b>0.006912</b> </td><td> 0.004763 </td><td> 0.000393 </td><td> 1.012710 </td><td>  4 </td><td> 7.6840 </td></tr><tr><td>  100 </td><td>  10 <sup>5</sup> </td><td> <b>0.007264</b> </td><td> 0.005107 </td><td> 0.000419 </td><td> 0.692387 </td><td>  4 </td><td> 7.2641 </td></tr><tr><td>  300 </td><td>  10 <sup>5</sup> </td><td> <b>0.013518</b> </td><td> 0.009496 </td><td> 0.000986 </td><td> 3.349766 </td><td>  3 </td><td> 4.5060 </td></tr><tr><td>  500 </td><td>  10 <sup>5</sup> </td><td> <b>0.028194</b> </td><td> 0.014554 </td><td> 0.001541 </td><td> 4.558749 </td><td>  2 </td><td> 5.6388 </td></tr><tr><td>  800 </td><td>  10 <sup>5</sup> </td><td> <b>0.049385</b> </td><td> 0.022735 </td><td> 0.002367 </td><td> 6.192782 </td><td>  1 </td><td> 6.1731 </td></tr><tr><td>  1000 </td><td> <b>10 <sup>6</sup></b> </td><td> <b>0.062157</b> </td><td> 0.027727 </td><td> 0.002943 </td><td> 8.015123 </td><td>  0 </td><td> 6.2156 </td></tr><tr><td>  3000 </td><td>  10 <sup>5</sup> </td><td> <b>0.177290</b> </td><td> 0.088507 </td><td> 0.008537 </td><td> 16.713140 </td><td>  0 </td><td> 5.9097 </td></tr><tr><td>  5000 </td><td>  10 <sup>5</sup> </td><td> <b>0.159239</b> </td><td> 0.136047 </td><td> 0.014224 </td><td> 42.181080 </td><td>  0 </td><td> 3.1849 </td></tr><tr><td>  10 <sup>4</sup> </td><td>  10 <sup>5</sup> </td><td> <b>0.321003</b> </td><td> 0.270927 </td><td> 0.028594 </td><td> 79.321174 </td><td>  0 </td><td> 3.2100 </td></tr><tr><td> 3*10 <sup>4</sup> </td><td>  10 <sup>4</sup> </td><td> <b>0.968795</b> </td><td> 0.651618 </td><td> 0.084936 </td><td> 139.28827 </td><td>  0 </td><td> 3.2293 </td></tr><tr><td> 5*10 <sup>4</sup> </td><td>  5000 </td><td> <b>1.147196</b> </td><td> 0.864045 </td><td> 0.143005 </td><td> 154.38225 </td><td>  0 </td><td> 2.2944 </td></tr><tr><td> 8*10 <sup>4</sup> </td><td>  4000 </td><td> <b>2.112079</b> </td><td> 1.215612 </td><td> 0.229532 </td><td> 204.27321 </td><td>  0 </td><td> 2.6401 </td></tr><tr><td>  10 <sup>5</sup> </td><td>  2000 </td><td> <b>2.253118</b> </td><td> 1.433197 </td><td> 0.290566 </td><td> 224.34623 </td><td>  0 </td><td> 2.2531 </td></tr><tr><td> 3*10 <sup>5</sup> </td><td>  2000 </td><td> <b>4.330649</b> </td><td> 3.181905 </td><td> 0.990932 </td><td> 340.29584 </td><td>  0 </td><td> 1.4435 </td></tr><tr><td> 5*10 <sup>5</sup> </td><td>  2000 </td><td> <b>5.985339</b> </td><td> 4.532205 </td><td> 1.488209 </td><td> 382.20016 </td><td>  0 </td><td> 1.1971 </td></tr><tr><td> 8*10 <sup>5</sup> </td><td>  2000 </td><td> <b>8.297512</b> </td><td> 6.554302 </td><td> 2.902425 </td><td> 75.87513 </td><td>  0 </td><td> 1.0372 </td></tr><tr><td>  10 <sup>6</sup> </td><td>  1000 </td><td> <b>11.376632</b> </td><td> 7.932194 </td><td> 2.954968 </td><td> 510.6265 </td><td>  0 </td><td> 1.1377 </td></tr><tr><td> 3*10 <sup>6</sup> </td><td>  400 </td><td> <b>23.138609</b> </td><td> 18.521503 </td><td> 10.433580 </td><td> 122.7597 </td><td>  0 </td><td> 0.7713 </td></tr><tr><td> 5*10 <sup>6</sup> </td><td>  300 </td><td> <b>33.103386</b> </td><td> 28.057816 </td><td> 14.937556 </td><td> 155.0890 </td><td>  0 </td><td> 0.6621 </td></tr><tr><td> 10*10 <sup>6</sup> </td><td>  200 </td><td> <b>61.444001</b> </td><td> 52.269241 </td><td> 31.624475 </td><td> 228.3087 </td><td>  0 </td><td> 0.6144 </td></tr><tr><td> 30*10 <sup>6</sup> </td><td>  50 </td><td> <b>149.71717</b> </td><td> 136.66441 </td><td> 84.556686 </td><td> 352.0534 </td><td>  0 </td><td> 0.4991 </td></tr><tr><td> 50*10 <sup>6</sup> </td><td>  40 </td><td> <b>253.86220</b> </td><td> 228.93732 </td><td> 105.37934 </td><td> 558.4629 </td><td>  0 </td><td> 0.5077 </td></tr><tr><td> 80*10 <sup>6</sup> </td><td>  30 </td><td> <b>372.29294</b> </td><td> 341.56397 </td><td> 250.80182 </td><td> 728.4806 </td><td>  0 </td><td> 0.4654 </td></tr><tr><td> 100*10 <sup>6</sup> </td><td>  20 </td><td> <b>508.43573</b> </td><td> 474.04890 </td><td> 354.80864 </td><td> 831.3753 </td><td>  0 </td><td> 0.5084 </td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die allgemeine Schlussfolgerung, die auf der Grundlage der erhaltenen Ergebnisse gezogen werden kann, lautet wie folgt: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Der Algorithmus arbeitet schnell genug. Beispielsweise beträgt die durchschnittliche Kompilierungszeit einer beliebigen Komposition für ein Schachbrett der Größe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000 x 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die auf der Grundlage von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einer Million</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rechenexperimenten erhalten wurde, 0,062157 Sekunden. Das heißt, wenn die Komposition eine Lösung hat, wird diese sofort nach dem Drücken der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Enter"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Taste gefunden </font><font style="vertical-align: inherit;">. Die durchschnittliche Kompilierungszeit einer beliebigen Komposition für alle Werte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Bereich von 7 bis 30.000 überschreitet eine Sekunde nicht.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) In jeder Probe gibt es ungefähr 10% der Zusammensetzungen, die viel mehr Zeit benötigen, um fertig zu werden. Solche Zusammensetzungen bilden im Verteilungshistogramm einen langen rechten Schwanz. Wenn wir diese 10% der Zusammensetzungen ausschließen und Berechnungen für die restlichen 90% der Lösungen durchführen, ist die Berechnungszeit ( </font><i><sub><font style="vertical-align: inherit;">Mittelwert</font></sub></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> t90</font></font><sub><font style="vertical-align: inherit;"></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) viel kürzer. Bei einem Schachbrett von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000 x 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beträgt die durchschnittliche Zählzeit beispielsweise 0,027727 Sekunden, was dem 2,24-fachen der durchschnittlichen Zeit entspricht, die auf der Grundlage der gesamten Stichprobe ermittelt wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) Für Werte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n ≤ 800</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gab es in der Stichprobe von Zusammensetzungen diejenigen, die bis zu einer vollständigen Lösung nicht vervollständigt werden konnten. Dies ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsch negativ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entscheidungen. </font><font style="vertical-align: inherit;">Der Algorithmus konnte diese Kompositionen </font><font style="vertical-align: inherit;">innerhalb der im Programm festgelegten Grenzen, die es ermöglichten, das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Back-Tracking-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verfahren </font><font style="vertical-align: inherit;">bis zu 1000-mal </font><font style="vertical-align: inherit;">durchzuführen </font><font style="vertical-align: inherit;">, nicht vervollständigen. Sie wurden fälschlicherweise als negative Zusammensetzungen klassifiziert, d.h. diejenigen, die keine Lösung haben. Die Anzahl solcher </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsch-negativen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lösungen ist unbedeutend und ihr Anteil an der Stichprobe beträgt weniger als 0,0001. Wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zunimmt </font><font style="vertical-align: inherit;">, nimmt ferner der Anteil der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsch negativen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lösungen ab. Für alle Werte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; 800 gab es in dieser Reihe von Rechnerexperimenten keinen einzigen Fall von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsch negativen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lösungen. Es ist jedoch offensichtlich, dass die Möglichkeit des Auftretens von </font><i><font style="vertical-align: inherit;">falschem Negativ</font></i><font style="vertical-align: inherit;"> nicht ausgeschlossen wird, wenn die Probengröße um ein Vielfaches erhöht </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lösungen, obwohl die Wahrscheinlichkeit eines solchen Ereignisses sehr gering sein wird. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zeitliche Komplexität des Algorithmus</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Fig. 7 zeigt eine graphische Darstellung von Änderungen in der durchschnittlichen Aufnahmedauer von Zufallszusammensetzungen für verschiedene Werte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><img src="https://habrastorage.org/webt/fe/lj/zy/feljzywqkqijg-0pftjholzx3es.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Die Abhängigkeit der durchschnittlichen Erntezeit ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) zufälliger Zusammensetzungen von der Größe ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) der Entscheidungsmatrix. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf der Abszissenachse </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist der</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dezimale Logarithmus des Wertes von </font><i><font style="vertical-align: inherit;">n und</font></i><font style="vertical-align: inherit;"> auf der Ordinatenachse </font><font style="vertical-align: inherit;">der um das 1000-fache erhöhte Logarithmus der mittleren Zählzeit aufgetragen. Zur Verdeutlichung zeigt die Figur auch die gepunktete Linie der Diagonale des Quadranten. Es ist zu sehen, dass die Erntezeit linear mit einer Zunahme von n zunimmt. Über den gesamten Bereich von n-Werten von 50 bis 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 bilden die</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> experimentellen Zählzeiten eine gerade Linie, die mit einer relativ hohen Korrelation ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = 0,9998</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) durch die lineare Regressionsgleichung </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">log (1000 * t) = - 0,628927 + 0,781568 * log (n) beschrieben wird.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine leichte Abweichung vom allgemeinen Trend ist nur für die Werte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (10, ... 49)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> typisch </font><font style="vertical-align: inherit;">, da zur Lösung des Problems nur der fünfte Berechnungsblock in diesem Bereich verwendet wird, dessen Algorithmus sich erheblich von der Funktionsweise der Algorithmen des ersten und dritten Blocks unterscheidet. In der erhaltenen Abhängigkeit ist der lineare Koeffizient ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,781568</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) kleiner als Eins, was dazu führt, dass mit zunehmendem n die Regressionslinie und die Diagonale des Quadranten auseinander laufen. Um den Grund für eine solche Diskrepanz anstelle der Anfangszeit klar zu erklären, betrachten wir die durchschnittliche Zeit, die für den Ort einer Dame auf einer Zeile erforderlich ist, d. H. dividiere die durchschnittliche Zählzeit durch </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wir nennen einen solchen Indikator die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reduzierte Zeit.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn sich die reduzierte Zeit mit zunehmendem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht ändert </font><font style="vertical-align: inherit;">, ist eine solche Lösung </font><font style="vertical-align: inherit;">offensichtlich </font><font style="vertical-align: inherit;">linear ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (n)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Wie aus Fig. 8 ersichtlich ist, zeigt diese eine Auftragung des Logarithmus der reduzierten Zeit</font></font><br><br><img src="https://habrastorage.org/webt/rm/zo/i5/rmzoi5vzkips2kreyaltswbzivm.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 Die Abhängigkeit der Durchschnittszeit ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">row</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), die erforderlich ist, damit sich die Dame auf einer beliebigen Linie befindet, von der Größe ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) der Entscheidungsmatrix. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tRow</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), erhöht um das 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6-</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fache vom Logarithmus der Größe der Lösungsmatrix im Bereich von n von 50 bis 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , verringert sich die reduzierte Zeit mit zunehmendem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn die reduzierte Zeit für </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 50</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10,7146 × 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">–6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekunden </font><font style="vertical-align: inherit;">beträgt </font><font style="vertical-align: inherit;">, wird die entsprechende Zeit für n = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 um</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> das 21-fache reduziert und beträgt 0,5084 × 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">–6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekunden. Ein solches Verhalten des Algorithmus erscheint auf den ersten Blick irrtümlich, da es keine objektiven Gründe gibt, warum der Algorithmus ihn für kleine Werte von n als langsamer als für große Werte ansieht. Es liegt jedoch kein Fehler vor, und dies ist eine objektive Eigenschaft dieses Algorithmus. Dies liegt an der Tatsache, dass dieser Algorithmus aus drei Algorithmen besteht, die mit unterschiedlichen Geschwindigkeiten arbeiten. Darüber hinaus ändert sich die Anzahl der von jedem dieser Algorithmen verarbeiteten Zeilen mit zunehmendem Wert von n. Aus diesem Grund nimmt die Zählzeit im anfänglichen Wertebereich n = (10, 20, 30, 40) zu, da alle Berechnungen in diesem kleinen Bereich nur auf der Grundlage des fünften Verfahrensblocks durchgeführt werden, der sehr effizient, jedoch nicht so schnell wie arbeitet erster Block von Prozeduren. Angesichts der Zeit, die erforderlich ist, um die Dame in einer Zeile zu positionieren,nimmt mit zunehmender Größe des Schachbretts ab, so kann die zeitliche Komplexität dieses Algorithmus als abnehmend - linear bezeichnet werden.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Häufigkeit, mit der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Back Tracking (BT) verwendet wurde</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In allen Fällen eines Computerexperiments haben wir die Anzahl der Fälle mithilfe des BT-Verfahrens bei der Lösung jedes Problems verfolgt. Es wurde eine kumulative Zusammenfassung aller Fälle der Verwendung von BT erstellt, unabhängig davon, auf welche Basisebene bei der Suche nach einer Lösung zurückgekehrt wurde. Dies gab uns die Möglichkeit, für jede Stichprobe den Anteil der Entscheidungen zu bestimmen, bei denen das BT-Verfahren noch nie angewendet wurde. Abbildung 9 zeigt</font></font><br><br><img src="https://habrastorage.org/webt/_l/5t/h5/_l5th5fsxg_u7aw_dei4o3b5h2w.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9. Der Anteil der Entscheidungen in der Stichprobe, bei denen das Verfahren zur Rückverfolgung noch nie verwendet wurde, in einem </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diagramm, das zeigt, wie sich der Anteil der Fälle der Lösung ändert, ohne das BT-Verfahren ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zero Back Tracking</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) mit zunehmendem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n zu verwenden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es ist zu erkennen, dass im Wertebereich </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (7, ..., 100000)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Anzahl der Lösungen, in denen das BT-Verfahren noch nie angewendet wurde, 35% überschreitet. Darüber hinaus </font><font style="vertical-align: inherit;">übersteigt </font><font style="vertical-align: inherit;">im Wertebereich </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (320, ..., 22500)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Anzahl solcher Fälle 50%. Die effektivsten Ergebnisse wurden für ein Schachbrett mit einer Größe von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5000 x 5000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erzielt </font><font style="vertical-align: inherit;">, bei dem in einer Stichprobe von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kompositionen in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">61,92% der</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fälle </font><i><font style="vertical-align: inherit;">„deterministisch“ </font></i><i><font style="vertical-align: inherit;">vorgegangen wurde</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lösen eines </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht deterministischen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Problems, weil In </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">61,92% der</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fälle wurde das </font><font style="vertical-align: inherit;">BT-Verfahren </font><font style="vertical-align: inherit;">nie angewendet. In den übrigen Lösungen wurde in 21,87% der Fälle das BT-Verfahren einmal, in 9,07% der Fälle zweimal und in 3,77% der Fälle dreimal angewendet. Zusammen macht dies 96,63% der Fälle aus. Die Tatsache, dass nach dem Wert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 5000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Anzahl der Fälle, in denen das Konfigurationsproblem ohne Verwendung der BT-Prozedur gelöst wird, allmählich abnimmt, hängt mit dem ausgewählten Modell für die Auswahl der Grenzwerte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel3 zusammen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sie können diese Parameter ändern und die Anzahl der Lösungen erhöhen, ohne das BT-Verfahren zu verwenden. Dies führt jedoch zu einer Verlängerung der Rechenzeit, da die Beteiligung des fünften Blocks an der Funktionsweise des Algorithmus zunimmt.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Histogramm der Verteilung der Zeiterfassung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In 10 ist für einen Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein Histogramm der Verteilung der Entnahmezeit für eine Million Entscheidungen dargestellt. Die nicht ganz gewöhnliche Ansicht des Verteilungshistogramms (das höchstwahrscheinlich der Nachtsilhouette hoher Gebäude ähnelt) ist nicht mit einem Fehler bei der Auswahl der Länge oder Anzahl der Intervalle verbunden. Dies ist eine natürliche Eigenschaft dieses Algorithmus. Zu verstehen</font></font><br><br><img src="https://habrastorage.org/webt/cm/ii/z9/cmiiz94kbp7hxfss1aqzkejd09o.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. Ein Histogramm der Zusammenstellungszeit von Kompositionen beliebiger Größe. ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stichprobengröße = 1.000.000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berücksichtigen Sie, warum das Histogramm eine solche Form hat, die Verteilung der Aufnahmezeit für Zusammensetzungen mit derselben Größe. Als Beispiel werden wir aus der ersten Stichprobe alle Kompositionen auswählen, deren Größe 800 beträgt. In einer Stichprobe von einer Million waren 998 solcher Kompositionen enthalten. Fig. 11 zeigt ein Histogramm der Verteilung der Zählzeit für diese Probe. Aus der Abbildung ist ersichtlich, dass die Verteilung aus sechs separaten Histogrammen mit abnehmender Größe besteht.</font></font><br><br><img src="https://habrastorage.org/webt/ku/70/xa/ku70xadamrocfeimg3zpvyvurgu.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. Ein Histogramm der Kompilierungszeit von Kompositionen gleicher Größe (k = 800). ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stichprobengröße = 998</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Grund, warum die Kompilierungszeit von 998 Kompositionen, in denen jeweils 800 Königinnen zufällig verteilt sind, in 6 Gruppen "gruppiert" wird, weil das </font><i><font style="vertical-align: inherit;">Back-Tracking-</font></i><font style="vertical-align: inherit;"> Verfahren verwendet wird</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Das erste Histogramm in der Abbildung mit der maximalen Stichprobengröße zeigt die Lösungen, bei denen das BT-Verfahren noch nie angewendet wurde. Dies ist eine Gruppe der schnellsten Lösungen. Das zweite Histogramm, das wesentlich kleiner ist als das erste, sind diejenigen Lösungen, bei denen das BT-Verfahren nur einmal verwendet wurde. Daher ist die Entscheidungszeit in dieser Gruppe etwas länger als in der ersten. Dementsprechend wurde in der dritten Gruppe die BT-Prozedur zweimal verwendet, in der vierten - dreimal usw., d.h. Entscheidungen, bei denen das BT-Verfahren wiederholt angewendet wurde, wurden über einen längeren Zeitraum durchgeführt. Solche Lösungen bilden den langen rechten Schwanz der gewünschten Verteilung. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falsch Negative Lösungen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Teilen wir alle möglichen Kompositionen durch einen beliebigen Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu positiv und negativ, dann gibt es unter den positiven Kompositionen diejenigen, die dieser Algorithmus als negativ einstufen kann. Dies liegt an der Tatsache, dass der Algorithmus innerhalb der durch die Suchparameter festgelegten Grenzen nicht den richtigen Weg finden kann, um solche Kompositionen zu vervollständigen. Wie die experimentellen Ergebnisse (Tabelle 2) zeigen, überschreitet die Anzahl solcher Fälle nicht 0,0001 der Probengröße und der Wert dieses Fehlers nimmt mit zunehmendem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n ab</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Zusätzlich gab es für alle Werte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n&gt; 800</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keinen einzigen Fall einer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsch negativen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lösung. Selbst eine Erhöhung des Stichprobenumfangs auf eine Million für </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> führte nicht zu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">False Negative</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entscheidungen. </font><font style="vertical-align: inherit;">Das Ergebnis erlaubt es uns, die folgende Regel zur Lösung des Problems zu formulieren: „Jede zufällige Zusammensetzung von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Damen, die konsistent auf einem beliebigen Schachbrett der Größe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn verteilt ist,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann vervollständigt werden, bis eine vollständige Lösung </font><i><font style="vertical-align: inherit;">vorliegt</font></i><font style="vertical-align: inherit;"> , oder es wird entschieden, dass diese Zusammensetzung negativ ist und nicht abgeschlossen sein. </font><font style="vertical-align: inherit;">Die Wahrscheinlichkeit, eine solche Entscheidung zu treffen, überschreitet </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,0001 nicht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mit zunehmender Größe eines Schachbretts sinkt die Wahrscheinlichkeit, falsche Entscheidungen zu treffen. </font><font style="vertical-align: inherit;">Die zeitliche Komplexität des Algorithmus ist linear. “</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Schlussfolgerungen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird ein Algorithmus vorgestellt, der es ermöglicht, in linearer Zeit das gesamte </font><i><font style="vertical-align: inherit;">Mengenproblem</font></i><font style="vertical-align: inherit;"> zu lösen, bis eine vollständige Lösung einer zufälligen Zusammensetzung von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Königinnen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorliegt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die konsistent auf einem Schachbrett beliebiger Größe </font><i><font style="vertical-align: inherit;">nxn verteilt ist</font></i><font style="vertical-align: inherit;"> . Darüber hinaus wird für jede Zusammensetzung von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Königinnen (1 </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">≤ k &lt;n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) eine Lösung bereitgestellt, falls vorhanden, oder es wird eine Entscheidung getroffen, dass diese Zusammensetzung nicht vervollständigt werden kann. Die Wahrscheinlichkeit eines Fehlers bei einer solchen Entscheidung überschreitet nicht 0,0001 und dieser Wert nimmt mit zunehmender Größe eines Schachbretts ab. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Die Funktionsweise dieses Algorithmus basiert auf der Verwendung von zwei wichtigen Regeln:</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) In der letzten Phase der Problemlösung wird aus allen verbleibenden freien Positionen eine ausgewählt, für die die Anzahl der freien Positionen minimal ist ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minimale Risikoregel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Dies minimiert die Risiken, die mit der Möglichkeit verbunden sind, die letzten offenen Positionen in einigen der verbleibenden Linien auszuschließen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Von allen vakanten Positionen in der betreffenden Linie wird diejenige Position ausgewählt, die den freien Positionen in den verbleibenden freien Linien einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minimalen Schaden zufügt (Regel des minimalen Schadens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Mit " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minimaler Schaden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " ist die Auswahl einer solchen Position in einer Zeile gemeint, die die geringste Menge an freien Positionen in allen verbleibenden freien Zeilen ausschließt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Es wurde festgestellt, dass als Ergebnis der Operation dieses Algorithmus die durchschnittliche Zeit, die erforderlich ist, um die Königin auf eine Zeile zu setzen, mit einer Zunahme des Werts von n abnimmt. Die durchschnittliche Zeit, die erforderlich ist, um die Dame in einer Zeile zu platzieren, wenn n 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist, ist 21-mal kürzer als die entsprechende Zeit für den Fall n = 50. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Es wurde festgestellt, dass im Wertebereich </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (7, ..., 100000) die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anzahl der Lösungen, in denen das Rückverfolgungsverfahren noch nie angewendet wurde, 35% übersteigt. Darüber hinaus </font><font style="vertical-align: inherit;">übersteigt </font><font style="vertical-align: inherit;">im Wertebereich </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (320, ..., 22500)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Anzahl solcher Fälle 50%, was die hohe Effizienz dieses Algorithmus anzeigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Ein Modell für die Organisation des </font><i><font style="vertical-align: inherit;">Back Tracking-</font></i><font style="vertical-align: inherit;"> Verfahrens wird vorgeschlagen.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, basierend auf der Trennung der Reihenfolge der Entscheidungsschritte auf den Grundebenen. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Level bedeutet einen bestimmten Entscheidungsschritt mit einer bestimmten Anzahl von Königinnen, die korrekt platziert wurden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Zur Berechnung der Werte der zweiten und dritten Grundstufe in Abhängigkeit von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n werden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Regressionsformeln angegeben </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Die Ergebnisse einer vergleichenden Analyse von zwei Zufallsauswahlmethoden, die als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand bezeichnet werden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , werden </font><i><font style="vertical-align: inherit;">vorgestellt</font></i><font style="vertical-align: inherit;"> . Der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Algorithmus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hat sich als schnell, aber unhöflich </font><i><font style="vertical-align: inherit;">erwiesen</font></i><font style="vertical-align: inherit;"> . Daher ist seine Verwendung beim Erreichen der zweiten Grundstufe begrenzt. Danach wird der </font><i><font style="vertical-align: inherit;">Rand &amp; Rand-</font></i><font style="vertical-align: inherit;"> Algorithmus verwendet.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die nicht so schnell durchgeführt wird, sondern Königinnen effektiver auf ein Schachbrett legt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Es wird ein effektiver Algorithmus zur Überprüfung der Korrektheit der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens-Problemlösung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angegeben </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dieses Programm dient auch dazu, die Richtigkeit einer zufälligen Zusammensetzung beliebiger Größe zu überprüfen. </font><font style="vertical-align: inherit;">Das Programm arbeitet schnell genug. </font><font style="vertical-align: inherit;">Beispielsweise beträgt die zur Validierung einer aus 5 Millionen Positionen bestehenden Lösung erforderliche Zeit 0,85 Sekunden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Kommentare </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Wie zu Beginn des Artikels angegeben, wurden Studien im Bereich von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werten </font><font style="vertical-align: inherit;">von 7 bis 100 Millionen durchgeführt. Das Programm wurde jedoch in einem größeren Bereich von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werten getestet </font><font style="vertical-align: inherit;">, bis zu einer Milliarde. In letzterem Fall musste das Programm allerdings aufgrund der Größe der Arrays leicht angepasst werden. Wenn die Größe des RAM dies zulässt, ist es daher möglich, Berechnungen für große Werte von n durchzuführen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Die Werte der Basisindikatoren sowie die Grenzwerte für die Anzahl der Wiederholungen auf verschiedenen Ebenen wurden optimiert, um das Problem im gesamten Forschungsbereich zu lösen. Sie können in einem kleineren Bereich geändert werden und verkürzen die Zählzeit. Es ist wichtig, den Anteil der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsch negativen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lösungen </font><font style="vertical-align: inherit;">nicht zu erhöhen </font><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. In diesem Artikel habe ich die Zeit </font><font style="vertical-align: inherit;">zum </font><font style="vertical-align: inherit;">Drücken der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eingabetaste</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als Zeitmaß verwendet, um zu bewerten, wie schnell der Algorithmus arbeitet. Wenn das Ergebnis unmittelbar nach dem Drücken der Taste angezeigt wird, scheint es auf der Ebene der Benutzerwahrnehmung, dass das Programm "sehr" schnell arbeitet. Egal wie schnell der Algorithmus arbeitet, das Ergebnis wird erst auf dem Bildschirm angezeigt, wenn der Schlüssel vollständig ist. Aus diesem Grund schien es mir, dass eine solche bedingte Zeitmessung als Schwellenwert dienen kann, um die Geschwindigkeit verschiedener Algorithmen nicht genau zu vergleichen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Philosophisch ... Während der Studie wurde eine Vielzahl von Veröffentlichungen zur Lösung nicht deterministischer Probleme betrachtet. In den meisten Fällen handelte es sich dabei um Aufgaben, bei denen unter den Bedingungen vorgegebener Beschränkungen in einem großen Staatenraum eine Auswahl getroffen werden musste. Im Vergleich war es interessant zu wissen, wie weit man bei der Lösung solcher Probleme mit dem mathematischen Standardansatz kommen kann. Ich hatte den Eindruck, dass es unmöglich ist, solche Probleme nur auf der Grundlage von Definitionen, Behauptungen und Beweisen zu lösen. Es scheint mir, dass es zur Lösung solcher Probleme notwendig ist, die Methoden der algorithmischen Mathematik unter Verwendung von Computersimulationen anzuwenden. Um die Gültigkeit dieser Schlussfolgerung zu demonstrieren, habe ich als einfaches Beispiel ein Schachbrett vorbereitet, dessen Größe 10 ist</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> x 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zwei Kompositionen gleicher Größe, bestehend aus 999.999.482 Königinnen. Sie werden wie am Anfang des Artikels beschrieben erstellt und als zwei Dateien im Format .mat angezeigt. Sie können unter diesem Link heruntergeladen werden </font></font><a href="https://drive.google.com/drive/folders/1p5VJO4fAEs8vNp_EonFIitd1o6EJqzQt%3Fusp%3Dsharing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(zwei Testdateien)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dateien sind ziemlich "schwer", die Größe jeder von ihnen beträgt etwa 3,97 GB. In 999 997 976 Zeilen (in 99,9998% der Fälle) stimmen die Positionen der Königinnen in beiden Kompositionen überein, und nur in willkürlichen 1506 Zeilen unterscheiden sich die Positionen der Königinnen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Zusammensetzungsdaten zu einer vollständigen Lösung zu vervollständigen, müssen Sie die Damen korrekt in die verbleibenden 518 freien Zeilen einfügen. Die Anzahl der möglichen Möglichkeiten, 518 Königinnen in den verbleibenden freien Linien anzuordnen (wobei nur die Anzahl der Möglichkeiten berücksichtigt wird, eine freie Position in der ausgewählten Linie auszuwählen), beträgt ungefähr </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.146</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Der Unterschied zwischen diesen beiden Zusammensetzungen besteht nur darin, dass eine davon positiv ist und bis zu einer vollständigen Lösung vervollständigt werden kann, und die andere Zusammensetzung negativ ist - sie kann nicht bis zu einer vollständigen Lösung vervollständigt werden. Frage: „Ist es möglich, auf der Grundlage eines strengen mathematischen Ansatzes (dh ohne Ausführung algorithmischer Rechenoperationen) zu bestimmen, welche dieser beiden Kompositionen positiv ist?“ Wenn dies nicht zu lösen ist, können wir davon ausgehen, dass der Satz durch Widerspruch bewiesen ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich möchte darauf hinweisen, dass unabhängig von der Herangehensweise an die rein mathematische Lösung dieses Problems der Status 518 * 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9 ermittelt werden muss</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zellen in den verbleibenden freien Zeilen. Um dies zu tun, ist es notwendig, jede Position von zuvor eingerichteten Königinnen zu berücksichtigen, und es gibt fast eine Milliarde von ihnen, um die Beschränkungen festzulegen, die jede eingerichtete Königin den freien Positionen in den verbleibenden 518 Linien auferlegt. Ich habe keinen „Drehpunkt“ gefunden, der es mir erlaubt, diese Arbeit nur auf der Grundlage eines rein mathematischen Ansatzes ohne algorithmische Berechnungen durchzuführen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe hier ein minimales Beispiel gegeben, das nur aus zwei Kompositionen besteht. Bei Bedarf kann die Anzahl solcher Zusammensetzungen erhöht werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist anzumerken, dass auf der Grundlage des vorgeschlagenen linearen Algorithmus, der leicht an das Arbeiten mit großen Zusammensetzungen angepasst ist, die Aufgaben der beiden Testzusammensetzungen abgeschlossen werden können, bis eine vollständige Lösung auf </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desktop-13 ausgeführt wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In ca. 4,5 Minuten (ohne Ladezeit der Eingabedaten). </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10. Zugabe </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Handeln von Professoren, die fähige Aufgaben empfehlen, die die Studenten entwickeln und erforschen können, verdient Respekt. </font><font style="vertical-align: inherit;">Dies erfordert einen erheblichen Aufwand, aber bei der Überwindung von Schwierigkeiten sieht der Forscher andere komplexe Aufgabenstellungen anders. </font><font style="vertical-align: inherit;">Ich dachte, es wäre nützlich, die Optionen zum Festlegen des n-Queens-Problems für solche Zwecke zu erweitern. </font><font style="vertical-align: inherit;">Wenn Sie dieselbe Aufgabe aus verschiedenen Perspektiven betrachten, können Sie verschiedene Dinge sehen. </font><font style="vertical-align: inherit;">Nachfolgend einige davon. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Betrachten Sie das Problem, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">Damen</font></i><font style="vertical-align: inherit;"> auf einem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rechteckigen „Schachbrett“ der</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Größe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxm anzuordnen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Bezeichne </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k = m - n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es sei eine Lösung erhalten, und in jedem von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In jeder Reihe befand sich eine Königin. Positionen, an denen sich Königinnen befinden, werden von der weiteren Betrachtung ausgeschlossen. Jetzt gibt es in jeder Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m-1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> freie Position. In den verbleibenden freien Positionen finden wir wieder eine Lösung. Nach wie vor schließen wir die Positionen aus, an denen sich die Königinnen der zweiten Lösung befinden. Jetzt gibt es in jeder Reihe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m-2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> freie Positionen. Offensichtlich kreuzen sich die erste und die zweite Lösung in keiner Zeile - sie sind orthogonal. Es ist erforderlich, die maximale Anzahl von zueinander orthogonalen Lösungen für verschiedene Werte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu bestimmen </font><font style="vertical-align: inherit;">. Wenn </font><font style="vertical-align: inherit;">für den Wert </font><i><font style="vertical-align: inherit;">k = 0 </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zueinander orthogonale Lösungen gefunden werden</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dann wird der Royal Latin Square gebaut. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bemerkung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Das Papier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grigoryan E. (2018)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die für jede Lösung gezeigt , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens Problem</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gibt es eine ergänzende Lösung ist, die nicht mit ihrem interferiert. Dies bedeutet, dass für einen beliebigen Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Menge aller Lösungen des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens-Problems</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in zwei </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gleich große</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teilmengen aufgeteilt wird. Jede Lösung aus der zweiten Teilmenge ist eine Komplementärlösung zur entsprechenden Lösung aus der ersten Teilmenge. Die Regel ist ganz einfach: Wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q1 (i)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Lösung aus der ersten Menge ist, dann ist die entsprechende komplementäre Lösung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q2 (i)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus der zweiten Teilmenge wird durch die Formel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q2 (i) = n + 1 - Q1 (i) bestimmt, wobei i = (1, ..., n)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Diese Regel erklärt die Tatsache, dass die Anzahl aller Lösungen des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens-Problems</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für einen beliebigen Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> immer eine gerade Zahl ist. (Diese Regel erlaubt es uns, die Zeit für die Berechnung aller vollständigen Lösungen für eine beliebige Größe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n des</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schachbretts </font><font style="vertical-align: inherit;">zu halbieren </font><font style="vertical-align: inherit;">. Wenn wir </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesamtzahl aller Lösungen </font><font style="vertical-align: inherit;">mit </font><i><font style="vertical-align: inherit;">2 * k</font></i><font style="vertical-align: inherit;"> bezeichnen </font><font style="vertical-align: inherit;">, dann ist der Wert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gleich dem Index in der sequentiellen Liste aller Lösungen, wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q (k) + Q ( k + 1) = n + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. In der anfänglichen Formulierung des Problems </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Qeens Problem</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nachdem die Königin in Position </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j) gebracht wurde</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden die folgenden Aktionen ausgeführt: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Alle Zellen der Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und der Spalte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden ausgeschlossen, b) Alle Zellen, die sich auf der Linie der linken und rechten Diagonalen befinden, die durch die Zelle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j) verlaufen,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden ausgeschlossen </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir ändern die Bedingung b) in der Erklärung des Problems. Anstatt Zellen zu eliminieren, werden wir die Zellenvermittlung verwenden. Wenn die Zelle in der Linie der linken oder rechten Diagonale frei ist, schließen wir sie, wenn die Zelle geschlossen ist, öffnen wir sie. Dies erleichtert das Finden einer Lösung. Anstelle der quadratischen Matrix </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn betrachten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir jedoch eine rechteckige Matrix der Größe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nx (n - k)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Für einen gegebenen Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist es erforderlich, </font><font style="vertical-align: inherit;">den Maximalwert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k zu finden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bei denen mindestens drei orthogonale Lösungen erhalten werden können. Wie ändert sich der Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit zunehmendem Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Ändern Sie einige Bedingungen in der Anfangsformulierung des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problems</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit dem </font><i><font style="vertical-align: inherit;">n-Queens-Problem</font></i><font style="vertical-align: inherit;"> . Wenn die Dame an Position </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf einem Schachbrett der Größe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn positioniert ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) schließen wir alle Zellen in Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i aus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) wenn der Index </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine gerade Zahl ist, dann: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b1) schließen wir Zellen in geraden Zeilen der Spalte j aus, </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b2) schließen wir Zellen in aus gerade Linien, die die linken und rechten Diagonalen schneiden und durch die Zelle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j) verlaufen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) Wenn Index </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i>  ,   b1)  b2)   ,    . <br><br> 3.1  <i>(Sloane-2016)</i> ,      <i>nQueens Problem</i> ,  <i>n=(8, 9, 10, 11, 12, 13, 14, 15, 16)</i> ,   <i>(92, 352, 724, 2680, 14200, 73712, 365596, 2279184, 14772512)</i> .     ,            b)    c)? <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2 Grigoryan (2018) ist bekannt, dass, wenn wir die Häufigkeit der Beteiligung verschiedener Zellen der Lösungsmatrix an der Bildung einer Liste aller Lösungen bestimmen, harmonische Beziehungen zwischen allen Zellen in Form vertikaler und horizontaler Symmetrien der entsprechenden Frequenzen bestehen. Dies bedeutet, wenn wir annehmen, dass </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k &lt;n / 2 ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ist die Frequenz der Zellen der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k-ten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeile identisch mit der Frequenz der Zellen der Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-k + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In ähnlicher Weise ist die Frequenz der Zellen der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k-ten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spalte identisch mit der Frequenz der Zellen der Spalte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-k + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Frage: "Wie werden sich diese harmonischen Beziehungen im Kontext der Aufgabe verändern?"</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Alle Zellen eines Schachbretts sind durch ihre Farbe in zwei Klassen unterteilt. Es wird angenommen, dass eine Farbe weiß und die andere schwarz ist. Betrachten Sie zwei Schachbretter und legen Sie eines so auf das andere, dass die Kanten vollständig zusammenfallen. Als Ergebnis erhalten wir ein "Sandwich" aus zwei Schachbrettern, in denen die Anordnung der weißen und schwarzen Zellen übereinstimmt. Die Aufgabe besteht darin, auf zwei Tafeln gleichzeitig Lösungen zu finden, wobei folgende Bedingungen zu beachten sind: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Befindet sich die Dame auf einem der Tafeln auf einem schwarzen Feld mit den Indizes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dann: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- auf beiden Tafeln alle schwarzen Felder, die auftreten in Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Spalte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Auf beiden Brettern sind alle schwarzen Zellen ausgeschlossen, die sich entlang der linken und rechten Diagonalen befinden, die durch die Zelle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j) verlaufen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Befindet sich die Dame auf einem der Bretter auf einem weißen Feld mit den Indizes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , werden alle Aktionen von Absatz a) nur für weiße Felder ausgeführt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Stellen Sie sich vor, dass in einer Lösungsmatrix der Größe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeilen mit einem Schritt von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen </font><font style="vertical-align: inherit;">relativ zueinander nach rechts oder links </font><i><font style="vertical-align: inherit;">verschoben</font></i><font style="vertical-align: inherit;"> werden können </font><font style="vertical-align: inherit;">. Wenn darüber hinaus die vorherige Reihe beispielsweise nach links verschoben wurde, sollte die nächste Reihe nach rechts verschoben werden, d.h. Jede nächste Zeile wird in die entgegengesetzte Richtung zur vorherigen Zeile verschoben. Durch diese Konstruktion erhalten wir eine rechteckige Größenmatrix</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nx (n + k)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wobei in jeder Zeile k Zellen vom Zeilenanfang oder vom Zeilenende von der Betrachtung ausgeschlossen werden. Die Aufgabe besteht darin </font><font style="vertical-align: inherit;">, den Maximalwert von </font><i><font style="vertical-align: inherit;">k</font></i><font style="vertical-align: inherit;"> für einen beliebigen Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n zu finden,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für den es mindestens eine Lösung für das </font><i><font style="vertical-align: inherit;">n-Queens-Problem gibt</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Stellen Sie sich eine Variante des Problems vor, bei der der Versatz einer Zeile in Bezug auf eine andere eine Zufallszahl ist, die von </font><i><font style="vertical-align: inherit;">k1</font></i><font style="vertical-align: inherit;"> bis </font><i><font style="vertical-align: inherit;">k2 reicht</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">6. Die </font><b><font style="vertical-align: inherit;">eindimensionale Formulierung des </font></b><b><i><font style="vertical-align: inherit;">nQueens-Problems</font></i></b><font style="vertical-align: inherit;"> . Auf der Halbachse seien </font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;"> Segmente beliebiger Länge von </font><i><font style="vertical-align: inherit;">1 bis n</font></i><font style="vertical-align: inherit;"> angeordnet </font><font style="vertical-align: inherit;">. Teilen Sie jedes Segment durch </font><i><font style="vertical-align: inherit;">n</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i></b><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zellen beliebiger Größe und innerhalb jedes Segments Zellen von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 bis n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wir nennen solche Zellen offen. Es erfordert eine </font><font style="vertical-align: inherit;">enge eine Zelle auf jedes Segment, die folgenden Einschränkungen Berücksichtigung </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Wir können eine offenzellige mit Index wählen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ten Segment , </font><font style="vertical-align: inherit;">wenn: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r) = 0; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (t) = 0; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wobei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r = n + j - i, t = j + i, D1 und D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eindimensionale Steuerfelder sind, die aus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen bestehen, die zuvor auf Null gesetzt wurden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Nach dieser Auswahl werden Segment </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Zellen mit der Nummer </font><i><font style="vertical-align: inherit;">j</font></i><font style="vertical-align: inherit;"> geschlossen</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in allen verbleibenden freien Segmenten. Es ist auch notwendig, die entsprechenden Zellen in den Kontrollfeldern zu schließen: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r) = 1; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (t) = 1; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Einstellung ist die Aufgabe völlig identisch mit der ursprünglichen. Interessant ist die Formulierung dieses Problems mit anderen Randbedingungen. Wenn beispielsweise anstelle der Formeln: </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r = n + j - i, t = j + i,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden andere Verhältnisse berücksichtigt werden, die funktionell verknüpft sind Indizes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Indizes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Matrix zu </font><font style="vertical-align: inherit;">machen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Wortlaut der Aufgabe anhand einer Urne mit Kugeln</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (identisch mit dem vorherigen Wortlaut). Angenommen, es gibt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Urnen mit den Nummern </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 bis n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und in jeder Urne gibt es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kugeln, die ebenfalls von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 bis n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nummeriert sind </font><font style="vertical-align: inherit;">. Erfordert urn von jedem Ball entfernt, die folgenden Einschränkungen Berücksichtigung </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Wir um </font><font style="vertical-align: inherit;">den Ballon mit der Nummer auswählen können </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> th urn , </font><font style="vertical-align: inherit;">wenn: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r) = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (t) = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wobei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r = n + j - i, t = j + i, D1 und D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind eindimensionale Steuerfelder, die aus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen bestehen, die zuvor auf Null gesetzt wurden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Nach dieser Auswahl werden die Wahlurne </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die Bälle mit der Nummer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in allen verbleibenden freien Wahlurnen </font><font style="vertical-align: inherit;">geschlossen </font><font style="vertical-align: inherit;">. Es ist auch notwendig, die entsprechenden Zellen in den Kontrollfeldern zu schließen:</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r) = 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (t) = 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Einstellung ist die Aufgabe völlig identisch mit der ursprünglichen. Wie im vorherigen Fall ist die Erklärung dieses Problems mit anderen Bedingungen von Interesse, die die Indizes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funktional </font><font style="vertical-align: inherit;">mit den Indizes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Entscheidungsmatrix verbinden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Spiel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Betrachten Sie ein Schachbrett der Größe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Lassen Sie uns die Farbe zu den Königinnen zurückbringen, lassen Sie einige Königinnen weiße Farbe haben, andere schwarz. Wir geben auch die abwechselnde weiße und schwarze Farbe an die Zellen des Schachbretts zurück, basierend auf der Tatsache, dass die Zelle mit dem Index </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1, n)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte weiß sein. Alle Zellen zu Beginn des Spiels gelten als frei. Weiße Königinnen machen den ersten Schritt. Der Spieler platziert die Dame in eine beliebige freie Zelle mit Indizes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Lass es eine weiße Zelle sein. Infolge dieser Auswahl werden sie geschlossen: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) alle weißen Zellen der Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) alle weißen Zellen der Spalte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) alle weißen Zellen, die auf der linken und rechten Diagonale liegen und durch die Zelle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j) verlaufen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn </font><font style="vertical-align: inherit;">sich herausstellt, dass </font><font style="vertical-align: inherit;">die Zelle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schwarz ist, sind alle Punkte </font><i><font style="vertical-align: inherit;">(a, b, c)</font></i><font style="vertical-align: inherit;"> erfüllt</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dementsprechend sind alle schwarzen Zellen geschlossen. Als nächstes führt Schwarz den Zug aus und platziert die Dame in eine der verbleibenden freien Zellen. Danach schließen sich die Zellen auf ähnliche Weise wie oben beschrieben. Der Zeitpunkt, an dem über den nächsten Schritt nachgedacht werden soll, ist festgelegt und wird von den Parteien vereinbart. Wenn einer der Spieler während der angegebenen Zeit seinen Zug nicht beendet, wird das Spiel auf den anderen übertragen. Das Spiel endet, wenn beide Spieler nacheinander nicht in der angegebenen Zeit an der Reihe sind. Derjenige, der mehr Königinnen auf dem Brett platzieren kann, gewinnt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9. Auf die Stabilität der zufälligen Auswahl. Betrachten Sie das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Modell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Als Ergebnis des Vergleichs von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zufälligen Paaren von Zeilen- und Spaltenindizes ist es in der ersten Stufe des Zyklus möglich, die Königinnen im Durchschnitt bei festzulegen</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k * n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeilen. Der Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann als konstanter Wert von 0,6 betrachtet werden. Sein Wert variiert von 0,605701 bei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 10</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und bis 0,599777 bei n = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und mit zunehmendem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nimmt die Varianz dieses Wertes ab. Was ist der Grund für eine solche "Beständigkeit"? Warum ist es mit einer zufälligen Auswahl des Zeilenindex und des Positionsindex der Dame in dieser Zeile auf der Grundlage von zwei Listen von Zahlen, die auf der Grundlage einer zufälligen Permutation von Zahlen von 1 bis n erhalten wurden, möglich, die Damen (im Durchschnitt) auf 60% der Zeilen konsistent zu platzieren? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. Die Größe des Schachbretts sei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Basierend auf dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Verfahren</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lege die Königinnen auf das Schachbrett, bis der Suchzweig eine Sackgasse erreicht. Bezeichnen Sie die Länge der so erhaltenen Zusammensetzung mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn für einen gegebenen Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diese Prozedur viele Male wiederholt wird und ein Histogramm der Verteilung der Werte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k erstellt wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , zeigt sich, dass sich die Änderung der Häufigkeit des Auftretens von Ereignissen von der Änderung der Häufigkeit des Auftretens von Ereignissen nach diesem Wert unterscheidet. Wenn das Histogramm auf der Grundlage des Modalwerts in zwei Teile unterteilt ist, stimmt der linke Teil nicht mit dem rechten Teil überein. Dieses Muster ist charakteristisch für jeden Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Warum nimmt die Häufigkeit des Eintretens von Ereignissen nach dem Übergang der Länge der Komposition über den Modalwert eine andere Form an? Unter einem Ereignis verstehen wir das Erhalten einer Komposition einer bestimmten Größe, bevor ein Zustand der Sackgasse erreicht wird.</font></font><br><br><h4>  Literatur </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Nauck, F. (1850). </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Briefwechsel mit allen fur alle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Illustrierte Zeitung, 15, 182. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. </font></font><a href="https://jair.org/index.php/jair/article/view/11079/26262"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gent, IP, Jefferson, C. &amp; Nightingale, P. (2017). </font></font></a> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komplexität der Fertigstellung von n-Queens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Journal of Artificial Intelligence Research., 59, 815-848. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Sosic, R. &amp; Gu, J. (1990). </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein polynomieller Zeitalgorithmus für das n-Königinnen-Problem</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . SIGART Bulletin, 1 (3), 7–11. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. </font></font><a href="https://www.cl.cam.ac.uk/~mr10/backtrk.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richards, M. (1997). </font></font></a> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Backtracking-Algorithmen in MCPL unter Verwendung von Bitmustern und Rekursion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tech. rep., Computerlabor, Universität Cambridge. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Randomisierungsmethoden im Algorithmusdesign</font></font></i> , Proceedings of a DIMACS Workshop, Princeton, New Jersey, USA, December 12-14, 1997. DIMACS Series in Discrete Mathematics and Theoretical Computer Science 43, DIMACS/AMS 1999, ISBN 978-0-8218-0916-7 <br><br> 6. <a href="http://ejournal11.com/journals_n/1537458681.pdf">Grigoryan E. (2018).</a> <i>Investigation of the Regularities in the Formation of Solutions n-Queens Problem</i> . Modeling of Artificial Intelligence, 5(1), 3-21 <br><br> 7. <a href="http://oeis.org/A000170,%25202016">Sloane N.-JA (2016).</a> The on-line encyclopedia of integer sequences. <br><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483036/">https://habr.com/ru/post/de483036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483018/index.html">Maske-R CNN vom Anfänger bis zum Profi</a></li>
<li><a href="../de483024/index.html">„Was haben Unternehmen mit Ihrer Privatsphäre gemacht?“, Arthur Khachuyan</a></li>
<li><a href="../de483026/index.html">Java / Spring: So generieren Sie mit Speedment eine CRUD REST-API vollständig</a></li>
<li><a href="../de483030/index.html">API, die Sie zum Weinen bringt</a></li>
<li><a href="../de483032/index.html">Umzug aus der GUS in die Tschechische Republik, eigene Erfahrung (Teil 2)</a></li>
<li><a href="../de483038/index.html">Die Spielwelt kompetent neu starten</a></li>
<li><a href="../de483040/index.html">Magic Schraubendreher für Fernost Montage Excel 97</a></li>
<li><a href="../de483042/index.html">9 Tipps zur Vue-Leistung</a></li>
<li><a href="../de483048/index.html">Terminal Fun: 10 klassische Konsolenwitze</a></li>
<li><a href="../de483050/index.html">Top 5 ReactJS Entwicklungsunternehmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>