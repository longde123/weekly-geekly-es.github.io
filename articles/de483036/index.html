<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèø üé¶ üåµ n-Queens Completion Problem - linearer L√∂sungsalgorithmus üë©üèø‚Äç‚öïÔ∏è ‚Ü©Ô∏è üö≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ericgrig 



 Vorwort 
 Ich m√∂chte das Vorwort mit Dankesworten an zwei wundervolle Programmierer aus Odessa beginnen: Andrei Kiper (Lohica) und Timur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>n-Queens Completion Problem - linearer L√∂sungsalgorithmus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483036/">  Ericgrig <br><p><br></p><h4>  Vorwort </h4><br>  Ich m√∂chte das Vorwort mit Dankesworten an zwei wundervolle Programmierer aus Odessa beginnen: Andrei Kiper (Lohica) und Timur Giorgadze (Luxoft), um meine Ergebnisse in der Anfangsphase der Studie unabh√§ngig zu verifizieren. <br><br><ol><li>  Der Artikel "Linearer Algorithmus zur L√∂sung des n-Queens-Abschlussproblems" wurde zu Beginn des ersten Tages des Jahres 2020 in <a href="https://arxiv.org/pdf/1912.05935.pdf">(arXiv.org)</a> ver√∂ffentlicht.  Urspr√ºnglich war der Artikel in russischer Sprache verfasst, daher wird hier die grundlegende Pr√§sentation vorgestellt und dort die √úbersetzung. </li><li>  Diese Aufgabe und einige andere der vielen NP-Kompletts√§tze (die Aufgabe, Boolesche Formeln (3-SAT) zu erf√ºllen, die Aufgabe, die maximale Clique oder eine Clique einer bestimmten Gr√∂√üe zu finden ...) zu unterschiedlichen Zeiten waren in meinem Interesse.  Ich suchte nach einer algorithmischen L√∂sung, die auf verschiedenen Computerexperimenten basierte, aber es gab keinen konkreten Erfolg.  Es war wie ein Mensch, der zu lernen versuchte, wie man an einem Arm auf der horizontalen Stange fit wird.  Es gibt kein Ergebnis, aber jedes Mal gibt es die Hoffnung, dass alles bald klappt.  Das letzte Mal, als ich mich entschied, l√§nger bei der n-Queens-Abschlussaufgabe zu bleiben (als eines der Familienmitglieder) und zu versuchen, etwas zu tun.  Es ist angebracht, sich an den wunderbaren Odessa-Witz zu erinnern: "In einem √ºberf√ºllten Bus, der abends auf einer holprigen Stra√üe in die Vororte zur√ºckkehrt, ist eine Frauenstimme zu h√∂ren - Mann, wenn Sie mich v√∂llig √ºberfallen haben, dann tun Sie wenigstens etwas." </li><li>  Das Studium dauerte lange genug - fast eineinhalb Jahre.  Dies liegt zum einen daran, dass andere Aufgaben im Forschungsprozess ber√ºcksichtigt wurden, zum anderen gab es auf dem Weg schwierige Fragen, ohne die wir nicht weiterkommen k√∂nnten.  Ich werde einige von ihnen auflisten: <br><br><ul><li>  Es gibt n Zeilen in der Entscheidungsmatrix. In welcher Reihenfolge sollte der Zeilenindex ausgew√§hlt werden, wenn die Anzahl der M√∂glichkeiten f√ºr eine solche Auswahl n betr√§gt! </li><li>  Wenn eine Reihe erstellt wird, sollte die verbleibende freie Position in dieser Reihe ausgew√§hlt werden, da die Anzahl der M√∂glichkeiten f√ºr eine solche Auswahl so gro√ü ist, dass sie als ‚Äûenger Verwandter‚Äú der Unendlichkeit angesehen werden kann (z. B. die Anzahl der M√∂glichkeiten, eine freie Position in allen Reihen f√ºr ein Schachbrett der Gr√∂√üe 100 auszuw√§hlen x 100 ist ungef√§hr 10 <sup>124</sup> ) </li><li>  Zusammen bilden diese beiden Indikatoren einen Zustandsraum (einen Auswahlraum).  Es sieht so aus, als g√§be es riesige M√∂glichkeiten, Sie k√∂nnen w√§hlen, was Sie wollen.  Hinter jeder spezifischen Auswahl bei jedem Schritt steht jedoch ein anderes Problem - die Einschr√§nkung der Auswahl in allen nachfolgenden Schritten.  Dar√ºber hinaus ist dies in den letzten Phasen der Probleml√∂sung besonders heikel.  Wir k√∂nnen sagen, dass die Entscheidungsmatrix "rachs√ºchtig" ist.  Alle ‚Äûunbewussten Fehler‚Äú, die Sie bei der Auswahl in den vorherigen Phasen gemacht haben, werden ‚Äûakkumuliert‚Äú. Am Ende der Entscheidung zeigt sich dies in der Tatsache, dass in den Zeilen, in denen Sie die K√∂nigin platzieren sollten, keine leeren Positionen mehr vorhanden sind und der Suchzweig zum Stillstand kommt .  Hier, wie bei Zhvanetsky: "Ein falscher Zug, und Sie sind schwanger." </li><li>  Wenn der Zweig der Suche nach einer L√∂sung zum Stillstand kommt, haben wir die M√∂glichkeit, zu einigen der vorherigen Positionen zur√ºckzukehren (Back Tracking), so dass wir von dieser Position aus wieder mit der Bildung des Zweigs der Suche nach einer L√∂sung beginnen.  Dies ist eine nat√ºrliche ‚ÄûEigenschaft‚Äú nicht deterministischer Probleme.  Die Frage ist, welche der vorherigen Ebenen zur√ºckgegeben werden sollen.  Dies ist das gleiche offene Problem wie die Frage der Auswahl des Zeilenindex oder der Auswahl einer freien Position in dieser Zeile. </li><li>  Schlie√ülich sollte ein Problem in Bezug auf die Geschwindigkeit des Algorithmus festgestellt werden.  Es w√§re traurig, wenn es kein Ziel g√§be, schnell laufende Algorithmen zu entwickeln.  Bei der Modellierung war es nicht m√∂glich, einen Algorithmus zu entwickeln, der in allen Bereichen der Probleml√∂sung schnell und effizient funktioniert.  Ich musste drei Algorithmen entwickeln.  Sie √ºbertragen die Ergebnisse wie ein Schlagstock aufeinander.  Einer von ihnen arbeitet sehr schnell, aber unh√∂flich, der andere - im Gegenteil, arbeitet langsam, aber effizient.  Jeder von ihnen arbeitet in der ‚ÄûZone ihrer Verantwortung‚Äú. </li></ul></li><li>  Der Zweck der Studie bestand zun√§chst nur darin, zumindest eine L√∂sung zu finden.  Ich musste viel herausfinden, bevor die erste L√∂sung entwickelt wurde.  Es dauerte mehr als vier Monate.  Es war m√∂glich dort anzuhalten, das Ziel wurde erreicht - na ja, okay.  Es schien mir jedoch, dass nicht alle M√∂glichkeiten einer algorithmischen L√∂sung dieses Problems ausgesch√∂pft waren.  Nat√ºrlich bestand der Wunsch, den entwickelten Algorithmus so zu verbessern, dass die zeitliche Komplexit√§t des Algorithmus linear-O (n) war.  Als eine solche lineare L√∂sung gefunden wurde, gab es "einen weiteren Wunsch" - die Anzahl der F√§lle zu reduzieren, in denen das Back Tracking (BT) -Verfahren bei der Bildung des L√∂sungssuchzweigs verwendet wurde.  Es war ein "unversch√§mter" Wunsch, die Aufgabe von nicht deterministisch auf bedingt determiniert (so weit wie m√∂glich) zu √ºbertragen.  Es hat lange gedauert, aber das Ziel wurde beispielsweise im Bereich der Schachbrettgr√∂√üenwerte n = (320, ..., 22500) erreicht, die Anzahl der F√§lle, in denen das BT-Verfahren nie angewendet wird, betr√§gt mehr als 50%.  Es stellt sich heraus, dass in 50% der F√§lle, in denen das Programm gestartet wird, der Algorithmus ‚Äûabsichtlich‚Äú eine L√∂sung bildet und niemals ‚Äûstolpert‚Äú.  (Ich erinnere mich an das M√§rchen √ºber den Goldfisch und dachte √ºber diese beiden W√ºnsche nach ...) </li><li>  Beim Vergleich der Ver√∂ffentlichungen, die ich w√§hrend der Recherche kennenlernen durfte, kam ich zu dem Ergebnis, dass dieses Problem und andere Probleme dieser Art nicht auf der Grundlage eines rigorosen mathematischen Ansatzes gel√∂st werden k√∂nnen, d. H. Nur auf der Grundlage von Definitionen, Lemmas√§tzen und Theorems√§tzen.  In dem Artikel gibt es eine "philosophische Bemerkung" dazu.  Ich bin mir sicher, dass viele Probleme aus den vielen NP-Complete nur auf der Basis algorithmischer Mathematik mit Hilfe von Computersimulationen gel√∂st werden k√∂nnen.  Eine solche Schlussfolgerung bedeutet nicht, die Mathematik einzuschr√§nken, sondern vielmehr, die F√§higkeiten der Mathematik durch die Entwicklung algorithmischer mathematischer Methoden zu erweitern.  F√ºr jede Familie von Problemen m√ºssen Sie Ihren eigenen angemessenen mathematischen Ansatz verwenden.  (Warum sollte man einen Doktoranden beauftragen, ein Problem aus der NP-Complete-Familie zu l√∂sen, ohne algorithmische Mathematik und Computermodellierungsmethoden anzuwenden, wenn bekannt ist, dass aus einem solchen Unterfangen eigentlich nichts wird?) </li><li>  Jeder Algorithmus (Programm) hat eine einfache Eigenschaft - entweder funktioniert er oder nicht!  Ich m√∂chte die Mitglieder unserer Habro-Community ansprechen, die einen Computer mit Matlab in der Barrierefreiheit installiert haben.  Ich m√∂chte Sie bitten, die Funktionsweise des in Betracht gezogenen Algorithmus zur L√∂sung des <i>n-Queens-Abschlussproblems</i> zu testen.  Dies dauert nur 5-10 Minuten.  Um den Algorithmus zu testen, m√ºssen Sie einige einfache Schritte ausf√ºhren: <br><br><ul><li>  Generiere eine zuf√§llige Komposition aus <i>k</i> K√∂niginnen und √ºberpr√ºfe die Korrektheit dieser Komposition. </li><li>  Vervollst√§ndigen Sie diese Zusammensetzung auf der Grundlage des vorgeschlagenen Entscheidungsalgorithmus zu einer vollst√§ndigen L√∂sung.  Oder das Programm muss entscheiden, dass diese Zusammensetzung keine L√∂sung hat. </li><li>  √úberpr√ºfen Sie die Richtigkeit der durch die Konfiguration erhaltenen L√∂sung. </li></ul><br><br>  Sie m√ºssen f√ºr solche Tests keinen Code schreiben.  Zus√§tzlich zum Hauptprogramm habe ich zwei weitere Programme in der Matlab-Sprache vorbereitet: <br><br>  1. <i>Generarion_k_Queens_Composition</i> - Erzeugung einer zuf√§lligen Komposition der Gr√∂√üe <i>k</i> f√ºr ein beliebiges Schachbrett der Gr√∂√üe <i>nxn</i> <br><br>  2. <i>Completion_k_Queens_Composition.m</i> - Vervollst√§ndigen einer beliebigen Komposition bis zu einer vollst√§ndigen Entscheidung oder Entscheiden, dass diese Komposition keine L√∂sung hat ( <b>Hauptprogramm</b> ). <br><br>  3. <i>Validation_n_Queens_Solution.m</i> - √úberpr√ºfung der Richtigkeit der L√∂sung des <i>n-Queens-Problems</i> oder der Richtigkeit der Zusammensetzung von <i>k</i> K√∂niginnen. <br><br>  Sie arbeiten sehr schnell.  Zum Beispiel f√ºr ein Schachbrett mit einer Gr√∂√üe von <i>1000 x 1000</i> Zellen, die Gesamtzeit, die durchschnittlich ben√∂tigt wird, um eine beliebige Zusammensetzung zu erzeugen (0,0015 s), diese Zusammensetzung zu vervollst√§ndigen (0,0622 s) und die Richtigkeit der erhaltenen L√∂sung zu √ºberpr√ºfen (0,0003 s). 0,1 Sekunden nicht √ºberschreitet.  (Ausgenommen die Zeit, die zum Herunterladen der Daten oder Speichern der Ergebnisse ben√∂tigt wird.) <br><br>  Schicken Sie mir eine E-Mail (ericgrig@gmail.com), wenn Sie die M√∂glichkeit haben, einem Freund zu helfen, sende ich Ihnen diese drei Programme umgehend zu.  Ich bin allen Kollegen dankbar, die den Algorithmus objektiv testen und ihre Meinung in der Diskussion √§u√üern k√∂nnen. </li><li>  Ich habe den Quellcode des Programms mit detaillierten Kommentaren erstellt, die hoffentlich bald auf Habr√© ver√∂ffentlicht werden.  Ich denke, dass diejenigen, die an der L√∂sung komplexer Probleme aus der <i>NP-Complete-</i> Familie interessiert sind, etwas Interessantes f√ºr sich finden. </li><li>  Ich m√∂chte noch einmal an die Mitglieder der Habr-Gemeinschaft appellieren, aber aus einem anderen Grund.  Hier in Marseille (Frankreich) wird das Team der <i>France Fold Group gebildet</i> , mit dem Algorithmen zur Vorhersage der physikochemischen Eigenschaften von Verbindungen mit hohem Molekulargewicht erforscht und entwickelt werden sollen.  Ich denke, es ist nicht wert zu sagen, dass dies eine ziemlich schwierige Aufgabe mit einer langen Geschichte ist und dass ernsthafte Teams in verschiedenen L√§ndern an diesem Problem arbeiten, einschlie√ülich des <i>Khasabis-</i> Teams von <i>Deep Mind</i> (Sie k√∂nnen den Artikel auf Habr√© <a href="https://habr.com/ru/post/431948/">(habr.com_Folding) sehen)</a> . Ziel ist es, ein starkes Team zu bilden, das keine Angst vor der L√∂sung komplexer Probleme hat. Die Form der Organisation der gemeinsamen Arbeit ist verteilt. Jedes Teammitglied lebt in seiner Stadt und arbeitet in seiner Freizeit an dem Projekt. Wir brauchen Programmierer und Forscher (Physiker, Chemiker, Mathematiker, Biologen). ) usw.  osto "r√ºcksichtslose" Programmierer- (squared). Schreiben Sie mir, wenn Sie es interessant finden, die oben ist meine E-Mail. Ausf√ºhrlicher kann ich im Antwortschreiben erz√§hlen. </li></ol><br>  Das Vorwort zum Artikel war genauso lang wie der Artikel.  Das Format der Familienpr√§sentation auf Habr√© erm√∂glicht es mir, meine Gedanken freier auszudr√ºcken, aber gemessen an der Gr√∂√üe habe ich es ziemlich frei ausgenutzt.  Ich wollte kurz schreiben, aber "es stellte sich heraus wie immer." <br><br>  PS Ich dachte, dass die Mitglieder der Habr-Community interessiert w√§ren, auf welche Schwierigkeiten ich stie√ü, wenn ich die Ergebnisse der Studie ver√∂ffentlichen wollte.  Als der Artikel erstellt wurde, habe ich ihn gem√§√ü den Anforderungen des Journal of Artificial Intelligence Research (JAIR) in das .tex-Format umformatiert und dorthin gesendet.  Fr√ºher gab es Ver√∂ffentlichungen zu einem √§hnlichen Thema.  Besonders hervorzuheben ist der Artikel <i>C. Gent, I.-P.</i>  <i>Jefferson und P. Nightingale (2017)</i> <a href="https://jair.org/index.php/jair/article/view/11079/26262">(Komplexit√§t der Fertigstellung von n-K√∂niginnen)</a> , in denen die Autoren bewiesen haben, dass das betreffende Problem zum NP-Complete-Set geh√∂rt, und √ºber die Schwierigkeiten bei der L√∂sung dieses Problems sprachen.  In den Schlussfolgerungen schreiben die Autoren: ‚ÄûF√ºr jeden, der die Regeln des Schachs versteht, kann die n-Queens-Vervollst√§ndigung eines der nat√ºrlichsten NP-Complete-Probleme von allen sein.‚Äú ( <i>F√ºr jeden, der die Regeln des Schachs versteht, kann die n-Queens-Vervollst√§ndigungsaufgabe eine von ihnen werden die nat√ºrlichsten NP-Complete Aufgaben</i> ). <br><br>  Nach 10 Tagen erhielt ich eine Absage von JAIR mit dem Wortlaut: "Der Artikel entspricht nicht dem Format der Zeitschrift."  Ich habe den Artikel nicht einmal in Betracht gezogen.  Mit einer solchen Antwort habe ich nicht gerechnet.  Ich dachte, wenn eine Zeitschrift Artikel ver√∂ffentlicht, in denen die Autoren zu dem Schluss kommen, dass es sehr schwierig ist, ein bestimmtes Problem zu l√∂sen, und keine konkrete L√∂sung liefert, wird der Artikel, der einen effektiven L√∂sungsalgorithmus liefert, mit Sicherheit zur Pr√ºfung angenommen.  Die Redaktion hatte jedoch eine eigene Meinung zu diesem Thema.  (Ich glaube, dass dort kompetente Spezialisten arbeiten, und h√∂chstwahrscheinlich wurden sie durch den ‚Äûunversch√§mten‚Äú Titel des Artikels und alles, was dort steht, in Frage gestellt. Wir dachten, ‚Äûes liegt h√∂chstwahrscheinlich ein Fehler vor und schickten mich vorsichtig weg, bezogen auf das Format "). <br><br>  Ich musste mich f√ºr eine andere von Experten begutachtete periodische wissenschaftliche Ver√∂ffentlichung zu relevanten Themen entscheiden.  Hier bin ich mit der harten Realit√§t konfrontiert.  Fakt ist, dass ungef√§hr 80% aller Zeitschriften bezahlt werden: Entweder muss ich einen anst√§ndigen Betrag an die Zeitschrift zahlen, damit der Artikel f√ºr alle Leser frei verf√ºgbar ist, oder sie m√ºssen den Artikel als Geschenk "in the bow" geben und sie werden jeden in Rechnung stellen, der m√∂chte diese Studie kennenlernen.  Und die erste und die zweite Option sind f√ºr mich grunds√§tzlich inakzeptabel.  Ich f√ºhlte mich gut mit dieser Art des Verlagsschl√§gers, als ich versuchte, mich mit einigen Ver√∂ffentlichungen vertraut zu machen. <br><br>  Die n√§chste Zeitschrift, die sich zum Prinzip des freien Zugangs zu Informationen bekennt, war <i>das SMAI Journal of Computational Mathematics</i> .  Sie weigerten sich auch mit dem gleichen Wortlaut, wenn auch viel schneller - in zwei Tagen. <br><br>  Dann wurde eine Zeitschrift ausgew√§hlt: <i>Diskrete Mathematik und Theoretische Informatik</i> .  Hier sind die Anforderungen einfach: Zuerst m√ºssen Sie den Artikel in arXiv.org ver√∂ffentlichen und erst danach m√ºssen Sie den Artikel zur Pr√ºfung registrieren.  Okay, wir werden die Regeln befolgen - ich habe einen Artikel in <i>arXiv.org</i> eingereicht.  Sie schrieben mir, dass sie den Artikel in 8 Stunden ver√∂ffentlichen w√ºrden.  Dies geschah jedoch nicht nach 8 Stunden, nicht nach 8 Tagen.  Der Artikel wurde von den Mentoren ‚Äûfestgehalten‚Äú und erst nach 9 Tagen ver√∂ffentlicht.  Es gab keine Beschwerden in Form und Inhalt des Artikels.  Ich denke, wie im Fall von JAIR hatten Mentoren Zweifel an der M√∂glichkeit, "dies zu tun und dar√ºber zu schreiben".  Einige Zeit sp√§ter wurde der Artikel nach Korrektur technischer Fehler aktualisiert und in seiner endg√ºltigen Form in der Neujahrsnacht ver√∂ffentlicht. <br><br>  Ich muss im Detail darauf eingehen, um zu zeigen, dass es zum Zeitpunkt der Ver√∂ffentlichung der Forschungsergebnisse Probleme geben kann, die sich nicht logisch erkl√§ren lassen. <br><br>  Das Folgende ist ein Artikel, dessen √úbersetzung ins Englische unter <a href="https://arxiv.org/pdf/1912.05935.pdf">(arXiv.org) ver√∂ffentlicht wurde</a> . <br><br><h3>  1. Einleitung </h3><br>  Unter den verschiedenen M√∂glichkeiten, das <i>n-Queens-Problem</i> zu formulieren, nimmt <i>die</i> betreffende <i>n-Queens-Completion-</i> Aufgabe aufgrund ihrer Komplexit√§t eine Sonderstellung ein.  In ihrer Arbeit <a href="https://jair.org/index.php/jair/article/view/11079/26262">(Gent at all (2017))</a> zeigte sich, dass das <i>n-Queens Completion-Problem</i> zur Menge <i>NP-Complete geh√∂rt</i> ( <i>zeigte, dass n-Queens Completion sowohl NP-Complete als auch # P-Complete ist</i> ).  Es wird davon ausgegangen, dass die L√∂sung dieses Problems uns den Weg zur L√∂sung einiger anderer Probleme aus dem Satz von <i>NP-Complete ebnen kann</i> . <br><br>  Das Problem wird wie folgt formuliert.  Es gibt eine Komposition von <i>k</i> K√∂niginnen, die gleichm√§√üig auf einem Schachbrett der Gr√∂√üe <i>nxn verteilt sind</i> .  Es muss nachgewiesen werden, dass diese Zusammensetzung zu einer vollst√§ndigen L√∂sung vervollst√§ndigt werden kann, und es muss mindestens eine L√∂sung angegeben werden, oder es muss nachgewiesen werden, dass eine solche L√∂sung nicht existiert.  Mit Konsistenz ist hier eine Zusammensetzung von <i>k</i> K√∂niginnen gemeint, f√ºr die drei Bedingungen des Problems erf√ºllt sind: In jeder Reihe, jeder Spalte und auch auf der linken und rechten Diagonale, die durch die Zelle gehen, in der sich die K√∂nigin befindet, befindet sich nicht mehr als eine K√∂nigin.  Das Problem in dieser Form wurde erstmals von <i>Nauk (1850)</i> formuliert. <br><br>  <b>1.1 Definitionen</b> <br><br>  Im Folgenden werden wir die Gr√∂√üe der Seite des Schachbretts mit dem Symbol <i>n bezeichnen</i> .  Eine L√∂sung wird als vollst√§ndig bezeichnet, wenn alle <i>n</i> K√∂niginnen konsistent auf einem Schachbrett platziert sind.  Bei allen anderen L√∂sungen wird die Komposition aufgerufen, wenn die Anzahl <i>k der</i> korrekt platzierten K√∂niginnen kleiner als <i>n ist</i> .  Wir bezeichnen eine Zusammensetzung von <i>k</i> K√∂niginnen als positiv, wenn sie vor einer vollst√§ndigen L√∂sung abgeschlossen werden kann.  Dementsprechend wird eine Zusammensetzung, die erst mit einer vollst√§ndigen L√∂sung abgeschlossen werden kann, als negativ bezeichnet.  Als Analogie zu einem "Schachbrett" der Gr√∂√üe <i>nxn betrachten</i> wir auch eine "L√∂sungsmatrix" der Gr√∂√üe <i>nxn</i> .  Als Beispiel werden alle zur L√∂sung des Problems entwickelten Algorithmen in der Matlab-Sprache dargestellt. <br><br>  Die Studie wurde auf der Basis einer Computersimulation (Computersimulation) durchgef√ºhrt.  Um diese oder jene Hypothese zu testen, f√ºhrten wir Rechnerexperimente in einem weiten Bereich von Werten <i>n</i> = (10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 500, 800, 1000, 3000, 5000, 10000, 30 000, 50 000, 80 000, 10 <sup>5</sup> , 3 ¬∑ 10 <sup>5</sup> , 5 ¬∑ 10 <sup>5</sup> , 10 <sup>6</sup> , 3 ¬∑ 10 <sup>6</sup> , 5 ¬∑ 10 <sup>6</sup> , 10 <sup>7</sup> , 3 ¬∑ 10 <sup>7</sup> , 5 ¬∑ 10 <sup>7</sup> , 8 * 10 <sup>7</sup> , 10 <sup>8</sup> ) und in Abh√§ngigkeit von dem Wert von <i>n</i> wurden ausreichend gro√üe Proben zur Analyse erzeugt.  Wir bezeichnen eine solche Liste als " <i>Basisliste von n Werten</i> " f√ºr die Durchf√ºhrung von Computerexperimenten.  Alle Berechnungen wurden auf einem normalen Computer durchgef√ºhrt.  Zum Zeitpunkt der Montage (Anfang 2013) war die Konfiguration recht erfolgreich: <i>CPU - Intel Core i7-3820, 3,60 GH, RAM-32,0 GB, GPU-NVIDIA GeForse GTX 550 Ti, Festplattenger√§t - ATA Intel SSD, SCSI, OS- 64-Bit-Betriebssystem Windows 7 Professional</i> .  Wir nennen dieses Kit einfach - <i>Desktop-13</i> . <br><br><h3>  2. Datenaufbereitung </h3><br>  Der Algorithmus beginnt mit dem Lesen einer Datei, die ein eindimensionales Array von Daten zur Verteilung einer beliebigen Zusammensetzung von <i>k</i> K√∂niginnen enth√§lt.  Es wird davon ausgegangen, dass die Daten auf folgende Weise aufbereitet werden.  Es gebe ein Array mit Nullen <i>Q (i) = 0, i = (1, ..., n)</i> , wobei die Indizes der Zellen dieses Arrays den Zeilenindizes der L√∂sungsmatrix entsprechen.  Befindet sich in einer beliebigen Zeile <i>i</i> der L√∂sungsmatrix eine Dame in Position <i>j</i> , so wird die Zuordnung <i>Q (i) = j</i> durchgef√ºhrt.  Somit ist die Zusammensetzungsgr√∂√üe <i>k</i> gleich der Anzahl von Nicht-Null-Zellen des Arrays <i>Q.</i>  (Zum Beispiel bedeutet <i>Q = (0, 0, 5, 0, 4, 0, 0, 3, 0, 0)</i> , dass wir eine Zusammensetzung von <i>k = 3</i> K√∂niginnen auf der Matrix <i>n = 10 betrachten</i> , wobei sich die K√∂niginnen in der 3. befinden. 5. und 8. Zeile in den Positionen: 5, 4, 3). <br><br><h3>  3. Algorithmus zur √úberpr√ºfung der Richtigkeit des n-Queens-L√∂sungsproblems </h3><br>  F√ºr die Forschung brauchen wir einen Algorithmus, mit dem wir in kurzer Zeit die Richtigkeit der L√∂sung des <i>n-Queens-Problems</i> bestimmen k√∂nnen.  Die Position der K√∂niginnen in jeder Reihe und jeder Spalte ist einfach zu steuern.  Die Frage betrifft diagonale Grenzen.  Wir k√∂nnten einen effektiven Algorithmus f√ºr eine solche Abrechnung entwickeln, wenn wir jede Zelle der L√∂sungsmatrix einer bestimmten Zelle eines bestimmten Kontrollvektors zuordnen k√∂nnten, der den Einfluss diagonaler Beschr√§nkungen auf die betreffende Zelle eindeutig charakterisieren w√ºrde.  Dann kann basierend darauf, ob die Zelle des Steuervektors frei oder besetzt ist, beurteilt werden, ob die entsprechende Zelle der Entscheidungsmatrix frei oder geschlossen ist.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine solche Idee wurde zuerst von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sosic &amp; Gu (1990) verwendet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die Anzahl der Konfliktsituationen zwischen verschiedenen Positionen von K√∂niginnen zu ber√ºcksichtigen und zu akkumulieren. Wir verwenden eine √§hnliche Idee in dem unten dargestellten Algorithmus, jedoch nur, um zu ber√ºcksichtigen, ob die Zelle der L√∂sungsmatrix frei oder belegt ist. Abbildung 1 zeigt als Beispiel ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 x 8-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schachbrett, </font><font style="vertical-align: inherit;">√ºber dem sich eine Folge von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen </font><font style="vertical-align: inherit;">befindet </font><font style="vertical-align: inherit;">.</font></font><br><br><img src="https://habrastorage.org/webt/sx/0f/ws/sx0fwsydzdsy954rtlqpdwwigqg.png"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Ein Demo-Beispiel f√ºr die Entsprechung der diagonalen Projektionen der Matrixzellen zu den entsprechenden Zellen der Kontrollfelder </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 8) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrachten Sie die ersten 15 Zellen als Elemente des Kontrollvektors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die Projektionen aller linken Diagonalen von irgendeiner Zelle der L√∂sungsmatrix fallen in eine der Zellen des Kontrollvektors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tats√§chlich befinden sich alle derartigen Vorspr√ºnge innerhalb von zwei parallelen Liniensegmenten, von denen eines die Matrixzelle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(8.1)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit der ersten Zelle des Vektors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und das zweite </font><font style="vertical-align: inherit;">die Matrixzelle </font><font style="vertical-align: inherit;">(1.8) mit der 15. Zelle des Steuervektors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 verbindet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir geben eine √§hnliche Definition f√ºr die rechten diagonalen Projektionen. Verschieben Sie dazu die Referenz von Zelle 1 nach Zelle 9 nach rechts und betrachten Sie die Folge von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen als Elemente des Kontrollvektors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (in der Abbildung sind dies Zellen vom 9. bis zum 24.) Projektionen aller rechten Diagonalen von einer beliebigen Zelle der Matrix Die L√∂sungen fallen in eine der Zellen dieses Kontrollvektors, beginnend von der 2. bis zur 16. Zelle (in der Abbildung vom 10. bis zum 24.). Hierbei liegen alle derartigen Vorspr√ºnge zwischen zwei parallelen Liniensegmenten - dem Segment, das die Zelle (8, 8) der L√∂sungsmatrix mit der Zelle 16 des Vektors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Zelle 24 in der Figur) verbindet, und dem Segment, das die Zelle (1,1) der L√∂sungsmatrix mit der Zelle verbindet 2 Steuervektoren </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Zelle 10 in der Figur). Die Projektionen aller Zellen der L√∂sungsmatrix, die auf derselben linken Diagonale liegen, fallen jeweils in dieselbe Zelle des linken Kontrollvektors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die Projektionen aller Zellen der L√∂sungsmatrix, die auf derselben rechten Diagonale liegen, fallen in </font><font style="vertical-align: inherit;">dieselbe Zelle </font><font style="vertical-align: inherit;">Zelle des rechten Kontrollvektors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Somit erm√∂glichen diese beiden Steuervektoren </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die vollst√§ndige Kontrolle aller diagonalen Hemmungen f√ºr jede Zelle der Entscheidungsmatrix. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist wichtig anzumerken, dass die Idee, diagonale Projektionen auf Zellen von Steuervektoren zu verwenden, um zu bestimmen, ob eine Zelle einer L√∂sungsmatrix mit Koordinaten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> frei oder besetzt ist, </font><font style="vertical-align: inherit;">auch sp√§ter in implementiert wurde</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richards (1997)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es bietet einen der schnellsten rekursiven Suchalgorithmen f√ºr alle L√∂sungen, basierend auf Operationen mit einer Bitmaske. Ein wichtiger Unterschied besteht darin, dass der angegebene Algorithmus f√ºr die sequentielle Suche aller L√∂sungen ab der ersten Zeile der L√∂sungsmatrix nach unten oder ab der letzten Zeile der Matrix nach oben ausgelegt ist. Der von uns vorgeschlagene Algorithmus basiert auf der Bedingung, dass die Wahl der Nummer jeder Zeile f√ºr den Ort der K√∂nigin willk√ºrlich sein muss. F√ºr den betrachteten Algorithmus ist dies von grundlegender Bedeutung. Beachten Sie, dass die obige Abbildung 1 in Analogie zu dem aufgebaut ist, was in diesem Artikel ver√∂ffentlicht wird. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Programm, um zu √ºberpr√ºfen, ob eine gegebene L√∂sung des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens-Problems</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> korrekt ist oder ob eine gegebene Zusammensetzung aus </font><i><font style="vertical-align: inherit;">k</font></i><font style="vertical-align: inherit;"> wahr ist</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queens ist wie folgt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Um diagonale Hemmungen zu steuern, erstellen Sie zwei Arrays </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (1: n2)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (1: n2)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wobei n2 = 2 * n ist, und ein Array </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B (1: n)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die Belegung der Spalten der L√∂sungsmatrix zu steuern. Setzen Sie diese drei Arrays au√üer Kraft. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Wir f√ºhren den Z√§hler der Anzahl der korrekt installierten K√∂niginnen ein ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">totPos = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Ausgehend von der ersten Zeile werden in einem Zyklus konsequent alle Positionen der K√∂niginnen ber√ºcksichtigt. Wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q (i)&gt; 0 ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dann </font><font style="vertical-align: inherit;">bilden </font><i><font style="vertical-align: inherit;">wir</font></i><font style="vertical-align: inherit;"> basierend auf dem Index der Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und dem Index der Position der K√∂nigin in dieser Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j = Q (i)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die entsprechenden Indizes f√ºr die Steuerfelder </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (t)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r = n + j - i </font></font></i> <br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t = j + i</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3. Wenn alle Bedingungen ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r) = 0, D2 (t) = 0, B (j) = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">erf√ºllt sind </font><font style="vertical-align: inherit;">, bedeutet dies, dass die Zelle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( i, j) ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> frei und f√§llt nicht in die Projektionszone von diagonalen Beschr√§nkungen, die von zuvor festgelegten K√∂niginnen gebildet werden. Die Position der K√∂nigin in dieser Position ist korrekt. Wenn mindestens eine dieser Bedingungen nicht erf√ºllt ist, ist die Wahl einer solchen Position jeweils falsch, und die Entscheidung ist falsch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Wenn die L√∂sung korrekt ist, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erh√∂hen Sie</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den Z√§hler der Anzahl der korrekt installierten K√∂niginnen ( </font><i><font style="vertical-align: inherit;">totPos = totPos + 1</font></i><font style="vertical-align: inherit;"> ) und schlie√üen Sie die entsprechenden Zellen der Kontrollfelder: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(D1 (r) = 1, D2 (t) = 1, B (j) = 1)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Also schlie√üen wir alle Zellen in der Spalte</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die Zellen der L√∂sungsmatrix, die sich entlang der linken und rechten Diagonalen befinden, die sich in der Zelle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schneiden </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Wiederholen Sie den √úberpr√ºfungsvorgang f√ºr alle verbleibenden Positionen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielleicht ist dies einer der schnellsten Algorithmen zur Bewertung der Richtigkeit der L√∂sung des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens-Problems</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die √úberpr√ºfungszeit von einer Million Positionen f√ºr die Matrix der L√∂sungen 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> x 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desktop-13</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> betr√§gt 0,175 Sekunden, was ungef√§hr der Zeit entspricht, in der die Eingabetaste gedr√ºckt wurde. </font><font style="vertical-align: inherit;">Offensichtlich ist dieser Algorithmus in Bezug auf die Z√§hlzeit in Bezug auf </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> linear </font><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4. Beschreibung des Algorithmus zur L√∂sung des Problems </font></font></h3><br>  <b>Der General</b> .  <i>Das n-Queens-Vervollst√§ndigungsproblem</i> ist ein klassisches nicht deterministisches Problem.  Die Hauptschwierigkeit seiner L√∂sung h√§ngt mit dem Problem der Auswahl des Zeilenindex und des Positionsindex in dieser Zeile zusammen, wenn der Zustandsraum sehr gro√ü ist.  Bei der Suche nach allen m√∂glichen L√∂sungen tritt ein solches Problem nicht auf.  Wir m√ºssen alle g√ºltigen Suchzweige im Zustandsraum ber√ºcksichtigen, und die Reihenfolge, in der sie ber√ºcksichtigt werden, spielt keine Rolle.  Wenn jedoch eine beliebige Zusammensetzung von <i>k</i> K√∂niginnen bis zu einer vollst√§ndigen L√∂sung vervollst√§ndigt werden muss, ben√∂tigen wir in diesem Fall einen Algorithmus zum Ausw√§hlen von Zeilen- und Spaltenindizes, der die vorhandene Zusammensetzung angemessen wahrnimmt und zu einer L√∂sung f√ºhrt, die schneller als andere ist.  In diesem Projekt haben wir die Frage der Wahl auf der Grundlage der folgenden allgemeinen Position entschieden: <i>Wenn wir keine Bedingungen formulieren k√∂nnen, die einer Zeile oder einer Position in dieser Zeile den Vorrang vor anderen geben, verwenden wir einen Zufallsauswahlalgorithmus auf der Grundlage von gleichm√§√üig verteilte Zufallszahlen</i> .  Eine √§hnliche Zufallsauswahlmethode zur L√∂sung von Problemen, bei denen der Zustandsraum sehr gro√ü ist, ist ganz nat√ºrlich.  Eine der Ausgaben der Reihe Proceedings of a <i>DIMACS Workshop (1999)</i> widmete sich ganz der Verwendung der Zufallsauswahl bei der Entwicklung von Algorithmen zur L√∂sung komplexer Probleme.  Die korrekte Implementierung des Zufallsauswahlalgorithmus kann eine ziemlich produktive L√∂sung sein, obwohl dies eine notwendige, aber nicht ausreichende Bedingung f√ºr die Vervollst√§ndigung der L√∂sung ist.  <i>Sosic und Gu (1990) verwenden</i> als eine der ersten Studien einen Zufallsauswahlalgorithmus zur L√∂sung des <i>n-Queens-Problems</i> .  Der untersuchte Algorithmus basiert auf einer relativ einfachen und pr√§gnanten Idee.  Es gebe eine Folge von Zahlen von <i>1</i> bis <i>n</i> , die zuf√§llig neu angeordnet werden.  Eine solche Menge von Zahlen hat eine wichtige Eigenschaft.  Es besteht darin, dass unabh√§ngig davon, wie diese Zahlen auf verschiedene Zeilen der L√∂sungsmatrix verteilt sind, wie die Positionen der K√∂nigin (eine Zahl pro Zeile), die ersten beiden Regeln in der Aussage des Problems immer erf√ºllt sind: Jede Zeile und jede Spalte haben keine mehr als eine K√∂nigin.  Es wird jedoch nur ein Teil der so erhaltenen Positionen frei von diagonalen Beschr√§nkungen sein.  Der andere Teil befindet sich in einem Konflikt mit zuvor eingerichteten K√∂niginnen.  Um aus dieser Situation herauszukommen, verwendeten die Autoren die Methode, gegens√§tzliche Positionen zu vergleichen und auszutauschen, um eine vollst√§ndige L√∂sung zu erhalten.  In unserem vorgeschlagenen Algorithmus sind Konfliktsituationen unm√∂glich, da bei jedem Schritt zur L√∂sung des Problems die K√∂nigin nur dann in die Zelle der betreffenden Leitung installiert wird, wenn die Zelle frei ist. <br><br>  <b>4.1 Ausw√§hlen eines Modells f√ºr die R√ºckverfolgung (BT)</b> <br><br>  Beim Finden einer L√∂sung f√ºr ein Problem kann eine Situation auftreten, in der eine sequentielle L√∂sungskette zu einer Sackgasse f√ºhrt.  Dies ist eine ‚Äûgenetische‚Äú Eigenschaft nicht deterministischer Probleme.  In diesem Fall m√ºssen Sie zu einem der vorherigen Schritte zur√ºckkehren, den Status der Aufgabe gem√§√ü dieser Ebene wiederherstellen und die Suche nach einer L√∂sung von dieser Position aus erneut starten.  Die Frage ist, welches der vorherigen Level zur√ºckgegeben werden soll und wie viele solcher Level es sein sollen (mit Level meinen wir einen bestimmten Schritt bei der L√∂sung des Problems mit einer bestimmten Anzahl korrekt installierter K√∂niginnen).  Offensichtlich ist die Auswahl einer L√∂sungsebene zum Zur√ºckgehen genauso relevant wie die Auswahl eines Zeilenindex oder eines Positionsindex in dieser Zeile.  Unabh√§ngig von der Vorgehensweise zur L√∂sung dieses Problems ist es daher erforderlich, zun√§chst die Anzahl der Grundstufen f√ºr die R√ºckkehr sowie den Mechanismus und die Bedingungen f√ºr die R√ºckkehr zu einer dieser Stufen zu bestimmen.  In unserem vorgeschlagenen Algorithmus unterteilen wir die L√∂sungsmatrix in drei Grundebenen.  Dies sind die R√ºckgabestellen.  Wenn aufgrund der L√∂sung ein Deadlock auftritt, kehren wir abh√§ngig von den Parametern der Aufgabe zu einer dieser drei grundlegenden Ebenen zur√ºck.  Die erste Basisebene ( <i>baseLevel1</i> ) entspricht dem Zustand, in dem die Daten√ºberpr√ºfung der betreffenden Zusammensetzung abgeschlossen ist.  Dies ist der Beginn des Programms.  Die Werte der folgenden zwei Basisebenen ( <i>baseLevel2</i> und <i>baseLevel3</i> ) h√§ngen von der Gr√∂√üe der Matrix <i>n ab</i> .  Die empirische Abh√§ngigkeit dieser Grundwerte von der Gr√∂√üe der L√∂sungsmatrix wurde anhand einer Vielzahl von Rechnerexperimenten ermittelt.  Zur genaueren Darstellung dieser Abh√§ngigkeit haben wir das gesamte betrachtete Intervall von 7 bis 10 <sup>8</sup> in zwei Teile geteilt.  Sei <i>u = log (n)</i> , dann wenn <i>n &lt;30 000</i> , dann <br><br>  <i>baseLevel2 = n - rund (12.749568 * u3 - 46.535838 * u2 + 120.011829 * u - 89.600272)</i> <br>  <i>baseLevel3 = n - rund (9.717958 * u3 - 46.144187 * u2 + 101.296409 * u - 50.669273)</i> <br><br>  ansonsten <br><br>  <i>baseLevel2 = n - rund (-0,886344 * u3 + 56,136743 * u2 + 146,486415 * u + 227,967782)</i> <br>  <i>baseLevel3 = n - round (14.959815 * u3 - 253.661725 * u2 + 1584.713376 * u - 3060.691342)</i> <br><br>  <b>4.2 Blockstruktur</b> <br><br>  Der Algorithmus ist in Form einer Folge von <i>f√ºnf Ereignisbl√∂cken aufgebaut</i> , wobei jedes Ereignis der Ausf√ºhrung eines bestimmten Teils der L√∂sung des Problems zugeordnet ist.  Die Verarbeitungsalgorithmen in jedem Block unterscheiden sich voneinander.  Nur drei der f√ºnf Bl√∂cke dienen zur Bildung einer sequentiellen L√∂sungskette, und die verbleibenden zwei Bl√∂cke sind vorbereitend.  Die Wahl der Blocknummer, ab der die Berechnungen beginnen, h√§ngt vom Wert von <i>n</i> und von den Ergebnissen des Vergleichs der Zusammensetzungsgr√∂√üe <i>k</i> mit den Werten von <i>baseLeve2</i> und <i>baseLevel3 ab</i> .  Eine Ausnahme bildet das Intervall der Werte <i>n = (7, ..., 99)</i> , das aufgrund der Besonderheiten des Algorithmusverhaltens in diesem Abschnitt als "turbulente Zone" bezeichnet werden kann.  F√ºr die Werte <i>n = (7, ..., 49)</i> beginnen die Berechnungen unabh√§ngig von der Gr√∂√üe der Zusammensetzung nach der Eingabe und √úberwachung der Daten ab dem 4. Block.  F√ºr Werte <i>n = (50, ..., 99)</i> beginnen die Berechnungen je nach Gr√∂√üe der Komposition entweder ab dem zweiten Block oder ab dem vierten.  Wie oben erw√§hnt, werden bei jedem Schritt zur L√∂sung des Problems nur die Positionen in der Linie ber√ºcksichtigt, die nicht in die von den zuvor eingerichteten K√∂niginnen geschaffene Beschr√§nkungszone fallen.  Es sind diese Positionen, <i>die als frei bezeichnet werden</i> . <br>  Beschreiben wir kurz, welche Berechnungen in jedem dieser f√ºnf Programmbl√∂cke durchgef√ºhrt werden. <br><br>  <b>4.3 Beginn des Algorithmus</b> <br><br>  Die Daten werden eingegeben und die Zusammensetzung auf Richtigkeit √ºberpr√ºft.  Bei jedem √úberpr√ºfungsschritt werden die Zellen der Steuerfelder ge√§ndert.  Die Anzahl der korrekt installierten K√∂niginnen wird gez√§hlt.  Wenn die Komposition keine Fehler enth√§lt, wird die L√∂sung fortgesetzt, andernfalls wird eine Fehlermeldung angezeigt.  Nach Abschluss der √úberpr√ºfung werden Kopien der Haupt-Arrays f√ºr deren Wiederverwendung auf dieser Ebene erstellt.  Danach wird die Steuerung auf <i>Block 1 √ºbertragen</i> . <br><br>  <b>4.4 Block 1</b> <br><br>  Der Beginn der Bildung des Suchzweigs.  Wir betrachten <i>k</i> Damen auf einem Schachbrett als Startposition.  Es ist erforderlich, diese Komposition fortzusetzen und die Damen auf ein Schachbrett zu <i>legen,</i> bis ihre Gesamtzahl gleich <i>baseLevel2 ist</i> .  Der hier verwendete Algorithmus hei√üt <i>randSet &amp; randSet</i> .  Dies liegt an der Tatsache, dass wir hier st√§ndig zwei zuf√§llige Listen von Indizes vergleichen, um Paare zu suchen, die frei von den entsprechenden diagonalen Beschr√§nkungen sind.  Dazu werden folgende Aktionen ausgef√ºhrt: <br><br>  a) Es werden zwei Listen gebildet: eine Liste freier Zeilenindizes und eine Liste freier Spaltenindizes; <br><br>  b) zuf√§llige Neuordnung von Zahlen in jeder dieser Listen; <br><br>  c) In einer Schleife wird jedes aufeinanderfolgende Wertepaar <i>(i, j)</i> , bei dem Index <i>(i)</i> aus der Liste der freien Zeilenindizes und Index <i>(j)</i> aus der Liste der freien Spaltenindizes ausgew√§hlt wird, als m√∂gliche K√∂niginposition betrachtet und gepr√ºft, ob dies der Fall ist Position im Projektionsbereich von diagonalen Ausnahmen. <br><br>  Wenn die Regel der diagonalen Ausnahmen nicht verletzt wird, gilt die Position als korrekt und die Dame wird an diese Position gesetzt.  Danach wird der Z√§hler um die Anzahl der korrekt installierten K√∂niginnen erh√∂ht und die entsprechenden Zellen der Steuerfelder werden ge√§ndert.  F√§llt die Position <i>(i, j)</i> in die Zone der diagonalen Beschr√§nkungen, die durch die zuvor festgelegten K√∂niginnen gebildet werden, so √§ndert sich nichts und der √úbergang zur Ber√ºcksichtigung des n√§chsten Wertepaares findet statt. <br><br>  Wenn der Vergleichszyklus aller Paare der Liste abgeschlossen ist, wird basierend auf den verbleibenden Indizes, die sich in der diagonalen Ausschlusszone befinden, erneut eine Liste der Indizes der verbleibenden freien Zeilen und freien Spalten gebildet, und dieser Vorgang wird wiederholt, bis die Gesamtzahl der korrekt platzierten K√∂niginnen <i>(totPos )</i> wird nicht gleich dem Grenzwert von <i>baseLevel2 sein</i> oder diesen √ºberschreiten.  Sobald diese Bedingung erf√ºllt ist, wird die Steuerung auf <i>Block 2 √ºbertragen</i> .  Wenn sich als Ergebnis der Suche nach einer L√∂sung herausstellt, dass aus der gesamten Liste der Indizes der verbleibenden freien Zeilen und freien Spalten keines der Paare f√ºr die Position der K√∂nigin geeignet ist, werden in diesem Fall die urspr√ºnglichen Werte der Steuerfelder basierend auf zuvor erzeugten Kopien wiederhergestellt , und die Steuerung wird zum erneuten Z√§hlen an den Anfang von <i>Block 1 √ºbertragen</i> . <br><br>  <b>4.5 Block 2</b> <br><br>  Dieser Block dient als Vorbereitungsstufe f√ºr den √úbergang zu <i>Block-3</i> .  Auf dieser Ebene ist die Anzahl der verbleibenden freien Leitungen ( <i>freeRows</i> ) deutlich geringer als <i>n</i> .  Auf diese Weise k√∂nnen Sie Ereignisse von der urspr√ºnglichen Matrix der Gr√∂√üe <i>nxn</i> auf eine Matrix der kleineren Gr√∂√üe <i>L √ºbertragen (1: freeRows, 1: freeRows)</i> .  Dar√ºber hinaus werden basierend auf Informationen √ºber die verbleibenden freien Zeilen und freien Spalten in der urspr√ºnglichen L√∂sungsmatrix Nullen in die entsprechenden Zellen des Arrays <i>L geschrieben</i> , was anzeigt, dass diese Zellen frei sind.  Bei diesem <i>"Projektions"</i> -√úbergang bleibt die Entsprechung der Zeilen- und Spaltenindizes der neuen Matrix mit den entsprechenden Indizes der urspr√ºnglichen Matrix erhalten.  Es ist wichtig anzumerken, dass, obwohl sich bei der L√∂sung dieses Problems alle Ereignisse auf der urspr√ºnglichen Matrix der Gr√∂√üe <i>nxn</i> entfalten und eine solche Matrix der Hauptaktionsbereich ist, <i>diese Matrix</i> in <i>Wirklichkeit nicht erstellt</i> wird und nur Kontrollfelder zur Ber√ºcksichtigung der Zeilenindizes <i>A (1: n)</i> und Spalten <i>B (1: n)</i> dieser Matrix. <br><br>  In diesem Block werden neben dem L-Array auch zwei Arbeits-Arrays <i>rAr (1: freeRows)</i> und <i>tAr (1: freeRows)</i> gebildet, um die entsprechenden Indizes der Steuer-Arrays <i>D1</i> und <i>D2</i> <i>abzuspeichern</i> .  Dies liegt an der Tatsache, dass wir, wenn wir die n√§chste Dame in der Zelle <i>(i, j) der</i> anf√§nglichen Matrix der Gr√∂√üe <i>nxn installieren</i> , danach die Zellen des Arrays <i>L</i> ausschlie√üen m√ºssen, die in die Projektionszone der diagonalen Ausnahmen des urspr√ºnglichen "gro√üen" Arrays fallen.  Da die Steuerung von diagonalen Beschr√§nkungen nur innerhalb der urspr√ºnglichen Matrix der Gr√∂√üe <i>nxn ausgef√ºhrt wird</i> , k√∂nnen <i>wir</i> durch das Vorhandensein von Arbeitsarrays <i>rAr</i> und <i>tAr</i> die Korrespondenz aufrechterhalten und verbotene Zellen in die Grenzen von Array L √ºbersetzen. Dies vereinfacht die Abrechnung ausgeschlossener Positionen erheblich. <br>  Nach Abschluss der Vorarbeiten in diesem Block werden Kopien der Haupt-Arrays zur Wiederverwendung auf dieser Ebene erstellt, und die Steuerung wird an <i>Block 3 √ºbertragen</i> . <br><br>  <b>4.6 Block 3</b> <br><br>  In diesem Block wird die Bildung des L√∂sungssuchzweigs auf der Grundlage der im vorherigen Block vorbereiteten Daten fortgesetzt.  Die Anzahl der Zeilen, in denen die <i>Damen</i> richtig eingestellt sind, ist gleich oder gr√∂√üer als <i>baseLevel-2</i> .  Sie m√ºssen mit der Auswahl fortfahren, bis die Anzahl der installierten K√∂niginnen gleich <i>baseLevel-3 ist</i> .  Hier verwenden wir den <i>Rand &amp; Rand-</i> L√∂sungssuchalgorithmus, d.h.  Um die Position einer Dame zu bilden, werden anstelle einer Liste freier Indizes nur zwei Indizes verwendet, ein zuf√§lliger Indexwert einer freien Zeile und ein zuf√§lliger Indexwert einer freien Position in dieser Zeile.  Dieser Vorgang wird zyklisch wiederholt, bis die Gesamtzahl der platzierten K√∂niginnen dem Wert von <i>baseLevel-3 entspricht</i> .  Sobald diese Bedingung erf√ºllt ist, wird die Steuerung auf <i>Block 4 √ºbertragen</i> .  Wenn sich als Ergebnis von Berechnungen herausstellt, dass der Suchzweig eine Sackgasse ist, wird dieser Abschnitt der Suchzweigbildung geschlossen und kehrt zum Anfang von <i>Block 3 zur√ºck</i> , von wo aus die Berechnungen erneut wiederholt werden.  Hierzu werden die Anfangswerte aller Control Arrays wiederhergestellt. <br><br>  <b>4.7 Block 4</b> <br><br>  In diesem Block werden Daten f√ºr die √úbertragung der Steuerung an <i>Block 5</i> vorbereitet.  In diesem Schritt ist die Anzahl der freien Leitungen ( <i>nRow</i> ) nach Abschluss der Prozedur in <i>Block-3</i> noch geringer geworden.  Daher ist es auch vorteilhaft, Ereignisse von einem gr√∂√üeren Array in ein kleineres Array zu √ºbersetzen.  Dieser Ansatz gibt uns die M√∂glichkeit, die erforderlichen Eigenschaften f√ºr die verbleibenden Leitungen, die wir in dieser Phase ben√∂tigen, schnell zu bestimmen.  Von besonderer Bedeutung ist die Tatsache, dass es auf der Basis eines solchen Arrays m√∂glich ist, die Aussichten des Suchzweigs f√ºr viele weitere Schritte vorherzusagen, ohne die Berechnungen abschlie√üen zu m√ºssen.  Der Zustand ist recht einfach.  Wenn sich herausstellt, dass es unter den verbleibenden freien Zeilen eine Zeile gibt, in der keine freie Position vorhanden ist, wird der betreffende Suchzweig geschlossen und die Steuerung auf einen der Bl√∂cke der unteren Ebene √ºbertragen.  Die hier durchgef√ºhrten vorbereitenden Ma√ünahmen √§hneln weitgehend denen in <i>Block 2</i> .  Basierend auf den urspr√ºnglichen Indizes freier Zeilen und freier Spalten wird ein neues zweidimensionales Array gebildet, dessen Nullwerte freien Positionen in der urspr√ºnglichen L√∂sungsmatrix entsprechen.  Au√üerdem wird in diesem Block ein spezielles Array <i>E (1: nRow, 1: nRow)</i> erstellt, anhand dessen Sie die Anzahl der freien Positionen in den verbleibenden freien Zeilen bestimmen k√∂nnen, die geschlossen werden, wenn Sie die Position <i>(i, j)</i> ausw√§hlen <i>,</i> in die die Dame gesetzt werden soll Quellmatrix.  Vor dem √úbertragen der Steuerung auf <i>Block 5</i> werden die folgenden Aktionen ausgef√ºhrt: <br><br>  a) die Anzahl der offenen Stellen in allen verbleibenden Zeilen wird bestimmt, <br><br>  b) ein Array der Summe der freien Positionen f√ºr die betrachteten Linien in aufsteigender Reihenfolge sortiert wird, <br><br>  c) wenn alle verbleibenden freien Linien freie Positionen haben (d. h. der Minimalwert in dieser Rangliste ist von 0 verschieden), wird die Steuerung zu Block 5 √ºbertragen. <br><br>  Wenn sich herausstellt, dass in einer der verbleibenden Zeilen keine freie Position vorhanden ist, werden die erforderlichen Arrays basierend auf den gespeicherten Kopien wiederhergestellt, und die Steuerung wird abh√§ngig von den Parametern der Aufgabe auf eine der Basisebenen √ºbertragen. <br><br>  d) Sicherungskopien aller Steuerfelder f√ºr diese 4. Ebene werden erstellt. <br><br>  <b>4.8 Block 5</b> <br><br>  Diese Phase ist abgeschlossen, und hier wird die Bildung des Suchzweigs ‚Äûausgewogener‚Äú und ‚Äûrationaler‚Äú durchgef√ºhrt.  Dies ist die "letzte Meile", es bleiben nur noch wenige freie Leitungen.  Gleichzeitig ist dies der schwierigste Teil.  Alle Fehler, die m√∂glicherweise in den vorherigen Phasen der Bildung des Zweigs der Suche nach einer L√∂sung begangen wurden, werden hier zusammengefasst angezeigt - in Form des Fehlens einer freien Position in der Zeile. <br><br>  Der Algorithmus dieses Blocks wird auf der Basis von zwei verschachtelten Schleifen ausgef√ºhrt, in denen die dritte Schleife ausgef√ºhrt wird.  Ein Merkmal des dritten Zyklus ist, dass er wiederholt werden kann, ohne die Parameter von zwei externen Zyklen zu √§ndern.  Dies passiert, wenn der generierte Suchzweig blockiert ist.  Die Anzahl solcher Wiederholungen √ºberschreitet nicht den Grenzwert von <i>repeatBound</i> , dessen optimaler Wert auf der Basis von Computerexperimenten ermittelt wurde. <br><br>  Der √§u√üere Schleifenindex ist mit einer sequentiellen Auswahl von Zeilenindizes verbunden, die nach Berechnungen auf der dritten Basisebene frei blieben.  Dies geschieht auf der Grundlage einer zuvor nach der Anzahl der freien Positionen in der Zeile geordneten Liste von Zeilen.  Die Auswahl beginnt mit einer Zeile mit einer Mindestanzahl von freien Positionen und wird dann in nachfolgenden Schritten in aufsteigender Reihenfolge durchgef√ºhrt.  Innerhalb dieses Zyklus wird ein zweiter Zyklus gebildet, dessen Index die Indizes aller freien Positionen in der betreffenden Zeile durchl√§uft.  Der Zweck des ersten Zyklus besteht nur darin, den Index einer der freien Zeilen auf dieser Ebene auszuw√§hlen.  Dementsprechend besteht der Zweck des zweiten Zyklus darin, nur eine freie Position innerhalb der betrachteten Linie auszuw√§hlen.  Diese Aktionen finden nur auf der dritten Grundstufe statt.  Nach dieser Auswahl wird die Anzahl der installierten K√∂niginnen erh√∂ht und die entsprechenden Zellen aller Steuerfelder werden ge√§ndert.  Ferner wird die Steuerung innerhalb eines verschachtelten (dritten) Zyklus √ºbertragen, dessen Aktivit√§tszone bereits alle verbleibenden freien Leitungen enth√§lt.  Innerhalb dieses Zyklus werden die Auswahl des Zeilenindex und die Auswahl einer freien Position in dieser Zeile basierend auf den folgenden Regeln durchgef√ºhrt: <br><br>  a) <b>W√§hlen Sie eine freie Leitung</b> .  Alle verbleibenden freien Zeilen werden ber√ºcksichtigt, und die Anzahl der freien Positionen wird in jeder Zeile bestimmt.  Die Zeile wird ausgew√§hlt, f√ºr die die Anzahl der freien Positionen minimal ist.  Dies minimiert die Risiken, die mit der M√∂glichkeit verbunden sind, die letzten vakanten Positionen in einigen der verbleibenden Linien, f√ºr die der Staat minimal und kritisch in Bezug auf die Anzahl der vakanten Positionen ist <b>, auszuschlie√üen</b> ( <b>Mindestrisikoregel</b> ).  Im √úbrigen beginnt der Index des ersten Zyklus in diesem f√ºnften Block mit einer sequentiellen Auswahl von Zeilen mit einem Mindestwert f√ºr die Anzahl der freien Positionen in einer Zeile.  Wenn sich in einem Schritt herausstellt, dass die beiden Zeilen die gleiche Mindestanzahl an freien Positionen haben, wird der Index einer der beiden Positionen, die in der Rangliste an erster Stelle stehen, zuf√§llig ausgew√§hlt.  Wenn die Anzahl der Zeilen mit der gleichen Mindestanzahl an freien Positionen mehr als zwei betr√§gt, wird der Index einer der drei Positionen, die an erster Stelle in der Rangliste aufgef√ºhrt sind, zuf√§llig ausgew√§hlt. <br><br>  b) <b>Auswahl einer freien Position in einer Reihe</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus der Liste aller vakanten Positionen in der betreffenden Zeile wird eine ausgew√§hlt, die den vakanten Positionen in allen verbleibenden Zeilen nur minimalen Schaden zuf√ºgt. Dies geschieht auf der Grundlage des zuvor gebildeten Arrays E. Mit "minimaler Besch√§digung" ist die Auswahl einer solchen Position in einer bestimmten Zeile gemeint, die die geringste Menge an freien Positionen in allen verbleibenden Zeilen ausschlie√üt ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel f√ºr minimale Besch√§digung)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Wenn sich herausstellt, dass zwei oder mehr freie Positionen in einer Reihe gem√§√ü dem Schadenskriterium die gleichen Mindestwerte aufweisen, wird der Index einer der beiden Positionen, die zuerst in der Liste aufgef√ºhrt sind, zuf√§llig ausgew√§hlt. Wenn Sie eine Position ausw√§hlen, die die Mindestanzahl an freien Positionen in den verbleibenden Zeilen ausschlie√üt, wird der mit der Position der K√∂nigin in dieser Position verbundene ‚ÄûSchaden‚Äú minimiert. Die Verwendung dieser beiden Regeln erm√∂glicht eine rationellere Ressourcennutzung bei jedem Schritt der Bildung eines Suchzweigs. Dies verringert das Risiko erheblich und erh√∂ht die Wahrscheinlichkeit, eine beliebige Zusammensetzung zu einer vollst√§ndigen L√∂sung zu w√§hlen, wenn die fragliche Zusammensetzung eine L√∂sung aufweist. Wenn sich bei einem L√∂sungsschritt herausstellt, dass in einer der verbleibenden zu ber√ºcksichtigenden Zeilen keine offenen Stellen vorhanden sind, wird dieser Suchzweig geschlossen. In diesem Fall,Auf der Grundlage von Sicherungen werden alle Steuerfelder wiederhergestellt, und wenn der Z√§hler f√ºr die Anzahl der Wiederholungen den Grenzwert nicht √ºberschreitet</font></font><i>repeatBound</i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann wird, ohne die Indizes des ersten und des zweiten externen Zyklus zu √§ndern, die Arbeit des dritten verschachtelten Zyklus erneut wiederholt. Dies ist darauf zur√ºckzuf√ºhren, dass wir in F√§llen, in denen die Mindestwerte der relevanten Kriterien √ºbereinstimmten, eine zuf√§llige Auswahl getroffen haben. Durch die Neugestaltung des Suchzweigs unter den gleichen Bedingungen wie auf der Basisebene k√∂nnen die auf dieser Ebene vorhandenen ‚ÄûStartressourcen‚Äú effizienter genutzt werden. Die Anzahl der wiederholten Starts des dritten verschachtelten Zyklus ist begrenzt, und wenn der Grenzwert √ºberschritten wird, wird der Betrieb dieses Zyklus unterbrochen. Danach werden die Werte der Steuerfelder wiederhergestellt, und die Steuerung wird in den Zyklus der dritten Basisebene √ºbertragen, um zum n√§chsten Indexwert zu gelangen. Diese Prozedur wird zyklisch wiederholt, bis eine vollst√§ndige L√∂sung erhalten wird, oder es stellt sich heraus, dassdass wir alle freien Zeilen und alle freien Positionen in diesen Zeilen auf dieser Basisebene verwendet haben. In diesem Fall kehrt man in Abh√§ngigkeit von der Gesamtzahl der wiederholten Berechnungen auf verschiedenen Basisebenen und unter Ber√ºcksichtigung der Gr√∂√üe der Entscheidungsmatrix und der Gr√∂√üe der Zusammensetzung zu einer der niedrigeren Ebenen f√ºr wiederholte Berechnungen zur√ºck, oder es wird beurteilt, dass die fragliche Zusammensetzung nicht sein kann ausger√ºstet, um L√∂sung zu vervollst√§ndigen. In dem Programm wird, um die Gesamtzeit der Rechnung zu begrenzen, das Verfahren akzeptiertoder es wird entschieden, dass die fragliche Komposition erst nach einer vollst√§ndigen Entscheidung vervollst√§ndigt werden kann. In dem Programm wird, um die Gesamtzeit der Rechnung zu begrenzen, das Verfahren akzeptiertoder es wird entschieden, dass die fragliche Komposition erst nach einer vollst√§ndigen Entscheidung vervollst√§ndigt werden kann. In dem Programm wird, um die Gesamtzeit der Rechnung zu begrenzen, das Verfahren akzeptiert</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die R√ºckverfolgung kann</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , unabh√§ngig davon, auf welche der vorherigen Ebenen die R√ºckgabe erfolgt, nur bis zu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">totSimBound-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeiten durchgef√ºhrt werden. </font><font style="vertical-align: inherit;">Dieser Grenzwert wird auf der Grundlage von Berechnungsexperimenten f√ºr verschiedene Werte von n ausgew√§hlt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Analyse der Wirksamkeit von Auswahlalgorithmen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Effizienz des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Algorithmus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Um die F√§higkeiten dieses Algorithmus zu analysieren, wurde ein Computerexperiment durchgef√ºhrt, das darin bestand </font><font style="vertical-align: inherit;">, K√∂niginnen in der L√∂sungsmatrix </font><font style="vertical-align: inherit;">basierend auf dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modell </font><font style="vertical-align: inherit;">zu platzieren, solange diese M√∂glichkeit besteht. Sobald der Suchzweig eine Sackgasse erreichte oder eine vollst√§ndige L√∂sung erhalten wurde, wurden die Zusammensetzungsgr√∂√üe, die L√∂sungszeit festgelegt und der Test erneut wiederholt. Computerexperimente wurden f√ºr die gesamte Basisliste von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werten durchgef√ºhrt </font><font style="vertical-align: inherit;">. Die Anzahl der wiederholten Tests f√ºr die Werte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (30, 40, ..., 90, 100, 200, 300, 500, 800, 1000)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> betrug </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Million</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , f√ºr die √ºbrigen Werte die Anzahl der Tests mit zunehmendem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Analyse der Ergebnisse von Computerexperimenten erlaubt es uns, die folgenden Schlussfolgerungen zu ziehen: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Als Ergebnis nur des ersten Zyklus der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Prozedur sind</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> durchschnittlich etwa 60% aller K√∂niginnen korrekt platziert. F√ºr </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100 betr√§gt die Anzahl der korrekt platzierten K√∂niginnen 60,05%. Mit zunehmendem Wert von n nimmt dieser Wert allm√§hlich ab und f√ºr n = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> betr√§gt er 59,97%. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Das Histogramm der Verteilung der L√§ngenwerte der erhaltenen Zusammensetzungen hat unabh√§ngig von der Gr√∂√üe der Entscheidungsmatrix </font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;"> die gleiche Form</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dar√ºber hinaus haben sie alle ein charakteristisches Merkmal - die linke Seite der Verteilung (zum Modalwert) unterscheidet sich von der rechten Seite. Abbildung 2 zeigt als Beispiel das entsprechende Histogramm f√ºr</font></font><br><br><img src="https://habrastorage.org/webt/fu/h3/xy/fuh3xyqsx5ro7zx8ru7b66fliy8.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Ein Histogramm der Verteilung von L√∂sungen unterschiedlicher L√§nge f√ºr das randSet &amp; randSet-Modell ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100, Stichprobengr√∂√üe = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100. Es scheint, dass das Histogramm aus der H√§ufigkeitsverteilung von zwei verschiedenen Ereignissen gewonnen wird, da die H√§ufigkeit des Auftretens von Ereignissen im linken und rechten Teil der Verteilung unterschiedlich ist. Um diese Verteilung zu beschreiben, ist es am wahrscheinlichsten, zwei Funktionen der Dichte der Normalverteilung zu verwenden, von denen eine das Intervall bis zum Modalwert und die andere - das Intervall nach dem Modalwert - abdeckt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) Der Durchschnittswert der Anzahl der K√∂niginnen ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), die in der auf diesem Algorithmus basierenden Entscheidungsmatrix festgelegt werden k√∂nnen, steigt mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wie aus Fig. 3 ersichtlich ist, wo ein Graph der Abh√§ngigkeit des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean / n-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verh√§ltnisses </font><font style="vertical-align: inherit;">von der Matrixgr√∂√üe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dargestellt ist </font><font style="vertical-align: inherit;">, nimmt dieses Verh√§ltnis mit einer Zunahme der Matrixgr√∂√üe zu. Zum Beispiel</font></font><br><img src="https://habrastorage.org/webt/wi/5b/kr/wi5bkrcaftlplvllyxfmek0lycg.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Die Abh√§ngigkeit des Verh√§ltnisses </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean / n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vom Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr verschiedene Gr√∂√üen der L√∂sungsmatrix. Das Modell ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der Durchschnittswert der L√§nge der L√∂sung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn f√ºr eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100x100-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Matrix der </font><font style="vertical-align: inherit;">Positionsauswahlalgorithmus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "ohne anzuhalten" erlaubt, K√∂niginnen auf durchschnittlich 89 Zeilen zu platzieren, </font><font style="vertical-align: inherit;">erh√∂ht sich </font><font style="vertical-align: inherit;">f√ºr eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000x1000-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Matrix </font><font style="vertical-align: inherit;">die Anzahl solcher Zeilen im Durchschnitt auf 967. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d) Basierend auf dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Algorithmus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k√∂nnen Sie den vollst√§ndigen </font><i><font style="vertical-align: inherit;">Wert</font></i><font style="vertical-align: inherit;"> erhalten Als L√∂sung ist die ‚ÄûProduktivit√§t‚Äú dieses Ansatzes jedoch √§u√üerst gering. Wie aus Figur 4 ersichtlich ist, z</font></font><br><br><img src="https://habrastorage.org/webt/7w/gt/jg/7wgtjgp2ria3lxqff4ouw9zqzpw.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Die Abnahme der Wahrscheinlichkeit, im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Modell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine vollst√§ndige L√∂sung zu </font><i><font style="vertical-align: inherit;">erhalten,</font></i><font style="vertical-align: inherit;"> mit einer Zunahme von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei Werten von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 7 betr√§gt die Wahrscheinlichkeit, eine vollst√§ndige L√∂sung zu erhalten, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,057</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ferner nimmt mit einer Zunahme von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wahrscheinlichkeit, eine vollst√§ndige L√∂sung zu erhalten, schnell ab und n√§hert sich asymptotisch Null. Beginnend mit den Werten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 48, ist </font><font style="vertical-align: inherit;">die Wahrscheinlichkeit eine Komplettl√∂sung in der Gr√∂√üenordnung von 10 zu </font><font style="vertical-align: inherit;">erhalten </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nach dem Schwellenwert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 70 wurde f√ºr die nachfolgenden Werte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keine einzige vollst√§ndige L√∂sung erhalten (mit einer Anzahl von Tests von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einer Million</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e) Modell</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bilden sehr </font><i><font style="vertical-align: inherit;">schnell Suchzweige</font></i><font style="vertical-align: inherit;"> . F√ºr </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1000 betr√§gt die durchschnittliche Zeit zum Erhalten der Zusammensetzung 0,0015 Sekunden. Die durchschnittliche L√§nge von Kompositionen betr√§gt 967. Dementsprechend betr√§gt </font><sup><font style="vertical-align: inherit;">die</font></sup><font style="vertical-align: inherit;"> durchschnittliche Zeit </font><font style="vertical-align: inherit;">f√ºr </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2,6754 Sekunden bei einer durchschnittlichen L√§nge von Kompositionen von 999793. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f) Mit Ausnahme eines kleinen Intervalls </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;= 70, zu dem das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Modell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in sehr seltenen F√§llen f√ºhren kann vollst√§ndige l√∂sung, in allen anderen f√§llen endet der entscheidungszweig mit der bildung einer negativen zusammensetzung, die erst mit einer vollst√§ndigen l√∂sung abgeschlossen werden kann. Also der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet Algorithmus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es hat einen wichtigen Vorteil - die hohe Geschwindigkeit der Bildung des Suchzweigs und ein wesentlicher Nachteil besteht darin, dass dieser Algorithmus zur Bildung von Zusammensetzungen f√ºhrt, wenn die Gr√∂√üe der Zusammensetzung einen bestimmten Schwellenwert √ºberschreitet, der erst zu einer vollst√§ndigen L√∂sung abgeschlossen werden kann. Um diesen Nachteil zu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beseitigen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , stoppen wir die Bildung des </font><i><font style="vertical-align: inherit;">Suchzweigs,</font></i><font style="vertical-align: inherit;"> wenn der Schwellenwert </font><i><font style="vertical-align: inherit;">baseLevel-2 erreicht ist</font></i><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Effizienz des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rand &amp; Rand-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithmus </font><font style="vertical-align: inherit;">. Um die F√§higkeiten des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rand &amp; Rand-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithmus zu bestimmen </font><font style="vertical-align: inherit;">, wurde eine ziemlich detaillierte Computersimulation f√ºr eine Grundliste von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werten durchgef√ºhrt </font><font style="vertical-align: inherit;">. Wie beim </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet Modell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In den meisten F√§llen betrug die Anzahl der erneuten Tests </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Million</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Bei anderen Werten verringerte sich die Anzahl der Tests allm√§hlich von 100.000 auf 100. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beide Algorithmen basieren auf dem Prinzip der Zufallsauswahl. Daher ist zu erwarten, dass die hier gezogenen Schlussfolgerungen im Wesentlichen mit den f√ºr das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Modell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> formulierten </font><i><font style="vertical-align: inherit;">Schlussfolgerungen √ºbereinstimmen</font></i><font style="vertical-align: inherit;"> . Es gibt jedoch einen grundlegenden Unterschied zwischen ihnen und er besteht aus Folgendem: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modell </font><font style="vertical-align: inherit;">funktioniert nicht so "hart" wie das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Modell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn wir von einem ‚ÄûIndex rationaler Nutzung der </font><i><font style="vertical-align: inherit;">gebotenen</font></i><font style="vertical-align: inherit;"> M√∂glichkeiten‚Äú sprechen, dem </font><i><font style="vertical-align: inherit;">rand &amp; rand-</font></i><font style="vertical-align: inherit;"> Modell</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei jedem Schritt werden Ressourcen rationeller eingesetzt. Dies f√ºhrt dazu, dass beispielsweise bei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 30 die Wahrscheinlichkeit, in diesem Modell eine vollst√§ndige L√∂sung von 0,00170 zu erhalten, 15-mal gr√∂√üer ist als der √§hnliche Wert von 0,00011 f√ºr das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Modell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Au√üerdem </font><font style="vertical-align: inherit;">bleibt </font><font style="vertical-align: inherit;">hier bis zum Schwellwert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 370 die Wahrscheinlichkeit bestehen, in einer Million Tests mindestens eine vollst√§ndige L√∂sung zu erhalten. Nach diesem Schwellenwert wurde f√ºr nachfolgende Werte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit einer Anzahl von Tests von einer Million </font><font style="vertical-align: inherit;">keine vollst√§ndige L√∂sung </font><font style="vertical-align: inherit;">auf der Basis des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rand &amp; Rand-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modells erhalten </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Dieser Algorithmus ist viel langsamer als der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithmus randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn f√ºr</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1000, um eine Komposition der Gr√∂√üe 967 zu generieren. Die durchschnittliche Zeit, um eine Komposition zu erhalten, betr√§gt 0,0497 Sekunden. Dies sind 33 Sekunden mehr als der entsprechende Wert von 0,0015 f√ºr das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet- und randSet-Modell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Grund f√ºr die Unterschiede zwischen zwei im Wesentlichen √§hnlichen Methoden der Zufallsauswahl liegt darin, dass im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Modell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur Beschleunigung der Berechnungen nicht bei jedem Schritt eine Zufallsauswahl aus der verbleibenden Liste durchgef√ºhrt wird. Stattdessen wird ein Indexpaar nacheinander aus zwei Listen ausgew√§hlt, deren Elemente nach dem Zufallsprinzip neu angeordnet wurden. Eine solche Auswahl ist nicht in vollem Umfang zuf√§llig, passt jedoch gut zur Logik des Problems und erm√∂glicht es Ihnen, schnell zu z√§hlen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zur visuellen Demonstration der Funktionsweise des </font><i><font style="vertical-align: inherit;">rand &amp; rand-</font></i><font style="vertical-align: inherit;"> Algorithmus</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wurde folgendes Experiment durchgef√ºhrt: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) F√ºr ein Schachbrett der Gr√∂√üe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100x100</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach jedem Schritt der Position der K√∂nigin in einer beliebigen Zeile wurde die Anzahl der freien Positionen in jeder der verbleibenden freien Zeilen bestimmt. So erhielten wir nach jedem Schritt der Probleml√∂sung eine Liste der freien Zeilen und eine entsprechende Liste der Anzahl der freien Positionen in diesen Zeilen. Dies erm√∂glichte es, ein Diagramm zu erstellen, in dem die Indizes der Spalten der fraglichen Matrix entlang der Abszissenachse und die Anzahl der verbleibenden freien Positionen entlang der Ordinatenachse aufgetragen sind. Zum Vergleich wurden die Berechnungen auch f√ºr das Modell der sequentiellen Positionsauswahl durchgef√ºhrt. Mit sequentieller Auswahl ist das Folgende gemeint. Es wird die erste Zeile ber√ºcksichtigt, in der die erste freie Position in der Liste ausgew√§hlt wird. Dann wird die zweite Zeile ber√ºcksichtigt, in der auch die erste freie Position in der Liste usw. ausgew√§hlt wird. In den Abbildungen 5 und 6</font></font><br><br><img src="https://habrastorage.org/webt/y1/b5/vc/y1b5vcf2es-tsqteleekwvp5dly.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Reduzieren Sie die Anzahl der freien Positionen in den verbleibenden freien Linien nach der Platzierung der K√∂niginnen. Sequenziell regelm√§√üige Positionsauswahl. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ergebnisse, die den betrachteten Modellen entsprechen, werden vorgestellt. Zur Verdeutlichung zeigt das Diagramm die Ergebnisse erst nach den Schritten (10, 40, 60). F√ºr das Modell der sequentiellen Auswahl von Positionen ist die letzte die Grafik nach dem 62. Schritt, da der Suchzweig aufgrund des Fehlens einer freien Position in der 63. Zeile endet. Andererseits wird im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modell </font><font style="vertical-align: inherit;">die letzte Grafik nach dem 70. Schritt des Platzierens der K√∂nigin dargestellt, obwohl hier die durchschnittliche Anzahl der korrekt platzierten K√∂niginnen 89 erreicht, was 26 Schritte mehr ist als im sequentiellen Modell. Eine seltsame Ansicht der Graphen im </font><i><font style="vertical-align: inherit;">rand &amp; rand-</font></i><font style="vertical-align: inherit;"> Modell</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aufgrund der Tatsache, dass der Zeilenindex zuf√§llig aus den verbleibenden freien Zeilen ausgew√§hlt wird und sie daher zuf√§llig in der L√∂sungsmatrix verstreut sind. Ein Vergleich dieser beiden Zahlen zeigt, dass im sequentiellen Modell der Positionsauswahl der Variabilit√§tsbereich der Anzahl der freien Positionen h√∂her ist als im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modell </font><font style="vertical-align: inherit;">. Dies liegt an der Tatsache, dass bei regelm√§√üiger Auswahl diagonale Beschr√§nkungen freie Positionen in den verbleibenden Zeilen ungleichm√§√üig ausschlie√üen, was dazu f√ºhrt, dass in einigen Zeilen die Rate der Verringerung der Anzahl freier Positionen h√∂her ist als in anderen Zeilen.</font></font><br><br><img src="https://habrastorage.org/webt/9y/mn/m6/9ymnm6wo_jsazg8_u474pjngke8.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Reduzieren Sie die Anzahl der freien Positionen in den verbleibenden freien Linien nach der Platzierung der K√∂niginnen. Das Positionierungsmodell ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Gegensatz dazu werden bei zuf√§lliger Auswahl des freien Zeilenindex und des freien Spaltenindex die Positionen der Dame gleichm√§√üig √ºber den "Bereich" der Entscheidungsmatrix verteilt, wodurch die "durchschnittliche" Verringerungsrate der Anzahl freier Positionen in den verbleibenden Zeilen verringert wird. Unter Ber√ºcksichtigung der Funktionen des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithmus </font><font style="vertical-align: inherit;">wird dieser im Programm verwendet, um die Bildung des L√∂sungssuchzweigs </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fortzusetzen,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bis die </font><i><font style="vertical-align: inherit;">baseLevel-3-</font></i><font style="vertical-align: inherit;"> Ebene </font><i><font style="vertical-align: inherit;">erreicht ist</font></i><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist zu beachten, dass auch wenn die Auswahlalgorithmen ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet, rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) nicht so effektiv w√§re, m√ºssten wir bei der Entwicklung des Algorithmus noch eine andere Zufallsauswahlmethode anwenden. Dies ist auf die Aussage des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens-Completion-Problems zur√ºckzuf√ºhren</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn wir uns vorstellen, dass es einen bestimmten optimalen Algorithmus gibt, der das Problem l√∂st, dann erh√§lt ein solcher Algorithmus am Eingang immer eine bestimmte zuf√§llige Menge von Zeilen- und Spaltenindizes. Jedes Mal wird es einen neuen zuf√§lligen Satz von Zeilen- und Spaltenindizes aus einer Vielzahl von M√∂glichkeiten geben. Um den Algorithmus in einer solchen Vielfalt von Zufallszusammensetzungen "aufnehmen" zu k√∂nnen, muss der Algorithmus selbst auf der Basis einer Zufallsauswahl aufgebaut werden. Matching sollte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie ein Schl√ºssel zum Schloss sein</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Konstruieren wir den Algorithmus nach diesem Prinzip, so ergibt sich eine beliebige konsistente Zusammensetzung aus</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> K√∂niginnen werden als Ausgangsposition im Entscheidungssuchzyklus betrachtet. </font><font style="vertical-align: inherit;">Au√üerdem wird das Ziel nur darin bestehen, den Zweig der Suche nach einer L√∂sung fortzusetzen, bis eine L√∂sung f√ºr eine gegebene Zusammensetzung gefunden wird, oder es wird bewiesen, dass eine solche L√∂sung nicht existiert.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Ein Beispiel f√ºr die Verwendung der Minimalrisikoregel (n = 100) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Anfangsphase der L√∂sungsfindung ist die Auswahl des Index der freien Zeile oder des Index der Position in dieser Zeile nicht schwerwiegend, wenn die Anzahl der freien Positionen in den Zeilen nicht kritisch ist. Wenn jedoch in der letzten Phase die Anzahl der freien Positionen in einigen Zeilen 1 oder 2 betr√§gt, sollten Sie in diesem Fall einen anderen Auswahlalgorithmus ausw√§hlen. Auf dieser Ebene </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktionieren</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Zufallsauswahlalgorithmen </font><i><font style="vertical-align: inherit;">randSet &amp; randSet</font></i><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht mehr. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Grund, warum Zufallsauswahlalgorithmen nicht funktionieren, kann anhand des folgenden einfachen Beispiels erkl√§rt werden. Lassen Sie in einem Schritt das Problem f√ºr einen beliebigen Wert von n in den verbleibenden Zeilen </font><i><font style="vertical-align: inherit;">i </font></i><i><sub><font style="vertical-align: inherit;">1</font></sub></i><i><font style="vertical-align: inherit;"> , i </font></i><i><sub><font style="vertical-align: inherit;">2</font></sub></i><i><font style="vertical-align: inherit;"> , ..., i </font></i><i><sub><font style="vertical-align: inherit;">k</font></sub></i><font style="vertical-align: inherit;"> l√∂sen</font></font><i><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anzahl der offenen Stellen (in Klammern angegeben) betr√§gt: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (1), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (2), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (4), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (5), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (3), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (4)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usw. Wenn Sie nach dem Zufallsprinzip eine Zeile ausw√§hlen, jedoch nicht die Zeile i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in der nur eine freie Position vorhanden ist, kann dies zu einer Risikosituation f√ºhren, wenn diagonale Verbote in Bezug auf die Position der Dame in der ausgew√§hlten Zeile zur Schlie√üung der einzigen freien Position in der Zeile f√ºhren k√∂nnen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , was die L√∂sung zum Stillstand bringt. Von allen Zeilen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am anf√§lligsten und empfindlichsten f√ºr die Auswahl des Zeilenindex ist Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In solchen Situationen sollten Sie zuerst die Zeile ausw√§hlen, deren Status am kritischsten ist und ein Risiko f√ºr die L√∂sung des Problems darstellt. In der letzten Phase der Probleml√∂sung muss daher bei jedem Schritt die Position der Linie auf der Grundlage eines einfachen Algorithmus mit minimalem Risiko ausgew√§hlt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrachten wir der Klarheit halber als Beispiel f√ºr eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100 x 100-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Matrix </font><font style="vertical-align: inherit;">die letzte Stufe bei der Bildung einer echten L√∂sung nach dem 88. Schritt. Bis zum Abschluss der Aufgabe blieben 12 freie Zeilen, f√ºr die jeweils die Anzahl der freien Positionen gefunden wurde (die Zeilen sind in aufsteigender Reihenfolge der Anzahl der freien Positionen angeordnet):</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt 89 - 25 (1), 12 (2), 22 (2), 82 (2), 88 (2), 7 (3), 64 (3), 3 (4), 76 (4), 91 (4), 4 (5), 96 (5)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - gibt den Index einer freien Zeile und in Klammern die Anzahl der freien Positionen in dieser Zeile an. Gem√§√ü der minimalen Risikoregel wird im 89. Schritt der Probleml√∂sung die Zeile 25 ausgew√§hlt und die eine freie Position, die sich darin befindet. Als Ergebnis der Nachz√§hlung haben wir noch 11 freie Zeilen: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt-90 - 7 (2), 12 (2), 22 (2), 82 (2), 88 (2), 3 (3), 64 (3), 76 (3), 4 (4), 91 (4), 96 (4).</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen k√∂nnen, ist die Anzahl der freien Positionen in den ersten f√ºnf Zeilen gleich und gleich 2. Daher wird der Index einer der ersten drei Zeilen zuf√§llig ausgew√§hlt. </font><font style="vertical-align: inherit;">In diesem Fall wurde die 12. Reihe ausgew√§hlt und die Position der beiden verbleibenden in dieser Reihe, was zu minimalem Schaden f√ºhrt. </font><font style="vertical-align: inherit;">So haben wir im 91. Schritt der L√∂sungsbildung 10 freie Linien: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt-91 - 22 (1), 3 (2), 7 (2), 82 (2), 88 (2), 64 (3) 76 (3), 91 (3), 4 (4), 96 (4)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In diesem Schritt wird Zeile 22 ausgew√§hlt und die eine freie Position, die sich darin befindet. </font><font style="vertical-align: inherit;">In √§hnlicher Weise wurde die folgende Abfolge von Entscheidungen getroffen (Tabelle 1). </font><font style="vertical-align: inherit;">Die Indizes der ausgew√§hlten Zeilen sind fett gedruckt.</font></font><br><div class="scrollable-table"><table><caption> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabelle 1. Demonstration der Verwendung der Mindestrisikoregel ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100).</font></font></b> <br></caption><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schritt </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihe </font></font></th></tr><tr><td>  89 </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25 (1)</font></font></b> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12 (2) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 22 (2) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 82 (2) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7 (3) </font></font></td><td> 64(3) </td><td> 3(4) </td><td> 76(4) </td><td> 91(4) </td><td> 4(5) </td><td> 96(5) </td></tr><tr><td>  90 </td><td> 7(2) </td><td> <b>12(2)</b> </td><td> 22(2) </td><td> 82(2) </td><td> 3(3) </td><td> 64(3) </td><td> 76(3) </td><td> 4(4) </td><td> 91(4) </td><td> 96(4) </td><td></td></tr><tr><td>  91 </td><td> <b>22(1)</b> </td><td> 3(2) </td><td> 7(2) </td><td> 82(2) </td><td> 64(3) </td><td> 76(3) </td><td> 91(3) </td><td> 4(4) </td><td> 96(4) </td><td></td><td></td></tr><tr><td>  92 </td><td> <b>88(1)</b> </td><td> 3(2) </td><td> 7(2) </td><td> 82(2) </td><td> 91(2) </td><td> 64(3) </td><td> 76(3) </td><td> 4(4) </td><td> 96(4) </td><td></td><td></td></tr><tr><td>  93 </td><td> <b>3(1)</b> </td><td> 7(2) </td><td> 76(2) </td><td> 82(2) </td><td> 91(2) </td><td> 4(3) </td><td> 64(3) </td><td> 96(4) </td><td></td><td></td><td></td></tr><tr><td>  94 </td><td> <b>76(1)</b> </td><td> 4(2) </td><td> 7(2) </td><td> 82(2) </td><td> 91(2) </td><td> 64(3) </td><td> 96(4) </td><td></td><td></td><td></td><td></td></tr><tr><td>  95 </td><td> <b>91(1)</b> </td><td> 7(2) </td><td> 82(2) </td><td> 64(3) </td><td> 96(3) </td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  96 </td><td> <b>4(1)</b> </td><td> 82(1) </td><td> 7(2) </td><td> 64(3) </td><td> 96(3) </td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  97 </td><td> <b>7(1)</b> </td><td> 82(1) </td><td> 64(2) </td><td> 96(3) </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  98 </td><td> <b>82(1)</b> </td><td> 64(2) </td><td> 96(2) </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  99 </td><td> 64(1) </td><td> <b>96(1)</b> </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  100 </td><td> <b>64(1)</b> </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem speziellen Beispiel gab es in 11 von 12 F√§llen eine Situation, in der in der Liste der verbleibenden freien Zeilen mindestens eine Zeile vorhanden war, in der nur eine freie Position vorhanden war. Wenn wir nicht die Mindestrisikoregel anwenden, k√∂nnen wir nicht bis zum Ende kommen. Da ein ‚Äûfalscher Zug‚Äú bei der Auswahl eines Index einer freien Zeile zu einer Zerst√∂rung der einzigen freien Position f√ºhren w√ºrde, die sich in einer der verbleibenden freien Zeilen befand. Dies ist der Grund, warum die </font><font style="vertical-align: inherit;">L√∂sung in den letzten Phasen in eine Sackgasse </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ger√§t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wenn nur der Algorithmus </font><i><font style="vertical-align: inherit;">randSet x randSet</font></i><font style="vertical-align: inherit;"> oder </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand x rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet wird </font><font style="vertical-align: inherit;">, um eine vollst√§ndige L√∂sung zu erhalten.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist zu beachten, dass der Minimalrisiko-Algorithmus eine einfache allt√§gliche Bedeutung hat und h√§ufig bei der Entscheidungsfindung verwendet wird. </font><font style="vertical-align: inherit;">Zum Beispiel operiert der Arzt zuallererst den Patienten, dessen Zustand f√ºr das Leben am kritischsten ist, ebenso wie der Landwirt w√§hrend einer schweren D√ºrre, der versucht, die Ernte zu retten, zuerst die Bereiche w√§sserte, die sich in dem kritischsten Zustand befinden ...</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Analyse der Effizienz des Algorithmus </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Effizienz des Algorithmus f√ºr verschiedene Werte von n zu bewerten, wurde ein relativ langwieriges (in Bezug auf die Gesamtzeit) Rechenexperiment durchgef√ºhrt. Anf√§nglich wurde ein ziemlich schneller Algorithmus entwickelt, um Arrays von L√∂sungen nQueens Problem f√ºr einen beliebigen Wert von n zu erzeugen. Basierend auf diesem Programm wurden dann gro√üe Stichproben von L√∂sungen f√ºr eine Grundliste von n Werten gebildet. Die Gr√∂√üen der erhaltenen Proben von nQueens Probleml√∂sungen f√ºr verschiedene Werte von n waren gleich: (10) - 1000, (20, 30, ..., 90, 100, 200, 300, 500, 800, 1000, 3000, 5000, 10.000) - -10000, (30000, 50000, 80000) - 5000, (105, 3 * 105) - 3000, (5 * 105, 8 * 105, 106) - 1000, (3 * 106) - 300, ( 5 * 106) - 200, (10 * 106) - 100, (30 * 106) - 50, (50 * 106) - 30, (80 * 106, 100 * 106) - 20. Hier ist in Klammern eine Liste von n Werten angegeben, und ein doppelter Strich gibt die Stichprobengr√∂√üe der erhaltenen L√∂sungen an.Danach wurden zuf√§llige Zusammensetzungen beliebiger Gr√∂√üe auf der Basis jeder Probe von L√∂sungen gebildet. Beispielsweise wurden f√ºr jede von 10.000 L√∂sungen f√ºr n = 1000 100 zuf√§llige Zusammensetzungen beliebiger Gr√∂√üe gebildet. Das Ergebnis war eine Probe von einer Million Songs. Da jede Zusammensetzung beliebiger Gr√∂√üe, die auf der Grundlage einer vorhandenen L√∂sung gebildet wird, mindestens einmal bis zu einer vollst√§ndigen L√∂sung vervollst√§ndigt werden kann, bestand die Aufgabe darin, jede Zusammensetzung von der erzeugten Probe bis zu einer vollst√§ndigen L√∂sung auf der Grundlage des L√∂sungsalgorithmus f√ºr das n-Queens-Vervollst√§ndigungsproblem zu vervollst√§ndigen . Da im betrachteten Algorithmus bei jedem Schritt die korrekte Platzierung der Dame auf dem Schachbrett √ºberpr√ºft wird, kann dies hier grunds√§tzlich nicht der Fall seinAuf der Basis jeder Probe von L√∂sungen wurden zuf√§llige Zusammensetzungen beliebiger Gr√∂√üe gebildet. Beispielsweise wurden f√ºr jede von 10.000 L√∂sungen f√ºr n = 1000 100 zuf√§llige Zusammensetzungen beliebiger Gr√∂√üe gebildet. Das Ergebnis war eine Probe von einer Million Songs. Da jede Zusammensetzung beliebiger Gr√∂√üe, die auf der Grundlage einer vorhandenen L√∂sung gebildet wird, mindestens einmal bis zu einer vollst√§ndigen L√∂sung vervollst√§ndigt werden kann, bestand die Aufgabe darin, jede Zusammensetzung von der erzeugten Probe bis zu einer vollst√§ndigen L√∂sung auf der Grundlage des L√∂sungsalgorithmus f√ºr das n-Queens-Vervollst√§ndigungsproblem zu vervollst√§ndigen . Da im betrachteten Algorithmus bei jedem Schritt die korrekte Platzierung der Dame auf dem Schachbrett √ºberpr√ºft wird, kann dies hier grunds√§tzlich nicht der Fall seinAuf der Basis jeder Probe von L√∂sungen wurden zuf√§llige Zusammensetzungen beliebiger Gr√∂√üe gebildet. Beispielsweise wurden f√ºr jede von 10.000 L√∂sungen f√ºr n = 1000 100 zuf√§llige Zusammensetzungen beliebiger Gr√∂√üe gebildet. Das Ergebnis war eine Probe von einer Million Songs. Da jede Zusammensetzung beliebiger Gr√∂√üe, die auf der Grundlage einer vorhandenen L√∂sung gebildet wird, mindestens einmal bis zu einer vollst√§ndigen L√∂sung vervollst√§ndigt werden kann, bestand die Aufgabe darin, jede Zusammensetzung von der erzeugten Probe bis zu einer vollst√§ndigen L√∂sung auf der Grundlage des L√∂sungsalgorithmus f√ºr das n-Queens-Vervollst√§ndigungsproblem zu vervollst√§ndigen . Da im betrachteten Algorithmus bei jedem Schritt die korrekte Platzierung der Dame auf dem Schachbrett √ºberpr√ºft wird, kann dies hier grunds√§tzlich nicht der Fall seinEs wurden 100 zuf√§llige Zusammensetzungen beliebiger Gr√∂√üe gebildet. Das Ergebnis war eine Probe von einer Million Songs. Da jede Zusammensetzung beliebiger Gr√∂√üe, die auf der Grundlage einer vorhandenen L√∂sung gebildet wird, mindestens einmal bis zu einer vollst√§ndigen L√∂sung vervollst√§ndigt werden kann, bestand die Aufgabe darin, jede Zusammensetzung von der erzeugten Probe bis zu einer vollst√§ndigen L√∂sung auf der Grundlage des L√∂sungsalgorithmus f√ºr das n-Queens-Vervollst√§ndigungsproblem zu vervollst√§ndigen . Da im betrachteten Algorithmus bei jedem Schritt die korrekte Platzierung der Dame auf dem Schachbrett √ºberpr√ºft wird, kann dies hier grunds√§tzlich nicht der Fall seinEs wurden 100 zuf√§llige Zusammensetzungen beliebiger Gr√∂√üe gebildet. Das Ergebnis war eine Probe von einer Million Songs. Da jede Zusammensetzung beliebiger Gr√∂√üe, die auf der Grundlage einer vorhandenen L√∂sung gebildet wird, mindestens einmal bis zu einer vollst√§ndigen L√∂sung vervollst√§ndigt werden kann, bestand die Aufgabe darin, jede Zusammensetzung von der erzeugten Probe bis zu einer vollst√§ndigen L√∂sung auf der Grundlage des L√∂sungsalgorithmus f√ºr das n-Queens-Vervollst√§ndigungsproblem zu vervollst√§ndigen . Da im betrachteten Algorithmus bei jedem Schritt die korrekte Platzierung der Dame auf dem Schachbrett √ºberpr√ºft wird, kann dies hier grunds√§tzlich nicht der Fall seindann bestand die Aufgabe darin, jede Komposition von der generierten Stichprobe, basierend auf dem L√∂sungsalgorithmus f√ºr das n-Queens-Abschlussproblem, zu einer vollst√§ndigen L√∂sung zu vervollst√§ndigen. Da im betrachteten Algorithmus bei jedem Schritt die korrekte Platzierung der Dame auf dem Schachbrett √ºberpr√ºft wird, kann dies hier grunds√§tzlich nicht der Fall seinAnschlie√üend bestand die Aufgabe darin, jede Komposition von der generierten Stichprobe auf der Grundlage des L√∂sungsalgorithmus f√ºr das n-Queens-Abschlussproblem zu einer vollst√§ndigen L√∂sung zu vervollst√§ndigen. Da im betrachteten Algorithmus bei jedem Schritt die korrekte Platzierung der Dame auf dem Schachbrett √ºberpr√ºft wird, kann dies hier grunds√§tzlich nicht der Fall sein</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falsch positive</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entscheidungen (d. H. Falsche Entscheidungen, die wir f√§lschlicherweise f√ºr richtig halten). Es kann jedoch auch zu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsch-negativen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L√∂sungen kommen - f√ºr den Fall, dass eine auf der Basis der vorhandenen L√∂sung gebildete Zusammensetzung vom Programm erst vervollst√§ndigt wird, wenn die L√∂sung vollst√§ndig ist (obwohl wir wissen, dass alle Zusammensetzungen eine L√∂sung haben). Bei der Durchf√ºhrung eines Computerexperiments in einem derart gro√üen Bereich von n Werten haben wir uns folgende Ziele gesetzt: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Bestimmung der zeitlichen Komplexit√§t des Algorithmus, </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Bestimmung der Wahrscheinlichkeit von falsch negativen L√∂sungen f√ºr verschiedene Werte von n, </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) Bestimmung der H√§ufigkeit, mit der das Back Tracking-Verfahren angewendet wird verschiedene Werte von n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ergebnisse eines solchen Berechnungsexperiments sind in Tabelle 2 dargestellt.</font></font><br><div class="scrollable-table"><table><caption> <b> 2.         n.</b> <br> <i>n</i> ‚Äì   ; <i>m</i> ‚Äì   ; t <sub>mean</sub> , t <sub>min</sub> , t <sub>max</sub> ‚Äì ,     ; t90 <sub>mean</sub> ‚Äì   ,    10%    ; FalseNeg( FalseNegative) ‚Äì  ,      ; <i>t <sub>row</sub> = t <sub>mean</sub> *10 <sup>6</sup> / n</i> ,   10 <sup>6</sup>   ,            <i>nxn</i> . <br></caption><tbody><tr><th>  n </th><th> m </th><th> t <sub>mean</sub> </th><th> t90 <sub>mean</sub> </th><th> t <sub>min</sub> </th><th> t <sub>max</sub> </th><th> FalseNeg </th><th> t <sub>row</sub> </th></tr><tr><td>  10 </td><td>  5000 </td><td> <b>0.001010</b> </td><td> 0.000532 </td><td> 0.000168 </td><td> 0.080673 </td><td>  2 </td><td> 1.0102 </td></tr><tr><td>  20 </td><td>  10 <sup>5</sup> </td><td> <b>0.003589</b> </td><td> 0.001809 </td><td> 0.000197 </td><td> 0.363096 </td><td>  5 </td><td> 1.7945 </td></tr><tr><td>  30 </td><td>  10 <sup>5</sup> </td><td> <b>0.008025</b> </td><td> 0.003793 </td><td> 0.000244 </td><td> 0.495716 </td><td>  10 </td><td> 2.6752 </td></tr><tr><td>  40 </td><td>  10 <sup>5</sup> </td><td> <b>0.014323</b> </td><td> 0.009127 </td><td> 0.000252 </td><td> 0.965817 </td><td>  7 </td><td> 3.5807 </td></tr><tr><td>  50 </td><td>  10 <sup>5</sup> </td><td> <b>0.005357</b> </td><td> 0.003589 </td><td> 0.000313 </td><td> 0.441711 </td><td>  9 </td><td> 10.7146 </td></tr><tr><td>  60 </td><td>  10 <sup>5</sup> </td><td> <b>0.005991</b> </td><td> 0.004103 </td><td> 0.000340 </td><td> 0.013738 </td><td>  10 </td><td> 9.9852 </td></tr><tr><td>  70 </td><td>  10 <sup>5</sup> </td><td> <b>0.006533</b> </td><td> 0.004566 </td><td> 0.000368 </td><td> 0.583897 </td><td>  8 </td><td> 9.3328 </td></tr><tr><td>  80 </td><td>  10 <sup>5</sup> </td><td> <b>0.006975</b> </td><td> 0.004987 </td><td> 0.000394 </td><td> 0.635676 </td><td>  7 </td><td> 8.7187 </td></tr><tr><td>  90 </td><td>  10 <sup>5</sup> </td><td> <b>0.006912</b> </td><td> 0.004763 </td><td> 0.000393 </td><td> 1.012710 </td><td>  4 </td><td> 7.6840 </td></tr><tr><td>  100 </td><td>  10 <sup>5</sup> </td><td> <b>0.007264</b> </td><td> 0.005107 </td><td> 0.000419 </td><td> 0.692387 </td><td>  4 </td><td> 7.2641 </td></tr><tr><td>  300 </td><td>  10 <sup>5</sup> </td><td> <b>0.013518</b> </td><td> 0.009496 </td><td> 0.000986 </td><td> 3.349766 </td><td>  3 </td><td> 4.5060 </td></tr><tr><td>  500 </td><td>  10 <sup>5</sup> </td><td> <b>0.028194</b> </td><td> 0.014554 </td><td> 0.001541 </td><td> 4.558749 </td><td>  2 </td><td> 5.6388 </td></tr><tr><td>  800 </td><td>  10 <sup>5</sup> </td><td> <b>0.049385</b> </td><td> 0.022735 </td><td> 0.002367 </td><td> 6.192782 </td><td>  1 </td><td> 6.1731 </td></tr><tr><td>  1000 </td><td> <b>10 <sup>6</sup></b> </td><td> <b>0.062157</b> </td><td> 0.027727 </td><td> 0.002943 </td><td> 8.015123 </td><td>  0 </td><td> 6.2156 </td></tr><tr><td>  3000 </td><td>  10 <sup>5</sup> </td><td> <b>0.177290</b> </td><td> 0.088507 </td><td> 0.008537 </td><td> 16.713140 </td><td>  0 </td><td> 5.9097 </td></tr><tr><td>  5000 </td><td>  10 <sup>5</sup> </td><td> <b>0.159239</b> </td><td> 0.136047 </td><td> 0.014224 </td><td> 42.181080 </td><td>  0 </td><td> 3.1849 </td></tr><tr><td>  10 <sup>4</sup> </td><td>  10 <sup>5</sup> </td><td> <b>0.321003</b> </td><td> 0.270927 </td><td> 0.028594 </td><td> 79.321174 </td><td>  0 </td><td> 3.2100 </td></tr><tr><td> 3*10 <sup>4</sup> </td><td>  10 <sup>4</sup> </td><td> <b>0.968795</b> </td><td> 0.651618 </td><td> 0.084936 </td><td> 139.28827 </td><td>  0 </td><td> 3.2293 </td></tr><tr><td> 5*10 <sup>4</sup> </td><td>  5000 </td><td> <b>1.147196</b> </td><td> 0.864045 </td><td> 0.143005 </td><td> 154.38225 </td><td>  0 </td><td> 2.2944 </td></tr><tr><td> 8*10 <sup>4</sup> </td><td>  4000 </td><td> <b>2.112079</b> </td><td> 1.215612 </td><td> 0.229532 </td><td> 204.27321 </td><td>  0 </td><td> 2.6401 </td></tr><tr><td>  10 <sup>5</sup> </td><td>  2000 </td><td> <b>2.253118</b> </td><td> 1.433197 </td><td> 0.290566 </td><td> 224.34623 </td><td>  0 </td><td> 2.2531 </td></tr><tr><td> 3*10 <sup>5</sup> </td><td>  2000 </td><td> <b>4.330649</b> </td><td> 3.181905 </td><td> 0.990932 </td><td> 340.29584 </td><td>  0 </td><td> 1.4435 </td></tr><tr><td> 5*10 <sup>5</sup> </td><td>  2000 </td><td> <b>5.985339</b> </td><td> 4.532205 </td><td> 1.488209 </td><td> 382.20016 </td><td>  0 </td><td> 1.1971 </td></tr><tr><td> 8*10 <sup>5</sup> </td><td>  2000 </td><td> <b>8.297512</b> </td><td> 6.554302 </td><td> 2.902425 </td><td> 75.87513 </td><td>  0 </td><td> 1.0372 </td></tr><tr><td>  10 <sup>6</sup> </td><td>  1000 </td><td> <b>11.376632</b> </td><td> 7.932194 </td><td> 2.954968 </td><td> 510.6265 </td><td>  0 </td><td> 1.1377 </td></tr><tr><td> 3*10 <sup>6</sup> </td><td>  400 </td><td> <b>23.138609</b> </td><td> 18.521503 </td><td> 10.433580 </td><td> 122.7597 </td><td>  0 </td><td> 0.7713 </td></tr><tr><td> 5*10 <sup>6</sup> </td><td>  300 </td><td> <b>33.103386</b> </td><td> 28.057816 </td><td> 14.937556 </td><td> 155.0890 </td><td>  0 </td><td> 0.6621 </td></tr><tr><td> 10*10 <sup>6</sup> </td><td>  200 </td><td> <b>61.444001</b> </td><td> 52.269241 </td><td> 31.624475 </td><td> 228.3087 </td><td>  0 </td><td> 0.6144 </td></tr><tr><td> 30*10 <sup>6</sup> </td><td>  50 </td><td> <b>149.71717</b> </td><td> 136.66441 </td><td> 84.556686 </td><td> 352.0534 </td><td>  0 </td><td> 0.4991 </td></tr><tr><td> 50*10 <sup>6</sup> </td><td>  40 </td><td> <b>253.86220</b> </td><td> 228.93732 </td><td> 105.37934 </td><td> 558.4629 </td><td>  0 </td><td> 0.5077 </td></tr><tr><td> 80*10 <sup>6</sup> </td><td>  30 </td><td> <b>372.29294</b> </td><td> 341.56397 </td><td> 250.80182 </td><td> 728.4806 </td><td>  0 </td><td> 0.4654 </td></tr><tr><td> 100*10 <sup>6</sup> </td><td>  20 </td><td> <b>508.43573</b> </td><td> 474.04890 </td><td> 354.80864 </td><td> 831.3753 </td><td>  0 </td><td> 0.5084 </td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die allgemeine Schlussfolgerung, die auf der Grundlage der erhaltenen Ergebnisse gezogen werden kann, lautet wie folgt: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Der Algorithmus arbeitet schnell genug. Beispielsweise betr√§gt die durchschnittliche Kompilierungszeit einer beliebigen Komposition f√ºr ein Schachbrett der Gr√∂√üe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000 x 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die auf der Grundlage von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einer Million</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rechenexperimenten erhalten wurde, 0,062157 Sekunden. Das hei√üt, wenn die Komposition eine L√∂sung hat, wird diese sofort nach dem Dr√ºcken der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Enter"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Taste gefunden </font><font style="vertical-align: inherit;">. Die durchschnittliche Kompilierungszeit einer beliebigen Komposition f√ºr alle Werte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Bereich von 7 bis 30.000 √ºberschreitet eine Sekunde nicht.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) In jeder Probe gibt es ungef√§hr 10% der Zusammensetzungen, die viel mehr Zeit ben√∂tigen, um fertig zu werden. Solche Zusammensetzungen bilden im Verteilungshistogramm einen langen rechten Schwanz. Wenn wir diese 10% der Zusammensetzungen ausschlie√üen und Berechnungen f√ºr die restlichen 90% der L√∂sungen durchf√ºhren, ist die Berechnungszeit ( </font><i><sub><font style="vertical-align: inherit;">Mittelwert</font></sub></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> t90</font></font><sub><font style="vertical-align: inherit;"></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) viel k√ºrzer. Bei einem Schachbrett von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000 x 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> betr√§gt die durchschnittliche Z√§hlzeit beispielsweise 0,027727 Sekunden, was dem 2,24-fachen der durchschnittlichen Zeit entspricht, die auf der Grundlage der gesamten Stichprobe ermittelt wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) F√ºr Werte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n ‚â§ 800</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gab es in der Stichprobe von Zusammensetzungen diejenigen, die bis zu einer vollst√§ndigen L√∂sung nicht vervollst√§ndigt werden konnten. Dies ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsch negativ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entscheidungen. </font><font style="vertical-align: inherit;">Der Algorithmus konnte diese Kompositionen </font><font style="vertical-align: inherit;">innerhalb der im Programm festgelegten Grenzen, die es erm√∂glichten, das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Back-Tracking-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verfahren </font><font style="vertical-align: inherit;">bis zu 1000-mal </font><font style="vertical-align: inherit;">durchzuf√ºhren </font><font style="vertical-align: inherit;">, nicht vervollst√§ndigen. Sie wurden f√§lschlicherweise als negative Zusammensetzungen klassifiziert, d.h. diejenigen, die keine L√∂sung haben. Die Anzahl solcher </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsch-negativen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L√∂sungen ist unbedeutend und ihr Anteil an der Stichprobe betr√§gt weniger als 0,0001. Wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zunimmt </font><font style="vertical-align: inherit;">, nimmt ferner der Anteil der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsch negativen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L√∂sungen ab. F√ºr alle Werte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; 800 gab es in dieser Reihe von Rechnerexperimenten keinen einzigen Fall von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsch negativen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L√∂sungen. Es ist jedoch offensichtlich, dass die M√∂glichkeit des Auftretens von </font><i><font style="vertical-align: inherit;">falschem Negativ</font></i><font style="vertical-align: inherit;"> nicht ausgeschlossen wird, wenn die Probengr√∂√üe um ein Vielfaches erh√∂ht </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√∂sungen, obwohl die Wahrscheinlichkeit eines solchen Ereignisses sehr gering sein wird. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zeitliche Komplexit√§t des Algorithmus</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Fig. 7 zeigt eine graphische Darstellung von √Ñnderungen in der durchschnittlichen Aufnahmedauer von Zufallszusammensetzungen f√ºr verschiedene Werte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><img src="https://habrastorage.org/webt/fe/lj/zy/feljzywqkqijg-0pftjholzx3es.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Die Abh√§ngigkeit der durchschnittlichen Erntezeit ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) zuf√§lliger Zusammensetzungen von der Gr√∂√üe ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) der Entscheidungsmatrix. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf der Abszissenachse </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist der</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dezimale Logarithmus des Wertes von </font><i><font style="vertical-align: inherit;">n und</font></i><font style="vertical-align: inherit;"> auf der Ordinatenachse </font><font style="vertical-align: inherit;">der um das 1000-fache erh√∂hte Logarithmus der mittleren Z√§hlzeit aufgetragen. Zur Verdeutlichung zeigt die Figur auch die gepunktete Linie der Diagonale des Quadranten. Es ist zu sehen, dass die Erntezeit linear mit einer Zunahme von n zunimmt. √úber den gesamten Bereich von n-Werten von 50 bis 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 bilden die</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> experimentellen Z√§hlzeiten eine gerade Linie, die mit einer relativ hohen Korrelation ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = 0,9998</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) durch die lineare Regressionsgleichung </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">log (1000 * t) = - 0,628927 + 0,781568 * log (n) beschrieben wird.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine leichte Abweichung vom allgemeinen Trend ist nur f√ºr die Werte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (10, ... 49)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> typisch </font><font style="vertical-align: inherit;">, da zur L√∂sung des Problems nur der f√ºnfte Berechnungsblock in diesem Bereich verwendet wird, dessen Algorithmus sich erheblich von der Funktionsweise der Algorithmen des ersten und dritten Blocks unterscheidet. In der erhaltenen Abh√§ngigkeit ist der lineare Koeffizient ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,781568</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) kleiner als Eins, was dazu f√ºhrt, dass mit zunehmendem n die Regressionslinie und die Diagonale des Quadranten auseinander laufen. Um den Grund f√ºr eine solche Diskrepanz anstelle der Anfangszeit klar zu erkl√§ren, betrachten wir die durchschnittliche Zeit, die f√ºr den Ort einer Dame auf einer Zeile erforderlich ist, d. H. dividiere die durchschnittliche Z√§hlzeit durch </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wir nennen einen solchen Indikator die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reduzierte Zeit.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn sich die reduzierte Zeit mit zunehmendem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht √§ndert </font><font style="vertical-align: inherit;">, ist eine solche L√∂sung </font><font style="vertical-align: inherit;">offensichtlich </font><font style="vertical-align: inherit;">linear ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (n)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Wie aus Fig. 8 ersichtlich ist, zeigt diese eine Auftragung des Logarithmus der reduzierten Zeit</font></font><br><br><img src="https://habrastorage.org/webt/rm/zo/i5/rmzoi5vzkips2kreyaltswbzivm.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 Die Abh√§ngigkeit der Durchschnittszeit ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">row</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), die erforderlich ist, damit sich die Dame auf einer beliebigen Linie befindet, von der Gr√∂√üe ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) der Entscheidungsmatrix. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tRow</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), erh√∂ht um das 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6-</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fache vom Logarithmus der Gr√∂√üe der L√∂sungsmatrix im Bereich von n von 50 bis 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , verringert sich die reduzierte Zeit mit zunehmendem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn die reduzierte Zeit f√ºr </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 50</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10,7146 √ó 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äì6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekunden </font><font style="vertical-align: inherit;">betr√§gt </font><font style="vertical-align: inherit;">, wird die entsprechende Zeit f√ºr n = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 um</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> das 21-fache reduziert und betr√§gt 0,5084 √ó 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äì6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekunden. Ein solches Verhalten des Algorithmus erscheint auf den ersten Blick irrt√ºmlich, da es keine objektiven Gr√ºnde gibt, warum der Algorithmus ihn f√ºr kleine Werte von n als langsamer als f√ºr gro√üe Werte ansieht. Es liegt jedoch kein Fehler vor, und dies ist eine objektive Eigenschaft dieses Algorithmus. Dies liegt an der Tatsache, dass dieser Algorithmus aus drei Algorithmen besteht, die mit unterschiedlichen Geschwindigkeiten arbeiten. Dar√ºber hinaus √§ndert sich die Anzahl der von jedem dieser Algorithmen verarbeiteten Zeilen mit zunehmendem Wert von n. Aus diesem Grund nimmt die Z√§hlzeit im anf√§nglichen Wertebereich n = (10, 20, 30, 40) zu, da alle Berechnungen in diesem kleinen Bereich nur auf der Grundlage des f√ºnften Verfahrensblocks durchgef√ºhrt werden, der sehr effizient, jedoch nicht so schnell wie arbeitet erster Block von Prozeduren. Angesichts der Zeit, die erforderlich ist, um die Dame in einer Zeile zu positionieren,nimmt mit zunehmender Gr√∂√üe des Schachbretts ab, so kann die zeitliche Komplexit√§t dieses Algorithmus als abnehmend - linear bezeichnet werden.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die H√§ufigkeit, mit der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Back Tracking (BT) verwendet wurde</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In allen F√§llen eines Computerexperiments haben wir die Anzahl der F√§lle mithilfe des BT-Verfahrens bei der L√∂sung jedes Problems verfolgt. Es wurde eine kumulative Zusammenfassung aller F√§lle der Verwendung von BT erstellt, unabh√§ngig davon, auf welche Basisebene bei der Suche nach einer L√∂sung zur√ºckgekehrt wurde. Dies gab uns die M√∂glichkeit, f√ºr jede Stichprobe den Anteil der Entscheidungen zu bestimmen, bei denen das BT-Verfahren noch nie angewendet wurde. Abbildung 9 zeigt</font></font><br><br><img src="https://habrastorage.org/webt/_l/5t/h5/_l5th5fsxg_u7aw_dei4o3b5h2w.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9. Der Anteil der Entscheidungen in der Stichprobe, bei denen das Verfahren zur R√ºckverfolgung noch nie verwendet wurde, in einem </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diagramm, das zeigt, wie sich der Anteil der F√§lle der L√∂sung √§ndert, ohne das BT-Verfahren ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zero Back Tracking</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) mit zunehmendem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n zu verwenden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es ist zu erkennen, dass im Wertebereich </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (7, ..., 100000)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Anzahl der L√∂sungen, in denen das BT-Verfahren noch nie angewendet wurde, 35% √ºberschreitet. Dar√ºber hinaus </font><font style="vertical-align: inherit;">√ºbersteigt </font><font style="vertical-align: inherit;">im Wertebereich </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (320, ..., 22500)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Anzahl solcher F√§lle 50%. Die effektivsten Ergebnisse wurden f√ºr ein Schachbrett mit einer Gr√∂√üe von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5000 x 5000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erzielt </font><font style="vertical-align: inherit;">, bei dem in einer Stichprobe von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kompositionen in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">61,92% der</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√§lle </font><i><font style="vertical-align: inherit;">‚Äûdeterministisch‚Äú </font></i><i><font style="vertical-align: inherit;">vorgegangen wurde</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√∂sen eines </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht deterministischen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Problems, weil In </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">61,92% der</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√§lle wurde das </font><font style="vertical-align: inherit;">BT-Verfahren </font><font style="vertical-align: inherit;">nie angewendet. In den √ºbrigen L√∂sungen wurde in 21,87% der F√§lle das BT-Verfahren einmal, in 9,07% der F√§lle zweimal und in 3,77% der F√§lle dreimal angewendet. Zusammen macht dies 96,63% der F√§lle aus. Die Tatsache, dass nach dem Wert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 5000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Anzahl der F√§lle, in denen das Konfigurationsproblem ohne Verwendung der BT-Prozedur gel√∂st wird, allm√§hlich abnimmt, h√§ngt mit dem ausgew√§hlten Modell f√ºr die Auswahl der Grenzwerte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel3 zusammen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sie k√∂nnen diese Parameter √§ndern und die Anzahl der L√∂sungen erh√∂hen, ohne das BT-Verfahren zu verwenden. Dies f√ºhrt jedoch zu einer Verl√§ngerung der Rechenzeit, da die Beteiligung des f√ºnften Blocks an der Funktionsweise des Algorithmus zunimmt.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Histogramm der Verteilung der Zeiterfassung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In 10 ist f√ºr einen Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein Histogramm der Verteilung der Entnahmezeit f√ºr eine Million Entscheidungen dargestellt. Die nicht ganz gew√∂hnliche Ansicht des Verteilungshistogramms (das h√∂chstwahrscheinlich der Nachtsilhouette hoher Geb√§ude √§hnelt) ist nicht mit einem Fehler bei der Auswahl der L√§nge oder Anzahl der Intervalle verbunden. Dies ist eine nat√ºrliche Eigenschaft dieses Algorithmus. Zu verstehen</font></font><br><br><img src="https://habrastorage.org/webt/cm/ii/z9/cmiiz94kbp7hxfss1aqzkejd09o.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. Ein Histogramm der Zusammenstellungszeit von Kompositionen beliebiger Gr√∂√üe. ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stichprobengr√∂√üe = 1.000.000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ber√ºcksichtigen Sie, warum das Histogramm eine solche Form hat, die Verteilung der Aufnahmezeit f√ºr Zusammensetzungen mit derselben Gr√∂√üe. Als Beispiel werden wir aus der ersten Stichprobe alle Kompositionen ausw√§hlen, deren Gr√∂√üe 800 betr√§gt. In einer Stichprobe von einer Million waren 998 solcher Kompositionen enthalten. Fig. 11 zeigt ein Histogramm der Verteilung der Z√§hlzeit f√ºr diese Probe. Aus der Abbildung ist ersichtlich, dass die Verteilung aus sechs separaten Histogrammen mit abnehmender Gr√∂√üe besteht.</font></font><br><br><img src="https://habrastorage.org/webt/ku/70/xa/ku70xadamrocfeimg3zpvyvurgu.jpeg"><br>  Abb.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. Ein Histogramm der Kompilierungszeit von Kompositionen gleicher Gr√∂√üe (k = 800). ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stichprobengr√∂√üe = 998</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Grund, warum die Kompilierungszeit von 998 Kompositionen, in denen jeweils 800 K√∂niginnen zuf√§llig verteilt sind, in 6 Gruppen "gruppiert" wird, weil das </font><i><font style="vertical-align: inherit;">Back-Tracking-</font></i><font style="vertical-align: inherit;"> Verfahren verwendet wird</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Das erste Histogramm in der Abbildung mit der maximalen Stichprobengr√∂√üe zeigt die L√∂sungen, bei denen das BT-Verfahren noch nie angewendet wurde. Dies ist eine Gruppe der schnellsten L√∂sungen. Das zweite Histogramm, das wesentlich kleiner ist als das erste, sind diejenigen L√∂sungen, bei denen das BT-Verfahren nur einmal verwendet wurde. Daher ist die Entscheidungszeit in dieser Gruppe etwas l√§nger als in der ersten. Dementsprechend wurde in der dritten Gruppe die BT-Prozedur zweimal verwendet, in der vierten - dreimal usw., d.h. Entscheidungen, bei denen das BT-Verfahren wiederholt angewendet wurde, wurden √ºber einen l√§ngeren Zeitraum durchgef√ºhrt. Solche L√∂sungen bilden den langen rechten Schwanz der gew√ºnschten Verteilung. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falsch Negative L√∂sungen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Teilen wir alle m√∂glichen Kompositionen durch einen beliebigen Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu positiv und negativ, dann gibt es unter den positiven Kompositionen diejenigen, die dieser Algorithmus als negativ einstufen kann. Dies liegt an der Tatsache, dass der Algorithmus innerhalb der durch die Suchparameter festgelegten Grenzen nicht den richtigen Weg finden kann, um solche Kompositionen zu vervollst√§ndigen. Wie die experimentellen Ergebnisse (Tabelle 2) zeigen, √ºberschreitet die Anzahl solcher F√§lle nicht 0,0001 der Probengr√∂√üe und der Wert dieses Fehlers nimmt mit zunehmendem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n ab</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Zus√§tzlich gab es f√ºr alle Werte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n&gt; 800</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keinen einzigen Fall einer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsch negativen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L√∂sung. Selbst eine Erh√∂hung des Stichprobenumfangs auf eine Million f√ºr </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºhrte nicht zu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">False Negative</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entscheidungen. </font><font style="vertical-align: inherit;">Das Ergebnis erlaubt es uns, die folgende Regel zur L√∂sung des Problems zu formulieren: ‚ÄûJede zuf√§llige Zusammensetzung von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Damen, die konsistent auf einem beliebigen Schachbrett der Gr√∂√üe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn verteilt ist,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann vervollst√§ndigt werden, bis eine vollst√§ndige L√∂sung </font><i><font style="vertical-align: inherit;">vorliegt</font></i><font style="vertical-align: inherit;"> , oder es wird entschieden, dass diese Zusammensetzung negativ ist und nicht abgeschlossen sein. </font><font style="vertical-align: inherit;">Die Wahrscheinlichkeit, eine solche Entscheidung zu treffen, √ºberschreitet </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,0001 nicht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mit zunehmender Gr√∂√üe eines Schachbretts sinkt die Wahrscheinlichkeit, falsche Entscheidungen zu treffen. </font><font style="vertical-align: inherit;">Die zeitliche Komplexit√§t des Algorithmus ist linear. ‚Äú</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Schlussfolgerungen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird ein Algorithmus vorgestellt, der es erm√∂glicht, in linearer Zeit das gesamte </font><i><font style="vertical-align: inherit;">Mengenproblem</font></i><font style="vertical-align: inherit;"> zu l√∂sen, bis eine vollst√§ndige L√∂sung einer zuf√§lligen Zusammensetzung von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> K√∂niginnen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorliegt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die konsistent auf einem Schachbrett beliebiger Gr√∂√üe </font><i><font style="vertical-align: inherit;">nxn verteilt ist</font></i><font style="vertical-align: inherit;"> . Dar√ºber hinaus wird f√ºr jede Zusammensetzung von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> K√∂niginnen (1 </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚â§ k &lt;n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) eine L√∂sung bereitgestellt, falls vorhanden, oder es wird eine Entscheidung getroffen, dass diese Zusammensetzung nicht vervollst√§ndigt werden kann. Die Wahrscheinlichkeit eines Fehlers bei einer solchen Entscheidung √ºberschreitet nicht 0,0001 und dieser Wert nimmt mit zunehmender Gr√∂√üe eines Schachbretts ab. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Die Funktionsweise dieses Algorithmus basiert auf der Verwendung von zwei wichtigen Regeln:</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) In der letzten Phase der Probleml√∂sung wird aus allen verbleibenden freien Positionen eine ausgew√§hlt, f√ºr die die Anzahl der freien Positionen minimal ist ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minimale Risikoregel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Dies minimiert die Risiken, die mit der M√∂glichkeit verbunden sind, die letzten offenen Positionen in einigen der verbleibenden Linien auszuschlie√üen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Von allen vakanten Positionen in der betreffenden Linie wird diejenige Position ausgew√§hlt, die den freien Positionen in den verbleibenden freien Linien einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minimalen Schaden zuf√ºgt (Regel des minimalen Schadens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Mit " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minimaler Schaden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " ist die Auswahl einer solchen Position in einer Zeile gemeint, die die geringste Menge an freien Positionen in allen verbleibenden freien Zeilen ausschlie√üt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Es wurde festgestellt, dass als Ergebnis der Operation dieses Algorithmus die durchschnittliche Zeit, die erforderlich ist, um die K√∂nigin auf eine Zeile zu setzen, mit einer Zunahme des Werts von n abnimmt. Die durchschnittliche Zeit, die erforderlich ist, um die Dame in einer Zeile zu platzieren, wenn n 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist, ist 21-mal k√ºrzer als die entsprechende Zeit f√ºr den Fall n = 50. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Es wurde festgestellt, dass im Wertebereich </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (7, ..., 100000) die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anzahl der L√∂sungen, in denen das R√ºckverfolgungsverfahren noch nie angewendet wurde, 35% √ºbersteigt. Dar√ºber hinaus </font><font style="vertical-align: inherit;">√ºbersteigt </font><font style="vertical-align: inherit;">im Wertebereich </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (320, ..., 22500)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Anzahl solcher F√§lle 50%, was die hohe Effizienz dieses Algorithmus anzeigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Ein Modell f√ºr die Organisation des </font><i><font style="vertical-align: inherit;">Back Tracking-</font></i><font style="vertical-align: inherit;"> Verfahrens wird vorgeschlagen.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, basierend auf der Trennung der Reihenfolge der Entscheidungsschritte auf den Grundebenen. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Level bedeutet einen bestimmten Entscheidungsschritt mit einer bestimmten Anzahl von K√∂niginnen, die korrekt platziert wurden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Zur Berechnung der Werte der zweiten und dritten Grundstufe in Abh√§ngigkeit von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n werden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Regressionsformeln angegeben </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Die Ergebnisse einer vergleichenden Analyse von zwei Zufallsauswahlmethoden, die als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand bezeichnet werden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , werden </font><i><font style="vertical-align: inherit;">vorgestellt</font></i><font style="vertical-align: inherit;"> . Der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Algorithmus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hat sich als schnell, aber unh√∂flich </font><i><font style="vertical-align: inherit;">erwiesen</font></i><font style="vertical-align: inherit;"> . Daher ist seine Verwendung beim Erreichen der zweiten Grundstufe begrenzt. Danach wird der </font><i><font style="vertical-align: inherit;">Rand &amp; Rand-</font></i><font style="vertical-align: inherit;"> Algorithmus verwendet.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die nicht so schnell durchgef√ºhrt wird, sondern K√∂niginnen effektiver auf ein Schachbrett legt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Es wird ein effektiver Algorithmus zur √úberpr√ºfung der Korrektheit der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens-Probleml√∂sung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angegeben </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dieses Programm dient auch dazu, die Richtigkeit einer zuf√§lligen Zusammensetzung beliebiger Gr√∂√üe zu √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Das Programm arbeitet schnell genug. </font><font style="vertical-align: inherit;">Beispielsweise betr√§gt die zur Validierung einer aus 5 Millionen Positionen bestehenden L√∂sung erforderliche Zeit 0,85 Sekunden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Kommentare </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Wie zu Beginn des Artikels angegeben, wurden Studien im Bereich von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werten </font><font style="vertical-align: inherit;">von 7 bis 100 Millionen durchgef√ºhrt. Das Programm wurde jedoch in einem gr√∂√üeren Bereich von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werten getestet </font><font style="vertical-align: inherit;">, bis zu einer Milliarde. In letzterem Fall musste das Programm allerdings aufgrund der Gr√∂√üe der Arrays leicht angepasst werden. Wenn die Gr√∂√üe des RAM dies zul√§sst, ist es daher m√∂glich, Berechnungen f√ºr gro√üe Werte von n durchzuf√ºhren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Die Werte der Basisindikatoren sowie die Grenzwerte f√ºr die Anzahl der Wiederholungen auf verschiedenen Ebenen wurden optimiert, um das Problem im gesamten Forschungsbereich zu l√∂sen. Sie k√∂nnen in einem kleineren Bereich ge√§ndert werden und verk√ºrzen die Z√§hlzeit. Es ist wichtig, den Anteil der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsch negativen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L√∂sungen </font><font style="vertical-align: inherit;">nicht zu erh√∂hen </font><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. In diesem Artikel habe ich die Zeit </font><font style="vertical-align: inherit;">zum </font><font style="vertical-align: inherit;">Dr√ºcken der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eingabetaste</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als Zeitma√ü verwendet, um zu bewerten, wie schnell der Algorithmus arbeitet. Wenn das Ergebnis unmittelbar nach dem Dr√ºcken der Taste angezeigt wird, scheint es auf der Ebene der Benutzerwahrnehmung, dass das Programm "sehr" schnell arbeitet. Egal wie schnell der Algorithmus arbeitet, das Ergebnis wird erst auf dem Bildschirm angezeigt, wenn der Schl√ºssel vollst√§ndig ist. Aus diesem Grund schien es mir, dass eine solche bedingte Zeitmessung als Schwellenwert dienen kann, um die Geschwindigkeit verschiedener Algorithmen nicht genau zu vergleichen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Philosophisch ... W√§hrend der Studie wurde eine Vielzahl von Ver√∂ffentlichungen zur L√∂sung nicht deterministischer Probleme betrachtet. In den meisten F√§llen handelte es sich dabei um Aufgaben, bei denen unter den Bedingungen vorgegebener Beschr√§nkungen in einem gro√üen Staatenraum eine Auswahl getroffen werden musste. Im Vergleich war es interessant zu wissen, wie weit man bei der L√∂sung solcher Probleme mit dem mathematischen Standardansatz kommen kann. Ich hatte den Eindruck, dass es unm√∂glich ist, solche Probleme nur auf der Grundlage von Definitionen, Behauptungen und Beweisen zu l√∂sen. Es scheint mir, dass es zur L√∂sung solcher Probleme notwendig ist, die Methoden der algorithmischen Mathematik unter Verwendung von Computersimulationen anzuwenden. Um die G√ºltigkeit dieser Schlussfolgerung zu demonstrieren, habe ich als einfaches Beispiel ein Schachbrett vorbereitet, dessen Gr√∂√üe 10 ist</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> x 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zwei Kompositionen gleicher Gr√∂√üe, bestehend aus 999.999.482 K√∂niginnen. Sie werden wie am Anfang des Artikels beschrieben erstellt und als zwei Dateien im Format .mat angezeigt. Sie k√∂nnen unter diesem Link heruntergeladen werden </font></font><a href="https://drive.google.com/drive/folders/1p5VJO4fAEs8vNp_EonFIitd1o6EJqzQt%3Fusp%3Dsharing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(zwei Testdateien)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dateien sind ziemlich "schwer", die Gr√∂√üe jeder von ihnen betr√§gt etwa 3,97 GB. In 999 997 976 Zeilen (in 99,9998% der F√§lle) stimmen die Positionen der K√∂niginnen in beiden Kompositionen √ºberein, und nur in willk√ºrlichen 1506 Zeilen unterscheiden sich die Positionen der K√∂niginnen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Zusammensetzungsdaten zu einer vollst√§ndigen L√∂sung zu vervollst√§ndigen, m√ºssen Sie die Damen korrekt in die verbleibenden 518 freien Zeilen einf√ºgen. Die Anzahl der m√∂glichen M√∂glichkeiten, 518 K√∂niginnen in den verbleibenden freien Linien anzuordnen (wobei nur die Anzahl der M√∂glichkeiten ber√ºcksichtigt wird, eine freie Position in der ausgew√§hlten Linie auszuw√§hlen), betr√§gt ungef√§hr </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.146</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Der Unterschied zwischen diesen beiden Zusammensetzungen besteht nur darin, dass eine davon positiv ist und bis zu einer vollst√§ndigen L√∂sung vervollst√§ndigt werden kann, und die andere Zusammensetzung negativ ist - sie kann nicht bis zu einer vollst√§ndigen L√∂sung vervollst√§ndigt werden. Frage: ‚ÄûIst es m√∂glich, auf der Grundlage eines strengen mathematischen Ansatzes (dh ohne Ausf√ºhrung algorithmischer Rechenoperationen) zu bestimmen, welche dieser beiden Kompositionen positiv ist?‚Äú Wenn dies nicht zu l√∂sen ist, k√∂nnen wir davon ausgehen, dass der Satz durch Widerspruch bewiesen ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich m√∂chte darauf hinweisen, dass unabh√§ngig von der Herangehensweise an die rein mathematische L√∂sung dieses Problems der Status 518 * 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9 ermittelt werden muss</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zellen in den verbleibenden freien Zeilen. Um dies zu tun, ist es notwendig, jede Position von zuvor eingerichteten K√∂niginnen zu ber√ºcksichtigen, und es gibt fast eine Milliarde von ihnen, um die Beschr√§nkungen festzulegen, die jede eingerichtete K√∂nigin den freien Positionen in den verbleibenden 518 Linien auferlegt. Ich habe keinen ‚ÄûDrehpunkt‚Äú gefunden, der es mir erlaubt, diese Arbeit nur auf der Grundlage eines rein mathematischen Ansatzes ohne algorithmische Berechnungen durchzuf√ºhren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe hier ein minimales Beispiel gegeben, das nur aus zwei Kompositionen besteht. Bei Bedarf kann die Anzahl solcher Zusammensetzungen erh√∂ht werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist anzumerken, dass auf der Grundlage des vorgeschlagenen linearen Algorithmus, der leicht an das Arbeiten mit gro√üen Zusammensetzungen angepasst ist, die Aufgaben der beiden Testzusammensetzungen abgeschlossen werden k√∂nnen, bis eine vollst√§ndige L√∂sung auf </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desktop-13 ausgef√ºhrt wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In ca. 4,5 Minuten (ohne Ladezeit der Eingabedaten). </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10. Zugabe </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Handeln von Professoren, die f√§hige Aufgaben empfehlen, die die Studenten entwickeln und erforschen k√∂nnen, verdient Respekt. </font><font style="vertical-align: inherit;">Dies erfordert einen erheblichen Aufwand, aber bei der √úberwindung von Schwierigkeiten sieht der Forscher andere komplexe Aufgabenstellungen anders. </font><font style="vertical-align: inherit;">Ich dachte, es w√§re n√ºtzlich, die Optionen zum Festlegen des n-Queens-Problems f√ºr solche Zwecke zu erweitern. </font><font style="vertical-align: inherit;">Wenn Sie dieselbe Aufgabe aus verschiedenen Perspektiven betrachten, k√∂nnen Sie verschiedene Dinge sehen. </font><font style="vertical-align: inherit;">Nachfolgend einige davon. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Betrachten Sie das Problem, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">Damen</font></i><font style="vertical-align: inherit;"> auf einem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rechteckigen ‚ÄûSchachbrett‚Äú der</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gr√∂√üe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxm anzuordnen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Bezeichne </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k = m - n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es sei eine L√∂sung erhalten, und in jedem von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In jeder Reihe befand sich eine K√∂nigin. Positionen, an denen sich K√∂niginnen befinden, werden von der weiteren Betrachtung ausgeschlossen. Jetzt gibt es in jeder Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m-1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> freie Position. In den verbleibenden freien Positionen finden wir wieder eine L√∂sung. Nach wie vor schlie√üen wir die Positionen aus, an denen sich die K√∂niginnen der zweiten L√∂sung befinden. Jetzt gibt es in jeder Reihe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m-2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> freie Positionen. Offensichtlich kreuzen sich die erste und die zweite L√∂sung in keiner Zeile - sie sind orthogonal. Es ist erforderlich, die maximale Anzahl von zueinander orthogonalen L√∂sungen f√ºr verschiedene Werte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu bestimmen </font><font style="vertical-align: inherit;">. Wenn </font><font style="vertical-align: inherit;">f√ºr den Wert </font><i><font style="vertical-align: inherit;">k = 0 </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zueinander orthogonale L√∂sungen gefunden werden</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dann wird der Royal Latin Square gebaut. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bemerkung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Das Papier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grigoryan E. (2018)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die f√ºr jede L√∂sung gezeigt , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens Problem</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gibt es eine erg√§nzende L√∂sung ist, die nicht mit ihrem interferiert. Dies bedeutet, dass f√ºr einen beliebigen Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Menge aller L√∂sungen des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens-Problems</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in zwei </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gleich gro√üe</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teilmengen aufgeteilt wird. Jede L√∂sung aus der zweiten Teilmenge ist eine Komplement√§rl√∂sung zur entsprechenden L√∂sung aus der ersten Teilmenge. Die Regel ist ganz einfach: Wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q1 (i)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine L√∂sung aus der ersten Menge ist, dann ist die entsprechende komplement√§re L√∂sung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q2 (i)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus der zweiten Teilmenge wird durch die Formel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q2 (i) = n + 1 - Q1 (i) bestimmt, wobei i = (1, ..., n)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Diese Regel erkl√§rt die Tatsache, dass die Anzahl aller L√∂sungen des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens-Problems</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr einen beliebigen Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> immer eine gerade Zahl ist. (Diese Regel erlaubt es uns, die Zeit f√ºr die Berechnung aller vollst√§ndigen L√∂sungen f√ºr eine beliebige Gr√∂√üe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n des</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schachbretts </font><font style="vertical-align: inherit;">zu halbieren </font><font style="vertical-align: inherit;">. Wenn wir </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesamtzahl aller L√∂sungen </font><font style="vertical-align: inherit;">mit </font><i><font style="vertical-align: inherit;">2 * k</font></i><font style="vertical-align: inherit;"> bezeichnen </font><font style="vertical-align: inherit;">, dann ist der Wert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gleich dem Index in der sequentiellen Liste aller L√∂sungen, wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q (k) + Q ( k + 1) = n + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. In der anf√§nglichen Formulierung des Problems </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Qeens Problem</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nachdem die K√∂nigin in Position </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j) gebracht wurde</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden die folgenden Aktionen ausgef√ºhrt: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Alle Zellen der Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und der Spalte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden ausgeschlossen, b) Alle Zellen, die sich auf der Linie der linken und rechten Diagonalen befinden, die durch die Zelle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j) verlaufen,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden ausgeschlossen </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir √§ndern die Bedingung b) in der Erkl√§rung des Problems. Anstatt Zellen zu eliminieren, werden wir die Zellenvermittlung verwenden. Wenn die Zelle in der Linie der linken oder rechten Diagonale frei ist, schlie√üen wir sie, wenn die Zelle geschlossen ist, √∂ffnen wir sie. Dies erleichtert das Finden einer L√∂sung. Anstelle der quadratischen Matrix </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn betrachten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir jedoch eine rechteckige Matrix der Gr√∂√üe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nx (n - k)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . F√ºr einen gegebenen Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist es erforderlich, </font><font style="vertical-align: inherit;">den Maximalwert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k zu finden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bei denen mindestens drei orthogonale L√∂sungen erhalten werden k√∂nnen. Wie √§ndert sich der Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit zunehmendem Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. √Ñndern Sie einige Bedingungen in der Anfangsformulierung des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problems</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit dem </font><i><font style="vertical-align: inherit;">n-Queens-Problem</font></i><font style="vertical-align: inherit;"> . Wenn die Dame an Position </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf einem Schachbrett der Gr√∂√üe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn positioniert ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) schlie√üen wir alle Zellen in Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i aus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) wenn der Index </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine gerade Zahl ist, dann: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b1) schlie√üen wir Zellen in geraden Zeilen der Spalte j aus, </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b2) schlie√üen wir Zellen in aus gerade Linien, die die linken und rechten Diagonalen schneiden und durch die Zelle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j) verlaufen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) Wenn Index </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i>  ,   b1)  b2)   ,    . <br><br> 3.1  <i>(Sloane-2016)</i> ,      <i>nQueens Problem</i> ,  <i>n=(8, 9, 10, 11, 12, 13, 14, 15, 16)</i> ,   <i>(92, 352, 724, 2680, 14200, 73712, 365596, 2279184, 14772512)</i> .     ,            b)    c)? <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2 Grigoryan (2018) ist bekannt, dass, wenn wir die H√§ufigkeit der Beteiligung verschiedener Zellen der L√∂sungsmatrix an der Bildung einer Liste aller L√∂sungen bestimmen, harmonische Beziehungen zwischen allen Zellen in Form vertikaler und horizontaler Symmetrien der entsprechenden Frequenzen bestehen. Dies bedeutet, wenn wir annehmen, dass </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k &lt;n / 2 ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ist die Frequenz der Zellen der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k-ten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeile identisch mit der Frequenz der Zellen der Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-k + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In √§hnlicher Weise ist die Frequenz der Zellen der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k-ten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spalte identisch mit der Frequenz der Zellen der Spalte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-k + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Frage: "Wie werden sich diese harmonischen Beziehungen im Kontext der Aufgabe ver√§ndern?"</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Alle Zellen eines Schachbretts sind durch ihre Farbe in zwei Klassen unterteilt. Es wird angenommen, dass eine Farbe wei√ü und die andere schwarz ist. Betrachten Sie zwei Schachbretter und legen Sie eines so auf das andere, dass die Kanten vollst√§ndig zusammenfallen. Als Ergebnis erhalten wir ein "Sandwich" aus zwei Schachbrettern, in denen die Anordnung der wei√üen und schwarzen Zellen √ºbereinstimmt. Die Aufgabe besteht darin, auf zwei Tafeln gleichzeitig L√∂sungen zu finden, wobei folgende Bedingungen zu beachten sind: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Befindet sich die Dame auf einem der Tafeln auf einem schwarzen Feld mit den Indizes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dann: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- auf beiden Tafeln alle schwarzen Felder, die auftreten in Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Spalte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Auf beiden Brettern sind alle schwarzen Zellen ausgeschlossen, die sich entlang der linken und rechten Diagonalen befinden, die durch die Zelle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j) verlaufen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Befindet sich die Dame auf einem der Bretter auf einem wei√üen Feld mit den Indizes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , werden alle Aktionen von Absatz a) nur f√ºr wei√üe Felder ausgef√ºhrt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Stellen Sie sich vor, dass in einer L√∂sungsmatrix der Gr√∂√üe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeilen mit einem Schritt von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen </font><font style="vertical-align: inherit;">relativ zueinander nach rechts oder links </font><i><font style="vertical-align: inherit;">verschoben</font></i><font style="vertical-align: inherit;"> werden k√∂nnen </font><font style="vertical-align: inherit;">. Wenn dar√ºber hinaus die vorherige Reihe beispielsweise nach links verschoben wurde, sollte die n√§chste Reihe nach rechts verschoben werden, d.h. Jede n√§chste Zeile wird in die entgegengesetzte Richtung zur vorherigen Zeile verschoben. Durch diese Konstruktion erhalten wir eine rechteckige Gr√∂√üenmatrix</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nx (n + k)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wobei in jeder Zeile k Zellen vom Zeilenanfang oder vom Zeilenende von der Betrachtung ausgeschlossen werden. Die Aufgabe besteht darin </font><font style="vertical-align: inherit;">, den Maximalwert von </font><i><font style="vertical-align: inherit;">k</font></i><font style="vertical-align: inherit;"> f√ºr einen beliebigen Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n zu finden,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr den es mindestens eine L√∂sung f√ºr das </font><i><font style="vertical-align: inherit;">n-Queens-Problem gibt</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Stellen Sie sich eine Variante des Problems vor, bei der der Versatz einer Zeile in Bezug auf eine andere eine Zufallszahl ist, die von </font><i><font style="vertical-align: inherit;">k1</font></i><font style="vertical-align: inherit;"> bis </font><i><font style="vertical-align: inherit;">k2 reicht</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">6. Die </font><b><font style="vertical-align: inherit;">eindimensionale Formulierung des </font></b><b><i><font style="vertical-align: inherit;">nQueens-Problems</font></i></b><font style="vertical-align: inherit;"> . Auf der Halbachse seien </font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;"> Segmente beliebiger L√§nge von </font><i><font style="vertical-align: inherit;">1 bis n</font></i><font style="vertical-align: inherit;"> angeordnet </font><font style="vertical-align: inherit;">. Teilen Sie jedes Segment durch </font><i><font style="vertical-align: inherit;">n</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i></b><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zellen beliebiger Gr√∂√üe und innerhalb jedes Segments Zellen von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 bis n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wir nennen solche Zellen offen. Es erfordert eine </font><font style="vertical-align: inherit;">enge eine Zelle auf jedes Segment, die folgenden Einschr√§nkungen Ber√ºcksichtigung </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Wir k√∂nnen eine offenzellige mit Index w√§hlen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ten Segment , </font><font style="vertical-align: inherit;">wenn: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r) = 0; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (t) = 0; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wobei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r = n + j - i, t = j + i, D1 und D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eindimensionale Steuerfelder sind, die aus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen bestehen, die zuvor auf Null gesetzt wurden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Nach dieser Auswahl werden Segment </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Zellen mit der Nummer </font><i><font style="vertical-align: inherit;">j</font></i><font style="vertical-align: inherit;"> geschlossen</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in allen verbleibenden freien Segmenten. Es ist auch notwendig, die entsprechenden Zellen in den Kontrollfeldern zu schlie√üen: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r) = 1; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (t) = 1; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Einstellung ist die Aufgabe v√∂llig identisch mit der urspr√ºnglichen. Interessant ist die Formulierung dieses Problems mit anderen Randbedingungen. Wenn beispielsweise anstelle der Formeln: </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r = n + j - i, t = j + i,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden andere Verh√§ltnisse ber√ºcksichtigt werden, die funktionell verkn√ºpft sind Indizes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Indizes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Matrix zu </font><font style="vertical-align: inherit;">machen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Wortlaut der Aufgabe anhand einer Urne mit Kugeln</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (identisch mit dem vorherigen Wortlaut). Angenommen, es gibt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Urnen mit den Nummern </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 bis n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und in jeder Urne gibt es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kugeln, die ebenfalls von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 bis n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nummeriert sind </font><font style="vertical-align: inherit;">. Erfordert urn von jedem Ball entfernt, die folgenden Einschr√§nkungen Ber√ºcksichtigung </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Wir um </font><font style="vertical-align: inherit;">den Ballon mit der Nummer ausw√§hlen k√∂nnen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> th urn , </font><font style="vertical-align: inherit;">wenn: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r) = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (t) = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wobei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r = n + j - i, t = j + i, D1 und D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind eindimensionale Steuerfelder, die aus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen bestehen, die zuvor auf Null gesetzt wurden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Nach dieser Auswahl werden die Wahlurne </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die B√§lle mit der Nummer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in allen verbleibenden freien Wahlurnen </font><font style="vertical-align: inherit;">geschlossen </font><font style="vertical-align: inherit;">. Es ist auch notwendig, die entsprechenden Zellen in den Kontrollfeldern zu schlie√üen:</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r) = 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (t) = 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Einstellung ist die Aufgabe v√∂llig identisch mit der urspr√ºnglichen. Wie im vorherigen Fall ist die Erkl√§rung dieses Problems mit anderen Bedingungen von Interesse, die die Indizes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funktional </font><font style="vertical-align: inherit;">mit den Indizes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Entscheidungsmatrix verbinden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Spiel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Betrachten Sie ein Schachbrett der Gr√∂√üe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Lassen Sie uns die Farbe zu den K√∂niginnen zur√ºckbringen, lassen Sie einige K√∂niginnen wei√üe Farbe haben, andere schwarz. Wir geben auch die abwechselnde wei√üe und schwarze Farbe an die Zellen des Schachbretts zur√ºck, basierend auf der Tatsache, dass die Zelle mit dem Index </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1, n)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte wei√ü sein. Alle Zellen zu Beginn des Spiels gelten als frei. Wei√üe K√∂niginnen machen den ersten Schritt. Der Spieler platziert die Dame in eine beliebige freie Zelle mit Indizes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Lass es eine wei√üe Zelle sein. Infolge dieser Auswahl werden sie geschlossen: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) alle wei√üen Zellen der Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) alle wei√üen Zellen der Spalte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) alle wei√üen Zellen, die auf der linken und rechten Diagonale liegen und durch die Zelle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j) verlaufen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn </font><font style="vertical-align: inherit;">sich herausstellt, dass </font><font style="vertical-align: inherit;">die Zelle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schwarz ist, sind alle Punkte </font><i><font style="vertical-align: inherit;">(a, b, c)</font></i><font style="vertical-align: inherit;"> erf√ºllt</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dementsprechend sind alle schwarzen Zellen geschlossen. Als n√§chstes f√ºhrt Schwarz den Zug aus und platziert die Dame in eine der verbleibenden freien Zellen. Danach schlie√üen sich die Zellen auf √§hnliche Weise wie oben beschrieben. Der Zeitpunkt, an dem √ºber den n√§chsten Schritt nachgedacht werden soll, ist festgelegt und wird von den Parteien vereinbart. Wenn einer der Spieler w√§hrend der angegebenen Zeit seinen Zug nicht beendet, wird das Spiel auf den anderen √ºbertragen. Das Spiel endet, wenn beide Spieler nacheinander nicht in der angegebenen Zeit an der Reihe sind. Derjenige, der mehr K√∂niginnen auf dem Brett platzieren kann, gewinnt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9. Auf die Stabilit√§t der zuf√§lligen Auswahl. Betrachten Sie das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Modell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Als Ergebnis des Vergleichs von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zuf√§lligen Paaren von Zeilen- und Spaltenindizes ist es in der ersten Stufe des Zyklus m√∂glich, die K√∂niginnen im Durchschnitt bei festzulegen</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k * n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeilen. Der Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann als konstanter Wert von 0,6 betrachtet werden. Sein Wert variiert von 0,605701 bei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 10</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und bis 0,599777 bei n = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und mit zunehmendem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nimmt die Varianz dieses Wertes ab. Was ist der Grund f√ºr eine solche "Best√§ndigkeit"? Warum ist es mit einer zuf√§lligen Auswahl des Zeilenindex und des Positionsindex der Dame in dieser Zeile auf der Grundlage von zwei Listen von Zahlen, die auf der Grundlage einer zuf√§lligen Permutation von Zahlen von 1 bis n erhalten wurden, m√∂glich, die Damen (im Durchschnitt) auf 60% der Zeilen konsistent zu platzieren? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. Die Gr√∂√üe des Schachbretts sei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Basierend auf dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet-Verfahren</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lege die K√∂niginnen auf das Schachbrett, bis der Suchzweig eine Sackgasse erreicht. Bezeichnen Sie die L√§nge der so erhaltenen Zusammensetzung mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn f√ºr einen gegebenen Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diese Prozedur viele Male wiederholt wird und ein Histogramm der Verteilung der Werte von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k erstellt wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , zeigt sich, dass sich die √Ñnderung der H√§ufigkeit des Auftretens von Ereignissen von der √Ñnderung der H√§ufigkeit des Auftretens von Ereignissen nach diesem Wert unterscheidet. Wenn das Histogramm auf der Grundlage des Modalwerts in zwei Teile unterteilt ist, stimmt der linke Teil nicht mit dem rechten Teil √ºberein. Dieses Muster ist charakteristisch f√ºr jeden Wert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Warum nimmt die H√§ufigkeit des Eintretens von Ereignissen nach dem √úbergang der L√§nge der Komposition √ºber den Modalwert eine andere Form an? Unter einem Ereignis verstehen wir das Erhalten einer Komposition einer bestimmten Gr√∂√üe, bevor ein Zustand der Sackgasse erreicht wird.</font></font><br><br><h4>  Literatur </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Nauck, F. (1850). </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Briefwechsel mit allen fur alle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Illustrierte Zeitung, 15, 182. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. </font></font><a href="https://jair.org/index.php/jair/article/view/11079/26262"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gent, IP, Jefferson, C. &amp; Nightingale, P. (2017). </font></font></a> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komplexit√§t der Fertigstellung von n-Queens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Journal of Artificial Intelligence Research., 59, 815-848. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Sosic, R. &amp; Gu, J. (1990). </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein polynomieller Zeitalgorithmus f√ºr das n-K√∂niginnen-Problem</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . SIGART Bulletin, 1 (3), 7‚Äì11. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. </font></font><a href="https://www.cl.cam.ac.uk/~mr10/backtrk.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richards, M. (1997). </font></font></a> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Backtracking-Algorithmen in MCPL unter Verwendung von Bitmustern und Rekursion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tech. rep., Computerlabor, Universit√§t Cambridge. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Randomisierungsmethoden im Algorithmusdesign</font></font></i> , Proceedings of a DIMACS Workshop, Princeton, New Jersey, USA, December 12-14, 1997. DIMACS Series in Discrete Mathematics and Theoretical Computer Science 43, DIMACS/AMS 1999, ISBN 978-0-8218-0916-7 <br><br> 6. <a href="http://ejournal11.com/journals_n/1537458681.pdf">Grigoryan E. (2018).</a> <i>Investigation of the Regularities in the Formation of Solutions n-Queens Problem</i> . Modeling of Artificial Intelligence, 5(1), 3-21 <br><br> 7. <a href="http://oeis.org/A000170,%25202016">Sloane N.-JA (2016).</a> The on-line encyclopedia of integer sequences. <br><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483036/">https://habr.com/ru/post/de483036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483018/index.html">Maske-R CNN vom Anf√§nger bis zum Profi</a></li>
<li><a href="../de483024/index.html">‚ÄûWas haben Unternehmen mit Ihrer Privatsph√§re gemacht?‚Äú, Arthur Khachuyan</a></li>
<li><a href="../de483026/index.html">Java / Spring: So generieren Sie mit Speedment eine CRUD REST-API vollst√§ndig</a></li>
<li><a href="../de483030/index.html">API, die Sie zum Weinen bringt</a></li>
<li><a href="../de483032/index.html">Umzug aus der GUS in die Tschechische Republik, eigene Erfahrung (Teil 2)</a></li>
<li><a href="../de483038/index.html">Die Spielwelt kompetent neu starten</a></li>
<li><a href="../de483040/index.html">Magic Schraubendreher f√ºr Fernost Montage Excel 97</a></li>
<li><a href="../de483042/index.html">9 Tipps zur Vue-Leistung</a></li>
<li><a href="../de483048/index.html">Terminal Fun: 10 klassische Konsolenwitze</a></li>
<li><a href="../de483050/index.html">Top 5 ReactJS Entwicklungsunternehmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>