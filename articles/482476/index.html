<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåú ‚ô®Ô∏è üë®‚Äçüíª ActivityLifecycleCallbacks: un punto ciego en la API p√∫blica üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë© ‚ùóÔ∏è üôçüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desde peque√±o, me gusta leer las instrucciones. Crec√≠, pero todav√≠a me sorprende c√≥mo los adultos son descuidados con las instrucciones: muchos de ell...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ActivityLifecycleCallbacks: un punto ciego en la API p√∫blica</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yamoney/blog/482476/"><img src="https://habrastorage.org/webt/h5/7s/op/h57sopubtnsjbnkfclj9sapsho4.png"><br><br>  Desde peque√±o, me gusta leer las instrucciones.  Crec√≠, pero todav√≠a me sorprende c√≥mo los adultos son descuidados con las instrucciones: muchos de ellos piensan que todos lo saben, y al mismo tiempo usan una o dos funciones, ¬°mientras que hay muchas m√°s!  ¬øCu√°ntos de ustedes sol√≠an mantener la temperatura en el microondas?  Y ella est√° en casi todos. <br><br>  Una vez decid√≠ leer la documentaci√≥n de las diversas clases del marco de Android.  Revis√© las clases principales: Vista, Actividad, Fragmento, Aplicaci√≥n, y estaba muy interesado en el m√©todo <a href="https://developer.android.com/reference/android/app/Application.html">Application.registerActivityLifecycleCallbacks ()</a> y la interfaz <a href="https://developer.android.com/reference/android/app/Application.ActivityLifecycleCallbacks.html">ActivityLifecycleCallbacks</a> .  De los ejemplos de su uso en Internet, nada fue mejor que registrar el ciclo de vida de la Actividad.  Luego comenc√© a experimentar con m√≠ mismo, y ahora en Yandex.Money lo usamos activamente para resolver una amplia gama de tareas relacionadas con el impacto de los objetos de actividad desde el exterior. <br><a name="habracut"></a><br><h1>  ¬øQu√© son ActivityLifecycleCallbacks? </h1><br>  Mire esta interfaz, as√≠ es como se ve√≠a cuando apareci√≥ en API 14: <br><br><pre><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActivityLifecycleCallbacks</span></span></span><span class="hljs-class"> </span></span>{    void onActivityCreated(Activity activity, Bundle savedInstanceState);    void onActivityStarted(Activity activity);    void onActivityResumed(Activity activity);    void onActivityPaused(Activity activity);    void onActivityStopped(Activity activity);    void onActivitySaveInstanceState(Activity activity, Bundle outState);    void onActivityDestroyed(Activity activity); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Comenzando con API 29, se le han agregado varios m√©todos nuevos.</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActivityLifecycleCallbacks</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPreCreated( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity, <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> Bundle savedInstanceState) { }   void onActivityCreated( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity, <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> Bundle savedInstanceState);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostCreated( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity, <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> Bundle savedInstanceState) { }   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPreStarted(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   void onActivityStarted(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostStarted(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPreResumed(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   void onActivityResumed(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostResumed(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPrePaused(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   void onActivityPaused(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostPaused(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPreStopped(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   void onActivityStopped(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostStopped(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPreSaveInstanceState( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity, <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Bundle outState) { }   void onActivitySaveInstanceState( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity, <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Bundle outState);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostSaveInstanceState( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity, <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Bundle outState) { }   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPreDestroyed(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   void onActivityDestroyed(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostDestroyed(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { } }</code> </pre> <br></div></div><br>  Quiz√°s esta interfaz recibe tan poca atenci√≥n porque solo apareci√≥ en Android 4.0 ICS.  Pero en vano, porque te permite hacer algo muy interesante de forma nativa: influir en todos los objetos de actividad desde el exterior.  Pero m√°s sobre eso m√°s adelante, y primero eche un vistazo m√°s de cerca a los m√©todos. <br><br>  Cada m√©todo muestra un m√©todo similar del ciclo de vida de la Actividad y se llama en el momento en que el m√©todo se activa en cualquier Actividad en la aplicaci√≥n.  Es decir, si la aplicaci√≥n se inicia con MainActivity, entonces el primero recibiremos una llamada a ActivityLifecycleCallback.onActivityCreated (MainActivity, null). <br><br>  Genial, pero ¬øc√≥mo funciona?  Aqu√≠ no hay magia: la actividad en s√≠ misma informa sobre en qu√© estado se encuentran.  Aqu√≠ hay un fragmento de c√≥digo de Activity.onCreate (): <br><br><pre> <code class="java hljs"> mFragments.restoreAllState(p, mLastNonConfigurationInstances != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>           ? mLastNonConfigurationInstances.fragments : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } mFragments.dispatchCreate(); getApplication().dispatchActivityCreated(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, savedInstanceState); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mVoiceInteractor != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {</code> </pre><br>  Parece que nosotros mismos hicimos BaseActivity.  Solo colegas de Android hicieron esto por nosotros, y tambi√©n obligaron a todos a usarlo.  ¬°Y esto es muy bueno! <br><br>  En API 29, estos m√©todos funcionan casi igual, pero sus copias Pre y Post se llaman honestamente antes y despu√©s de m√©todos espec√≠ficos.  Probablemente ahora est√© controlado por el ActivityManager, pero esta es solo mi suposici√≥n, porque no ingres√© a la fuente lo suficiente como para averiguarlo. <br><br><h2>  ¬øC√≥mo hacer que ActivityLifecycleCallbacks funcione? </h2><br>  Como todas las devoluciones de llamada, primero debe registrarlas.  Registramos todos los ActivityLifecycleCallbacks en Application.onCreate (), por lo que obtenemos informaci√≥n sobre toda la Actividad y la capacidad de administrarlos. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() {   <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate() registerActivityLifecycleCallbacks(MyCallbacks()) } }</code> </pre> <br>  Una peque√±a digresi√≥n: a partir de API 29, ActivityLifecycleCallbacks tambi√©n se puede registrar desde la Actividad.  Esta ser√° una <a href="https://developer.android.com/reference/android/app/Activity.html">devoluci√≥n de llamada local</a> que solo funciona para esta Actividad. <br><br>  Eso es todo  Pero puede encontrar esto simplemente ingresando el nombre ActivityLifecycleCallbacks en el cuadro de b√∫squeda.  Habr√° muchos ejemplos de registro del ciclo de vida de la Actividad, pero ¬øes interesante?  La actividad tiene muchos m√©todos p√∫blicos (alrededor de 400), y todo esto se puede utilizar para hacer muchas cosas interesantes y √∫tiles. <br><br><h2>  ¬øQu√© se puede hacer con esto? </h2><br>  Que quieres  ¬øDesea cambiar din√°micamente el tema en todas las actividades de la aplicaci√≥n?  Por favor: el m√©todo setTheme () es p√∫blico, lo que significa que puede llamarlo desde un ActivityLifecycleCallback: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThemeCallback</span></span></span></span>( <span class="hljs-meta"><span class="hljs-meta">@StyleRes</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myTheme: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ) : ActivityLifecycleCallbacks { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span> { activity.setTheme(myTheme) } }</code> </pre> <br>  <b>Repite este truco SOLO en casa</b> <br>  Algunas actividades de las bibliotecas conectadas pueden usar sus temas personalizados.  Por lo tanto, verifique el paquete o cualquier otro s√≠ntoma por el cual se pueda determinar que el tema de esta Actividad se puede cambiar de manera segura.  Por ejemplo, verificamos el paquete de esta manera (en Kotlinovsky =)): <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThemeCallback</span></span></span></span>( <span class="hljs-meta"><span class="hljs-meta">@StyleRes</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myTheme: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ) : ActivityLifecycleCallbacks { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myPackage = <span class="hljs-string"><span class="hljs-string">"my.cool.application"</span></span> activity .takeIf { it.javaClass.name.startsWith(myPackage) } ?.setTheme(myTheme) } }</code> </pre> <br>  ¬øEl ejemplo no funciona?  Es posible que haya olvidado registrar ThemeCallback en la Aplicaci√≥n o Aplicaci√≥n en AndroidManifest. <br><br>  ¬øQuieres otro ejemplo interesante?  Puede mostrar cuadros de di√°logo en cualquier Actividad en la aplicaci√≥n. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DialogCallback</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dialogFragment: DialogFragment ) : Application.ActivityLifecycleCallbacks { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tag = dialogFragment.javaClass.name (activity <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? AppCompatActivity) ?.supportFragmentManager ?.also { fragmentManager -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fragmentManager.findFragmentByTag(tag) == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { dialogFragment.show(fragmentManager, tag) } } } } }</code> </pre> <br>  <b>Repite este truco SOLO en casa</b> <br>  Por supuesto, no debe mostrar un di√°logo en cada pantalla; nuestros usuarios no nos amar√°n por esto.  Pero a veces puede ser √∫til mostrar algo como esto en algunas pantallas espec√≠ficas. <br><br>  Y aqu√≠ hay otro caso: ¬øqu√© pasa si necesitamos comenzar una actividad? Todo es simple aqu√≠: Activity.startActivity (), y lo condujo.  Pero, ¬øqu√© sucede si necesitamos esperar el resultado despu√©s de llamar a Activity.startActivityForResult ()?  Tengo una receta: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartingActivityCallback</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application.ActivityLifecycleCallbacks { override fun onActivityCreated</span></span></span></span>( activity: Activity, savedInstanceState: Bundle? ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { (activity <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? AppCompatActivity) ?.supportFragmentManager ?.also { fragmentManager -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startingFragment = findOrCreateFragment(fragmentManager) startingFragment.listener = { resultCode, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> -&gt; <span class="hljs-comment"><span class="hljs-comment">// handle response here } // start Activity inside StartingFragment } } } private fun findOrCreateFragment( fragmentManager: FragmentManager ): StartingFragment { val tag = StartingFragment::class.java.name return fragmentManager .findFragmentByTag(tag) as StartingFragment? ?: StartingFragment().apply { fragmentManager .beginTransaction() .add(this, tag) .commit() } } }</span></span></code> </pre> <br>  En el ejemplo, simplemente dejamos caer el Fragmento, que inicia la Actividad y obtiene el resultado, y luego nos delega su procesamiento.  Tenga cuidado: aqu√≠ verificamos que nuestra Actividad es AppCompatActivity, lo que puede conducir a un bucle infinito.  Use otras condiciones. <br><br>  Vamos a complicar los ejemplos.  Hasta ese momento, utilizamos solo aquellos m√©todos que ya est√°n en la Actividad.  ¬øQu√© hay de agregar el tuyo?  Supongamos que queremos enviar an√°lisis sobre c√≥mo abrir una pantalla.  Al mismo tiempo, nuestras pantallas tienen sus propios nombres.  ¬øC√≥mo resolver este problema?  Muy simple  Cree una interfaz de pantalla que pueda dar el nombre de pantalla: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> screenName: String }</code> </pre> <br>  Ahora lo implementamos en la Actividad deseada: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamedActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), Screen { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> screenName: String = <span class="hljs-string"><span class="hljs-string">"First screen"</span></span> }</code> </pre> <br>  Despu√©s de eso, configuramos ActivityLifecycleCallbacks especiales para dicha Actividad: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyticsActivityCallback</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sendAnalytics: (String) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ) : Application.ActivityLifecycleCallbacks { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { (activity <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? Screen)?.screenName?.let(sendAnalytics) } } }</code> </pre> <br>  ¬øVes?  Simplemente verificamos la interfaz y, si se implementa, enviamos an√°lisis. <br><br>  Repita para la fijaci√≥n.  ¬øQu√© hacer si necesita lanzar algunos par√°metros m√°s?  Extienda la interfaz: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScreenWithParameters</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Screen { val parameters: Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String, String</span></span></span><span class="hljs-class">&gt; }</span></span></code> </pre> <br>  Implementamos: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamedActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), ScreenWithParameters { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> screenName: String = <span class="hljs-string"><span class="hljs-string">"First screen"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parameters: Map&lt;String, String&gt; = mapOf(<span class="hljs-string"><span class="hljs-string">"key"</span></span> to <span class="hljs-string"><span class="hljs-string">"value"</span></span>) }</code> </pre> <br>  Enviamos: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyticsActivityCallback</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sendAnalytics: (String, Map&lt;String, String&gt;?) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ) : Application.ActivityLifecycleCallbacks { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { (activity <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? Screen)?.screenName?.let { name -&gt; sendAnalytics( name, (activity <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? ScreenWithParameters)?.parameters ) } } } }</code> </pre> <br>  Pero a√∫n es f√°cil.  Todo esto fue solo para llevarlo a un tema realmente interesante: la inyecci√≥n de dependencia nativa.  S√≠, tenemos Dagger, Koin, Guice, Kodein y m√°s.  Pero en proyectos peque√±os, son redundantes.  Pero tengo una soluci√≥n ... ¬øAdivina cu√°l? <br><br>  Digamos que tenemos alguna herramienta como esta: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoolToolImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> extraInfo = <span class="hljs-string"><span class="hljs-string">"i am dependency"</span></span> }</code> </pre> <br>  Ci√©rrelo con la interfaz, como programadores adultos: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoolTool</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> extraInfo: String } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoolToolImpl</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CoolTool { override val extraInfo = "i am dependency" }</span></span></span></span></code> </pre> <br>  Y ahora un poco de magia callejera de ActivityLifecycleCallbacks: crearemos una interfaz para implementar esta dependencia, la implementaremos en la Actividad deseada, y usando ActivityLifecycleCallbacks la encontraremos e implementaremos la implementaci√≥n CoolToolImpl. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RequireCoolTool</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> coolTool: CoolTool } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoolToolActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), RequireCoolTool { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> coolTool: CoolTool } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InjectingLifecycleCallbacks</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ActivityLifecycleCallbacks { override fun onActivityCreated</span></span></span></span>( activity: Activity, savedInstanceState: Bundle? ) { (activity <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? RequireCoolTool)?.coolTool = CoolToolImpl() } }</code> </pre> <br>  Recuerde registrar InjectingLifecycleCallbacks en su aplicaci√≥n, ejec√∫telo y funciona. <br><br>  Y no olvides probar: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith(AndroidJUnit4::class)</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DIActivityTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> `should access extraInfo </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">when</span></span></span><span class="hljs-function"> created`</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// prepare val mockTool: CoolTool = mock() val application = getApplicationContext&lt;android.app.Application&gt;() application.registerActivityLifecycleCallbacks( object : Application.ActivityLifecycleCallbacks { override fun onActivityCreated( activity: Activity, savedInstanceState: Bundle? ) { (activity as? RequireCoolTool)?.coolTool = mockTool } }) // invoke launch&lt;DIActivity&gt;(Intent(application, DIActivity::class.java)) // assert verify(mockTool).extraInfo } }</span></span></code> </pre> <br>  Pero en proyectos grandes, este enfoque no se escalar√° bien, por lo que no voy a quitarle ning√∫n marco DI a nadie.  Donde es mejor combinar esfuerzos y lograr sinergia.  Te mostrar√© el ejemplo de Dagger2.  Si tiene alguna Actividad b√°sica en el proyecto que hace algo como AndroidInjection.inject (this), entonces es hora de tirarla.  En su lugar, haga lo siguiente: <br><ol><li>  de acuerdo con las instrucciones, implementamos DispatchingAndroidInjector en la aplicaci√≥n; </li><li>  cree un ActivityLifecycleCallbacks que llame a DispatchingAndroidInjector.maybeInject () en cada actividad; </li><li>  registre ActivityLifecycleCallbacks en la aplicaci√≥n. </li></ol><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dispatchingAndroidInjector: DispatchingAndroidInjector&lt;Any&gt; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate() DaggerYourApplicationComponent.create().inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); registerActivityLifecycleCallbacks( InjectingLifecycleCallbacks( dispatchingAndroidInjector ) ) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InjectingLifecycleCallbacks</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dispatchingAndroidInjector: DispatchingAndroidInjector&lt;Any&gt; ) : ActivityLifecycleCallbacks { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span> {       dispatchingAndroidInjector.maybeInject(activity) } }</code> </pre> <br>  Y se puede lograr el mismo efecto con otros marcos DI.  Intenta escribir en los comentarios lo que pas√≥. <br><br><h2>  Para resumir </h2><br>  ActivityLifecycleCallbacks es una herramienta poderosa y subestimada.  Pruebe uno de <a href="https://github.com/yandex-money/android-activitylifecyclecallbacks-example">estos ejemplos</a> y deje que lo ayuden en sus proyectos de la misma manera que Yandex.Money ayuda a mejorar nuestras aplicaciones. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/482476/">https://habr.com/ru/post/482476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../482466/index.html">5 cosas que puedes hacer para prepararte para Vue 3.0</a></li>
<li><a href="../482468/index.html">5 extensiones y temas para VS Code que pueden cambiar la vida de un desarrollador front-end</a></li>
<li><a href="../482470/index.html">Carga r√°pida de p√°ginas en los tel√©fonos m√°s simples y baratos</a></li>
<li><a href="../482472/index.html">¬øDe qu√© est√° hecho JavaScript?</a></li>
<li><a href="../482474/index.html">"C√≥mo pas√© el verano"</a></li>
<li><a href="../482478/index.html">Iteraptor: biblioteca para redus de mapa transparente profundo</a></li>
<li><a href="../482480/index.html">Toques c√≥smicos del a√±o saliente</a></li>
<li><a href="../482482/index.html">Juego de roles</a></li>
<li><a href="../482484/index.html">C√≥mo aumentar la eficiencia del desarrollo utilizando la teor√≠a de las restricciones</a></li>
<li><a href="../482486/index.html">¬øQu√© es Misra y c√≥mo cocinarlo?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>