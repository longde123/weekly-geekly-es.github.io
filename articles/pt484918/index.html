<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö° üèí üñêüèæ Processamento de anota√ß√£o incremental para acelerar constru√ß√µes de gradle üë®üèª‚Äç‚öïÔ∏è üî≠ üë©üèº‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A partir das vers√µes Gradle 4.7 e Kotlin 1.3.30, foi poss√≠vel obter uma montagem incremental acelerada de projetos devido √† opera√ß√£o correta do proces...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Processamento de anota√ß√£o incremental para acelerar constru√ß√µes de gradle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/484918/"><p><img src="https://habrastorage.org/webt/ne/dq/wg/nedqwgztbpmabplkbivfwi8gx9s.jpeg" alt="imagem"></p><br><p>  A partir das vers√µes Gradle 4.7 e Kotlin 1.3.30, foi poss√≠vel obter uma montagem incremental acelerada de projetos devido √† opera√ß√£o correta do processamento incremental de anota√ß√µes.  Neste artigo, entendemos como a teoria da compila√ß√£o incremental em Gradle funciona em teoria, o que precisa ser feito para liberar todo o seu potencial (sem perder a gera√ß√£o de c√≥digo ao mesmo tempo) e que tipo de aumento na velocidade de montagens incrementais pode ser alcan√ßado pela ativa√ß√£o do processamento incremental de anota√ß√µes na pr√°tica. </p><a name="habracut"></a><br><h2 id="kak-rabotaet-inkrementalnaya-kompilyaciya">  Como a compila√ß√£o incremental funciona </h2><br><p>  As constru√ß√µes incrementais no Gradle s√£o implementadas em dois n√≠veis.  O primeiro n√≠vel √© cancelar o in√≠cio da recompila√ß√£o dos m√≥dulos usando a <a href="https://docs.gradle.org/current/userguide/java_plugin.html">compila√ß√£o evitada</a> .  O segundo √© a compila√ß√£o diretamente incremental, iniciando o compilador na estrutura de um m√≥dulo apenas nos arquivos que foram alterados ou que dependem diretamente dos arquivos alterados. </p><br><p>  Vamos considerar a compila√ß√£o evitada em um exemplo (retirado de um <a href="https://blog.gradle.org/incremental-compiler-avoidance">artigo</a> da Gradle) de um projeto de tr√™s m√≥dulos: <strong>app</strong> , <strong>core</strong> e <strong>utils</strong> . </p><br><p>  A classe principal do m√≥dulo de <strong>aplicativo</strong> (depende do <strong>n√∫cleo</strong> ): </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ WordCount wc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WordCount(); wc.collect(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); System.out.println(<span class="hljs-string"><span class="hljs-string">"Word count: "</span></span> + wc.wordCount()); } }</code> </pre> <br><p>  No m√≥dulo <strong>principal</strong> (depende dos <strong>utils</strong> ): </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WordCount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... void collect(File source) { IOUtils.eachLine(source, WordCount::collectLine); } }</span></span></code> </pre> <br><p>  No m√≥dulo <strong>utils</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eachLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Callable&lt;String&gt; action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (BufferedReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileReader(file))) { <span class="hljs-comment"><span class="hljs-comment">// ... } } catch (IOException e) { // ... } } }</span></span></code> </pre> <br><p>  A ordem da primeira compila√ß√£o dos m√≥dulos √© a seguinte (de acordo com a ordem das depend√™ncias): </p><br><p>  1) <strong>utils</strong> <br>  2) <strong>n√∫cleo</strong> <br>  3) <strong>app</strong> </p><br><p>  Agora considere o que acontece quando voc√™ altera a implementa√ß√£o interna da classe IOUtils: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// IOUtils lives in project `utils` void eachLine(File file, Callable&lt;String&gt; action) { try { try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "utf-8") )) { // ... } } catch (IOException e) { // ... } } }</span></span></code> </pre> <br><p>  Essa altera√ß√£o n√£o afeta o m√≥dulo ABI.  ABI (Application Binary Interface) √© uma representa√ß√£o bin√°ria da interface p√∫blica do m√≥dulo montado.  No caso em que a altera√ß√£o se relacione apenas √† implementa√ß√£o interna do m√≥dulo e n√£o afete sua interface p√∫blica de forma alguma, a Gradle usar√° a compila√ß√£o e evitar√° a recompila√ß√£o apenas do m√≥dulo <strong>utils</strong> .  Se a ABI do m√≥dulo <strong>utils</strong> for afetada (por exemplo, um m√©todo p√∫blico adicional aparecer ou a assinatura do existente mudar), a compila√ß√£o do m√≥dulo <strong>principal</strong> ser√° iniciada adicionalmente, mas o m√≥dulo de <strong>aplicativo</strong> dependente do <strong>n√∫cleo</strong> n√£o ser√° recompilado transitivamente se a depend√™ncia nele for conectada atrav√©s da <a href="https://medium.com/mindorks/implementation-vs-api-in-gradle-3-0-494c817a6fa">implementa√ß√£o</a> . </p><br><p><img src="https://habrastorage.org/webt/io/pv/b-/iopvb-pf4b-fzrwksogs3ydsuzk.png"><br>  <em>Ilustra√ß√£o da compila√ß√£o evitada no n√≠vel do m√≥dulo do projeto</em> </p><br><p>  O segundo n√≠vel de incremento √© o incremento no n√≠vel de inicializa√ß√£o do compilador para arquivos alterados diretamente dentro de m√≥dulos individuais. </p><br><p>  Por exemplo, adicione uma nova classe ao m√≥dulo <strong>principal</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NGrams</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// NGrams lives in project `core` // ... void collect(String source, int ngramLength) { collectInternal(StringUtils.sanitize(source), ngramLength); } // ... }</span></span></code> </pre> <br><p>  E nos <strong>utils</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanitize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String dirtyString)</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br><p>  Nesse caso, nos dois m√≥dulos, √© necess√°rio recompilar apenas dois novos arquivos (sem afetar o WordCount e o IOUtils existentes e n√£o alterados), pois n√£o h√° depend√™ncias entre as classes nova e antiga. </p><br><p>  Assim, o compilador incremental analisa depend√™ncias entre classes e recompila apenas: </p><br><ul><li>  classes contendo altera√ß√µes </li><li><p>  classes que dependem diretamente da mudan√ßa de classe </p><br><h2 id="inkrementalnyy-annotation-processing">  Processamento de anota√ß√£o incremental </h2><br><p><img src="https://habrastorage.org/webt/qd/qy/c1/qdqyc14pw7rak4d89dgft7oylus.png" alt="insira a descri√ß√£o da imagem aqui"></p><br></li></ul><br><p>  A gera√ß√£o de c√≥digo usando o APT e o KAPT reduz o tempo necess√°rio para escrever e depurar o c√≥digo padr√£o, mas o processamento da anota√ß√£o pode aumentar significativamente o tempo de cria√ß√£o.  Para piorar a situa√ß√£o, por muito tempo, o processamento de anota√ß√µes quebrou fundamentalmente as possibilidades de compila√ß√£o incremental em Gradle. </p><br><p>  Cada processador de anota√ß√£o em um projeto informa ao compilador informa√ß√µes sobre a lista de anota√ß√µes que processa.  Mas, do ponto de vista da montagem, o processamento de anota√ß√µes √© uma caixa preta: Gradle n√£o sabe o que o processador far√°, em particular, quais arquivos ele gerar√° e onde.  At√© o Gradle 4.7, a compila√ß√£o incremental era automaticamente desativada nos conjuntos de fontes em que os processadores de anota√ß√£o eram usados. </p><br><p>  Com o <a href="https://docs.gradle.org/4.7/userguide/java_plugin.html">lan√ßamento do</a> Gradle 4.7, a compila√ß√£o incremental agora suporta o processamento de anota√ß√µes, mas apenas para o APT.  No KAPT, o suporte √† anota√ß√£o incremental foi <a href="https://blog.jetbrains.com/kotlin/2019/04/kotlin-1-3-30-released/">introduzido</a> no Kotlin 1.3.30.  Tamb√©m requer <a href="https://docs.gradle.org/current/userguide/java_plugin.html">suporte</a> de bibliotecas que fornecem processadores de anota√ß√£o.  Os desenvolvedores de processadores de anota√ß√£o t√™m a oportunidade de definir explicitamente a categoria do processador, informando Gradle das informa√ß√µes necess√°rias para que a compila√ß√£o incremental funcione. </p><br><h2 id="kategorii-processorov-annotaciy">  Categorias do processador de anota√ß√£o </h2><br><p>  Gradle suporta duas categorias de processadores: </p><br><p>  <strong>Isolamento</strong> - esses processadores devem tomar todas as decis√µes para gera√ß√£o de c√≥digo com base apenas nas informa√ß√µes do <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">AST</a> associadas a um elemento de uma anota√ß√£o espec√≠fica.  Essa √© a categoria mais r√°pida de processadores de anota√ß√£o, pois o Gradle pode n√£o reiniciar o processador e usar os arquivos gerados anteriormente, se n√£o houver altera√ß√µes no arquivo de origem. </p><br><p>  <strong>Agrega√ß√£o</strong> - usada para processadores que tomam decis√µes com base em v√°rias entradas (por exemplo, an√°lise de anota√ß√µes em v√°rios arquivos de uma vez ou com base no estudo do AST, que √© alcan√ß√°vel transitivamente a partir de um elemento anotado).  Cada vez, o Gradle iniciar√° o processador para arquivos que usam anota√ß√µes do processador agregador, mas n√£o recompilar√° os arquivos gerados se n√£o houver altera√ß√µes neles. </p><br><p>  Para muitas bibliotecas populares baseadas na gera√ß√£o de c√≥digo, o suporte √† compila√ß√£o incremental j√° est√° implementado nas vers√µes mais recentes.  Veja a lista de bibliotecas que oferecem suporte <a href="https://docs.gradle.org/current/userguide/java_plugin.html">aqui</a> . </p><br><h2 id="nash-opyt-vnedreniya-incremental-annotation-processing">  Nossa experi√™ncia na implementa√ß√£o de processamento de anota√ß√£o incremental </h2><br><p>  Agora, para projetos que come√ßam do zero e usam as vers√µes mais recentes de bibliotecas e plugins gradle, √© prov√°vel que as constru√ß√µes incrementais estejam ativas por padr√£o.  Mas a maior parte do aumento na produtividade da montagem pode ser alcan√ßada pela incrementalidade do processamento de anota√ß√µes em projetos grandes e de longa dura√ß√£o.  Nesse caso, pode ser necess√°ria uma atualiza√ß√£o maci√ßa da vers√£o.  Vale a pena na pr√°tica?  Vamos ver! </p><br><p>  Portanto, para que o processamento incremental de anota√ß√µes funcione, precisamos: </p><br><ul><li>  Gradle 4.7+ </li><li>  Kotlin 1.3.30+ </li><li>  Todos os processadores de anota√ß√£o em nosso projeto devem ter seu suporte.  Isso √© muito importante, porque se em um √∫nico m√≥dulo pelo menos um processador n√£o suportar incrementalidade, o Gradle o desativar√° em todo o m√≥dulo.  Todos os arquivos no m√≥dulo ser√£o compilados novamente a cada vez!  Uma das op√ß√µes alternativas para obter suporte para compila√ß√£o incremental sem atualizar vers√µes √© a remo√ß√£o de todo o c√≥digo usando processadores de anota√ß√£o em um m√≥dulo separado.  Nos m√≥dulos que n√£o possuem processadores de anota√ß√£o, a compila√ß√£o incremental funcionar√° bem </li></ul><br><p>  Para detectar processadores que n√£o atendem √† √∫ltima condi√ß√£o, voc√™ pode executar o assembly com o sinalizador <em>-Pkapt.verbose = true</em> .  Se Gradle foi for√ßado a desativar o processamento de anota√ß√£o incremental para um √∫nico m√≥dulo, no log de compila√ß√£o, veremos uma mensagem sobre quais processadores e em quais m√≥dulos isso est√° acontecendo (consulte o nome da tarefa): </p><br><pre> <code class="plaintext hljs">&gt; Task :common:kaptDebugKotlin w: [kapt] Incremental annotation processing requested, but support is disabled because the following processors are not incremental: toothpick.compiler.factory.FactoryProcessor (NON_INCREMENTAL), toothpick.compiler.memberinjector.MemberInjectorProcessor (NON_INCREMENTAL).</code> </pre> <br><p>  Em nosso projeto de biblioteca com processadores de anota√ß√£o n√£o incrementais, havia 3: </p><br><ul><li>  Palito de dente </li><li>  Quarto </li><li>  PermissionsDispatcher </li></ul><br><p>  Felizmente, essas bibliotecas s√£o ativamente suportadas e suas vers√µes mais recentes j√° t√™m suporte √† incrementalidade.  Al√©m disso, todos os processadores de anota√ß√£o nas vers√µes mais recentes dessas bibliotecas t√™m uma categoria ideal - isolamento.  No processo de elevar as vers√µes, tive que lidar com a refatora√ß√£o devido a altera√ß√µes na API da biblioteca Toothpick, que afetaram quase todos os nossos m√≥dulos.  Mas, nesse caso, tivemos sorte e refatoramos completamente automaticamente usando os nomes de substitui√ß√£o autom√°tica dos m√©todos de biblioteca p√∫blica usados. </p><br><p>  Observe que, se voc√™ usar a biblioteca de <em>salas</em> , precisar√° passar explicitamente o <em>sinalizador room.incremental: true</em> para o processador de anota√ß√µes.  <a href="https://developer.android.com/jetpack/androidx/releases/room">Um exemplo</a>  No futuro, os desenvolvedores de <a href="https://developer.android.com/jetpack/androidx/releases/room">salas planejam</a> ativar esse sinalizador por padr√£o. </p><br><p>  Para vers√µes do Kotlin 1.3.30-1.3.50, voc√™ deve ativar o suporte ao processamento incremental de anota√ß√µes <strong>explicitamente</strong> por meio de <em>kapt.incremental.apt = true</em> no arquivo gradle.properties do projeto.  A partir da vers√£o 1.3.50, essa op√ß√£o √© configurada como true por padr√£o. </p><br><h2 id="profayling-inkrementalnyh-sborok">  Cria√ß√£o de perfil de montagem incremental </h2><br><p>  Ap√≥s o aumento das vers√µes de todas as depend√™ncias necess√°rias, √© hora de testar a velocidade das compila√ß√µes incrementais.  Para fazer isso, usamos o seguinte conjunto de ferramentas e t√©cnicas: </p><br><ul><li>  <a href="https://guides.gradle.org/creating-build-scans/">Gradle build scan</a> </li><li>  <a href="https://github.com/gradle/gradle-profiler">gradle-profiler</a> </li><li>  Para executar scripts com o processamento de anota√ß√£o incremental ativado e desativado, a propriedade <em>gradle kapt.incremental.apt = [true | false] foi usada</em> </li><li>  Para resultados consistentes e informativos, as assembl√©ias foram realizadas em um ambiente de IC separado.  Incrementalidade de compila√ß√£o foi reproduzida usando gradle-profiler </li></ul><br><p>  O gradle-profiler permite preparar declarativamente <a href="https://github.com/gradle/gradle-profiler">scripts</a> para benchmarks de constru√ß√£o incrementais.  4 cen√°rios foram compilados com base nas seguintes condi√ß√µes: </p><br><ul><li>  A modifica√ß√£o de um arquivo afeta / n√£o afeta sua ABI </li><li>  Suporte para ligar / desligar o processamento incremental de anota√ß√£o </li></ul><br><p>  A execu√ß√£o de cada um dos cen√°rios √© uma sequ√™ncia de: </p><br><ul><li>  Reiniciando o daemon gradle </li><li>  Lan√ßar compila√ß√µes de aquecimento </li><li>  Execute 10 montagens incrementais, antes de cada um dos quais um arquivo ser alterado, adicionando um novo m√©todo (privado para altera√ß√µes que n√£o sejam da ABI e p√∫blico para altera√ß√µes da ABI) </li></ul><br><p>  Todas as compila√ß√µes foram feitas com o Gradle 5.4.1.  O arquivo envolvido nas altera√ß√µes refere-se a um dos m√≥dulos principais do projeto (comum), dos quais 40 m√≥dulos (incluindo n√∫cleo e recurso) s√£o diretamente dependentes.  Este arquivo usa a anota√ß√£o para isolar o processador. </p><br><p>  Tamb√©m √© importante notar que a execu√ß√£o do benchmark foi realizada em duas tarefas <em>gradle</em> : <em>ompileDebugSources</em> e <em>assembleDebug</em> .  O primeiro inicia apenas a compila√ß√£o de arquivos com c√≥digo fonte, sem fazer nenhum trabalho com recursos e agrupar o aplicativo em um arquivo .apk.  Com base no fato de que a compila√ß√£o incremental afeta apenas os arquivos .kt e .java, a tarefa <em>compileDedugSource</em> foi escolhida para um benchmarking mais isolado e mais r√°pido.  Em condi√ß√µes reais de desenvolvimento, quando voc√™ reinicia o aplicativo, o Android Studio usa a tarefa <em>assembleDebug</em> , que inclui a gera√ß√£o completa da vers√£o de depura√ß√£o do aplicativo. </p><br><h2 id="rezultaty-benchmarkov">  Resultados de refer√™ncia </h2><br><p>  Em todos os gr√°ficos gerados pelo gradle-profiler, o eixo vertical mostra o tempo de montagem incremental em milissegundos e o eixo horizontal mostra o n√∫mero inicial da montagem. </p><br><h3 id="compiledebugsource-do-obnovleniya-processorov-annotaciy">  : compileDebugSource antes de atualizar os processadores de anota√ß√£o </h3><br><p><img src="https://habrastorage.org/webt/mn/cd/jj/mncdjjla37vj8ogbycy0szzpj-e.png" alt="insira a descri√ß√£o da imagem aqui"><br>  O tempo m√©dio de execu√ß√£o para cada cen√°rio foi de 38 segundos antes de atualizar os processadores de anota√ß√£o para vers√µes que suportam incrementalidade.  Nesse caso, o Gradle desabilita o suporte √† compila√ß√£o incremental, portanto, n√£o h√° diferen√ßa significativa entre os scripts. </p><br><h3 id="compiledebugsource-posle-obnovleniya-processorov-annotaciy">  : compileDebugSource ap√≥s atualizar os processadores de anota√ß√£o </h3><br><p><img src="https://habrastorage.org/webt/wk/fk/h1/wkfkh1e37r3jpagocxqbdi4twqk.png"></p><br><div class="scrollable-table"><table><thead><tr><th>  Cen√°rio </th><th>  Altera√ß√£o incremental da ABI </th><th>  Altera√ß√£o n√£o incremental da ABI </th><th>  Altera√ß√£o incremental n√£o ABI </th><th>  Altera√ß√£o n√£o incremental e n√£o-abi </th></tr></thead><tbody><tr><td>  <strong>dizer</strong> </td><td>  23978 </td><td>  35370 </td><td>  23514 </td><td>  34602 </td></tr><tr><td>  <strong>mediana</strong> </td><td>  23879 </td><td>  35019 </td><td>  23424 </td><td>  34749 </td></tr><tr><td>  <strong>min</strong> </td><td>  22618 </td><td>  33969 </td><td>  22343 </td><td>  33292 </td></tr><tr><td>  <strong>max</strong> </td><td>  26820 </td><td>  38097 </td><td>  25651 </td><td>  35843 </td></tr><tr><td>  <strong>stddev</strong> </td><td>  1193.29 </td><td>  1240,81 </td><td>  888,24 </td><td>  815,91 </td></tr></tbody></table></div><br><p>  A redu√ß√£o mediana no tempo de montagem devido √† incrementalidade foi de 31% para altera√ß√µes no ABI e 32,5% para altera√ß√µes n√£o relacionadas ao ABI.  Em valor absoluto, cerca de 10 segundos. </p><br><h3 id="assembledebug-posle-obnovleniya-processorov-annotaciy">  : assembleDebug ap√≥s atualizar os processadores de anota√ß√£o </h3><br><p><img src="https://habrastorage.org/webt/fa/5h/qx/fa5hqxvowacrovlvmc12xard7_i.png"></p><br><div class="scrollable-table"><table><thead><tr><th>  Cen√°rio </th><th>  Altera√ß√£o incremental da ABI </th><th>  Altera√ß√£o n√£o incremental da ABI </th><th>  Altera√ß√£o incremental n√£o ABI </th><th>  Altera√ß√£o n√£o incremental e n√£o-abi </th></tr></thead><tbody><tr><td>  <strong>dizer</strong> </td><td>  39902 </td><td>  49850 </td><td>  39005 </td><td>  52123 </td></tr><tr><td>  <strong>mediana</strong> </td><td>  38974 </td><td>  49691 </td><td>  38713 </td><td>  50336 </td></tr><tr><td>  <strong>min</strong> </td><td>  38563 </td><td>  48782 </td><td>  38233 </td><td>  48944 </td></tr><tr><td>  <strong>max</strong> </td><td>  48255 </td><td>  52364 </td><td>  41732 </td><td>  65941 </td></tr><tr><td>  <strong>stddev</strong> </td><td>  2953,28 </td><td>  1011,20 </td><td>  1015,37 </td><td>  5039.11 </td></tr></tbody></table></div><br><p>  Para compilar a vers√£o de depura√ß√£o completa do aplicativo em nosso projeto, a redu√ß√£o m√©dia no tempo de compila√ß√£o devido ao incremento foi de 21,5% para altera√ß√µes de ABI e 23% para altera√ß√µes que n√£o s√£o de ABI.  Em termos absolutos, aproximadamente os mesmos 10 segundos, pois o incremento da compila√ß√£o do c√≥digo-fonte n√£o afeta a velocidade de montagem dos recursos. </p><br><h2 id="anatomiya-sborki-v-gradle-build-scan">  Construir Anatomia da Varredura no Gradle Build Scan </h2><br><p>  Para uma compreens√£o mais profunda de como o incremento foi alcan√ßado durante a compila√ß√£o incremental, comparamos as varreduras de montagens incrementais e n√£o incrementais. </p><br><p>  No caso de incremento desabilitado do KAPT, a parte principal do tempo de compila√ß√£o √© a compila√ß√£o do m√≥dulo de aplicativo, que n√£o pode ser paralelo a outras tarefas.  A linha do tempo para o KAPT n√£o incremental √© a seguinte: </p><br><p><img src="https://habrastorage.org/webt/r0/cw/_n/r0cw_n4xvp7olnharknhce--9fe.png" alt="insira a descri√ß√£o da imagem aqui"></p><br><p>  Execu√ß√£o da tarefa: kaptDebugKotlin do nosso m√≥dulo de aplicativo leva cerca de 8 segundos neste caso. </p><br><p>  Linha do tempo para o caso com o incremento KAPT ativado: </p><br><p><img src="https://habrastorage.org/webt/_u/xt/se/_uxtsee_4jt_g7oems5ggxbm3rg.png" alt="insira a descri√ß√£o da imagem aqui"></p><br><p>  Agora, o m√≥dulo do aplicativo foi recompilado em menos de um segundo.  Vale a pena prestar aten√ß√£o √† desproporcionalidade visual das escalas das duas digitaliza√ß√µes na imagem acima.  As tarefas que parecem mais curtas na primeira imagem n√£o s√£o necessariamente mais longas na segunda, onde parecem mais longas.  Mas √© muito percept√≠vel o quanto a propor√ß√£o de recompila√ß√£o do m√≥dulo de aplicativo foi reduzida quando o KAPT incremental foi ativado.  No nosso caso, ganhamos cerca de 8 segundos neste m√≥dulo e mais 2 segundos adicionais em m√≥dulos menores que s√£o compilados em paralelo. </p><br><p>  Ao mesmo tempo, o tempo total de execu√ß√£o de todas as tarefas * kapt para a incrementalidade desabilitada das anota√ß√µes de processamento √© de 1 minuto e 36 segundos contra 55 segundos quando ativado.  Ou seja, sem levar em conta a montagem paralela dos m√≥dulos, o ganho √© mais substancial. </p><br><p>  Tamb√©m √© importante notar que os resultados do benchmark acima foram preparados em um ambiente de CI com a capacidade de executar 24 threads paralelos para montagem.  Em um ambiente de 8 threads, o ganho ao ativar o processamento de anota√ß√£o incremental √© de cerca de 20 a 30 segundos em nosso projeto. </p><br><h2 id="incremental-vs--parallel">  Paralelo incremental vs (?) </h2><br><p>  Outra maneira de acelerar significativamente a montagem (incremental e limpa) √© executar tarefas de nivelamento em paralelo, dividindo o projeto em um grande n√∫mero de m√≥dulos fracamente acoplados.  De uma forma ou de outra, a modulariza√ß√£o representa um potencial muito maior para acelerar as montagens do que usar o KAPT incremental.  Por√©m, quanto mais monol√≠tico o projeto for, e quanto mais a gera√ß√£o de c√≥digo for usada nele, maior ser√° o processamento incremental de anota√ß√µes.  √â mais f√°cil obter o efeito de incrementalidade completa de montagens do que quebrar um aplicativo em m√≥dulos.  No entanto, ambas as abordagens n√£o se contradizem e se complementam perfeitamente. </p><br><h2 id="itog">  Sum√°rio </h2><br><ul><li>  A inclus√£o do processamento incremental de anota√ß√µes em nosso projeto nos permitiu alcan√ßar um aumento de 20% na velocidade da reconstru√ß√£o local </li><li>  Para habilitar o processamento de anota√ß√£o incremental, ser√° √∫til estudar o log completo dos assemblies atuais e procurar mensagens de aviso com o texto "Processamento de anota√ß√£o incremental solicitado, mas o suporte est√° desativado porque os seguintes processadores n√£o s√£o incrementais ...".  √â necess√°rio atualizar vers√µes de bibliotecas para vers√µes com suporte para processamento incremental de anota√ß√µes e ter as vers√µes Gradle 4.7+, Kotlin 1.3.30+ </li></ul><br><h3 id="materialy-i-chto-pochitat-po-teme">  Materiais e o que ler sobre o t√≥pico </h3><br><ul><li>  <a href="https://docs.gradle.org/6.0.1/userguide/java_plugin.html">Sobre o suporte ao processamento de anota√ß√µes adicionais no n√≠vel do plug-in Gradle Java</a> </li><li>  <a href="https://medium.com/andrews-tech-blog/the-gradle-profiler-part-1-introduction-bdcbe70efe08">Artigo sobre gradle-profiler</a> </li><li>  <a href="https://kotlinlang.org/docs/reference/kapt.html">Mais sobre os recursos do KAPT</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DsQC9-Rj2yLI">Relat√≥rio no Google I / O 2019 com truques atuais de acelera√ß√£o de compila√ß√£o</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3D7ll-rkLCtyk">Outro relat√≥rio sobre o Gradle Optimization no Google I / O 2017, inclui material de constru√ß√£o incremental e compila√ß√£o evitada</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt484918/">https://habr.com/ru/post/pt484918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt484902/index.html">Em equa√ß√µes de graus mais altos</a></li>
<li><a href="../pt484904/index.html">Um ano sem Splunk - como uma empresa americana mudou o mercado de an√°lise de dados de m√°quinas na R√∫ssia e quem deixou para tr√°s</a></li>
<li><a href="../pt484906/index.html">Equipe distribu√≠da e l√≠der da equipe no controle remoto</a></li>
<li><a href="../pt484908/index.html">HighLoad ++, Eugene Kuzovlev (EcommPay IT): o que fazer quando um minuto de inatividade custa US $ 100.000</a></li>
<li><a href="../pt484910/index.html">Paul Graham: Aborrecedores</a></li>
<li><a href="../pt484920/index.html">Como entender que voc√™ √© um operador de fresadora?</a></li>
<li><a href="../pt484930/index.html">Vamos acelerar como profissionais</a></li>
<li><a href="../pt484932/index.html">A natureza dupla dos requisitos de software</a></li>
<li><a href="../pt484934/index.html">Do desenvolvimento pessoal ao Agile em uma escala XXXL em dois dias na TeamLead Conf</a></li>
<li><a href="../pt484936/index.html">Conhecimento e compet√™ncias da equipe: encontre, veja, bombeie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>