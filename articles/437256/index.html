<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äç‚öïÔ∏è ‚ôìÔ∏è ü§Ωüèø Validaci√≥n de direcciones de memoria en un Cortex-M0 / M3 / M4 / M7 üç° üöú üçú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! 

 Con respecto al aflojamiento del r√©gimen el otro d√≠a, la indignaci√≥n en los comentarios de una publicaci√≥n vecina de que los art√≠culos s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Validaci√≥n de direcciones de memoria en un Cortex-M0 / M3 / M4 / M7</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437256/">  Hola Habr! <br><br>  Con respecto al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aflojamiento del r√©gimen el</a> otro d√≠a, la indignaci√≥n en los comentarios de una publicaci√≥n vecina de que los art√≠culos sobre microcontroladores est√°n parpadeando por el LED, as√≠ como la muerte prematura de mi blog est√°ndar, que soy demasiado vago para restaurar, transferir√© aqu√≠ material √∫til sobre una peque√±a y lamentable luz. Un truco de prensa para trabajar con n√∫cleos Cortex-M: verificar la validez de las direcciones aleatorias. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rl/he/2w/rlhe2wjgxij3ej65fi5t8lverts.jpeg"></div><br>  Una de las funciones muy √∫tiles y al mismo tiempo, por alguna raz√≥n, listas para usar que no se describen en ning√∫n lugar en los microcontroladores Cortex-M (todo) es la capacidad de verificar la exactitud de la direcci√≥n en la memoria.  Con √©l, puede determinar el tama√±o de flash, RAM y EEPROM, determinar la presencia en un procesador particular de perif√©ricos y registros espec√≠ficos, vencer los procesos ca√≠dos mientras se mantiene la salud general del sistema operativo, etc. <br><a name="habracut"></a><br>  En el modo normal, cuando llega a una direcci√≥n inexistente en Cortex-M3 / M4 / M7, se emite una excepci√≥n BusFault y, en ausencia de su controlador, se intensifica a HardFault.  En Cortex-M0 no hay excepciones "detalladas" (MemFault, BusFault, UsageFault), y cualquier falla se escala inmediatamente a HardFault. <br><br>  En general, no puede ignorar HardFault: puede ser el resultado de una falla de hardware, por ejemplo, y el comportamiento posterior del dispositivo se volver√° impredecible.  Pero en el caso particular, esto puede y debe hacerse. <br><br><h4>  Cortex-M3 y Cortex-M4: el BusFault no cumplido </h4><br>  En Cortex-M3 y superior, verificar la validez de la direcci√≥n es bastante simple: debe prohibir todas las excepciones (excepto, obviamente, no enmascarables) a trav√©s del registro FAULTMASK, deshabilitar el procesamiento de BusFault espec√≠ficamente y luego meter la direcci√≥n que se est√° verificando y ver si la bandera BFARVALID en el registro BFAR , es decir, registro de direcci√≥n de falla del bus.  Si lo ha tomado, acaba de tener un BusFault, es decir  La direcci√≥n es incorrecta. <br><br>  El c√≥digo se ve as√≠, todas las definiciones y funciones provienen del CMSIS est√°ndar (no de proveedor), por lo que deber√≠a funcionar en cualquier M3, M4 o M7: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cpu_check_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *address)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Cortex-M3, Cortex-M4, Cortex-M4F, Cortex-M7 are supported */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> BFARVALID_MASK = (<span class="hljs-number"><span class="hljs-number">0x80</span></span> &lt;&lt; SCB_CFSR_BUSFAULTSR_Pos); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_valid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Clear BFARVALID flag by writing 1 to it */</span></span> SCB-&gt;CFSR |= BFARVALID_MASK; <span class="hljs-comment"><span class="hljs-comment">/* Ignore BusFault by enabling BFHFNMIGN and disabling interrupts */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask = __get_FAULTMASK(); __disable_fault_irq(); SCB-&gt;CCR |= SCB_CCR_BFHFNMIGN_Msk; <span class="hljs-comment"><span class="hljs-comment">/* probe address in question */</span></span> *address; <span class="hljs-comment"><span class="hljs-comment">/* Check BFARVALID flag */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((SCB-&gt;CFSR &amp; BFARVALID_MASK) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* Bus Fault occured reading the address */</span></span> is_valid = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Reenable BusFault by clearing BFHFNMIGN */</span></span> SCB-&gt;CCR &amp;= ~SCB_CCR_BFHFNMIGN_Msk; __set_FAULTMASK(mask); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> is_valid; }</code> </pre> <br><h4>  Cortex-M0 y Cortex-M0 + </h4><br>  Con Cortex-M0 y Cortex-M0 + todo es m√°s complicado, como dije anteriormente, no tienen BusFault y todos los registros correspondientes, y las excepciones se escalan de inmediato a HardFault.  Por lo tanto, solo hay una salida: hacer que el controlador HardFault pueda comprender que la excepci√≥n fue causada deliberadamente y volver a la funci√≥n que la llam√≥, pasando una bandera que indica que HardFault estaba all√≠. <br><br>  Esto se hace puramente en ensamblador.  En el siguiente ejemplo, el registro R5 se establece en 1 y se escriben dos "n√∫meros m√°gicos" en los registros R1 y R2.  Si HardFault ocurre despu√©s de intentar cargar el valor en la direcci√≥n que se est√° verificando, entonces debe verificar los valores de R1 y R2, y si encuentran los n√∫meros necesarios, establezca R5 en cero.  El valor de R5 se transfiere al c√≥digo syshech a trav√©s de una variable especial que est√° r√≠gidamente vinculada a este registro, la direcci√≥n que se ensamblar√° en el ensamblador est√° impl√≠cita, solo sabemos que en arm-none-eabi el primer par√°metro de la funci√≥n se coloca en R0. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cpu_check_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *address)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Cortex-M0 doesn't have BusFault so we need to catch HardFault */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)address; <span class="hljs-comment"><span class="hljs-comment">/* R5 will be set to 0 by HardFault handler */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* to indicate HardFault has occured */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> result __asm(<span class="hljs-string"><span class="hljs-string">"r5"</span></span>); __<span class="hljs-function"><span class="hljs-function">asm__ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r5, =1 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* set default R5 value */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r1, =0xDEADF00D \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* set magic number */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r2, =0xCAFEBABE \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* 2nd magic to be sure */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldrb r3, [r0] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* probe address */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  El c√≥digo del controlador HardFault en su forma m√°s simple se ve as√≠: <br><br><pre> <code class="cpp hljs">__attribute__((naked)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hard_fault_default</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Get stack pointer where exception stack frame lies */</span></span> __<span class="hljs-function"><span class="hljs-function">asm__ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* decide if we need MSP or PSP stack */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movs r0, #4 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* r0 = 0x4 */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mov r2, lr \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* r2 = lr */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"tst r2, r0 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* if(lr &amp; 0x4) */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"bne use_psp \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* { */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mrs r0, msp \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* r0 = msp */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"b out \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* } */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" use_psp: \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* else { */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mrs r0, psp \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* r0 = psp */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" out: \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* } */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* catch intended HardFaults on Cortex-M0 to probe memory addresses */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r1, [r0, #0x04] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* read R1 from the stack */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r2, =0xDEADF00D \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* magic number to be found */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"cmp r1, r2 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* compare with the magic number */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"bne regular_handler \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* no magic -&gt; handle as usual */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r1, [r0, #0x08] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* read R2 from the stack */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r2, =0xCAFEBABE \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* 2nd magic number to be found */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"cmp r1, r2 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* compare with 2nd magic number */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"bne regular_handler \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* no magic -&gt; handle as usual */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r1, [r0, #0x18] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* read PC from the stack */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"add r1, r1, #2 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* move to the next instruction */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"str r1, [r0, #0x18] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* modify PC in the stack */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r5, =0 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* set R5 to indicate HardFault */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"bx lr \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* exit the exception handler */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" regular_handler: \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* here comes the rest of the fucking owl */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span></code> </pre> <br>  En el momento de abandonar el controlador de excepciones, Cortex arroja los registros, que se garantiza que est√°n da√±ados por el controlador (R0-R3, R12, LR, PC ...), en la pila.  El primer fragmento, que ya se encuentra en la mayor√≠a de los controladores HardFault listos para usar, a excepci√≥n de aquellos escritos bajo metal puro, determina qu√© pila: cuando se trabaja en el sistema operativo, puede ser MSP o PSP, y tienen direcciones diferentes.  En proyectos de metal desnudo, la pila MSP (puntero de pila principal) generalmente se instala a priori, sin verificar, porque el PSP (puntero de pila de proceso) no puede estar all√≠ debido a la falta de procesos. <br><br>  Despu√©s de determinar la pila deseada y poner su direcci√≥n en R0, leemos los valores R1 (desplazamiento 0x04) y R2 (desplazamiento 0x08), la comparamos con palabras m√°gicas, si ambas coinciden: leemos el valor de PC (desplazamiento 0x18) de la pila, sumamos 2 (2 bytes: el tama√±o de la instrucci√≥n en Cortex-M *) y gu√°rdelo de nuevo en la pila.  Si esto no se hace, cuando regresemos del controlador, nos encontraremos con la misma instrucci√≥n que realmente caus√≥ la excepci√≥n, y siempre correremos en c√≠rculos.  El ap√©ndice 2 nos lleva a la siguiente instrucci√≥n en el momento del regreso. <br><br>  <i><b>* Upd.</b></i>  <i>En los comentarios, surgi√≥ la pregunta sobre el tama√±o de las instrucciones en el Cortex-M, har√© la respuesta correcta aqu√≠: en este caso, el bloqueo provoca la instrucci√≥n LDRB, que est√° disponible en la arquitectura ARMv7-M en dos versiones: 16 bits y 32 bits.</i>  <i>La segunda opci√≥n se seleccionar√° si se cumple al menos una de las condiciones:</i> <i><br><br></i> <ul><li>  <i>el autor indic√≥ expl√≠citamente la instrucci√≥n LDRB.W en lugar de LDRB (nosotros no)</i> </li><li>  <i>se utilizan registros por encima de R7 (para nosotros - R0 y R3)</i> </li><li>  <i>Se especifica un desplazamiento mayor de 31 bytes (no tenemos un desplazamiento)</i> </li></ul> <i><br><br></i>  <i>En todos los dem√°s casos (es decir, cuando los operandos se ajustan al formato de la versi√≥n de 16 bits de la instrucci√≥n), el ensamblador <b>debe</b> seleccionar la versi√≥n de 16 bits.</i> <i><br><br></i>  <i>Por lo tanto, en nuestro caso, siempre habr√° una instrucci√≥n de 2 bytes que debe ser superada, pero si edita el c√≥digo con fuerza, las opciones son posibles.</i> <br><br>  Luego, escriba 0 en R5, que sirve como indicador de entrar en HardFault.  Los registros despu√©s de R3 no se guardan en la pila antes de los registros especiales, y al salir del controlador, no se restauran de ninguna manera, por lo que es nuestra conciencia estropearlos o no estropearlos.  En este caso, cambiamos R5 de 1 a 0 a prop√≥sito. <br><br>  El regreso del manejador de interrupciones se realiza exactamente de una manera.  Al ingresar al controlador, se escribe un valor especial en el registro LR llamado EXC_RETURN, que es necesario escribir en la PC para salir del controlador, y no solo escribirlo, sino hacerlo con un comando POP o BX (es decir, "mov pc, lr, por ejemplo, no funciona , aunque la primera vez te parezca que funciona).  BX LR parece un intento de ir a una direcci√≥n sin sentido (en LR habr√° algo como 0xFFFFFFF1 que no tiene nada que ver con la direcci√≥n real del procedimiento al que debemos regresar), pero en realidad el procesador ve este valor en la PC (donde ir√° autom√°ticamente), restaurar√° los registros de la pila y continuar√° ejecutando nuestro procedimiento, con el siguiente procedimiento despu√©s de llamar a HardFault debido al hecho de que aumentamos manualmente la PC en esta pila en 2. <br><br>  Puede leer sobre todas las compensaciones y comandos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">claramente d√≥nde</a> , por supuesto. <br><br>  Bueno, o si los n√∫meros m√°gicos no son visibles, entonces todo ir√° a regular_handler, despu√©s de lo cual sigue el procedimiento habitual de procesamiento de HardFault: como regla, esta es una funci√≥n que imprime valores de registro en la consola, decide qu√© hacer a continuaci√≥n con el procesador, etc. <br><br><h4>  Determinaci√≥n del tama√±o de RAM </h4><br>  Usar todo esto es simple y directo.  ¬øQueremos escribir un firmware que funcione en varios microcontroladores con diferentes cantidades de RAM, mientras que cada vez use RAM en un programa completo? <br><br>  S√≠ f√°cil: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cpu_find_memory_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> block, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxsize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *address = base; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { address += block; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cpu_check_address(address)) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)(address - base) &lt; maxsize); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)(address - base); } <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> get_cpu_ram_size(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cpu_find_memory_size((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)SRAM_BASE, <span class="hljs-number"><span class="hljs-number">4096</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>); }</code> </pre> <br>  Entonces, se necesita maxsize aqu√≠, que a la m√°xima cantidad posible de RAM entre √©l y el siguiente bloque de direcciones puede que no haya espacio en el que cpu_check_address se rompa.  En este ejemplo, es 80 KB.  Tampoco tiene sentido sondear todas las direcciones: solo mire la hoja de datos para ver cu√°l es el paso m√≠nimo posible entre los dos modelos de controlador y config√∫relo como bloque. <br><br><h4>  Transici√≥n program√°tica al gestor de arranque ubicado en el medio de la nada </h4><br>  A veces puedes hacer trucos a√∫n m√°s complicados; por ejemplo, imagina que quieres saltar program√°ticamente al cargador de arranque de f√°brica STM32 para cambiar al modo de actualizaci√≥n de firmware a trav√©s de UART o USB, sin molestarte en escribir tu cargador de arranque. <br><br>  El gestor de arranque STM32 se encuentra en el √°rea llamada Memoria del sistema, a la que debe ir, pero hay un problema: esta √°rea tiene diferentes direcciones no solo en diferentes series de procesadores, sino en diferentes modelos de la misma serie (se puede encontrar una placa √©pica en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AN2606</a> en p√°ginas 22 a 26).  Cuando agrega la funcionalidad correspondiente a la plataforma en general, y no solo a un producto espec√≠fico, desea versatilidad. <br><br>  En los archivos CMSIS, tambi√©n falta la direcci√≥n de inicio de la Memoria del sistema.  No es posible determinarlo por ID de cargador de arranque, porque  Este es un problema de huevo y gallina: la identificaci√≥n del cargador de arranque se encuentra en el √∫ltimo byte de la memoria del sistema, lo que nos lleva de nuevo a la cuesti√≥n de la direcci√≥n. <br><br>  Sin embargo, si miramos la tarjeta de memoria STM32, veremos algo como esto: <br><br><img src="https://habrastorage.org/webt/l4/nf/b3/l4nfb3xcw87qnsrey9n4mp3t0we.png"><br>  En este caso, estamos interesados ‚Äã‚Äãen el entorno de Memoria del sistema; por ejemplo, en la parte superior hay un √°rea que alguna vez fue programable (no en todos los STM32) y bytes de Opci√≥n (en total).  Esta estructura se observa no solo en diferentes modelos, sino en diferentes l√≠neas STM32, con la √∫nica diferencia en la presencia de OTP y la presencia de una brecha en las direcciones entre la memoria del sistema y las opciones. <br><br>  Pero para nosotros en este caso, lo m√°s importante es que la direcci√≥n de inicio de los Bytes de opci√≥n est√° en los encabezados regulares de CMSIS; all√≠ se llama OB_BASE. <br><br>  M√°s simple.  Escribimos la funci√≥n para buscar la primera direcci√≥n v√°lida o no v√°lida desde la especificada: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cpu_find_next_valid_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *stop, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> valid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *address = start; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (address == stop) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cpu_check_address(address) == valid) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> address; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stop &gt; start) { address++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { address--; } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre> <br>  Y mire hacia abajo desde los bytes de Opci√≥n, primero el final de la memoria del sistema o la OTP adyacente, y luego el comienzo de la memoria del sistema en dos pasadas: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* System memory is the valid area next _below_ Option bytes */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *a, *b, *c; a = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)(OB_BASE - <span class="hljs-number"><span class="hljs-number">1</span></span>); b = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Here we have System memory top address */</span></span> c = cpu_find_next_valid_address(a, b, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Here we have System memory bottom address */</span></span> c = cpu_find_next_valid_address(c, b, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Y sin mucha dificultad, organizamos esto en una funci√≥n que encuentra el comienzo de la memoria del sistema y salta sobre ella, es decir, inicia el gestor de arranque: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jump_to_bootloader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> __</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attribute__</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((noreturn))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Sets up and jumps to the bootloader */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jump_to_bootloader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* System memory is the valid area next _below_ Option bytes */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *a, *b, *c; a = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)(OB_BASE - <span class="hljs-number"><span class="hljs-number">1</span></span>); b = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Here we have System memory top address */</span></span> c = cpu_find_next_valid_address(a, b, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Here we have System memory bottom address */</span></span> c = cpu_find_next_valid_address(c, b, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c) { NVIC_SystemReset(); } <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> boot_addr = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)c; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> boot_stack_ptr = *(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*)(boot_addr); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> dfu_reset_addr = *(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*)(boot_addr+<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*dfu_bootloader)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*))(dfu_reset_addr); <span class="hljs-comment"><span class="hljs-comment">/* Reset the stack pointer */</span></span> __set_MSP(boot_stack_ptr); dfu_bootloader(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Depende del modelo de procesador espec√≠fico ... nada depende.  La l√≥gica no funcionar√° en los modelos que tienen un agujero entre OTP y la memoria del sistema, pero no he verificado si hay alguno.  Trabajar√° activamente con OTP - verificar. <br><br>  Otros trucos se aplican solo al procedimiento habitual para llamar al gestor de arranque desde su c√≥digo; no olvide restablecer el puntero de la pila y llame al procedimiento para abandonar el gestor de arranque antes de inicializar perif√©ricos en el procesador, velocidades de reloj, etc .: debido a su minimalismo, el gestor de arranque puede obstruirse Inicialice la periferia y espere que est√© en el estado predeterminado.  Una buena opci√≥n para llamar al gestor de arranque desde un lugar arbitrario en su programa es escribir en el RTC Backup Register o simplemente en una direcci√≥n conocida en la memoria de un n√∫mero m√°gico, reiniciar el programa y verificar en las primeras etapas de inicializaci√≥n de este n√∫mero. <br><br>  PD Dado que todas las direcciones en la tarjeta de memoria del procesador est√°n alineadas en el peor de los casos por 4, el procedimiento anterior se acelerar√° en gran medida por la idea de recorrerlas en incrementos de 4 bytes en lugar de uno. <br><br><h4>  Aviso importante </h4><br>  NB: tenga en cuenta que en un controlador espec√≠fico la validez de una direcci√≥n espec√≠fica no indica necesariamente la presencia real de la funcionalidad que se puede encontrar en esa direcci√≥n.  Por ejemplo, la direcci√≥n del registro que controla alg√∫n bloque perif√©rico opcional puede ser v√°lida, aunque el bloque en s√≠ est√° ausente en este modelo.  Desde el punto de vista del fabricante, los trucos m√°s interesantes son posibles, generalmente enraizados en el uso de los mismos cristales para diferentes modelos de procesadores.  Sin embargo, en la mayor√≠a de los casos, estos procedimientos funcionan y resultan muy √∫tiles. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437256/">https://habr.com/ru/post/437256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437244/index.html">Google ense√±a a los usuarios a reconocer correos electr√≥nicos de phishing</a></li>
<li><a href="../437248/index.html">FPGA mitap en San Petersburgo</a></li>
<li><a href="../437250/index.html">C√≥mo creamos una aplicaci√≥n m√≥vil que no necesita un dise√±ador</a></li>
<li><a href="../437252/index.html">Ciclo de lecciones de SDL 2.0: Lecci√≥n 3 - Bibliotecas de extensiones de SDL</a></li>
<li><a href="../437254/index.html">Computaci√≥n ternaria: conceptos b√°sicos</a></li>
<li><a href="../437258/index.html">Proyecto √∫nico del equipo de CATIA DESIGN: concept car Bleu</a></li>
<li><a href="../437260/index.html">Windows Phone 8.1: desarrollo posterior a la nostalgia. Historial de aplicaciones individuales</a></li>
<li><a href="../437262/index.html">¬øC√≥mo se hace potable el agua del r√≠o?</a></li>
<li><a href="../437264/index.html">Burnout profesional en TI (resultados del estudio de My Circle)</a></li>
<li><a href="../437270/index.html">Implementamos una m√°quina virtual de Windows con un reenv√≠o de tarjeta de video virtual usando QEMU e Intel GVT-g</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>