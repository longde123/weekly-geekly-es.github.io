<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïµüèæ üóØÔ∏è üïü Nous √©crivons un client http hautes performances en utilisant fasthttp comme exemple. Alexander Valyalkin (VertaMedia) üéÅ üë®üèª ü§±üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La biblioth√®que Fasthttp est une alternative acc√©l√©r√©e √† net / http √† partir des packages Golang standard. 
 Comment est-il organis√©? Pourquoi est-ell...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous √©crivons un client http hautes performances en utilisant fasthttp comme exemple. Alexander Valyalkin (VertaMedia)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443378/"><p>  La biblioth√®que Fasthttp est une alternative acc√©l√©r√©e √† net / http √† partir des packages Golang standard. <br>  Comment est-il organis√©?  Pourquoi est-elle si rapide? </p><br><p>  Je porte √† votre attention une transcription du rapport des clients internes d'Alexander Valyalkin Fasthttp. <br>  Les mod√®les Fasthttp peuvent √™tre utilis√©s pour acc√©l√©rer vos applications, votre code. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/fg3JPUswiek" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Peu importe, bienvenue au chat. </p><a name="habracut"></a><br><p>  Je suis Alexander Valyalkin.  Je travaille chez VertaMedia.  J'ai d√©velopp√© fasthttp pour nos besoins.  Il inclut l'impl√©mentation du client http et du serveur http.  Fasthttp est beaucoup plus rapide que net / http des packages Go standard. </p><br><p><img src="https://habrastorage.org/webt/mw/xn/qb/mwxnqbi-ufmc9agmni-so-gy-ls.png"></p><br><p>  Fasthttp est une impl√©mentation rapide du serveur et du client http.  Situ√© fasthttp sur github.com </p><br><p><img src="https://habrastorage.org/webt/ve/vz/07/vevz07ucp1l6ou4pg8zp2kuhvzu.png"></p><br><p>  Je pense que beaucoup ont entendu parler du serveur fasthttp, qu'il est tr√®s rapide.  Mais peu ont entendu parler du client fasthttp.  Le serveur Fasthttp participe √† la r√©f√©rence de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">techempower</a> - la c√©l√®bre r√©f√©rence dans les cercles √©troits pour les serveurs http.  Le serveur Fasthttp participe aux tours 12 et 13.  Le tour 13 n'est pas encore sorti (en 2016 - environ). </p><br><p><img src="https://habrastorage.org/webt/ow/t8/hv/owt8hvhbrxpvfxihc1golxlgp-y.png"></p><br><p>  Les r√©sultats de l'un des tests de la ronde 12, o√π fasthttp est presque au sommet.  Les chiffres indiquent le nombre de requ√™tes qu'il effectue par seconde sur ce test.  Dans ce test, une demande est faite pour une page qui renvoie bonjour le monde.  Sur hello world, fasthttp est tr√®s rapide. </p><br><p><img src="https://habrastorage.org/webt/tk/h8/1t/tkh81tfzy0ee5jt0poqw_gxmv-e.png"></p><br><p>  R√©sultats pr√©liminaires du prochain tour, qui n'a pas encore √©t√© publi√© (en 2016 - env. Ed.).  4 impl√©mentations fasthttp occupent la premi√®re place dans le benchmark, que non seulement Hello World r√©v√®le, mais qui rampe √©galement dans la base de donn√©es et forme une page HTML bas√©e sur le mod√®le. </p><br><p><img src="https://habrastorage.org/webt/lj/h1/ov/ljh1ovyrxst7hzjjgd16yk4tbmo.png"></p><br><p>  Tr√®s peu de gens connaissent le client fasthttp.  Mais en fait, il est aussi cool.  Dans ce rapport, je vais vous parler du client fasthttp du p√©riph√©rique interne et pourquoi il a √©t√© d√©velopp√©. </p><br><p><img src="https://habrastorage.org/webt/z6/rp/az/z6rpazy3l_asbpcbaklgdo8mnkq.png"></p><br><p>  Il existe en fait plusieurs clients dans fasthttp: Client, HostClient et PipelineClient.  De plus, je vais vous en dire plus sur chacun d'eux. </p><br><p><img src="https://habrastorage.org/webt/vs/ok/5u/vsok5umamlhuly1-gcfdewuxybu.png"></p><br><p>  Fasthttp.Client est un client http √† usage g√©n√©ral r√©gulier.  Avec lui, vous pouvez faire des demandes √† n'importe quel site Internet, recevoir des r√©ponses.  Ses caract√©ristiques: il fonctionne rapidement, il peut limiter le nombre de connexions ouvertes par h√¥te, contrairement au package net / http.  La documentation se trouve sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://godoc.org/github.com/valyala/fast">https://godoc.org/github.com/valyala/fasthttp#Client</a> . </p><br><p><img src="https://habrastorage.org/webt/r0/il/cc/r0ilcc3iwd6acpv1pqbawqxvfc4.png"></p><br><p>  Fasthttp.HostClient est un client sp√©cialis√© pour communiquer avec un seul serveur.  Habituellement, il est utilis√© pour acc√©der √† l'API HTTP: API REST, API JSON.  Il peut √©galement √™tre utilis√© pour proxyner le trafic depuis Internet vers un DataCenter interne sur plusieurs serveurs.  La documentation est ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://godoc.org/github.com/valyala/fast">https://godoc.org/github.com/valyala/fasthttp#HostClient</a> . </p><br><p>  Comme Fasthttp.Client, Fasthttp.HostClient peut limiter le nombre de connexions ouvertes √† chacun des serveurs principaux.  Cette fonctionnalit√© est absente dans net / http, et cette fonctionnalit√© est √©galement absente dans nginx gratuit.  Pour autant que je sache, cette fonctionnalit√© n'est disponible que dans Nginx payant. </p><br><p><img src="https://habrastorage.org/webt/sn/ys/ep/snysephpvj2u3itk5icip242ima.png"></p><br><p>  Fasthttp.PipelineClient est un client sp√©cialis√© qui vous permet de g√©rer les requ√™tes de pipeline vers un serveur ou vers un nombre limit√© de serveurs.  Il peut √™tre utilis√© pour acc√©der √† l'API, via le protocole HTTP, o√π vous devez effectuer un grand nombre de requ√™tes et le plus rapidement possible.  La limitation de Fasthttp.PipelineClient est qu'il peut souffrir d'un blocage de Head of Line.  C'est lorsque nous envoyons un grand nombre de demandes au serveur et n'attendons pas de r√©ponse √† chaque demande.  Le serveur est bloqu√© sur l'une de ces demandes.  Pour cette raison, toutes les autres requ√™tes qui l'ont suivi attendent que ce serveur traite une requ√™te lente.  Fasthttp.PipelineClient ne doit √™tre utilis√© que si vous √™tes s√ªr que le serveur r√©pondra instantan√©ment √† vos demandes.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://godoc.org/github.com/valyala/fast">La documentation</a> </p><br><p><img src="https://habrastorage.org/webt/9b/sa/z2/9bsaz297eqozr0ckcwrlbmefdqk.png"></p><br><p>  Je vais maintenant parler de l'impl√©mentation interne de chacun de ces clients.  Je vais commencer par Fasthttp.HostClient, car presque tous les autres clients sont construits sur sa base. </p><br><p><img src="https://habrastorage.org/webt/zm/vq/rt/zmvqrtpi1eogjgjqmlnvxbjh7ca.png"></p><br><p>  Il s'agit de l'impl√©mentation la plus simple du client HTTP en pseudo-code sur Go.  Nous sommes connect√©s, nous obtenons une r√©ponse http √† cette URL.  Nous nous connectons √† cet h√¥te.  Nous obtenons une connexion.  Dans ce code, afin qu'il soit inf√©rieur au volume, toutes les v√©rifications d'erreur sont manquantes.  En fait, ce n'est pas le cas.  Vous devez toujours v√©rifier les erreurs.  Cr√©ez une connexion.  Connexion √©troite avec diff√©rer.  Nous envoyons une demande de connexion par URL.  Nous recevons la r√©ponse, nous renvoyons cette r√©ponse.  Quel est le probl√®me avec cette impl√©mentation du client HTTP? </p><br><p><img src="https://habrastorage.org/webt/ev/lq/q4/evlqq4u3y3qbzr_agvrnmknzdee.png"></p><br><p>  Le premier probl√®me est que dans cette impl√©mentation, la connexion est √©tablie pour chaque requ√™te.  Cette impl√©mentation ne prend pas en charge HTTP KeepAlive.  Comment r√©soudre ce probl√®me?  Vous pouvez utiliser le pool de connexions pour chaque serveur.  Vous ne pouvez pas utiliser le pool de connexions pour tous les serveurs, car la demande suivante ne pr√©cise pas vers quel serveur envoyer.  Chaque serveur doit avoir son propre pool de connexions.  Et nous utilisons HTTP KeepAlive.  Cela signifie que l'en-t√™te de connexion n'a pas besoin de sp√©cifier la fermeture de connexion.  Dans HTTP / 1.1, par d√©faut, HTTP KeepAlive est pris en charge et Connection Close doit √™tre supprim√© de l'en-t√™te.  Voici l'impl√©mentation dans le pseudo-code client avec prise en charge du pool de connexions.  Il existe un ensemble de plusieurs pools de connexions pour chaque h√¥te.  La premi√®re fonction, connPoolForHost, renvoie le pool de connexions pour un h√¥te donn√© √† partir d'une URL donn√©e.  Ensuite, nous obtenons la connexion de ce pool de connexions, nous pr√©voyons d'utiliser Defer pour renvoyer cette connexion au pool, envoyer une demande KeepAlive pour cette connexion et renvoyer une r√©ponse.  Apr√®s la r√©ponse, Defer est ex√©cut√© et la connexion revient √† Pool.  Ainsi, nous activons le support HTTP KeepAlive et tout commence √† fonctionner plus rapidement.  Parce que nous ne perdons pas de temps √† cr√©er une connexion pour chaque demande. </p><br><p>  Mais la solution a aussi des probl√®mes.  Si vous regardez la signature de la fonction, vous pouvez voir qu'elle renvoie un objet de r√©ponse pour chaque demande.  Cela signifie que pour cet objet, vous devez allouer de la m√©moire √† chaque fois, l'initialiser et la renvoyer.  C'est mauvais pour les performances.  Cela peut √™tre mauvais si vous avez beaucoup d'appels de ce type pour obtenir des fonctions. </p><br><p><img src="https://habrastorage.org/webt/jb/yq/rr/jbyqrrzhu_qusd9j9ocba8m0czk.png"></p><br><p>  Par cons√©quent, ce probl√®me peut √™tre r√©solu tel qu'il est r√©solu dans Fasthttp en pla√ßant l'objet pointeur sur l'objet r√©ponse dans les param√®tres de cette fonction.  De cette fa√ßon, ce code appelant peut r√©utiliser cet objet de r√©ponse plusieurs fois.  Sur la diapositive se trouve la mise en ≈ìuvre de cette id√©e.  Nous transmettons une r√©f√©rence √† l'objet de r√©ponse √† la fonction Get - et la fonction remplit cette r√©ponse.  La derni√®re ligne remplit cet objet. </p><br><p><img src="https://habrastorage.org/webt/bm/z7/rq/bmz7rqtnowb5dreyup6c-er_tq0.png"></p><br><p>  Voici √† quoi cela pourrait ressembler dans votre code.  Une fonction qui accepte un canal qui re√ßoit une liste d'URL √† interroger.  Nous organiserons un cycle sur cette cha√Æne.  Nous cr√©ons un objet de r√©ponse une fois et le r√©utilisons en boucle.  Appelez Get, passez un pointeur sur l'objet, traitez cette r√©ponse.  Apr√®s l'avoir trait√©, nous le r√©initialisons √† son √©tat d'origine.  De cette fa√ßon, nous √©vitons l'allocation de m√©moire et acc√©l√©rons notre code. </p><br><p><img src="https://habrastorage.org/webt/ok/2t/5z/ok2t5zsghgoxj7ruc2z_1hhcagu.png"></p><br><p>  Le troisi√®me probl√®me est la fermeture de la connexion.  Fermeture de connexion - en-t√™te HTTP, qui peut √™tre trouv√© √† la fois dans la demande et la r√©ponse.  Si nous obtenons un tel en-t√™te, cette connexion doit √™tre ferm√©e.  Par cons√©quent, dans la mise en ≈ìuvre du client, il est n√©cessaire de pr√©voir la fermeture de la connexion.  Si vous avez envoy√© une demande avec l'en-t√™te Connexion ferm√©e, apr√®s avoir re√ßu la r√©ponse, vous devez fermer cette connexion.  Si vous avez envoy√© une demande sans fermeture de connexion et que vous avez renvoy√© une r√©ponse avec fermeture de connexion, vous devez √©galement fermer cette connexion apr√®s avoir re√ßu une r√©ponse. </p><br><p><img src="https://habrastorage.org/webt/bc/ve/up/bcveuplhhdifuc0malg7f7bm2vw.png"></p><br><p>  Voici le pseudo-code de cette impl√©mentation.  Apr√®s avoir re√ßu une r√©ponse, nous v√©rifions si les en-t√™tes de fermeture de connexion y sont install√©s.  S'il est install√©, fermez simplement la connexion.  S'il n'est pas install√©, renvoyez la connexion au pool.  Si cela n'est pas fait, alors si le serveur ferme la connexion apr√®s avoir renvoy√© les r√©ponses, votre pool de connexions contiendra la connexion interrompue que le serveur a ferm√©e, et vous essaierez d'y √©crire quelque chose et vous obtiendrez des erreurs. </p><br><p><img src="https://habrastorage.org/webt/wi/ms/gh/wimsghjdbpnjilbkgmvw5cryrvg.png"></p><br><p>  Le quatri√®me probl√®me auquel les clients HTTP sont expos√©s est les serveurs lents ou un r√©seau lent et inactif.  Les serveurs peuvent cesser de r√©pondre √† vos demandes pour diverses raisons.  Par exemple, le serveur est cass√© ou le r√©seau entre votre client et le serveur a cess√© de fonctionner.  Pour cette raison, tous vos goroutines qui appellent la fonction Get d√©crite pr√©c√©demment seront bloqu√©s, en attendant une r√©ponse du serveur ind√©finiment.  Par exemple, vous impl√©mentez un proxy http qui accepte une connexion entrante et appelle la fonction Get sur chaque connexion, puis un grand nombre de goroutines seront cr√©√©s et ils se bloqueront tous sur votre serveur jusqu'√† ce que le serveur plante, jusqu'√† ce que la m√©moire soit √©puis√©e. </p><br><p><img src="https://habrastorage.org/webt/cb/mq/1c/cbmq1c_b9ua-0ess-if8dfqkk0a.png"></p><br><p>  Comment r√©soudre ce probl√®me?  Il y a une telle d√©cision na√Øve qui vient d'abord √† l'esprit - il suffit d'envelopper ce Get dans un goroutine s√©par√©.  Ensuite, dans goroutine, passez un canal vide, qui sera ferm√© apr√®s l'ex√©cution de Get.  Apr√®s avoir d√©marr√© ce goroutine, attendez un moment sur cette cha√Æne (timeout).  Dans ce cas, si un certain temps s'√©coule et que cette Get n'est pas ex√©cut√©e, la sortie de cette fonction se produira par timeout.  Si cette Get est ex√©cut√©e, le canal se fermera et la sortie se produira.  Mais cette d√©cision est erron√©e, car elle transf√®re le probl√®me d'une t√™te malade √† une t√™te saine.  Tout de m√™me, les goroutines seront cr√©√©es et suspendues quel que soit le d√©lai d'attente que vous utilisez.  Le nombre de goroutines √† l'origine du d√©lai d'expiration de Get sera limit√©, mais un nombre illimit√© de goroutines sera cr√©√© dans Get avec un d√©lai d'expiration. </p><br><p><img src="https://habrastorage.org/webt/yx/jx/nj/yxjxnjpdobdntdoel9119aqdgyo.png"></p><br><p>  Comment r√©soudre ce probl√®me?  La premi√®re solution consiste √† limiter le nombre de goroutines bloqu√©es dans la fonction Get.  Cela peut √™tre fait en utilisant un mod√®le bien connu comme l'utilisation d'un canal tamponn√© de longueur limit√©e, qui comptera le nombre de goroutines qui ex√©cutent la fonction Get.  Si cette quantit√© de goroutine d√©passe une certaine limite - la capacit√© de ce canal, alors nous quitterons la branche par d√©faut.  Cela signifie que nous avons tous les goroutines qui sont ex√©cut√©s sont occup√©s, et dans la branche par d√©faut, nous avons juste besoin de retourner Erreur, qu'il n'y a pas de ressources libres.  Avant de cr√©er goroutine, nous essayons d'√©crire une structure vide sur ce canal.  Si cela ne fonctionne pas, nous avons d√©pass√© la quantit√© de goroutines.  Si cela s'est av√©r√©, nous cr√©ons ce gorutin et apr√®s l'ex√©cution de Get, nous lisons une valeur de ce canal.  Ainsi, nous limitons la quantit√© de goroutines qui peuvent √™tre bloqu√©es dans Get. </p><br><p><img src="https://habrastorage.org/webt/w4/id/rr/w4idrrvfykc05ahmf_hrbyscwcs.png"></p><br><p>  La deuxi√®me solution, qui compl√®te la premi√®re, consiste √† d√©finir des d√©lais d'expiration sur la connexion au serveur.  Cela d√©bloquera la fonction get si le serveur ne r√©pond pas pendant longtemps ou si le r√©seau est en panne. </p><br><p>  Si le r√©seau ne fonctionne pas dans la solution n ¬∞ 1, tout se bloque.  Apr√®s avoir tap√© cuncurrency un nombre limit√© de goroutines suspendues ici, la fonction getimeout retournera toujours une erreur.  Pour qu'il fonctionne normalement, vous avez besoin d'une deuxi√®me solution (Solution # 2), qui d√©finit un d√©lai pour la lecture et l'√©criture √† partir de la connexion.  Cela permet de d√©verrouiller les goroutines bloqu√©es si le r√©seau ou le serveur cesse de fonctionner. </p><br><p><img src="https://habrastorage.org/webt/yx/jx/nj/yxjxnjpdobdntdoel9119aqdgyo.png"></p><br><p>  La solution n ¬∞ 1 a une course aux donn√©es.  L'objet de r√©ponse √† partir duquel le pointeur a √©t√© transmis sera occup√© si Get est bloqu√©.  Mais cette fonction Get timeout peut expirer.  Dans ce cas, nous quittons cette fonction, une r√©ponse qui se bloque et apr√®s un certain temps sera r√©√©crite.  Ainsi, une course aux donn√©es est obtenue.  Puisque nous avons une r√©ponse apr√®s avoir quitt√© la fonction, elle est toujours utilis√©e quelque part dans goroutine. </p><br><p>  Le probl√®me est r√©solu en cr√©ant une copie de r√©ponse et en passant la copie de r√©ponse √† goroutine.  Une fois Get termin√©, copiez la r√©ponse de cette r√©ponse dans notre r√©ponse d'origine, qui est transmise ici.  Ainsi, la course aux donn√©es est r√©solue.  Cette copie de la r√©ponse vit un court instant et retourne dans le pool.  Nous r√©utilisons la r√©ponse.  Une copie de r√©ponse peut ne pas entrer dans le pool uniquement apr√®s expiration du d√©lai.  Par timeout, il y a une perte de r√©ponse du pool. </p><br><p><img src="https://habrastorage.org/webt/sc/cm/ar/sccmar-ze8kukg1nm5csyxz2riy.png"></p><br><p>  Dois-je fermer la connexion apr√®s que le serveur n'a pas renvoy√© de r√©ponse dans un d√©lai?  La r√©ponse est non.  Au contraire, oui, si vous souhaitez sauvegarder le serveur.  Parce que lorsque vous envoyez une demande au serveur, attendez un certain temps, le serveur ne r√©pond pas pendant ce temps - il ne r√©pond pas aux demandes.  Par exemple, vous fermez cette connexion, mais cela ne signifie pas que le serveur cessera imm√©diatement d'ex√©cuter cette demande.  Le serveur continuera de l'ex√©cuter.  Le serveur d√©tectera que cette demande n'a pas besoin d'√™tre ex√©cut√©e apr√®s avoir tent√© de vous renvoyer une r√©ponse.  Vous avez ferm√© la connexion, r√©essay√© de cr√©er une nouvelle demande, encore une fois le d√©lai √©coul√©, ferm√© √† nouveau, cr√©√© une nouvelle demande.  Vous aurez une charge sur l'augmentation du serveur.  Par cons√©quent, votre service d√©pend de vos demandes.  Ce sont des DoS au niveau des requ√™tes http.  Si vous avez des serveurs qui s'ex√©cutent lentement et que vous ne souhaitez pas les sauvegarder, vous n'avez pas besoin de fermer la connexion apr√®s un d√©lai d'expiration.  Vous devez attendre un moment, laisser la connexion expier pour ce serveur.  Laissez-le essayer de vous donner une r√©ponse.  En attendant, utilisez d'autres connexions gratuites.  Tout ce qui a √©t√© dit avant, ce sont toutes les √©tapes de l'impl√©mentation de Fasthttp.Client et les probl√®mes survenus lors de l'impl√©mentation de Fasthttp.Client.  Ces probl√®mes sont r√©solus dans Fasthttp.HostClient. </p><br><p><img src="https://habrastorage.org/webt/ht/yz/uj/htyzujg6gqaycezv_ot4_xucb6w.png">  Nous avons maintenant un client rapide?  Pas vraiment.  Vous devez voir comment le pool de connexions est impl√©ment√©. </p><br><p><img src="https://habrastorage.org/webt/tk/rs/1u/tkrs1uhjy3nlqecg_j2payseg_i.png"></p><br><p>  L'impl√©mentation na√Øve de Connection Pool ressemble √† ceci.  Il existe une sorte d'adresse de serveur o√π vous devez installer la connexion.  Il y a une liste de connexions gratuites et un verrou pour synchroniser l'acc√®s √† cette liste. </p><br><p><img src="https://habrastorage.org/webt/zb/lk/j5/zblkj5q4hygyxgd9rmrzjx2nxpa.png"></p><br><p>  Voici la fonction pour obtenir la connexion √† partir du pool de connexions.  Nous regardons une liste de notre collection.  S'il y a quelque chose l√†-bas, alors nous obtenons une connexion gratuite et le renvoyons.  S'il n'y a rien, cr√©ez une nouvelle connexion √† ce serveur et renvoyez-la.  Qu'est-ce qui ne va pas ici? </p><br><p><img src="https://habrastorage.org/webt/lw/xz/7q/lwxz7qmhwkqv3tmu4mc5f0tfumi.png">  La fonction connPool.Put renvoie une connexion gratuite. </p><br><p>  Au compte timeout.  Dans Fasthttp.Client, vous pouvez sp√©cifier la dur√©e de vie maximale d'une connexion inutilis√©e ouverte.  Une fois ce d√©lai √©coul√©, les connexions inutilis√©es sont ferm√©es automatiquement et rejet√©es de ce pool. </p><br><p>  Les connexions plus anciennes deviennent inutilis√©es au fil du temps et sont automatiquement ferm√©es et supprim√©es du pool. </p><br><p>  Lorsque la connexion est retir√©e du pool et qu'il s'av√®re que son serveur a √©t√© ferm√© et que vous avez essay√© d'y √©crire quelque chose, une deuxi√®me tentative est effectu√©e - une nouvelle connexion est obtenue et tente d'envoyer √† nouveau des demandes pour cette connexion.  Mais ce n'est que si cette demande est idempotente - c'est-√†-dire une demande qui peut √™tre ex√©cut√©e plusieurs fois sans effets secondaires sur le serveur - est-ce une demande GET ou HEAD.  Par exemple, dans le net / http standard, nous venons d'ajouter une v√©rification des connexions ferm√©es.  L√†, ils ont fait un contr√¥le plus d√©licat.  Ils v√©rifient, lorsqu'ils essaient d'envoyer une nouvelle demande √† la connexion √† partir du pool, si au moins un octet est envoy√© √† cette connexion.  S'il est d√©clench√©, retournez ensuite Erreur.  Si vous n'√™tes pas parti, nous prenons une nouvelle connexion √† partir du pool. </p><br><p><img src="https://habrastorage.org/webt/h2/ug/yv/h2ugyvjrfzht7gfwx2gemetfazy.png"></p><br><p>  Quel est le probl√®me avec la piscine?  Sa taille n'est pas limit√©e.  M√™me impl√©mentation que dans net / http.  Si vous √©crivez un client qui passe de millions de goroutines √† un serveur lent, le client tentera de cr√©er une connexion d'un million √† ce serveur.  Il n'y a pas de limite sur le nombre maximum de connexions dans le package net / http standard.  Pour le client utilis√© pour acc√©der √† l'API via HTTP, il est conseill√© de limiter la taille de ce pool de connexions.  Sinon, vos clients risquent de baisser, car vous utiliserez toutes les ressources: threads, objets, connexion, goroutines et m√©moire.  En outre, cela peut conduire √† un DoS de vos serveurs, car beaucoup de connexions seront √©tablies avec eux, qui ne sont pas utilis√©es ou sont utilis√©es de mani√®re inefficace, car le serveur ne peut pas maintenir autant de connexion. </p><br><p><img src="https://habrastorage.org/webt/km/zk/pn/kmzkpnls98apnqltus4tvoeeb5c.png"></p><br><p>  Limiter le pool de connexions.  Le code n'est pas ici, car il est trop volumineux pour tenir sur une seule diapositive.  Les personnes int√©ress√©es peuvent voir la mise en ≈ìuvre de cette fonction sur github.com. </p><br><p><img src="https://habrastorage.org/webt/ub/1a/ko/ub1akoqexz4yoqyn3xogkcwveza.png"></p><br><p>  Le deuxi√®me probl√®me.  Beaucoup de demandes arrivent au client √† un moment donn√©.  Et apr√®s cela, il y a une baisse et un retour au nombre pr√©c√©dent de demandes.  Par exemple, 10 000 demandes sont arriv√©es simultan√©ment, puis le nombre de demandes est revenu √† 1 000 par unit√© de temps.  Apr√®s cela, le pool de connexions passera √† 10000 connexions.  Ces connexions y resteront √† l'infini.  Ce probl√®me se trouvait dans le client net / http standard avant la version 1.7.  Par cons√©quent, vous devez r√©soudre ce probl√®me. </p><br><p><img src="https://habrastorage.org/webt/dm/o1/w4/dmo1w4jixcnjjjaoznw8r7zz8bw.png"></p><br><p>  Ce probl√®me est r√©solu en limitant la dur√©e de vie d'une connexion inutilis√©e.  Si pendant un certain temps aucune requ√™te n'a √©t√© envoy√©e via la connexion, elle se ferme simplement et est rejet√©e hors du pool.  Il n'y a pas d'impl√©mentation car elle est trop grande. </p><br><p><img src="https://habrastorage.org/webt/hs/wj/wx/hswjwxgrlyawxzj_t-mmdbxhh3m.png"></p><br><p>  Nous avons un client qui travaille vite et bien?  Pas vraiment comme √ßa.  Nous avons toujours la fonction de cr√©er une connexion - dialHost. </p><br><p><img src="https://habrastorage.org/webt/cl/bs/jr/clbsjrbour6diwgkjri6jpdhnx8.png"></p><br><p>  Regardons sa mise en ≈ìuvre.  Une impl√©mentation na√Øve ressemble √† ceci.  L'adresse √† laquelle vous souhaitez vous connecter est simplement transmise.  Nous appelons la fonction standard net.Dial.  Elle retourne la connexion.  Quel est le probl√®me avec cette mise en ≈ìuvre? </p><br><p><img src="https://habrastorage.org/webt/sm/b_/bc/smb_bcj41taldeo3mvnfl9ek-2g.png"></p><br><p>  Par d√©faut, net.Dial effectue une demande DNS pour chaque appel.  Cela peut entra√Æner une utilisation accrue des ressources de votre sous-syst√®me DNS.  Si les clients API se connectent √† des serveurs qui ne prennent pas en charge les connexions KeepAlive, ils ferment les connexions.  Vous √™tes pris en charge par KeepAlive, et les serveurs ne le sont pas.  Apr√®s une telle r√©ponse, le serveur ferme la connexion.  Il s'av√®re que net.Dial est appel√© √† chaque demande.  Il y a environ 10 000 demandes de ce type par seconde.  Vous avez 10 mille fois par seconde va r√©soudre en DNS.  Cela charge le sous-syst√®me DNS. </p><br><p><img src="https://habrastorage.org/webt/2j/au/e6/2jaue6kkmfwaob6p9tu-5quhgei.png"></p><br><p>  Comment r√©soudre ce probl√®me?  Cr√©ez un cache qui mappe l'h√¥te dans IP pendant une courte p√©riode directement dans votre code Go, et n'appelez pas la r√©solution DNS sur chaque net.Dial.  Connectez-vous √† des adresses IP pr√™tes √† l'emploi. </p><br><p><img src="https://habrastorage.org/webt/eh/n2/j3/ehn2j3tfuse-43qoibyq5oqqcsu.png"></p><br><p>  Le deuxi√®me probl√®me est la charge in√©gale sur le serveur si vous avez plusieurs serveurs cach√©s derri√®re le nom de domaine.  Par exemple, comme Round Robin DNS.  Si vous mettez en cache une adresse IP dans DNS pendant un certain temps, alors pendant ce temps, toutes vos demandes iront √† un serveur.  Bien que vous puissiez en avoir plusieurs.  Il est n√©cessaire de r√©soudre ce probl√®me.  Il est r√©solu en √©num√©rant toutes les adresses IP disponibles qui sont cach√©es derri√®re un nom de domaine donn√©.  Cela se fait √©galement dans Fasthttp.Client. </p><br><p><img src="https://habrastorage.org/webt/wx/hb/6r/wxhb6r3hlt_wofv6o347jyvw_oo.png"></p><br><p>  Le troisi√®me probl√®me est que net.Dial peut √©galement se bloquer ind√©finiment en raison de probl√®mes avec le r√©seau ou le serveur auquel vous essayez de vous connecter.  Dans ce cas, vos goroutines se bloqueront sur la fonction Get.  Cela peut √©galement conduire √† une utilisation accrue des ressources. </p><br><p><img src="https://habrastorage.org/webt/jc/k3/id/jck3idzikb6vyzvsbcuckeg8wae.png">  La solution consiste √† ajouter un d√©lai d'attente.   Dial     package net. ,   ,   . ,    ,      ,   . </p><br><p><img src="https://habrastorage.org/webt/cb/mq/1c/cbmq1c_b9ua-0ess-if8dfqkk0a.png"></p><br><p>     .  Get  Dial .    - .  Dial ,  ,   .   ,  ,   .    DialTimeout. ,   . </p><br><p><img src="https://habrastorage.org/webt/jo/tn/t0/jotnt0t9nwul2jx8sym4-kycfvu.png"></p><br><p>   HostClient   . </p><br><p> HostClient      ,   .     LoadBalance. </p><br><p>  HostClient    .          ,  HostClient        .   connection       .     .     . </p><br><p> Fauly host     . </p><br><p>   ‚Äî        .   Dial.    ,     Dial. Get,  ,   - .   ,           .  ,       ,   . </p><br><p>   ‚Äî      .   Get   ,   .     ,    ,  ,    . </p><br><p>   Error ,     Round Robin    . </p><br><p>  SSL   ,    Golang   .        . </p><br><p><img src="https://habrastorage.org/webt/py/wf/93/pywf93cfwemlknabq_iejxfgpt4.png"></p><br><p>   fasthttp.Client.           HostClient,   fasthttp.Client    HostClient. </p><br><p><img src="https://habrastorage.org/webt/0s/f8/mz/0sf8mzfxpk1nl5lucgjvwaqkgy8.png"></p><br><p>        Get.     HostClient    .      HostClient      .     HostClient   Get.       HostClient. </p><br><p><img src="https://habrastorage.org/webt/xd/nf/u8/xdnfu88duh8s5ibm0qx_riwe4go.png"></p><br><p>       HostClient  -  ,      URL.    web-crawling (  ),        .        HostClient       .      net/http,      .    ,    HostClient,      .   fasthttp. </p><br><p><img src="https://habrastorage.org/webt/r2/f7/bk/r2f7bkykq6m6oqcd3ylss9rwdr4.png"></p><br><p>    Client  HostClient,  PipelineClient   .  PipelineClient  connection pool.  PipelineClient    connection,     . PipelineClient         connection.     connection pool. PipelineClient   connection       . </p><br><p><img src="https://habrastorage.org/webt/lj/vw/ew/ljvwewxdpm8ag50y-tcfzthrxia.png"></p><br><p>  PipelineClient   connection   . PipelineConnClient.writer ‚Äî    connection,   . PipelineConnClient.reader ‚Äî     connection     ,     PipelineConnClient.writer. PipelineConnClient.reader   ,     Get. </p><br><p><img src="https://habrastorage.org/webt/nj/9q/lp/nj9qlpw3mexynplnky52vvhcar4.png"></p><br><p>      PipelineClient.Get  PipelineClient.   pipelineWork  url,    ,    response,  channel done,     response. </p><br><p>     Get. C   .    channel,   PipelineConnClient.writer      connection.   channel w.done,   PipelineConnClient.reader,   response   request. </p><br><p><img src="https://habrastorage.org/webt/s4/vf/oq/s4vfoqg_mmutotfdw66gs4nbxvs.png"></p><br><p>   net/http   fasthttp.Client   2 . </p><br><p><img src="https://habrastorage.org/webt/ah/ra/-o/ahra-oaf0uydcje9yqofoh6l-6k.png"></p><br><p> ,     ,   fasthttp.     , , .    fasthttp. ,      fasthttp,          .    allocation  .         . </p><br><p><img src="https://habrastorage.org/webt/q6/c3/ss/q6c3ss7kpmkwwlxk01o_ffyqhs0.png"></p><br><p>     net/http. ,  allocation    net/nttp.       . </p><br><p><img src="https://habrastorage.org/webt/jm/fh/sg/jmfhsgqsqoiwblgnfsliiytqauw.png"></p><br><p> :  PipelineClient      connection? </p><br><p> :     ‚Äî  pending ,      .     .    request,      pending ,   Error. </p><br><p> :    API   ,    fasthttp,  net/http? </p><br><p> :  .     net/http     .        .  string -,  string   .  ,     net/http,   .    -     ,    .  fasthttp     ,     .    .   net/http   fasthttp  ,    net/http     POST-,   response,  () .   fasthttp  ,  request  response    .    10 request   10 response .    ,      .    fasthttp   10 request   10 response?         .           ‚Äî    .            ,     net/http.           . ,  net/http   ‚Äî    . </p><br><p> PS        . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    </a> . </p><br><p>     ‚Äî     . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443378/">https://habr.com/ru/post/fr443378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443360/index.html">Un regard de l'int√©rieur. Ecole doctorale √† l'EPFL. Partie 3: de la r√©ception √† la protection</a></li>
<li><a href="../fr443364/index.html">Comment une holding m√©diatique peut lancer 12 startups prosp√®res par an</a></li>
<li><a href="../fr443368/index.html">Nous pr√©parons une recherche plein texte dans Postgres. 2e partie</a></li>
<li><a href="../fr443372/index.html">Backend sur CodeFest. Des tripes command√©es?</a></li>
<li><a href="../fr443376/index.html">G√©r√© pour trouver des dizaines de stockages d'entreprise Box.com qui divulguent des donn√©es d'Apple, Herbalife, etc.</a></li>
<li><a href="../fr443380/index.html">UDB. Qu'est-ce que c'est? Partie 6. Module d'√©tat et de contr√¥le</a></li>
<li><a href="../fr443382/index.html">Fintech Digest: Mir Pay pour Android, levant l'interdiction de retirer de l'argent des portefeuilles anonymes, les startups de l'IA ne sont pas exactement de l'IA</a></li>
<li><a href="../fr443384/index.html">Slurm et MegaSlerm √† Moscou fin mai</a></li>
<li><a href="../fr443386/index.html">Comment obtenir le journal de s√©curit√© avec un utilisateur non administrateur</a></li>
<li><a href="../fr443388/index.html">Contr√¥le d'√©clairage √† plusieurs niveaux bas√© sur KTS NPL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>