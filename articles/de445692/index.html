<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🌾 🤞🏿 🐲 Übersicht über die PlayCanvas-Funktionen zum Erstellen von Web-VR-Anwendungen 🔻 👩🏻‍🤝‍👨🏾 💍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PlayCanvas ist eine visuelle Plattform für die Entwicklung interaktiver Webanwendungen. Alles, was mit PlayCanvas entwickelt wird, basiert auf den Fun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Übersicht über die PlayCanvas-Funktionen zum Erstellen von Web-VR-Anwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445692/"><img src="https://habrastorage.org/webt/mu/fu/yq/mufuyqm46wxnzg_gaz5wyehcajs.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PlayCanvas</a> ist eine visuelle Plattform für die Entwicklung interaktiver Webanwendungen.  Alles, was mit PlayCanvas entwickelt wird, basiert auf den Funktionen von HTML5.  PlayCanvas ist eine Webanwendung, dh Sie müssen keine speziellen Programme installieren und können von jedem Gerät auf der ganzen Welt über das Internet auf Ihr Projekt zugreifen.  Alle von Ihnen erstellten Projekte können mit nur einem Klick im Netzwerk platziert werden. <br><a name="habracut"></a><br><h2>  Workflow in PlayCanvas </h2><br><img src="https://habrastorage.org/webt/ws/oo/di/wsoodieak3-adlz0md5-wl_ojlc.png"><br><br>  Alles in PlayCanvas beginnt mit einem visuellen Editor. <br><br>  Auf der linken Seite des Bildschirms befindet sich ein Abschnitt der Entitätshierarchie.  Sie können sowohl leere als auch vordefinierte Objekte erstellen, z. B. Kameras, Lichter, Grundelemente, Audio, Schnittstellen, Partikelsysteme oder Modelle.  Jede der Hierarchie hinzugefügte Entität betritt automatisch die Szene. <br><br>  In der Mitte des Bildschirms befindet sich der Szeneneditor.  Hier können Sie die Anordnung von Entitäten ändern, sie zum Bearbeiten auswählen und einfach anzeigen, wie Ihre Anwendungsszene aussehen wird. <br><br>  Am unteren Rand des Szeneneditors befindet sich der Asset-Bereich.  Assets sind alle Dateien und andere Elemente, die Ihren Entitäten hinzugefügt werden können.  In PlayCanvas gibt es verschiedene Arten von Assets: Ordner, CSS, Cubemap, HTML, JSON, Material, Skript, Shader und Text.  Alle von ihnen haben unterschiedliche Zwecke. <br><br>  Und schließlich befindet sich auf der rechten Seite des Bildschirms ein Abschnitt der Entitätseigenschaften.  Eine Entität verfügt über grundlegende Eigenschaften: Position, Drehung, Skalierung, Name, Tags, Einstellungen der hinzugefügten Komponenten.  Die Eigenschaften ändern sich je nachdem, welche Entität hinzugefügt wird.  Wenn wir beispielsweise einen Würfel hinzufügen, hat dieser die folgenden Eigenschaften: Typ, Material, Schatteneinstellungen, Ebenen und Gruppen. <br><br>  Der allgemeine Prozess zum Entwickeln von Anwendungen und Spielen in PlayCanvas sieht ungefähr wie folgt aus: <br><br><ol><li>  Wir fügen die notwendigen Vermögenswerte hinzu.  Zum Beispiel: Modelle, Materialien, Audio, Video. </li><li>  Wir schaffen die Umgebung unserer Szene.  Zum Beispiel: Stadt, Haus, Landschaft. </li><li>  Fügen Sie interaktive Elemente hinzu.  Zum Beispiel: ein Spieler und seine Feinde. </li><li>  Fügen Sie Anwendungslogik mithilfe von Skripten hinzu. </li><li>  Veröffentlichen Sie ein Spiel oder eine Anwendung online. </li></ol><br><h2>  PlayCanvas und JavaScript </h2><br><img src="https://habrastorage.org/webt/ba/ho/_t/baho_trfpv1_buk71c4wj8gfzqi.png"><br><br>  Um unserem Spiel oder unserer Anwendung in PlayCanvas Logik hinzuzufügen, gibt es eine spezielle Komponente: ein Skript.  Skripte können global sein. In diesem Fall müssen sie der Stammentität der Szenenhierarchie hinzugefügt werden.  Lokale Skripte werden direkt zur Entität innerhalb der Hierarchie hinzugefügt (z. B. zum Modell des Spielcharakters).  Alle Skripte müssen seitdem in JavaScript geschrieben sein  Schließlich schreiben wir Spiele im Browser.  ES6-Liebhaber werden leider enttäuscht sein, weil  PlayCanvas verwendet immer noch ES5, und wenn Sie versuchen, ein Design aus ES6 zu schreiben, beginnt der eingebaute Linter zu schwören.  Im Allgemeinen entspricht die Anatomie des Skripts der folgenden Vorlage: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> NewScript = pc.createScript(<span class="hljs-string"><span class="hljs-string">'newScript'</span></span>); NewScript.attributes.add(<span class="hljs-string"><span class="hljs-string">'someString'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">default</span></span>: <span class="hljs-string"><span class="hljs-string">'any'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Some string'</span></span> }); NewScript.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.getPosition(); }; NewScript.prototype.update = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.setLocalPosition(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newPosition); }; NewScript.prototype.calcaulateNewPosition = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startPosition.dot(pc.Vec3.ZERO) };</code> </pre> <br>  Hier erstellen wir ein neues Skript.  Er erhält zwei Hauptmethoden: initialize - wird aufgerufen, wenn die Entität zur Szene hinzugefügt wird.  Update - Jeder Render-Frame wird aufgerufen.  Der Parameter dt in update ist die Deltazeit -% der Sekunde, für die der letzte Frame gezeichnet wurde.  Dies wird durch das folgende Beispiel gut veranschaulicht: Sie müssen ein Objekt in einer Sekunde um 360 Grad drehen.  Wir schreiben den folgenden Code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.rotate(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">360</span></span> * dt, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Schließlich ist die letzte <i>calcaulateNewPosition-</i> Methode eine benutzerdefinierte Methode und kann zum Strukturieren von Code verwendet werden. <br><br>  Auch im Code gibt es die Möglichkeit, ein neues Attribut <i>someString hinzuzufügen</i> .  Mit diesem Design können Sie Parameter definieren, die über die Editoroberfläche weiter spezifiziert werden können.  Um der ausgewählten Entität ein Skript hinzuzufügen, klicken Sie auf die Schaltfläche <b>"Analysieren"</b> .  Wenn das Skript eine Konstruktion mit Attributen hatte, wird ein spezielles Feld angezeigt, um den Wert auszufüllen.  Dieser Wert überschreibt den Standardwert.  PlayCanvas unterstützt viele verschiedene Arten von Attributen für ein Skript.  Mehr dazu lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Skripte können sowohl im integrierten Editor als auch auf Ihrem lokalen Computer in einer für Sie geeigneten IDE bearbeitet werden.  Im zweiten Fall müssen Sie jedoch mit den Einstellungen herumspielen, da Sie den mit PlayCanvas gekoppelten Server erhöhen müssen. <br><br>  Nun, da wir die Hauptfunktionen von PlayCanvas behandelt haben, können wir darüber sprechen, wie Virtual-Reality-Szenen in PlayCanvas erstellt werden. <br><br><h2>  VR aus der Box </h2><br><img src="https://habrastorage.org/webt/ih/qs/rb/ihqsrbmkce9ju7q-dzb93z8c7oa.png"><br><br>  Mit PlayCanvas können Sie sofort eine VR-Szene erstellen.  Wählen Sie dazu beim Erstellen eines neuen Projekts die entsprechende Option (VR Starter Kit).  Mal sehen, was uns die Standard-PlayCanvas bieten (Spoiler: nicht so viele, wie wir möchten). <br><br>  Wenn Sie die Szene laufen lassen, sehen Sie drei Würfel vor sich.  Wenn Sie sie betrachten (Blicksteuerung), wird ein Fortschrittsbalken gestartet, der den Würfel transparent macht.  Keine Controller oder WASD-Steuerungen für PC.  Im Wesentlichen können Sie mit dieser Verwaltung eine kleine Anwendung für Kartons erstellen, da dort standardmäßig Berührungsereignisse unterstützt werden. <br><br>  Der Code unseres Starter-VR-Kits ist in der Tat nicht sehr gut strukturiert und einige seiner Teile sind direkt mit der Logik dieser Szene verbunden.  Das heißt, um etwas anderes zu tun, müssen Sie herausfinden, wie alles funktioniert, und sich an Ihre Bedürfnisse anpassen.  Es gibt keine API, mit der Sie Funktionen separat verbinden können. <br><br>  Lassen Sie uns nun versuchen, die Starter-Kit-Dateien durchzugehen, um herauszufinden, wofür verantwortlich ist und wie Sie es für Ihre eigenen Zwecke verwenden können. <br><br><ul><li>  <b>look-camera.js</b> .  Hier ist die Logik, die für das Koppeln von VR-Display und Kamera verantwortlich ist.  Darüber hinaus können wir mit mouse-controller.js oder touch-controller.js Tonhöhe und Gieren übertragen, um die Kamera von einem PC oder Mobiltelefon aus zu steuern. </li><li>  <b>selector-camera.js</b> .  Diese Datei verfügt über eine versteckte Logik zum Implementieren der Blicksteuerung.  Jedes Element, das für die Interaktion verfügbar ist, muss über die Auswahlkamera hinzugefügt werden: Ereignis hinzufügen.  Außerdem muss der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AABB</a> manuell berechnet werden. Auch hier finden Sie die Strahlenlogik (ray \ raycaster).  PlayCanvas hat ein spezielles Objekt this._ray = new pc.Ray ();  die weiß, wie man Schnittpunkte mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BoundingBox</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BoundingSphere findet</a> . </li><li>  <b>web-vr-ui.js</b> .  Fügt einfach eine VR-Anmeldeschnittstelle hinzu.  Ehrlich gesagt ist das nicht sehr elegant.  Alle Stile und HTML befinden sich direkt in diesem Skript.  Anscheinend liegt dies daran, dass der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2D-Bildschirm</a> für Schnittstellen seine eigenen Einschränkungen hat und sich die Schaltfläche ausschließlich in der unteren rechten Ecke befinden sollte. </li><li>  <b>box.js.</b>  Hier finden Sie die gesamte Logik, die mit der Cube-Verwaltung des Fortschrittsbalkens usw. verbunden ist. </li></ul><br>  Wie Sie oben sehen können, gibt es im VR-Startkit nicht viel, worauf Sie sich verlassen können.  Alles, was getan werden kann, ist eine Pappanwendung, und dies ist meiner Meinung nach nicht sehr interessant, da Pappen eine Art Spielzeug sind, das keine Vorstellung von der normalen Erfahrung mit VR vermittelt.  Mit Oculus Go, Oculus Rift oder HTC Vive können Sie wirklich in die virtuelle Realität eintauchen. <br><br>  Lassen Sie uns nun darüber sprechen, wie wir unserer Anwendung Controller-Unterstützung hinzufügen können. <br><br><h2>  VR-Controller </h2><br><img src="https://habrastorage.org/webt/tu/ev/9f/tuev9fuqge3rucidyes50bkmaeo.png"><br><br>  Es wäre schön, wenn PlayCanvas seinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicher</a> so anpassen würde, dass verschiedene Elemente, die mit der erforderlichen Logik verbunden sind, mit einer Taste mit der Anwendung verbunden werden könnten.  Aber heute ist dies nicht möglich. Versuchen wir es also anders.  Um nicht die gesamte Logik zum Vergleichen der Position der Steuerungen zu schreiben, können wir vorhandene Lösungen verwenden.  Es gibt ein großartiges Beispiel für ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web VR Lab</a> .  Es gibt viele interessante Dinge, aber der Code ... der Teufel selbst wird sich das Bein brechen.  Es gibt auch eine kleine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VR Tracked Controller-</a> Szene - nur eine einfache Szene mit zwei Controllern.  Hier ist es genauso und eignet sich zum Ausleihen von Elementen in Ihr Projekt. <br><br>  Öffnen Sie die VR Tracked Controller-Szene zur Bearbeitung.  Zuerst müssen wir den Controller übertragen: <br><br><ol><li>  Wir wählen den Controller aus, im Abschnitt Eigenschaften finden wir das Modell, klicken darauf und greifen als Asset darauf zu. </li><li>  In den Einstellungen befindet sich eine Schaltfläche zum Herunterladen, auf die wir klicken und das Modell und die Texturen herunterladen. </li><li>  Entpacken Sie die Assets und laden Sie sie in Ihre Anwendung.  Ziehen Sie sie dazu einfach in das Asset-Fenster, das sich unten befindet.  Sie müssen alles übertragen: ein Modell im JSON-Format und alle Texturen. </li><li>  Das Modell wird in unserer Liste der Assets angezeigt.  Ziehen Sie es auf die Bühne.  Und hier ist sie schon da.  Nennen wir es Left Controller. </li></ol><br>  Jetzt müssen wir das Material hinzufügen: <br><br><ol><li>  Erstellen Sie ein neues Material, indem Sie im Asset-Bereich auf die Schaltfläche <b>„+“</b> klicken.  Nennen Sie das Material Controller Material. </li><li>  Jetzt müssen wir das Quellprojekt öffnen und dort das Tracked-Controller-Material finden und alle Einstellungen in unser Material kopieren, einschließlich normaler, emittierender, spiegelnder und diffuser Karten (Karten). </li></ol><br>  Jetzt können Sie den Controller mit der speziellen Schaltfläche Duplizieren im Hierarchiefenster kopieren und den zweiten Controller als richtigen Controller bezeichnen. <br><br>  Das war's, die Controller auf unserer Bühne.  Bisher sind dies jedoch nur zwei Modelle. Damit alles funktioniert, müssen die Skripte übertragen werden.  Lassen Sie uns genauer sehen, was dort benötigt wird und wie es funktioniert: <br><br><ul><li>  <b>vr-gamepad-manager.js</b> - enthält im Wesentlichen die gesamte Logik, die Ihre Controller <b>benötigen</b> , um die Position und Drehung des realen Controllers zu ermitteln.  Hier wird die Fake-Elbow-Logik für 3-Dof-Helme wie Oculus Go, Gear VR oder Daydream implementiert.  _updatePadToHandMappings ist hier dafür verantwortlich, Controller zu lokalisieren und sie unseren Controllern zuzuordnen.  Die gesamte Logik zum Abgleichen des realen und des virtuellen Controllers befindet sich in der Funktion _poseToWorld.  Tatsächlich werden hier die Daten von der WebXR-API über die Instanz des Controllers selbst übernommen - padPose.position, padPose.poseRotation.  Die folgende Logik ist für die Nuancen verantwortlich, die mit verschiedenen Gerätetypen verbunden sind.  Das Skript selbst muss global sein (d. H. Zum Stamm der Hierarchie hinzugefügt werden). </li><li>  <b>input-vr.js</b> - ist verantwortlich für die Registrierung unserer Controller und die Arbeit mit Tasten.  Tatsächlich bestimmt es einfach den Tastendruck und sendet die Nummer des gedrückten Knopfes.  Dies ist nicht sehr praktisch, da verschiedene Geräte möglicherweise unterschiedliche Tasten und eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GamePad-API</a> haben und es keine Tatsache ist, dass die erste Taste in Oculus Go ein Auslöser für den HTC Vive-Controller ist.  Daher müssen Sie manuell graben.  Dieses Skript muss mit dem Controller-Element verbunden sein. </li></ul><br>  Wenn alles richtig gemacht ist, können Sie in die virtuelle Realität eintreten und Ihre Controller winken lassen.  Nicht schlecht, obwohl der Prozess der Integration der erforderlichen Funktionalität ziemlich unpraktisch und langwierig ist. <br><br><h2>  Insgesamt </h2><br>  PlayCanvas ist eine hervorragende Engine, mit der Sie WebGL-Spiele oder -Anwendungen erstellen können.  Aber ich muss zugeben, dass es für WebVR schlecht angepasst ist.  Es scheint, dass das Ziel darin bestand, zu demonstrieren, was PlayCanvas tun kann, um das öffentliche Interesse zu fördern.  Aber diese Richtung hat offenbar keine Entwicklung erhalten.  Daher können Sie ein VR-Spiel oder eine VR-Anwendung erstellen, müssen jedoch viel kopieren und den komplizierten Code verstehen, der nur zur Demonstration erstellt wurde (Web VR Lab). <br><br>  Im nächsten Artikel möchte ich eine kleine Lektion zum Erstellen einer Teleport-Steuerung durchführen, damit wir zumindest ein kleines Set haben, mit dem Sie ein Web-VR-Spiel oder eine Web-VR-Anwendung starten können.  Vielen Dank für Ihre Aufmerksamkeit! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445692/">https://habr.com/ru/post/de445692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445678/index.html">4. Check Point Erste Schritte R80.20. Installation und Initialisierung</a></li>
<li><a href="../de445680/index.html">Neues Feature in Git 3: Schließungen</a></li>
<li><a href="../de445682/index.html">PVS-Studio für Java wird an den Pfad gesendet. Nächster Halt ist Elasticsearch</a></li>
<li><a href="../de445684/index.html">Monoblock gegen modulare USV</a></li>
<li><a href="../de445686/index.html">Anwendungsentwicklung für einen alten PDA (Cybiko Xtreme) im Jahr 2019</a></li>
<li><a href="../de445696/index.html">Wie Roboter entstehen, die dahin gehen können, wo wir sind</a></li>
<li><a href="../de445698/index.html">NanoCAD-Lizenzierung</a></li>
<li><a href="../de445700/index.html">„33 Wörter über Design“: Wer und warum macht einen Film über Design in Russland?</a></li>
<li><a href="../de445702/index.html">SlowPochta - Messenger für ungerechtfertigte Zustellung von Nachrichten mit unbestimmter Weiterleitungszeit</a></li>
<li><a href="../de445704/index.html">Citymobil - ein Leitfaden für Startups zur Erhöhung der Stabilität bei Wachstum. Teil 2. Welche Arten von Unfällen gibt es?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>