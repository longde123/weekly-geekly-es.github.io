<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüåæ ü§ûüèø üê≤ √úbersicht √ºber die PlayCanvas-Funktionen zum Erstellen von Web-VR-Anwendungen üîª üë©üèª‚Äçü§ù‚Äçüë®üèæ üíç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PlayCanvas ist eine visuelle Plattform f√ºr die Entwicklung interaktiver Webanwendungen. Alles, was mit PlayCanvas entwickelt wird, basiert auf den Fun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úbersicht √ºber die PlayCanvas-Funktionen zum Erstellen von Web-VR-Anwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445692/"><img src="https://habrastorage.org/webt/mu/fu/yq/mufuyqm46wxnzg_gaz5wyehcajs.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PlayCanvas</a> ist eine visuelle Plattform f√ºr die Entwicklung interaktiver Webanwendungen.  Alles, was mit PlayCanvas entwickelt wird, basiert auf den Funktionen von HTML5.  PlayCanvas ist eine Webanwendung, dh Sie m√ºssen keine speziellen Programme installieren und k√∂nnen von jedem Ger√§t auf der ganzen Welt √ºber das Internet auf Ihr Projekt zugreifen.  Alle von Ihnen erstellten Projekte k√∂nnen mit nur einem Klick im Netzwerk platziert werden. <br><a name="habracut"></a><br><h2>  Workflow in PlayCanvas </h2><br><img src="https://habrastorage.org/webt/ws/oo/di/wsoodieak3-adlz0md5-wl_ojlc.png"><br><br>  Alles in PlayCanvas beginnt mit einem visuellen Editor. <br><br>  Auf der linken Seite des Bildschirms befindet sich ein Abschnitt der Entit√§tshierarchie.  Sie k√∂nnen sowohl leere als auch vordefinierte Objekte erstellen, z. B. Kameras, Lichter, Grundelemente, Audio, Schnittstellen, Partikelsysteme oder Modelle.  Jede der Hierarchie hinzugef√ºgte Entit√§t betritt automatisch die Szene. <br><br>  In der Mitte des Bildschirms befindet sich der Szeneneditor.  Hier k√∂nnen Sie die Anordnung von Entit√§ten √§ndern, sie zum Bearbeiten ausw√§hlen und einfach anzeigen, wie Ihre Anwendungsszene aussehen wird. <br><br>  Am unteren Rand des Szeneneditors befindet sich der Asset-Bereich.  Assets sind alle Dateien und andere Elemente, die Ihren Entit√§ten hinzugef√ºgt werden k√∂nnen.  In PlayCanvas gibt es verschiedene Arten von Assets: Ordner, CSS, Cubemap, HTML, JSON, Material, Skript, Shader und Text.  Alle von ihnen haben unterschiedliche Zwecke. <br><br>  Und schlie√ülich befindet sich auf der rechten Seite des Bildschirms ein Abschnitt der Entit√§tseigenschaften.  Eine Entit√§t verf√ºgt √ºber grundlegende Eigenschaften: Position, Drehung, Skalierung, Name, Tags, Einstellungen der hinzugef√ºgten Komponenten.  Die Eigenschaften √§ndern sich je nachdem, welche Entit√§t hinzugef√ºgt wird.  Wenn wir beispielsweise einen W√ºrfel hinzuf√ºgen, hat dieser die folgenden Eigenschaften: Typ, Material, Schatteneinstellungen, Ebenen und Gruppen. <br><br>  Der allgemeine Prozess zum Entwickeln von Anwendungen und Spielen in PlayCanvas sieht ungef√§hr wie folgt aus: <br><br><ol><li>  Wir f√ºgen die notwendigen Verm√∂genswerte hinzu.  Zum Beispiel: Modelle, Materialien, Audio, Video. </li><li>  Wir schaffen die Umgebung unserer Szene.  Zum Beispiel: Stadt, Haus, Landschaft. </li><li>  F√ºgen Sie interaktive Elemente hinzu.  Zum Beispiel: ein Spieler und seine Feinde. </li><li>  F√ºgen Sie Anwendungslogik mithilfe von Skripten hinzu. </li><li>  Ver√∂ffentlichen Sie ein Spiel oder eine Anwendung online. </li></ol><br><h2>  PlayCanvas und JavaScript </h2><br><img src="https://habrastorage.org/webt/ba/ho/_t/baho_trfpv1_buk71c4wj8gfzqi.png"><br><br>  Um unserem Spiel oder unserer Anwendung in PlayCanvas Logik hinzuzuf√ºgen, gibt es eine spezielle Komponente: ein Skript.  Skripte k√∂nnen global sein. In diesem Fall m√ºssen sie der Stammentit√§t der Szenenhierarchie hinzugef√ºgt werden.  Lokale Skripte werden direkt zur Entit√§t innerhalb der Hierarchie hinzugef√ºgt (z. B. zum Modell des Spielcharakters).  Alle Skripte m√ºssen seitdem in JavaScript geschrieben sein  Schlie√ülich schreiben wir Spiele im Browser.  ES6-Liebhaber werden leider entt√§uscht sein, weil  PlayCanvas verwendet immer noch ES5, und wenn Sie versuchen, ein Design aus ES6 zu schreiben, beginnt der eingebaute Linter zu schw√∂ren.  Im Allgemeinen entspricht die Anatomie des Skripts der folgenden Vorlage: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> NewScript = pc.createScript(<span class="hljs-string"><span class="hljs-string">'newScript'</span></span>); NewScript.attributes.add(<span class="hljs-string"><span class="hljs-string">'someString'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">default</span></span>: <span class="hljs-string"><span class="hljs-string">'any'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Some string'</span></span> }); NewScript.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.getPosition(); }; NewScript.prototype.update = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.setLocalPosition(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newPosition); }; NewScript.prototype.calcaulateNewPosition = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startPosition.dot(pc.Vec3.ZERO) };</code> </pre> <br>  Hier erstellen wir ein neues Skript.  Er erh√§lt zwei Hauptmethoden: initialize - wird aufgerufen, wenn die Entit√§t zur Szene hinzugef√ºgt wird.  Update - Jeder Render-Frame wird aufgerufen.  Der Parameter dt in update ist die Deltazeit -% der Sekunde, f√ºr die der letzte Frame gezeichnet wurde.  Dies wird durch das folgende Beispiel gut veranschaulicht: Sie m√ºssen ein Objekt in einer Sekunde um 360 Grad drehen.  Wir schreiben den folgenden Code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.rotate(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">360</span></span> * dt, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Schlie√ülich ist die letzte <i>calcaulateNewPosition-</i> Methode eine benutzerdefinierte Methode und kann zum Strukturieren von Code verwendet werden. <br><br>  Auch im Code gibt es die M√∂glichkeit, ein neues Attribut <i>someString hinzuzuf√ºgen</i> .  Mit diesem Design k√∂nnen Sie Parameter definieren, die √ºber die Editoroberfl√§che weiter spezifiziert werden k√∂nnen.  Um der ausgew√§hlten Entit√§t ein Skript hinzuzuf√ºgen, klicken Sie auf die Schaltfl√§che <b>"Analysieren"</b> .  Wenn das Skript eine Konstruktion mit Attributen hatte, wird ein spezielles Feld angezeigt, um den Wert auszuf√ºllen.  Dieser Wert √ºberschreibt den Standardwert.  PlayCanvas unterst√ºtzt viele verschiedene Arten von Attributen f√ºr ein Skript.  Mehr dazu lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Skripte k√∂nnen sowohl im integrierten Editor als auch auf Ihrem lokalen Computer in einer f√ºr Sie geeigneten IDE bearbeitet werden.  Im zweiten Fall m√ºssen Sie jedoch mit den Einstellungen herumspielen, da Sie den mit PlayCanvas gekoppelten Server erh√∂hen m√ºssen. <br><br>  Nun, da wir die Hauptfunktionen von PlayCanvas behandelt haben, k√∂nnen wir dar√ºber sprechen, wie Virtual-Reality-Szenen in PlayCanvas erstellt werden. <br><br><h2>  VR aus der Box </h2><br><img src="https://habrastorage.org/webt/ih/qs/rb/ihqsrbmkce9ju7q-dzb93z8c7oa.png"><br><br>  Mit PlayCanvas k√∂nnen Sie sofort eine VR-Szene erstellen.  W√§hlen Sie dazu beim Erstellen eines neuen Projekts die entsprechende Option (VR Starter Kit).  Mal sehen, was uns die Standard-PlayCanvas bieten (Spoiler: nicht so viele, wie wir m√∂chten). <br><br>  Wenn Sie die Szene laufen lassen, sehen Sie drei W√ºrfel vor sich.  Wenn Sie sie betrachten (Blicksteuerung), wird ein Fortschrittsbalken gestartet, der den W√ºrfel transparent macht.  Keine Controller oder WASD-Steuerungen f√ºr PC.  Im Wesentlichen k√∂nnen Sie mit dieser Verwaltung eine kleine Anwendung f√ºr Kartons erstellen, da dort standardm√§√üig Ber√ºhrungsereignisse unterst√ºtzt werden. <br><br>  Der Code unseres Starter-VR-Kits ist in der Tat nicht sehr gut strukturiert und einige seiner Teile sind direkt mit der Logik dieser Szene verbunden.  Das hei√üt, um etwas anderes zu tun, m√ºssen Sie herausfinden, wie alles funktioniert, und sich an Ihre Bed√ºrfnisse anpassen.  Es gibt keine API, mit der Sie Funktionen separat verbinden k√∂nnen. <br><br>  Lassen Sie uns nun versuchen, die Starter-Kit-Dateien durchzugehen, um herauszufinden, wof√ºr verantwortlich ist und wie Sie es f√ºr Ihre eigenen Zwecke verwenden k√∂nnen. <br><br><ul><li>  <b>look-camera.js</b> .  Hier ist die Logik, die f√ºr das Koppeln von VR-Display und Kamera verantwortlich ist.  Dar√ºber hinaus k√∂nnen wir mit mouse-controller.js oder touch-controller.js Tonh√∂he und Gieren √ºbertragen, um die Kamera von einem PC oder Mobiltelefon aus zu steuern. </li><li>  <b>selector-camera.js</b> .  Diese Datei verf√ºgt √ºber eine versteckte Logik zum Implementieren der Blicksteuerung.  Jedes Element, das f√ºr die Interaktion verf√ºgbar ist, muss √ºber die Auswahlkamera hinzugef√ºgt werden: Ereignis hinzuf√ºgen.  Au√üerdem muss der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AABB</a> manuell berechnet werden. Auch hier finden Sie die Strahlenlogik (ray \ raycaster).  PlayCanvas hat ein spezielles Objekt this._ray = new pc.Ray ();  die wei√ü, wie man Schnittpunkte mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BoundingBox</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BoundingSphere findet</a> . </li><li>  <b>web-vr-ui.js</b> .  F√ºgt einfach eine VR-Anmeldeschnittstelle hinzu.  Ehrlich gesagt ist das nicht sehr elegant.  Alle Stile und HTML befinden sich direkt in diesem Skript.  Anscheinend liegt dies daran, dass der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2D-Bildschirm</a> f√ºr Schnittstellen seine eigenen Einschr√§nkungen hat und sich die Schaltfl√§che ausschlie√ülich in der unteren rechten Ecke befinden sollte. </li><li>  <b>box.js.</b>  Hier finden Sie die gesamte Logik, die mit der Cube-Verwaltung des Fortschrittsbalkens usw. verbunden ist. </li></ul><br>  Wie Sie oben sehen k√∂nnen, gibt es im VR-Startkit nicht viel, worauf Sie sich verlassen k√∂nnen.  Alles, was getan werden kann, ist eine Pappanwendung, und dies ist meiner Meinung nach nicht sehr interessant, da Pappen eine Art Spielzeug sind, das keine Vorstellung von der normalen Erfahrung mit VR vermittelt.  Mit Oculus Go, Oculus Rift oder HTC Vive k√∂nnen Sie wirklich in die virtuelle Realit√§t eintauchen. <br><br>  Lassen Sie uns nun dar√ºber sprechen, wie wir unserer Anwendung Controller-Unterst√ºtzung hinzuf√ºgen k√∂nnen. <br><br><h2>  VR-Controller </h2><br><img src="https://habrastorage.org/webt/tu/ev/9f/tuev9fuqge3rucidyes50bkmaeo.png"><br><br>  Es w√§re sch√∂n, wenn PlayCanvas seinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicher</a> so anpassen w√ºrde, dass verschiedene Elemente, die mit der erforderlichen Logik verbunden sind, mit einer Taste mit der Anwendung verbunden werden k√∂nnten.  Aber heute ist dies nicht m√∂glich. Versuchen wir es also anders.  Um nicht die gesamte Logik zum Vergleichen der Position der Steuerungen zu schreiben, k√∂nnen wir vorhandene L√∂sungen verwenden.  Es gibt ein gro√üartiges Beispiel f√ºr ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web VR Lab</a> .  Es gibt viele interessante Dinge, aber der Code ... der Teufel selbst wird sich das Bein brechen.  Es gibt auch eine kleine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VR Tracked Controller-</a> Szene - nur eine einfache Szene mit zwei Controllern.  Hier ist es genauso und eignet sich zum Ausleihen von Elementen in Ihr Projekt. <br><br>  √ñffnen Sie die VR Tracked Controller-Szene zur Bearbeitung.  Zuerst m√ºssen wir den Controller √ºbertragen: <br><br><ol><li>  Wir w√§hlen den Controller aus, im Abschnitt Eigenschaften finden wir das Modell, klicken darauf und greifen als Asset darauf zu. </li><li>  In den Einstellungen befindet sich eine Schaltfl√§che zum Herunterladen, auf die wir klicken und das Modell und die Texturen herunterladen. </li><li>  Entpacken Sie die Assets und laden Sie sie in Ihre Anwendung.  Ziehen Sie sie dazu einfach in das Asset-Fenster, das sich unten befindet.  Sie m√ºssen alles √ºbertragen: ein Modell im JSON-Format und alle Texturen. </li><li>  Das Modell wird in unserer Liste der Assets angezeigt.  Ziehen Sie es auf die B√ºhne.  Und hier ist sie schon da.  Nennen wir es Left Controller. </li></ol><br>  Jetzt m√ºssen wir das Material hinzuf√ºgen: <br><br><ol><li>  Erstellen Sie ein neues Material, indem Sie im Asset-Bereich auf die Schaltfl√§che <b>‚Äû+‚Äú</b> klicken.  Nennen Sie das Material Controller Material. </li><li>  Jetzt m√ºssen wir das Quellprojekt √∂ffnen und dort das Tracked-Controller-Material finden und alle Einstellungen in unser Material kopieren, einschlie√ülich normaler, emittierender, spiegelnder und diffuser Karten (Karten). </li></ol><br>  Jetzt k√∂nnen Sie den Controller mit der speziellen Schaltfl√§che Duplizieren im Hierarchiefenster kopieren und den zweiten Controller als richtigen Controller bezeichnen. <br><br>  Das war's, die Controller auf unserer B√ºhne.  Bisher sind dies jedoch nur zwei Modelle. Damit alles funktioniert, m√ºssen die Skripte √ºbertragen werden.  Lassen Sie uns genauer sehen, was dort ben√∂tigt wird und wie es funktioniert: <br><br><ul><li>  <b>vr-gamepad-manager.js</b> - enth√§lt im Wesentlichen die gesamte Logik, die Ihre Controller <b>ben√∂tigen</b> , um die Position und Drehung des realen Controllers zu ermitteln.  Hier wird die Fake-Elbow-Logik f√ºr 3-Dof-Helme wie Oculus Go, Gear VR oder Daydream implementiert.  _updatePadToHandMappings ist hier daf√ºr verantwortlich, Controller zu lokalisieren und sie unseren Controllern zuzuordnen.  Die gesamte Logik zum Abgleichen des realen und des virtuellen Controllers befindet sich in der Funktion _poseToWorld.  Tats√§chlich werden hier die Daten von der WebXR-API √ºber die Instanz des Controllers selbst √ºbernommen - padPose.position, padPose.poseRotation.  Die folgende Logik ist f√ºr die Nuancen verantwortlich, die mit verschiedenen Ger√§tetypen verbunden sind.  Das Skript selbst muss global sein (d. H. Zum Stamm der Hierarchie hinzugef√ºgt werden). </li><li>  <b>input-vr.js</b> - ist verantwortlich f√ºr die Registrierung unserer Controller und die Arbeit mit Tasten.  Tats√§chlich bestimmt es einfach den Tastendruck und sendet die Nummer des gedr√ºckten Knopfes.  Dies ist nicht sehr praktisch, da verschiedene Ger√§te m√∂glicherweise unterschiedliche Tasten und eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GamePad-API</a> haben und es keine Tatsache ist, dass die erste Taste in Oculus Go ein Ausl√∂ser f√ºr den HTC Vive-Controller ist.  Daher m√ºssen Sie manuell graben.  Dieses Skript muss mit dem Controller-Element verbunden sein. </li></ul><br>  Wenn alles richtig gemacht ist, k√∂nnen Sie in die virtuelle Realit√§t eintreten und Ihre Controller winken lassen.  Nicht schlecht, obwohl der Prozess der Integration der erforderlichen Funktionalit√§t ziemlich unpraktisch und langwierig ist. <br><br><h2>  Insgesamt </h2><br>  PlayCanvas ist eine hervorragende Engine, mit der Sie WebGL-Spiele oder -Anwendungen erstellen k√∂nnen.  Aber ich muss zugeben, dass es f√ºr WebVR schlecht angepasst ist.  Es scheint, dass das Ziel darin bestand, zu demonstrieren, was PlayCanvas tun kann, um das √∂ffentliche Interesse zu f√∂rdern.  Aber diese Richtung hat offenbar keine Entwicklung erhalten.  Daher k√∂nnen Sie ein VR-Spiel oder eine VR-Anwendung erstellen, m√ºssen jedoch viel kopieren und den komplizierten Code verstehen, der nur zur Demonstration erstellt wurde (Web VR Lab). <br><br>  Im n√§chsten Artikel m√∂chte ich eine kleine Lektion zum Erstellen einer Teleport-Steuerung durchf√ºhren, damit wir zumindest ein kleines Set haben, mit dem Sie ein Web-VR-Spiel oder eine Web-VR-Anwendung starten k√∂nnen.  Vielen Dank f√ºr Ihre Aufmerksamkeit! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445692/">https://habr.com/ru/post/de445692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445678/index.html">4. Check Point Erste Schritte R80.20. Installation und Initialisierung</a></li>
<li><a href="../de445680/index.html">Neues Feature in Git 3: Schlie√üungen</a></li>
<li><a href="../de445682/index.html">PVS-Studio f√ºr Java wird an den Pfad gesendet. N√§chster Halt ist Elasticsearch</a></li>
<li><a href="../de445684/index.html">Monoblock gegen modulare USV</a></li>
<li><a href="../de445686/index.html">Anwendungsentwicklung f√ºr einen alten PDA (Cybiko Xtreme) im Jahr 2019</a></li>
<li><a href="../de445696/index.html">Wie Roboter entstehen, die dahin gehen k√∂nnen, wo wir sind</a></li>
<li><a href="../de445698/index.html">NanoCAD-Lizenzierung</a></li>
<li><a href="../de445700/index.html">‚Äû33 W√∂rter √ºber Design‚Äú: Wer und warum macht einen Film √ºber Design in Russland?</a></li>
<li><a href="../de445702/index.html">SlowPochta - Messenger f√ºr ungerechtfertigte Zustellung von Nachrichten mit unbestimmter Weiterleitungszeit</a></li>
<li><a href="../de445704/index.html">Citymobil - ein Leitfaden f√ºr Startups zur Erh√∂hung der Stabilit√§t bei Wachstum. Teil 2. Welche Arten von Unf√§llen gibt es?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>