<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏾 🔕 🚌 Comment enseigner pour surmonter les difficultés et en même temps pour écrire des cycles 📱 🧜🏾 👸🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Malgré le fait que nous allons nous concentrer sur l'un des sujets de base, cet article est écrit pour les professionnels expérimentés. Le but est de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment enseigner pour surmonter les difficultés et en même temps pour écrire des cycles</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456500/">  Malgré le fait que nous allons nous concentrer sur l'un des sujets de base, cet article est écrit pour les professionnels expérimentés.  Le but est de montrer quelles idées fausses les débutants ont en programmation.  Pour les développeurs praticiens, ces problèmes sont résolus depuis longtemps, oubliés ou pas du tout remarqués.  Un article peut être utile si vous devez soudainement aider quelqu'un sur ce sujet.  L'article établit un parallèle avec le matériel de divers livres sur la programmation de Shildt, Straustrup, Okulov. <br><br>  Le thème des cycles a été choisi car beaucoup de gens abandonnent dessus lors de la maîtrise de la programmation. <br><br>  Cette technique est conçue pour les élèves faibles.  En règle générale, ceux qui sont forts sur ce sujet ne sont pas coincés et n'ont pas besoin d'inventer des techniques spéciales pour eux.  L'objectif secondaire de l'article est de transférer cette méthodologie de la classe «fonctionne pour tous les élèves, mais seulement pour un enseignant» à la classe «fonctionne pour tous les élèves, tous les enseignants».  Je ne prétends pas être absolument original.  Si vous appliquez déjà une technique similaire pour enseigner ce sujet, veuillez indiquer en quoi votre version diffère.  Si vous décidez de postuler, dites-nous par résultats comment tout s'est passé.  Si une technique similaire est décrite dans un livre, veuillez en écrire le nom. <br><br><a name="habracut"></a><br>  J'ai pratiqué cette technique pendant 4 ans, étudiant individuellement avec des étudiants de différents niveaux de formation.  Seulement une cinquantaine d'étudiants et deux mille heures de cours.  Initialement, les étudiants sont restés et sont partis pour toujours sur ce sujet.  Après chaque élève, la méthodologie et le matériel ont été ajustés.  L'année dernière, les étudiants ne sont plus bloqués sur ce sujet, j'ai donc décidé de partager mes bonnes pratiques. <br><br><h4>  Pourquoi tant de lettres?  Les cycles sont élémentaires! </h4><br>  Comme je l'ai écrit ci-dessus, pour les développeurs pratiquants et pour les étudiants forts, la complexité du concept de cycles peut être sous-estimée.  Par exemple, vous pouvez organiser une longue conférence, voir hocher la tête et les yeux intelligents.  Mais lorsque vous essayez de résoudre un problème, une stupeur et des problèmes inexplicables commencent.  Après la conférence, les étudiants n'ont probablement développé qu'une compréhension partielle.  La situation est aggravée par le fait que les étudiants eux-mêmes ne peuvent pas exprimer quelle est exactement leur erreur. <br>  Une fois, j'ai réalisé que les élèves perçoivent mes exemples comme des hiéroglyphes.  Autrement dit, en tant que morceaux de texte indivisibles dans lesquels vous devez ajouter une sorte de lettre "magique" et cela fonctionnera. <br>  Parfois, j'ai remarqué que les étudiants pensent que pour résoudre un problème spécifique, <i>une autre</i> construction est nécessaire, ce que je n'ai pas encore dit.  Bien que la solution ne nécessite qu'une petite modification de l'exemple. <br><br>  Par conséquent, j'ai eu l'idée que l'objectif principal ne devrait pas être la syntaxe des expressions, mais l'idée de refactoriser le code répétitif à l'aide de boucles.  Dès que les élèves maîtrisent cette idée, toute syntaxe est resserrée avec un peu d'exercice. <br><br><h4>  À qui et pourquoi j'enseigne </h4><br>  Puisqu'il n'y a pas d'examens d'entrée, dans la classe il peut y avoir des étudiants forts et très faibles.  Plus de détails sur mes étudiants peuvent être trouvés dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Portrait des étudiants des cours du soir.</a> <br>  J'ai essayé de faire en sorte que tous ceux qui le souhaitent maîtrisent la programmation. <br>  Mes cours ont lieu individuellement et l'étudiant paie son argent pour chacun.  Il semblerait que les étudiants optimiseront les coûts et exigeront un minimum.  Cependant, les gens ne suivent pas des cours à temps plein avec un enseignant vivant pour la connaissance elle-même, mais pour la confiance qu'ils ont apprise, pour le sens du progrès et pour l'approbation d'un expert (enseignant).  Si les étudiants ne ressentent pas de progrès dans leurs études, ils partiront.  En général, les classes peuvent être conçues de sorte que les élèves ressentent des progrès dans l'augmentation du nombre de modèles familiers.  Autrement dit, nous étudions d'abord en détail, puis nous étudions pendant, puis faisons pendant et maintenant nous avons un cours de mille et une nuits, dans lequel nous étudions des cycles seulement pendant deux mois, et à la fin nous avons un étudiant qui a écrit une bibliothèque standard dictée.  Cependant, pour résoudre des problèmes pratiques, il faut non seulement la connaissance du matériau, mais aussi l'indépendance dans son application et dans la recherche de nouvelles informations.  Par conséquent, pour les cours à temps plein, je pense que le principe est correct - enseigner un minimum et encourager l'étude indépendante des nuances et des sujets connexes.  Dans le sujet des boucles, je considère la construction while comme un minimum.  Sur celui-ci, vous pouvez comprendre le principe.  Connaissant le principe, vous pouvez maîtriser à la fois pour et à faire vous-même. <br><br>  Il ne suffit pas de décrire la syntaxe pour atteindre la maîtrise du matériel par des élèves faibles.  Vous devez donner des tâches plus simples mais diverses et des exemples de peinture plus en détail.  En fin de compte, la vitesse de développement est limitée par la capacité de l'élève à transformer les expressions et à rechercher des modèles.  Pour les étudiants intelligents, la plupart des devoirs seront ennuyeux.  Lorsque vous pratiquez avec eux, vous ne pouvez pas insister pour résoudre 100% des tâches.  Mon matériel peut être consulté sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">mon github</a> .  Certes, le référentiel ressemble plus à un grimoire de démoniste - personne sauf moi ne comprendra où il se trouve <s>, et si vous échouez à la vérification, vous pouvez devenir fou</s> <br><br><h4>  Pratique orientée vers la pratique </h4><br>  La théorie est expliquée par l'exemple de la résolution d'un problème.  Dans les cours sur les bases de la programmation, où les branchements et les boucles sont étudiés, vous ne pourrez tout simplement pas donner une conférence utile sur un sujet pendant une heure entière.  15-20 minutes suffisent pour expliquer le concept.  Les principales difficultés apparaissent lors de l'exécution de tâches pratiques. <br>  Les enseignants débutants peuvent vider des instructions, des branches, des boucles et des tableaux en une seule conférence.  Voici juste les étudiants qui vont rencontrer le problème d'assimilation de ces informations. <br>  Vous devez non seulement dire le matériel, mais aussi vous assurer que le public l'a compris. <br><br>  Le fait de maîtriser le sujet est déterminé par la façon dont l'élève fait face à un travail indépendant. <br>  Si un élève a réussi à résoudre un problème sur un sujet sans l'aide d'un enseignant, alors le sujet a été appris.  Pour permettre l'auto-vérification, chaque tâche est décrite dans un tableau avec des scripts de test.  Les tâches ont un ordre prononcé.  Il n'est pas recommandé de sauter des tâches.  Si la tâche en cours est trop compliquée, passer à la suivante est inutile.  Elle est encore plus dure.  Pour que l'élève puisse maîtriser la tâche difficile actuelle, on lui explique plusieurs astuces sur l'exemple de la première tâche.  En fait, tout le contenu du sujet est réduit à des méthodes pour surmonter les difficultés.  Les cycles sont plus susceptibles d'être un effet secondaire. <br><br>  La première tâche est toujours un exemple.  Le second diffère légèrement et s'effectue «indépendamment» immédiatement après le premier sous la supervision d'un enseignant.  Toutes les tâches ultérieures visent à attirer l'attention sur diverses petites choses qui peuvent prêter à confusion. <br><br>  L'explication de l'exemple est un dialogue dans lequel l'élève doit rappeler la propagation et la validation croisée pour s'assurer qu'il assimile une partie du matériel. <br><br>  Je vais être banal et déclarer que le premier exemple sur le sujet est très important.  S'il y a matière à un travail indépendant approfondi, les omissions du premier exemple peuvent être corrigées.  Si, à part l'exemple, il n'y a rien de plus, alors l'élève ne maîtrisera probablement pas le sujet. <br><br><h4>  Pendant ou pour? </h4><br>  L'une des questions controversées est le choix de la construction pour un exemple: tout ou pour.  Une fois, un de mes amis, un développeur pratiquant sans expérience d'enseignement, m'a convaincu pendant une heure que la boucle for était la plus facile à comprendre.  Les arguments se résumaient à «tout est clair en elle et présenté par endroits».  Cependant, la cause profonde des difficultés des vrais débutants dans l'idée même du cycle, et non dans son écriture.  Si une personne ne comprend pas cette idée, elle aura des difficultés avec la syntaxe.  Dès que l'idée est réalisée, les problèmes de conception de code disparaissent d'eux-mêmes. <br><br>  Dans mes matériaux, le thème des cycles suit le thème de la ramification.  La similitude extérieure de if et while nous permet de tirer une analogie directe: "lorsque la condition dans l'en-tête est vraie, alors le corps est satisfait."  La particularité du cycle est que le corps est exécuté plusieurs fois. <br><br>  Mon deuxième argument est que tandis que nécessite moins de décoration que pour.  Moins de style - moins d'erreurs stupides avec des virgules et des crochets manquants.  Les débutants ne sont pas encore si attentifs et méticuleux qu'ils évitent automatiquement les erreurs de syntaxe. <br>  Le troisième argument est que beaucoup de bons livres sont expliqués en premier. <br><br>  Si un élève parvient à transformer facilement des expressions, vous pouvez en parler en passant.  L'élève choisira ce qu'il préfère.  Si les transformations causent des difficultés, il vaut mieux ne pas disperser l'attention.  Laissez l'élève résoudre tout avec l'aide de tout.  Une fois que vous maîtrisez le sujet des boucles, vous pouvez réécrire des solutions pour déterminer la conversion de while en for. <br>  Les cycles de post-conditionnement sont un animal rare.  Je ne m'y attarde pas du tout.  Si un élève a maîtrisé les idées de révéler des modèles et de transformer des expressions, il pourra le comprendre sans mon aide. <br><br>  Lors de la démonstration du premier exemple à des étudiants forts, j'attire l'attention sur le fait que dans le premier exemple, il est important de fixer non seulement la solution, mais aussi toute la chaîne d'actions qui a conduit au résultat.  Les étudiants paresseux peuvent négliger les écrits et ne transférer que l'algorithme fini à eux-mêmes.  Ils doivent être convaincus qu’un jour ils rencontreront une tâche difficile.  Pour le résoudre, vous devrez suivre les étapes comme dans cet exemple.  C'est pourquoi il est important de fixer toutes les étapes.  Dans les tâches suivantes, il sera possible de ne laisser que la solution finale. <br><br>  L'idée principale de l'automatisation est que nous demandons à l'ordinateur d'effectuer un travail de routine par personne.  L'un des trucs de base est d'écrire des cycles.  Il est utilisé lorsque plusieurs actions répétitives identiques sont écrites dans un programme d'affilée. <br><br><h4>  Explicite vaut mieux qu'implicite </h4><br>  Cela peut sembler une bonne idée dans la première tâche sur les cycles d'afficher plusieurs fois une phrase identique.  Par exemple: <br><blockquote>  Hourra, ça marche! <br>  Hourra, ça marche! <br>  Hourra, ça marche! <br>  Hourra, ça marche! <br>  Hourra, ça marche! <br>  Hourra, ça marche! <br>  Hourra, ça marche! <br>  Hourra, ça marche! <br></blockquote><br>  Cette option est mauvaise car la sortie n'affiche pas la valeur du compteur.  C'est un problème pour les débutants.  Ne le sous-estimez pas.  Au début, cette tâche était la première, et la tâche de sortie d'une série de nombres dans l'ordre croissant était la seconde.  J'ai dû introduire des termes supplémentaires «cycle N fois» et «cycle de A à B», qui sont essentiellement les mêmes.  Afin de ne pas produire d'entités inutiles, j'ai décidé de ne montrer qu'un exemple avec une série de nombres.  Peu parviennent à apprendre à garder un compteur dans leur tête et à simuler le comportement d'un programme dans leur tête sans préparation.  Pour la première fois, certains élèves sont confrontés à une modélisation «dans l'esprit» sur le thème des cycles. <br>  Après un peu de pratique, je donne la tâche de répéter le même texte à une solution indépendante.  Si vous donnez d'abord un compteur visible, puis invisible, les élèves ont moins de problèmes.  Parfois, les invites «n'écrivez pas le compteur à l'écran» suffisent. <br><br><h4>  Comment les autres l'expliquent-ils? </h4><br>  Dans la plupart des supports pédagogiques sur Internet, la syntaxe de boucle est donnée dans le cadre d'une «conférence».  Par exemple, sur developer.mozilla.org (actuellement), plusieurs autres constructions sont décrites avec la boucle while.  Dans ce cas, seules les constructions elles-mêmes sont données sous forme de modèles.  Le résultat de leur lancement est décrit en mots, mais l'illustration manque.  À mon avis, une telle présentation du sujet multiplie par zéro l'utilité de ces documents.  L'élève peut réécrire le code et l'exécuter lui-même, mais la référence pour la comparaison est toujours nécessaire.  Comment comprendre que l'exemple est correctement réécrit s'il n'y a rien pour comparer le résultat? <br>  Lorsque seul un modèle est donné, sans exemple, cela devient encore plus difficile pour un étudiant.  Comment comprendre que les fragments de code sont correctement placés dans le modèle?  Vous pouvez essayer d'écrire en <i>quelque sorte</i> , puis exécuter.  Mais s'il n'y a pas de standard pour comparer le résultat, le lancement n'aidera pas non plus. <br><br>  Dans le cours C ++ sur l'intuition, la syntaxe de boucle est enterrée dans la troisième page de la leçon 4 sur le thème des «opérateurs».  Lors de l'explication de la syntaxe des boucles, un accent particulier est mis sur le terme «opérateur».  Le terme est présenté comme un ensemble de faits comme «symbole;  c'est un opérateur »,« {} c'est un opérateur composé »,« le corps de la boucle doit être un opérateur ».  Je n'aime pas cette approche car elle semble cacher des relations importantes en un seul terme.  L'analyse du code source du programme en termes à un tel niveau est nécessaire pour les développeurs de compilateurs pour implémenter la spécification du langage, mais pas pour les étudiants dans la première approximation.  Les débutants en programmation ont rarement la minutie d'être si attentifs aux termes.  Une personne rare se souvient et comprend de nouveaux mots la première fois.  Pratiquement personne ne peut appliquer correctement le terme qu'il vient d'apprendre.  Par conséquent, les étudiants ont un tas d'erreurs comme «écrit pendant (a &lt;7); {, mais le programme ne fonctionne pas». <br>  À mon avis, au début, il est préférable de donner immédiatement la syntaxe de la construction avec des crochets.  L'option sans parenthèses n'est expliquée que si l'étudiant a une question spécifique «pourquoi ça marche sans parenthèses». <br><br>  Dans le livre d'Okulov «Fundamentals of Programming» en 2012, la connaissance des cycles commence par le modèle for, puis des recommandations sont données pour son utilisation, puis la section expérimentale de la leçon suit immédiatement.  Je comprends que le livre a été écrit pour cette minorité d'étudiants très capables qui viennent rarement dans mes cours. <br><br>  Dans les livres populaires, le résultat des fragments de code est toujours écrit.  Par exemple, l'édition 2015 de «Java 8. Complete Guide» de Schildt.  D'abord, un modèle est donné, puis un exemple de programme et immédiatement après, il est le résultat de l'exécution. <br><blockquote>  Par exemple, considérons une boucle while dans laquelle l'inverse <br>  le compte à rebours, commençant à 10, et exactement 10 lignes de «mesures» sont sortis: <pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    while class While { public static void main(String args []) { int n = 10; while (n &gt; 0) { System.out.println(" " + n); n--; } } }</span></span></code> </pre> <br>  Après avoir démarré ce programme affiche dix «mesures» comme suit: <br> <code> 10 <br>  9 <br>  8 <br>  7 <br>  6 <br>  5 <br>  4 <br>  3 <br>  2 <br>  1</code> </blockquote> <br>  Une approche décrivant le modèle, un exemple de programme et le résultat de ce programme est également utilisée dans le livre «Javascript for children» et dans le cours js sur w3schools.com.  Le format de page Web vous permet même de rendre cet exemple interactif. <br><br>  Dans le livre de 2016 de Straustrup, Principles and Practices Using C ++, l'auteur est allé encore plus loin.  La première étape explique ce que le résultat devrait être, et après cela - montrer le texte du programme.  De plus, à titre d'exemple, ils prennent non seulement un programme aléatoire, mais donnent une excursion dans l'histoire.  Cela aide à attirer l'attention sur lui. «Écoutez, ce n'est pas seulement un texte inutile.  Vous voyez quelque chose d'important. " <br><blockquote>  Comme exemple d'itération, considérons le premier programme exécuté sur une machine avec un programme stocké (EDSAC).  Il a été écrit par David Wheeler au laboratoire informatique de l'Université de Cambridge, en Angleterre, le 6 mai 1949.  Ce programme calcule et imprime une simple liste de carrés. <br> <code>0 0 <br> 1 1 <br> 2 4 <br> 3 9 <br> 4 16 <br> ... <br> 98 9604 <br> 99 9801</code> <br>  Ici, chaque ligne contient un nombre suivi d'un onglet ('\ t') et du carré de ce nombre.  La version C ++ de ce programme ressemble à ceci: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      0-99 int main() { int i = 0; //    while(i &lt; 100){ cout &lt;&lt; i &lt;&lt; '\t' &lt;&lt; square(i) &lt;&lt; '\n'; ++i; } }</span></span></code> </pre> </blockquote><br>  Curieusement, le modèle de syntaxe n'est pas décrit dans ce livre.  Stroustrup dans le manuel de l'instructeur ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction</a> ) souligne qu'il respecte l'intelligence de ses élèves.  Peut-être que la capacité d'identifier le modèle dans plusieurs exemples est considérée comme une manifestation d'une telle intelligence. <br><br><h4>  Comme je m'explique </h4><br>  L'approche de Straustrup: une description du résultat, puis une solution au problème, puis une analyse indépendante par l'étudiant - semble la plus réfléchie.  Par conséquent, j'ai décidé de le prendre comme base, mais de le dire sur un exemple moins historique - la tâche de dériver une «table des matières».  Il forme une ancre reconnaissable, de sorte que plus tard, il est dit "rappelez-vous la tâche de la table des matières" et que les élèves s'en souviennent.  Dans mon exemple, j'ai essayé de mettre en garde deux autres idées fausses les plus courantes.  Ensuite, j'écrirai plus à leur sujet. <br><blockquote>  Dans cette tâche, nous nous familiarisons avec les méthodes de résolution de problèmes complexes.  La décision initiale doit être prise de manière primitive et simple.  Eh bien, alors vous pouvez réfléchir à la façon d'améliorer cette solution. <br> <code> <br>  1 <br>  2 <br>  3 <br>  4 <br>  5 <br>  6 <br>  7 <br> </code> </blockquote> <br>  Selon mes observations, l'approche «modèle-exemple-résultat» dans différentes combinaisons amène toujours les élèves à percevoir le cycle comme un hiéroglyphe.  Cela s'est manifesté par le fait qu'ils ne comprenaient pas pourquoi ils devaient écrire une condition, comment choisir entre i ++ et i-- et d'autres choses apparemment évidentes.  Pour éviter ces idées fausses, l'approche de l'histoire des cycles devrait mettre l'accent sur le sens de la répétition des mêmes actions et ensuite seulement - les concevoir en utilisant le design.  Par conséquent, avant de donner la syntaxe de la boucle, vous devez résoudre le problème "front".  Une solution primitive au problème de la table des matières ressemble à ceci: <br><pre> <code class="cs hljs">Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" 1"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" 2"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" 3"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" 4"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" 5"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" 6"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" 7"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre><br>  Comment peut-il être amélioré? <br>  Remplacez les actions répétitives par une boucle. <br>  Quelles actions sont répétées d'affilée sans modifications? <br>  Il n'y en a pas dans ce fragment.  Cependant, la commande pour sortir le mot "Chapter" avec le numéro est très similaire. <br>  Par conséquent, l'étape suivante est la recherche de la différence entre les fragments.  Ce n'est que dans cette tâche que tout est évident, alors pas de commandes uniques ne seront répétées, mais des blocs de code de 5 lignes ou plus.  Vous devrez rechercher non seulement dans la liste des commandes, mais dans les constructions de branche ou de boucle. <br>  Dans l'exemple, la différence entre les équipes dans le nombre après le mot "Chapitre". <br>  Une fois la différence trouvée, vous devez comprendre le schéma du changement.  Un autre fragment est ce nombre?  Augmente-t-il ou diminue-t-il constamment?  Comment la valeur d'un nombre change-t-elle entre deux équipes côte à côte? <br>  Dans l'exemple, le nombre après le mot «Chapitre» augmente avec l'étape 1. La différence est trouvée, le motif est révélé.  Vous pouvez maintenant remplacer le fragment différent par une variable. <br>  Une telle variable doit être déclarée avant le premier des fragments répétitifs.  Une telle variable est généralement appelée I ou j ou plus développée.  Sa valeur initiale doit être égale à la première valeur affichée à l'écran.  Dans l'exemple, la première valeur est 1. <br>  Quelle valeur initiale faut-il prendre pour sortir une série de nombres "100, 101, 102, 103, 104, 105"? <br>  Dans cette ligne, le premier nombre est 100. <br>  Après chaque commande de sortie, vous devez augmenter la valeur de cette variable de 1. Cette unité est une étape de changement. <br>  Quelle étape sera dans la série des nombres "100, 102, 104, 106"? <br>  Dans cette ligne, étape 2. <br>  Après avoir remplacé le fragment différent par une variable, le code ressemblera à ceci: <br><pre> <code class="cs hljs">Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; i = <span class="hljs-number"><span class="hljs-number">0</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span> + i); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span> + i); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span> + i); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span> + i); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span> + i); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span> + i); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span> + i); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre><br>  Après avoir appliqué la technique «exprimer la loi de la variable», le code produit plusieurs groupes d'actions identiques qui se succèdent.  Désormais, les actions répétitives peuvent être remplacées par une boucle. <br><br>  La séquence de résolution du problème où vous devez utiliser des cycles comprend les étapes suivantes: <br><ol><li>  Résolvez le «front» avec de nombreuses équipes distinctes </li><li>  Trouver un motif </li><li>  Exprimer la régularité d'une variable </li><li>  Le design en boucle </li></ol><br><br>  Ensuite, de nouveaux termes sont introduits pour que l’élève ne se retrouve pas dans la situation «je comprends tout, mais je ne peux pas dire»: <br>  - un compteur est toujours une variable nécessaire pour suivre le nombre d'étapes d'un cycle.  Habituellement, un entier qui est comparé à une contrainte. <br>  - étape du compteur - une description du modèle de changement dans le compteur. <br>  - restriction - un nombre ou une variable avec laquelle le compteur est comparé, de sorte que l'algorithme est fini.  La valeur du compteur change de manière à approcher la limite. <br>  - cycle body - un ensemble de commandes qui seront répétées.  Quand il dit "la commande est écrite à l'intérieur du cycle", cela signifie le corps. <br>  - itération de boucle - une seule exécution du corps de la boucle. <br>  - une condition de boucle est une expression logique qui détermine si une autre itération sera effectuée.  (Il peut y avoir confusion avec les conceptions de succursales) <br>  Vous devez être préparé au fait qu'au début, les étudiants utiliseront les termes à d'autres fins.  Cela s'applique à la fois aux forts et aux faibles.  Construire un langage commun est tout un art.  Je vais écrire brièvement maintenant: vous devez définir la tâche «sélectionner un fragment de code avec &lt;term&gt;» et utiliser correctement ces termes dans une conversation. <br>  Après la conversion avec une boucle, un fragment est obtenu: <br><pre> <code class="cs hljs">Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span> + i); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre> <br><br><h4>  Idée fausse principale </h4><br>  Une idée fausse très répandue des étudiants est qu'ils mettent dans la structure de la boucle de telles actions qui ne doivent être effectuées qu'une seule fois.  Par exemple, comme ceci: <br><pre> <code class="cs hljs">; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span> + i); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>); }</code> </pre><br>  Les élèves tombent constamment sur ce problème, tant au début que dans des tâches plus complexes. <br>  Indice de couronne dans ce cas: <br><blockquote>  Combien de fois devez-vous répéter la commande: une ou plusieurs fois? <br></blockquote><br>  Les commandes de sortie pour les mots "Introduction" et "Conclusion", ainsi que la déclaration et l'initialisation de la variable i, ne sont pas comme les autres actions répétitives.  Ils ne sont exécutés qu'une seule fois, ce qui signifie qu'ils doivent être écrits en dehors du corps du cycle. <br><br>  Les trois étapes de la solution doivent rester dans le code, afin de s'y référer ensuite en cas de difficulté.  Les deux premières options sont suffisantes pour commenter afin qu'elles n'interfèrent pas. <br>  L'attention de l'étudiant doit être portée sur les faits suivants: <br>  - En boucle, le compteur et la limite sont généralement comparés.  Le compteur peut changer dans le corps de la boucle, mais la limite ne l'est pas.  Pour enfreindre cette règle, vous devez formuler de bonnes raisons. <br>  - Les commandes pour afficher les mots "Introduction" et "Conclusion" sont en dehors du corps du cycle.  Nous devons les exécuter 1 fois.  «Introduction» - avant de répéter les actions, «Conclusion» - après. <br>  Dans le processus de fixation de ce sujet, de maîtrise des éléments suivants, ainsi que de procédures difficiles, il est utile que même des étudiants forts posent la question: «Mais combien de fois cette action doit-elle être effectuée?  Un ou plusieurs? " <br><br><h4>  Développement de compétences supplémentaires </h4><br>  Au cours de l'étude des cycles, les élèves ont toujours la capacité de diagnostiquer et de résoudre des problèmes.  Pour effectuer le diagnostic, l'étudiant doit présenter le résultat souhaité et le comparer avec le résultat réel.  Les actions de correction dépendent de la différence entre elles. <br>  Étant donné que les étudiants à ce stade ont encore une mauvaise idée du résultat «souhaité», ils peuvent se concentrer sur les données des tests.  En règle générale, personne à ce stade ne comprend encore ce qui peut mal tourner et comment y faire face.  Par conséquent, je donne une description des problèmes typiques et plusieurs façons de les résoudre sous une entrée dans un cahier.  Le choix du plus approprié d'entre eux est la tâche de l'étudiant lui-même. <br>  Le dossier est nécessaire pour demander, "Que s'est-il passé?", "Laquelle de ces situations s'est-elle produite?", "La solution a-t-elle aidé?". <br><ol><li>  Le nombre d'actions est inférieur ou supérieur à 1 prévu.  Façons de résoudre: <br>  - augmenter la valeur initiale du compteur de 1. <br>  - remplacez l'opérateur de comparaison strict (&lt;ou&gt;) par un opérateur non strict (&lt;= ou&gt; =). <br>  - changez la valeur de la restriction à 1. </li><li>  Les actions dans la boucle sont exécutées sans arrêt, sans fin.  Façons de résoudre: <br>  - ajouter une commande de changement de compteur si elle est absente. <br>  - fixer la commande de changement de compteur pour que sa valeur se rapproche de la limite. <br>  - supprimer la commande de modification de la contrainte, si elle se trouve dans le corps du cycle. </li><li>  Le nombre d'actions dans la boucle est supérieur ou égal à 1 ou supérieur à celui attendu.  L'action dans la boucle n'a jamais été exécutée.  Vous devez d'abord connaître les valeurs réelles des variables juste avant le début du cycle.  Façons de résoudre: <br>  - changer la valeur initiale de la contrainte <br>  - changer la valeur initiale du compteur </li></ol><br>  Habituellement, le problème 3 est lié à l'utilisation de la mauvaise variable ou à la non-remise à zéro du compteur. <br><br>  Après cette explication, l'élève peut encore avoir diverses idées fausses sur le fonctionnement des cycles. <br>  Pour dissiper les plus courants, je donne des tâches: <br><ol><li>  Dans lequel la restriction, la valeur initiale du compteur ou le pas du compteur est entrée par l'utilisateur. </li><li>  Dans lequel la valeur du compteur doit être utilisée dans une expression arithmétique.  Il est conseillé au compteur dans l'expression radicale ou dans le dénominateur pour que la différence soit non linéaire. </li><li>  Dans lequel la valeur du compteur n'est pas affichée pendant le cycle.  Par exemple, la sortie du nombre requis de fragments de texte identiques ou dessinez une figure avec des graphiques de tortue. </li><li>  Dans lequel vous devez effectuer d'abord certaines actions répétitives, puis d'autres. </li><li>  Dans lequel vous devez effectuer d'autres actions avant et après la répétition </li></ol><br>  Pour chaque tâche, vous devez fournir des données de test et le résultat attendu. <br><br>  Pour comprendre à quelle vitesse vous pouvez vous déplacer, vous devez lire les conditions de ces tâches et demander: «en quoi diffèrent-elles de l'exemple?», «Qu'est-ce qui doit être changé dans l'exemple pour les résoudre?».  Si l'élève répond de manière significative, laissez-le en décider au moins un dans la leçon, et le reste - à la maison par eux-mêmes.  Si la solution réussit, vous pouvez commencer à expliquer les conditions à l'intérieur des boucles. <br>  Si avec une solution indépendante aux difficultés, vous devez tout régler dans la leçon.  Pour que la solution au problème ne ressemble pas au dessin d'un hibou, je vous recommande de résoudre d'abord le problème de manière non universelle.  Autrement dit, pour que la solution passe le premier test et n'utilise pas la construction de boucle.  Eh bien, appliquez ensuite les transformations pour atteindre l'universalité de la solution. <br><br><h4>  Boucles et branches </h4><br>  À mon avis, il est utile de donner séparément le sujet «boucles à l'intérieur des branches».  Pour que plus tard, vous puissiez voir la différence entre une vérification de plusieurs conditions et une seule. <br>  Les tâches de fixation concerneront la sortie des nombres de A à B, qui sont entrés par l'utilisateur: <br>  - toujours ascendant. <br>  - ascendant ou descendant selon les valeurs de A et B. <br><br>  Le sujet de «ramification à l'intérieur des cycles» ne doit être abordé qu'après que l'élève a maîtrisé les astuces: «remplacer les motifs par une variable» et «remplacer les actions répétitives par une boucle». <br>  La principale raison de l'utilisation de la ramification dans les boucles est due à des anomalies dans les modèles.  Au milieu, il est cassé en fonction des données sources. <br>  Pour les étudiants qui sont capables de rechercher une solution en combinant des techniques simples, il suffit de dire que «le branchement peut être écrit à l'intérieur de boucles» et de donner la tâche «par exemple» complètement à une solution indépendante. <br>  Tâche par exemple: <br><blockquote>  L'utilisateur entre le nombre X. Affichez dans la colonne les nombres de 0 à 9 et mettez le signe '+' en face du nombre égal à X. </blockquote><br><div class="spoiler">  <b class="spoiler_title">Si 0 a été entré</b> <div class="spoiler_text">  0+ <br>  1 <br>  2 <br>  3 <br>  4 <br>  5 <br>  6 <br>  7 <br>  8 <br>  9 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Si 6 a été entré</b> <div class="spoiler_text">  0 <br>  1 <br>  2 <br>  3 <br>  4 <br>  5 <br>  6+ <br>  7 <br>  8 <br>  9 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Si 9 a été entré</b> <div class="spoiler_text">  0 <br>  1 <br>  2 <br>  3 <br>  4 <br>  5 <br>  6 <br>  7 <br>  8 <br>  9+ <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Si 777 a été entré</b> <div class="spoiler_text">  0 <br>  1 <br>  2 <br>  3 <br>  4 <br>  5 <br>  6 <br>  7 <br>  8 <br>  9 <br></div></div><br>  Si une brève explication ne suffit pas pour écrire avec une boucle, alors vous devez trouver une solution universelle au même problème sans boucle. <br>  Vous obtiendrez l'une des deux options: <br><div class="spoiler">  <b class="spoiler_title">Souhaité</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> temp; temp = Console.ReadLine(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; x = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(temp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">0</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">1</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">2</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">3</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">3</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">4</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">4</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">5</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">5</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">6</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">6</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">6</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">7</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">7</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">7</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">8</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">8</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">8</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">9</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">9</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">9</span></span>); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Possible</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> temp; temp = Console.ReadLine(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; x = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(temp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">0</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0+\n1\n2\n3\n4\n5\n6\n7\n8\n9"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">1</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0\n1+\n2\n3\n4\n5\n6\n7\n8\n9"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">2</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0\n1\n2+\n3\n4\n5\n6\n7\n8\n9"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">3</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0\n1\n2\n3+\n4\n5\n6\n7\n8\n9"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">4</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0\n1\n2\n3\n4+\n5\n6\n7\n8\n9"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">5</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0\n1\n2\n3\n4\n5+\n6\n7\n8\n9"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">6</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0\n1\n2\n3\n4\n5\n6+\n7\n8\n9"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">7</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0\n1\n2\n3\n4\n5\n6\n7+\n8\n9"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">8</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0\n1\n2\n3\n4\n5\n6\n7\n8+\n9"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">9</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0\n1\n2\n3\n4\n5\n6\n7\n8\n9+"</span></span>); }</code> </pre><br></div></div><br>  Je donne un problème similaire à l'avance, tout en étudiant le sujet de la ramification. <br>  Si l'étudiant a une option «possible», alors vous devez dire qu'il peut y avoir plusieurs solutions au même problème.  Cependant, ils diffèrent par leur résistance aux exigences changeantes.  Posez la question: "Combien de places dans le code devront être corrigées si vous devez ajouter un autre numéro?"  Dans la version «possible», vous devrez ajouter une autre branche et ajouter un nouveau numéro à 10 autres endroits.  Dans le "souhaité", il suffit d'ajouter une seule branche. <br>  Définissez la tâche pour reproduire l'option «souhaitée», puis recherchez un modèle dans le code, effectuez un remplacement de variable et écrivez une boucle. <br>  Si vous avez une idée de la façon de résoudre ce problème sans boucle d'une autre manière, veuillez écrire dans les commentaires. <br><br><h4>  Boucles à l'intérieur des boucles </h4><br>  Dans ce fil, vous devez faire attention au fait que: <br>  - Les compteurs de la boucle intérieure et extérieure doivent être des variables différentes. <br>  - le compteur de la boucle intérieure doit être réinitialisé plusieurs fois (c'est-à-dire dans le corps de la boucle extérieure). <br>  - dans les tâches de sortie de texte, vous ne pouvez pas d'abord écrire une lettre sur plusieurs lignes, puis la seconde.  Vous devez d'abord imprimer toutes les lettres de la première ligne, puis toutes les lettres de la seconde et ainsi de suite. <br><br>  Il est préférable de commencer une explication du sujet sur les boucles à l'intérieur des boucles en expliquant l'importance de réinitialiser le compteur. <br>  Tâche par exemple: <br><blockquote>  L'utilisateur entre deux chiffres: R et T. Imprimez deux lignes de caractères "#".  La première ligne doit contenir des caractères R.  La deuxième ligne est constituée de pièces en T.  Si un nombre est négatif, affichez un message d'erreur. </blockquote><br><div class="spoiler">  <b class="spoiler_title">R = 5, T = 11</b> <div class="spoiler_text">  ##### <br>  ############ <br></div></div><br><div class="spoiler">  <b class="spoiler_title">R = 20, T = 3</b> <div class="spoiler_text">  ###################### <br>  ### <br></div></div><br><div class="spoiler">  <b class="spoiler_title">R = -1, T = 6</b> <div class="spoiler_text">  La valeur de R doit être non négative <br></div></div><br><div class="spoiler">  <b class="spoiler_title">R = 6, T = -2</b> <div class="spoiler_text">  La valeur de T doit être non négative <br></div></div><br>  De toute évidence, ce problème a également au moins deux solutions. <br><div class="spoiler">  <b class="spoiler_title">Souhaité</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> temp; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> R; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> T; temp = Console.ReadLine(); R = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(temp); temp = Console.ReadLine(); T = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(temp); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; R) { Console.Write(<span class="hljs-string"><span class="hljs-string">"#"</span></span>); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; } Console.WriteLine(); i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; T) { Console.Write(<span class="hljs-string"><span class="hljs-string">"#"</span></span>); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Possible n ° 1</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> temp; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> R; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> T; temp = Console.ReadLine(); R = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(temp); temp = Console.ReadLine(); T = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(temp); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; R) { Console.Write(<span class="hljs-string"><span class="hljs-string">"#"</span></span>); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; } Console.WriteLine(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (j &lt; T) { Console.Write(<span class="hljs-string"><span class="hljs-string">"#"</span></span>); j = j + <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br></div></div><br>  La différence est que dans la solution «possible», la deuxième variable a été utilisée pour afficher la deuxième ligne.  Vous devez insister sur l'utilisation de la même variable pour les deux cycles.  On peut plaider en faveur d'une telle limitation dans la mesure où une solution avec un compteur pour deux cycles sera une illustration du terme «compteur à zéro».  Comprendre ce terme est nécessaire pour résoudre les problèmes suivants.  Comme compromis, vous pouvez enregistrer les deux solutions au problème. <br><br>  Un problème typique avec l'utilisation d'une seule variable de compteur pour deux cycles se présente comme suit: <br><div class="spoiler">  <b class="spoiler_title">R = 5, T = 11</b> <div class="spoiler_text">  ##### <br>  ###### <br></div></div><br>  Le nombre de caractères dans la deuxième ligne ne correspond pas à la valeur de T. Si vous avez besoin d'aide avec ce problème, alors vous devez "mettre le nez" dans le synopsis sur les problèmes typiques avec les boucles.  Il s'agit du symptôme numéro 3.  Il est diagnostiqué si vous ajoutez la sortie de la valeur du compteur immédiatement avant le deuxième cycle.  Corrigé par remise à zéro.  Mais il vaut mieux ne pas le dire tout de suite.  L'élève doit essayer de formuler au moins une hypothèse. <br><br>  Bien sûr, il existe toujours une telle solution.  Mais je ne l'ai jamais vu parmi les étudiants.  Au stade de l'étude des cycles, l'histoire de lui dispersera l'attention.  Vous pouvez y revenir plus tard, lorsque vous étudierez les fonctions de travail avec des chaînes. <br><div class="spoiler">  <b class="spoiler_title">Numéro possible 2</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> temp; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> R; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> T; temp = Console.ReadLine(); R = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(temp); temp = Console.ReadLine(); T = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(temp); Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">'#'</span></span>, R)); Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">'#'</span></span>, T));</code> </pre><br></div></div><br><br>  La prochaine tâche requise: <br><blockquote>  Affichez les chiffres de 0 à 9. Chaque chiffre doit être sur sa propre ligne.  Le nombre de chiffres par ligne (W) est entré à partir du clavier. </blockquote><br><div class="spoiler">  <b class="spoiler_title">W = 1</b> <div class="spoiler_text">  0 <br>  1 <br>  2 <br>  3 <br>  4 <br>  5 <br>  6 <br>  7 <br>  8 <br>  9 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">W = 10</b> <div class="spoiler_text"> <code>0000000000 <br> 1111111111 <br> 2222222222 <br> 3333333333 <br> 4444444444 <br> 5555555555 <br> 6666666666 <br> 7777777777 <br> 8888888888 <br> 9999999999</code> <br> </div></div><br>  Si un élève maîtrise la technique de remplacement d'une variable, il s'en sortira assez rapidement.  Un problème possible sera à nouveau la mise à zéro de la variable.  Si vous ne pouvez pas gérer la conversion, vous êtes pressé et vous devez résoudre des problèmes plus simples. <br><br>  Merci de votre attention.  <s>Comme, abonnez-vous à la chaîne.</s> <br><br>  PS Si vous trouvez des fautes de frappe ou des erreurs dans le texte, faites-le moi savoir.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela peut être fait en mettant en surbrillance une partie du texte et en appuyant sur "⌘ + Entrée" sur le Mac, et sur les claviers classiques "Ctrl / Entrée", ou via des messages privés. </font><font style="vertical-align: inherit;">Si ces options ne sont pas disponibles, notez les erreurs dans les commentaires.</font></font> Je vous remercie! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456500/">https://habr.com/ru/post/fr456500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456488/index.html">Journalisation rapide</a></li>
<li><a href="../fr456490/index.html">Conférences sur le cerveau, partie 1. L'évolution du cerveau humain. Le cerveau fonctionne à chaque étape de son développement</a></li>
<li><a href="../fr456492/index.html">Armée de trolls</a></li>
<li><a href="../fr456494/index.html">Aux États-Unis, les GOST sont aussi des moyens. Vulnérabilité fatale YubiKey FIPS qui aurait pu être évitée</a></li>
<li><a href="../fr456498/index.html">Gestionnaire de périphériques Étendre MIS aux appareils</a></li>
<li><a href="../fr456502/index.html">Les articles scientifiques les plus courts</a></li>
<li><a href="../fr456504/index.html">Le mode sombre ne résout pas les problèmes d'écran</a></li>
<li><a href="../fr456506/index.html">Horloge Nixie ou lampe chaude dans votre maison</a></li>
<li><a href="../fr456508/index.html">Guide de documentation interne sur la sécurité de l'information. Quoi, comment et pourquoi</a></li>
<li><a href="../fr456510/index.html">Grimpeurs liquides: manipuler des gouttes d'eau pour créer des laboratoires sur une puce et une technologie autonettoyante</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>