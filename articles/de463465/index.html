<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèø‚Äçü§ù‚Äçüßëüèª üôÖüèª üÉè Das Buch ‚ÄûExpressive JavaScript. Moderne Webprogrammierung. 3. Auflage ü§∑ üîõ üçÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habrozhiteli! In diesem Buch k√∂nnen Sie tief in das Thema eintauchen und lernen, wie man sch√∂nen und effektiven Code schreibt. Sie lernen Syntax...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Buch ‚ÄûExpressive JavaScript. Moderne Webprogrammierung. 3. Auflage</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/463465/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/hj/ac/jw/hjacjwa9yynefuv1iquueauasum.jpeg" align="left" alt="Bild"></a>  Hallo habrozhiteli!  In diesem Buch k√∂nnen Sie tief in das Thema eintauchen und lernen, wie man sch√∂nen und effektiven Code schreibt.  Sie lernen Syntax, Pfeil- und asynchrone Funktionen, Iterator, Musterzeichenfolgen und Blockbereich kennen. <br><br>  Marein Haverbeke - Praktizierende.  Sammeln Sie Erfahrungen und lernen Sie die Sprache anhand einer Vielzahl von Beispielen durch √úbungen und Trainingsprojekte.  Zun√§chst werden Sie mit der Struktur der JavaScript-Sprache vertraut gemacht, Strukturen, Funktionen und Datenstrukturen verwalten, dann Fehlerbehandlung und Fehlerbehebungen, Modularit√§t und asynchrone Programmierung untersuchen und dann mit der Browserprogrammierung fortfahren. <br><a name="habracut"></a><br><h3>  √úberpr√ºfen Sie dieses Buch </h3><br>  Dieses Buch ist in drei gro√üe Teile gegliedert.  In den ersten 12 Kapiteln wird die JavaScript-Sprache erl√§utert.  In den n√§chsten sieben Kapiteln geht es um Browser und wie sie mit JavaScript programmiert werden.  Schlie√ülich sind zwei Kapitel Node.js gewidmet, einer anderen JavaScript-Programmierumgebung. <br><br>  Im gesamten Buch werden Sie f√ºnf Kapitel von Projekten kennenlernen, in denen gr√∂√üere Beispiele f√ºr Programme beschrieben werden, damit Sie den Geschmack einer echten Programmierung sp√ºren k√∂nnen.  In der Reihenfolge ihres Auftretens werden wir daran arbeiten, einen Bereitstellungsroboter, eine Programmiersprache, eine Spieleplattform, einen Raster-Grafikeditor und eine dynamische Site zu erstellen. <br><br>  Der sprachliche Teil des Buches beginnt mit vier Kapiteln, die Sie in die Grundstruktur der JavaScript-Sprache einf√ºhren.  Sie lernen Kontrollstrukturen (wie das Schl√ºsselwort while, das Sie bereits in der Einf√ºhrung gesehen haben), Funktionen (Schreiben eigener Bausteine) und Datenstrukturen kennen.  Danach k√∂nnen Sie die einfachsten Programme schreiben.  Dar√ºber hinaus wird in den Kapiteln 5 und 6 beschrieben, wie Funktionen und Objekte verwendet werden, um abstrakteren Code zu schreiben und dessen Komplexit√§t zu steuern. <br><br>  Nach dem Kapitel des ersten Projekts wird der sprachliche Teil des Buches fortgesetzt. Die folgenden Kapitel befassen sich mit der Erkennung und Korrektur von Fehlern, regul√§ren Ausdr√ºcken (ein wichtiges Werkzeug f√ºr die Arbeit mit Text), Modularit√§t (eine weitere Verteidigung gegen Komplexit√§t) und asynchroner Programmierung (Arbeit mit Ereignissen, die f√ºr einige von Dauer sind Zeit).  Der erste Teil des Buches wird durch das Kapitel des zweiten Entwurfs vervollst√§ndigt. <br><br>  Der zweite Teil, Kapitel 13 bis 19, beschreibt die Tools, auf die ein JavaScript-f√§higer Browser Zugriff hat.  Sie lernen, wie Sie Elemente auf dem Bildschirm anzeigen (Kapitel 14 und 17), auf Benutzereingaben reagieren (Kapitel 15) und diese √ºber das Netzwerk freigeben (Kapitel 18).  Dieser Teil enth√§lt auch zwei Kapitel von Projekten. <br><br>  Danach wird Node.js in Kapitel 20 beschrieben und eine kleine Site in Kapitel 21 mit dem angegebenen Tool erstellt. <br><br><h3>  Auszug.  Summation mit reduzieren </h3><br>  Eine andere h√§ufige Sache, die h√§ufig mit Arrays gemacht wird, ist die Berechnung eines einzelnen Werts basierend auf diesen.  Ein Sonderfall hierf√ºr ist das Beispiel, das wir bereits f√ºr die Summierung einer Reihe von Zahlen verwendet haben.  Ein weiteres Beispiel ist das Finden der Schriftart mit den meisten Zeichen. <br><br>  Eine Operation h√∂herer Ordnung, die dieses Muster implementiert, wird als Kurzform (manchmal auch als Faltung bezeichnet) bezeichnet.  Diese Operation erstellt den Wert, indem wiederholt ein Element aus dem Array abgerufen und mit dem aktuellen Wert kombiniert wird.  Wenn wir die Zahlen summieren, beginnen wir bei Null und addieren dann jedes nachfolgende Element zur Summe. <br><br>  Die Parameter der Reduktionsfunktion sind zus√§tzlich zum Array eine Kombinationsfunktion und ein Anfangswert.  Diese Funktion ist etwas komplizierter als Filter und Map. Schauen Sie sie sich also genauer an: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array, combine, start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> current = start; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> element <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> array) { current = combine(current, element); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(reduce([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], (a, b) =&gt; a + b, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 10</span></span></code> </pre> <br>  Die Standardmethode zum Arbeiten mit reduzierten Arrays, die nat√ºrlich dieser Funktion entspricht, bietet zus√§tzlichen Komfort.  Wenn das Array mindestens ein Element enth√§lt, k√∂nnen Sie das Startargument weglassen.  Die Methode w√§hlt das erste Element des Arrays als Anfangswert aus und beginnt mit der Reduzierung ab dem zweiten Element. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 10</span></span></code> </pre> <br>  Um mit reduz (zweimal) die Schriftart mit den meisten Zeichen zu finden, k√∂nnen wir Folgendes schreiben: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">characterCount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">script</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> script.ranges.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">count, [</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-function"><span class="hljs-params">, to]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count + <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">to ‚Äî </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span></span><span class="hljs-function">); }, 0); } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">console</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SCRIPTS.reduce((a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> characterCount(a) &lt; characterCount(b) ? b : a; })); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí {name: "Han", ...}</span></span></code> </pre> <br>  Die CharacterCount-Funktion reduziert die dieser Schriftart zugewiesenen Bereiche, indem sie die Summe ihrer Gr√∂√üen berechnet.  Achten Sie auf die Verwendung der Destrukturierung in der Liste der Parameter der Reduktionsfunktion.  Beim zweiten Aufruf zum Reduzieren wird das vorherige Ergebnis verwendet, um die gr√∂√üte Schriftart zu finden. Dabei werden die beiden Schriftarten wiederholt verglichen und die gr√∂√üere zur√ºckgegeben. <br><br>  Der Han-Schriftart sind im Unicode-Standard √ºber 89.000 Zeichen zugewiesen. Damit ist sie das gr√∂√üte Schriftsystem in unserem Datensatz.  Han ist eine Schriftart, die manchmal f√ºr chinesische, japanische und koreanische Texte verwendet wird.  Ihre Sprachen haben viele gemeinsame Zeichen, obwohl sie unterschiedlich geschrieben sind.  Das Unicode-Konsortium (in den USA ans√§ssig) hat beschlossen, solche Zeichen als ein einziges Aufzeichnungssystem zu betrachten, um Zeichencodes zu speichern.  Dies nennt man Han-Vereinigung und ist f√ºr manche Menschen immer noch sehr √§rgerlich. <br><br><h3>  Zusammensetzbarkeit </h3><br>  Denken wir mal: Wie k√∂nnten wir das vorherige Beispiel (die gr√∂√üte Schriftart finden) ohne Funktionen h√∂herer Ordnung umschreiben?  Der folgende Code ist nicht viel schlimmer. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> biggest = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> script <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> SCRIPTS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (biggest == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || characterCount(biggest) &lt; characterCount(script)) { biggest = script; } } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(biggest); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí {name: "Han", ...}</span></span></code> </pre> <br>  Es erschienen mehrere zus√§tzliche Bindungen, und das Programm wurde vier Zeilen l√§nger.  Aber dieser Code ist immer noch ziemlich klar. <br><br>  Funktionen h√∂herer Ordnung sind sehr n√ºtzlich, wenn Sie Operationen erstellen m√ºssen.  Als Beispiel schreiben wir einen Code, der das durchschnittliche Jahr der Erstellung von Schriftarten lebender und toter Sprachen in einem Datensatz berechnet. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">average</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b) / array.length; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(average( SCRIPTS.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.living).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.year)))); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 1188 console.log(Math.round(average( SCRIPTS.filter(s =&gt; !s.living).map(s =&gt; s.year)))); // ‚Üí 188</span></span></code> </pre> <br>  Daher sind Skripte toter Sprachen in Unicode im Durchschnitt √§lter als Skripte lebender Sprachen. <br><br>  Dies sind keine besonders signifikanten oder √ºberraschenden Statistiken.  Aber Sie stimmen hoffentlich zu, dass der zur Berechnung verwendete Code leicht zu lesen ist.  Dies kann man sich als F√∂rderer vorstellen: Wir analysieren zun√§chst alle Schriftarten, filtern die Lebenden (oder Toten) heraus, nehmen die Jahre ihrer Erstellung, berechnen den Durchschnittswert und runden das Ergebnis ab. <br><br>  Diese Berechnung k√∂nnte auch als ein gro√üer Zyklus dargestellt werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>, count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> script <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> SCRIPTS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (script.living) { total += script.year; count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(total / count)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 1188</span></span></code> </pre> <br>  In diesem Code ist es jedoch schwieriger zu verstehen, was und wie berechnet wird.  Und da die Zwischenergebnisse nicht als konsistente Werte dargestellt werden, m√ºsste viel mehr Arbeit geleistet werden, um so etwas wie den Durchschnitt in eine separate Funktion zu trennen. <br><br>  In Bezug auf die tats√§chliche Funktionsweise des Computers unterscheiden sich diese beiden Ans√§tze ebenfalls grundlegend.  Der erste erstellt neue Arrays, wenn Filter und Map ausgef√ºhrt werden, w√§hrend der zweite nur einige Zahlen berechnet und weniger Arbeit erledigt.  Normalerweise k√∂nnen Sie sich eine besser lesbare Option leisten. Wenn Sie jedoch sehr gro√üe Arrays verarbeiten und mehrmals ausf√ºhren m√ºssen, kann ein weniger abstrakter Stil zu einem zus√§tzlichen Geschwindigkeitsgewinn f√ºhren. <br><br><h3>  Zeichenfolgen und Zeichencodes </h3><br>  Eine Verwendung von Datens√§tzen besteht darin, zu bestimmen, in welche Schriftart ein bestimmtes Textst√ºck eingegeben wird.  Schauen wir uns ein Programm an, das dies tut. <br><br>  Denken Sie daran, dass es f√ºr jede Schriftart ein Array von Zeichencodebereichen gibt.  Wenn wir den Zeichencode kennen, k√∂nnen wir die folgende Funktion verwenden, um die entsprechende Schriftart (falls vorhanden) zu finden: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">characterScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> script <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> SCRIPTS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (script.ranges.some(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-function"><span class="hljs-params">, to]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> code &gt;= <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> &amp;&amp; code &lt; to; })) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> script; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(characterScript(<span class="hljs-number"><span class="hljs-number">121</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí {name: "Latin", ...}</span></span></code> </pre> <br>  Die Methode some ist eine weitere Funktion h√∂herer Ordnung.  Es nimmt eine Testfunktion und meldet, ob es f√ºr ein Element des Arrays true zur√ºckgibt. <br><br>  Aber wie bekommen wir Zeichencodes als Zeichenfolge? <br><br>  In Kapitel 1 habe ich erw√§hnt, dass Zeichenfolgen in JavaScript als Sequenzen von 16-Bit-Zahlen dargestellt werden.  Dies sind die sogenannten Codeeinheiten.  Anfangs wurde angenommen, dass in Unicode der Zeichencode in einem solchen Block platziert wird (was etwas mehr als 65.000 Zeichen ergibt).  Als klar wurde, dass dies nicht ausreichte, lehnten viele die Notwendigkeit ab, mehr Speicher zum Speichern eines Zeichens zu verwenden.  Um dieses Problem zu l√∂sen, wurde das in JavaScript-Strings verwendete UTF-16-Format erfunden.  Darin belegen die h√§ufigsten Zeichen eine 16-Bit-Codeeinheit und der Rest zwei Codeeinheiten. <br><br>  Heute ist allgemein anerkannt, dass UTF-16 eine schlechte Idee war.  Es scheint geschaffen zu sein, um Fehler zu erzeugen.  Sie k√∂nnen leicht ein Programm schreiben, f√ºr das die Codeeinheiten und Zeichen ein und dasselbe sind.  Und wenn Ihre Muttersprache keine Zeichen verwendet, die zwei Codeeinheiten belegen, funktioniert dieses Programm einwandfrei.  Sobald jedoch jemand versucht, ein solches Programm f√ºr ein weniger verbreitetes Alphabet zu verwenden, beispielsweise f√ºr chinesische Schriftzeichen, wird es sofort unterbrochen.  Gl√ºcklicherweise wurden nach dem Aufkommen von Emoticons √ºberall zwei Codeeinheiten f√ºr die Zeichenkodierung verwendet, und die Last der L√∂sung solcher Probleme wurde gerechter verteilt. <br><br>  Leider behandeln offensichtliche Operationen mit JavaScript-Zeichenfolgen, z. B. das Abrufen ihrer L√§nge √ºber die Eigenschaft length und der Zugriff auf deren Inhalt in eckigen Klammern, nur Codeeinheiten. <br><br><img src="https://habrastorage.org/webt/3j/es/v4/3jesv4isii9yakfk56ng-ezxo_i.png" alt="Bild"><br><br>  Die JavaScript-Methode charCodeAt gibt nicht den vollst√§ndigen Zeichencode zur√ºck, sondern eine Codeeinheit.  Die sp√§ter angezeigte codePointAt-Methode gibt das vollst√§ndige Unicode-Zeichen zur√ºck.  Wir k√∂nnten dies also verwenden, um Zeichen aus einer Zeichenfolge abzurufen.  Das an codePointAt √ºbergebene Argument ist jedoch immer noch ein Index in einer Folge von Codeeinheiten.  Um also alle Zeichen in einer Zeichenfolge zu durchlaufen, m√ºssen wir noch die Frage l√∂sen, ob eine oder zwei Codeeinheiten ein Zeichen belegen. <br><br>  Im vorherigen Kapitel habe ich erw√§hnt, dass die for / of-Schleife auch f√ºr Zeichenfolgen verwendet werden kann.  Wie codePointAt trat diese Art von Schleife zu einer Zeit auf, als Programmierer die Probleme von UTF-16 klar erkannten.  Wenn Sie diese Schleife auf eine Zeichenfolge anwenden, werden echte Zeichen und keine Codeeinheiten angegeben. <br><br><img src="https://habrastorage.org/webt/bh/8v/n_/bh8vn_vzqr45dpffqo7mlseo_wq.png" alt="Bild"><br><br>  Wenn Sie ein Zeichen haben (das eine Zeichenfolge aus einer oder zwei Codeeinheiten ist), k√∂nnen Sie codePointAt (0) verwenden, um den Code abzurufen. <br><br><h3>  Texterkennung </h3><br>  Wir haben eine CharacterScript-Funktion und eine M√∂glichkeit, Zeichen in einer Schleife korrekt aufzulisten.  Der n√§chste Schritt besteht darin, die Anzahl der Zeichen zu z√§hlen, die zu jeder Schriftart geh√∂ren.  Hier brauchen wir eine Z√§hlabstraktion: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items, groupName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counts = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> items) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = groupName(item); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> known = counts.findIndex(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> c.name == name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (known == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { counts.push({name, <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>}); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { counts[known].count++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counts; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(countBy([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>], n =&gt; n &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí [{name: false, count: 2}, {name: true, count: 3}]</span></span></code> </pre> <br>  Die countBy-Funktion akzeptiert eine Sammlung (alles, was in einer for / of-Schleife sortiert werden kann) und eine Funktion, die den Gruppennamen f√ºr ein bestimmtes Element berechnet.  Die Funktion countBy gibt ein Array von Objekten zur√ºck, von denen jedes den Namen der Gruppe und die Anzahl der daf√ºr gefundenen Elemente enth√§lt. <br><br>  Diese Funktion verwendet eine andere Methode zum Arbeiten mit Arrays - findIndex.  Diese Methode √§hnelt indexOf, sucht jedoch nicht nach einem bestimmten Wert, sondern findet den ersten Wert, f√ºr den die angegebene Funktion true zur√ºckgibt.  Wenn das Element nicht gefunden wird, gibt findIndex wie indexOf ‚Äì1 zur√ºck. <br><br>  Mit countBy k√∂nnen wir eine Funktion schreiben, die angibt, welche Schriftarten in diesem Text verwendet wurden. <br><br><img src="https://habrastorage.org/webt/fz/ph/l_/fzphl_qnjsxe6dmsr5rbetd1lam.png" alt="Bild"><br><br>  Die Funktion z√§hlt Zeichen zuerst nach Schriftartnamen und gibt ihnen mit CharacterScript einen Namen. F√ºr Zeichen, die keiner Schriftart angeh√∂ren, wird die Zeichenfolge "none" zur√ºckgegeben.  Durch das Aufrufen des Filters wird der Eintrag "none" aus dem resultierenden Array entfernt, da wir nicht an diesen Zeichen interessiert sind. <br><br>  Um Prozents√§tze berechnen zu k√∂nnen, m√ºssen wir zuerst die Gesamtzahl der Zeichen ermitteln, die zu der Schriftart geh√∂ren, die wir mit der Reduzierungsmethode berechnen k√∂nnen.  Wenn keine solchen Zeichen gefunden werden, gibt die Funktion eine bestimmte Zeichenfolge zur√ºck.  Andernfalls werden die Z√§hlergebnisse mithilfe von map in lesbare Zeichenfolgen konvertiert und anschlie√üend mithilfe von join kombiniert. <br><br><h3>  Zusammenfassung </h3><br>  Die M√∂glichkeit, Funktionswerte an andere Funktionen zu √ºbergeben, ist ein sehr n√ºtzlicher Aspekt von JavaScript.  Auf diese Weise k√∂nnen Sie Funktionen erstellen, die Berechnungen mit Leerzeichen simulieren.  Wenn anschlie√üend solche Funktionen im Code aufgerufen werden, werden diese ‚ÄûL√ºcken‚Äú mit Funktionswerten gef√ºllt. <br><br>  F√ºr Arrays gibt es eine Reihe n√ºtzlicher Methoden h√∂herer Ordnung.  Die forEach-Methode kann verwendet werden, um die Elemente eines Arrays zu durchlaufen.  Die Filtermethode gibt ein neues Array zur√ºck, das nur Elemente enth√§lt, die die Bedingung der Pr√§dikativfunktion erf√ºllen.  Die Array-Konvertierung durch Ausf√ºhren einer Funktion f√ºr jedes Element erfolgt mithilfe von map.  Um alle Elemente eines Arrays zu einem einzigen Wert zu kombinieren, k√∂nnen Sie Reduzieren verwenden.  Die Methode some pr√ºft, ob ein Element mit einer bestimmten Pr√§dikativfunktion √ºbereinstimmt.  Schlie√ülich findet die findIndex-Methode die Position des ersten Elements, das dem Pr√§dikat entspricht. <br><br>  ¬ªWeitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br>  25% Rabatt auf Gutschein f√ºr H√§ndler - <b>JavaScript</b> <br>  Nach Bezahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463465/">https://habr.com/ru/post/de463465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463447/index.html">Astra Linux 1.6 (Smolensk). Ist das System bereit, mit normalen Benutzern zu arbeiten? Kr√ºckenbeispiele</a></li>
<li><a href="../de463455/index.html">Tausende Dinge, die in Java ab Version 1 behoben werden m√ºssen: ein gro√üartiges Interview mit Sergey Kuksenko von Oracle</a></li>
<li><a href="../de463459/index.html">Versteckte Fehler bei Shared Element Transitions</a></li>
<li><a href="../de463461/index.html">Was ist und was nicht in Go. Teil 1</a></li>
<li><a href="../de463463/index.html">Methode zum Erstellen eines DRAG- und DROP-Effekts</a></li>
<li><a href="../de463469/index.html">Schr√∂dinger Katze ohne Box: das Problem des Konsenses in verteilten Systemen</a></li>
<li><a href="../de463471/index.html">Funktionsumschaltung: Ansichten, Vorteile und Arbeiten mit ihnen in .NET</a></li>
<li><a href="../de463473/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 16. Networking in einem kleinen B√ºro</a></li>
<li><a href="../de463477/index.html">Ruhe: dBud-Ohrst√∂psel mit zwei Ger√§uschreduzierungsstufen</a></li>
<li><a href="../de463481/index.html">Diskrete Mathematik f√ºr WMS: Algorithmus zum Komprimieren von Waren in Zellen (Teil 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>