<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏿‍🤝‍🧑🏻 🙅🏻 🃏 Das Buch „Expressive JavaScript. Moderne Webprogrammierung. 3. Auflage 🤷 🔛 🍆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habrozhiteli! In diesem Buch können Sie tief in das Thema eintauchen und lernen, wie man schönen und effektiven Code schreibt. Sie lernen Syntax...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Buch „Expressive JavaScript. Moderne Webprogrammierung. 3. Auflage</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/463465/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/hj/ac/jw/hjacjwa9yynefuv1iquueauasum.jpeg" align="left" alt="Bild"></a>  Hallo habrozhiteli!  In diesem Buch können Sie tief in das Thema eintauchen und lernen, wie man schönen und effektiven Code schreibt.  Sie lernen Syntax, Pfeil- und asynchrone Funktionen, Iterator, Musterzeichenfolgen und Blockbereich kennen. <br><br>  Marein Haverbeke - Praktizierende.  Sammeln Sie Erfahrungen und lernen Sie die Sprache anhand einer Vielzahl von Beispielen durch Übungen und Trainingsprojekte.  Zunächst werden Sie mit der Struktur der JavaScript-Sprache vertraut gemacht, Strukturen, Funktionen und Datenstrukturen verwalten, dann Fehlerbehandlung und Fehlerbehebungen, Modularität und asynchrone Programmierung untersuchen und dann mit der Browserprogrammierung fortfahren. <br><a name="habracut"></a><br><h3>  Überprüfen Sie dieses Buch </h3><br>  Dieses Buch ist in drei große Teile gegliedert.  In den ersten 12 Kapiteln wird die JavaScript-Sprache erläutert.  In den nächsten sieben Kapiteln geht es um Browser und wie sie mit JavaScript programmiert werden.  Schließlich sind zwei Kapitel Node.js gewidmet, einer anderen JavaScript-Programmierumgebung. <br><br>  Im gesamten Buch werden Sie fünf Kapitel von Projekten kennenlernen, in denen größere Beispiele für Programme beschrieben werden, damit Sie den Geschmack einer echten Programmierung spüren können.  In der Reihenfolge ihres Auftretens werden wir daran arbeiten, einen Bereitstellungsroboter, eine Programmiersprache, eine Spieleplattform, einen Raster-Grafikeditor und eine dynamische Site zu erstellen. <br><br>  Der sprachliche Teil des Buches beginnt mit vier Kapiteln, die Sie in die Grundstruktur der JavaScript-Sprache einführen.  Sie lernen Kontrollstrukturen (wie das Schlüsselwort while, das Sie bereits in der Einführung gesehen haben), Funktionen (Schreiben eigener Bausteine) und Datenstrukturen kennen.  Danach können Sie die einfachsten Programme schreiben.  Darüber hinaus wird in den Kapiteln 5 und 6 beschrieben, wie Funktionen und Objekte verwendet werden, um abstrakteren Code zu schreiben und dessen Komplexität zu steuern. <br><br>  Nach dem Kapitel des ersten Projekts wird der sprachliche Teil des Buches fortgesetzt. Die folgenden Kapitel befassen sich mit der Erkennung und Korrektur von Fehlern, regulären Ausdrücken (ein wichtiges Werkzeug für die Arbeit mit Text), Modularität (eine weitere Verteidigung gegen Komplexität) und asynchroner Programmierung (Arbeit mit Ereignissen, die für einige von Dauer sind Zeit).  Der erste Teil des Buches wird durch das Kapitel des zweiten Entwurfs vervollständigt. <br><br>  Der zweite Teil, Kapitel 13 bis 19, beschreibt die Tools, auf die ein JavaScript-fähiger Browser Zugriff hat.  Sie lernen, wie Sie Elemente auf dem Bildschirm anzeigen (Kapitel 14 und 17), auf Benutzereingaben reagieren (Kapitel 15) und diese über das Netzwerk freigeben (Kapitel 18).  Dieser Teil enthält auch zwei Kapitel von Projekten. <br><br>  Danach wird Node.js in Kapitel 20 beschrieben und eine kleine Site in Kapitel 21 mit dem angegebenen Tool erstellt. <br><br><h3>  Auszug.  Summation mit reduzieren </h3><br>  Eine andere häufige Sache, die häufig mit Arrays gemacht wird, ist die Berechnung eines einzelnen Werts basierend auf diesen.  Ein Sonderfall hierfür ist das Beispiel, das wir bereits für die Summierung einer Reihe von Zahlen verwendet haben.  Ein weiteres Beispiel ist das Finden der Schriftart mit den meisten Zeichen. <br><br>  Eine Operation höherer Ordnung, die dieses Muster implementiert, wird als Kurzform (manchmal auch als Faltung bezeichnet) bezeichnet.  Diese Operation erstellt den Wert, indem wiederholt ein Element aus dem Array abgerufen und mit dem aktuellen Wert kombiniert wird.  Wenn wir die Zahlen summieren, beginnen wir bei Null und addieren dann jedes nachfolgende Element zur Summe. <br><br>  Die Parameter der Reduktionsfunktion sind zusätzlich zum Array eine Kombinationsfunktion und ein Anfangswert.  Diese Funktion ist etwas komplizierter als Filter und Map. Schauen Sie sie sich also genauer an: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array, combine, start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> current = start; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> element <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> array) { current = combine(current, element); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(reduce([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], (a, b) =&gt; a + b, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// → 10</span></span></code> </pre> <br>  Die Standardmethode zum Arbeiten mit reduzierten Arrays, die natürlich dieser Funktion entspricht, bietet zusätzlichen Komfort.  Wenn das Array mindestens ein Element enthält, können Sie das Startargument weglassen.  Die Methode wählt das erste Element des Arrays als Anfangswert aus und beginnt mit der Reduzierung ab dem zweiten Element. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b)); <span class="hljs-comment"><span class="hljs-comment">// → 10</span></span></code> </pre> <br>  Um mit reduz (zweimal) die Schriftart mit den meisten Zeichen zu finden, können wir Folgendes schreiben: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">characterCount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">script</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> script.ranges.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">count, [</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-function"><span class="hljs-params">, to]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count + <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">to — </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span></span><span class="hljs-function">); }, 0); } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">console</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SCRIPTS.reduce((a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> characterCount(a) &lt; characterCount(b) ? b : a; })); <span class="hljs-comment"><span class="hljs-comment">// → {name: "Han", ...}</span></span></code> </pre> <br>  Die CharacterCount-Funktion reduziert die dieser Schriftart zugewiesenen Bereiche, indem sie die Summe ihrer Größen berechnet.  Achten Sie auf die Verwendung der Destrukturierung in der Liste der Parameter der Reduktionsfunktion.  Beim zweiten Aufruf zum Reduzieren wird das vorherige Ergebnis verwendet, um die größte Schriftart zu finden. Dabei werden die beiden Schriftarten wiederholt verglichen und die größere zurückgegeben. <br><br>  Der Han-Schriftart sind im Unicode-Standard über 89.000 Zeichen zugewiesen. Damit ist sie das größte Schriftsystem in unserem Datensatz.  Han ist eine Schriftart, die manchmal für chinesische, japanische und koreanische Texte verwendet wird.  Ihre Sprachen haben viele gemeinsame Zeichen, obwohl sie unterschiedlich geschrieben sind.  Das Unicode-Konsortium (in den USA ansässig) hat beschlossen, solche Zeichen als ein einziges Aufzeichnungssystem zu betrachten, um Zeichencodes zu speichern.  Dies nennt man Han-Vereinigung und ist für manche Menschen immer noch sehr ärgerlich. <br><br><h3>  Zusammensetzbarkeit </h3><br>  Denken wir mal: Wie könnten wir das vorherige Beispiel (die größte Schriftart finden) ohne Funktionen höherer Ordnung umschreiben?  Der folgende Code ist nicht viel schlimmer. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> biggest = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> script <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> SCRIPTS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (biggest == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || characterCount(biggest) &lt; characterCount(script)) { biggest = script; } } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(biggest); <span class="hljs-comment"><span class="hljs-comment">// → {name: "Han", ...}</span></span></code> </pre> <br>  Es erschienen mehrere zusätzliche Bindungen, und das Programm wurde vier Zeilen länger.  Aber dieser Code ist immer noch ziemlich klar. <br><br>  Funktionen höherer Ordnung sind sehr nützlich, wenn Sie Operationen erstellen müssen.  Als Beispiel schreiben wir einen Code, der das durchschnittliche Jahr der Erstellung von Schriftarten lebender und toter Sprachen in einem Datensatz berechnet. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">average</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b) / array.length; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(average( SCRIPTS.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.living).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.year)))); <span class="hljs-comment"><span class="hljs-comment">// → 1188 console.log(Math.round(average( SCRIPTS.filter(s =&gt; !s.living).map(s =&gt; s.year)))); // → 188</span></span></code> </pre> <br>  Daher sind Skripte toter Sprachen in Unicode im Durchschnitt älter als Skripte lebender Sprachen. <br><br>  Dies sind keine besonders signifikanten oder überraschenden Statistiken.  Aber Sie stimmen hoffentlich zu, dass der zur Berechnung verwendete Code leicht zu lesen ist.  Dies kann man sich als Förderer vorstellen: Wir analysieren zunächst alle Schriftarten, filtern die Lebenden (oder Toten) heraus, nehmen die Jahre ihrer Erstellung, berechnen den Durchschnittswert und runden das Ergebnis ab. <br><br>  Diese Berechnung könnte auch als ein großer Zyklus dargestellt werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>, count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> script <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> SCRIPTS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (script.living) { total += script.year; count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(total / count)); <span class="hljs-comment"><span class="hljs-comment">// → 1188</span></span></code> </pre> <br>  In diesem Code ist es jedoch schwieriger zu verstehen, was und wie berechnet wird.  Und da die Zwischenergebnisse nicht als konsistente Werte dargestellt werden, müsste viel mehr Arbeit geleistet werden, um so etwas wie den Durchschnitt in eine separate Funktion zu trennen. <br><br>  In Bezug auf die tatsächliche Funktionsweise des Computers unterscheiden sich diese beiden Ansätze ebenfalls grundlegend.  Der erste erstellt neue Arrays, wenn Filter und Map ausgeführt werden, während der zweite nur einige Zahlen berechnet und weniger Arbeit erledigt.  Normalerweise können Sie sich eine besser lesbare Option leisten. Wenn Sie jedoch sehr große Arrays verarbeiten und mehrmals ausführen müssen, kann ein weniger abstrakter Stil zu einem zusätzlichen Geschwindigkeitsgewinn führen. <br><br><h3>  Zeichenfolgen und Zeichencodes </h3><br>  Eine Verwendung von Datensätzen besteht darin, zu bestimmen, in welche Schriftart ein bestimmtes Textstück eingegeben wird.  Schauen wir uns ein Programm an, das dies tut. <br><br>  Denken Sie daran, dass es für jede Schriftart ein Array von Zeichencodebereichen gibt.  Wenn wir den Zeichencode kennen, können wir die folgende Funktion verwenden, um die entsprechende Schriftart (falls vorhanden) zu finden: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">characterScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> script <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> SCRIPTS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (script.ranges.some(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-function"><span class="hljs-params">, to]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> code &gt;= <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> &amp;&amp; code &lt; to; })) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> script; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(characterScript(<span class="hljs-number"><span class="hljs-number">121</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// → {name: "Latin", ...}</span></span></code> </pre> <br>  Die Methode some ist eine weitere Funktion höherer Ordnung.  Es nimmt eine Testfunktion und meldet, ob es für ein Element des Arrays true zurückgibt. <br><br>  Aber wie bekommen wir Zeichencodes als Zeichenfolge? <br><br>  In Kapitel 1 habe ich erwähnt, dass Zeichenfolgen in JavaScript als Sequenzen von 16-Bit-Zahlen dargestellt werden.  Dies sind die sogenannten Codeeinheiten.  Anfangs wurde angenommen, dass in Unicode der Zeichencode in einem solchen Block platziert wird (was etwas mehr als 65.000 Zeichen ergibt).  Als klar wurde, dass dies nicht ausreichte, lehnten viele die Notwendigkeit ab, mehr Speicher zum Speichern eines Zeichens zu verwenden.  Um dieses Problem zu lösen, wurde das in JavaScript-Strings verwendete UTF-16-Format erfunden.  Darin belegen die häufigsten Zeichen eine 16-Bit-Codeeinheit und der Rest zwei Codeeinheiten. <br><br>  Heute ist allgemein anerkannt, dass UTF-16 eine schlechte Idee war.  Es scheint geschaffen zu sein, um Fehler zu erzeugen.  Sie können leicht ein Programm schreiben, für das die Codeeinheiten und Zeichen ein und dasselbe sind.  Und wenn Ihre Muttersprache keine Zeichen verwendet, die zwei Codeeinheiten belegen, funktioniert dieses Programm einwandfrei.  Sobald jedoch jemand versucht, ein solches Programm für ein weniger verbreitetes Alphabet zu verwenden, beispielsweise für chinesische Schriftzeichen, wird es sofort unterbrochen.  Glücklicherweise wurden nach dem Aufkommen von Emoticons überall zwei Codeeinheiten für die Zeichenkodierung verwendet, und die Last der Lösung solcher Probleme wurde gerechter verteilt. <br><br>  Leider behandeln offensichtliche Operationen mit JavaScript-Zeichenfolgen, z. B. das Abrufen ihrer Länge über die Eigenschaft length und der Zugriff auf deren Inhalt in eckigen Klammern, nur Codeeinheiten. <br><br><img src="https://habrastorage.org/webt/3j/es/v4/3jesv4isii9yakfk56ng-ezxo_i.png" alt="Bild"><br><br>  Die JavaScript-Methode charCodeAt gibt nicht den vollständigen Zeichencode zurück, sondern eine Codeeinheit.  Die später angezeigte codePointAt-Methode gibt das vollständige Unicode-Zeichen zurück.  Wir könnten dies also verwenden, um Zeichen aus einer Zeichenfolge abzurufen.  Das an codePointAt übergebene Argument ist jedoch immer noch ein Index in einer Folge von Codeeinheiten.  Um also alle Zeichen in einer Zeichenfolge zu durchlaufen, müssen wir noch die Frage lösen, ob eine oder zwei Codeeinheiten ein Zeichen belegen. <br><br>  Im vorherigen Kapitel habe ich erwähnt, dass die for / of-Schleife auch für Zeichenfolgen verwendet werden kann.  Wie codePointAt trat diese Art von Schleife zu einer Zeit auf, als Programmierer die Probleme von UTF-16 klar erkannten.  Wenn Sie diese Schleife auf eine Zeichenfolge anwenden, werden echte Zeichen und keine Codeeinheiten angegeben. <br><br><img src="https://habrastorage.org/webt/bh/8v/n_/bh8vn_vzqr45dpffqo7mlseo_wq.png" alt="Bild"><br><br>  Wenn Sie ein Zeichen haben (das eine Zeichenfolge aus einer oder zwei Codeeinheiten ist), können Sie codePointAt (0) verwenden, um den Code abzurufen. <br><br><h3>  Texterkennung </h3><br>  Wir haben eine CharacterScript-Funktion und eine Möglichkeit, Zeichen in einer Schleife korrekt aufzulisten.  Der nächste Schritt besteht darin, die Anzahl der Zeichen zu zählen, die zu jeder Schriftart gehören.  Hier brauchen wir eine Zählabstraktion: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items, groupName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counts = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> items) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = groupName(item); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> known = counts.findIndex(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> c.name == name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (known == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { counts.push({name, <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>}); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { counts[known].count++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counts; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(countBy([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>], n =&gt; n &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// → [{name: false, count: 2}, {name: true, count: 3}]</span></span></code> </pre> <br>  Die countBy-Funktion akzeptiert eine Sammlung (alles, was in einer for / of-Schleife sortiert werden kann) und eine Funktion, die den Gruppennamen für ein bestimmtes Element berechnet.  Die Funktion countBy gibt ein Array von Objekten zurück, von denen jedes den Namen der Gruppe und die Anzahl der dafür gefundenen Elemente enthält. <br><br>  Diese Funktion verwendet eine andere Methode zum Arbeiten mit Arrays - findIndex.  Diese Methode ähnelt indexOf, sucht jedoch nicht nach einem bestimmten Wert, sondern findet den ersten Wert, für den die angegebene Funktion true zurückgibt.  Wenn das Element nicht gefunden wird, gibt findIndex wie indexOf –1 zurück. <br><br>  Mit countBy können wir eine Funktion schreiben, die angibt, welche Schriftarten in diesem Text verwendet wurden. <br><br><img src="https://habrastorage.org/webt/fz/ph/l_/fzphl_qnjsxe6dmsr5rbetd1lam.png" alt="Bild"><br><br>  Die Funktion zählt Zeichen zuerst nach Schriftartnamen und gibt ihnen mit CharacterScript einen Namen. Für Zeichen, die keiner Schriftart angehören, wird die Zeichenfolge "none" zurückgegeben.  Durch das Aufrufen des Filters wird der Eintrag "none" aus dem resultierenden Array entfernt, da wir nicht an diesen Zeichen interessiert sind. <br><br>  Um Prozentsätze berechnen zu können, müssen wir zuerst die Gesamtzahl der Zeichen ermitteln, die zu der Schriftart gehören, die wir mit der Reduzierungsmethode berechnen können.  Wenn keine solchen Zeichen gefunden werden, gibt die Funktion eine bestimmte Zeichenfolge zurück.  Andernfalls werden die Zählergebnisse mithilfe von map in lesbare Zeichenfolgen konvertiert und anschließend mithilfe von join kombiniert. <br><br><h3>  Zusammenfassung </h3><br>  Die Möglichkeit, Funktionswerte an andere Funktionen zu übergeben, ist ein sehr nützlicher Aspekt von JavaScript.  Auf diese Weise können Sie Funktionen erstellen, die Berechnungen mit Leerzeichen simulieren.  Wenn anschließend solche Funktionen im Code aufgerufen werden, werden diese „Lücken“ mit Funktionswerten gefüllt. <br><br>  Für Arrays gibt es eine Reihe nützlicher Methoden höherer Ordnung.  Die forEach-Methode kann verwendet werden, um die Elemente eines Arrays zu durchlaufen.  Die Filtermethode gibt ein neues Array zurück, das nur Elemente enthält, die die Bedingung der Prädikativfunktion erfüllen.  Die Array-Konvertierung durch Ausführen einer Funktion für jedes Element erfolgt mithilfe von map.  Um alle Elemente eines Arrays zu einem einzigen Wert zu kombinieren, können Sie Reduzieren verwenden.  Die Methode some prüft, ob ein Element mit einer bestimmten Prädikativfunktion übereinstimmt.  Schließlich findet die findIndex-Methode die Position des ersten Elements, das dem Prädikat entspricht. <br><br>  »Weitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br>  25% Rabatt auf Gutschein für Händler - <b>JavaScript</b> <br>  Nach Bezahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463465/">https://habr.com/ru/post/de463465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463447/index.html">Astra Linux 1.6 (Smolensk). Ist das System bereit, mit normalen Benutzern zu arbeiten? Krückenbeispiele</a></li>
<li><a href="../de463455/index.html">Tausende Dinge, die in Java ab Version 1 behoben werden müssen: ein großartiges Interview mit Sergey Kuksenko von Oracle</a></li>
<li><a href="../de463459/index.html">Versteckte Fehler bei Shared Element Transitions</a></li>
<li><a href="../de463461/index.html">Was ist und was nicht in Go. Teil 1</a></li>
<li><a href="../de463463/index.html">Methode zum Erstellen eines DRAG- und DROP-Effekts</a></li>
<li><a href="../de463469/index.html">Schrödinger Katze ohne Box: das Problem des Konsenses in verteilten Systemen</a></li>
<li><a href="../de463471/index.html">Funktionsumschaltung: Ansichten, Vorteile und Arbeiten mit ihnen in .NET</a></li>
<li><a href="../de463473/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 16. Networking in einem kleinen Büro</a></li>
<li><a href="../de463477/index.html">Ruhe: dBud-Ohrstöpsel mit zwei Geräuschreduzierungsstufen</a></li>
<li><a href="../de463481/index.html">Diskrete Mathematik für WMS: Algorithmus zum Komprimieren von Waren in Zellen (Teil 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>