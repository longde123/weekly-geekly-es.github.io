<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏾 💽 🎽 Débogage des retards réseau dans Kubernetes 👗 🤲🏻 🌄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelques années, Kubernetes a déjà été discuté sur le blog officiel de GitHub. Depuis lors, il est devenu la technologie standard pour le déplo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Débogage des retards réseau dans Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/477390/"><img src="https://habrastorage.org/getpro/habr/post_images/c82/5b1/413/c825b1413d9c59cf78c51e6e2c8f8049.png"><br><br>  Il y a quelques années, Kubernetes a <a href="https://github.blog/2017-08-16-kubernetes-at-github/">déjà</a> été <a href="https://github.blog/2017-08-16-kubernetes-at-github/">discuté</a> sur le blog officiel de GitHub.  Depuis lors, il est devenu la technologie standard pour le déploiement de services.  Kubernetes gère désormais une partie importante des services internes et publics.  Au fur et à mesure que nos clusters se sont développés et que les exigences de performances sont devenues plus strictes, nous avons commencé à remarquer que certains services sur Kubernetes affichent sporadiquement des retards qui ne peuvent être expliqués par la charge de l'application elle-même. <br><br>  En fait, dans les applications, un retard de réseau aléatoire allant jusqu'à 100 ms ou plus se produit, ce qui entraîne des délais d'attente ou des tentatives.  Il était prévu que les services seraient en mesure de répondre aux demandes beaucoup plus rapidement que 100 ms.  Mais cela n'est pas possible si la connexion elle-même prend autant de temps.  Séparément, nous avons observé des requêtes MySQL très rapides, qui devaient prendre des millisecondes, et MySQL vraiment géré en millisecondes, mais du point de vue de l'application demandeuse, la réponse a pris 100 ms ou plus. <br><a name="habracut"></a><br>  Il est immédiatement devenu clair que le problème se produit uniquement lors de la connexion à l'hôte Kubernetes, même si l'appel provenait de l'extérieur de Kubernetes.  Le moyen le plus simple de reproduire le problème est le test <a href="https://github.com/tsenart/vegeta">Vegeta</a> , qui s'exécute à partir de n'importe quel hôte interne, teste le service Kubernetes sur un port spécifique et enregistre sporadiquement un délai important.  Dans cet article, nous verrons comment nous avons réussi à rechercher la cause de ce problème. <br><br><h1>  Élimine la complexité inutile de la chaîne de défaillance </h1><br>  Après avoir reproduit le même exemple, nous avons voulu affiner le centre du problème et supprimer les couches supplémentaires de complexité.  Au départ, il y avait trop d'éléments dans le ruisseau entre Vegeta et les gousses sur Kubernetes.  Pour identifier un problème de réseau plus profond, vous devez en exclure certains. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/488/8c1/d29/4888c1d29a8fc1b4a1194c4c3a14c9ff.png"><br><br>  Le client (Vegeta) crée une connexion TCP avec n'importe quel nœud du cluster.  Kubernetes agit comme un réseau de superposition (au-dessus du réseau de centre de données existant) qui utilise <a href="https://en.wikipedia.org/wiki/IP_in_IP">IPIP</a> , c'est-à-dire qui encapsule les paquets IP du réseau de superposition à l'intérieur des paquets IP du centre de données.  Lorsqu'il est connecté au premier nœud, la <a href="https://en.wikipedia.org/wiki/Network_address_translation">traduction d'</a> adresse réseau NAT ( <a href="https://en.wikipedia.org/wiki/Network_address_translation">Network Address Translation</a> ) est effectuée avec une surveillance d'état pour convertir l'adresse IP et le port de l'hôte Kubernetes en adresse IP et port sur le réseau de superposition (en particulier, le pod avec l'application).  Pour les paquets reçus, la séquence inverse est effectuée.  Il s'agit d'un système complexe avec de nombreux états et de nombreux éléments qui sont constamment mis à jour et modifiés au fur et à mesure du déploiement et du déplacement des services. <br><br>  L'utilitaire <code>tcpdump</code> dans le test Vegeta donne un délai pendant la négociation TCP (entre SYN et SYN-ACK).  Pour supprimer cette complexité inutile, vous pouvez utiliser <code>hping3</code> pour de simples «pings» avec les packages SYN.  Vérifiez s'il y a un retard dans le paquet de réponse, puis réinitialisez la connexion.  Nous pouvons filtrer les données en n'incluant que les paquets de plus de 100 ms, et obtenir une option plus simple pour reproduire le problème que le test complet du réseau de niveau 7 dans Vegeta.  Voici les «pings» de l'hôte Kubernetes utilisant TCP SYN / SYN-ACK sur le «port» hôte du service (30927) avec un intervalle de 10 ms, filtré par les réponses les plus lentes: <br><br> <code>theojulienne@shell ~ $ sudo hping3 172.16.47.27 -S -p 30927 -i u10000 | egrep --line-buffered 'rtt=[0-9]{3}\.' <br> <br> len=46 ip=172.16.47.27 ttl=59 DF id=0 sport=30927 flags=SA seq=1485 win=29200 rtt=127.1 ms <br> <br> len=46 ip=172.16.47.27 ttl=59 DF id=0 sport=30927 flags=SA seq=1486 win=29200 rtt=117.0 ms <br> <br> len=46 ip=172.16.47.27 ttl=59 DF id=0 sport=30927 flags=SA seq=1487 win=29200 rtt=106.2 ms <br> <br> len=46 ip=172.16.47.27 ttl=59 DF id=0 sport=30927 flags=SA seq=1488 win=29200 rtt=104.1 ms <br> <br> len=46 ip=172.16.47.27 ttl=59 DF id=0 sport=30927 flags=SA seq=5024 win=29200 rtt=109.2 ms <br> <br> len=46 ip=172.16.47.27 ttl=59 DF id=0 sport=30927 flags=SA seq=5231 win=29200 rtt=109.2 ms</code> <br> <br>  Peut immédiatement faire la première observation.  Les numéros de série et les horaires montrent qu'il ne s'agit pas d'une congestion ponctuelle.  Le retard s'accumule souvent et est finalement traité. <br><br>  Ensuite, nous voulons savoir quels composants peuvent être impliqués dans l'apparition de congestion.  Peut-être que ce sont quelques-unes des centaines de règles iptables en NAT?  Ou quelques problèmes avec le tunnel IPIP sur le réseau?  Une façon de le vérifier consiste à vérifier chaque étape du système en l'excluant.  Que se passe-t-il si vous supprimez la logique NAT et pare-feu, ne laissant qu'une partie de IPIP: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b3/e2a/cff/5b3e2acff2ef9f1f8c7c527356741d92.png"><br><br>  Heureusement, Linux facilite l'accès direct à la couche de superposition IP si la machine est sur le même réseau: <br><br> <code>theojulienne@kube-node-client ~ $ sudo hping3 10.125.20.64 -S -i u10000 | egrep --line-buffered 'rtt=[0-9]{3}\.' <br> <br> len=40 ip=10.125.20.64 ttl=64 DF id=0 sport=0 flags=RA seq=7346 win=0 rtt=127.3 ms <br> <br> len=40 ip=10.125.20.64 ttl=64 DF id=0 sport=0 flags=RA seq=7347 win=0 rtt=117.3 ms <br> <br> len=40 ip=10.125.20.64 ttl=64 DF id=0 sport=0 flags=RA seq=7348 win=0 rtt=107.2 ms</code> <br> <br>  A en juger par les résultats, le problème persiste!  Cela exclut iptables et NAT.  Le problème est donc dans TCP?  Voyons comment va le ping ICMP: <br><br> <code>theojulienne@kube-node-client ~ $ sudo hping3 10.125.20.64 --icmp -i u10000 | egrep --line-buffered 'rtt=[0-9]{3}\.' <br> <br> len=28 ip=10.125.20.64 ttl=64 id=42594 icmp_seq=104 rtt=110.0 ms <br> <br> len=28 ip=10.125.20.64 ttl=64 id=49448 icmp_seq=4022 rtt=141.3 ms <br> <br> len=28 ip=10.125.20.64 ttl=64 id=49449 icmp_seq=4023 rtt=131.3 ms <br> <br> len=28 ip=10.125.20.64 ttl=64 id=49450 icmp_seq=4024 rtt=121.2 ms <br> <br> len=28 ip=10.125.20.64 ttl=64 id=49451 icmp_seq=4025 rtt=111.2 ms <br> <br> len=28 ip=10.125.20.64 ttl=64 id=49452 icmp_seq=4026 rtt=101.1 ms <br> <br> len=28 ip=10.125.20.64 ttl=64 id=50023 icmp_seq=4343 rtt=126.8 ms <br> <br> len=28 ip=10.125.20.64 ttl=64 id=50024 icmp_seq=4344 rtt=116.8 ms <br> <br> len=28 ip=10.125.20.64 ttl=64 id=50025 icmp_seq=4345 rtt=106.8 ms <br> <br> len=28 ip=10.125.20.64 ttl=64 id=59727 icmp_seq=9836 rtt=106.1 ms</code> <br> <br>  Les résultats montrent que le problème n'a pas disparu.  C'est peut-être un tunnel IPIP?  Simplifions le test: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/267/ff6/137/267ff613754b99f8cc1bb1d89119206e.png"><br><br>  Tous les paquets sont-ils envoyés entre ces deux hôtes? <br><br> <code>theojulienne@kube-node-client ~ $ sudo hping3 172.16.47.27 --icmp -i u10000 | egrep --line-buffered 'rtt=[0-9]{3}\.' <br> <br> len=46 ip=172.16.47.27 ttl=61 id=41127 icmp_seq=12564 rtt=140.9 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 id=41128 icmp_seq=12565 rtt=130.9 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 id=41129 icmp_seq=12566 rtt=120.8 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 id=41130 icmp_seq=12567 rtt=110.8 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 id=41131 icmp_seq=12568 rtt=100.7 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 id=9062 icmp_seq=31443 rtt=134.2 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 id=9063 icmp_seq=31444 rtt=124.2 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 id=9064 icmp_seq=31445 rtt=114.2 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 id=9065 icmp_seq=31446 rtt=104.2 ms</code> <br> <br>  Nous avons simplifié la situation pour que deux hôtes Kubernetes s'envoient n'importe quel paquet, même un ping ICMP.  Ils voient toujours un retard si l'hôte cible est «mauvais» (certains pires que d'autres). <br><br>  Maintenant, la dernière question: pourquoi le retard ne se produit-il que sur les serveurs de nœuds de kube?  Et cela se produit-il lorsque le noeud kube est l'expéditeur ou le destinataire?  Heureusement, cela est également assez facile à comprendre en envoyant un paquet à partir d'un hôte en dehors de Kubernetes, mais avec le même destinataire "mauvais connu".  Comme vous pouvez le constater, le problème n'a pas disparu: <br><br> <code>theojulienne@shell ~ $ sudo hping3 172.16.47.27 -p 9876 -S -i u10000 | egrep --line-buffered 'rtt=[0-9]{3}\.' <br> <br> len=46 ip=172.16.47.27 ttl=61 DF id=0 sport=9876 flags=RA seq=312 win=0 rtt=108.5 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 DF id=0 sport=9876 flags=RA seq=5903 win=0 rtt=119.4 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 DF id=0 sport=9876 flags=RA seq=6227 win=0 rtt=139.9 ms <br> <br> len=46 ip=172.16.47.27 ttl=61 DF id=0 sport=9876 flags=RA seq=7929 win=0 rtt=131.2 ms</code> <br> <br>  Ensuite, nous effectuons les mêmes requêtes depuis le nœud kube source précédent vers l'hôte externe (ce qui exclut l'hôte d'origine, car le ping inclut à la fois les composants RX et TX): <br><br> <code>theojulienne@kube-node-client ~ $ sudo hping3 172.16.33.44 -p 9876 -S -i u10000 | egrep --line-buffered 'rtt=[0-9]{3}\.' <br> ^C <br> --- 172.16.33.44 hping statistic --- <br> 22352 packets transmitted, 22350 packets received, 1% packet loss <br> round-trip min/avg/max = 0.2/7.6/1010.6 ms</code> <br> <br>  Après avoir examiné les captures de paquets retardées, nous avons obtenu des informations supplémentaires.  En particulier, que l'expéditeur (ci-dessous) voit ce délai, mais le récepteur (ci-dessus) ne le voit pas - voir la colonne Delta (en secondes): <br><br> <a href=""><img src="https://habrastorage.org/webt/4m/-t/dj/4m-tdjzws9lrhnva3xcxijel7eg.png"></a> <br><br>  De plus, si vous regardez la différence dans l'ordre des paquets TCP et ICMP (par numéros de séquence) du côté destinataire, les paquets ICMP arrivent toujours dans la même séquence dans laquelle ils ont été envoyés, mais avec un timing différent.  Dans le même temps, les paquets TCP alternent parfois et certains d'entre eux sont bloqués.  En particulier, si nous examinons les ports des paquets SYN, du côté émetteur, ils vont dans l'ordre, mais pas du côté destinataire. <br><br>  Il existe une différence subtile dans la façon dont <a href="https://en.wikipedia.org/wiki/Network_address_translation">les cartes réseau des</a> serveurs modernes (comme dans notre centre de données) traitent les paquets contenant TCP ou ICMP.  Lorsqu'un paquet arrive, l'adaptateur réseau «le hache sur la connexion», c'est-à-dire qu'il essaie de rompre les connexions à tour de rôle et d'envoyer chaque file d'attente à un cœur de processeur distinct.  Pour TCP, ce hachage comprend à la fois l'adresse IP source et de destination et le port.  En d'autres termes, chaque connexion est hachée (potentiellement) différemment.  Pour ICMP, seules les adresses IP sont hachées, car il n'y a pas de ports. <br><br>  Autre nouvelle observation: pendant cette période, nous constatons des retards ICMP sur toutes les communications entre les deux hôtes, mais pas TCP.  Cela nous indique que la raison est probablement due au hachage des files d'attente RX: il est presque certain que l'encombrement se produit dans le traitement des paquets RX, plutôt que dans l'envoi de réponses. <br><br>  Cela exclut l'envoi de paquets de la liste des raisons possibles.  Nous savons maintenant que le problème du traitement des paquets est du côté de la réception sur certains serveurs de nœuds de kube. <br><br><h1>  Comprendre le traitement des packages dans le noyau Linux </h1><br>  Pour comprendre pourquoi le problème se produit avec le destinataire sur certains serveurs de nœuds de cube, voyons comment le noyau Linux gère les packages. <br><br>  Revenant à l'implémentation traditionnelle la plus simple, la carte réseau reçoit le paquet et envoie une <a href="https://en.wikipedia.org/wiki/Interrupt">interruption</a> au noyau Linux, qui est le paquet qui doit être traité.  Le noyau arrête une autre opération, bascule le contexte vers le gestionnaire d'interruption, traite le package, puis revient aux tâches en cours. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a2/3c3/4ee/1a23c34eea2236294913fd09a25aa1e4.png"><br><br>  Ce changement de contexte est lent: il n'était peut-être pas perceptible sur les cartes réseau de 10 mégaoctets dans les années 1990, mais sur les cartes 10G modernes avec un débit maximal de 15 millions de paquets par seconde, chaque cœur d'un petit serveur à huit cœurs peut être interrompu des millions de fois par seconde. <br><br>  Afin de ne pas gérer constamment la gestion des interruptions, Linux a ajouté il y a de nombreuses années <a href="https://en.wikipedia.org/wiki/New_API">NAPI</a> : une API réseau que tous les pilotes modernes utilisent pour augmenter les performances à des vitesses élevées.  À basse vitesse, le noyau accepte toujours les interruptions de la carte réseau à l'ancienne.  Dès qu'un nombre suffisant de paquets arrive et dépasse le seuil, le noyau désactive les interruptions et commence à interroger la carte réseau et à prendre des paquets par lots.  Le traitement est effectué dans softirq, c'est-à-dire dans le <a href="https://www.kernel.org/doc/htmldocs/kernel-hacking/basics-softirqs.html">contexte des interruptions logicielles</a> après les appels système et des interruptions matérielles lorsque le noyau (contrairement à l'espace utilisateur) est déjà en cours d'exécution. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22a/50d/ee1/22a50dee1fffdbc20614db2b1db28fc4.png"><br><br>  C'est beaucoup plus rapide, mais cause un problème différent.  S'il y a trop de paquets, tout le temps qu'il faut pour traiter les paquets de la carte réseau et les processus de l'espace utilisateur n'ont pas le temps de vider réellement ces files d'attente (lecture à partir des connexions TCP, etc.).  À la fin, les files d'attente se remplissent et nous commençons à abandonner les paquets.  En essayant de trouver un équilibre, le noyau établit un budget pour le nombre maximum de paquets traités dans le contexte softirq.  Une fois ce budget dépassé, un thread <code>ksoftirqd</code> séparé <code>ksoftirqd</code> (vous en verrez un en <code>ps</code> pour chaque cœur), qui traite ces softirqs en dehors du chemin normal de syscall / interruption.  Ce thread est planifié à l'aide d'un planificateur de processus standard qui tente de répartir équitablement les ressources. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d0f/1e6/f0c/d0f1e6f0c54d45c24d62cb2bcf90c674.png"><br><br>  Après avoir examiné comment le noyau traite les paquets, vous pouvez voir qu'il existe une certaine probabilité de congestion.  Si les appels softirq sont reçus moins fréquemment, les paquets devront attendre un certain temps avant d'être traités dans la file d'attente RX de la carte réseau.  Cela est peut-être dû à une tâche bloquant le cœur du processeur, ou quelque chose d'autre empêche le noyau de démarrer softirq. <br><br><h1>  Nous limitons le traitement au noyau ou à la méthode </h1><br>  Les retards Softirq ne sont qu'une hypothèse.  Mais cela a du sens et nous savons que nous voyons quelque chose de très similaire.  Par conséquent, l'étape suivante consiste à confirmer cette théorie.  Et si cela est confirmé, trouvez la raison des retards. <br><br>  Retour à nos packages lents: <br><br> <code>len=46 ip=172.16.53.32 ttl=61 id=29573 icmp_seq=1953 rtt=99.3 ms <br> <br> len=46 ip=172.16.53.32 ttl=61 id=29574 icmp_seq=1954 rtt=89.3 ms <br> <br> len=46 ip=172.16.53.32 ttl=61 id=29575 icmp_seq=1955 rtt=79.2 ms <br> <br> len=46 ip=172.16.53.32 ttl=61 id=29576 icmp_seq=1956 rtt=69.1 ms <br> <br> len=46 ip=172.16.53.32 ttl=61 id=29577 icmp_seq=1957 rtt=59.1 ms <br> <br> len=46 ip=172.16.53.32 ttl=61 id=29790 icmp_seq=2070 rtt=75.7 ms <br> <br> len=46 ip=172.16.53.32 ttl=61 id=29791 icmp_seq=2071 rtt=65.6 ms <br> <br> len=46 ip=172.16.53.32 ttl=61 id=29792 icmp_seq=2072 rtt=55.5 ms</code> <br> <br>  Comme indiqué précédemment, ces paquets ICMP sont hachés dans une seule file d'attente NIC RX et traités par un seul cœur de processeur.  Si nous voulons comprendre comment fonctionne Linux, il est utile de savoir où (sur quel cœur de processeur) et comment (softirq, ksoftirqd) ces packages sont traités pour suivre le processus. <br><br>  Il est maintenant temps d'utiliser des outils qui permettent une surveillance en temps réel du noyau Linux.  Ici, nous avons utilisé <a href="https://github.com/iovisor/bcc">bcc</a> .  Cette boîte à outils vous permet d'écrire de petits programmes C qui interceptent des fonctions arbitraires dans le noyau et les événements de tampon dans un programme Python de l'espace utilisateur qui peut les traiter et vous renvoyer le résultat.  Les crochets pour les fonctions arbitraires dans le noyau sont complexes, mais l'utilitaire est conçu pour une sécurité maximale et est conçu pour suivre précisément ces problèmes de production qui ne sont pas faciles à reproduire dans un environnement de test ou de développement. <br><br>  Le plan ici est simple: nous savons que le noyau traite ces pings ICMP, donc nous <a href="">accrochons la fonction de</a> noyau <a href="">icmp_echo</a> , qui reçoit le paquet ICMP de demande d'écho entrant et initie l'envoi de la réponse ICMP de réponse d'écho.  Nous pouvons identifier le package en augmentant le nombre icmp_seq, qui montre <code>hping3</code> ci-dessus. <br><br>  Le code du <a href="https://gist.github.com/theojulienne/9d78a0cb68dbe56f19a2ae6316bc6846">script Cci</a> semble compliqué, mais il n'est pas aussi effrayant qu'il n'y paraît.  La fonction <code>icmp_echo</code> passe la <code>struct sk_buff *skb</code> : c'est le paquet avec la requête "echo request".  Nous pouvons le suivre, extraire la séquence <code>echo.sequence</code> (qui correspond à <code>icmp_seq</code> partir de hping3 <code></code> ) et l'envoyer à l'espace utilisateur.  Il est également pratique de capturer le nom / identificateur de processus actuel.  Voici les résultats que nous voyons directement lors du traitement des paquets par le noyau: <br><br><pre>  NOM DU PROCESSUS TGID PID ICMP_SEQ
 0 0 swapper / 11,770
 0 0 swapper / 11,771
 0 0 swapper / 11 772
 0 0 swapper / 11 773
 0 0 swapper / 11,774
 20041 20086 prometheus 775
 0 0 swapper / 11,776
 0 0 swapper / 11,777
 0 0 swapper / 11 778
 4512 4542 rayons-rapport-s 779 </pre><br>  Ici, il convient de noter que dans le contexte de <code>softirq</code> processus qui ont effectué des appels système apparaîtront comme des «processus», bien qu'en fait ce noyau traite en toute sécurité les paquets dans le contexte du noyau. <br><br>  Avec cet outil, nous pouvons établir la connexion de processus spécifiques avec des packages spécifiques qui montrent un retard dans <code>hping3</code> .  Nous faisons un simple <code>grep</code> sur cette capture pour des valeurs <code>icmp_seq</code> spécifiques.  Les paquets correspondant aux valeurs icmp_seq ci-dessus ont été marqués avec leur RTT, que nous avons observé ci-dessus (entre parenthèses sont les valeurs RTT attendues pour les paquets que nous avons filtrés en raison de valeurs RTT inférieures à 50 ms): <br><br><pre>  NOM DU PROCESSUS TGID PID ICMP_SEQ ** RTT
 -
 10137 10436 cadvisor 1951
 10137 10436 cadvisor 1952
 76 76 ksoftirqd / 11 1953 ** 99ms
 76 76 ksoftirqd / 11 1954 ** 89ms
 76 76 ksoftirqd / 11 1955 ** 79ms
 76 76 ksoftirqd / 11 1956 ** 69ms
 76 76 ksoftirqd / 11 1957 ** 59 ms
 76 76 ksoftirqd / 11 1958 ** (49 ms)
 76 76 ksoftirqd / 11 1959 ** (39 ms)
 76 76 ksoftirqd / 11 1960 ** (29 ms)
 76 76 ksoftirqd / 11 1961 ** (19 ms)
 76 76 ksoftirqd / 11 1962 ** (9 ms)
 -
 10137 10436 cadvisor 2068
 10137 10436 cadvisor 2069
 76 76 ksoftirqd / 11 2070 ** 75 ms
 76 76 ksoftirqd / 11 2071 ** 65ms
 76 76 ksoftirqd / 11 2072 ** 55 ms
 76 76 ksoftirqd / 11 2073 ** (45 ms)
 76 76 ksoftirqd / 11 2074 ** (35 ms)
 76 76 ksoftirqd / 11 2075 ** (25 ms)
 76 76 ksoftirqd / 11 2076 ** (15 ms)
 76 76 ksoftirqd / 11 2077 ** (5 ms) </pre><br>  Les résultats nous disent quelques choses.  Tout d'abord, le contexte <code>ksoftirqd/11</code> gère tous ces packages.  Cela signifie que pour cette paire particulière de machines, les paquets ICMP ont été hachés sur le cœur 11 à la réception.  Nous constatons également qu'à chaque embouteillage, des paquets sont traités dans le cadre de l' <code>cadvisor</code> système <code>cadvisor</code> .  Ensuite, <code>ksoftirqd</code> prend la tâche et remplit la file d'attente accumulée: exactement le nombre de paquets qui se sont accumulés après <code>cadvisor</code> . <br><br>  Le fait qu'un <code>cadvisor</code> travaille toujours juste avant cela implique son implication dans le problème.  Ironiquement, l'objectif de <a href="https://github.com/google/cadvisor">cadvisor</a> est «d'analyser l'utilisation des ressources et les caractéristiques de performance des conteneurs en cours d'exécution», plutôt que de causer ce problème de performance. <br><br>  Comme pour d'autres aspects de la manutention des conteneurs, ce sont tous des outils extrêmement avancés à partir desquels des problèmes de performances peuvent être attendus dans certaines circonstances imprévues. <br><br><h1>  Que fait cadvisor pour ralentir la file d'attente des paquets? </h1><br>  Maintenant, nous avons une assez bonne compréhension de la façon dont la panne se produit, quel processus la cause et sur quel processeur.  Nous voyons qu'en raison d'un verrouillage dur, le noyau Linux n'a pas le temps de planifier <code>ksoftirqd</code> .  Et nous voyons que les colis sont traités dans le cadre de <code>cadvisor</code> .  Il est logique de supposer que <code>cadvisor</code> démarre un appel système lent, après quoi tous les paquets accumulés à ce moment sont traités: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6fd/6fb/970/6fd6fb970f2d27943039910db9b41743.png"><br><br>  C'est une théorie, mais comment la tester?  Ce que nous pouvons faire, c'est suivre le fonctionnement du cœur de processeur tout au long de ce processus, trouver le point où le budget est dépassé par le nombre de paquets et ksoftirqd est appelé, puis regarder un peu plus tôt - ce qui fonctionnait exactement sur le cœur de processeur juste avant ce moment.  C'est comme une radiographie d'un CPU toutes les quelques millisecondes.  Cela ressemblera à ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/44a/954/6e8/44a9546e8de19e43cb125eb8a03a8f47.png"><br><br>  Idéalement, tout cela peut être fait avec les outils existants.  Par exemple, <a href="https://perf.wiki.kernel.org/index.php/Tutorial">perf record</a> vérifie le cœur de processeur spécifié avec la fréquence indiquée et peut générer un calendrier d'appels vers un système en cours d'exécution, y compris à la fois l'espace utilisateur et le noyau Linux.  Vous pouvez prendre cet enregistrement et le traiter à l'aide d'un petit fork du programme <a href="https://github.com/brendangregg/FlameGraph">FlameGraph</a> de Brendan Gregg, qui préserve l'ordre de trace de la pile.  Nous pouvons enregistrer des traces de pile sur une ligne toutes les 1 ms, puis sélectionner et enregistrer l'échantillon pendant 100 millisecondes avant que <code>ksoftirqd</code> dans la trace: <br><br> <code># record 999 times a second, or every 1ms with some offset so not to align exactly with timers <br> sudo perf record -C 11 -g -F 999 <br> # take that recording and make a simpler stack trace. <br> sudo perf script 2&gt;/dev/null | ./FlameGraph/stackcollapse-perf-ordered.pl | grep ksoftir -B 100</code> <br> <br>  Voici les résultats: <br><br> <code>( ,   ) <br> <br> cadvisor;[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];entry_SYSCALL_64_after_swapgs;do_syscall_64;sys_read;vfs_read;seq_read;memcg_stat_show;mem_cgroup_nr_lru_pages;mem_cgroup_node_nr_lru_pages cadvisor;[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];entry_SYSCALL_64_after_swapgs;do_syscall_64;sys_read;vfs_read;seq_read;memcg_stat_show;mem_cgroup_nr_lru_pages;mem_cgroup_node_nr_lru_pages cadvisor;[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];entry_SYSCALL_64_after_swapgs;do_syscall_64;sys_read;vfs_read;seq_read;memcg_stat_show;mem_cgroup_iter cadvisor;[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];entry_SYSCALL_64_after_swapgs;do_syscall_64;sys_read;vfs_read;seq_read;memcg_stat_show;mem_cgroup_nr_lru_pages;mem_cgroup_node_nr_lru_pages cadvisor;[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];[cadvisor];entry_SYSCALL_64_after_swapgs;do_syscall_64;sys_read;vfs_read;seq_read;memcg_stat_show;mem_cgroup_nr_lru_pages;mem_cgroup_node_nr_lru_pages ksoftirqd/11;ret_from_fork;kthread;kthread;smpboot_thread_fn;smpboot_thread_fn;run_ksoftirqd;__do_softirq;net_rx_action;ixgbe_poll;ixgbe_clean_rx_irq;napi_gro_receive;netif_receive_skb_internal;inet_gro_receive;bond_handle_frame;__netif_receive_skb_core;ip_rcv_finish;ip_rcv;ip_forward_finish;ip_forward;ip_finish_output;nf_iterate;ip_output;ip_finish_output2;__dev_queue_xmit;dev_hard_start_xmit;ipip_tunnel_xmit;ip_tunnel_xmit;iptunnel_xmit;ip_local_out;dst_output;__ip_local_out;nf_hook_slow;nf_iterate;nf_conntrack_in;generic_packet;ipt_do_table;set_match_v4;ip_set_test;hash_net4_kadt;ixgbe_xmit_frame_ring;swiotlb_dma_mapping_error;hash_net4_test ksoftirqd/11;ret_from_fork;kthread;kthread;smpboot_thread_fn;smpboot_thread_fn;run_ksoftirqd;__do_softirq;net_rx_action;gro_cell_poll;napi_gro_receive;netif_receive_skb_internal;inet_gro_receive;__netif_receive_skb_core;ip_rcv_finish;ip_rcv;ip_forward_finish;ip_forward;ip_finish_output;nf_iterate;ip_output;ip_finish_output2;__dev_queue_xmit;dev_hard_start_xmit;dev_queue_xmit_nit;packet_rcv;tpacket_rcv;sch_direct_xmit;validate_xmit_skb_list;validate_xmit_skb;netif_skb_features;ixgbe_xmit_frame_ring;swiotlb_dma_mapping_error;__dev_queue_xmit;dev_hard_start_xmit;__bpf_prog_run;__bpf_prog_run</code> <br> <br>  Il y a beaucoup de choses ici, mais l'essentiel est que nous trouvions le modèle «cadvisor avant ksoftirqd» que nous avons vu plus tôt dans le traceur ICMP.  Qu'est-ce que cela signifie? <br><br>  Chaque ligne est une trace du CPU à un moment donné.  Chaque appel sur la pile d'une ligne est séparé par un point-virgule.  Au milieu des lignes, nous voyons syscall appelé: <code>read(): .... ;do_syscall_64;sys_read; ...</code>  <code>read(): .... ;do_syscall_64;sys_read; ...</code>  Ainsi, cadvisor passe beaucoup de temps sur l'appel système <code>read()</code> lié aux fonctions <code>mem_cgroup_*</code> (haut de la pile d'appels / fin de ligne). <br><br>  Dans la trace des appels, il n'est pas pratique de voir exactement ce qui est lu, alors exécutez <code>strace</code> et voyez ce que fait cadvisor, et recherchez les appels système de plus de 100 ms: <br><br> <code>theojulienne@kube-node-bad ~ $ sudo strace -p 10137 -T -ff 2&gt;&amp;1 | egrep '&lt;0\.[1-9]' <br> [pid 10436] &lt;... futex resumed&gt; ) = 0 &lt;0.156784&gt; <br> [pid 10432] &lt;... futex resumed&gt; ) = 0 &lt;0.258285&gt; <br> [pid 10137] &lt;... futex resumed&gt; ) = 0 &lt;0.678382&gt; <br> [pid 10384] &lt;... futex resumed&gt; ) = 0 &lt;0.762328&gt; <br> [pid 10436] &lt;... read resumed&gt; "cache 154234880\nrss 507904\nrss_h"..., 4096) = 658 &lt;0.179438&gt; <br> [pid 10384] &lt;... futex resumed&gt; ) = 0 &lt;0.104614&gt; <br> [pid 10436] &lt;... futex resumed&gt; ) = 0 &lt;0.175936&gt; <br> [pid 10436] &lt;... read resumed&gt; "cache 0\nrss 0\nrss_huge 0\nmapped_"..., 4096) = 577 &lt;0.228091&gt; <br> [pid 10427] &lt;... read resumed&gt; "cache 0\nrss 0\nrss_huge 0\nmapped_"..., 4096) = 577 &lt;0.207334&gt; <br> [pid 10411] &lt;... epoll_ctl resumed&gt; ) = 0 &lt;0.118113&gt; <br> [pid 10382] &lt;... pselect6 resumed&gt; ) = 0 (Timeout) &lt;0.117717&gt; <br> [pid 10436] &lt;... read resumed&gt; "cache 154234880\nrss 507904\nrss_h"..., 4096) = 660 &lt;0.159891&gt; <br> [pid 10417] &lt;... futex resumed&gt; ) = 0 &lt;0.917495&gt; <br> [pid 10436] &lt;... futex resumed&gt; ) = 0 &lt;0.208172&gt; <br> [pid 10417] &lt;... futex resumed&gt; ) = 0 &lt;0.190763&gt; <br> [pid 10417] &lt;... read resumed&gt; "cache 0\nrss 0\nrss_huge 0\nmapped_"..., 4096) = 576 &lt;0.154442&gt;</code> <br> <br>  Comme vous pouvez vous y attendre, nous voyons ici des appels <code>read()</code> .  Du contenu des opérations de lecture et du contexte <code>mem_cgroup</code> , <code>mem_cgroup</code> peut voir que ces appels <code>read()</code> réfèrent au fichier <code>memory.stat</code> , qui montre l'utilisation de la mémoire et les limitations de cgroup (technologie d'isolation des ressources Docker).  L'outil cadvisor interroge ce fichier pour obtenir des informations sur l'utilisation des ressources pour les conteneurs.  Vérifions si ce noyau ou ce conseiller fait quelque chose d'inattendu: <br><br> <code>theojulienne@kube-node-bad ~ $ time cat /sys/fs/cgroup/memory/memory.stat &gt;/dev/null <br> <br> real 0m0.153s <br> user 0m0.000s <br> sys 0m0.152s <br> theojulienne@kube-node-bad ~ $</code> <br> <br>  Nous pouvons maintenant reproduire le bogue et comprendre que le noyau Linux est confronté à une pathologie. <br><br><h1>  Qu'est-ce qui rend la lecture si lente? </h1><br>  À ce stade, il est beaucoup plus facile de trouver des messages d'autres utilisateurs sur des problèmes similaires.  Il s'est avéré que dans le tracker cadvisor, ce bogue a été signalé comme un <a href="https://github.com/google/cadvisor/issues/1774">problème d'utilisation excessive du processeur</a> , personne n'a remarqué que le retard était également reflété de manière aléatoire dans la pile du réseau.  En effet, il a été remarqué que cadvisor consomme plus de temps processeur que prévu, mais cela n'a pas été accordé beaucoup d'importance, car nos serveurs ont beaucoup de ressources processeur, nous n'avons donc pas étudié attentivement le problème. <br><br>  Le problème est que les groupes de contrôle (cgroups) prennent en compte l'utilisation de la mémoire à l'intérieur de l'espace de noms (conteneur).  Lorsque tous les processus de ce groupe de contrôle se terminent, Docker libère un groupe de contrôle de mémoire.  Cependant, la «mémoire» n'est pas seulement une mémoire de processus.  Bien que la mémoire de processus elle-même ne soit plus utilisée, il s'avère que le noyau attribue également du contenu mis en cache, comme des denteries et des inodes (métadonnées de répertoire et de fichier), qui sont mis en cache dans le groupe de mémoire.  D'après la description du problème: <br><br><blockquote>  cgroups zombies: groupes de contrôle dans lesquels il n'y a pas de processus et ils sont supprimés, mais pour lesquels la mémoire est toujours allouée (dans mon cas, à partir du cache dentry, mais elle peut également être allouée à partir du cache de page ou tmpfs). </blockquote><br>  Le noyau vérifiant toutes les pages du cache lorsque cgroup est libéré peut être très lent, donc le processus paresseux est choisi: attendez que ces pages soient à nouveau demandées, et même lorsque la mémoire est vraiment nécessaire, effacez finalement cgroup.  Jusqu'à présent, cgroup est toujours pris en compte lors de la collecte des statistiques. <br><br>  En termes de performances, ils ont sacrifié la mémoire pour les performances: accélérant le nettoyage initial en raison du fait qu'il reste un peu de mémoire en cache.  C'est normal.  Lorsque le noyau utilise la dernière partie de la mémoire cache, cgroup est finalement effacé, donc cela ne peut pas être appelé une «fuite».  Malheureusement, l'implémentation spécifique du moteur de recherche <code>memory.stat</code> dans cette version du noyau (4.9), combinée à l'énorme quantité de mémoire sur nos serveurs, conduit au fait qu'il faut beaucoup plus de temps pour restaurer les dernières données mises en cache et effacer les zombies de groupe de contrôle. <br><br>  Il s'avère qu'il y avait tellement de zombies de groupes de contrôle sur certains de nos nœuds que la lecture et la latence ont dépassé une seconde. <br><br>  Une solution de contournement pour le problème du conseiller consiste à effacer immédiatement les caches dentiers / inodes dans tout le système, ce qui élimine immédiatement la latence de lecture ainsi que la latence du réseau sur l'hôte, car la suppression du cache inclut les pages mises en cache par zombies cgroup, et elles sont également libérées.  Ce n'est pas une solution, mais confirme la cause du problème. <br><br>  Il s'est avéré que les versions plus récentes du noyau (4.19+) amélioraient les performances de l'appel <code>memory.stat</code> , donc le passage à ce noyau a résolu le problème.  Dans le même temps, nous avions des outils pour détecter les nœuds problématiques dans les clusters Kubernetes, les vidanger avec élégance et redémarrer.  Nous avons parcouru tous les clusters, trouvé les nœuds avec un retard suffisamment élevé et les avons redémarrés.  Cela nous a donné le temps de mettre à jour le système d'exploitation sur le reste des serveurs. <br><br><h1>  Pour résumer </h1><br>  Étant donné que ce bogue a arrêté le traitement des files d'attente NIC RX pendant des centaines de millisecondes, il a simultanément provoqué un retard important sur les connexions courtes et un retard au milieu de la connexion, par exemple, entre les requêtes MySQL et les paquets de réponse. <br><br>       ,   Kubernetes,            .    Kubernetes    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477390/">https://habr.com/ru/post/fr477390/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477378/index.html">Agile mixte - approche Waterfall lors de la mise en œuvre d'applications métier (aka Agile-like)</a></li>
<li><a href="../fr477382/index.html">Esports - faire du profit: Mercedes, mégaphone, paris et image de marque pour les esports</a></li>
<li><a href="../fr477384/index.html">Conférence «Sécurité de l'information. Menaces du présent et du futur »</a></li>
<li><a href="../fr477386/index.html">Semaine de sécurité 48: fuite de données gigantesque et vulnérabilité dans Whatsapp</a></li>
<li><a href="../fr477388/index.html">NILFS2 - système de fichiers pare-balles pour / home</a></li>
<li><a href="../fr477392/index.html">Microphone ouvert: backend. Nous invitons des conférenciers</a></li>
<li><a href="../fr477396/index.html">Comment s'inscrire à un cours et ... aller jusqu'au bout</a></li>
<li><a href="../fr477400/index.html">A propos du métier de chef de produit: comment atteindre l'idéal?</a></li>
<li><a href="../fr477402/index.html">Déploiement du modèle Keras Deep Learning en tant qu'application Web Python</a></li>
<li><a href="../fr477404/index.html">Le problème de la création et de la suppression fréquentes d'objets en C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>