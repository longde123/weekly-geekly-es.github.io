<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüç≥ üçÑ üìπ Node.js-Handbuch, Teil 8: HTTP- und WebSocket-Protokolle „ÄΩÔ∏è üé∫ üëéüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Node.js ist eine Serverplattform. Die Hauptaufgabe des Servers besteht darin, Anforderungen von Clients, insbesondere von Browsern, so schnell und eff...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js-Handbuch, Teil 8: HTTP- und WebSocket-Protokolle</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424557/">  Node.js ist eine Serverplattform.  Die Hauptaufgabe des Servers besteht darin, Anforderungen von Clients, insbesondere von Browsern, so schnell und effizient wie m√∂glich zu verarbeiten.  Der achte Teil der √úbersetzung des Node.js-Tutorials, das wir heute ver√∂ffentlichen, befasst sich mit HTTP und WebSocket. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Wir empfehlen Ihnen zu lesen] Andere Teile des Zyklus</b> <div class="spoiler_text">  Teil 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine Informationen und erste Schritte</a> <br>  Teil 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript, V8, einige Entwicklungstricks</a> <br>  Teil 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hosting, REPL, Arbeit mit der Konsole, Module</a> <br>  Teil 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dateien npm, package.json und package-lock.json</a> <br>  Teil 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">npm und npx</a> <br>  Teil 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisschleife, Aufrufstapel, Timer</a> <br>  Teil 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchrone Programmierung</a> <br>  Teil 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 8: HTTP- und WebSocket-Protokolle</a> <br>  Teil 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 9: Arbeiten mit dem Dateisystem</a> <br>  Teil 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 10: Standardmodule, Streams, Datenbanken, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollst√§ndiges PDF des Node.js-Handbuchs</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Was passiert bei HTTP-Anfragen?</font> </h2><br>  Lassen Sie uns dar√ºber sprechen, wie Browser mithilfe des HTTP / 1.1-Protokolls Anforderungen an Server stellen. <br><br>  Wenn Sie jemals ein Interview im IT-Bereich gef√ºhrt haben, werden Sie m√∂glicherweise gefragt, was passiert, wenn Sie etwas in die Adressleiste Ihres Browsers eingeben und die Eingabetaste dr√ºcken.  Vielleicht ist dies eine der beliebtesten Fragen, die bei solchen Interviews auftreten.  Jeder, der solche Fragen stellt, m√∂chte wissen, ob Sie einige ziemlich einfache Konzepte erkl√§ren und herausfinden k√∂nnen, ob Sie die Prinzipien des Internets verstehen. <br><br>  Diese Frage ber√ºhrt viele Technologien, um die allgemeinen Prinzipien zu verstehen, die bedeuten, zu verstehen, wie eines der komplexesten Systeme gebaut wird, die jemals von der Menschheit gebaut wurden und das die ganze Welt abdeckt. <br><br><h3>  <font color="#3AC1EF">‚ñç HTTP-Protokoll</font> </h3><br>  Moderne Browser k√∂nnen echte URLs, die in ihre Adressleiste eingegeben wurden, von Suchanfragen unterscheiden, f√ºr deren Verarbeitung normalerweise die Standardsuchmaschine verwendet wird.  Wir werden √ºber URLs sprechen.  Wenn Sie eine Website-Adresse wie <code>flaviocopes.com</code> in die <code>flaviocopes.com</code> , konvertiert der Browser diese Adresse in die Form <code>http://flaviocopes.com</code> , basierend auf der Annahme, dass das HTTP-Protokoll zum Datenaustausch mit der angegebenen Ressource verwendet wird.  Bitte beachten Sie, dass unter Windows das, wor√ºber wir hier sprechen, m√∂glicherweise etwas anders aussieht als unter MacOS und Linux. <br><br><h3>  <font color="#3AC1EF">‚ñç DNS-Suchphase</font> </h3><br>  Der Browser beginnt mit dem Herunterladen von Daten von der von den Benutzern angeforderten Adresse und f√ºhrt die DNS-Suchoperation (DNS-Suche) aus, um die IP-Adresse des entsprechenden Servers zu ermitteln.  Die symbolischen Namen der in die Adressleiste eingegebenen Ressourcen sind f√ºr Personen praktisch. Das Internetger√§t bietet jedoch die M√∂glichkeit, Daten zwischen Computern mithilfe von IP-Adressen auszutauschen, bei denen es sich um Nummerns√§tze wie 222.324.3.1 (f√ºr IPv4) handelt. <br><br>  Um die IP-Adresse des Servers herauszufinden, √ºberpr√ºft der Browser zun√§chst den lokalen DNS-Cache, um festzustellen, ob k√ºrzlich ein √§hnliches Verfahren durchgef√ºhrt wurde.  Im Chrome-Browser gibt es beispielsweise eine bequeme M√∂glichkeit, den DNS-Cache anzuzeigen, indem Sie die folgende Adresse in die Adressleiste eingeben: <code>chrome://net-internals/#dns</code> . <br><br>  Wenn im Cache nichts gefunden werden kann, ermittelt der Browser mithilfe des POSIX- <code>gethostbyname</code> die IP-Adresse des Servers. <br><br><h3>  <font color="#3AC1EF">‚ñç Funktion gethostbyname</font> </h3><br>  Die Funktion <code>gethostbyname</code> √ºberpr√ºft zun√§chst die <code>hosts</code> , die sich unter macOS oder Linux unter <code>/etc/hosts</code> , um herauszufinden, ob lokale Informationen durch Ermitteln der Serveradresse ermittelt werden k√∂nnen. <br><br>  Wenn local Mittel zum Aufl√∂sen der Anforderung zum Ermitteln der IP-Adresse des Servers fehlschl√§gt, f√ºhrt das System eine Anforderung an den DNS-Server durch.  Die Adressen solcher Server werden in den Systemeinstellungen gespeichert. <br><br>  Hier sind einige beliebte DNS-Server: <br><br><ul><li>  8.8.8.8: Google DNS-Server. </li><li>  1.1.1.1: CloudFlare-DNS-Server. </li></ul><br>  Die meisten Benutzer verwenden die von ihren Anbietern bereitgestellten DNS-Server.  Der Browser f√ºhrt DNS-Abfragen mit dem UDP-Protokoll durch. <br><br>  TCP und UDP sind zwei grundlegende Protokolle, die in Computernetzwerken verwendet werden.  Sie befinden sich auf derselben konzeptionellen Ebene, aber TCP ist ein verbindungsorientiertes Protokoll. F√ºr den Austausch von UDP-Nachrichten, deren Verarbeitung das System geringf√ºgig zus√§tzlich belastet, ist kein Verbindungsaufbau erforderlich.  Wir werden nicht genau dar√ºber sprechen, wie Daten √ºber UDP ausgetauscht werden. <br><br>  Die IP-Adresse, die dem f√ºr uns interessanten Domainnamen entspricht, befindet sich m√∂glicherweise im Cache des DNS-Servers.  Ist dies nicht der Fall, wird er den DNS-Stammserver kontaktieren.  Das Root-DNS-Serversystem besteht aus 13 Servern, von denen der Betrieb des gesamten Internets abh√§ngt. <br><br>  Es ist zu beachten, dass der DNS-Stammserver die Korrespondenz zwischen allen vorhandenen Dom√§nennamen und IP-Adressen in der Welt nicht kennt.  √Ñhnliche Server kennen jedoch die Adressen von DNS-Servern der obersten Ebene f√ºr Dom√§nen wie .com, .it, .pizza usw. <br><br>  Nach Erhalt der Anforderung leitet der Root-DNS-Server diese an den DNS-Server der Top-Level-Domain weiter, an den sogenannten TLD-Server (von der Top-Level-Domain). <br><br>  Angenommen, der Browser sucht nach der IP-Adresse f√ºr den <code>flaviocopes.com</code> Server.  Wenn Sie sich an den DNS-Stammserver wenden, erh√§lt der Browser von ihm die TLD-Serveradresse f√ºr die .com-Zone.  Jetzt wird diese Adresse im Cache gespeichert. Wenn Sie also die IP-Adresse einer anderen URL aus der .com-Zone herausfinden m√ºssen, m√ºssen Sie den DNS-Stammserver nicht erneut kontaktieren. <br><br>  TLD-Server haben IP-Adressen von Nameservern (Name Server, NS), mit deren Hilfe Sie die IP-Adresse anhand der uns vorliegenden URL ermitteln k√∂nnen.  Woher erh√§lt der NS-Server diese Informationen?  Tatsache ist, dass der Domain-Registrar beim Kauf einer Domain Daten dar√ºber an die Nameserver sendet.  Ein √§hnliches Verfahren wird beispielsweise beim √Ñndern des Hostings durchgef√ºhrt. <br><br>  Die betreffenden Server geh√∂ren normalerweise Hosting-Anbietern.  Zum Schutz vor Ausf√§llen werden in der Regel mehrere solcher Server erstellt.  Beispielsweise k√∂nnen sie folgende Adressen haben: <br><br><ul><li>  ns1.dreamhost.com </li><li>  ns2.dreamhost.com </li><li>  ns3.dreamhost.com </li></ul><br>  Um die IP-Adresse anhand der URL herauszufinden, wenden sie sich am Ende an solche Server.  Sie speichern die tats√§chlichen Daten zu IP-Adressen. <br><br>  Nachdem wir nun die IP-Adresse hinter der in der Adressleiste des Browsers eingegebenen URL ermittelt haben, fahren wir mit dem n√§chsten Schritt unserer Arbeit fort. <br><br><h3>  <font color="#3AC1EF">‚ñç Herstellen einer TCP-Verbindung</font> </h3><br>  Nachdem der Client die IP-Adresse des Servers gelernt hat, kann er eine TCP-Verbindung zu ihm herstellen.  Beim Aufbau einer TCP-Verbindung √ºbertragen Client und Server einige Servicedaten aneinander, wonach sie Informationen austauschen k√∂nnen.  Dies bedeutet, dass der Client nach dem Herstellen der Verbindung eine Anforderung an den Server senden kann. <br><br><h3>  <font color="#3AC1EF">‚ñçAnforderung senden</font> </h3><br>  Eine Anfrage ist ein Textfragment, das gem√§√ü den Regeln des verwendeten Protokolls strukturiert ist.  Es besteht aus drei Teilen: <br><br><ul><li>  Abfragezeichenfolge </li><li>  Header anfordern. </li><li>  Text anfordern. </li></ul><br><h4>  Abfragezeichenfolge </h4><br>  Die Abfragezeichenfolge ist eine einzelne Textzeichenfolge, die die folgenden Informationen enth√§lt: <br><br><ul><li>  HTTP-Methode. </li><li>  Ressourcenadresse </li><li>  Protokollversion. </li></ul><br>  Es k√∂nnte zum Beispiel so aussehen: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> / HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span></code> </pre> <br><h4>  Header anfordern </h4><br>  Der Anforderungsheader wird durch eine Reihe von <code>: </code> .  Es sind 2 Headerfelder erforderlich, von denen eines <code>Host</code> und das zweite <code>Connection</code> .  Die restlichen Felder sind optional. <br><br>  Der Titel k√∂nnte folgenderma√üen aussehen: <br><br><pre> <code class="hljs pgsql">Host: flaviocopes.com <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">close</span></span></code> </pre> <br>  Das Feld <code>Host</code> gibt den Domainnamen an, an dem der Browser interessiert ist.  Das auf <code>close</code> gesetzte Feld Verbindung bedeutet, dass die Verbindung zwischen Client und Server nicht offen gehalten werden muss. <br><br>  Andere h√§ufig verwendete Anforderungsheader umfassen Folgendes: <br><br><ul><li> <code>Origin</code> </li> <li> <code>Accept</code> </li> <li> <code>Accept-Encoding</code> </li> <li> <code>Cookie</code> </li> <li> <code>Cache-Control</code> </li> <li> <code>Dnt</code> </li> </ul><br>  In der Tat gibt es noch viel mehr. <br><br>  Der Anforderungsheader endet mit einer leeren Zeichenfolge. <br><br><h4>  Text anfordern </h4><br>  Der Anforderungshauptteil ist optional und wird in GET-Anforderungen nicht verwendet.  Der Anforderungshauptteil wird sowohl in POST-Anforderungen als auch in anderen Anforderungen verwendet.  Es kann beispielsweise Daten im JSON-Format enthalten. <br><br>  Da es sich jetzt um eine GET-Anfrage handelt, ist der Anfragetext leer und wir werden nicht damit arbeiten. <br><br><h3>  <font color="#3AC1EF">‚ñç Antwort</font> </h3><br>  Nachdem der Server die vom Client gesendete Anforderung empfangen hat, verarbeitet er sie und sendet eine Antwort an den Client. <br><br>  Die Antwort beginnt mit einem Statuscode und einer entsprechenden Nachricht.  Wenn die Anforderung erfolgreich ist, sieht der Beginn der Antwort folgenderma√üen aus: <br><br><pre> <code class="hljs">200 OK</code> </pre> <br>  Wenn etwas schief gelaufen ist, gibt es m√∂glicherweise andere Codes.  Zum Beispiel Folgendes: <br><br><ul><li> <code>404 Not Found</code> </li> <li> <code>403 Forbidden</code> </li> <li> <code>301 Moved Permanently</code> </li> <li> <code>500 Internal Server Error</code> </li> <li> <code>304 Not Modified</code> </li> <li> <code>401 Unauthorized</code> </li> </ul><br>  Ferner enth√§lt die Antwort eine Liste von HTTP-Headern und den Hauptteil der Antwort (die, da die Anforderung vom Browser ausgef√ºhrt wird, HTML-Code ist). <br><br><h4>  HTML-Analyse </h4><br>  Nachdem der Browser die Antwort des Servers erhalten hat, dessen Hauptteil HTML-Code enth√§lt, beginnt er mit dem Parsen und wiederholt den obigen Vorgang f√ºr jede Ressource, die zum Erstellen der Seite ben√∂tigt wird.  Zu diesen Ressourcen geh√∂ren beispielsweise die folgenden: <br><br><ul><li>  CSS-Dateien. </li><li>  Bilder </li><li>  Webseiten-Symbol (Favicon). </li><li>  JavaScript-Dateien. </li></ul><br>  Wie genau der Browser die Seite anzeigt, gilt nicht f√ºr unsere Konversation.  Das Wichtigste, was uns hier interessiert, ist, dass der oben beschriebene Prozess zum Anfordern und Empfangen von Daten nicht nur f√ºr HTML-Code verwendet wird, sondern auch f√ºr alle anderen Objekte, die mithilfe des HTTP-Protokolls vom Server an den Browser √ºbertragen werden. <br><br><h2>  <font color="#3AC1EF">Informationen zum Erstellen eines einfachen Servers mit Node.js.</font> </h2><br>  Nachdem wir den Prozess der Interaktion zwischen dem Browser und dem Server untersucht haben, k√∂nnen Sie einen neuen Blick auf den Anwendungsabschnitt First Node.js aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil</a> dieser Materialreihe werfen, in dem wir den Code f√ºr einen einfachen Server beschrieben haben. <br><br><h2>  <font color="#3AC1EF">HTTP-Anfragen mit Node.js stellen</font> </h2><br>  Um HTTP-Anforderungen mit Node.js auszuf√ºhren, wird das entsprechende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://nodejs.org/api/">Modul verwendet</a> .  In den folgenden Beispielen wird das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://nodejs.org/api/">https-</a> Modul verwendet.  Tatsache ist, dass unter modernen Bedingungen, wann immer m√∂glich, das HTTPS-Protokoll verwendet werden muss. <br><br><h3>  <font color="#3AC1EF">‚ñç Ausf√ºhren von GET-Anforderungen</font> </h3><br>  Hier ist ein Beispiel f√ºr die Ausf√ºhrung einer GET-Anforderung mit Node.js: <br><br><pre> <code class="hljs coffeescript">const https = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) const options = { hostname: <span class="hljs-string"><span class="hljs-string">'flaviocopes.com'</span></span>, port: <span class="hljs-number"><span class="hljs-number">443</span></span>, path: <span class="hljs-string"><span class="hljs-string">'/todos'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'GET'</span></span> } const req = https.request(options, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">statusCode: ${res.statusCode}</span></span>`) res.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   process.stdout.write(d) }) }) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) }) req.end()</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçPOST-Anforderungsausf√ºhrung</font> </h3><br>  So stellen Sie eine POST-Anfrage von Node.js: <br><br><pre> <code class="hljs coffeescript">const https = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) const data = JSON.stringify({ todo: <span class="hljs-string"><span class="hljs-string">'Buy the milk'</span></span> }) const options = { hostname: <span class="hljs-string"><span class="hljs-string">'flaviocopes.com'</span></span>, port: <span class="hljs-number"><span class="hljs-number">443</span></span>, path: <span class="hljs-string"><span class="hljs-string">'/todos'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, headers: {   <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>,   <span class="hljs-string"><span class="hljs-string">'Content-Length'</span></span>: data.length } } const req = https.request(options, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">statusCode: ${res.statusCode}</span></span>`) res.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   process.stdout.write(d) }) }) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) }) req.write(data) req.end()</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçPUT- und DELETE-Abfragen</font> </h3><br>  Die Ausf√ºhrung solcher Anforderungen sieht genauso aus wie die Ausf√ºhrung von POST-Anforderungen.  Der Hauptunterschied ist neben dem semantischen Inhalt solcher Operationen der Wert der <code>method</code> Eigenschaft des <code>options</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç Ausf√ºhren von HTTP-Anforderungen in Node.js mithilfe der Axios-Bibliothek</font> </h3><br>  Axios ist eine sehr beliebte JavaScript-Bibliothek, die sowohl im Browser (dies schlie√üt alle modernen Browser und im Internet Explorer ab IE8 ein) als auch in der Node.js-Umgebung funktioniert, mit der HTTP-Anforderungen ausgef√ºhrt werden k√∂nnen. <br><br>  Diese Bibliothek basiert auf Versprechungen und hat einige Vorteile gegen√ºber Standardmechanismen, insbesondere gegen√ºber API Fetch.  Zu seinen Vorteilen geh√∂ren: <br><br><ul><li>  Unterst√ºtzung f√ºr √§ltere Browser (Sie ben√∂tigen eine Polyf√ºllung, um Fetch verwenden zu k√∂nnen). </li><li>  M√∂glichkeit, Anfragen zu unterbrechen. </li><li>  Unterst√ºtzung f√ºr das Festlegen von Zeit√ºberschreitungen f√ºr Anforderungen. </li><li>  Eingebauter Schutz gegen CSRF-Angriffe. </li><li>  Unterst√ºtzung beim Hochladen von Daten durch Bereitstellung von Informationen zum Fortschritt dieses Prozesses. </li><li>  Unterst√ºtzung f√ºr die JSON-Datenkonvertierung. </li><li>  Jobs bei Node.js. </li></ul><br><h4>  Installation </h4><br>  Sie k√∂nnen Axios mit npm installieren: <br><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> axios</code> </pre> <br>  Der gleiche Effekt kann mit Garn erzielt werden: <br><br><pre> <code class="hljs cs">yarn <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> axios</code> </pre> <br>  Sie k√∂nnen die Bibliothek √ºber <code>unpkg.com</code> mit der Seite <code>unpkg.com</code> : <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://unpkg.com/axios/dist/axios.min.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h4>  Axios API </h4><br>  Sie k√∂nnen eine HTTP-Anfrage mit dem <code>axios</code> Objekt stellen: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">axios</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">url</span></span>: <span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'get'</span></span>, data: {   foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> } })</code> </pre> <br>  In der Regel ist es jedoch bequemer, spezielle Methoden anzuwenden: <br><br><ul><li> <code>axios.get()</code> </li> <li> <code>axios.post()</code> </li> </ul><br>  Dies √§hnelt der Verwendung von <code>$.get()</code> und <code>$.post()</code> jQuery anstelle von <code>$.ajax()</code> <code>$.post()</code> . <br><br>  Axios bietet separate Methoden zum Ausf√ºhren anderer Arten von HTTP-Anforderungen, die nicht so beliebt sind wie GET und POST, aber dennoch verwendet werden: <br><br><ul><li> <code>axios.delete()</code> </li> <li> <code>axios.put()</code> </li> <li> <code>axios.patch()</code> </li> <li> <code>axios.options()</code> </li> </ul><br>  Die Bibliothek verf√ºgt √ºber eine Methode zum Ausf√ºhren einer Anforderung, die nur HTTP-Header ohne Antworttext empfangen soll: <br><br><ul><li> <code>axios.head()</code> </li> </ul><br><h4>  GET-Anfragen </h4><br>  Axios ist bequem mit der modernen Async / Wait-Syntax zu verwenden.  Das folgende Codebeispiel, das f√ºr Node.js entwickelt wurde, verwendet die Bibliothek, um eine Liste von Hunderassen aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Hunde-API</a> zu laden.  Hier wird die Methode <code>axios.get()</code> angewendet und die Steine ‚Äã‚Äãgez√§hlt: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> axios = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'axios'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> countBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> breeds = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getBreeds() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (breeds.data.message) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Got </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Object</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.entries(breeds.data.message).length}</span></span></span><span class="hljs-string"> breeds`</span></span>) } } countBreeds()</code> </pre> <br>  Dasselbe kann ohne Verwendung von async / await umgeschrieben werden, wobei Versprechen angewendet werden: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> axios = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'axios'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getBreeds = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> countBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> breeds = getBreeds()   .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.data.message) {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(         <span class="hljs-string"><span class="hljs-string">`Got </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Object</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.entries(response.data.message).length}</span></span></span><span class="hljs-string"> breeds`</span></span>       )     }   })   .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error)   }) } countBreeds()</code> </pre> <br><h4>  Verwenden von Parametern in GET-Anforderungen </h4><br>  Eine GET-Anforderung kann Parameter enthalten, die in einer URL folgenderma√üen aussehen: <br><br><pre> <code class="hljs objectivec">https:<span class="hljs-comment"><span class="hljs-comment">//site.com/?foo=bar</span></span></code> </pre> <br>  Bei Verwendung von Axios kann eine solche Abfrage folgenderma√üen durchgef√ºhrt werden: <br><br><pre> <code class="hljs swift">axios.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>('https:<span class="hljs-comment"><span class="hljs-comment">//site.com/?foo=bar')</span></span></code> </pre> <br>  Der gleiche Effekt kann erzielt werden, indem die Eigenschaft <code>params</code> in einem Objekt mit folgenden Parametern festgelegt wird: <br><br><pre> <code class="hljs cs">axios.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'https://site.com/'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>: {   foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> } })</code> </pre> <br><h4>  POST-Anfragen </h4><br>  Das Ausf√ºhren von POST-Anforderungen ist dem Ausf√ºhren von GET-Anforderungen sehr √§hnlich, aber hier wird anstelle der <code>axios.get()</code> -Methode die <code>axios.post()</code> -Methode verwendet: <br><br><pre> <code class="hljs scala">axios.post(<span class="hljs-symbol"><span class="hljs-symbol">'https</span></span>:<span class="hljs-comment"><span class="hljs-comment">//site.com/')</span></span></code> </pre> <br>  Als zweites Argument akzeptiert die <code>post</code> Methode ein Objekt mit Anforderungsparametern: <br><br><pre> <code class="hljs cs">axios.post(<span class="hljs-string"><span class="hljs-string">'https://site.com/'</span></span>, { foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> })</code> </pre> <br><h2>  <font color="#3AC1EF">Verwenden des WebSocket-Protokolls in Node.js.</font> </h2><br>  WebSocket ist eine Alternative zu HTTP und kann zum Organisieren des Datenaustauschs in Webanwendungen verwendet werden.  Mit diesem Protokoll k√∂nnen Sie langlebige bidirektionale Kommunikationskan√§le zwischen Client und Server erstellen.  Nach dem Herstellen der Verbindung bleibt der Kommunikationskanal offen, wodurch die Anwendung √ºber eine sehr schnelle Verbindung verf√ºgt, die durch geringe Latenzen und eine geringe zus√§tzliche Belastung des Systems gekennzeichnet ist. <br><br>  Das WebSocket-Protokoll wird von allen modernen Browsern unterst√ºtzt. <br><br><h3>  <font color="#3AC1EF">‚ñç HTTP-Unterschiede</font> </h3><br>  HTTP und WebSocket sind sehr unterschiedliche Protokolle, die unterschiedliche Ans√§tze f√ºr den Datenaustausch verwenden.  HTTP basiert auf dem "Request-Response" -Modell: Der Server sendet einige Daten an den Client, nachdem er angefordert wurde.  Bei WebSocket ist alles anders angeordnet.  N√§mlich: <br><br><ul><li>  Der Server kann von sich aus Nachrichten an den Client senden, ohne auf eine Anfrage des Clients warten zu m√ºssen. </li><li>  Der Client und der Server k√∂nnen gleichzeitig Daten austauschen. </li><li>  Bei der √úbertragung einer Nachricht wird eine extrem kleine Menge von Servicedaten verwendet.  Dies f√ºhrt insbesondere zu einer geringen Latenz bei der Daten√ºbertragung. </li></ul><br>  Das WebSocket-Protokoll eignet sich sehr gut f√ºr die Echtzeitkommunikation √ºber Kan√§le, die lange offen bleiben.  HTTP eignet sich wiederum hervorragend f√ºr die Organisation gelegentlicher Kommunikationssitzungen, die vom Client initiiert werden.  Gleichzeitig ist zu beachten, dass es aus programmtechnischer Sicht viel einfacher ist, den Datenaustausch √ºber das HTTP-Protokoll zu implementieren als √ºber das WebSocket-Protokoll. <br><br><h3>  <font color="#3AC1EF">‚ñç Gesch√ºtzte Version des WebSocket-Protokolls</font> </h3><br>  Es gibt eine unsichere Version des WebSocket-Protokolls ( <code>ws://</code> URI-Schema), die in Bezug auf die Sicherheit dem <code>http://</code> -Protokoll √§hnelt.  Die Verwendung von <code>ws://</code> sollte vermieden werden, wobei eine sichere Version des Protokolls bevorzugt wird - <code>wss://</code> . <br><br><h3>  <font color="#3AC1EF">‚ñçErstellen einer WebSocket-Verbindung</font> </h3><br>  Um eine WebSocket-Verbindung herzustellen, m√ºssen Sie den entsprechenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konstruktor verwenden</a> : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'wss://myserver.com/something'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> connection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket(url)</code> </pre> <br>  Nachdem eine erfolgreiche Verbindung hergestellt wurde, wird das <code>open</code> Ereignis ausgel√∂st.  Sie k√∂nnen dieses Ereignis organisieren, indem <code>onopen</code> Eigenschaft <code>onopen</code> des <code>connection</code> eine R√ºckruffunktion <code>onopen</code> : <br><br><pre> <code class="hljs javascript">connection.onopen = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Zur Behandlung von Fehlern wird der <code>onerror</code> Ereignishandler verwendet: <br><br><pre> <code class="hljs javascript">connection.onerror = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`WebSocket error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error}</span></span></span><span class="hljs-string">`</span></span>) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçSenden von Daten an den Server</font> </h3><br>  Nach dem √ñffnen einer WebSocket-Verbindung zum Server k√∂nnen Sie Daten an diesen senden.  Dies kann beispielsweise im Onopen- <code>onopen</code> : <br><br><pre> <code class="hljs coffeescript">connection.onopen = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { connection.send(<span class="hljs-string"><span class="hljs-string">'hey'</span></span>) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Abrufen von Daten vom Server</font> </h3><br>  Um Daten zu empfangen, die mit dem WebSocket-Protokoll vom Server gesendet wurden, k√∂nnen Sie den <code>onmessage</code> onmessage zuweisen, der beim Empfang des <code>message</code> aufgerufen wird: <br><br><pre> <code class="hljs javascript">connection.onmessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e.data) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Implementierung des WebSocket-Servers in der Node.js-Umgebung</font> </h3><br>  Um einen WebSocket-Server in der Node.js-Umgebung zu implementieren, k√∂nnen Sie die beliebte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ws-</a> Bibliothek verwenden.  Wir werden es f√ºr die Serverentwicklung verwenden, aber es eignet sich zum Erstellen von Clients sowie zum Organisieren der Interaktion zwischen zwei Servern. <br><br>  Installieren Sie diese Bibliothek, indem Sie zuerst das Projekt initialisieren: <br><br><pre> <code class="hljs swift">yarn <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> yarn add ws</code> </pre> <br>  Der Code f√ºr den WebSocket-Server, den wir schreiben m√ºssen, ist ziemlich kompakt: <br><br><pre> <code class="hljs javascript">constWebSocket = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ws'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wss = newWebSocket.Server({ <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">8080</span></span> }) wss.on(<span class="hljs-string"><span class="hljs-string">'connection'</span></span>, ws =&gt; { ws.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, message =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Received message =&gt; </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message}</span></span></span><span class="hljs-string">`</span></span>) }) ws.send(<span class="hljs-string"><span class="hljs-string">'ho!'</span></span>) })</code> </pre> <br>  Hier erstellen wir einen neuen Server, der den Standardport 8080 f√ºr das WebSocket-Protokoll √ºberwacht und einen R√ºckruf beschreibt, der beim Herstellen der Verbindung eine <code>ho!</code> Nachricht an den Client sendet <code>ho!</code>  und druckt eine vom Client empfangene Nachricht an die Konsole. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist ein</a> funktionierendes Beispiel f√ºr einen WebSocket-Server, und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ist ein Client, der mit ihm interagieren kann. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute haben wir √ºber die von der Node.js-Plattform unterst√ºtzten Netzwerkmechanismen gesprochen und Parallelen zu √§hnlichen Mechanismen gezogen, die in Browsern verwendet werden.  Unser n√§chstes Thema wird die Arbeit mit Dateien sein. <br><br>  <b>Liebe Leser!</b>  Verwenden Sie das WebSocket-Protokoll in Ihren Webanwendungen, deren Serverseite mit Node.js erstellt wurde? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424557/">https://habr.com/ru/post/de424557/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424541/index.html">UGJ 2018 Fiasko-Geschichte: Wie man ein Spiel macht, das niemand mag (tu es nicht!)</a></li>
<li><a href="../de424543/index.html">Java 11 / JDK 11: Allgemeine Verf√ºgbarkeit</a></li>
<li><a href="../de424551/index.html">Warm and Tube: F√ºnf Balalaikas √ºber magnetische Audiotechnologie</a></li>
<li><a href="../de424553/index.html">Node.js Guide, Teil 6: Ereignisschleife, Call Stack, Timer</a></li>
<li><a href="../de424555/index.html">Node.js Handbuch, Teil 7: Asynchrone Programmierung</a></li>
<li><a href="../de424559/index.html">Big Data Resistance 1 oder schwer fassbarer Joe. Internet-Anonymit√§t, Anti-Erkennung, Anti-Tracking f√ºr Anti-Sie und Anti-uns</a></li>
<li><a href="../de424563/index.html">Beeline sendet Einzelheiten zu Gespr√§chen an Fremde</a></li>
<li><a href="../de424565/index.html">√úbersicht: 3D-Scannen von Immobilien</a></li>
<li><a href="../de424567/index.html">Die Erfahrung, Online-Werbung im lokalen Netzwerk des Unternehmens zu blockieren</a></li>
<li><a href="../de424569/index.html">Programmierer einstellen. Programmierertipps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>