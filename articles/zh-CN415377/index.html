<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙏 🤵🏻 👨🏼‍🤝‍👨🏻 JS的工作原理：类和继承，Babel和TypeScript中的转译 💃🏾 🤹🏿 🤲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="类是当今构建软件项目的最流行的方法之一。 这种编程方法也用在JavaScript中。 今天，我们将发布JS生态系统系列第15部分的翻译。 本文将讨论在JavaScript中实现类，继承机制和蒸腾的各种方法。 首先，我们将告诉您原型的工作原理，并分析各种方法来模拟流行的库中基于类的继承。 接下来，我们...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JS的工作原理：类和继承，Babel和TypeScript中的转译</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415377/"> 类是当今构建软件项目的最流行的方法之一。 这种编程方法也用在JavaScript中。 今天，我们将发布JS生态系统系列第15部分的翻译。 本文将讨论在JavaScript中实现类，继承机制和蒸腾的各种方法。 首先，我们将告诉您原型的工作原理，并分析各种方法来模拟流行的库中基于类的继承。 接下来，我们将讨论如何通过转译来编写JS程序，这些程序使用的功能不是该语言提供的，或者尽管它们以新标准的形式存在或处于不同批准阶段的提案，但尚未在JS-中实现引擎。 特别是，我们将讨论Babel和TypeScript以及ECMAScript 2015类，之后，我们将看一些示例，这些示例演示了V8 JS引擎中类的内部实现的功能。 <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/196/736/c87/196736c87449034c2354db7c52f1cd08.png" alt="图片"></div><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">[建议阅读]周期的其他19个部分</b> <div class="spoiler_text">第1部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引擎概述，运行时机制，调用堆栈</a> <br> 第2部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于V8内部和代码优化</a> <br> 第3部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">管理内存，四种类型的内存泄漏并进行处理</a> <br> 第4部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件循环，异步和通过异步/等待改进代码的五种方法</a> <br> 第5部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WebSocket和HTTP / 2 + SSE。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">选择什么？</a> <br> 第6部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WebAssembly的功能和范围</a> <br> 第7部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Web Workers和五个使用方案</a> <br> 第八部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">服务人员</a> <br> 第9部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Web推送通知</a> <br> 第10部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用MutationObserver跟踪DOM中的更改</a> <br> 第11部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网页呈现引擎和优化其性能的技巧</a> <br> 第12部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">浏览器</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网络子系统，优化其性能和安全性</a> <br> 第12部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">浏览器</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网络子系统，优化其性能和安全性</a> <br> 第13部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CSS和JavaScript动画</a> <br> 第14部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作原理：抽象语法树，解析及其优化</a> <br> 第15部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作方式：类和继承，Babel和TypeScript中的转译</a> <br> 第16部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作原理：存储</a> <br> 第17部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作方式：Shadow DOM技术和Web组件</a> <br> 第18部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作原理：WebRTC和P2P通讯机制</a> <br> 第19部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作方式：自定义元素</a> </div></div><br><h2>  <font color="#3AC1EF">复习</font> </h2><br> 在JavaScript中，即使看起来我们正在使用原始数据类型，我们也经常遇到对象。 例如，创建一个字符串文字： <br><br><pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name = <span class="hljs-string"><span class="hljs-string">"SessionStack"</span></span>;</code> </pre> <br> 之后，我们可以立即使用<code>name</code>来调用<code>String</code>类型的对象的各种方法，我们创建的字符串文字将自动转换为该方法。 <br><br><pre> <code class="hljs pgsql">console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>.repeat(<span class="hljs-number"><span class="hljs-number">2</span></span>)); // SessionStackSessionStack console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>.toLowerCase()); // sessionstack</code> </pre> <br> 与其他语言不同，在JavaScript中，创建了一个包含例如字符串或数字的变量后，我们无需进行显式转换就可以使用此变量，就好像它最初是使用<code>new</code>关键字和相应的构造函数创建的一样。 结果，由于自动创建了封装原始值的对象，因此您可以像对待对象一样使用这些值，尤其是可以引用它们的方法和属性。 <br><br> 关于JavaScript类型系统的另一个值得注意的事实是，例如，数组也是对象。 如果查看为数组<code>typeof</code>的<code>typeof</code>命令的输出，则可以看到它报告所调查的实体具有<code>object</code>数据类型。 结果，事实证明数组元素的索引仅仅是特定对象的属性。 因此，当我们通过索引访问数组的元素时，它归结为使用<code>Array</code>类型的对象的属性并获取该属性的值。 如果我们讨论数据如何存储在普通对象和数组中，那么以下两种构造将导致创建几乎相同的数据结构： <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> names = [<span class="hljs-string"><span class="hljs-string">"SessionStack"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> names = { <span class="hljs-string"><span class="hljs-string">"0"</span></span>: <span class="hljs-string"><span class="hljs-string">"SessionStack"</span></span>, <span class="hljs-string"><span class="hljs-string">"length"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br> 结果，以相同的速度执行对数组元素和对象属性的访问。 本文的作者说，他是在解决一个复杂问题的过程中发现的。 即，一旦他需要对项目中非常重要的代码进行认真的优化。 在尝试了许多简单的方法之后，他决定用数组替换此代码中使用的所有对象。 从理论上讲，访问数组元素比使用哈希表键要快。 令他惊讶的是，这种替换丝毫不影响性能，因为使用数组和使用JavaScript中的对象归结为与哈希表的键进行交互，这两种情况都需要相同的时间。 <br><br><h2>  <font color="#3AC1EF">使用原型模拟类</font> </h2><br> 当我们考虑对象时，首先想到的是类。 也许今天从事编程的每个人都创建了应用程序，这些应用程序的结构基于类以及它们之间的关系。 尽管JavaScript的对象几乎可以在任何地方找到，但是该语言并未使用传统的基于类的继承系统。  JavaScript使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原型</a>来解决类似的问题。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/633/ba7/cab/633ba7cabdf251ed3747fb2a3764b344.png"></div><br>  <i><font color="#999999">对象及其原型</font></i> <br><br> 在JavaScript中，每个对象都与另一个对象相关联-具有自己的原型。 当您尝试访问对象的属性或方法时，首先在对象本身中执行对所需内容的搜索。 如果搜索失败，则在对象的原型中继续搜索。 <br><br> 考虑一个简单的示例，该示例描述<code>Component</code>基类的构造函数： <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Component</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">content</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } Component.prototype.render = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content); }</code> </pre> <br> 在这里，我们将<code>render()</code>函数分配给原型方法，因为我们需要<code>Component</code>类的每个实例才能使用此方法。 在<code>Component</code>任何实例中，当调用<code>render</code>方法时，其搜索均始于为其调用对象。 然后在原型中继续搜索，系统在该原型中找到此方法。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/553/6d8/74d/5536d874d81cc44b164174953614f725.png"></div><br>  <i><font color="#999999">原型和Component类的两个实例</font></i> <br><br> 现在，让我们尝试扩展<code>Component</code>类。 让我们为一个新类<code>InputField</code>创建一个构造函数： <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   this.content = `&lt;input type=<span class="hljs-string"><span class="hljs-string">"text"</span></span> value=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$</span></span></span><span class="hljs-string">{value}"</span></span> /&gt;`; }</code> </pre> <br> 如果我们需要<code>InputField</code>类<code>InputField</code>扩展<code>Component</code>类的功能并能够调用其<code>render</code>方法，则需要更改其原型。 在子类的实例上调用方法时，在空的原型中查找它是没有意义的。 在搜索此方法时，我们需要在<code>Component</code>类中找到。 因此，我们需要执行以下操作： <br><br><pre> <code class="hljs pgsql">InputField.prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Component());</code> </pre> <br> 现在，当使用<code>InputField</code>类的实例并调用<code>Component</code>类的方法时，可以在<code>Component</code>类的原型中找到此方法。 要实现继承系统，您需要将<code>InputField</code>原型连接到<code>Component</code>类的实例。 许多库使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.setPrototypeOf（）</a>解决此问题。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5c/c43/ba8/f5cc43ba8e7a66cf1bb5c8aecec04572.png"></div><br>  <i><font color="#999999">用InputField类扩展组件类</font></i> <br><br> 但是，上述动作不足以实现类似于传统继承的机制。 每次扩展类时，我们需要执行以下操作： <br><br><ul><li> 使后代类的原型成为父类的实例。 </li><li> 在后代类的构造函数中调用父类的构造函数，以确保正确初始化了父类。 </li><li> 提供一种机制，用于在后代类重写父方法的情况下调用父类的方法，但是需要从父类调用此方法的原始实现。 </li></ul><br> 如您所见，如果JS开发人员想要使用基于类的继承功能，则他将不得不不断执行上述步骤。 如果需要创建许多类，则可以采用适合重用的函数形式来完成所有这些工作。 <br><br> 实际上，以这种方式在JS开发的实践中最初解决了基于类组织继承的任务。 特别是使用各种库。 这样的解决方案变得非常流行，这清楚地表明JavaScript显然缺少某些东西。 因此，ECMAScript 2015引入了新的语法构造，旨在支持类的工作并实现相应的继承机制。 <br><br><h2>  <font color="#3AC1EF">课堂翻译</font> </h2><br> 在提出ECMAScript 2015（ES6）的新功能之后，JS社区希望尽快利用它们，而不必等待完成在JS引擎和浏览器中添加对这些功能的支持的漫长过程。 在解决这些问题中，移植是好的。 在这种情况下，编译过程简化为将根据ES6规则编写的JS代码转换为迄今为止不支持ES6功能的浏览器可以理解的视图。 结果，例如，可以声明类并根据ES6规则实现基于类的继承机制，并将这些构造转换为可在任何浏览器中使用的代码。 示意性地，该过程以编译器处理箭头功能为例（另一个需要时间支持的新语言功能）的示例可以表示为下图。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/37b/f2c/80237bf2c453fb8f9d7913c310a21384.png"></div><br>  <i><font color="#999999">转译</font></i> <br><br>  Babel.js是最受欢迎的JavaScript编译器之一。 让我们通过执行上面讨论的<code>Component</code>类声明代码的编译来查看其工作原理。 这是ES6代码： <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(content) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } render() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> component = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Component(<span class="hljs-string"><span class="hljs-string">'SessionStack'</span></span>); component.render();</code> </pre> <br> 这是代码在编译后变成的内容： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Component = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Component</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">content</span></span></span><span class="hljs-function">) </span></span>{   _classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, Component);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } _createClass(Component, [{   <span class="hljs-attr"><span class="hljs-attr">key</span></span>: <span class="hljs-string"><span class="hljs-string">'render'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content);   } }]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Component; }();</code> </pre> <br> 如您所见，ECMAScript 5代码是从transpiler的输出中获得的，可以在任何环境中运行。 此外，此处还添加了对Babel标准库一部分的某些函数的调用。 <br><br> 我们正在讨论转码中包含的<code>_classCallCheck()</code>和<code>_createClass()</code>函数。 第一个函数<code>_classCallCheck()</code>旨在防止像常规函数一样调用构造函数。 为此，它检查在其中调用该函数的上下文是否是<code>Component</code>类的实例上下文。 代码检查以查看this关键字是否指向相似的实例。 第二个函数<code>_createClass()</code>创建对象属性，该属性作为包含键及其值的对象数组传递给它。 <br><br> 为了了解继承的工作原理，我们分析了<code>InputField</code>类，它是<code>Component</code>类的后代。 在ES6中，类关系如何结合在一起： <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputField</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   constructor(value) {       const content = `&lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> value=<span class="hljs-string"><span class="hljs-string">"${value}"</span></span> /&gt;`;       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(content);   } }</code> </pre> <br> 这是使用Babel编译此代码的结果： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> InputField = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_Component</span></span></span><span class="hljs-function">) </span></span>{ _inherits(InputField, _Component); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputField</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{   _classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, InputField);   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-string"><span class="hljs-string">'&lt;input type="text" value="'</span></span> + value + <span class="hljs-string"><span class="hljs-string">'" /&gt;'</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _possibleConstructorReturn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, (InputField.__proto__ || <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(InputField)).call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, content)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InputField; }(Component);</code> </pre> <br> 在此示例中，继承机制的逻辑封装在对<code>_inherits()</code>函数的调用中。 它执行与上述相同的动作，尤其是将父类的实例写入后代类的原型时。 <br><br> 为了转置代码，Babel执行了一些转换。 首先，解析ES6代码并将其转换为称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">抽象语法树</a>的中间表示形式。 然后将生成的抽象语法树转换为另一棵树，该树的每个节点都转换为其等效的ES5。 结果，该树被转换为JS代码。 <br><br><h2>  <font color="#3AC1EF">Babel中的抽象语法树</font> </h2><br> 抽象语法树包含节点，每个节点只有一个父节点。  Babel具有节点的基本类型。 它包含有关节点是什么以及在代码中可以找到它的位置的信息。 有多种类型的节点，例如，用于表示文字的节点，例如字符串，数字， <code>null</code>值等。 另外，还有用于表示用于控制程序执行流程的表达式的节点（ <code>if</code>构造），以及用于循环的节点（ <code>for</code> ， <code>while</code> ）。 还有一种特殊的节点用于表示类。 它是<code>Node</code>基类的后代。 他通过添加用于存储对基类和作为单独节点的类主体的引用的字段来扩展此类。 <br> 将以下代码片段转换为抽象语法树： <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(content) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } render() {   console.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content) } }</code> </pre> <br> 这是他的示意图表示的外观。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8b/4c5/c1d/a8b4c5c1d077388bac770d1b452e51ed.png"></div><br>  <i><font color="#999999">抽象语法树</font></i> <br><br> 创建树后，将其每个节点转换为对应的ES5节点，然后将此新树转换为符合ECMAScript 5标准的代码，在转换过程中，首先找到离根节点最远的节点，然后将该节点转换为代码。使用为每个节点生成的摘要。 之后，重复该过程。 这种技术称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">深度搜索</a> 。 <br><br> 在上面的示例中，将首先生成两个<code>MethodDefinition</code>节点的代码， <code>ClassBody</code>将生成<code>ClassBody</code>节点的代码，最后生成<code>ClassBody</code>节点的代码。 <br><br><h2>  <font color="#3AC1EF">TypeScript编译</font> </h2><br> 另一种使用翻译的流行系统是TypeScript。 这是一种编程语言，其代码会转换为任何JS引擎都可以理解的ECMAScript 5代码。 它提供了用于编写JS应用程序的新语法。 这是在TypeScript上实现<code>Component</code>类的方法： <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   content: string;   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(content: string) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content;   }   render() {       console.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content)   } }</code> </pre> <br> 这是此代码的抽象语法树。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/332/806/ad0/332806ad0bd9882f32c58c0280a8ae40.png"></div><br>  <i><font color="#999999">抽象语法树</font></i> <br><br>  TypeScript支持继承。 <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputField</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   constructor(value: string) {       const content = `&lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> value=<span class="hljs-string"><span class="hljs-string">"${value}"</span></span> /&gt;`;       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(content);   } }</code> </pre> <br> 这是此代码的编译结果： <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> InputField = <span class="hljs-comment"><span class="hljs-comment">/** @class */</span></span> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_super)</span></span></span><span class="hljs-function"> </span></span>{   __extends(InputField, _super);   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-string"><span class="hljs-string">"&lt;input type=\"text\" value=\""</span></span> + value + <span class="hljs-string"><span class="hljs-string">"\" /&gt;"</span></span>;       _this = _super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, content) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _this;   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InputField; }(Component));</code> </pre> <br> 如您所见，这又是一个ES5代码，其中除了标准构造外，还调用了TypeScript库中的某些函数。  <code>__extends()</code>函数的功能类似于我们在本材料开头提到的功能。 <br><br> 由于Babel和TypeScript的广泛采用，用于声明类和组织基于类的继承的机制已成为构建JS应用程序的标准工具。 这有助于增加对浏览器中这些机制的支持。 <br><br><h2>  <font color="#3AC1EF">浏览器类支持</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">类支持</a>出现在2014年的Chrome浏览器中。 这使浏览器无需使用转译或任何辅助库即可使用类声明。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad5/860/a55/ad5860a550c7956d6bbf17cd1b0afbb6.png"></div><br>  <i><font color="#999999">在Chrome JS控制台中使用类</font></i> <br><br> 实际上，浏览器对这些机制的支持不过是语法糖。 这些结构被转换为该语言已经支持的相同基本结构。 结果，即使您使用新的语法，在较低的层次上，一切看起来也像创建构造函数和操作对象的原型： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b61/d1c/a5b/b61d1ca5b3d35b3b1f431ae8e82c48bd.png"></div><br>  <i><font color="#999999">类支持是语法糖</font></i> <br><br><h2>  <font color="#3AC1EF">V8中的类支持</font> </h2><br> 让我们讨论一下ES6类支持如何在V8 JS引擎中工作。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">先前</a>专门讨论抽象语法树的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">材料中</a> ，我们谈到了以下事实：在准备要执行的JS代码时，系统会对其进行解析并在其基础上形成一个抽象语法树。 解析类声明的构造时， <a href="">ClassLiteral</a>类型的节点将落入抽象语法树中。 <br><br> 这些节点存储了一些有趣的东西。 首先，它是作为单独函数的构造函数，其次，它是类属性的列表。 它可以是方法，获取器，设置器，公共或私有字段。 此外，此类节点还存储对父类的引用，该引用扩展了要为其形成节点的类，该类又存储了构造函数，属性列表以及指向其自身父类的链接。 <br><br> 将新的<code>ClassLiteral</code>节点<a href="">转换为代码后</a> ，将其转换为由函数和原型组成的构造。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 该材料的作者说， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SessionStack</a>致力于尽可能全面地优化其库的代码，因为它必须解决收集有关网页上发生的所有事情的信息的艰巨任务。 在解决这些问题的过程中，库不应减慢所分析页面的工作。 此级别的优化需要考虑到影响性能的JavaScript生态系统的最小细节，尤其是要考虑到ES6中类和继承机制的排列方式。 <br><br>  <b>亲爱的读者们！</b> 您是否使用ES6语法构造来处理JavaScript中的类？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN415377/">https://habr.com/ru/post/zh-CN415377/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN415367/index.html">如果外星人变成具有人工智能的机器怎么办？</a></li>
<li><a href="../zh-CN415369/index.html">重构价格</a></li>
<li><a href="../zh-CN415371/index.html">加密货币隐私</a></li>
<li><a href="../zh-CN415373/index.html">Python中的NumPy。 第4部分</a></li>
<li><a href="../zh-CN415375/index.html">藏羊与印刷考古学</a></li>
<li><a href="../zh-CN415381/index.html">与Kubernetes一起玩-熟悉K8s的服务</a></li>
<li><a href="../zh-CN415383/index.html">由于英国经纪人系统的错误，新手交易者完成了55亿欧元的交易</a></li>
<li><a href="../zh-CN415385/index.html">DCIM状况：近年来数据中心基础架构管理的变化</a></li>
<li><a href="../zh-CN415387/index.html">每个开发人员都想知道如何进行网络钓鱼。</a></li>
<li><a href="../zh-CN415389/index.html">今天，支付系统“ VKontakte”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>