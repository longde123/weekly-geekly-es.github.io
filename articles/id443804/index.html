<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚱️ 📲 🔳 C # adalah bahasa tingkat rendah? 👄 👈🏿 👇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya penggemar berat semua yang dilakukan Fabien Sanglard , saya suka blognya, dan saya membaca kedua bukunya sampul depan (dijelaskan dalam podcast H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C # adalah bahasa tingkat rendah?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443804/"> Saya penggemar berat semua yang dilakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fabien Sanglard</a> , saya suka blognya, dan saya membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bukunya</a> sampul depan (dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">podcast Hansleminutes</a> baru-baru ini). <br><br>  Fabien baru-baru ini menulis posting yang bagus di mana dia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendekripsi</a> pelacak sinar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kecil</a> , menghilangkan kode dan menjelaskan matematika dengan sangat indah.  Saya sangat merekomendasikan meluangkan waktu untuk membaca ini! <br><br>  Tapi itu membuat saya bertanya-tanya <i><b>apakah mungkin untuk mem-porting kode C ++ ini ke C #</b></i> ?  Karena saya harus menulis banyak C ++ di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pekerjaan utama</a> saya belakangan ini, saya pikir saya bisa mencobanya. <br><br>  Tetapi yang lebih penting, saya ingin mendapatkan ide yang lebih baik tentang <b>apakah C # adalah bahasa tingkat rendah</b> ? <br><a name="habracut"></a><br>  Pertanyaan yang sedikit berbeda, tetapi terkait: berapa banyak C # cocok untuk "pemrograman sistem"?  Mengenai hal ini, saya sangat merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">postingan bagus Joe Duffy mulai 2013</a> . <br><br><h1>  Port jalur </h1><br>  Saya mulai dengan hanya porting <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode C ++ deobfuscated</a> baris demi baris ke C #.  Itu cukup sederhana: tampaknya kebenaran masih dikatakan bahwa C # adalah C ++++ !!! <br><br>  Contoh menunjukkan struktur data utama - 'vektor', di sini adalah perbandingan, C ++ di sebelah kiri, C # di kanan: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/f14/ecc/cbd/f14ecccbd0091486caf57fc43fb2ac7f.png"></a> <br><br>  Jadi, ada beberapa perbedaan sintaksis, tetapi karena .NET memungkinkan Anda untuk menentukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jenis nilai Anda sendiri</a> , saya bisa mendapatkan fungsionalitas yang sama.  Ini penting karena memperlakukan 'vektor' sebagai struktur berarti kita bisa mendapatkan "lokalitas data" yang lebih baik dan kita tidak perlu melibatkan pengumpul sampah .NET, karena data akan didorong ke tumpukan (ya, saya tahu ini adalah detail implementasi). <br><br>  Untuk informasi lebih lanjut tentang <code>structs</code> atau "tipe nilai" di .NET, lihat di sini: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Heap versus stack, tipe nilai versus tipe referensi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jenis nilai versus tipe referensi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memori di .NET: ke mana</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kebenaran tentang tipe nilai</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tumpukan adalah detail implementasi, bagian satu</a> </li></ul><br>  Secara khusus, dalam posting terakhir Eric Lippert, kami menemukan kutipan yang sangat berguna yang memperjelas “tipe nilai” sebenarnya: <br><br><blockquote>  Tentu saja, fakta yang paling penting tentang jenis-jenis nilai <b>bukanlah rincian implementasi, <i>bagaimana mereka dialokasikan</i></b> , melainkan <i>makna semantik asli dari</i> “tipe nilai”, <b>yaitu, bahwa ia <i>selalu disalin “berdasarkan nilai”</i></b> .  Jika informasi alokasi penting, kami akan menyebutnya "tipe tumpukan" dan "tipe tumpukan".  Tetapi dalam kebanyakan kasus itu tidak masalah.  Sebagian besar waktu, semantik penyalinan dan identifikasi relevan. </blockquote><br>  Sekarang mari kita lihat seperti apa beberapa metode lain dalam perbandingan (lagi C ++ di sebelah kiri, C # di kanan), <code>RayTracing(..)</code> pertama <code>RayTracing(..)</code> : <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4d0/3c5/277/4d03c5277ffa4f1e73462dab4edc7dd0.png"></a> <br><br>  Kemudian <code>QueryDatabase (..)</code> : <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/2fc/c17/839/2fcc17839a00bfc619e14c7323e28f52.png"></a> <br><br>  (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting Fabian</a> untuk penjelasan tentang apa yang dilakukan kedua fungsi ini) <br><br>  Tetapi sekali lagi, kenyataannya adalah bahwa C # membuatnya sangat mudah untuk menulis kode C ++!  Dalam hal ini, kata kunci <code>ref</code> paling membantu kami, yang memungkinkan kami memberikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nilai dengan referensi</a> .  Kami telah menggunakan <code>ref</code> dalam panggilan metode untuk beberapa waktu, tetapi baru-baru ini, upaya telah dilakukan untuk menyelesaikan <code>ref</code> tempat lain: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ref kembali dan ref lokal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seri C # 7, bagian 9: ref struct</a> </li></ul><br>  Sekarang <i>kadang</i> - <i>kadang</i> menggunakan <code>ref</code> akan meningkatkan kinerja, karena dengan demikian struktur tidak perlu disalin, lihat tolok ukur dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting oleh Adam Stinix</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Perangkap kinerja ref lokal dan pengembalian ref dalam C #”</a> untuk informasi lebih lanjut. <br><br>  Tetapi yang paling penting adalah bahwa skrip semacam itu memberikan C # port kita dengan perilaku yang sama dengan kode sumber C ++.  Meskipun saya ingin mencatat bahwa apa yang disebut "tautan terkelola" tidak persis sama dengan "petunjuk", khususnya, Anda tidak dapat melakukan aritmatika pada mereka, lihat lebih lanjut tentang ini di sini: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ref return bukan pointer</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pointer yang Dikelola</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan bukan alamat</a> </li></ul><br><h2>  Performa </h2><br>  Dengan demikian, kode porting baik, tetapi kinerja juga penting.  Terutama pada ray tracer, yang dapat menghitung frame selama beberapa menit.  Kode C ++ berisi <code>sampleCount</code> variabel, yang mengontrol kualitas gambar akhir, dengan <code>sampleCount = 2</code> sebagai berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/10a/17e/e2d/10a17ee2df5205f5fa8bd138693bc4a6.png"><br><br>  Jelas tidak terlalu realistis! <br><br>  Tetapi ketika Anda mendapatkan <code>sampleCount = 2048</code> , semuanya terlihat <i>jauh</i> lebih baik: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/304/4b2/14d/3044b214da9027dd34dcbc19fdc75d2f.png"><br><br>  Tetapi memulai dengan <code>sampleCount = 2048</code> <b>sangat</b> memakan waktu, jadi semua proses lainnya dilakukan dengan nilai <code>2</code> untuk memenuhi setidaknya satu menit.  Mengubah <code>sampleCount</code> hanya memengaruhi jumlah iterasi dari loop kode terluar, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">intisari ini</a> untuk penjelasan. <br><br><h3>  Hasil setelah port baris “naif” </h3><br>  Untuk membandingkan secara substansial C ++ dan C #, saya menggunakan alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">time-windows</a> , ini adalah port dari perintah unix <code>time</code> .  Hasil awal terlihat seperti ini: <br><br><table><thead><tr><th></th><th>  C ++ (VS 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) </th></tr></thead><tbody><tr><td>  Waktu (detik) </td><td>  47.40 </td><td>  80.14 </td><td>  78.02 </td></tr><tr><td>  Dalam inti (dtk) </td><td>  0,14 (0,3%) </td><td>  0,72 (0,9%) </td><td>  0,63 (0,8%) </td></tr><tr><td>  Di ruang pengguna (detik) </td><td>  43,86 (92,5%) </td><td>  73,06 (91,2%) </td><td>  70.66 (90.6%) </td></tr><tr><td>  Jumlah kesalahan halaman kesalahan </td><td>  1143 </td><td>  4818 </td><td>  5945 </td></tr><tr><td>  Perangkat Kerja (KB) </td><td>  4232 </td><td>  13 624 </td><td>  17 052 </td></tr><tr><td>  Memori yang Diekstrusi (KB) </td><td>  95 </td><td>  172 </td><td>  154 </td></tr><tr><td>  Memori non-preemptive </td><td>  7 </td><td>  14 </td><td>  16 </td></tr><tr><td>  Swap File (KB) </td><td>  1460 </td><td>  10 936 </td><td>  11 024 </td></tr></tbody></table><br>  Awalnya, kita melihat bahwa kode C # sedikit lebih lambat dari versi C ++, tetapi semakin baik (lihat di bawah). <br><br>  Tapi pertama-tama mari kita lihat apa yang dilakukan oleh .NET JIT kepada kita bahkan dengan port baris demi baris yang “naif” ini.  Pertama, ini melakukan pekerjaan yang baik dengan menanamkan metode pembantu yang lebih kecil.  Ini dapat dilihat pada output alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Inlining Analyzer yang</a> sangat baik (hijau = <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bawaan</a> ): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4cc/484/0a5/4cc4840a53f18362d3b4f3a4249fb2d5.png"></a> <br><br>  Namun, itu tidak menanamkan semua metode, misalnya, karena kompleksitas, <code>QueryDatabase(..)</code> dilewati: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9e2/648/da2/9e2648da2a8ae7df5f94ceb77771c0ab.png"></a> <br><br>  Fitur kompiler .NET Just-In-Time (JIT) lainnya adalah konversi panggilan metode khusus ke instruksi CPU yang sesuai.  Kita dapat melihat ini beraksi dengan fungsi shell <code>sqrt</code> , di sini adalah kode sumber C # (perhatikan panggilan ke <code>Math.Sqrt</code> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// intnv square root public static Vec operator !(Vec q) { return q * (1.0f / (float)Math.Sqrt(q % q)); }</span></span></code> </pre> <br>  Dan di sini adalah kode assembler yang dihasilkan oleh .NET JIT: tidak ada panggilan ke <code>Math.Sqrt</code> dan instruksi prosesor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vsqrtsd digunakan</a> : <br><br><pre> <code class="plaintext hljs">; Assembly listing for method Program:sqrtf(float):float ; Emitting BLENDED_CODE for X64 CPU with AVX - Windows ; Tier-1 compilation ; optimized code ; rsp based frame ; partially interruptible ; Final local variable assignments ; ; V00 arg0 [V00,T00] ( 3, 3 ) float -&gt; mm0 ;# V01 OutArgs [V01 ] ( 1, 1 ) lclBlk ( 0) [rsp+0x00] "OutgoingArgSpace" ; ; Lcl frame size = 0 G_M8216_IG01: vzeroupper G_M8216_IG02: vcvtss2sd xmm0, xmm0 vsqrtsd xmm0, xmm0 vcvtsd2ss xmm0, xmm0 G_M8216_IG03: ret ; Total bytes of code 16, prolog size 3 for method Program:sqrtf(float):float ; ============================================================</code> </pre> <br>  (untuk mendapatkan masalah ini, ikuti <a href="">instruksi ini</a> , gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">add-on "Disasmo" VS2019</a> atau lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SharpLab.io</a> ) <br><br>  Penggantian ini juga dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">intrinsik</a> , dan dalam kode di bawah ini kita dapat melihat bagaimana JIT menghasilkannya.  Cuplikan ini hanya menunjukkan pemetaan untuk <code>AMD64</code> , tetapi JIT juga menargetkan <code>X86</code> , <code>ARM</code> dan <code>ARM64</code> , metode lengkap di <a href="">sini</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Compiler::IsTargetIntrinsic(CorInfoIntrinsics intrinsicId) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_TARGET_AMD64_) || (defined(_TARGET_X86_) &amp;&amp; !defined(LEGACY_BACKEND)) switch (intrinsicId) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// AMD64/x86 has SSE2 instructions to directly compute sqrt/abs and SSE4.1 // instructions to directly compute round/ceiling/floor. // // </span></span><span class="hljs-doctag"><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span></span><span class="hljs-meta"><span class="hljs-comment"> Because the x86 backend only targets SSE for floating-point code, // it does not treat Sine, Cosine, or Round as intrinsics (JIT32 // implemented those intrinsics as x87 instructions). If this poses // a CQ problem, it may be necessary to change the implementation of // the helper calls to decrease call overhead or switch back to the // x87 instructions. This is tracked by #7097. case CORINFO_INTRINSIC_Sqrt: case CORINFO_INTRINSIC_Abs: return true; case CORINFO_INTRINSIC_Round: case CORINFO_INTRINSIC_Ceiling: case CORINFO_INTRINSIC_Floor: return compSupports(InstructionSet_SSE41); default: return false; } ... }</span></span></span></span></code> </pre> <br>  Seperti yang Anda lihat, beberapa metode diimplementasikan seperti <code>Sqrt</code> dan <code>Abs</code> , sementara yang lain menggunakan fungsi runtime C ++, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">powf</a> . <br><br>  Seluruh proses ini dijelaskan dengan sangat baik dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Bagaimana Math.Pow () diimplementasikan dalam .NET Framework?"</a>  , itu juga dapat dilihat pada sumber CoreCLR: <br><br><ul><li>  Implementasi <code><a href="">COMSingle::Pow</a></code> , yaitu, metode yang dieksekusi jika <code>MathF.Pow(..)</code> dipanggil dari kode C # <br></li><li>  Pemetaan dalam <a href="">implementasi metode runtime C</a> <br></li><li>  Versi lintas platform <a href="">dari implementasi powf</a> yang menyediakan perilaku yang sama di seluruh OS </li></ul><br><h3>  Hasil setelah peningkatan kinerja sederhana </h3><br>  Saya ingin tahu apakah Anda dapat segera meningkatkan port line-by-port yang naif.  Setelah membuat profil, saya membuat dua perubahan besar: <br><br><ul><li>  Menghapus Inisialisasi Array Inline </li><li>  Mengganti fungsi <code>Math.XXX(..)</code> dengan analog dari <code>MathF.()</code> </li></ul><br>  Perubahan ini dijelaskan secara lebih rinci di bawah ini. <br><br><h4>  Menghapus Inisialisasi Array Inline </h4><br>  Untuk informasi lebih lanjut tentang mengapa ini perlu, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jawaban Stack Overflow yang luar biasa</a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Andrei Akinshin ini</a> , bersama dengan kode benchmark dan assembler.  Dia sampai pada kesimpulan berikut: <br><br><blockquote>  <b>Kesimpulan</b> <br><br><ul><li>  <i><b>Apakah .NET cache array lokal kode-keras?</b></i>  Seperti yang meletakkan kompiler Roslyn di metadata. </li><li>  <i><b>Dalam hal ini, akan ada overhead?</b></i>  Sayangnya, ya: untuk setiap panggilan, JIT akan menyalin isi array dari metadata, yang membutuhkan waktu lebih lama dibandingkan dengan array statis.  Runtime juga memilih objek dan menciptakan lalu lintas di memori. </li><li>  <i><b>Apakah ada yang perlu dikhawatirkan tentang hal ini?</b></i>  Mungkin  Jika ini adalah metode panas dan Anda ingin mencapai tingkat kinerja yang baik, Anda perlu menggunakan array statis.  Jika ini adalah metode dingin yang tidak mempengaruhi kinerja aplikasi, Anda mungkin perlu menulis kode sumber "baik" dan menempatkan array di area metode. </li></ul></blockquote><br>  Anda dapat melihat perubahan yang dibuat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diff ini</a> . <br><br><h4>  Menggunakan Fungsi MathF Daripada Matematika </h4><br>  Kedua, dan yang paling penting, saya meningkatkan kinerja secara signifikan dengan melakukan perubahan berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> NETSTANDARD2_1 || NETCOREAPP2_0 || NETCOREAPP2_1 || NETCOREAPP2_2 || NETCOREAPP3_0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// intnv square root public static Vec operator !(Vec q) { return q * (1.0f / MathF.Sqrt(q % q)); } #else public static Vec operator !(Vec q) { return q * (1.0f / (float)Math.Sqrt(q % q)); } #endif</span></span></span></span></code> </pre> <br>  Dimulai dengan .NET Standard 2.1, implementasi konkret dari fungsi matematika umum <code>float</code> ada.  Mereka berada di kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">System.MathF</a> .  Untuk selengkapnya tentang API ini dan implementasinya, lihat di sini: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API matematika baru dengan presisi tunggal</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tambahkan fungsi matematika dengan presisi tunggal</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menyediakan rangkaian uji unit untuk API matematika presisi tunggal baru</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">System.Math dan System.MathF harus diimplementasikan dalam kode yang dikelola, bukan sebagai FCALL untuk runtime C</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memindahkan Math.Abs ​​(dobel) dan Math.Abs ​​(float) untuk diterapkan dalam kode terkelola</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Desain dan proses untuk menambahkan alat embedded khusus platform ke .NET</a> </li></ul><br>  Setelah perubahan ini, perbedaan dalam kinerja kode C # dan C ++ dikurangi menjadi sekitar 10%: <br><br><table><thead><tr><th></th><th>  C ++ (VS C ++ 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) TC OFF </th><th>  .NET Core (2.2) TC ON </th></tr></thead><tbody><tr><td>  Waktu (detik) </td><td>  41.38 </td><td>  58.89 </td><td>  46.04 </td><td>  44.33 </td></tr><tr><td>  Dalam inti (dtk) </td><td>  0,05 (0,1%) </td><td>  0,06 (0,1%) </td><td>  0,14 (0,3%) </td><td>  0,13 (0,3%) </td></tr><tr><td>  Di ruang pengguna (detik) </td><td>  41,19 (99,5%) </td><td>  58,34 (99,1%) </td><td>  44,72 (97,1%) </td><td>  44,03 (99,3%) </td></tr><tr><td>  Jumlah kesalahan halaman kesalahan </td><td>  1119 </td><td>  4749 </td><td>  5776 </td><td>  5661 </td></tr><tr><td>  Perangkat Kerja (KB) </td><td>  4136 </td><td>  13,440 </td><td>  16.788 </td><td>  16.652 </td></tr><tr><td>  Memori yang Diekstrusi (KB) </td><td>  89 </td><td>  172 </td><td>  150 </td><td>  150 </td></tr><tr><td>  Memori non-preemptive </td><td>  7 </td><td>  13 </td><td>  16 </td><td>  16 </td></tr><tr><td>  Swap File (KB) </td><td>  1428 </td><td>  10 904 </td><td>  10 960 </td><td>  11 044 </td></tr></tbody></table><br>  TC - kompilasi bertingkat, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kompilasi Berjenjang</a> ( <i>saya kira</i> ini akan diaktifkan secara default di .NET Core 3.0) <br><br>  Untuk kelengkapan, berikut adalah hasil dari beberapa proses: <br><br><table><thead><tr><th>  Lari </th><th>  C ++ (VS C ++ 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) TC OFF </th><th>  .NET Core (2.2) TC ON </th></tr></thead><tbody><tr><td>  TestRun-01 </td><td>  41.38 </td><td>  58.89 </td><td>  46.04 </td><td>  44.33 </td></tr><tr><td>  TestRun-02 </td><td>  41.19 </td><td>  57.65 </td><td>  46.23 </td><td>  45,96 </td></tr><tr><td>  TestRun-03 </td><td>  42.17 </td><td>  62.64 </td><td>  46.22 </td><td>  48.73 </td></tr></tbody></table><br>  <b>Catatan</b> : perbedaan antara .NET Core dan .NET Framework adalah karena tidak adanya API MathF di .NET Framework 4.7.2, untuk informasi lebih lanjut, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiket dukungan .Net Framework (4.8?) Untuk netstandard 2.1</a> . <br><br><h1>  Lebih lanjut meningkatkan produktivitas </h1><br>  Saya yakin kode itu masih bisa diperbaiki! <br><br>  Jika Anda tertarik untuk menyelesaikan perbedaan kinerja, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini adalah kode C #</a> .  Sebagai perbandingan, Anda dapat menonton kode assembler C ++ dari layanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Compiler Explorer yang sangat</a> baik. <br><br>  Akhirnya, jika itu membantu, berikut ini adalah output profiler Visual Studio dengan tampilan "jalur panas" (setelah peningkatan kinerja yang dijelaskan di atas): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b78/3df/2e6/b783df2e692b62f492b78c8e7affcbf4.png"></a> <br><br><h1>  Apakah C # bahasa tingkat rendah? </h1><br>  Atau lebih khusus: <br><br><blockquote>  <b><b>Apa fitur bahasa dari fungsi C # / F # / VB.NET atau BCL / Runtime yang berarti "level rendah" *?</b></b> </blockquote><br>  * Ya, saya mengerti bahwa "level rendah" adalah istilah subyektif. <br><br>  <b>Catatan:</b> setiap pengembang C # memiliki ide sendiri tentang apa "level rendah" itu, fungsi-fungsi ini akan diterima begitu saja oleh programmer C ++ atau Rust. <br><br>  Ini daftar yang saya buat: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ref pengembalian dan ref penduduk setempat</a> <br><ul><li>  “Melewati dan kembali dengan referensi untuk menghindari menyalin struktur besar.  Jenis dan memori yang aman bisa lebih <b>cepat</b> daripada tidak aman! " </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode tidak aman di .NET</a> <br><ul><li>  “Bahasa inti C #, sebagaimana didefinisikan dalam bab-bab sebelumnya, sangat berbeda dari C dan C ++ karena tidak memiliki pointer sebagai tipe data.  Sebaliknya, C # memberikan tautan dan kemampuan untuk membuat objek yang diatur oleh pengumpul sampah.  Desain ini, dikombinasikan dengan fitur-fitur lain, menjadikan C # bahasa yang jauh lebih aman daripada C atau C ++. ” </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pointer yang Dikelola di .NET</a> <br><ul><li>  “Ada jenis pointer lain di CLR - pointer terkelola.  Ini dapat didefinisikan sebagai jenis tautan yang lebih umum yang dapat menunjuk ke lokasi lain, dan tidak hanya ke awal objek. " </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seri C # 7, Bagian 10: Rentang &lt;T&gt; dan Manajemen Memori Universal</a> <br><ul><li>  "System.Span &lt;T&gt; hanyalah tipe tumpukan ( <code>ref struct</code> ) yang membungkus semua pola akses memori, ini adalah tipe untuk akses memori kontinu universal.  Kita dapat membayangkan implementasi Span dengan referensi dummy dan panjang yang menerima ketiga jenis akses memori. " </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kompatibilitas ("Panduan Pemrograman C #")</a> <br><ul><li>  ".NET Framework menyediakan interoperabilitas dengan kode yang tidak dikelola melalui layanan permintaan platform, <code>System.Runtime.InteropServices</code> , kompatibilitas C ++, dan kompatibilitas COM (interoperabilitas COM)." </li></ul></li></ul><br>  Saya juga melemparkan teriakan di Twitter dan mendapat lebih banyak opsi untuk dimasukkan dalam daftar: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ben Adams</a> : "Alat Bawaan untuk Platform (Instruksi CPU)" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mark Gravell</a> : “SIMD via Vector (yang cocok dengan Span) * cukup * rendah;  .NET Core harus (segera?) Menawarkan alat embedded CPU langsung untuk penggunaan instruksi CPU spesifik yang lebih eksplisit ” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mark Gravell</a> : “JIT Powerfull: hal-hal seperti rentang elision pada array / interval, serta menggunakan aturan per-struct-T untuk menghapus potongan besar kode yang JIT tahu pasti bahwa mereka tidak tersedia untuk T atau spesifik Anda CPU (BitConverter.IsLittleEndian, Vector.IsHardwareDipercepat, dll.) " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kevin Jones</a> : "Saya akan secara khusus menyebutkan kelas <code>MemoryMarshal</code> dan <code>Unsafe</code> , dan mungkin beberapa hal lain di dalam <code>System.Runtime.CompilerServices</code> " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Theodoros Chatsigiannakis</a> : "Anda juga bisa memasukkan <code>__makeref</code> dan yang lainnya" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">damageboy</a> : "Kemampuan untuk secara dinamis menghasilkan kode yang sama persis dengan input yang diharapkan, mengingat bahwa yang terakhir hanya akan diketahui pada saat run time dan dapat berubah secara berkala?" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Robert Hacken</a> : "Emisi dinamis IL" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Victor Baybekov</a> : “Stackalloc tidak disebutkan.  Dimungkinkan juga untuk menulis IL murni (bukan dinamis, oleh karena itu disimpan pada panggilan fungsi), misalnya, gunakan <code>ldftn</code> cache dan panggil mereka melalui <code>calli</code> .  Ada template proj di VS2017 yang membuat ini sepele dengan menulis ulang metode extern + MethodImplOptions.ForwardRef + ilasm.ex » <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Victor Baybekov</a> : "MethodImplOptions.AggressiveInlining juga" mengaktifkan pemrograman tingkat rendah "dalam arti memungkinkan Anda untuk menulis kode tingkat tinggi dengan banyak metode kecil dan masih mengontrol perilaku JIT untuk mendapatkan hasil yang optimal.  Kalau tidak, salin dan tempel ratusan metode LOC ... " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ben Adams</a> : "Menggunakan konvensi pemanggilan yang sama (ABI) seperti pada platform dasar, dan p / memanggil untuk interaksi?" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Victor Baibekov</a> : “Juga, karena Anda menyebutkan #fsharp - <code>inline</code> yang berfungsi di tingkat IL hingga JIT, oleh karena itu dianggap penting di tingkat bahasa.  C # ini tidak cukup (sejauh ini) untuk lambdas, yang selalu merupakan panggilan virtual, dan solusi sering aneh (obat generik terbatas) " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alexandre Mutel</a> : “SIMD tertanam baru, pasca pemrosesan kelas Utilitas Tidak Aman / IL (misalnya, kustom, Fody, dll.).  Untuk C # 8.0, pointer fungsi mendatang ... " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alexandre Mutel</a> : “Mengenai IL, F # secara langsung mendukung IL dalam bahasa, misalnya” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OmariO</a> : " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BinaryPrimitive</a> .  Tingkat rendah, tapi aman " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Koji Matsui</a> : “Bagaimana dengan assembler bawaanmu sendiri?  Sulit untuk toolkit dan runtime, tetapi dapat mengganti solusi p / invoke saat ini dan mengimplementasikan kode yang disematkan, jika ada ” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frank A. Kruger</a> : "Ldobj, stobj, initobj, initblk, cpyblk" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Conrad Coconut</a> : “Mungkin streaming penyimpanan lokal?  Memperbaiki ukuran buffer?  Anda mungkin harus menyebutkan batasan yang tidak dikelola dan tipe yang bisa ditembus :) ” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sebastiano Mandala</a> : "Hanya tambahan kecil untuk semua yang dikatakan: bagaimana dengan sesuatu yang sederhana, seperti mengatur struktur dan bagaimana mengisi dan menyelaraskan memori dan bidang pemesanan dapat mempengaruhi kinerja cache?  Ini adalah sesuatu yang saya sendiri harus jelajahi. ” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nino Floris</a> : "Konstanta yang disematkan melalui readonlyspan, stackalloc, finalizers, WeakReference, delegasi terbuka, MethodImplOptions, MemoryBarriers, TypedReference, varargs, SIMD, Unsafe.AsRef, dapat mengatur jenis struktur sesuai dengan tata letak (digunakan untuk TaskAwaiter dan versinya)" </li></ul><br>  <b>Jadi pada akhirnya, saya akan mengatakan bahwa C # tentu memungkinkan Anda untuk menulis kode yang terlihat seperti C ++, dan dalam kombinasi dengan pustaka runtime dan kelas dasar menyediakan banyak fungsi tingkat rendah.</b> <br><br><h1>  Bacaan lebih lanjut </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Template untuk C # kinerja tinggi.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Federico Andres Lois</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Performance Quiz # 6 - kamus Bahasa Mandarin-Bahasa Inggris</a> (sejak 2005, dua blogger Microsoft telah berperang melawan kinerja C ++ melawan C #) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Performance Quiz # 6 - Kesimpulan, eksplorasi ruang angkasa</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seberapa cepatkah C ++ daripada C #?</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Optimasi kode C # dan asli C ++ yang dikelola</a> (2005) </li></ul><br>  Unity Burst Compiler: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana Unity membuat (subset) dari C # secepat C ++</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unity Burst Compiler: Optimasi Kinerja Mudah</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pathtracer Harian, Bagian 3: C # dan Unity Burst</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C ++, C # dan Unity</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menyelam dalam-dalam ke Burst compiler - Unite LA</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443804/">https://habr.com/ru/post/id443804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443788/index.html">Dasar-dasar routing statis di Mikrotik RouterOS</a></li>
<li><a href="../id443790/index.html">Kesalahan Survivor</a></li>
<li><a href="../id443792/index.html">Kesalahan umum ketika bekerja dengan PostgreSQL. Bagian 2</a></li>
<li><a href="../id443794/index.html">Arahan utama untuk startup IT di bidang penjualan real estat</a></li>
<li><a href="../id443798/index.html">Zotero hacks: penyimpanan yang disinkronkan tanpa batas dan penggunaannya yang mulus dengan rmarkdown</a></li>
<li><a href="../id443808/index.html">Analisis gadis dengan tanggung jawab sosial yang rendah (Dibebankan dengan Power BI, Qlik Sense, Tableau)</a></li>
<li><a href="../id443810/index.html">Berapa penghasilan para pengembang dari berbagai kualifikasi, 2018</a></li>
<li><a href="../id443812/index.html">Bagaimana menerapkan bahasa pemrograman dalam JavaScript. Bagian 2: Penerjemah</a></li>
<li><a href="../id443814/index.html">Memberi adalah "bekas bisnis" saya</a></li>
<li><a href="../id443816/index.html">Kementerian Komunikasi menekankan pada operator 5G tunggal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>