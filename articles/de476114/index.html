<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÄ üë®üèº‚Äçüéì ü§æüèæ Was w√§re wenn ohne Python? Julia f√ºr maschinelles Lernen und allgemein üôÖüèø üåæ üñï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir wollen immer schnell Code schreiben, aber Sie m√ºssen daf√ºr bezahlen. In gew√∂hnlichen flexiblen Hochsprachen k√∂nnen Programme schnell entwickelt we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was w√§re wenn ohne Python? Julia f√ºr maschinelles Lernen und allgemein</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/476114/">  Wir wollen immer schnell Code schreiben, aber Sie m√ºssen daf√ºr bezahlen.  In gew√∂hnlichen flexiblen Hochsprachen k√∂nnen Programme schnell entwickelt werden, sie werden jedoch nach dem Start langsam ausgef√ºhrt.  Zum Beispiel ist es ungeheuer langsam, etwas Schweres in reinem Python zu lesen.  C-√§hnliche Sprachen arbeiten viel schneller, aber es ist einfacher, Fehler in ihnen zu machen, deren Suche den Geschwindigkeitsgewinn auf Null reduziert. <br><br>  In der Regel wird dieses Dilemma folgenderma√üen gel√∂st: Zuerst schreiben sie den Prototyp auf etwas Flexibles, zum Beispiel auf Python oder R, und dann schreiben sie ihn auf C / C ++ oder Fortran um.  Aber dieser Zyklus ist zu lang, k√∂nnen Sie darauf verzichten? <br><br><img src="https://habrastorage.org/webt/c0/hu/mw/c0humwwihszecprm5u7-j1ofego.jpeg"><br><br>  Vielleicht gibt es eine L√∂sung.  Julia ist eine hochqualifizierte und flexible Programmiersprache mit hoher Geschwindigkeit.  Julia verf√ºgt √ºber mehrere Versandfunktionen, einen integrierten intelligenten Compiler und Metaprogrammier-Tools.  <strong>Gleb Ivashkevich</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">phtRaveller</a> ), der Gr√ºnder der Datarythmik, der als ehemaliger Physiker maschinelle Lernsysteme f√ºr die Industrie und andere Industrien entwickelt, wird Ihnen mehr √ºber Julia erz√§hlen. <br><br>  Gleb wird erkl√§ren, warum neue Sprachen ben√∂tigt werden und warum manchmal Python fehlt.  Er erkl√§rt Ihnen, was an Julia interessant ist, welche St√§rken und Schw√§chen sie hat, vergleicht sie mit anderen Sprachen und zeigt, welche Aussichten die Sprache auf maschinelles Lernen und Computing im Allgemeinen hat. <br><br>  <em>Haftungsausschluss.</em>  <em>Es wird keine Syntaxanalyse durchgef√ºhrt.</em>  <em>Habrazhiteli hat Erfahrung mit Entwicklern, daher macht es keinen Sinn zu zeigen, wie man zum Beispiel eine Schleife schreibt.</em> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/REVmhiJ1Zi8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Das Problem zweier Sprachen </h2><blockquote>  Wenn Sie Code schnell schreiben, werden Programme langsam ausgef√ºhrt.  Wenn Programme schnell arbeiten, schreiben Sie sie f√ºr eine lange Zeit. </blockquote> Klassisches Python f√§llt in die erste Kategorie.  Wenn Sie NumPy entfernen, sollten Sie etwas in reinem Python langsam in Betracht ziehen.  Auf der anderen Seite gibt es Sprachen wie C und C ++.  Es ist schwierig, ein Gleichgewicht zu finden. Daher schreiben sie in den meisten F√§llen zuerst einen Prototyp f√ºr etwas Flexibles und schreiben ihn nach dem Debuggen des Algorithmus schneller in die Sprache um.  Dies ist ein Beispiel f√ºr ein <strong>klares Problem in zwei Sprachen</strong> : Ein langer Zyklus, in dem Sie in Python schreiben und es beispielsweise in C oder in Cython neu schreiben m√ºssen. <br><br>  Spezialisten f√ºr maschinelles Lernen und Data Science sind NumPy, Sklearn und TensorFlow.  Sie l√∂sen ihre Probleme seit Jahren ohne eine einzige Zeile in C, und es scheint, dass das Problem der beiden Sprachen sie nicht betrifft.  Dies ist nicht so, das Problem manifestiert sich <strong>implizit</strong> , da der Code in NumPy oder TensorFlow eigentlich nicht wirklich Python ist.  Es wird als Metasprache verwendet, um das zu starten, was sich im Inneren befindet.  Darin befindet sich genau C / Fortran (im Fall von NumPy) oder C ++ (im Fall von TensorFlow). <br><br>  Dieses ‚ÄûMerkmal‚Äú ist beispielsweise in PyTorch schlecht sichtbar, in Numpy jedoch deutlich.  Wenn beispielsweise ein klassischer Python-Zyklus <code>for</code> in den Berechnungen enthalten ist, ist ein Fehler aufgetreten.  In produktivem Code werden keine Schleifen ben√∂tigt, Sie m√ºssen alles neu schreiben, damit NumPy es vektorisieren und schnell berechnen kann. <br><br>  Gleichzeitig scheint es vielen, dass NumPy schnell ist und damit alles in Ordnung ist.  Mal sehen, was NumPy unter der Haube hat, um das zu sehen. <br><br><ul><li>  NumPy versucht, das Problem mit der Python-Typflexibilit√§t zu beheben, sodass es ein ziemlich <strong>striktes Typsystem gibt</strong> .  Wenn das Array einen bestimmten Typ hat, kann sich nichts anderes darin befinden, und wenn <code>Float64</code> ist, kann nichts dagegen unternommen werden. </li><li>  <strong>Entsendung.</strong>  Abh√§ngig von den Arten der Arrays und der auszuf√ºhrenden Operation entscheidet NumPy in sich selbst, welche Funktion aufgerufen wird, um die Berechnungen so schnell wie m√∂glich durchzuf√ºhren.  Die Bibliothek versucht, klassisches Python aus der Rechenschleife zu werfen. </li></ul><br>  Es stellt sich heraus, dass Numpy nicht so schnell ist, wie es scheint.  Deshalb gibt es Projekte wie <strong>Cython</strong> oder <strong>Numba</strong> .  Der erste generiert C-Code aus dem "Hybrid" von Python und C, und der zweite kompiliert den Code in Python und dies ist normalerweise schneller. <br><blockquote>  Wenn NumPy wirklich so schnell w√§re, wie es vielen scheint, dann w√ºrde die Existenz von Cython und Numba keinen Sinn ergeben. </blockquote>  Wir schreiben alles in Cython neu, wenn wir schnell etwas Gro√ües und Komplexes finden wollen.  Eines der Kriterien f√ºr die Qualit√§t eines Wrappers in Cython ist das Vorhandensein oder Fehlen von reinen Python-Aufrufen im generierten Code. <br><br>  Ein einfaches Beispiel: Wir addieren den Typ (gut) oder nicht (schlecht) und erhalten zwei v√∂llig unterschiedliche Codes, obwohl die anf√§nglichen Optionen nicht anders sind als die Typen. <br><br><img src="https://habrastorage.org/webt/23/nj/e0/23nje0ddwbpf8c9debfufjvg0h8.png"><br><br>  Wenn wir den C-Code generieren, erhalten wir im ersten Fall Folgendes: <br><br><pre> <code class="cpp hljs">__pyx_t_4 = __pyx_v_i; __pyx_v_result = (__pyx_v_result + (*((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *) ( <span class="hljs-comment"><span class="hljs-comment">/* dim=0 */</span></span> (__pyx_v_a.data + __pyx_t_4 * __pyx_v_a.strides[<span class="hljs-number"><span class="hljs-number">0</span></span>]) ))));</code> </pre> <br>  Und im zweiten <code>result =0.</code>  wird sich in diese verwandeln: <br><br><pre> <code class="cpp hljs">__pyx_t_6 = PyFloat_FromDouble((*((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *) ( <span class="hljs-comment"><span class="hljs-comment">/* dim=0 */</span></span> (__pyx_v_a.data + __pyx_t_4 * __pyx_v_a.strides[<span class="hljs-number"><span class="hljs-number">0</span></span>]) )))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(!__pyx_t_6)) __PYX_ERR(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_6); __pyx_t_7 = PyNumber_InPlaceAdd(__pyx_v_result, __pyx_t_6); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(!__pyx_t_7)) __PYX_ERR(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_7); __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = <span class="hljs-number"><span class="hljs-number">0</span></span>; __Pyx_DECREF_SET(__pyx_v_result, __pyx_t_7); __pyx_t_7 = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Wenn ein Typ angegeben wird, l√§uft der C-Code blitzschnell.  Wenn der Typ nicht angegeben ist, sehen wir normales Python, aber von der C-Seite: Standard-Python-Aufrufe, bei denen aus irgendeinem Grund <code>float</code> aus <code>double</code> , Links gez√§hlt werden und eine Menge anderer Garbage-Codes.  Dieser Code ist langsam, weil er bei jeder Operation Python aufruft. <br><br><h3>  Ist es m√∂glich, alle Probleme auf einmal zu l√∂sen </h3><br>  Es ist lustig, dass wir, wenn wir an etwas denken, versuchen, reines Python zu entfernen.  Hierf√ºr gibt es zwei M√∂glichkeiten. <br><br><ul><li>  Verwenden von <strong>Cython</strong> oder anderen Tools.  Es gibt viele M√∂glichkeiten, wie Sie Ihren Cython-Code optimieren k√∂nnen, um so gut wie keine Python-Aufrufe zu erhalten.  Dies ist jedoch nicht die angenehmste Aktivit√§t: In Cython ist nicht alles so offensichtlich, und es wird nur ein bisschen weniger Zeit aufgewendet, als wenn Sie nur alles in C schreiben. Das resultierende Modul kann in Python verwendet werden, es dauert jedoch lange, Fehler treten auf, der Code ist nicht immer offensichtlich und Es ist nicht immer klar, wie man es optimiert. </li><li>  Mit Numba wird eine <strong>JIT-Kompilierung durchgef√ºhrt</strong> . </li></ul><br>  Aber vielleicht gibt es einen besseren Weg, und ich denke, das ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Julia</a> . <br><br><h2>  Julia </h2><br>  Die Autoren behaupten, dass dies eine <strong>schnelle</strong> , <strong>hochentwickelte</strong> und <strong>flexible</strong> Sprache ist, die in Bezug auf die einfache Code-Erstellung mit Python vergleichbar ist.  Meiner Meinung nach ist Julia wie eine <strong>Skriptsprache:</strong> Sie m√ºssen nicht das tun, was Sie in C tun m√ºssen, wo alles sehr niedrig ist, einschlie√ülich Datenstrukturen.  Gleichzeitig k√∂nnen Sie in einer normalen Konsole arbeiten, z. B. mit Python und anderen Sprachen. <br><br>  Julia verwendet die <strong>Just-In-Time-Kompilierung</strong> - dies ist eines der Elemente, die Geschwindigkeit verleihen.  Aber die Sprache kann gut rechnen, weil sie f√ºr sie entwickelt wurde.  Julia wird f√ºr wissenschaftliche Aufgaben eingesetzt und bekommt ordentliche Leistung. <br><blockquote>  Obwohl Julia versucht, wie eine Allzwecksprache auszusehen, ist Julia gut f√ºr Computer und nicht sehr gut f√ºr Webdienste.  Zum Beispiel ist es nicht die beste Wahl, Julia anstelle von Django zu verwenden. </blockquote>  Betrachten wir die Merkmale der Sprache als Beispiel einer primitiven Funktion. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; methods(f) <span class="hljs-comment"><span class="hljs-comment"># 1 method for generic function "f": [1] f(x) in Main at mpconf.jl:2</span></span></code> </pre> <br>  In diesem Code sind vier Funktionen erkennbar. <br><br><ul><li>  <strong>Es gibt praktisch keine Einschr√§nkungen f√ºr die Verwendung von Unicode</strong> .  Sie k√∂nnen Formeln aus einem Artikel √ºber vertieftes Lernen oder numerisches Modellieren entnehmen, mit denselben Zeichen neu schreiben und alles wird funktionieren - Unicode wird fast √ºberall gen√§ht. </li><li>  <strong>Es gibt kein Multiplikationszeichen.</strong>  Es ist jedoch nicht immer m√∂glich, darauf zu verzichten, zum Beispiel, indem 2.x (eine Gleitkommazahl mal x) Julia schw√∂rt. </li><li>  <strong>Keine <code>return</code></strong> .  Im Allgemeinen wird empfohlen, dass Sie <code>return</code> schreiben <code>return</code> damit Sie sehen k√∂nnen, was gerade passiert. Das Beispiel gibt jedoch <code>Œ±</code> , da die Zuweisung ein Ausdruck ist. </li><li>  <strong>Keine Typen</strong> .  Es scheint, dass, wenn es Geschwindigkeit gibt, irgendwann die Typen erscheinen sollten?  Ja, sie werden erscheinen, aber sp√§ter. </li></ul><br>  Julia verf√ºgt √ºber drei Funktionen, die Flexibilit√§t und Geschwindigkeit <strong>bieten</strong> : <strong>Mehrfachversand, Metaprogrammierung und Parallelit√§t</strong> .  Wir werden √ºber die ersten beiden sprechen und die Parallelisierung dem unabh√§ngigen Studium f√ºr fortgeschrittene Benutzer √ºberlassen. <br><br><h3>  Mehrfachterminierung </h3><br>  Der Aufruf von <code>methods(f)</code> im obigen Beispiel sieht unerwartet aus - √ºber welche Methoden verf√ºgt die Funktion?  Wir sind daran gew√∂hnt, dass wir Klassenobjekte haben, Klassen Methoden.  Aber in Julia ist alles auf den Kopf gestellt: Funktionen haben Methoden, weil die Sprache mehrere Dispatchings verwendet. <br><blockquote>  Mehrfachterminierung bedeutet, dass die auszuf√ºhrende Variante einer bestimmten Funktion durch den gesamten Satz von Parametertypen dieser Funktion bestimmt wird. </blockquote>  Ich werde kurz beschreiben, wie dies an einem bereits bekannten Beispiel funktioniert. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x::<span class="hljs-built_in"><span class="hljs-built_in">AbstractFloat</span></span>) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + sin(x) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; methods(f) <span class="hljs-comment"><span class="hljs-comment"># 2 methods for generic function "f": [1] f(x::AbstractFloat) in Main at mpconf.jl:6 [2] f(x) in Main at mpconf.jl:2</span></span></code> </pre> <br>  Varianten der gleichen Funktion f√ºr verschiedene Typen werden als Methoden bezeichnet.  Der Code enth√§lt zwei Elemente: das erste f√ºr alle Gleitkommazahlen und das zweite f√ºr alles andere.  Wenn wir die Funktion zum ersten Mal aufrufen, wird Julia entscheiden, welche Methode verwendet und ob sie kompiliert werden soll.  Wenn es bereits aufgerufen und kompiliert wurde, √ºbernimmt es das, was ist. <br><br>  Da in Julia nicht alles so ist, wie wir es gewohnt sind, k√∂nnen Sie hier benutzerdefinierte Typen mit Funktionen versehen. Dies sind jedoch keine Typmethoden im Sinne von OOP.  Es wird einfach das Feld sein, in das die Funktion geschrieben wird, da die <strong>Funktion dasselbe vollwertige Objekt ist</strong> wie alles andere. <br><br>  Um herauszufinden, was genau ausgel√∂st wird, gibt es spezielle Makros.  Sie beginnen mit <code>@</code> .  In diesem Beispiel k√∂nnen <code>@which</code> mit dem <code>@which</code> Makro herausfinden, welche Methode f√ºr einen bestimmten Fall aufgerufen wurde. <br><br><img src="https://habrastorage.org/webt/nu/ix/ih/nuixiha2x9r2b148gdqyo81fkri.png"><br><br>  Im ersten Fall entschied Julia, dass 2 eine Ganzzahl ist, die nicht zu <code>AbstractFloat</code> passt, und rief die erste Option auf.  Im zweiten Fall entschied sie, dass es sich um <code>Float</code> und forderte bereits eine spezialisierte Version.  Dies funktioniert ungef√§hr, wenn Sie f√ºr bestimmte Typen andere Methoden hinzuf√ºgen. <br><br><h3>  LLVM und JIT </h3><br>  Julia verwendet das LLVM-Framework zum Kompilieren.  Die JIT-Kompilierungsbibliothek wird in einem Sprachpaket geliefert.  Beim ersten Aufruf der Funktion pr√ºft Julia, ob die Funktion mit diesem Satz von Typen verwendet wurde, und kompiliert ihn gegebenenfalls.  Der erste Start wird einige Zeit in Anspruch nehmen, und dann wird alles schnell funktionieren. <br><blockquote>  Die Funktion wird zum Zeitpunkt des ersten Aufrufs dieses Parametersatzes √ºbersetzt. </blockquote>  Compiler-Funktionen <br><br><ul><li>  <strong>Der Compiler ist vern√ºnftig,</strong> da LLVM ein gutes Produkt ist. </li><li>  Fortgeschrittene Entwickler k√∂nnen <strong>sich den Kompilierungsprozess ansehen</strong> und sehen, was er generiert. </li><li>  <strong>Die Zusammenstellung von Julia und Numba ist √§hnlich</strong> .  In Numba erstellen Sie auch einen JIT-Dekorator, aber in Numba k√∂nnen Sie nicht so oft ‚Äûeinsteigen‚Äú und entscheiden, was optimiert oder ge√§ndert werden soll. </li></ul><br>  Um die Arbeit des Compilers zu veranschaulichen, werde ich ein Beispiel f√ºr eine einfache Funktion geben: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; <span class="hljs-meta"><span class="hljs-meta">@code_llvm</span></span> f(<span class="hljs-number"><span class="hljs-number">2</span></span>) define i64 <span class="hljs-meta"><span class="hljs-meta">@julia_f_35897</span></span>(i64) { top: %<span class="hljs-number"><span class="hljs-number">1</span></span> = mul i64 %<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> %<span class="hljs-number"><span class="hljs-number">2</span></span> = add i64 %<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ret i64 %<span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre><br>  Mit dem Makro <code>@code_llvm</code> k√∂nnen Sie das Ergebnis der Generierung <code>@code_llvm</code> .  Diese <strong>LLVM-IR</strong> ist <strong>eine Zwischendarstellung</strong> , eine Art Assembler. <br><br>  Im Code wird das Funktionsargument mit 3 multipliziert, zum Ergebnis wird 1 addiert, das Ergebnis wird zur√ºckgegeben.  Alles ist so einfach wie m√∂glich.  Wenn Sie die Funktion etwas anders definieren, z. B. 3 durch 2 ersetzen, √§ndert sich alles. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; <span class="hljs-meta"><span class="hljs-meta">@code_llvm</span></span> f(<span class="hljs-number"><span class="hljs-number">2</span></span>) define i64 <span class="hljs-meta"><span class="hljs-meta">@julia_f_35894</span></span>(i64) { top: %<span class="hljs-number"><span class="hljs-number">1</span></span> = shl i64 %<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> %<span class="hljs-number"><span class="hljs-number">2</span></span> = or i64 %<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ret i64 %<span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre> <br>  Es scheint, was ist der Unterschied: 2, 3, 10?  Aber Julia und LLVM sehen, dass Sie etwas schlauer vorgehen k√∂nnen, wenn Sie eine Funktion f√ºr eine Ganzzahl aufrufen.  Das Multiplizieren mit zwei Ganzzahlen ist eine Linksverschiebung um ein Bit - es ist schneller als das Produkt.  Dies funktioniert nat√ºrlich nur f√ºr Ganzzahlen. Es funktioniert jedoch nicht, <code>Float</code> um 1 Bit <code>Float</code> links zu verschieben und das Ergebnis der Multiplikation mit 2 zu erhalten. <br><br><h3>  Benutzerdefinierte Typen </h3><br>  Benutzerdefinierte Typen in Julia sind genauso schnell wie integrierte Typen.  Bei ihnen wird eine Mehrfachplanung durchgef√ºhrt, die genauso schnell ist wie bei integrierten Typen.  In diesem Sinne ist der Mehrfachversand-Mechanismus tief in die Sprache eingebettet. <br><br>  Es ist logisch zu erwarten, dass Variablen keine Typen haben, sondern nur Werte.  Variablen ohne Typ sind nur eine Markierung, eine Bezeichnung auf einem Container. <br><br>  <strong>Das Typensystem ist hierarchisch.</strong>  Wir k√∂nnen keine Nachkommen konkreter Typen erstellen, abstrakte Typen k√∂nnen sie nur haben.  Abstrakte Typen k√∂nnen jedoch nicht instanziiert werden.  Diese Nuance wird nicht jeden ansprechen. <br><br>  Wie die Autoren der Sprache erkl√§rten, als sie Julia entwickelten, wollten sie das Ergebnis erhalten, und wenn es schwierig war, etwas zu tun, lehnten sie es ab.  Ein solches hierarchisches Typensystem war einfacher zu entwickeln.  Dies ist kein katastrophales Problem, aber wenn Sie den Kopf zuerst nicht umdrehen, ist dies unpraktisch. <br><br>  <strong>Typen k√∂nnen parametrisiert werden</strong> , √§hnlich wie in C / C ++.  Zum Beispiel k√∂nnen wir eine Struktur haben, in der es Felder gibt, aber die Typen dieser Felder sind nicht spezifiziert - dies sind Parameter.  Bei der Instanziierung geben wir einen bestimmten Typ an. <br><br>  <strong>In den meisten F√§llen k√∂nnen Typen √ºbersprungen werden</strong> .  Normalerweise werden sie ben√∂tigt, wenn der Typ dem Compiler hilft, zu erraten, wie er am besten kompiliert.  In diesem Fall ist es besser, die Typen anzugeben.  Sie m√ºssen auch Typen angeben, wenn Sie eine bessere Leistung erzielen m√∂chten. <br><br>  Mal sehen, was m√∂glich ist und was nicht instanziiert werden kann. <br><br><img src="https://habrastorage.org/webt/0r/xr/bl/0rxrbllszhjk9okl1-3irj1zdns.png"><br><br>  Der erste Typ von <code>AbstractPoint</code> kann nicht instanziiert werden.  Dies ist nur ein gemeinsames √ºbergeordnetes Element f√ºr alle Benutzer, die wir beispielsweise in Methoden angeben k√∂nnen.  Die zweite Zeile besagt, dass <code>PlanarPoint{T}</code> ein Nachkomme dieses abstrakten Punktes ist.  Unterhalb der Felder beginnen - hier sehen Sie die Parametrierung.  Sie k√∂nnen hier ein <code>float</code> , <code>int</code> oder einen anderen Typ eingeben. <br><br>  Der erste Typ kann nicht instanziiert werden, und f√ºr den Rest ist es unm√∂glich, Nachkommen zu erstellen.  Au√üerdem sind sie standardm√§√üig <strong>unver√§nderlich</strong> .  Um die Felder √§ndern zu k√∂nnen, muss dies explizit angegeben werden. <br><br>  Wenn alles fertig ist, k√∂nnen Sie beispielsweise die Entfernung f√ºr verschiedene Arten von Punkten berechnen.  Im Beispiel ist der erste Punkt auf der Ebene <code>PlanarPoint</code> , dann auf der Kugel und auf dem Zylinder.  Je nachdem, zwischen welchen zwei Punkten wir den Abstand berechnen, m√ºssen wir verschiedene Methoden anwenden.  Im Allgemeinen sieht die Funktion folgenderma√üen aus: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> describe(p::AbstractPoint) println(<span class="hljs-string"><span class="hljs-string">"Point instance: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$p</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  F√ºr <code>Float64</code> , <code>Float32</code> , <code>Float16</code> es sein: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> distance(pf::PlanarPoint{T}, ps::PlanarPoint{T}) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">AbstractFloat</span></span> sqrt((pf.x-ps.x)^<span class="hljs-number"><span class="hljs-number">2</span></span> + (pf.y-ps.y)^<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Und f√ºr ganze Zahlen sieht die Entfernungsberechnungsmethode folgenderma√üen aus: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> distance(pf::PlanarPoint{T}, ps::PlanarPoint{T}) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span> abs(pf.x-ps.x) + abs(pf.y-ps.y) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  F√ºr Punkte jedes Typs werden unterschiedliche Methoden aufgerufen. <br><br><img src="https://habrastorage.org/webt/ya/8n/_d/ya8n_dvihkdqpsmqfkmdl5wm_ro.png"><br><br>  Wenn Sie schummeln und zum Beispiel <code>distance(f1, i2)</code> anwenden, schw√∂rt Julia: ‚ÄûIch kenne diese Methode nicht!  Sie haben mich nach solchen Methoden gefragt und gesagt, dass beide vom selben Typ sind.  Du hast mir nicht gesagt, wie ich das z√§hlen soll, wenn ein Parameter <code>float</code> und der andere <code>int</code> . " <br><br><h3>  Geschwindigkeit </h3><br>  Sie haben sich vielleicht schon gefreut: ‚ÄûEs gibt eine JIT-Zusammenstellung: Das Schreiben ist einfach, es wird schnell gehen.  Wirf Python raus und fang an, in Julia zu schreiben! ‚Äú <br><br>  Aber nicht so einfach.  Nicht jedes Feature in Julia wird schnell sein.  Das h√§ngt von zwei Faktoren ab. <br><br><ul><li>  <strong>Vom Entwickler</strong> .  Es gibt keine Sprachen, in denen eine Funktion schnell ist.  Ein unerfahrener Entwickler schreibt sogar Code in C, der viel langsamer arbeitet als der Python-Code eines erfahrenen Entwicklers.  Jede Sprache hat ihre eigenen Tricks und Nuancen, von denen die Leistung abh√§ngt.  Der Compiler, egal ob es sich um einen regul√§ren statischen oder einen JIT-Compiler handelt, kann nicht alle denkbaren Optionen bereitstellen und alles √ºberhaupt optimieren. </li><li>  <strong>Aus Typenstabilit√§t</strong> .  In einer schnelleren Version werden typstabile Funktionen kompiliert. </li></ul><br><h3>  Typstabilit√§t </h3><br>  Was ist Typstabilit√§t?  Wenn der Compiler nicht verl√§sslich genug erraten kann, was mit den Typen passiert, muss er eine Menge Wrapper-Code generieren, damit alles funktioniert, was an die Eingabe gelangt. <br><br>  Ein einfaches Beispiel, um die Typstabilit√§t zu verstehen. <br><br><img src="https://habrastorage.org/webt/ye/83/jv/ye83jvzws3gkfjvobwf6xvtlpaq.png"><br><br>  Experten f√ºr maschinelles Lernen werden sagen, dass dies eine normale relu-Aktivierung ist: Wenn x&gt; 0, geben Sie es so zur√ºck, wie es ist, andernfalls geben Sie Null zur√ºck.  Ein Problem ist die Null nach der Ganzzahl des Fragezeichens.  Dies bedeutet, dass, wenn wir diese Funktion f√ºr eine Gleitkommazahl aufrufen, in einem Fall eine Gleitkommazahl und in dem anderen eine Ganzzahl zur√ºckgegeben wird. <br><br>  Der Compiler kann den Ergebnistyp nicht nur anhand des Funktionsargumenttyps erraten.  Er muss auch die Bedeutung kennen.  Daher wird viel Code generiert. <br><br>  Als n√§chstes erstellen wir ein Array von 100 pro 100 Zufallszahlen von 0 bis 1, verschieben es um 0,5, um positive und negative Zahlen gleichm√§√üig zu verteilen, und messen das Ergebnis.  Es gibt zwei interessante Punkte: den Punkt und die Funktion.  Der Punkt nach <code>rand(100,100)</code> bedeutet "auf jedes Element anwenden".  Wenn Sie eine Art Sammlung und Skalarfunktion haben, setzen Sie dieser ein Ende, und Julia wird den Rest erledigen.  Wir k√∂nnen davon ausgehen, dass dies genauso effektiv ist wie eine normale Schleife in einer normalen kompilierten Sprache.  Sie brauchen nicht zu schreiben - alles wird f√ºr Sie erledigt. <br><br>  Derzeit gibt es keine Probleme - das <strong>Problem liegt in der Funktion selbst</strong> .  Die gesch√§tzte Ausf√ºhrungszeit einer solchen Option auf einem anst√§ndigen Computer f√ºr eine solche Matrix betr√§gt Mikrosekunden.  Aber in Wirklichkeit - Millisekunden, das ist zu viel f√ºr solch eine winzige Matrix. <br><br>  √Ñndern Sie nur eine Zeile. <br><br><img src="https://habrastorage.org/webt/bt/3g/4t/bt3g4t3kgng3thzuyb75mi_bmzw.png"><br><br>  Die ausgef√ºhrte Funktion <code>zero(x)</code> generiert eine Null des gleichen Typs wie das Argument <code>(x)</code> .  Dies bedeutet, dass unabh√§ngig vom Wert von <code>x</code> die Art des Ergebnisses immer der Art von <code>x</code> selbst bekannt ist. <br><blockquote>  Wenn wir uns nur die Art der Argumente ansehen und die Art des Ergebnisses bereits kennen, sind dies Funktionen, die typstabil sind. </blockquote>  Wenn wir uns die Bedeutung der Argumente ansehen m√ºssen, sind dies keine stabilen Funktionen. <br><br>  Wenn der Compiler den Code optimieren kann, wird der Unterschied in der Ausf√ºhrungszeit um zwei Gr√∂√üenordnungen erhalten.  Im zweiten Beispiel wurde es nur genau einem neuen Array zugewiesen, ein paar Dutzend Bytes mehr und nichts mehr.  Diese Option ist viel effektiver als die vorherige. <br><br>  Dies ist die Hauptsache, auf die Sie achten m√ºssen, wenn Sie Code in Julia schreiben.  Wenn Sie wie in Python schreiben, funktioniert dies wie in Python.  Wenn Sie die gleichen Operationen mit NumPy ausf√ºhren, spielt die Null mit oder ohne Punkt keine Rolle.  Bei Julia kann dies die Leistung erheblich beeintr√§chtigen. <br><br>  Gl√ºcklicherweise gibt es eine Methode, um herauszufinden, ob ein Problem vorliegt.  Dies ist das Makro <code>@code_warntype</code> , mit dem Sie herausfinden k√∂nnen, ob der Compiler erraten kann, wo sich welche Typen befinden, und optimieren, ob alles in Ordnung ist. <br><br><img src="https://habrastorage.org/webt/bg/jp/xf/bgjpxfne2jxskxqaloz2omljbda.png"><br><br>  In der ersten Option (links) ist sich der Compiler des Typs nicht sicher und zeigt ihn in rot an.  Im zweiten Fall gibt es f√ºr ein solches Argument immer <code>Float64</code> , sodass Sie Code viel k√ºrzer generieren k√∂nnen. <br><br>  Dies ist noch keine LLVM, aber der beschriftete Julia-Code, <code>return 0</code> oder <code>return 0.0</code> ergibt einen Leistungsunterschied von zwei Gr√∂√üenordnungen. <br><br><h3>  Metaprogrammierung </h3><blockquote>  Metaprogrammierung ist, wenn wir Programme in einem Programm erstellen und sie unterwegs ausf√ºhren. </blockquote>  Dies ist eine leistungsstarke Methode, mit der Sie viele verschiedene interessante Dinge tun k√∂nnen.  Ein klassisches Beispiel ist Django ORM, bei dem Felder mithilfe von Metaklassen erstellt werden. <br><br>  Vielen ist der Haftungsausschluss von <strong>Tim Peters</strong> , Autor von Zen of Python, bekannt: <i>‚ÄûMetaklassen sind eine tiefgreifende Magie, √ºber die sich 99% der Benutzer niemals Gedanken machen sollten.</i>  <i>Wenn Sie sich fragen, ob Metaklassen in Python ben√∂tigt werden, brauchen Sie sie nicht.</i>  <i>Wenn Sie sie brauchen, wissen Sie genau, warum und wie Sie sie verwenden m√ºssen. ‚Äú</i> <i><br></i> <br>  Bei der Metaprogrammierung ist die Situation √§hnlich, aber bei Julia ist sie viel tiefer gen√§ht, dies ist ein wichtiges Merkmal der gesamten Sprache.  Julia-Code hat dieselbe Datenstruktur wie jeder andere. Sie k√∂nnen Ausdr√ºcke bearbeiten, kombinieren und erstellen, und all dies funktioniert. <br><br><pre> <code class="julia hljs">julia&gt; x = <span class="hljs-number"><span class="hljs-number">4</span></span>; julia&gt; typeof(:(x+<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-built_in"><span class="hljs-built_in">Expr</span></span> julia&gt; expr = :(x+<span class="hljs-number"><span class="hljs-number">1</span></span>) :(x + <span class="hljs-number"><span class="hljs-number">1</span></span>) julia&gt; expr.head :call julia&gt; expr.args <span class="hljs-number"><span class="hljs-number">3</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: :+ :x <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  <strong>Makros sind eines der Metaprogrammierwerkzeuge in Julia</strong> : Wir geben ihnen etwas, sie schauen, f√ºgen das Richtige hinzu, entfernen das Unn√∂tige und geben das Ergebnis.  In allen vorherigen Beispielen haben wir den Aufruf an die Funktion √ºbergeben, und das Makro im Inneren hat den Aufruf analysiert.  All dies geschieht auf der Ebene der Arbeit mit dem Syntaxbaum. <br><br>  Sie k√∂nnen sehr einfache Ausdr√ºcke analysieren: Wenn es sich beispielsweise um <code>(x+1)</code> , ist dies ein Aufruf der Funktion <code>+</code> (der Zusatz ist kein Operator, wie in vielen anderen Sprachen, sondern eine Funktion) und zwei Argumente: Ein Zeichen (ein Doppelpunkt bedeutet, dass es sich um ein Zeichen handelt) ), und die zweite ist nur eine Konstante. <br><br>  Ein weiteres einfaches Makrobeispiel: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">macro</span></span> named(name, expr) println(<span class="hljs-string"><span class="hljs-string">"Starting </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">quote</span></span> $(esc(expr)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; <span class="hljs-meta"><span class="hljs-meta">@named</span></span> <span class="hljs-string"><span class="hljs-string">"some process"</span></span> x=<span class="hljs-number"><span class="hljs-number">5</span></span>; Starting some process julia&gt; x <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br>  Beispielsweise werden mithilfe von Makros Fortschrittsanzeigen oder Filter f√ºr Datenrahmen erstellt - dies ist ein in Julia √ºblicher Mechanismus. <br><blockquote>  Makros werden nicht zum Zeitpunkt des Aufrufs ausgef√ºhrt, sondern beim Parsen des Codes. </blockquote>  Dies ist die Hauptmakrofunktion in Julia.  -    ,       .   ,   ,       . <br><br><h3> ,      </h3><br> Julia ‚Äî     .      . <br><br><ul><li> Julia  <strong> </strong> .       . </li><li> <strong> </strong> ,    .    ,   ,  C    . </li><li>  Julia <strong>JIT-  </strong> .   ,  , ,   ,    . </li><li>     ‚Äî <strong> </strong> .      . </li><li> <strong>    </strong>     ( ).       ,         .    ,    ,    . </li><li> Julia  <strong></strong> ‚Äî      . </li></ul><br><h2>  √ñkosystem </h2><br>  ,    ,   Julia   .    ,     , data science   ,    ,  ,     Python. ,  Python  Pandas,      ,    ,    ,   Julia      . <br><br>  Julia  ,       Python 2008 .        Python,        ,    Julia.    ,     .    ,    Julia. <br><br><h3>   ( ) Python  Julia </h3><br> <strong> </strong> .    Julia:  , ,    .‚Ä¶ <br><br> <strong></strong> .   . <br><br><ul><li> <strong>DataFrames.jl</strong> . </li><li>   <strong>JuliaDB</strong>     ,       . </li><li>        <strong>Query.jl</strong> .     Pandas ‚Äî    - ,   .. </li></ul><br> <strong>Plotting</strong> .     <strong>Matplotlib</strong> ,         Julia.     :  <strong>VegaLite.jl</strong> ,   <strong>Plots.jl</strong> ,     ,  <strong>Gadfly.jl</strong> . <br><br> <strong> </strong> .    <strong>TensorFlow</strong> ,     Flux.jl.    Flux    , ,     ,   Keras  TensorFlow,   .      . <br><br> <strong>Scikit-learn</strong> .   ,  ,     sklearn,    ,  . <br><br> <strong>XGBoost</strong> .  ,  Julia   . <br><br><h3>     ? </h3><br>     <strong>Jupyter</strong> . IDE ‚Äî  Juno,    Visual Studio,         . <br><br> <strong></strong> .  GPU/TPU  .  CUDAnative.jl    Julia     .    Julia-,    -     ,        .    ,      ,      , , . <br><br> <strong> :</strong>   C, Fortran, Python   . <br><br> <strong> </strong>   ,    . <br><br> <strong>Packaging</strong> :      Julia:      , ,   .. <br><br><h3>   </h3><br>      ,      ,   .  ,   ,    .   ,   <strong>PyTorch</strong>       ,  TensorFlow,     ,        . <br><br>      ,        , ,      .      Julia,   , ,      .   ,   <strong> </strong> ,  <strong>Zygote.jl</strong> .     Flux.jl. <br><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Zygote julia&gt; <span class="hljs-literal"><span class="hljs-literal">œÜ</span></span>(x) = x*sin(x) julia&gt; Zygote.gradient(<span class="hljs-literal"><span class="hljs-literal">œÜ</span></span>, <span class="hljs-literal"><span class="hljs-literal">œÄ</span></span>/<span class="hljs-number"><span class="hljs-number">2.</span></span>) (<span class="hljs-number"><span class="hljs-number">1.0</span></span>,) julia&gt; model = Chain(Dense(<span class="hljs-number"><span class="hljs-number">768</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, relu), Dense(<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>), softmax) julia&gt; loss(x, y) = crossentropy(model(x), y) + sum(norm, params(model)) julia&gt; optimizer = ADAM(<span class="hljs-number"><span class="hljs-number">0.001</span></span>) julia&gt; Flux.train!(loss, params(model), data, optimizer) julia&gt; model = Chain(x -&gt; sqrt(x), x-&gt;x-<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>     <code>œÜ</code>  , , ,       . <br><br>  Zygote   ¬´source-to-source¬ª:         ,    ,   .   <strong>differentiable programming ‚Äî  </strong> ‚Äî       backpropagation     ,    . <br><br>     Julia     : ¬´source-to-source¬ª          ,      . ,     . <br><br><h2>  Julia  ? </h2><br>     ,         ‚Äî  .        . <br><br>   - , , ,       ‚Äî . <br><br>    ,   ,  . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Julia</a> ,   . <br><br><ul><li>     ,  ,    . Julia   ¬´¬ª . </li><li>    ,     API,     ,    . </li></ul><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Moscow Python Conf++</a>    ,  27   ,          Python  Julia.   ,     ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">telegram-</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  MoscowPython. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476114/">https://habr.com/ru/post/de476114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476104/index.html">Verwenden Sie kein freies MTProxy und keine anderen Arten von freien Proxys ...</a></li>
<li><a href="../de476106/index.html">"Cryptosystems Protocols": Diffie - Hellman, El-Gamal, MTI / A (0), STS</a></li>
<li><a href="../de476108/index.html">Ver√§nderliches Gehirn</a></li>
<li><a href="../de476110/index.html">Warum braucht die IT eine pers√∂nliche Marke?</a></li>
<li><a href="../de476112/index.html">Elixier als Entwicklungsziel f√ºr Python Async</a></li>
<li><a href="../de476118/index.html">Zeichne einen Havel-Ring aus Dark Souls 3</a></li>
<li><a href="../de476122/index.html">"H√∂re" den Kosmos: von der dunklen Materie zum Kometen Churyumov - Gerasimenko</a></li>
<li><a href="../de476126/index.html">So testen Sie die Serverleistung: Eine Auswahl verschiedener Open Source-Benchmarks</a></li>
<li><a href="../de476128/index.html">Ivan Osipov und Yuri Artamonov √ºber Kotlin und Plugins f√ºr IntelliJ IDEA beim Treffen von jug.msk.ru</a></li>
<li><a href="../de476134/index.html">MONQ - Monitoring und AIOps urspr√ºnglich aus Russland</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>