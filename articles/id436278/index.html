<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♉️ 👍🏾 🌈 Memverifikasi proyek CDK dengan IntelliJ IDEA Static Analyzer 〰️ ♌️ 🌧️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya memutuskan untuk menguji penganalisis kode Java statis IntelliJ IDEA dan, dengan itu, menguji proyek The Chemistry Development Kit . Di sini saya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memverifikasi proyek CDK dengan IntelliJ IDEA Static Analyzer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains/blog/436278/"><p>  Saya memutuskan untuk menguji penganalisis kode Java statis IntelliJ IDEA dan, dengan itu, menguji proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Chemistry Development Kit</a> .  Di sini saya akan memberikan beberapa kesalahan yang saya temukan.  Saya pikir beberapa dari mereka adalah tipikal untuk program Java secara keseluruhan, sehingga mereka bisa menarik. </p><br><p>  The Chemistry Development Kit adalah perpustakaan Java sumber terbuka untuk menyelesaikan masalah chemoinformatika dan bioinformatika.  Ketika saya terlibat dalam bioinformatika, kami secara aktif menggunakannya.  Proyek ini telah dikembangkan selama lebih dari 20 tahun, memiliki puluhan penulis, dan kualitas kode di sana sangat tidak merata.  Namun demikian, ada tes unit dalam proyek, dan integrasi dengan penganalisa cakupan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JaCoCo</a> ditentukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pom.xml</a> .  Selain itu, plugin untuk tiga analisis statis dikonfigurasikan di sana: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FindBugs</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PMD</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Checkstyle</a> .  Semakin menarik untuk memeriksa peringatan yang tersisa. </p><a name="habracut"></a><br><p>  Alat analisis kode Java statis yang dibangun ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IntelliJ IDEA</a> tidak kalah dengan alat analisis statis khusus, tetapi dalam beberapa hal melampaui mereka.  Selain itu, hampir semua kemampuan analisis statis tersedia dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Community Edition</a> , sebuah IDE open source gratis.  Khususnya, versi gratis menghasilkan semua peringatan yang dijelaskan dalam artikel ini. </p><br><p>  Secara default, analisis statis dilakukan terus-menerus dalam mode pengeditan kode, jadi jika Anda menulis kode di IntelliJ IDEA, maka Anda akan memperbaiki banyak kesalahan secara harfiah dalam beberapa detik setelah dibuat, bahkan sebelum menjalankan tes.  Anda dapat memeriksa seluruh proyek atau bagiannya dalam mode batch menggunakan <em>Analisis |</em>  <em>Periksa Kode</em> atau jalankan inspeksi terpisah menggunakan <em>Analisis |</em>  <em>Jalankan Inspeksi berdasarkan Nama</em> .  Dalam hal ini, beberapa inspeksi menjadi tersedia yang, karena kerumitannya, tidak berfungsi dalam mode edit.  Namun, ada beberapa inspeksi semacam itu. </p><br><p> Banyak inspeksi IntelliJ IDEA tidak melaporkan bug, melainkan kode yang tidak akurat atau menawarkan alternatif yang lebih idiomatis, indah, atau cepat.  Ini berguna ketika Anda terus-menerus bekerja di IDE.  Namun, dalam kasus saya, lebih baik memulai dengan pesan-pesan yang memperingatkan tentang bug nyata.  Pada dasarnya, kategori <em>Java</em> menarik <em>|</em>  <em>Kemungkinan Bug</em> , meskipun ada kategori lain yang perlu ditelusuri, seperti <em>Masalah Numerik</em> . </p><br><p>  Saya hanya akan memberi tahu Anda tentang beberapa peringatan menarik. </p><br><h3 id="1-unarnyy-plyus">  1. Unary plus </h3><br><p> Sudah ada 66 plus unary dalam proyek ini.  Untuk menulis <code>+1</code> bukannya hanya <code>1</code> kadang-kadang saya ingin menjadi cantik.  Namun, dalam beberapa kasus, plus unary muncul jika alih-alih <code>+=</code> <a href="">menulis</a> <code>=+</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> totalCharge1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (atoms1.hasNext()) { totalCharge1 = +((IAtom) atoms1.next()).getFormalCharge(); } Iterator&lt;IAtom&gt; atoms2 = products.atoms().iterator(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> totalCharge2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (atoms2.hasNext()) { totalCharge2 = +((IAtom) atoms2.next()).getFormalCharge(); }</code> </pre> <br><p>  Kesalahan ketik yang jelas yang mengabaikan semua iterasi loop kecuali yang terakhir.  Mungkin tampak aneh bahwa itu tidak ditulis "ruang sama dengan ruang plus", tetapi "ruang sama dengan ruang plus".  Namun, keanehan menghilang jika Anda <a href="">mempelajari sejarah</a> .  Awalnya, "sama" dan "plus" benar-benar ada, tetapi pada 2008 mereka pergi melalui formatter otomatis, dan kode berubah.  Ngomong-ngomong, ini adalah moral untuk analisa statis: masuk akal untuk mengeluarkan peringatan berdasarkan pemformatan aneh, tetapi jika kode diformat secara otomatis, peringatan akan hilang dan bug akan tetap ada. </p><br><h3 id="2-celochislennoe-delenie-s-privedeniem-k-drobnomu">  2. Pembagian integer yang mengarah ke pecahan </h3><br><p>  Sebuah kesalahan yang agak menjengkelkan, tetapi analisa statis menemukannya dengan baik.  Berikut ini <a href="">sebuah contoh</a> : </p><br><pre> <code class="java hljs">angle = <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">180</span></span> * Math.PI;</code> </pre> <br><p>  Sayangnya, sudutnya ternyata bukan satu derajat, tetapi nol.  <a href="">Kesalahan serupa</a> : </p><br><pre> <code class="java hljs">Integer c1 = features1.get(key); Integer c2 = features2.get(key); c1 = c1 == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : c1; c2 = c2 == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : c2; sum += <span class="hljs-number"><span class="hljs-number">1.0</span></span> - Math.abs(c1 - c2) / (c1 + c2); <span class="hljs-comment"><span class="hljs-comment">// integer division in floating-point context</span></span></code> </pre> <br><p>  Tampaknya kedua angka <code>c1</code> dan <code>c2</code> non-negatif, yang berarti bahwa perbedaan modulus tidak akan pernah melebihi jumlah.  Oleh karena itu, hasilnya akan menjadi 0 jika kedua angka bukan nol, atau 1 jika salah satunya adalah 0. </p><br><h3 id="3-vyzov-classgetclass">  3. Panggil Class.getClass () </h3><br><p>  Kadang-kadang orang memanggil metode <code>getClass()</code> pada objek bertipe <code>Class</code> .  Hasilnya lagi objek bertipe <code>Class</code> dengan nilai konstan <code>Class.class</code> .  Ini biasanya kesalahan: <code>getClass()</code> tidak perlu dipanggil.  Sebagai contoh, di <a href="">sini</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends ICDKObject&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ofClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; intf, Object... objects)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!intf.isInterface()) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"expected interface, got "</span></span> + intf.getClass()); ...</code> </pre> <br><p>  Jika pengecualian terjadi, melaporkannya akan sama sekali tidak berguna.  By the way, kesalahan dalam prosedur penanganan kesalahan sering ditemukan oleh analisis statis di proyek-proyek lama: sebagai aturan, prosedur penanganan kesalahan diuji yang terburuk. </p><br><h3 id="4-vyzov-tostring-na-massive">  4. Panggil toString () pada sebuah array </h3><br><p>  Ini adalah genre klasik: toString () tidak didefinisikan ulang untuk array, dan hasilnya cukup berguna.  Biasanya ini dapat ditemukan dalam <a href="">pesan diagnostik</a> . </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] dim = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Dim:"</span></span> + dim + <span class="hljs-string"><span class="hljs-string">" SizeX:"</span></span> + grid.length + <span class="hljs-string"><span class="hljs-string">" SizeY:"</span></span> + grid[<span class="hljs-number"><span class="hljs-number">0</span></span>].length + <span class="hljs-string"><span class="hljs-string">" SizeZ:"</span></span>...</code> </pre> <br><p>  Sulit untuk memperhatikan masalah dengan mata, karena di sini <code>dim.toString()</code> implisit, tetapi string concatenation mendelegasikannya.  Perbaikan segera disarankan - bungkus dalam <code>Arrays.toString(dim)</code> . </p><br><h3 id="5-kollekciya-chitaetsya-no-ne-zapolnyaetsya">  5. Koleksi dibaca tetapi tidak diisi </h3><br><p>  Ini, juga, sering ditemukan dalam basis kode yang tidak menjalani pengujian konstan oleh penganalisa statis.  Ini adalah <a href="">contoh sederhana</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Set&lt;IBond&gt; bondsToHydrogens = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;IBond&gt;(); <span class="hljs-comment"><span class="hljs-comment">// ... 220  ,  bondsToHydrogens   ! for (IBond bondToHydrogen : bondsToHydrogens) //     sgroup.removeBond(bondToHydrogen);</span></span></code> </pre> <br><p>  Tentunya pengisian baru saja terlewat.  Analisis statis memiliki pemeriksaan yang lebih sederhana yang menunjukkan variabel yang tidak digunakan, tetapi variabel tersebut digunakan di sini, sehingga mereka diam.  Kami membutuhkan inspeksi yang lebih cerdas yang tahu tentang koleksi. </p><br><h3 id="6-naoborot-zapolnyaem-no-ne-chitaem">  6. Sebaliknya: kita mengisi, tetapi tidak membaca </h3><br><p>  Kasus sebaliknya juga dimungkinkan.  Berikut ini adalah <a href="">contoh dengan array</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] tmp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[trueBits.length - <span class="hljs-number"><span class="hljs-number">1</span></span>]; System.arraycopy(trueBits, <span class="hljs-number"><span class="hljs-number">0</span></span>, tmp, <span class="hljs-number"><span class="hljs-number">0</span></span>, i); System.arraycopy(trueBits, i + <span class="hljs-number"><span class="hljs-number">1</span></span>, tmp, i, trueBits.length - i - <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Inspeksi tahu bahwa argumen ketiga ke metode arraycopy hanya digunakan untuk menulis array, dan setelah itu array tidak digunakan sama sekali.  Dilihat oleh logika kode, baris <code>trueBits = tmp;</code> dilewati <code>trueBits = tmp;</code>  . </p><br><h3 id="7-sravnenie-integer-po-">  7. Perbandingan Integer dengan == </h3><br><p>  Ini adalah bug yang berbahaya, karena nilai kecil dari objek Integer di-cache, dan semuanya dapat bekerja dengan baik sampai suatu hari jumlahnya melebihi 127. Masalah seperti itu mungkin tidak <a href="">jelas sama sekali</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>; a &lt; cliqueSize; a++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">0</span></span>; b &lt; vecSize; b += <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliqueList.get(a) == compGraphNodes.get(b + <span class="hljs-number"><span class="hljs-number">2</span></span>)) { cliqueMapping.add(compGraphNodes.get(b)); cliqueMapping.add(compGraphNodes.get(b + <span class="hljs-number"><span class="hljs-number">1</span></span>)); } } }</code> </pre> <br><p>  Nah, tampaknya beberapa objek dalam beberapa daftar dibandingkan, mungkin semuanya baik-baik saja.  Orang harus berhati-hati untuk melihat bahwa daftar ini berisi objek bertipe Integer. </p><br><h3 id="8-dublikat-v-map">  8. Gandakan di Peta </h3><br><p>  Dalam inspeksi ini, sebuah gambar bernilai ribuan kata.  <a href="">Lihat kesalahannya</a> ? <br><img src="https://habrastorage.org/webt/xc/ha/jh/xchajhzrjrstzxdo3uod6yatxue.png"></p><br><div class="spoiler">  <b class="spoiler_title">Apakah ini lebih baik?</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/dr/pi/n0/drpin0xkjvcmgrkqygsldhcl5ws.png"></p></div></div><br><h3 id="9-ne-ispolzuetsya-rezultat-metoda">  9. Hasil dari metode ini tidak digunakan. </h3><br><p>  Hasil dari beberapa metode adalah bodoh untuk tidak digunakan, yang dengan <a href="">mudah dilaporkan</a> IDEA: </p><br><pre> <code class="java hljs">currentChars.trim();</code> </pre> <br><p>  Mungkin, itu berarti <code>currentChars = currentChars.trim();</code>  .  Karena string di Jawa tidak berubah, jika hasilnya tidak dipindahkan, tidak ada yang akan terjadi.  Juga ditemukan, <a href="">misalnya</a> , <code>str.substring(2)</code> . </p><br><p>  Omong-omong, ini adalah pemeriksaan yang agak rumit.  Selain daftar metode yang telah disiapkan, kami terkadang mencoba untuk secara otomatis menentukan metode yang hasilnya layak digunakan.  Di sini, sebuah analisis antar prosedur diperlukan, baik dalam teks sumber maupun dalam bytecode perpustakaan.  Dan semua ini dilakukan dengan cepat dalam proses mengedit kode! </p><br><h3 id="10-nedostizhimye-vetki-switch">  10. Cabang switch yang tidak terjangkau </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// if character is out of scope don't if (c &gt; 128) return 0; switch (c) { case '\u002d': // hyphen case '\u2012': // figure dash case '\u2013': // en-dash case '\u2014': // em-dash case '\u2212': // minus return '-'; // 002d default: return c; }</span></span></code> </pre> <br><p>  Karena kami mengecualikan karakter dengan kode lebih besar dari 128, cabang <code>\u2012-\u2212</code> tidak <code>\u2012-\u2212</code> dijangkau.  Tampaknya itu tidak layak dikecualikan. </p><br><h3 id="11-nedostizhimoe-uslovie">  11. Kondisi yang tidak terjangkau </h3><br><p>  Masalah yang sangat luar biasa dalam <a href="">rantai kondisi</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oxNum == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hybrid.equals(<span class="hljs-string"><span class="hljs-string">"sp3"</span></span>)) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hybrid.equals(<span class="hljs-string"><span class="hljs-string">"sp2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">47</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oxNum == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; hybrid.equals(<span class="hljs-string"><span class="hljs-string">"sp3"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">47</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((oxNum == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; hybrid.equals(<span class="hljs-string"><span class="hljs-string">"sp3"</span></span>)) || (oxNum == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; hybrid.equals(<span class="hljs-string"><span class="hljs-string">"sp2"</span></span>)) || (oxNum == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; hybrid.equals(<span class="hljs-string"><span class="hljs-string">"sp"</span></span>))) <span class="hljs-comment"><span class="hljs-comment">//     return 48; else if ((oxNum == 3 &amp;&amp; hybrid.equals("sp3")) || (oxNum &gt;= 2 &amp;&amp; hybrid.equals("sp2")) || (oxNum &gt;= 1 &amp;&amp; hybrid.equals("sp"))) return 49;</span></span></code> </pre> <br><p>  Dalam logika kondisional yang kompleks, ini tidak jarang: kami memeriksa kondisi yang tidak mungkin benar, karena fragmennya telah diperiksa di atas.  Di sini kita memiliki cabang terpisah <code>oxNum == 0</code> , kalau tidak kita periksa <code>oxNum == 0 &amp;&amp; hybrid.equals("sp")</code> , yang tentu saja tidak bisa. </p><br><h3 id="12-pishem-v-massiv-nulevoy-dliny">  12. Kami menulis ke array dengan panjang nol </h3><br><p>  Terkadang IntelliJ IDEA akan melihat jika Anda menulis ke array di <a href="">luar ukurannya</a> : </p><br><pre> <code class="java hljs">Point3d points[] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point3d[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//    0  if (nwanted == 1) { points = new Point3d[1]; points[0] = new Point3d(aPoint); points[0].add(new Vector3d(length, 0.0, 0.0)); } else if (nwanted == 2) { //       —   points[0] = new Point3d(aPoint); points[0].add(new Vector3d(length, 0.0, 0.0)); points[1] = new Point3d(aPoint); points[1].add(new Vector3d(-length, 0.0, 0.0)); }</span></span></code> </pre> <br><h3 id="13-proverka-dliny-posle-obrascheniya-po-indeksu">  13. Memeriksa panjang setelah mengakses indeks </h3><br><p>  Masalah umum lainnya dengan prosedur dan lagi <a href="">selama penanganan kesalahan</a> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setParameters</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object[] params)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> CDKException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (params.length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CDKException(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(params[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Integer)) { <span class="hljs-comment"><span class="hljs-comment">//     throw new CDKException("The parameter must be of type Integer"); } if (params.length == 0) return; //      maxIterations = (Integer) params[0]; }</span></span></code> </pre> <br><p>  Dalam kasus array kosong, pembuat kode ingin keluar dengan tenang, tetapi karena verifikasi, ia akan keluar, dengan keras membenturkan ArrayIndexOutOfBoundsException.  Jelas, pesanan cek sudah rusak. </p><br><h3 id="14-proverka-na-null-posle-obrascheniya">  14. Periksa null setelah akses </h3><br><p>  Dan lagi, urutan tindakan dilanggar, <a href="">kali ini dengan nol</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!line.startsWith(<span class="hljs-string"><span class="hljs-string">"frame:"</span></span>) &amp;&amp; input.ready() &amp;&amp; line != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { line = input.readLine(); logger.debug(lineNumber++ + <span class="hljs-string"><span class="hljs-string">": "</span></span>, line); }</code> </pre> <br><p>  IDEA menulis <code>line != null</code> selalu benar.  Kebetulan ceknya benar-benar berlebihan, tetapi di sini kodenya tampak seolah-olah nol. </p><br><h3 id="15-dizyunkciya-vmesto-konyunkcii">  15. Disjungsi alih-alih konjungsi </h3><br><p>  Orang sering membingungkan operator logika AND dan OR.  Proyek CDK <a href="">tidak terkecuali</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rStereo != <span class="hljs-number"><span class="hljs-number">4</span></span> || pStereo != <span class="hljs-number"><span class="hljs-number">4</span></span> || rStereo != <span class="hljs-number"><span class="hljs-number">3</span></span> || pStereo != <span class="hljs-number"><span class="hljs-number">3</span></span>) { ... }</code> </pre> <br><p>  Apapun <code>rStereo</code> dan <code>pStereo</code> sama dengan, jelas bahwa mereka tidak dapat sama dengan empat dan tiga pada saat yang sama, oleh karena itu kondisi ini selalu benar. </p><br><h3 id="16-i-snova-dizyunkciya-vmesto-konyunkcii">  16. Sekali lagi disjungsi alih-alih konjungsi </h3><br><p>  <a href="">Kesalahan serupa</a> , tetapi ditangkap oleh pesan lain: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getFirstMapping() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !getFirstMapping().isEmpty()) { ... }</code> </pre> <br><p>  Kita bisa sampai ke sisi kanan hanya jika <code>getFirstMapping()</code> mengembalikan <code>null</code> , tetapi dalam hal ini kami dijamin NullPointerException, yang diperingatkan IDEA.  Omong-omong, di sini kita mengandalkan stabilitas hasil dari metode <code>getFirstMapping()</code> .  Terkadang kita menggunakan heuristik, tetapi stabilitas dianalisis langsung di sini.  Karena kelas adalah final, metode tidak dapat diganti.  <code>return firstSolution.isEmpty() ? null : firstSolution</code> IDEA memeriksa kembali body <code>return firstSolution.isEmpty() ? null : firstSolution</code>  <code>return firstSolution.isEmpty() ? null : firstSolution</code> dan menentukan stabilitas yang turun ke stabilitas metode <code>Map#isEmpty</code> , yang sebelumnya dijelaskan sebagai stabil. </p><br><h3 id="17-ierarhiya-interfeysov-i-instanceof">  17. Hirarki antarmuka dan instanceof </h3><br><p>  Saat memeriksa objek untuk memiliki antarmuka apa pun, jangan lupa bahwa antarmuka dapat saling mewarisi: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> IAtomContainer) { root = convertor.cdkAtomContainerToCMLMolecule((IAtomContainer) object); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ICrystal) { root = convertor.cdkCrystalToCMLMolecule((ICrystal) object); } ...</code> </pre> <br><p>  Antarmuka <code>ICrystal</code> <a href="">memperluas</a> antarmuka <code>IAtomContainer</code> , sehingga cabang kedua jelas tidak dapat <code>IAtomContainer</code> : jika kristal datang ke sini, ia akan jatuh ke cabang pertama. </p><br><h3 id="18-obhod-pustogo-spiska">  18. Menelusuri daftar kosong </h3><br><p>  Penulis kode ini mungkin <a href="">tidak terlalu mengenal</a> bahasa Jawa: </p><br><pre> <code class="java hljs">List&lt;Integer&gt; posNumList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; posNumList.size(); i++) { posNumList.add(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><p>  Parameter ukuran di <code>ArrayList</code> menunjukkan ukuran awal array internal.  Ini digunakan untuk optimasi untuk mengurangi jumlah alokasi, jika Anda tahu sebelumnya berapa banyak item yang akan ditempatkan di sana.  Namun, pada kenyataannya, item dalam daftar tidak muncul, dan metode <code>size()</code> mengembalikan 0. Oleh karena itu, siklus berikutnya dengan upaya untuk menginisialisasi item daftar dengan nol sama sekali tidak berguna. </p><br><h3 id="19-ne-zabyvaem-inicializirovat-polya">  19. Jangan lupa untuk menginisialisasi bidang </h3><br><p>  Alat analisa dengan cara khusus memeriksa konstruktor, dengan mempertimbangkan inisialisasi lapangan.  Berkat ini, <a href="">kesalahan seperti</a> itu ditemukan: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IMatrix</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] realmatrix; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] imagmatrix; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rows; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> columns; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IMatrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Matrix m)</span></span></span><span class="hljs-function"> </span></span>{ rows = m.rows; columns = m.columns; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rows; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; columns; j++) { realmatrix[i][j] = m.matrix[i][j]; <span class="hljs-comment"><span class="hljs-comment">// NullPointerException  imagmatrix[i][j] = 0d; } } }</span></span></code> </pre> <br><p>  Terlepas dari kenyataan bahwa bidangnya bersifat publik, tidak ada seorang pun di sini yang dapat mengganjal dan menginisialisasi mereka di depan konstruktor.  Oleh karena itu, IDEA dengan berani mengeluarkan peringatan bahwa mengakses elemen array akan meningkatkan NullPointerException. </p><br><h3 id="20-po-dva-raza-ne-povtoryat">  20. Jangan ulangi dua kali </h3><br><p>  Kondisi berulang juga sering terjadi.  Berikut ini <a href="">sebuah contoh</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (commonAtomCount &gt; vfMCSSize &amp;&amp; commonAtomCount &gt; vfMCSSize) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre> <br><p>  Bug seperti itu berbahaya, karena Anda tidak pernah tahu, kondisi kedua hanya berlebihan, atau penulis ingin memeriksa sesuatu yang lain.  Jika ini tidak segera diperbaiki, maka bisa sulit untuk mengetahuinya.  Ini adalah alasan lain mengapa analisis statis harus digunakan secara konstan. </p><br><p>  Saya melaporkan beberapa bug ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pelacak bug proyek</a> .  Sangat mengherankan bahwa ketika penulis proyek memperbaiki bagian, mereka sendiri menggunakan penganalisa IntelliJ IDEA, menemukan masalah lain yang tidak saya tulis, dan juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mulai memperbaikinya</a> .  Saya pikir ini adalah pertanda baik: penulis menyadari pentingnya analisis statis. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436278/">https://habr.com/ru/post/id436278/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436266/index.html">Penskalaan Ekstrim di Alibaba JDK</a></li>
<li><a href="../id436268/index.html">Kami mengumpulkan setumpuk lengkap</a></li>
<li><a href="../id436270/index.html">35% dari penonton Runet tidak menggunakan komputer untuk Internet sama sekali</a></li>
<li><a href="../id436272/index.html">Pemrograman Visual untuk Sonoff Basic</a></li>
<li><a href="../id436274/index.html">Aplikasi seluler untuk pendaftaran kecelakaan sedang dibuat di Rusia</a></li>
<li><a href="../id436280/index.html">Terapkan honeypot pada router Cisco</a></li>
<li><a href="../id436282/index.html">Tantangan dari perusahaan asing atau bagaimana saya gagal dalam wawancara</a></li>
<li><a href="../id436288/index.html">Bagaimana monopoli dimulai, atau sedikit ribut dengan IBM PC 5150</a></li>
<li><a href="../id436292/index.html">Kontrol, ubah, hapus: 10 laporan teratas dari DotNext 2018 Moscow</a></li>
<li><a href="../id436294/index.html">Pemodelan seri waktu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>