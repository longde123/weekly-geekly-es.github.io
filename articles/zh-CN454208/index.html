<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍🏾 🔄 👭 从头开始RISC-V 🤘 🌊 🧙🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我们将通过RISC-V体系结构及其生态系统来探讨各种底层概念（编译和布局，原始运行时，汇编器等）。 我本人是一名Web开发人员，我什么都不做，但这对我来说很有趣，这是文章的来源！ 和我一起在这低级混乱的深处进行忙碌的旅程。 

 首先，让我们谈谈RISC-V及其架构的重要性，设置RISC-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>从头开始RISC-V</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454208/"> 在本文中，我们将通过RISC-V体系结构及其生态系统来探讨各种底层概念（编译和布局，原始运行时，汇编器等）。 我本人是一名Web开发人员，我什么都不做，但这对我来说很有趣，这是文章的来源！ 和我一起在这低级混乱的深处进行忙碌的旅程。 <br><br> 首先，让我们谈谈RISC-V及其架构的重要性，设置RISC-V工具链并在仿真的RISC-V硬件上运行一个简单的C程序。 <br><a name="habracut"></a><br><h1> 目录内容 </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">什么是RISC-V？</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">配置QEMU和RISC-V工具</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">嗨，RISC-V！</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">天真的方法</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">提起窗帘-v</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">搜索我们的堆栈</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">布局图</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">别说了</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><s>锤击时间！</s></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">运行时！</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调试但现在是真实的</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">接下来是什么？</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">选配</a> </li></ol><br><a name="1"></a><h1> 什么是RISC-V？ </h1><br>  RISC-V是一种免费的指令集体系结构。 该项目于2010年起源于加利福尼亚大学伯克利分校。 代码的开放性和使用自由度在其成功中扮演着重要角色，这与许多其他体系结构有很大不同。 以ARM为例：要创建兼容的处理器，您必须支付<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">100万到1000万美元</a>的预付款<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，还需支付销售收入的0.5-2％的特许权使用费</a> 。 自由开放的模型使RISC-V对许多人来说都是有吸引力的选择，包括那些无法为ARM或其他处理器支付许可证的初创公司，学术研究人员以及（显然）开源社区。 <br><br>  RISC-V的迅速普及并没有引起人们的注意。  ARM <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">推出了一个站点</a> （尝试（但没有成功））强调ARM优于RISC-V的优势（该站点已关闭）。  RISC-V项目得到了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">许多大公司的</a>支持，包括Google，Nvidia和Western Digital。 <br><br><a name="2"></a><h1> 配置QEMU和RISC-V工具 </h1><br> 在设置环境之前，我们无法在RISC-V处理器上运行代码。 幸运的是，这不需要物理RISC-V处理器；相反，我们采用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">qemu</a> 。 按照<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说明</a>安装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">操作系统</a> 。 我有MacOS，因此只需输入一个命令： <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># also available via MacPorts - `sudo port install qemu` brew install qemu</span></span></code> </pre> <br> 方便地， <code>qemu</code>附带了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">几台现成的计算机</a> （请参阅<code>qemu-system-riscv32 -machine</code> ）。 <br><br> 接下来，安装适用于RISC-V和RISC-V工具的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenOCD</a> 。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>下载RISC-V OpenOCD和RISC-V工具的现成组件。 <br> 我们将文件解压缩到任何目录， <code>~/usys/riscv</code> 。 记住它以备将来使用。 <br><br><pre> <code class="bash hljs">mkdir -p ~/usys/riscv <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/Downloads cp openocd-&lt;date&gt;-&lt;platform&gt;.tar.gz ~/usys/riscv cp riscv64-unknown-elf-gcc-&lt;date&gt;-&lt;platform&gt;.tar.gz ~/usys/riscv <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/usys/riscv tar -xvf openocd-&lt;date&gt;-&lt;platform&gt;.tar.gz tar -xvf riscv64-unknown-elf-gcc-&lt;date&gt;-&lt;platform&gt;.tar.gz</code> </pre> <br> 设置环境变量<code>RISCV_OPENOCD_PATH</code>和<code>RISCV_PATH</code>以便其他程序可以找到我们的工具链。 根据操作系统和外壳，这可能看起来有所不同：我将路径添加到<code>~/.zshenv</code> 。 <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># I put these two exports directly in my ~/.zshenv file - you may have to do something else. export RISCV_OPENOCD_PATH="$HOME/usys/riscv/openocd-&lt;date&gt;-&lt;version&gt;" export RISCV_PATH="$HOME/usys/riscv/riscv64-unknown-elf-gcc-&lt;date&gt;-&lt;version&gt;" # Reload .zshenv with our new environment variables. Restarting your shell will have a similar effect. source ~/.zshenv</span></span></code> </pre> <br> 在<code>/usr/local/bin</code>中为此可执行文件创建一个符号链接，以便您可以随时运行它，而无需指定<code>~/usys/riscv/riscv64-unknown-elf-gcc-&lt;date&gt;-&lt;version&gt;/bin/riscv64-unknown-elf-gcc</code> 。 <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Symbolically link our gcc executable into /usr/local/bin. Repeat this process for any other executables you want to quickly access. ln -s ~/usys/riscv/riscv64-unknown-elf-gcc-8.2.0-&lt;date&gt;-&lt;version&gt;/bin/riscv64-unknown-elf-gcc /usr/local/bin</span></span></code> </pre> <br> 瞧，我们有一个有效的RISC-V工具包！ 我们所有的可执行文件，例如<code>riscv64-unknown-elf-gcc</code> ， <code>riscv64-unknown-elf-gdb</code> ， <code>riscv64-unknown-elf-ld</code>等，都位于<code>~/usys/riscv/riscv64-unknown-elf-gcc-&lt;date&gt;-&lt;version&gt;/bin/</code> 。 <br><br><a name="3"></a><h1> 嗨，RISC-V！ </h1><br>  <i>2019年5月26日补丁：</i> <i><br><br></i>  <i>不幸的是，由于RISC-V QEMU中的错误，QEMU中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自由e-sdk</a> “ hello world”程序不再起作用。</i>  <i>已经发布了一个补丁程序来解决此问题，但现在请跳过本节。</i>  <i>本文的后续部分将不需要此程序。</i>  <i>修复错误后，我会跟踪情况并更新文章。</i> <i><br><br></i>  <i>有关更多信息，请参<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">见此评论</a> 。</i> <br><br> 通过设置工具，让我们运行简单的RISC-V程序。 让我们从克隆SiFive Freedom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-e-sdk</a>存储库开始： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/wherever/you/want/to/<span class="hljs-built_in"><span class="hljs-built_in">clone</span></span>/this git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> --recursive https://github.com/sifive/freedom<span class="hljs-_"><span class="hljs-_">-e</span></span>-sdk.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> freedom<span class="hljs-_"><span class="hljs-_">-e</span></span>-sdk</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">按照传统</a> ，让我们从<code>freedom-e-sdk</code>存储库中的“ Hello，world”程序开始。 我们使用他们提供的现成的<code>Makefile</code>在调试模式下编译该程序： <br><br><pre> <code class="bash hljs">make PROGRAM=hello TARGET=sifive-hifive1 CONFIGURATION=debug software</code> </pre> <br> 并在QEMU中运行： <br><br><pre> <code class="bash hljs">qemu-system-riscv32 -nographic -machine sifive_e -kernel software/hello/debug/hello.elf Hello, World!</code> </pre> <br> 这是一个很好的开始。 您可以从<code>freedom-e-sdk</code>运行其他示例。 之后，我们将编写并尝试使用C调试我们自己的程序。 <br><br><h1> 天真的方法 </h1><br> 让我们从一个简单的程序开始，该程序无限地将两个数字相加。 <br><br><pre> <code class="cpp hljs">cat add.<span class="hljs-function"><span class="hljs-function">c </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = a + b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br> 我们要运行此程序，首先需要为RISC-V处理器编译它。 <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># -O0 to disable all optimizations. Without this, GCC might optimize # away our infinite addition since the result 'c' is never used. # -g to tell GCC to preserve debug info in our executable. riscv64-unknown-elf-gcc add.c -O0 -g</span></span></code> </pre> <br> 这将创建一个<code>a.out</code>文件，该文件<code>gcc</code>默认为可执行文件。 现在在<code>qemu</code>运行此文件： <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># -machine tells QEMU which among our list of available machines we want to # run our executable against. Run qemu-system-riscv64 -machine help to list # all available machines. # -m is the amount of memory to allocate to our virtual machine. # -gdb tcp::1234 tells QEMU to also start a GDB server on localhost:1234 where # TCP is the means of communication. # -kernel tells QEMU what we're looking to run, even if our executable isn't # exactly a "kernel". qemu-system-riscv64 -machine virt -m 128M -gdb tcp::1234 -kernel a.out</span></span></code> </pre> <br> 我们选择了<code>riscv-qemu</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最初随附</a>的<code>virt</code>机。 <br><br> 现在，我们的程序在QEMU中与<code>localhost:1234</code>上的GDB服务器一起运行，我们从另一个终端通过RISC-V GDB客户端连接到它： <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># --tui gives us a (t)extual (ui) for our GDB session. # While we can start GDB without any arguments, specifying 'a.out' tells GDB # to load debug symbols from that file for the newly created session. riscv64-unknown-elf-gdb --tui a.out</span></span></code> </pre> <br> 而且我们在GDB内部！ <br><br><pre> 此GDB配置为“ --host = x86_64-apple-darwin17.7.0 --target = riscv64-unknown-elf”。  │
键入“显示配置”以获取配置详细信息。  │
有关错误报告的说明，请参见：│
 &lt;http://www.gnu.org/software/gdb/bugs/&gt;。  │
在线查找GDB手册和其他文档资源：│
     &lt;http://www.gnu.org/software/gdb/documentation/&gt;。  │
                                                                                                       │
要获得帮助，请键入“帮助”。  │
输入“ apropos word”以搜索与“ word”相关的命令...│
从a.out读取符号...│
 （gdb） </pre><br> 我们可以尝试在GDB中为<code>a.out</code>可执行文件运行<code>run</code>或<code>start</code>命令，但是目前由于明显的原因，该命令无法正常工作。 我们将该程序编译为<code>riscv64-unknown-elf-gcc</code> ，因此主机应在<code>riscv64</code>体系结构上运行。 <br><br> 但是有出路！ 这种情况是存在GDB客户服务器模型的主要原因之一。 我们可以获取<code>riscv64-unknown-elf-gdb</code>可执行文件，而不是在主机上启动它，而是为它指定一些远程目标（GDB服务器）。 您还记得，我们刚刚启动<code>riscv-qemu</code>并告诉我们在<code>localhost:1234</code>上启动GDB服务器<code>localhost:1234</code> 。 只需连接到该服务器： <br><br><pre>  （GDB）目标远程：1234│
远程调试使用：1234 </pre><br> 现在您可以设置一些断点： <br><br><pre> <code class="bash hljs">(gdb) b main Breakpoint 1 at 0x1018e: file add.c, line 2. (gdb) b 5 <span class="hljs-comment"><span class="hljs-comment"># this is the line within the forever-while loop. int c = a + b; Breakpoint 2 at 0x1019a: file add.c, line 5.</span></span></code> </pre> <br> 最后，指定GDB <code>continue</code> （缩写为<code>c</code> ），直到到达断点： <br><br><pre> <code class="bash hljs">(gdb) c Continuing.</code> </pre> <br> 您会很快注意到该过程不会以任何方式结束。 这很奇怪……我们不应该立即到达断点<code>b 5</code>吗？ 发生什么事了 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a53/834/210/a538342106336ef7ed1b8f9e53a47f48.png"><br><br> 在这里您可以看到几个问题： <br><br><ol><li> 文本UI找不到源。 该界面应显示我们的代码和附近的任何断点。 <br></li><li>  GDB看不到当前执行行（ <code>L??</code> ），并显示计数器0x0（ <code>PC: 0x0</code> ）。 <br></li><li> 输入行中的某些文本全部如下所示： <code>0x0000000000000000 in ?? ()</code> <code>0x0000000000000000 in ?? ()</code> </li></ol><br> 结合我们无法达到断点的事实，这些指标表明：我们做错了<i>什么</i> 。 但是呢 <br><br><a name="5"></a><h1> 提起窗帘-v </h1><br> 要了解正在发生的事情，您需要退后一步，谈论我们的简单C程序实际上是如何工作的。  <code>main</code>函数做一个简单的加法，但实际上是什么呢？ 为什么要称其为“ <code>main</code> ”而不是“ <code>origin</code>或“ <code>begin</code> ？ 根据约定，所有可执行文件都开始使用<code>main</code>函数执行，但是什么魔术提供了这种功能？ <br><br> 要回答这些问题，让我们用<code>-v</code>标志重复我们的GCC团队，以获取实际情况的更详细输出。 <br><br><pre> <code class="bash hljs">riscv64-unknown-elf-gcc add.c -O0 -g -v</code> </pre> <br> 输出很大，因此我们将不会查看整个清单。 重要的是要注意，尽管GCC正式是编译器，但它也默认为编译（要限制自己进行编译和汇编，必须指定<code>-c</code>标志）。 为什么这很重要？ 好吧，看看<code>gcc</code>的详细输出中的代码片段： <br><br><pre>  ＃实际的`gcc -v`命令输出完整路径，但是这些路径相当
 ＃很长，因此假装这些变量存在。
 ＃$ RV_GCC_BIN_PATH = /用户/ twilcock / usys / riscv / riscv64-unknown-elf-gcc- &lt;日期&gt;-&lt;版本&gt; / bin /
 ＃$ RV_GCC_LIB_PATH = $ RV_GCC_BIN_PATH /../ lib / gcc / riscv64-unknown-elf / 8.2.0<font></font>
<font></font>
 $ RV_GCC_BIN_PATH /../ libexec / gcc / riscv64-unknown-elf / 8.2.0 / collect2 \
   ...被截断... 
   $ RV_GCC_LIB_PATH /../../../../ riscv64-unknown-elf / lib / rv64imafdc / lp64d / crt0.o \ 
   $ RV_GCC_LIB_PATH / riscv64-unknown-elf / 8.2.0 / rv64imafdc / lp64d / crtbegin.o \
   -lgcc-开始组-lc -lgloss-结束组-lgcc \ 
   $ RV_GCC_LIB_PATH / rv64imafdc / lp64d / crtend.o
   ...被截断...
 COLLECT_GCC_OPTIONS ='-O0''-g''-v''-march = rv64imafdc''-mabi = lp64d' </pre><br> 我知道即使是缩写形式也很多，所以让我解释一下。 在第一行， <code>gcc</code>运行<code>collect2</code>程序，传递参数<code>crt0.o</code> ， <code>crtbegin.o</code>和<code>crtend.o</code> ， <code>-lgcc</code>和<code>--start-group</code>标志。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到collect2的描述：简而言之，collect2在启动时会组织各种初始化函数，从而一次或多次传递布局。 <br><br> 因此，GCC使用我们的代码编译了多个<code>crt</code>文件。 如您所料， <code>crt</code>表示“ C运行时”。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>详细描述了每个<code>crt</code>用途，但是我们对<code>crt0</code>感兴趣，它做了一件重要的事情： <br><br><blockquote>  <i>“此[crt0]对象应该包含<code>_start</code>字符，它指示程序的引导程序。”</i> </blockquote><br>  “引导程序”的本质取决于平台，但是它通常涉及重要的任务，例如设置堆栈框架，传递命令行参数以及调用<code>main</code> 。 是的，我们<i>终于</i>找到了问题的答案： <code>_start</code>调用了我们的主要功能！ <br><br><a name="6"></a><h1> 搜索我们的堆栈 </h1><br> 我们解决了一个难题，但是这如何使我们更接近最初的目标-在<code>gdb</code>运行简单的C程序？ 仍然需要解决几个问题：第一个问题与<code>crt0</code>如何配置堆栈有关。 <br><br> 如上所述， <code>gcc</code>默认为<code>crt0</code> 。 基于以下几个因素选择默认参数： <br><br><ul><li> 与<code>machine-vendor-operatingsystem</code>的结构相对应的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目标三元组</a> 。 我们拥有<code>riscv64-unknown-elf</code> <br></li><li> 目标架构<code>rv64imafdc</code> <br></li><li> 目标ABI， <code>lp64d</code> </li></ul><br> 通常，一切都可以正常运行，但不适用于每个RISC-V处理器。 如前所述， <code>crt0</code>的任务之一是配置堆栈。 但是他不知道我们的CPU（ <code>-machine</code> ）的堆栈应该在哪里？ 没有我们的帮助，他无法做到。 <br><br> 在<code>qemu-system-riscv64 -machine virt -m 128M -gdb tcp::1234 -kernel a.out</code>我们使用了<code>virt</code>计算机。 幸运的是， <code>qemu</code>使将机器信息轻松转储到<code>dtb</code>转储（设备树blob）中。 <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Go to the ~/usys/riscv folder we created before and create a new dir # for our machine information. cd ~/usys/riscv &amp;&amp; mkdir machines cd machines # Use qemu to dump info about the 'virt' machine in dtb (device tree blob) # format. # The data in this file represents hardware components of a given # machine / device / board. qemu-system-riscv64 -machine virt -machine dumpdtb=riscv64-virt.dtb</span></span></code> </pre> <br>  Dtb数据很难读取，因为它基本上是二进制格式，但是有一个<code>dtc</code> （设备树编译器）命令行实用程序可以将文件转换为更具可读性的文件。 <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># I'm running MacOS, so I use Homebrew to install this. If you're # running another OS you may need to do something else. brew install dtc # Convert our .dtb into a human-readable .dts (device tree source) file. dtc -I dtb -O dts -o riscv64-virt.dts riscv64-virt.dtb</span></span></code> </pre> <br> 输出文件是<code>riscv64-virt.dts</code> ，在该文件中我们看到了许多关于<code>virt</code>的有趣信息：可用的处理器内核数量，各种外围设备（例如UART）的内存位置，内部内存（RAM）的位置。 堆栈应该在此内存中，因此请使用<code>grep</code>查找： <br><br><pre> <code class="bash hljs">grep memory riscv64-virt.dts -A 3 memory@80000000 { device_type = <span class="hljs-string"><span class="hljs-string">"memory"</span></span>; reg = &lt;0x00 0x80000000 0x00 0x8000000&gt;; };</code> </pre> <br> 如您所见，此节点的“内存”指定为<code>device_type</code> 。 显然，我们找到了想要的东西。 通过<code>reg = &lt;...&gt; ;</code>的值<code>reg = &lt;...&gt; ;</code> 您可以确定存储库的起始位置及其长度。 <br><br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">devicetree规范中，我们</a>看到<code>reg</code>语法是任意数量的对<code>(base_address, length)</code> 。 但是， <code>reg</code>内部有四个含义。 奇怪，两个值不足以容纳一个存储库吗？ <br><br> 再次，从devicetree规范（搜索<code>reg</code>属性）中我们发现，用于指定地址和长度的<code>&lt;u32&gt;</code>单元数由父节点（或节点本身）中的<code>#address-cells</code>和<code>#size-cells</code>属性确定。 这些值未在我们的内存节点中指定，并且父内存节点只是文件的根。 让我们看一下这些值： <br><br><pre> <code class="plaintext hljs">head -n8 riscv64-virt.dts /dts-v1/; / { #address-cells = &lt;0x02&gt;; #size-cells = &lt;0x02&gt;; compatible = "riscv-virtio"; model = "riscv-virtio,qemu";</code> </pre> <br> 事实证明，地址和长度都需要两个32位值。 这意味着<code>reg = &lt;0x00 0x80000000 0x00 0x8000000&gt;;</code> 我们的内存开始<code> 0x00 + 0x80000000 (0x80000000)</code>并占用<code>0x00 + 0x8000000 (0x8000000)</code>字节，即，它以<code>0x88000000</code>结束，对应于128兆字节。 <br><br><a name="7"></a><h1> 布局图 </h1><br> 使用<code>qemu</code>和<code>dtc</code>我们在virt虚拟机中找到了RAM地址。 我们还知道， <code>gcc</code>默认情况下会组成<code>crt0</code> ，而无需根据需要配置堆栈。 但是如何使用这些信息最终运行和调试程序？ <br><br> 由于<code>crt0</code>不适合我们，因此有一个显而易见的选择：编写您自己的代码，然后将其与在编译简单程序后获得的目标文件一起编写。 我们的<code>crt0</code>需要知道栈顶从哪里开始，以便正确地对其进行初始化。 我们可以<code>crt0</code>值<code>0x80000000</code>直接<code>crt0</code>为<code>crt0</code> ，但是考虑到将来可能需要的更改，这不是一个非常合适的解决方案。 如果我们想在仿真器中使用另一个具有不同特征的CPU，如<code>sifive_e</code> ，该怎么办？ <br><br> 幸运的是，我们不是第一个提出这个问题的人，而且已经存在一个好的解决方案。  GNU <code>ld</code>链接<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">器使您可以定义</a> <code>crt0</code>可用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的字符</a> 。 我们可以定义适用于不同处理器的<code>__stack_top</code>符号。 <br><br> 与其从头开始编写自己的链接器文件，不如将默认脚本与<code>ld</code>并对其进行一些修改以支持其他字符。 什么是链接描述文件？  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://www.scoberlin.de/content/media/">这是一个很好的描述</a> ： <br><br><blockquote>  <i>链接描述文件的主要目的是描述如何在输入和输出中匹配文件节，并控制输出文件的内存布局。</i> </blockquote><br> 知道了这一点，让我们将默认的链接<code>riscv64-unknown-elf-ld</code>文件<code>riscv64-unknown-elf-ld</code>复制到一个新文件中： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/usys/riscv <span class="hljs-comment"><span class="hljs-comment"># Make a new dir for custom linker scripts out RISC-V CPUs may require. mkdir ld &amp;&amp; cd ld # Copy the default linker script into riscv64-virt.ld riscv64-unknown-elf-ld --verbose &gt; riscv64-virt.ld</span></span></code> </pre> <br> 该文件包含<i>许多</i>有趣的信息，远远超出了我们在本文中讨论的范围。 使用<code>--Verbose</code>详细输出包括有关<code>ld</code>版本，支持的体系结构等的信息。 知道这一切都是很好的，但是在链接描述文件中这种语法是不可接受的，因此请打开文本编辑器并从文件中删除所有多余的内容。 <br><br><pre> 病毒riscv64-virt.ld<font></font>
<font></font>
 ＃删除上面的所有内容，包括=============
 GNU ld（GNU Binutils）2.32
  支持的仿真：
    elf64lriscv
    elf32lriscv
使用内部链接器脚本：
 ====================================================
 / * -z combreloc的脚本：组合和排序重定位节* /
 / *版权所有（C）2014-2019自由软件基金会，Inc.
   复制和分发此脚本（修改或不修改），
   允许在没有版权的情况下以任何媒体提供版权
   通知，此通知被保留。  * /
 OUTPUT_FORMAT（“ elf64-littleriscv”，“ elf64-littleriscv”，
	       “ elf64-littleriscv”）
 ...其余的链接描述文件... </pre><br> 之后，运行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MEMORY</a>命令手动确定<code>__stack_top</code>位置。 找到以<code>OUTPUT_ARCH(riscv)</code>开头的行，该行应位于文件的顶部，并在其下方添加<code>MEMORY</code>命令： <br><br><pre> <code class="plaintext hljs">OUTPUT_ARCH(riscv) /* &gt;&gt;&gt; Our addition. &lt;&lt;&lt; */ MEMORY { /* qemu-system-risc64 virt machine */ RAM (rwx) : ORIGIN = 0x80000000, LENGTH = 128M } /* &gt;&gt;&gt; End of our addition. &lt;&lt;&lt; */ ENTRY(_start)</code> </pre> <br> 我们创建了一个称为<code>RAM</code>的存储块，允许对其进行读（ <code>r</code> ），写（ <code>w</code> ）和存储可执行代码（ <code>x</code> ）。 <br><br> 太好了，我们已经定义了一个匹配<code>virt</code> RISC-V机器规格的内存布局。 现在您可以使用它了。 我们想将堆栈放入内存。 <br><br> 您需要定义<code>__stack_top</code>字符。 在文本编辑器中打开链接描述文件（ <code>riscv64-virt.ld</code> ）并添加几行： <br><br><pre> <code class="plaintext hljs">SECTIONS { /* Read-only sections, merged into text segment: */ PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x10000)); . = SEGMENT_START("text-segment", 0x10000) + SIZEOF_HEADERS; /* &gt;&gt;&gt; Our addition. &lt;&lt;&lt; */ PROVIDE(__stack_top = ORIGIN(RAM) + LENGTH(RAM)); /* &gt;&gt;&gt; End of our addition. &lt;&lt;&lt; */ .interp : { *(.interp) } .note.gnu.build-id : { *(.note.gnu.build-id) }</code> </pre> <br> 如您所见，我们使用<code>__stack_top</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">命令</a>定义<code>__stack_top</code> 。 可以从与此脚本关联的任何程序中访问该符号（假设该程序本身不会确定名称为<code>__stack_top</code>东西）。 将<code>__stack_top</code>设置为<code>ORIGIN(RAM)</code> 。 我们知道此值为<code>0x80000000</code>加上<code>LENGTH(RAM)</code> ，即128兆字节（ <code>0x8000000</code>字节）。 这意味着我们的<code>__stack_top</code>设置为<code>0x88000000</code> 。 <br><br> 为简便起见，我不会在<a href="">此处</a>列出整个链接器文件；您可以<a href="">在此处查看</a> 。 <br><br><a name="8"></a><h1> 别说了  <s>锤击时间！</s> 运行时！ </h1><br> 现在我们拥有创建自己的C运行时所需的一切，实际上，这是一个相当简单的任务，这是整个<code>crt0.s</code>文件： <br><br><pre> <code class="plaintext hljs">.section .init, "ax" .global _start _start: .cfi_startproc .cfi_undefined ra .option push .option norelax la gp, __global_pointer$ .option pop la sp, __stack_top add s0, sp, zero jal zero, main .cfi_endproc .end</code> </pre> <br> 立即吸引了大量以句点开头的行。 这是用于汇编程序的文件。 带点的线称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">汇编程序伪指令</a> ：它们为汇编程序提供信息。 这不是可执行代码，例如RISC-V汇编程序指令（例如<code>jal</code>和<code>add</code> 。 <br><br> 让我们逐行浏览文件。 我们将使用各种标准RISC-V寄存器，因此请查看<a href="">此表</a> ， <a href="">该表</a>涵盖了所有寄存器及其用途。 <br><br><pre> <code class="plaintext hljs">.section .init, "ax"</code> </pre> <br> 如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GNU汇编程序“ as”手册中所述</a> ，此行告诉汇编程序将以下代码插入<code>.init</code>节，该节已分配（ <code>a</code> ）和可执行文件（ <code>x</code> ）。 本节是在操作系统中运行代码的另一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">常见约定</a> 。 我们在没有操作系统的纯硬件上工作，因此在我们的情况下，这样的说明可能不是绝对必要的，但是在任何情况下，这都是一个好习惯。 <br><br><pre> <code class="plaintext hljs">.global _start _start:</code> </pre> <br>  <code>.global</code>使<code>ld</code>可以使用以下字符。 否则，链接将不起作用，因为链接描述文件中的<code>ENTRY(_start)</code>指向<code>_start</code>符号，作为可执行文件的入口。 下一行告诉汇编程序我们正在开始<code>_start</code>字符的定义。 <br><br><pre> <code class="plaintext hljs">_start: .cfi_startproc .cfi_undefined ra ...other stuff... .cfi_endproc</code> </pre> <br> 这些<code>.cfi</code>指令会<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通知您</a>有关框架的结构以及如何处理它。  <code>.cfi_startproc</code>和<code>.cfi_endproc</code>函数的开始和结束， <code>.cfi_undefined ra</code>告诉汇编程序，在<code>_start</code>之前， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不得将</a> <code>ra</code>寄存器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">恢复</a>为包含的任何值。 <br><br><pre> <code class="plaintext hljs">.option push .option norelax la gp, __global_pointer$ .option pop</code> </pre> <br> 当您需要应用一组特定的选项时，这些<code>.option</code>伪指令根据代码更改汇编程序的行为。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是</a>为什么在<code>.option</code>中使用<code>.option</code>很重要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>详细说明： <br><br><blockquote>  <i>...由于我们可能会将序列的寻址放宽到相对于GP较短的序列，因此GP的初始加载不应受到削弱，应该是这样的：</i> <i><br><br></i> <pre> <code class="plaintext hljs">.option push .option norelax la gp, __global_pointer$ .option pop</code> </pre> <br> 这样，在放松之后，您将获得以下代码： <br><br><pre> <code class="plaintext hljs">auipc gp, %pcrel_hi(__global_pointer$) addi gp, gp, %pcrel_lo(__global_pointer$)</code> </pre> <br> 而不是简单的： <br><br><pre> <code class="plaintext hljs">addi gp, gp, 0</code> </pre> </blockquote><br> 现在，我们的<code>crt0.s</code>的最后一部分： <br><br><pre> <code class="plaintext hljs">_start: ...other stuff... la sp, __stack_top add s0, sp, zero jal zero, main .cfi_endproc .end</code> </pre> <br> 在这里，我们终于可以使用我们努力创建的<code>__stack_top</code>符号。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">伪指令</a> <code>la</code> （加载地址）将<code>__stack_top</code>值加载到<code>sp</code>寄存器（堆栈指针）中，并将其设置为在程序的其余部分中使用。 <br><br> 然后<code>add s0, sp, zero</code> ，将寄存器<code>sp</code>和<code>zero</code>的值相加（实际上是硬引用0的寄存器<code>x0</code> ），并将结果放入寄存器<code>s0</code> 。 这是一个<a href="">特殊的寄存器</a> ，在几个方面都不常见。 首先，它是一个“永久寄存器”，即在函数调用时保存。 其次， <code>s0</code>有时充当帧指针，这给每个函数调用一个小的空间，用于在堆栈中存储传递给该函数的参数。 函数调用如何与堆栈指针和框架指针一起工作是一个非常有趣的主题，您可以轻松地专门写一篇单独的文章，但是就目前而言，仅知道在我们的运行时中，初始化框架指针<code>s0</code>很重要。 <br><br> 接下来，我们看到<code>jal zero, main</code>声明。 在这里， <code>jal</code>表示跳转和链接。 该指令期望操作数的形式为<code>jal rd (destination register), offset_address</code> 。 在功能上， <code>jal</code>将下一条指令的值（ <code>pc</code>寄存器加4）写入<code>rd</code> ，然后将<code>pc</code>寄存器设置为当前<code>pc</code>值加上带<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">符号扩展名的</a>偏移地址，从而有效地“调用”该地址。 <br><br> 如上所述， <code>x0</code>与字面值0紧密绑定，对其进行写入是没有用的。    ,         <code>zero</code> ,   RISC-V    <code>x0</code> .       <code>offset_address</code> .   ,         ? <br><br>    <code>jal zero, offset_address</code>      .       , ,  .    ISA,  .  ,       <code>jal</code>  <code>unconditional jump</code> ,  RISC-V   <code>jal</code> ,      <code>jal zero, main</code> . <br><br>  RISC-V    ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> .  ,       . ,    <code>j offset_address</code>  RISC-V   <code>jal zero, offset_address</code> .      .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> RISC-V ( 2.2)</a> . <br><br><pre> <code class="plaintext hljs">_start: ...other stuff... jal zero, main .cfi_endproc .end</code> </pre> <br>    —    <code>.end</code> ,     . <br><br><a name="9"></a><h1> ,   - </h1><br>     C   RISC-V,    .    <code>qemu</code>  <code>dtc</code>       <code>virt</code> RISC-V.                <code>riscv64-unknown-elf-ld</code> ,      <code>__stack_top</code> .        <code>crt0.s</code> ,        , ,   <code>main</code> .             GDB. <br><br> ,     C: <br><br><pre> <code class="cpp hljs">cat add.<span class="hljs-function"><span class="hljs-function">c </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = a + b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>   : <br><br><pre> <code class="bash hljs">riscv64-unknown-elf-gcc -g -ffreestanding -O0 -Wl,--gc-sections -nostartfiles -nostdlib -nodefaultlibs -Wl,-T,riscv64-virt.ld crt0.s add.c</code> </pre> <br>      ,    ,     ,    . <br><br> <code>-ffreestanding</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> ,      </a> ,         .           (  ),       ,      . <br><br> <code>-Wl</code> —        ( <code>ld</code> ).  <code>--gc-sections</code>  «  »,  <code>ld</code>       .  <code>-nostartfiles</code> , <code>-nostdlib</code>  <code>-nodefaultlibs</code>         (,  <code>crt0</code> ),    stdlib      .     <code>crt0</code>  ,     ,          . <br><br> <code>-T</code>      ,      <code>riscv64-virt.ld</code> . ,   ,   ,   : <code>crt0.s</code>  <code>add.c</code> .   ,            <code>a.out</code> . <br><br>         <code>qemu</code> : <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># -S freezes execution of our executable (-kernel) until we explicitly tell # it to start with a 'continue' or 'c' from our gdb client qemu-system-riscv64 -machine virt -m 128M -gdb tcp::1234 -S -kernel a.out</span></span></code> </pre> <br>   <code>gdb</code> ,       <code>a.out</code> ,    : <br><br><pre> <code class="bash hljs">riscv64-unknown-elf-gdb --tui a.out GNU gdb (GDB) 8.2.90.20190228-git Copyright (C) 2019 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type <span class="hljs-string"><span class="hljs-string">"show copying"</span></span> and <span class="hljs-string"><span class="hljs-string">"show warranty"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> details. This GDB was configured as <span class="hljs-string"><span class="hljs-string">"--host=x86_64-apple-darwin17.7.0 --target=riscv64-unknown-elf"</span></span>. Type <span class="hljs-string"><span class="hljs-string">"show configuration"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> configuration details. For bug reporting instructions, please see: &lt;http://www.gnu.org/software/gdb/bugs/&gt;. Find the GDB manual and other documentation resources online at: &lt;http://www.gnu.org/software/gdb/documentation/&gt;. For <span class="hljs-built_in"><span class="hljs-built_in">help</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">"help"</span></span>. Type <span class="hljs-string"><span class="hljs-string">"apropos word"</span></span> to search <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> commands related to <span class="hljs-string"><span class="hljs-string">"word"</span></span>... Reading symbols from a.out... (gdb)</code> </pre> <br>     <code>gdb</code>   <code>gdb</code> ,       <code>qemu</code> : <br><br><pre> <code class="bash hljs">(gdb) target remote :1234 │ Remote debugging using :1234</code> </pre> <br>     main: <br><br><pre> <code class="bash hljs">(gdb) b main Breakpoint 1 at 0x8000001e: file add.c, line 2.</code> </pre> <br>    : <br><br><pre> <code class="bash hljs">(gdb) c Continuing. Breakpoint 1, main () at add.c:2</code> </pre> <br>    ,          2!      , -     <code>L</code> ,  <code>PC:</code>  <code>L2</code> ,  <code>PC:</code> — <code>0x8000001e</code> .       ,     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd8/aa9/78d/bd8aa978df4289f584b5c422cdb6e44c.png"><br><br>      <code>gdb</code>  : <code>-s</code>     , <code>info all-registers</code>           . .    … , ,    ! <br><br><a name="10"></a><h1> 接下来是什么？ </h1><br>     , ,  !            ,    ,       .   ,   .        <code>jal</code> ,          ,  ,   <code>add.c</code> -     RISC-V.     - ,       - , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> . <br><br>   ! ,    ! <br><br><a name="11"></a><h1> 选配 </h1><br>         ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">«  :     main()»</a>   CppCon2018.      ,   .   ,  ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN454208/">https://habr.com/ru/post/zh-CN454208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN454190/index.html">手机被盗时不需要做什么</a></li>
<li><a href="../zh-CN454196/index.html">使用无人机示例对电子产品进行3D打印：不再需要电线和板</a></li>
<li><a href="../zh-CN454198/index.html">在IDEA中创建多模块Gradle SpringBoot + Angular项目</a></li>
<li><a href="../zh-CN454204/index.html">行为爬行不是万能药吗？</a></li>
<li><a href="../zh-CN454206/index.html">PH第9天：AI CTF解析</a></li>
<li><a href="../zh-CN454210/index.html">被遗忘的enchantjs +新的1C-Bitrix =激励客户的游戏</a></li>
<li><a href="../zh-CN454214/index.html">我讨厌几乎所有软件</a></li>
<li><a href="../zh-CN454216/index.html">找到的证据表明所有变化都是有序和偶然的混合</a></li>
<li><a href="../zh-CN454220/index.html">两位数温度计</a></li>
<li><a href="../zh-CN454222/index.html">使用PCIe 1.0-2.0总线升级旧服务器的磁盘子系统</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>