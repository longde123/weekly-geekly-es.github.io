<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï≥Ô∏è üë®üèº‚Äçüî¨ üë®üèº‚Äçüöí Einfache Implementierung eines kleinen CAM auf einem FPGA üë∑ üíæ üîª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 


 Einmal musste ich einen kleinen Block CAM (assoziativen Speicher) implementieren. Nachdem ich gelesen hatte, wie Xilinx dies auf BRAM (...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einfache Implementierung eines kleinen CAM auf einem FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470892/"><h2 id="vvedenie">  Einf√ºhrung </h2><br><p>  Einmal musste ich einen kleinen Block <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CAM</a> (assoziativen Speicher) implementieren.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nachdem ich gelesen hatte,</a> wie Xilinx dies auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BRAM</a> (statische Speicherbl√∂cke) oder auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SRL16</a> (16-Bit-Schieberegister) macht, war ich ein wenig traurig, da ihre Implementierungen ziemlich viel Platz in Anspruch nahmen.  Ich beschloss, es selbst zu versuchen.  Die erste Option war die Implementierung der Stirn.  Mit Blick auf die Zukunft kam es mir fast sofort in den Sinn und die Zielfrequenz f√ºr das Design betrug nur 125 MHz. </p><a name="habracut"></a><br><h2 id="arhitektura">  Architektur </h2><br><p>  Betrachten Sie zun√§chst die Erkl√§rung des Problems.  Wir brauchen also eine kleine CAM mit einer Wortbreite von 8-64 Bit und einer Tiefe von 16-1024 W√∂rtern.  Ich brauchte eine bin√§re Suche in CAM, aber sp√§ter stellte sich heraus, dass das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen von TCAM</a> (tern√§rer assoziativer Speicher) ressourcenschonend ist und das Timing geringf√ºgig beeinflusst.  Die untere Frequenzgrenze liegt bei der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kintex7-</a> Familie bei 125 MHz.  Fangen wir an!  Unser CAM besteht aus diesen Zeilen, von denen jede einer Adresse entspricht und ein Wort speichert: </p><br><p><img src="https://habrastorage.org/webt/pv/ua/gk/pvuagk4p3oiguausboxx2ltgc_8.png" alt="Cam_line"></p><br><p>  <em>Abbildung 1. Die Struktur einer CAM-Linie</em> </p><br><p>  In Fig. 1 ist <strong>D</strong> ein regul√§rer D-Trigger zum Speichern von Daten, wobei die Anzahl dieser Trigger in der Zeile der Breite des Eingabedatenworts in CAM entspricht.  <strong>G√úLTIG</strong> - D-Trigger, der '1' speichert, wenn die Daten in der Zeile relevant sind.  <strong>CMP</strong> ist ein Komparator, der den Wert des entsprechenden <strong>Suchschl√ºsselbusbits</strong> vergleicht, wenn VALID = '1' ist.  <strong>Daten schreiben</strong> - <strong>Datenbus schreiben</strong> , bitweise mit dem entsprechenden D ( <strong>N</strong> - CAM Wortbreite) verbunden, <strong>wir</strong> - Schreibflag, <strong>Clear</strong> - Reset VALID (Ung√ºltigmachung der Datenleitung).  <strong>UND</strong> - logisches UND von N Ausg√§ngen der Komparatoren, <strong>Match</strong> - Flag wird zu '1', wenn die Suche in dieser Zeile erfolgreich ist. </p><br><p>  Wir haben also eine Zeile, in der wir suchen k√∂nnen.  Kombinieren Sie sie jetzt: </p><br><p><img src="https://habrastorage.org/webt/cn/be/1u/cnbe1uhkh4wyaxifvaq3fpxkbrs.png" alt="Cam_structure"></p><br><p>  <em>Abbildung 2. CAM-Struktur</em> </p><br><p>  In Fig. 2 ist <strong>CAM_line</strong> die CAM-Leitung selbst aus Fig. 1, <strong>MUX</strong> ist der Eingangsadressenmultiplexer, <strong>MATCH REGISTER</strong> ist ein Register, das <strong>√úbereinstimmungsflagwerte</strong> speichert, <strong>ENCODER</strong> ist ein Decoder, der den √úbereinstimmungsbus in die niedrigste gefundene √úbereinstimmungsadresse konvertiert.  <strong>FSM</strong> ist eine steuernde Finite-State-Maschine <strong>.</strong>  <strong>match</strong> entfernt aus MATCH REGISTER das Bit, das der gesendeten Adresse entspricht, sodass ENCODER zur n√§chsten gefundenen Adresse wechselt.  Die Schnittstelle unseres CAM lautet wie folgt: </p><br><div class="scrollable-table"><table><thead><tr><th>  Linie </th><th>  Richtung </th><th>  Termin </th></tr></thead><tbody><tr><td>  addr </td><td>  Login </td><td>  Adresse schreiben / l√∂schen </td></tr><tr><td>  Daten </td><td>  Login </td><td>  Datensatz- / Schl√ºsseldaten </td></tr><tr><td>  wir </td><td>  Login </td><td>  Flag aufzeichnen </td></tr><tr><td>  √ºberpr√ºfen </td><td>  Login </td><td>  Schl√ºsselsuchflagge </td></tr><tr><td>  klar </td><td>  Login </td><td>  Kennzeichnen Sie die Behinderungslinie bei </td></tr><tr><td>  addr_o </td><td>  Beenden </td><td>  Adresse mit Schl√ºssel gefunden </td></tr><tr><td>  match_o </td><td>  Beenden </td><td>  Erfolgssymbol f√ºr Schl√ºsselsuche </td></tr></tbody></table></div><br><p>  <em>Tabelle 1. CAM-Schnittstelle</em> </p><br><p>  Unten in Fig. 3 ist ein Zeitdiagramm des Betriebs dieser Schnittstelle dargestellt, das zuerst die Aufzeichnung von drei W√∂rtern in CAM, dann eine erfolgreiche Suche, L√∂schung und erneute Suche zeigt: </p><br><p><img src="https://habrastorage.org/webt/zg/mw/vn/zgmwvnreqjf_ipoetqs-99mdrt4.png" alt="Cam_diagramm"><br>  <em>Abbildung 3. Zeitdiagramm der Schnittstelle zum CAM</em> </p><br><p>  Wir haben also eine Beschreibung von CAM. Fahren wir mit der Synthese fort. </p><br><h2 id="sintez">  Synthese </h2><br><p>  Wir werden in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Xilinx ISE</a> synthetisieren, um die Ergebnisse mit denen in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XAPP1151</a> zu vergleichen. </p><br><p><img src="https://habrastorage.org/webt/wi/jq/so/wijqso_fo0rq-yvbtqvbfxadtzi.png" alt="W8v5"></p><br><p>  <em>Abbildung 4. Frequenzabh√§ngigkeit nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XST</a> (Synthesizer als Teil von ISE) von der CAM-Tiefe f√ºr die 8-Bit-Datenbusbreite</em> </p><br><p><img src="https://habrastorage.org/webt/0g/de/m4/0gdem4tk5j6b2yd3pn9sgcqtp0q.png" alt="W32v5"></p><br><p>  <em>Abbildung 5. Frequenz nach XST im Verh√§ltnis zur CAM-Tiefe f√ºr die 32-Bit-Datenbusbreite</em> </p><br><p><img src="https://habrastorage.org/webt/s4/qs/nq/s4qsnqivplq45pvoylyokf947_0.png" alt="W64v5"></p><br><p>  <em>Abbildung 6. Frequenz nach XST im Verh√§ltnis zur CAM-Tiefe f√ºr die 64-Bit-Datenbusbreite</em> </p><br><p>  In 6 gibt es keine Daten f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Virtex5</a> , da CAM dieser Gr√∂√üe nicht in das vorhandene BRAM passte.  Wir stellen au√üerdem fest, dass unser Ergebnis bei einer Breite von 64 Bit und einer Tiefe von 1024 etwas schlechter war als das der Implementierung auf SRL16.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fahren</a> wir nun mit der Vivado-Synthese f√ºr den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XC7K325T fort</a> .  Die Ergebnisse sind wie folgt: </p><br><p><img src="https://habrastorage.org/webt/vx/3i/n-/vx3in-n-do46eukhxrkonmugvgy.png" alt="W32k7"></p><br><p>  <em>Abbildung 7. Frequenzabh√§ngigkeit nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PnR</a> (Platzierung von Bl√∂cken auf dem Chip und Signalverfolgung) von der CAM-Tiefe f√ºr eine 32-Bit-Datenbusbreite</em> </p><br><p><img src="https://habrastorage.org/webt/w6/1q/qc/w61qqcqylt_tb_0p1taxixcosps.png" alt="K7res"></p><br><p>  <em>Abbildung 8. Verwendung von Ressourcen f√ºr verschiedene CAM-Tiefen f√ºr eine Datenbreite von 32 Bit in%</em> </p><br><p>  Es ist wichtig zu beachten, dass die Ergebnisse auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vivado</a> nach PnR erhalten wurden, was bedeutet, dass das Design keine Schwierigkeiten bei der R√ºckverfolgung hat. </p><br><h2 id="tcam">  TCAM </h2><br><p>  Wie oben erw√§hnt, war es kein besonderes Problem, mit diesem Ansatz von CAM TCAM zu kommen.  Es reicht aus, einen Maskierungsbus f√ºr die Datenbits hinzuzuf√ºgen und ihn St√ºck f√ºr St√ºck an die Komparatoren zu verteilen, damit sie beim Vergleich der Daten mit dem Schl√ºssel deren Wert ber√ºcksichtigen.  Eine solche √Ñnderung f√ºhrte nicht zu einem Frequenzabfall oder einer ernsthaften Erh√∂hung des Ressourcenverbrauchs, sodass wir TCAM kostenlos erhielten. </p><br><h2 id="vyvody">  Schlussfolgerungen </h2><br><p>  So konnten wir die Aufgabe erledigen.  Das resultierende Design erm√∂glicht es der 7. Xilinx-FPGA-Familie, ausreichend gro√üe CAM mit einer Frequenz √ºber dem Ziel von 125 MHz zu empfangen.  Das Ergebnis des Vergleichs mit XAPP1151 stellte sich f√ºr mich als unerwartet heraus. Ich ging davon aus, dass die Implementierung auf BRAM, obwohl sie in Bezug auf Ressourcen sehr teuer ist, die frontale Implementierung in der H√§ufigkeit √ºberholen wird.  Feiern Sie den Sieg jedoch nicht so fr√ºh, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> Dokument beschreibt den Xilinx CAM IP-Kern, mit dem beispielsweise CAM mit einer Tiefe von 32K-Zellen und einer Frequenz von 155 MHz basierend auf BRAM erhalten werden kann.  Dieses Ergebnis kann wahrscheinlich in der im Artikel vorgeschlagenen Version erzielt werden, entweder durch Hinzuf√ºgen der Stufen der Pipeline oder durch Sammeln gro√üer CAM von kleinen, aber ich kann nicht sofort vorhersagen, ob es in den Chip passt.  In Zukunft werde ich versuchen, etwas √Ñhnliches auf BRAM zu implementieren, aber vorerst vielen Dank f√ºr Ihre Aufmerksamkeit. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470892/">https://habr.com/ru/post/de470892/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470878/index.html">Erstellen Sie mit Babel benutzerdefinierte JavaScript-Syntaxkonstrukte. Teil 2</a></li>
<li><a href="../de470880/index.html">Spielmechanik. Abenteuer, das Konzept der Null und √ºberzeugende Sprachtherapie</a></li>
<li><a href="../de470882/index.html">Warum hast du meine Maus oder ein Brettspiel als Modell f√ºr soziale Interaktion erwischt?</a></li>
<li><a href="../de470884/index.html">Schreiben und Lesen von Daten in der Bitcoin-Blockchain</a></li>
<li><a href="../de470888/index.html">Russische und internationale Gesetzgebung im Bereich des Schutzes personenbezogener Daten</a></li>
<li><a href="../de470894/index.html">Kugel</a></li>
<li><a href="../de470902/index.html">Hohe Leistung und native Partitionierung: Zabbix mit TimescaleDB-Unterst√ºtzung</a></li>
<li><a href="../de470904/index.html">Der weichste und pelzigste Weg in maschinellem Lernen und tiefen neuronalen Netzen</a></li>
<li><a href="../de470908/index.html">Zum ersten Mal auf der Welt wurde mit Hilfe additiver Technologien eine gro√üformatige Triebwerksbaugruppe f√ºr Flugzeuge erhalten</a></li>
<li><a href="../de470910/index.html">Was kann mit Anmerkungen zu Microservice-Vertr√§gen getan werden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>