<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕳️ 👨🏼‍🔬 👨🏼‍🚒 Einfache Implementierung eines kleinen CAM auf einem FPGA 👷 💾 🔻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 


 Einmal musste ich einen kleinen Block CAM (assoziativen Speicher) implementieren. Nachdem ich gelesen hatte, wie Xilinx dies auf BRAM (...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einfache Implementierung eines kleinen CAM auf einem FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470892/"><h2 id="vvedenie">  Einführung </h2><br><p>  Einmal musste ich einen kleinen Block <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CAM</a> (assoziativen Speicher) implementieren.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nachdem ich gelesen hatte,</a> wie Xilinx dies auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BRAM</a> (statische Speicherblöcke) oder auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SRL16</a> (16-Bit-Schieberegister) macht, war ich ein wenig traurig, da ihre Implementierungen ziemlich viel Platz in Anspruch nahmen.  Ich beschloss, es selbst zu versuchen.  Die erste Option war die Implementierung der Stirn.  Mit Blick auf die Zukunft kam es mir fast sofort in den Sinn und die Zielfrequenz für das Design betrug nur 125 MHz. </p><a name="habracut"></a><br><h2 id="arhitektura">  Architektur </h2><br><p>  Betrachten Sie zunächst die Erklärung des Problems.  Wir brauchen also eine kleine CAM mit einer Wortbreite von 8-64 Bit und einer Tiefe von 16-1024 Wörtern.  Ich brauchte eine binäre Suche in CAM, aber später stellte sich heraus, dass das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen von TCAM</a> (ternärer assoziativer Speicher) ressourcenschonend ist und das Timing geringfügig beeinflusst.  Die untere Frequenzgrenze liegt bei der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kintex7-</a> Familie bei 125 MHz.  Fangen wir an!  Unser CAM besteht aus diesen Zeilen, von denen jede einer Adresse entspricht und ein Wort speichert: </p><br><p><img src="https://habrastorage.org/webt/pv/ua/gk/pvuagk4p3oiguausboxx2ltgc_8.png" alt="Cam_line"></p><br><p>  <em>Abbildung 1. Die Struktur einer CAM-Linie</em> </p><br><p>  In Fig. 1 ist <strong>D</strong> ein regulärer D-Trigger zum Speichern von Daten, wobei die Anzahl dieser Trigger in der Zeile der Breite des Eingabedatenworts in CAM entspricht.  <strong>GÜLTIG</strong> - D-Trigger, der '1' speichert, wenn die Daten in der Zeile relevant sind.  <strong>CMP</strong> ist ein Komparator, der den Wert des entsprechenden <strong>Suchschlüsselbusbits</strong> vergleicht, wenn VALID = '1' ist.  <strong>Daten schreiben</strong> - <strong>Datenbus schreiben</strong> , bitweise mit dem entsprechenden D ( <strong>N</strong> - CAM Wortbreite) verbunden, <strong>wir</strong> - Schreibflag, <strong>Clear</strong> - Reset VALID (Ungültigmachung der Datenleitung).  <strong>UND</strong> - logisches UND von N Ausgängen der Komparatoren, <strong>Match</strong> - Flag wird zu '1', wenn die Suche in dieser Zeile erfolgreich ist. </p><br><p>  Wir haben also eine Zeile, in der wir suchen können.  Kombinieren Sie sie jetzt: </p><br><p><img src="https://habrastorage.org/webt/cn/be/1u/cnbe1uhkh4wyaxifvaq3fpxkbrs.png" alt="Cam_structure"></p><br><p>  <em>Abbildung 2. CAM-Struktur</em> </p><br><p>  In Fig. 2 ist <strong>CAM_line</strong> die CAM-Leitung selbst aus Fig. 1, <strong>MUX</strong> ist der Eingangsadressenmultiplexer, <strong>MATCH REGISTER</strong> ist ein Register, das <strong>Übereinstimmungsflagwerte</strong> speichert, <strong>ENCODER</strong> ist ein Decoder, der den Übereinstimmungsbus in die niedrigste gefundene Übereinstimmungsadresse konvertiert.  <strong>FSM</strong> ist eine steuernde Finite-State-Maschine <strong>.</strong>  <strong>match</strong> entfernt aus MATCH REGISTER das Bit, das der gesendeten Adresse entspricht, sodass ENCODER zur nächsten gefundenen Adresse wechselt.  Die Schnittstelle unseres CAM lautet wie folgt: </p><br><div class="scrollable-table"><table><thead><tr><th>  Linie </th><th>  Richtung </th><th>  Termin </th></tr></thead><tbody><tr><td>  addr </td><td>  Login </td><td>  Adresse schreiben / löschen </td></tr><tr><td>  Daten </td><td>  Login </td><td>  Datensatz- / Schlüsseldaten </td></tr><tr><td>  wir </td><td>  Login </td><td>  Flag aufzeichnen </td></tr><tr><td>  überprüfen </td><td>  Login </td><td>  Schlüsselsuchflagge </td></tr><tr><td>  klar </td><td>  Login </td><td>  Kennzeichnen Sie die Behinderungslinie bei </td></tr><tr><td>  addr_o </td><td>  Beenden </td><td>  Adresse mit Schlüssel gefunden </td></tr><tr><td>  match_o </td><td>  Beenden </td><td>  Erfolgssymbol für Schlüsselsuche </td></tr></tbody></table></div><br><p>  <em>Tabelle 1. CAM-Schnittstelle</em> </p><br><p>  Unten in Fig. 3 ist ein Zeitdiagramm des Betriebs dieser Schnittstelle dargestellt, das zuerst die Aufzeichnung von drei Wörtern in CAM, dann eine erfolgreiche Suche, Löschung und erneute Suche zeigt: </p><br><p><img src="https://habrastorage.org/webt/zg/mw/vn/zgmwvnreqjf_ipoetqs-99mdrt4.png" alt="Cam_diagramm"><br>  <em>Abbildung 3. Zeitdiagramm der Schnittstelle zum CAM</em> </p><br><p>  Wir haben also eine Beschreibung von CAM. Fahren wir mit der Synthese fort. </p><br><h2 id="sintez">  Synthese </h2><br><p>  Wir werden in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Xilinx ISE</a> synthetisieren, um die Ergebnisse mit denen in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XAPP1151</a> zu vergleichen. </p><br><p><img src="https://habrastorage.org/webt/wi/jq/so/wijqso_fo0rq-yvbtqvbfxadtzi.png" alt="W8v5"></p><br><p>  <em>Abbildung 4. Frequenzabhängigkeit nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XST</a> (Synthesizer als Teil von ISE) von der CAM-Tiefe für die 8-Bit-Datenbusbreite</em> </p><br><p><img src="https://habrastorage.org/webt/0g/de/m4/0gdem4tk5j6b2yd3pn9sgcqtp0q.png" alt="W32v5"></p><br><p>  <em>Abbildung 5. Frequenz nach XST im Verhältnis zur CAM-Tiefe für die 32-Bit-Datenbusbreite</em> </p><br><p><img src="https://habrastorage.org/webt/s4/qs/nq/s4qsnqivplq45pvoylyokf947_0.png" alt="W64v5"></p><br><p>  <em>Abbildung 6. Frequenz nach XST im Verhältnis zur CAM-Tiefe für die 64-Bit-Datenbusbreite</em> </p><br><p>  In 6 gibt es keine Daten für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Virtex5</a> , da CAM dieser Größe nicht in das vorhandene BRAM passte.  Wir stellen außerdem fest, dass unser Ergebnis bei einer Breite von 64 Bit und einer Tiefe von 1024 etwas schlechter war als das der Implementierung auf SRL16.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fahren</a> wir nun mit der Vivado-Synthese für den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XC7K325T fort</a> .  Die Ergebnisse sind wie folgt: </p><br><p><img src="https://habrastorage.org/webt/vx/3i/n-/vx3in-n-do46eukhxrkonmugvgy.png" alt="W32k7"></p><br><p>  <em>Abbildung 7. Frequenzabhängigkeit nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PnR</a> (Platzierung von Blöcken auf dem Chip und Signalverfolgung) von der CAM-Tiefe für eine 32-Bit-Datenbusbreite</em> </p><br><p><img src="https://habrastorage.org/webt/w6/1q/qc/w61qqcqylt_tb_0p1taxixcosps.png" alt="K7res"></p><br><p>  <em>Abbildung 8. Verwendung von Ressourcen für verschiedene CAM-Tiefen für eine Datenbreite von 32 Bit in%</em> </p><br><p>  Es ist wichtig zu beachten, dass die Ergebnisse auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vivado</a> nach PnR erhalten wurden, was bedeutet, dass das Design keine Schwierigkeiten bei der Rückverfolgung hat. </p><br><h2 id="tcam">  TCAM </h2><br><p>  Wie oben erwähnt, war es kein besonderes Problem, mit diesem Ansatz von CAM TCAM zu kommen.  Es reicht aus, einen Maskierungsbus für die Datenbits hinzuzufügen und ihn Stück für Stück an die Komparatoren zu verteilen, damit sie beim Vergleich der Daten mit dem Schlüssel deren Wert berücksichtigen.  Eine solche Änderung führte nicht zu einem Frequenzabfall oder einer ernsthaften Erhöhung des Ressourcenverbrauchs, sodass wir TCAM kostenlos erhielten. </p><br><h2 id="vyvody">  Schlussfolgerungen </h2><br><p>  So konnten wir die Aufgabe erledigen.  Das resultierende Design ermöglicht es der 7. Xilinx-FPGA-Familie, ausreichend große CAM mit einer Frequenz über dem Ziel von 125 MHz zu empfangen.  Das Ergebnis des Vergleichs mit XAPP1151 stellte sich für mich als unerwartet heraus. Ich ging davon aus, dass die Implementierung auf BRAM, obwohl sie in Bezug auf Ressourcen sehr teuer ist, die frontale Implementierung in der Häufigkeit überholen wird.  Feiern Sie den Sieg jedoch nicht so früh, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> Dokument beschreibt den Xilinx CAM IP-Kern, mit dem beispielsweise CAM mit einer Tiefe von 32K-Zellen und einer Frequenz von 155 MHz basierend auf BRAM erhalten werden kann.  Dieses Ergebnis kann wahrscheinlich in der im Artikel vorgeschlagenen Version erzielt werden, entweder durch Hinzufügen der Stufen der Pipeline oder durch Sammeln großer CAM von kleinen, aber ich kann nicht sofort vorhersagen, ob es in den Chip passt.  In Zukunft werde ich versuchen, etwas Ähnliches auf BRAM zu implementieren, aber vorerst vielen Dank für Ihre Aufmerksamkeit. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470892/">https://habr.com/ru/post/de470892/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470878/index.html">Erstellen Sie mit Babel benutzerdefinierte JavaScript-Syntaxkonstrukte. Teil 2</a></li>
<li><a href="../de470880/index.html">Spielmechanik. Abenteuer, das Konzept der Null und überzeugende Sprachtherapie</a></li>
<li><a href="../de470882/index.html">Warum hast du meine Maus oder ein Brettspiel als Modell für soziale Interaktion erwischt?</a></li>
<li><a href="../de470884/index.html">Schreiben und Lesen von Daten in der Bitcoin-Blockchain</a></li>
<li><a href="../de470888/index.html">Russische und internationale Gesetzgebung im Bereich des Schutzes personenbezogener Daten</a></li>
<li><a href="../de470894/index.html">Kugel</a></li>
<li><a href="../de470902/index.html">Hohe Leistung und native Partitionierung: Zabbix mit TimescaleDB-Unterstützung</a></li>
<li><a href="../de470904/index.html">Der weichste und pelzigste Weg in maschinellem Lernen und tiefen neuronalen Netzen</a></li>
<li><a href="../de470908/index.html">Zum ersten Mal auf der Welt wurde mit Hilfe additiver Technologien eine großformatige Triebwerksbaugruppe für Flugzeuge erhalten</a></li>
<li><a href="../de470910/index.html">Was kann mit Anmerkungen zu Microservice-Verträgen getan werden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>