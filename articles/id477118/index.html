<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ã üíü ‚öõÔ∏è MIRO adalah platform robot terbuka dalam ruangan. Bagian 5 - Komponen perangkat lunak: ARDUINO (AVR), kami memanjat "di bawah tenda" ‚õÑÔ∏è üßïüèº üêÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kali ini kita akan melihat sedikit lebih dalam tentang implementasi beberapa metode pustaka kunci untuk ARDUINO (AVR), yang bertanggung jawab untuk me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIRO adalah platform robot terbuka dalam ruangan. Bagian 5 - Komponen perangkat lunak: ARDUINO (AVR), kami memanjat "di bawah tenda"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477118/"><img src="https://habrastorage.org/webt/m-/j7/gm/m-j7gmvwywlwzlopp5x-27y_jta.png" alt="gambar"><br><br>  Kali ini kita akan melihat sedikit lebih dalam tentang implementasi beberapa metode pustaka kunci untuk ARDUINO (AVR), yang bertanggung jawab untuk memindahkan robot MIRO.  Bagian ini akan menarik bagi semua orang yang bertanya-tanya bagaimana mengontrol kecepatan linear dan sudut robot pada ARDUINO, dilengkapi dengan motor dengan enkoder yang paling sederhana. <br><a name="habracut"></a><br>  Daftar Isi: <a href="https://habr.com/ru/post/472380/">Bagian 1</a> , <a href="https://habr.com/ru/post/472802/">Bagian 2</a> , <a href="https://habr.com/ru/post/473368/">Bagian 3</a> , <a href="https://habr.com/ru/post/475512/">Bagian 4</a> , <a href="https://habr.com/ru/post/477118/">Bagian 5</a> . <br><br>  Metode yang bertanggung jawab untuk mengemudi dengan odometry masih menyakitkan dalam hal menjelaskan bagaimana, apa, dan mengapa.  Hal pertama yang perlu Anda ketahui tentang mengendalikan pergerakan robot adalah fakta sederhana dan jelas bahwa motor pengumpul robot tidak pernah berputar pada kecepatan yang sama tanpa penyesuaian tambahan.  Kopling yang berbeda, karakteristik keluaran yang berbeda dari saluran driver, motor listrik yang sedikit berbeda dan pelumasan di gearbox. <br><br>  Fakta kedua yang harus Anda pahami dan ketahui adalah kehadiran inersia di mesin, bahkan dengan rasio gigi yang cukup besar.  Yaitu  ketika melepaskan tegangan dari terminal motor, roda, bahkan tidak dimuat, membuat gerakan beberapa derajat lagi.  Besarnya rotasi tambahan ini tergantung pada gaya pemuatan pada roda, pada kecepatan rotasi sebelum menghilangkan stres, dan pada faktor-faktor tak kasat mata yang sama seperti jenis dan jumlah pelumas dalam gearbox. <br><br>  Fakta-fakta ini menentukan implementasi dari sekelompok metode yang berkaitan dengan pergerakan sasis yang dilengkapi dengan sensor odometer (dalam kasus MIRO, penyandi digital dari setiap roda). <br><br>  Seperti yang kami temukan di bagian keempat, dalam model perangkat lunak ada kelas <b>Chassis</b> , yang menerapkan kontrol rotasi mesin sasis individu.  Saya ingin menekankan - bukan kontrol gerakan sasis, troli, tetapi kontrol mesin troli.  Kontrol langsung troli diterapkan di kelas <b>Robot</b> dan <b>Miro</b> . <br><br>  Mari kita mulai dari atas.  Di bawah ini adalah metode kelas <b>Miro</b> yang mengimplementasikan pergerakan robot pada jarak tertentu ( <b>dist</b> , meter) dengan kecepatan linier ( <b>lin_speed</b> , m / s) dan angular ( <b>ang_speed</b> , deg / s).  <b>Kami</b> belum memperhatikan parameter <b>en_break</b> . <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Miro::moveDist(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lin_speed, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ang_speed, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> en_break) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _wheelSetAngSpeed[WHEEL_COUNT]; _wheelSetAngSpeed[LEFT] = MIRO_PI2ANG * (lin_speed - (ROBOT_DIAMETER * ang_speed / (<span class="hljs-number"><span class="hljs-number">2</span></span> * MIRO_PI2ANG))) / WHEEL_RADIUS; _wheelSetAngSpeed[RIGHT] = MIRO_PI2ANG * (lin_speed + (ROBOT_DIAMETER * ang_speed / (<span class="hljs-number"><span class="hljs-number">2</span></span> * MIRO_PI2ANG))) / WHEEL_RADIUS; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _wheelSetAng[WHEEL_COUNT]; _wheelSetAng[RIGHT] = _wheelSetAngSpeed[RIGHT] * dist / lin_speed; _wheelSetAng[LEFT] = _wheelSetAngSpeed[LEFT] * dist / lin_speed; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;chassis.wheelRotateAng(_wheelSetAngSpeed, _wheelSetAng, en_break); }</code> </pre> <br>  Dalam metode ini, kecepatan sudut DIBUTUHKAN untuk mesin kiri dan kanan pertama kali dihitung.  Menurut formula yang cukup jelas, yang tidak masalah untuk disimpulkan.  Hanya perlu diingat bahwa kecepatan linear dalam metode ini ditentukan dalam meter per detik, dan kecepatan sudut dalam derajat per detik (bukan dalam radian).  Oleh karena itu, kami menghitung sebelumnya konstanta <b>MIRO_PI2ANG = 57.29 = 180 / pi.</b>  <b>ROBOT_DIAMETER</b> - jarak antara roda kiri dan kanan robot (dalam meter), <b>WHEEL_RADIUS</b> - jari-jari roda (juga dalam meter).  Semua konstanta numerik untuk kasus tersebut terkandung dalam file defs.h, dan parameter khusus robot dan sasis ada di file config.h. <br><br>  Setelah itu, sudut dihitung dengan mana setiap roda harus diputar sehingga robot menempuh jarak <b>dist</b> (juga dalam meter). <br><br>  Jadi, pada tahap ini kita mendapatkan kecepatan dan sudut apa yang Anda butuhkan untuk memutar setiap roda sasis robot.  Dan kemudian metode <b>wheelRotateAng ()</b> dari objek <b>sasis</b> disebut. <br><br>  Metode <b>wheelRotateAng (kecepatan float *, float * ang, bool en_break)</b> digunakan untuk memutar roda robot dengan kecepatan sudut yang ditentukan oleh array <b>kecepatan []</b> (dalam m / s) dengan sudut yang ditentukan oleh larik <b>ang []</b> (dalam derajat).  Parameter terakhir <b>en_break</b> (sudah kami temui sebelumnya) menetapkan persyaratan untuk pemberhentian roda setelah berbelok dengan menerapkan tegangan balik jangka pendek untuknya.  Ini diperlukan untuk menekan inersia robot, mencegahnya bergerak melampaui jarak yang diperlukan setelah melepas tegangan kontrol dari motor.  Untuk kepuasan penuh, tentu saja, ada metode <b>wheelRotateAngRad ()</b> , mirip dengan <b>wheelRotateAng ()</b> dengan perbedaan bahwa dibutuhkan nilai sudut rotasi dan kecepatan sudut dalam radian dan radian per detik sebagai parameter. <br><br>  Algoritma metode <b>wheelRotateAng ()</b> adalah sebagai berikut. <br><br>  1. Pertama, korespondensi nilai dari <b>kecepatan []</b> dan <b>ang [] untuk</b> beberapa kondisi batas diperiksa.  Jelas, sasis memiliki keterbatasan fisik baik pada kecepatan sudut maksimum rotasi roda, dan pada minimum (kecepatan minimum menjauh).  Juga, sudut dalam <b>ang []</b> tidak boleh kurang dari sudut tetap minimum rotasi, ditentukan oleh keakuratan pembuat enkode. <br><br>  2. Selanjutnya, arah rotasi setiap roda dihitung.  Jelas melalui tanda produk <b>dan [i] * kecepatan [i]</b> ; <br><br>  3. ‚ÄúJarak rotasi‚Äù <b>Dw [i]</b> untuk setiap roda dihitung - jumlah sampel enkoder yang harus dilakukan untuk diputar oleh <b>ang [i] yang diberikan</b> . <br>  Nilai ini ditentukan oleh rumus: <br><br>  <b>Dw [i] = ang [i] * WHEEL_SEGMENTS / 360</b> , <br>  di mana <b>WHEEL_SEGMENTS</b> adalah jumlah segmen dari roda enkoder (revolusi penuh). <br><br>  4. Nilai tegangan pada driver motor dicatat. <br><br><div class="spoiler">  <b class="spoiler_title">Tentang tegangan pada mesin</b> <div class="spoiler_text">  * <i>PWM digunakan untuk mengontrol putaran motor, oleh karena itu, untuk mengetahui tegangan yang dipasok ke setiap motor, Anda perlu mengetahui tegangan suplai driver motor.</i>  <i>Pada robot MIRO, pengemudi terhubung langsung ke sirkuit daya baterai.</i>  <i>Function float getVoltage ();</i>  <i>mengembalikan tegangan dari pembagi tegangan dengan faktor VOLTAGE_DIVIDER.</i>  <i>Tegangan referensi ADC: 5V.</i>  <i>Saat ini, nilai VOLTAGE_DIVIDER dalam robot adalah 2, dan tegangan dari satu bank (1S) baterai disuplai ke input ADC (PIN_VBAT).</i>  <i>Ini tidak sepenuhnya benar karena fakta bahwa bank baterai dapat melepaskan berbeda dan kehilangan keseimbangan, tetapi, seperti yang telah ditunjukkan oleh praktik, dengan muatan konstan baterai dengan keseimbangan, solusinya cukup bekerja.</i>  <i>Di masa depan kami berencana untuk membuat pembagi normal dengan dua kaleng baterai.</i> <br></div></div><br>  5. Menurut tabel kalibrasi untuk setiap roda, nilai awal sinyal PWM ditentukan, yang memastikan rotasi roda dengan kecepatan <b>kecepatan yang</b> diperlukan <b>[i]</b> .  Jenis tabel kalibrasi dan dari mana asalnya - kami akan menganalisis lebih lanjut. <br><br>  6. Rotasi mesin dimulai sesuai dengan nilai kecepatan dan arah putaran yang dihitung.  Dalam teks implementasi kelas, metode pribadi <b>_wheel_rotate_sync ()</b> bertanggung jawab untuk ini. <br><br>  Kami melangkah lebih dalam.  Metode <b>_wheel_rotate_sync ()</b> bekerja sesuai dengan algoritma berikut: <br><br>  1. Dalam loop tak terbatas, pemeriksaan dilakukan untuk mencapai penghitung respons enkoder dari jarak belok <b>Dw [i]</b> untuk setiap roda.  Jika salah satu dari penghitung <b>Dw [i]</b> tercapai, semua roda berhenti dan keluar dari siklus dan kemudian keluar dari fungsi (langkah 5).  Ini dilakukan karena alasan berikut.  Karena perbedaan pengukuran sudut rotasi, itu adalah situasi yang sangat umum ketika jarak terhitung <b>Dw [i] dari</b> satu roda diperoleh dengan membulatkan nilai non-integer ke sisi yang lebih kecil dan <b>Dw [j] dari</b> roda kedua ke yang lebih besar.  Ini mengarah pada fakta bahwa setelah menghentikan salah satu roda, roda kedua terus berbelok.  Untuk sasis dengan penggerak diferensial (dan untuk banyak lainnya), ini mengarah pada "pergantian" robot yang tidak terencana di akhir tugas.  Karena itu, dalam hal mengatur pergerakan spasial dari seluruh sasis, perlu untuk menghentikan semua mesin sekaligus. <br><br>  2. Jika <b>Dw [i]</b> tidak tercapai, maka di loop fakta operasi encoder berikutnya diperiksa (variabel <b>_syncloop [w]</b> , diperbarui dari interupsi encoder dan reset di loop infinite ini).  Ketika persimpangan berikutnya terjadi, program menghitung modul kecepatan sudut saat ini setiap roda (deg / s), sesuai dengan rumus yang jelas: <br><br>  <b>W [i] = (360 * tau [i]) / WHEEL_SEGMENTS</b> , <br>  dimana: <br>  <b>tau [i]</b> - nilai rata-rata waktu antara dua respons terakhir dari pembuat enkode.  "Kedalaman" dari filter rata-rata ditentukan oleh <b>MEAN_DEPTH</b> dan default ke 8. <br><br>  3. Berdasarkan kecepatan roda yang dihitung, kesalahan absolut dihitung sebagai perbedaan antara set dan kecepatan sudut aktual. <br><br>  4. Berdasarkan kesalahan yang dihitung, aksi kontrol (nilai sinyal PWM) dikoreksi untuk setiap motor. <br><br>  5. Setelah mencapai <b>Dw [i]</b> , dalam kasus <b>en_break</b> aktif, <b>tegangan</b> balik jangka pendek diterapkan ke motor.  Durasi efek ini ditentukan dari tabel kalibrasi (lihat di bawah) dan biasanya berkisar antara 15 hingga 40 ms. <br><br>  6. Ada rilis lengkap stres dari mesin dan keluar <b>_wheel_rotate_sync ()</b> . <br><br>  Saya sudah menyebutkan tabel kalibrasi tertentu dua kali.  Jadi, di perpustakaan ada tabel khusus nilai yang disimpan di EEPROM memori robot dan berisi rekaman tiga nilai terkait: <br><br>  1. Tegangan di terminal motor.  Ini dihitung dengan menerjemahkan nilai sinyal PWM ke tegangan aktual.  Untuk ini, pada langkah 4 metode <b>wheelRotateAng ()</b> , tegangan aktual pada driver mesin dicatat. <br><br>  2. Kecepatan sudut rotasi roda (tanpa beban) sesuai dengan tegangan yang diberikan. <br><br>  3. Durasi sinyal henti sesuai dengan kecepatan sudut ini. <br>  Secara default, ukuran tabel kalibrasi adalah 10 catatan (ditentukan oleh <b>WHEEL_TABLE_SIZE</b> konstan dalam file <b>config.h</b> ) - 10 tiga kali lipat dari nilai "tegangan - kecepatan sudut - durasi sinyal berhenti". <br><br>  Untuk menentukan nilai dari entri 2 dan 3 dalam tabel ini, metode khusus digunakan - <b>wheelCalibrate (byte wheel)</b> . <br><br>  Mari kita lihat sedikit ke dalamnya.  Metode ini mengimplementasikan serangkaian tindakan untuk menentukan nilai yang hilang dalam tabel kalibrasi engine / roda, serta untuk mengetahui kecepatan sudut minimum mulai dan kecepatan sudut maksimum roda. <br><br>  Untuk melakukan kalibrasi, robot dipasang pada dudukan, semua rotasi roda selama kalibrasi dilakukan tanpa beban. <br><br>  1. Pertama, Anda perlu menentukan kecepatan mulai minimum.  Ini dilakukan dengan sangat sederhana.  Dalam sebuah siklus, PWM kontrol diumpankan ke mesin, mulai dari 0, dengan kenaikan 1. Pada setiap langkah, program menunggu beberapa waktu, ditentukan oleh <b>WHEEL_TIME_MAX</b> konstan ( <b>penundaan</b> normal <b>()</b> ).  Setelah waktu tunggu berlalu, ia memeriksa apakah permulaan telah selesai (dengan mengubah nilai penghitung pembuat enkode).  Jika pullaway selesai, maka kecepatan sudut rotasi roda dihitung.  Untuk kepastian yang lebih besar, nilai 10 ditambahkan ke nilai PWM yang sesuai dengan kecepatan awal ini. Ini memberikan pasangan pertama nilai "tegangan pada motor" - "kecepatan sudut". <br><br>  2. Setelah kecepatan mulai ditemukan, langkah PWM dihitung untuk mengisi tabel kalibrasi secara seragam. <br><br>  3. Dalam siklus, untuk setiap nilai PWM baru, roda diputar 2 putaran penuh dan kecepatan sudut diukur sesuai dengan algoritma yang mirip dengan metode <b>_wheel_rotate_sync ()</b> .  Dalam siklus yang sama, juga dengan pendekatan yang berurutan, nilai optimal dari durasi sinyal berhenti diukur.  Awalnya, beberapa nilai jelas diambil.  Dan kemudian diuji dalam mode "turn-stop".  Sebagai yang optimal, nilai maksimum durasi sinyal stop dipilih, di mana "putaran jarak" yang ditetapkan tidak terlampaui.  Dengan kata lain, nilai durasi sinyal seperti itu, pada saat pasokan ke mesin di satu sisi, inersia ditekan, dan di sisi lain, tidak ada gerakan mundur jangka pendek (yang difiksasi oleh enkoder yang sama). <br><br>  4. Setelah kalibrasi selesai, tegangan kontrol ke motor yang dikalibrasi berhenti diterapkan dan tabel kalibrasi roda ini dicatat dalam EEPROM. <br><br>  Saya menghilangkan segala macam hal sepele dari implementasi dan mencoba untuk menyatakan esensinya.  Anda mungkin memperhatikan bahwa metode <b>wheelRotateAng ()</b> dan <b>wheelRotateAngRad ()</b> menghalangi fungsi.  Ini adalah harga untuk akurasi gerakan dan integrasi yang cukup sederhana ke dalam sketsa pengguna.  Dimungkinkan untuk membuat task manager kecil dengan timing tetap, tetapi ini akan mengharuskan pengguna untuk menanamkan fungsionalitas mereka secara ketat dalam kuota waktu yang diberikan. <br><br>  Dan untuk aplikasi non-blocking, API memiliki fungsi <b>wheelRotate (float * speed)</b> .  Itu, seperti yang dapat dilihat dari daftar parameter, cukup melakukan rotasi roda dengan kecepatan yang ditetapkan.  Dan kecepatan rotasi disesuaikan dalam metode <b>Sync ()</b> pada sasis robot, yang disebut dalam metode <b>Sync ()</b> dari objek kelas Miro dengan nama yang sama.  Dan sesuai dengan persyaratan untuk struktur sketsa pengguna, metode ini harus disebut setiap iterasi dari <b>loop</b> utama <b>() loop dari</b> sketsa ARDUINO. <br><br>  Pada langkah 4, dalam uraian metode <b>_wheel_rotate_sync ()</b> , saya menyebutkan "koreksi kontrol" dari mesin.  Bagaimana menurut Anda)?  Ini adalah kontroler PID).  Nah, lebih tepatnya kontroler PD.  Seperti yang Anda tahu (pada kenyataannya - tidak selalu), cara terbaik untuk menentukan koefisien regulator adalah seleksi).  Ada satu definisi dalam file konfigurasi config.h: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEBUG_WHEEL_PID</span></span></code> </pre><br>  Jika Anda membatalkan komentarnya, maka ketika Anda memanggil metode <b>moveDist ()</b> dari kelas Miro, grafik terbalik berikut dari kesalahan relatif dalam mengendalikan kecepatan sudut salah satu roda robot (kiri) akan ditampilkan di konsol robot. <br><br> <a href=""><img src="https://habrastorage.org/webt/_v/4i/hr/_v4ihrxfnzpq-fvnofq_3kjkcz0.png"></a> <br><br>  Tidak menyerupai apa pun)?  Turun adalah waktu (setiap batang adalah langkah dari siklus kontrol), dan nilai kesalahan disimpan ke kanan (dengan tanda dipertahankan).  Berikut adalah dua pasang grafik pada skala yang sama dengan koefisien yang berbeda dari pengontrol PD.  "Humps" hanyalah "gelombang" dari overshoot.  Angka-angka pada bilah horizontal adalah kesalahan relatif (dengan pelestarian tanda).  Visualisasi sederhana dari regulator, membantu menyesuaikan koefisien secara manual.  Seiring waktu, saya berharap untuk melakukan pengaturan otomatis, tetapi untuk sekarang. <br><br>  Berikut adok seperti itu :-) <br><br>  Terakhir, mari kita lihat sebuah contoh.  Langsung dari perpustakaan API_Miro_moveDist: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Miro.h&gt; using namespace miro; byte PWM_pins[2] = { 5, 6 }; byte DIR_pins[2] = { 4, 7 }; byte ENCODER_pins[2] = { 2, 3 }; Miro robot(PWM_pins, DIR_pins, ENCODER_pins); int laps = 0; void setup() { Serial.begin(115200); } void loop() { for (unsigned char i = 0; i &lt; 4; i++) { robot.moveDist(robot.getOptLinSpeed(), 0, 1, true); delay(500); robot.rotateAng(0.5*robot.getOptAngSpeed(), -90, true); delay(500); } Serial.print("Laps: "); Serial.println(laps); laps++; }</span></span></span></span></code> </pre><br>  Dari teks program semuanya harus jelas.  Cara kerjanya - dalam video. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Bd96kgY2YsY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  600 x 600 mm ubin dan celah ubin 5 mm.  Secara teori, robot harus mengelilingi kotak dengan sisi 1 meter.  Tentu saja, lintasan "melayang".  Tetapi dalam keadilan layak untuk mengatakan bahwa dalam versi robot yang telah saya uji, ada mesin yang cukup berputar yang sulit untuk dikendarai dengan lambat.  Tetapi pada kecepatan tinggi dan selip ada tempat untuk dituju, dan kelembaman tidak mudah untuk diatasi.  Mesin dengan rasio roda gigi yang lebih tinggi (seperti bahkan pada robot MIRO kami, tidak tersedia selama pengujian) harus berperilaku agak lebih baik. <br><br>  Jika ada saat-saat yang tidak dapat dipahami - Saya senang mengklarifikasi, mendiskusikan dan meningkatkan.  Umpan balik umumnya menarik. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477118/">https://habr.com/ru/post/id477118/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477098/index.html">Kami menangani transmisi video dalam resolusi 4K pada 60 Hz melalui hub USB-C</a></li>
<li><a href="../id477100/index.html">Marathon Teknis Microsoft Dynamics 365</a></li>
<li><a href="../id477104/index.html">IntelliSense yang dibantu AI untuk basis kode tim Anda</a></li>
<li><a href="../id477110/index.html">Perencanaan yang menghibur</a></li>
<li><a href="../id477114/index.html">Implementasi penerjemah MSH</a></li>
<li><a href="../id477120/index.html">Perangkat Lunak Pemantauan Glukosa Darah Berkelanjutan untuk Windows</a></li>
<li><a href="../id477122/index.html">Otak perusahaan. Bagian 3</a></li>
<li><a href="../id477124/index.html">Bitcoin dalam sangkar?</a></li>
<li><a href="../id477126/index.html">Admin dalam 5 menit. Frontend - react-admin, backend - Flask-RESTful</a></li>
<li><a href="../id477128/index.html">Detektif Habra di akhir pekan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>