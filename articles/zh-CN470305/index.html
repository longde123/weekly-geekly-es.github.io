<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔩 🤖 🚱 准备春季专业认证。 容器，IoC，豆类 ⛹🏼 👩🏿‍🔬 🥞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="美好的一天，哈伯。 


 今天，我决定向您介绍一系列文章的翻译，以准备进行Spring Professional认证 。 


 这篇翻译只是第一篇文章，如果涉及到读者，我将继续发表翻译。 
 我为什么要这样做，因为已经有很多专门材料？ 

1. 通常，其中的信息不是结构化，未收集或不相关的 
2...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>准备春季专业认证。 容器，IoC，豆类</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470305/"><p> 美好的一天，哈伯。 </p><br><p> 今天，我决定向您介绍<a href="">一系列文章</a>的翻译，以准备进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Spring Professional认证</a> 。 </p><br><p> 这篇翻译只是第一篇文章，如果涉及到读者，我将继续发表翻译。 </p><br><div class="spoiler">  <b class="spoiler_title">我为什么要这样做，因为已经有很多专门材料？</b> <div class="spoiler_text"><ol><li> 通常，其中的信息不是结构化，未收集或不相关的 <br></li><li> 年轻的开发人员可能不会英语。 此循环不仅可以用于认证，还可以用于材料的自我训练/重复。 <br></li><li> 这些材料可以用来准备面试，因为 它们以问题和答案的形式排列。 <br></li><li>一个重要的也是最重要的优点是，此QA由正式的Pivotal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">研究指南中</a>的问题组成。 <br></li></ol><br><ul><li> 我故意遗漏了一些我觉得多余的问题，或者不在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">指南中的问题</a> 。 </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">目录</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">依赖注入，容器，IoC，bean</a> </li><li>  AOP（面向方面​​的编程） </li><li>  JDBC，事务，JPA，Spring数据 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">春季靴</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">春季MVC</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">春季安全</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">休息</a> </li><li> 测试中 </li></ol></div></div><br><img src="https://habrastorage.org/webt/r4/jl/yi/r4jlyi8dwzp-e9xvywevoicmwsg.jpeg"><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">我将列出作者从中获取资料的来源清单</b> <div class="spoiler_text"><ul><li> 春季5种设计模式 <br></li><li> 春季行动第四版 <br></li><li>  Spring Security-第三版 <br></li><li>  Ivan Krizsan详细介绍了Core Spring 5认证 <br></li><li>  Spring文档和Spring API javadocs <br></li></ul></div></div><br><p> 因此，让我们开始吧。 </p><br><div class="spoiler">  <b class="spoiler_title">什么是依赖项注入（DI）及其好处？</b> <div class="spoiler_text"><p> 依赖注入是一种特殊的模式，可以减少Spring组件之间的通信。 因此，在应用DI时，您的代码将变得更简洁，更简单，也更易于理解和测试。 <br> 根据DI模式，将为依赖项创建的对象转移到工厂或交给第三方。 这意味着我们可以专注于使用这些对象而不是创建它们。 </p><br><div class="spoiler">  <b class="spoiler_title">DI的好处</b> <div class="spoiler_text"><ul><li> 减少应用程序各部分之间的通信 <br></li><li> 改进测试 <br></li><li> 增强型应用架构 <br></li><li> 减少样板代码 <br></li><li> 标准化应用程序开发 <br></li></ul></div></div></div></div><br><div class="spoiler">  <b class="spoiler_title">为什么建议使用接口来创建Spring Bean？</b> <div class="spoiler_text"><ul><li> 改进了测试。 在测试中，可以用实现Bean接口的特殊对象（模拟或存根）替换Bean。 <br></li><li> 允许您使用JDK中的动态代理机制（例如，通过Spring Data创建存储库时） <br></li><li> 允许您隐藏实施 <br></li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">什么是应用程序上下文？</b> <div class="spoiler_text"><p>在Spring框架中， <code>org.springframework.factory.BeanFactory</code>接口提供了一个<code>org.springframework.factory.BeanFactory</code>工厂，它同时是一个IoC应用程序容器。  Bean管理基于配置（java或xml）。 </p><br><p>  <code>org.springframework.context.ApplicationContext</code>接口是Bean工厂的包装，提供了一些附加功能，例如AOP，事务，安全性，i18n等。 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">什么是容器，容器的生命周期是什么？</b> <div class="spoiler_text"><p>  Spring Framework的基础是一个容器，我们的对象“活”在该容器中。 <br> 容器通常根据其配置创建许多对象，并管理从创建对象到销毁对象的生命周期。 </p><br><p> 容器是实现<b>ApplicationContext</b>接口的对象。 </p><br><div class="spoiler">  <b class="spoiler_title">容器生命周期</b> <div class="spoiler_text"><ol><li> 该容器在应用程序启动时创建。 <br></li><li> 容器读取配置数据 <br></li><li> 箱的描述是根据配置数据创建的 <br></li><li>  BeanFactoryPostProcessors处理Bean描述 <br></li><li> 容器使用其描述创建bean <br></li><li>  Bean被初始化-属性值和依赖项被嵌入到Bean中 <br></li><li>  BeanPostProcessor启动回调方法 <br></li><li> 该应用程序已启动并正在运行 <br></li><li> 初始化应用程序关闭 <br></li><li> 集装箱关闭 <br></li><li> 调用回调方法 <br></li></ol></div></div></div></div><br><div class="spoiler">  <b class="spoiler_title">如何创建ApplicationContext的实例？</b> <div class="spoiler_text"><p>  Spring提供了几种上下文变化。 </p><br><p>  ApplicationContext接口有几种基本实现： </p><br><ul><li>  FileSystemXmlApplicationContext <br></li><li>  ClassPathXmlApplicationContext <br></li><li>  AnnotationConfigApplicationContext <br></li><li>  XmlWebApplicationContext <br></li><li>  AnnotationConfigWebApplicationContext <br></li></ul><br><p> 创建上下文的示例： </p><br><pre> <code class="java hljs">ApplicationContext ctx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileSystemXmlApplicationContext(                                     <span class="hljs-string"><span class="hljs-string">"c:/bean_properties.xml"</span></span>); ApplicationContext ctx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnnotationConfigApplicationContext(                            <span class="hljs-string"><span class="hljs-string">"com.springdemoapp.JavaConfig.class"</span></span>);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">您能否描述容器中bean的生命周期？</b> <div class="spoiler_text"><ol><li> 加载箱描述，创建一个依赖图（在bean之间） </li><li> 创建并<code>BeanFactoryPostProcessors</code> </li><li> 创建豆 </li><li>  Spring将值和依赖项注入到bean属性中 </li><li> 如果bean从NameBeanAware接口实现<code>setBeanName()</code>方法，则将bean ID传递给该方法。 </li><li> 如果bean实现了BeanFactoryAware，则Spring通过<code>setBeanFactory()</code>从此接口建立对bean工厂的引用。 </li><li> 如果bean实现了ApplicationContextAware接口，则Spring通过<code>setApplicationContext()</code>建立对ApplicationContext的引用。 </li><li>  <code>BeanPostProcessor</code>是一个特殊的接口（在下面有关于它的信息），Spring允许垃圾箱实现此接口。 通过实现<code>postProcessBeforeInitialization()</code>方法，可以在初始化bean（bean）之前更改bean的实例（设置属性等）。 </li><li> 如果定义了回调方法，则Spring会调用它们。 例如，这是一个<code>@PostConstruct</code>或<code>@Bean</code>注释中的<code>initMethod</code>方法注释的方法。 </li><li>  Bean现在可以使用了。 可以使用<code>ApplicationContext#getBean()</code>方法获得它。 </li><li> 在关闭上下文（ApplicationContext中的<code>close()</code>方法）之后，将销毁该Bean。 </li><li> 如果bean具有<code>@PreDestroy</code>注释的<code>@PreDestroy</code> ，则此方法将在销毁之前调用。 如果bean实现了DisposibleBean，则Spring将调用<code>destroy()</code>方法清除资源或杀死应用程序中的进程。 如果<code>destroyMethod</code>定义了<code>@Bean</code>方法，则也将调用它。 <br><img src="https://habrastorage.org/webt/kx/at/5e/kxat5ery0dcq_sujzijmiqyutda.png"></li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">如何在集成测试中获取ApplicationContext？</b> <div class="spoiler_text"><p> 如果使用的是JUnit 5，则需要指定2个注释： </p><br><ul><li>  @ExtendWith（TestClass.class）-用于指示测试类 <br></li><li>  @ContextConfoguration（类= JavaConfig.class）-加载Java / xml配置以在测试中创建上下文 <br></li></ul><br><p> 您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>@SpringJUnitConfig</code></a>批注，该批注将这两个批注结合在一起。 <br> 您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>@SpringJUnitWebConfig</code></a>批注来测试Web层。 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">如何在应用程序中关闭上下文？</b> <div class="spoiler_text"><p> 如果这不是Web应用程序，则有两种方法： </p><br><ul><li> 使用<code>registerShutdownHook()</code>方法调用注册shutdown-hook，它也在AbstractApplicationContext类中实现。 这是首选方法。 </li><li> 您可以从AbstractApplicationContext类调用<code>close()</code>方法。 </li></ul><br><p> 在Spring Boot应用程序中： </p><br><ul><li>  Spring Boot将自行为您注册关闭挂钩。 </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">什么是Java配置？</b>  <b class="spoiler_title">如何使用？</b> <div class="spoiler_text"><p> 要创建具有基于Java代码的配置的类，您需要使用注释它 <br>  <code>@Configuration</code> 。 <br> 此类将包含用于在容器中创建bean的工厂方法。 <br> 这些方法应使用<code>@Bean</code>注释进行注释。 </p><br><p> 一个例子： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DSConfig</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DataSource </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DataSourceBuilder          .create()          .username(<span class="hljs-string"><span class="hljs-string">""</span></span>)          .password(<span class="hljs-string"><span class="hljs-string">""</span></span>)          .url(<span class="hljs-string"><span class="hljs-string">""</span></span>)          .driverClassName(<span class="hljs-string"><span class="hljs-string">""</span></span>)          .build();  } }</code> </pre> <br><p> 此类将DataSource类的实例放置在容器中。 以后可以在访问数据库时使用它。 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">DI使用注释，类扫描</b> <div class="spoiler_text"><p> 组件扫描-Spring自动检测将在容器中的bean。 这些是带有注释定型的箱。 </p><br><p> 但是，默认情况下不启用组件扫描。 <br> 要启用扫描，请使用注释<code>@ComponentScanning</code>注释@ Configuration类。  Spring将自动扫描包含此类及其所有子包的包。 <br> 您可以指定其他要扫描的包，甚至是类： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 2  @Configuration(basePackages = {"soundsystem", "video"})</span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  @Configuration(basePackageClasses = "MyClass.class")</span></span></code> </pre> <br><p> 自动装配-扫描或将垃圾箱放入容器时，Spring会自动注入依赖项。 <br> 依赖注入使用<code>@Autowire</code>批注。 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">什么是刻板印象（注释-刻板印象）？</b> <div class="spoiler_text"><p> 刻板印象是表示特殊功能的注释。 <br> 所有<code>@Component</code>型都包含<code>@Component</code>批注。 </p><br><div class="scrollable-table"><table><tbody><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">组成部分</a> </td><td> 将类标记为自动实现候选者的根注释 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">控制者</a> </td><td> 指示该类是用于将数据发送到前端的控制器。 <br></td></tr><tr><td>  @RestController </td><td> 指示该类是REST的控制器。 <br> 包含<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Controller</a>和@ResponseBody批注 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">服务专区</a> </td><td> 指示该类是用于执行业务逻辑的服务。 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">资料库</a> </td><td> 指示该类是用于处理数据库的存储库。 </td></tr><tr><td>  @配置 </td><td> 指示该类包含Java配置（@ Bean方法） </td></tr></tbody></table></div></div></div><br><div class="spoiler">  <b class="spoiler_title">bin范围是什么？</b>  <b class="spoiler_title">他们的默认可见性是什么？</b> <div class="spoiler_text"><p> 范围-范围。 有2个默认范围。 </p><br><div class="scrollable-table"><table><tbody><tr><td> 辛格尔顿 <br></td><td> 默认范围。 容器中只有1个bean实例 <br></td></tr><tr><td> 样机 <br></td><td> 容器中可以有任意数量的Bin实例 <br></td></tr></tbody></table></div><br><p>  Web应用程序中的4个作用域。 </p><br><div class="scrollable-table"><table><tbody><tr><td> 索取 <br></td><td> 范围-1个HTTP请求。 为每个请求创建一个新bean。 <br></td></tr><tr><td> 届会 <br></td><td> 范围-1节。 为每个会话创建一个新bean。 <br></td></tr><tr><td> 申请书 <br></td><td> 范围-ServletContext生命周期 <br></td></tr><tr><td> 网络插座 <br></td><td> 范围-WebSocket生命周期 <br></td></tr></tbody></table></div><br><p> 使用<code>@Bean</code>方法上的<code>@Scope</code>注释指示范围。 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">各种作用域和多线程有何关系？</b> <div class="spoiler_text"><p> 原型范围不是线程安全的，因为 它不能保证仅在1个线程中调用同一实例。 </p><br><p> 另一方面，Singleton Scope是线程安全的。 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">如何创建豆：立即还是懒惰？</b>  <b class="spoiler_title">如何改变这种行为？</b> <div class="spoiler_text"><p> 通常在扫描后立即创建单例豆。 <br> 原型bean通常仅在请求时创建。 </p><br><p> 您可以使用<code>@Lazy</code>批注指示如何初始化。 <br> 它放在@Bean方法，@ Configuration类或@Component类上。 <br> 根据注释所接受的参数（是或否），初始化将是延迟的或立即进行。 默认情况下（即未指定参数），使用true。 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">如果将具有一个合并范围的合并箱嵌入另一个具有合并范围的合并箱，会发生什么情况？</b> <div class="spoiler_text"><p>  Singleton bean可以嵌入任何其他bean中。 </p><br><p> 只有<em><code>prototype</code></em>或<em><code>singleton</code></em>可以嵌入在<em><code>singleton</code></em> 。 <br> 如果实现原型，则将为每个单例创建一个唯一的原型。 </p><br><p> 原型可以是任何bean的依赖项。 <br> 您只能实现单例或原型。 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">什么是BeanFactoryPostProcessor？何时使用？</b> <div class="spoiler_text"><ul><li>  <code>BeanFactoryPostProcessor</code>在创建垃圾箱之前先处理垃圾箱描述或配置元数据。 </li><li>  Spring提供了几个有用的<code>BeanFactoryPostProcessor</code>实现，例如，读取属性文件并从中获取<code>BeanFactoryPostProcessor</code>属性。 </li><li> 您可以编写自己的BFPP实现。 </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">为什么需要静态@Bean方法？</b> <div class="spoiler_text"><p> 为了使用自定义BFPP。 您可以覆盖从图元文件获取数据的机制。 </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> PropertySourcesPlaceholderConfigurer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pspc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-comment"><span class="hljs-comment">//,    pspc }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">描述@Bean批注的属性</b> <div class="spoiler_text"><ul><li>  <code>destroyMethod</code>指向回调方法。 该方法在垃圾箱中。 </li><li>  <code>initMethod</code>指向回调方法。 该方法在垃圾箱中。 </li><li>  <code>name</code> -Bean的名称。 默认情况下，bean名称是方法名称。 </li><li>  <code>value</code> -名称的别名（） </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">什么是BeanPostProcessor，它与BeanFactoryPostProcessor有何不同？</b> <div class="spoiler_text"><p>  Spring使用了几个BeanPostProcessor。 <br> 例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>CommonAnnotationPostProcessor</code></a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>AutowiredAnnotationBeanPostProcessor</code></a> 。 <br>  BPP适用于Bean实例，即 容器创建容器，然后BPP启动。 </p><br><img src="https://habrastorage.org/webt/7u/-v/bt/7u-vbtqvcgkoscws4xca3e90yrw.png"></div></div><br><div class="spoiler">  <b class="spoiler_title">什么是回调方法以及如何使用它们？</b> <div class="spoiler_text"><p> 创建此类方法有3个选项： </p><br><ul><li>  <code>@PreDestroy</code>和<code>@PostConstruct</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">批注</a> </li><li>  <code>destroyMethod</code>批注中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a> <code>initMethod</code>和<code>destroyMethod</code>指向Bean类中的方法 </li><li>  <code>InitializingBean#afterPropertiesSet()</code>和<code>DisposableBean#destroy()</code> 。 要覆盖这些方法，您需要实现相应的接口。 </li></ul><br><img src="https://habrastorage.org/webt/y6/yz/yx/y6yzyxkd94o9omsqbjimep2fowg.png"></div></div><br><div class="spoiler">  <b class="spoiler_title">如何使用@Autowire注释，这两种方法有什么区别？</b> <div class="spoiler_text"><p> 以下是可以在您的应用程序中使用的DI的类型： </p><br><ul><li> 构造函数DI </li><li> 二传手 </li><li> 场二 </li></ul><br><p> 通过构造函数进行DI被认为是最好的方法，因为 对他来说，不需要使用反射，并且他也没有二传手的直接投资的缺点。 <br> 不建议通过字段进行DI，因为 为此，使用反射会降低生产率。 <br> 通过构造函数进行DI可能导致<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">循环依赖</a> 。 为了避免这种情况，可以通过设置器使用bean或DI的惰性初始化。 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">描述@Autowired注解的行为</b> <div class="spoiler_text"><ol><li> 容器确定要嵌入的对象的类型。 </li><li> 容器在上下文（也就是容器）中搜索与所需类型匹配的bean </li><li> 如果有多个候选者，并且其中一个标记为<code>@Primary</code> ，则将其实现 </li><li> 如果使用<code>@Autowire</code> + <code>Qualifier</code>批注，则容器将使用<code>@Qualifier</code>的信息来确定要部署的组件 </li><li> 否则，容器将尝试根据其名称或ID注入组件。 </li><li> 如果所有方法均无效，则将引发异常 </li></ol><br><p> 容器使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AutowiredAnnotationBeanPostProcessor</a>处理DI。 在这方面，注释不能在任何BeanFactoryPP或BeanPP中使用。 </p><br><p> 如果注入的对象是具有泛型的数组，集合或映射，则Spring将在该数组（或其他数据结构）中嵌入所有类型的bean。 对于map，键将是Bean名称。 </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ,   DI @Authowired(required = true/false)</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">如何在私人领域制作DI？</b> <div class="spoiler_text"><p> 您可以使用不同类型的实现： </p><br><ul><li> 建设者 </li><li> 塞特犬 </li><li> 现场注入 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">价值</a> </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">如何使用@Qualifier补充@Autowired？</b> <div class="spoiler_text"><p>  Spring提供了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Qualifier</a>注释来克服DI模糊性问题。 </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@Qualifier</span></span>(<span class="hljs-string"><span class="hljs-string">"SomeClass1"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> SomeClass </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{...} <span class="hljs-comment"><span class="hljs-comment">//… @Autowire @Qualifier("SomeField1") public SomeClass someField;</span></span></code> </pre> <br><p> 如果容器具有几个相同类型的容器（SomeClass），则容器将完全实现该容器，在@Bean方法上方有一个合适的限定符。 您也不能在方法上放置限定符，但可以使用Bean名称作为限定符参数。 <br> 可以通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Bean</a>批注参数指定Bean名称，默认情况下，这是工厂方法的名称。 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Spring可以创建什么代理对象和什么类型的代理对象？</b> <div class="spoiler_text"><p> 代理是一个特殊的对象，它具有与bean相同的公共方法，但是具有附加的功能。 <br> 两种类型的代理： </p><br><ul><li>  JDK-proxy-动态代理。  API内置在JDK中。 需要一个接口 </li><li>  CGLib代理-未内置在JDK中。 当对象的接口不可用时使用。 </li></ul><br><p> 代理对象的优点： </p><br><ul><li> 允许添加额外的内容。 逻辑-事务管理，安全性，日志记录 </li><li> 将一些代码（记录等）与主逻辑分开 </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">单例bean如何实现？</b> <div class="spoiler_text"><p> 如果容器中没有bean实例，则调用@ Bean方法。 如果有一个bean实例，则返回已经创建的bean。 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">什么是个人资料？</b>  <b class="spoiler_title">他们使用的原因是什么？</b> <div class="spoiler_text"><p> 使用Java配置时，可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>@Profile</code></a>批注。 <br> 它允许您根据指定的配置文件对Spring使用不同的设置。 <br> 可以将其放在@Configuration和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Component</a>类以及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Bean</a>方法上。 </p><br><pre> <code class="java hljs">Profile(<span class="hljs-string"><span class="hljs-string">"!test"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   ,  </span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>(<span class="hljs-string"><span class="hljs-string">"dataSource"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Profile</span></span>(<span class="hljs-string"><span class="hljs-string">"production"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DataSource </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jndiDataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{...} <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>(<span class="hljs-string"><span class="hljs-string">"dataSource"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Profile</span></span>(<span class="hljs-string"><span class="hljs-string">"development"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DataSource </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">standaloneDataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{...}</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">如何在Spring的属性中嵌入简单值？</b> <div class="spoiler_text"><p> 您可以<code>@Value</code>使用<code>@Value</code>批注。 <br> 可以从属性文件，垃圾箱等中获取此类值。 </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"$some.key"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String stringWithDefaultValue;</code> </pre> <br><p> 字符串将嵌入到此变量中，例如，从属性或视图中。 </p></div></div><br><blockquote> 与往常一样，请发送在PM中发现的更正或错误。 </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN470305/">https://habr.com/ru/post/zh-CN470305/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN470293/index.html">Yandex.Stations中的漏洞如何启发我参与该项目：音乐数据传输</a></li>
<li><a href="../zh-CN470295/index.html">简单的SQlite DB加密</a></li>
<li><a href="../zh-CN470299/index.html">高效的SignalR连接管理</a></li>
<li><a href="../zh-CN470301/index.html">关键字树：用于语义提取的图分析</a></li>
<li><a href="../zh-CN470303/index.html">在CentOS 8或RedHat 8上安装tftp服务器</a></li>
<li><a href="../zh-CN470309/index.html">Xamarin.Forms外壳</a></li>
<li><a href="../zh-CN470311/index.html">木制玩具，第七部分-1993年</a></li>
<li><a href="../zh-CN470313/index.html">木制玩具，第八部分-1994年</a></li>
<li><a href="../zh-CN470317/index.html">C ++缩写备忘单等。 第2部分：“不仅如此”</a></li>
<li><a href="../zh-CN470321/index.html">木制玩具，第九部分-1995</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>