<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ² ğŸ£ ğŸ‘‘ Testando contratos inteligentes da Ethereum on Go: adeus, JavaScript ğŸ§–ğŸ¿ ğŸ‘©ğŸ¾â€ğŸ”¬ ğŸ‘©ğŸ¼â€ğŸ’»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quero agradecer aos meus colegas: Sergey Nemesh, Mikhail Popsuyev, Evgeny Babich e Igor Titarenko pelas consultas, feedback e testes. TambÃ©m quero agr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testando contratos inteligentes da Ethereum on Go: adeus, JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445254/"><p><img src="https://cdn-images-1.medium.com/max/1600/1*WNQyyGK2TrOy2m784kJang.jpeg" alt="imagem"><br>  <em>Quero agradecer aos meus colegas: Sergey Nemesh, Mikhail Popsuyev, Evgeny Babich e Igor Titarenko pelas consultas, feedback e testes.</em>  <em>TambÃ©m quero agradecer Ã  equipe do PolySwarm por desenvolver a versÃ£o original do Perigord.</em> <em><br></em> <br>  <em>Esta Ã© uma traduÃ§Ã£o do meu primeiro artigo publicado em inglÃªs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mÃ©dio</a></em> </p><br><p>  Os testes sempre fizeram parte integrante do desenvolvimento de software, embora nÃ£o sejam os mais agradÃ¡veis.  Quando se trata de contratos inteligentes, sÃ£o necessÃ¡rios testes rigorosos com uma atenÃ§Ã£o excepcional aos detalhes, como  os erros serÃ£o impossÃ­veis de corrigir apÃ³s a implantaÃ§Ã£o na rede blockchain.  Nos Ãºltimos anos, a comunidade Ethereum criou muitas ferramentas para o desenvolvimento de contratos inteligentes.  Alguns deles nÃ£o se tornaram populares, por exemplo, o Vyper - um dialeto em Python para escrever contratos inteligentes.  Outros, como Solidity, tornaram-se um padrÃ£o reconhecido.  A documentaÃ§Ã£o mais extensa sobre o teste de contratos inteligentes atÃ© o momento fornece um monte de Truffle &amp; Ganache.  Ambas as ferramentas possuem boa documentaÃ§Ã£o, muitos casos jÃ¡ foram decididos no Stack Overflow e recursos semelhantes.  No entanto, essa abordagem tem uma desvantagem importante: para escrever testes, vocÃª precisa usar o Node.js. </p><a name="habracut"></a><br><h4 id="lovushki-javascript">  Armadilhas de JavaScript </h4><br><p>  Mesmo que vocÃª nÃ£o seja fÃ£ de linguagens de programaÃ§Ã£o estÃ¡ticas e adora JavaScript, considere fazer um erro de digitaÃ§Ã£o e comeÃ§ar a comparar o resultado de uma funÃ§Ã£o que retorna uma string com um valor booleano usando o mÃ©todo equal obsoleto em vez de strictEqual. </p><br><pre><code class="plaintext hljs">let proposalExists = await voting.checkProposal(); assert.equal(proposalExists, true, 'Proposal should exist');</code> </pre> <br><p>  Se checkProposal retornar a string "yes" ou "no", vocÃª sempre as converterÃ¡ em true.  A digitaÃ§Ã£o dinÃ¢mica oculta muitas dessas armadilhas, e mesmo programadores experientes podem cometer esses erros ao trabalhar em um projeto grande ou em uma equipe com outros desenvolvedores que podem fazer alteraÃ§Ãµes no cÃ³digo e nÃ£o reportÃ¡-lo. </p><br><p>  A digitaÃ§Ã£o estÃ¡tica do Go ajuda a evitar esses erros.  AlÃ©m disso, o uso da linguagem Go em vez do Node.js para teste Ã© o sonho de qualquer desenvolvedor Go que comece a trabalhar com contratos inteligentes. </p><br><p>  Minha equipe estava desenvolvendo um sistema de investimento baseado em contratos inteligentes com uma arquitetura muito complexa.  O sistema de contrato inteligente continha mais de 2.000 linhas de cÃ³digo.  Como a maior parte da equipe era de desenvolvedores Go, os testes no Go eram preferÃ­veis aos Node.js. </p><br><h4 id="pervaya-sreda-dlya-testirovaniya-smart-kontraktov-na-go">  O primeiro ambiente para testar contratos inteligentes no Go </h4><br><p>  Em 2017, a PolySwarm desenvolveu o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Perigord</a> , uma ferramenta semelhante ao Truffle, usando Go em vez de JavaScript.  Infelizmente, este projeto nÃ£o Ã© mais suportado, ele possui apenas um tutorial com exemplos muito simples.  AlÃ©m disso, ele nÃ£o suporta a integraÃ§Ã£o com o Ganache (uma blockchain privada para o desenvolvimento do Ethereum com uma GUI muito conveniente).  Melhoramos o Perigord eliminando bugs e introduzindo duas novas funÃ§Ãµes: gerar carteiras a partir do cÃ³digo mnemÃ´nico e usÃ¡-las para testar e conectar-se Ã  blockchain Ganache.  VocÃª pode ler o cÃ³digo fonte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  O tutorial original do Perigord contÃ©m apenas o exemplo mais simples de chamar um contrato para alterar um Ãºnico valor.  No entanto, no mundo real, vocÃª tambÃ©m precisarÃ¡ chamar um contrato de diferentes carteiras, enviar e receber Ether, etc.  Agora vocÃª pode fazer tudo isso usando o Perigord avanÃ§ado e o bom e velho Ganache.  Abaixo, vocÃª encontrarÃ¡ orientaÃ§Ãµes detalhadas sobre o desenvolvimento e teste de contratos inteligentes usando a Perigord &amp; Ganache. </p><br><h4 id="ispolzovanie-uluchshennogo-perigord-polnoe-rukovodstvo">  Usando o Perigord avanÃ§ado: um guia completo </h4><br><p>  Para usar o Perigord, vocÃª precisa instalar o Go 1.7+, solc, abigen e Ganache.  Por favor, consulte a documentaÃ§Ã£o do seu sistema operacional. </p><br><p>  Instale o Perigord da seguinte maneira: </p><br><pre> <code class="plaintext hljs">$ go get gitlab.com/go-truffle/enhanced-perigord $ go build</code> </pre> <br><p>  Depois disso, vocÃª pode usar o comando perigord: </p><br><pre> <code class="plaintext hljs">$ perigord A golang development environment for Ethereum Usage: perigord [command] Available Commands: add Add a new contract or test to the project build (alias for compile) compile Compile contract source files deploy (alias for migrate) generate (alias for compile) help Help about any command init Initialize new Ethereum project with example contracts and tests migrate Run migrations to deploy contracts test Run go and solidity tests Flags: -h, --help help for perigord Use "perigord [command] --help" for more information about a command.</code> </pre> <br><p>  Agora, criaremos um contrato inteligente de mercado simples para demonstrar as opÃ§Ãµes de teste disponÃ­veis. </p><br><p>  Para iniciar um projeto, digite o seguinte no terminal: </p><br><pre> <code class="plaintext hljs">$ perigord init market</code> </pre> <br><p>  O projeto aparecerÃ¡ na pasta src / em GOPATH.  Mova o projeto para outra pasta e atualize os caminhos de importaÃ§Ã£o se desejar alterar sua localizaÃ§Ã£o.  Vamos ver o que estÃ¡ no mercado / pasta. </p><br><pre> <code class="plaintext hljs">$ tree . â”œâ”€â”€ contracts â”‚ â””â”€â”€ Foo.sol â”œâ”€â”€ generate.go â”œâ”€â”€ main.go â”œâ”€â”€ migrations â”‚ â””â”€â”€ 1_Migrations.go â”œâ”€â”€ perigord.yaml â”œâ”€â”€ stub â”‚ â”œâ”€â”€ README.md â”‚ â””â”€â”€ main.go â”œâ”€â”€ stub_test.go â””â”€â”€ tests â””â”€â”€ Foo.go</code> </pre> <br><p>  Muito parecido com o projeto criado no Truffle, nÃ£o Ã©?  Mas estÃ¡ tudo pronto!  Vamos ver o que estÃ¡ no arquivo de configuraÃ§Ã£o perigord.yaml. </p><br><pre> <code class="plaintext hljs">networks: dev: url: /tmp/geth_private_testnet/geth.ipc keystore: /tmp/geth_private_testnet/keystore passphrase: blah mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat num_accounts: 10</code> </pre> <br><p>  Para o teste, vocÃª pode usar os arquivos de rede e carteira geth privados e conectar-se ao Ganache.  Essas opÃ§Ãµes sÃ£o mutuamente exclusivas.  Tomamos as mnemÃ´nicas padrÃ£o, geramos 10 contas e nos conectamos ao Ganache.  Substitua o cÃ³digo em perigord.yaml por: </p><br><pre> <code class="plaintext hljs">networks: dev: url: HTTP://127.0.0.1:7545 mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat num_accounts: 10</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HTTP http://127.0.0.1:7545</a> - o endereÃ§o padrÃ£o do servidor Ganache RPC.  Observe que vocÃª pode criar qualquer nÃºmero de contas para teste, mas apenas as contas geradas na Ganache (GUI) conterÃ£o fundos. </p><br><p>  Criaremos um contrato chamado Market.sol.  Ele pode manter um registro de pares de endereÃ§os, um dos quais envia fundos para a conta do contrato e o outro tem o direito de receber fundos quando o proprietÃ¡rio do contrato autorizar essa transaÃ§Ã£o.  Por exemplo, dois participantes nÃ£o confiam um no outro, mas confiam no proprietÃ¡rio do contrato, que decide se uma determinada condiÃ§Ã£o Ã© atendida.  O exemplo implementa vÃ¡rias funÃ§Ãµes bÃ¡sicas para fins de demonstraÃ§Ã£o. </p><br><p>  Adicione um contato ao projeto: </p><br><pre> <code class="plaintext hljs">$ perigord add contract Market</code> </pre> <br><p>  O postfix .sol serÃ¡ adicionado automaticamente.  VocÃª tambÃ©m pode adicionar outros contratos ou excluir o contrato de amostra Foo.sol.  Enquanto vocÃª trabalha na GOPATH, pode usar contratos de importaÃ§Ã£o para criar estruturas complexas.  Teremos trÃªs arquivos do Solidity: o contrato principal do Market, os contratos auxiliares Ownable e Migrations e a biblioteca SafeMath.  VocÃª pode encontrar o cÃ³digo fonte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  Agora o projeto tem a seguinte estrutura: </p><br><pre> <code class="plaintext hljs">. â”œâ”€â”€ contracts â”‚ â”œâ”€â”€ Market.sol â”‚ â”œâ”€â”€ Ownable.sol â”‚ â””â”€â”€ SafeMath.sol â”œâ”€â”€ generate.go â”œâ”€â”€ main.go â”œâ”€â”€ migrations â”‚ â””â”€â”€ 1_Migrations.go â”œâ”€â”€ perigord.yaml â”œâ”€â”€ stub â”‚ â”œâ”€â”€ README.md â”‚ â””â”€â”€ main.go â”œâ”€â”€ stub_test.go â””â”€â”€ tests â””â”€â”€ Foo.go</code> </pre> <br><p>  Gere ligaÃ§Ãµes de bytecode, ABI e Go do EVM: </p><br><pre> <code class="plaintext hljs">$ perigord build</code> </pre> <br><p>  Adicione as migraÃ§Ãµes de todos os contratos que vocÃª implantarÃ¡.  Porque  implantamos apenas o Market.sol, precisamos de apenas uma nova migraÃ§Ã£o: </p><br><pre> <code class="plaintext hljs">$ perigord add migration Market</code> </pre> <br><p>  Nosso contrato nÃ£o contÃ©m um construtor que aceite parÃ¢metros.  Se vocÃª precisar passar parÃ¢metros para o construtor, adicione-os Ã  funÃ§Ã£o Deploy {NewContract} no arquivo de migraÃ§Ã£o: </p><br><pre> <code class="plaintext hljs">address, transaction, contract, err := bindings.Deploy{NewContract}(auth, network.Client(), â€œFOOâ€, â€œBARâ€)</code> </pre> <br><p>  Exclua o arquivo de exemplo Foo.go e adicione um arquivo de teste para o nosso contrato: </p><br><pre> <code class="plaintext hljs">$ perigord add test Market</code> </pre> <br><p>  Para usar carteiras determinÃ­sticas, precisamos ler os mnemÃ´nicos do arquivo de configuraÃ§Ã£o: </p><br><pre> <code class="plaintext hljs">func getMnemonic() string { viper.SetConfigFile("perigord.yaml") if err := viper.ReadInConfig(); err != nil { log.Fatal() } mnemonic := viper.GetStringMapString("networks.dev")["mnemonic"] return mnemonic }</code> </pre> <br><p>  A seguinte funÃ§Ã£o auxiliar Ã© usada para obter o endereÃ§o de rede: </p><br><pre> <code class="plaintext hljs">func getNetworkAddress() string { viper.SetConfigFile("perigord.yaml") if err := viper.ReadInConfig(); err != nil { log.Fatal() } networkAddr := viper.GetStringMapString("networks.dev")["url"] return networkAddr }</code> </pre> <br><p>  Outra funÃ§Ã£o auxiliar que precisaremos Ã© sendETH, a usaremos para transferir o Ether de uma das carteiras geradas (indicadas pelo Ã­ndice) para qualquer endereÃ§o Ethereum: </p><br><pre> <code class="plaintext hljs">func sendETH(s *MarketSuite, c *ethclient.Client, sender int, receiver common.Address, value *big.Int) { senderAcc := s.network.Accounts()[sender].Address nonce, err := c.PendingNonceAt(context.Background(), senderAcc) if err != nil { log.Fatal(err) } gasLimit := uint64(6721975) // in units gasPrice := big.NewInt(3700000000) wallet, err := hdwallet.NewFromMnemonic(getMnemonic()) toAddress := receiver var data []byte tx := types.NewTransaction(nonce, toAddress, value, gasLimit, gasPrice, data) chainID, err := c.NetworkID(context.Background()) if err != nil { log.Fatal(err) } privateKey, err := wallet.PrivateKey(s.network.Accounts()[sender]) signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey) if err != nil { log.Fatal(err) } ts := types.Transactions{signedTx} rawTx := hex.EncodeToString(ts.GetRlp(0)) var trx *types.Transaction rawTxBytes, err := hex.DecodeString(rawTx) err = rlp.DecodeBytes(rawTxBytes, &amp;trx) err = c.SendTransaction(context.Background(), trx) if err != nil { log.Fatal(err) } }</code> </pre> <br><p>  As duas funÃ§Ãµes a seguir sÃ£o usadas para modificar uma chamada de contrato: </p><br><pre> <code class="plaintext hljs">func ensureAuth(auth bind.TransactOpts) *bind.TransactOpts { return &amp;bind.TransactOpts{ auth.From, auth.Nonce, auth.Signer, auth.Value, auth.GasPrice, auth.GasLimit, auth.Context} } func changeAuth(s MarketSuite, account int) bind.TransactOpts { return *s.network.NewTransactor(s.network.Accounts()[account]) }</code> </pre> <br><h4 id="procedura-testirovaniya">  Procedimento de teste </h4><br><p>  Para uma chamada, criamos um contractSessionActual para um contrato especÃ­fico.  Porque  Se o contrato tiver um proprietÃ¡rio, podemos obter seu endereÃ§o e verificar se ele corresponde Ã  conta Ganache zero padrÃ£o.  Faremos isso da seguinte maneira (omitiremos o tratamento de erros para economizar espaÃ§o): </p><br><pre> <code class="plaintext hljs">contractSession := contract.Session("Market") c.Assert(contractSession, NotNil) contractSessionActual, ok := contractSession.(*bindings.MarketSession) c.Assert(ok, Equals, true) c.Assert(contractSessionActual, NotNil) owner, _ := contractSessionActual.Owner() account0 := s.network.Accounts()[0] c.Assert(owner.Hex(), Equals, account0.Address.Hex()) //Owner account is account 0</code> </pre> <br><p>  O prÃ³ximo recurso Ãºtil Ã© alterar a carteira que causa o contrato: </p><br><pre> <code class="plaintext hljs">ownerInd := 0 sender := 5 receiver := 6 senderAcc := s.network.Accounts()[sender].Address receiverAcc := s.network.Accounts()[receiver].Address //Call contract on behalf of its owner auth := changeAuth(*s, ownerInd) _, err = contractSessionActual.Contract.SetSenderReceiverPair(ensureAuth(auth), senderAcc, receiverAcc)</code> </pre> <br><p>  Porque  uma das principais funÃ§Ãµes usadas no teste Ã© alterar o contrato de chamada, vamos fazer um pagamento em nome do remetente: </p><br><pre> <code class="plaintext hljs">auth = changeAuth(*s, sender) //Change auth fo senderAcc to make a deposit on behalf of the sender client, _ := ethclient.Dial(getNetworkAddress()) //Let's check the current balance balance, _ := client.BalanceAt(context.Background(), contract.AddressOf("Market"), nil) c.Assert(balance.Int64(), Equals, big.NewInt(0).Int64()) //Balance should be 0 //Let's transfer 3 ETH to the contract on behalf of the sender value := big.NewInt(3000000000000000000) // in wei (3 eth) contractReceiver := contract.AddressOf("Market") sendETH(s, client, sender, contractReceiver, value) balance2, _ := client.BalanceAt(context.Background(), contract.AddressOf("Market"), nil) c.Assert(balance2.Int64(), Equals, value.Int64()) //Balance should be 3 ETH</code> </pre> <br><p>  O cÃ³digo de teste completo estÃ¡ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  Agora abra stub_test.go e verifique se todas as importaÃ§Ãµes apontam para o seu projeto atual.  No nosso caso, Ã©: </p><br><pre> <code class="plaintext hljs">import ( _ "market/migrations" _ "market/tests" "testing" . "gopkg.in/check.v1" )</code> </pre> <br><p>  Execute os testes: </p><br><pre> <code class="plaintext hljs">$ perigord test</code> </pre> <br><p>  Se tudo for feito corretamente, depois do final do teste, haverÃ¡ um resultado semelhante: </p><br><pre> <code class="plaintext hljs">Running migration 2 Running migration 3 OK: 1 passed PASS ok market 0.657s</code> </pre> <br><p>  Se vocÃª tiver algum problema, baixe os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">arquivos de</a> origem e repita as etapas descritas neste guia. </p><br><h4 id="v-zaklyuchenie">  Em conclusÃ£o </h4><br><p>  O Perigord Ã© uma ferramenta de teste confiÃ¡vel, escrita no seu idioma favorito.  Ele cria a mesma estrutura de projeto que o Truffle e tem as mesmas equipes, portanto vocÃª nÃ£o precisa reaprender.  A digitaÃ§Ã£o estÃ¡tica e uma assinatura de funÃ§Ã£o inequÃ­voca permitem que vocÃª desenvolva e execute a depuraÃ§Ã£o rapidamente, alÃ©m de proteger significativamente contra erros de digitaÃ§Ã£o nos argumentos.  No Perigord, vocÃª pode migrar facilmente um projeto existente para o Truffle (tudo o que vocÃª precisa fazer Ã© copiar e colar os arquivos do contrato na pasta apropriada e adicionar testes), alÃ©m de iniciar um projeto completamente novo com os testes escritos em Go. </p><br><p>  Espero que o trabalho iniciado pela equipe PolySwarm e continuado pela Inn4Science seja Ãºtil para a comunidade Go e livre de horas de teste e depuraÃ§Ã£o com ferramentas menos convenientes. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt445254/">https://habr.com/ru/post/pt445254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt445242/index.html">ExperiÃªncia com Coroutines e Retrofit2</a></li>
<li><a href="../pt445244/index.html">"Jogos de dinheiro fora do blockchain devem morrer"</a></li>
<li><a href="../pt445246/index.html">Jogos sem Blockchain envolvendo dinheiro devem morrer</a></li>
<li><a href="../pt445248/index.html">Quer ser um pouco mais feliz? Tente ser o melhor em seu campo</a></li>
<li><a href="../pt445252/index.html">Direitos digitais chegaram Ã  RÃºssia</a></li>
<li><a href="../pt445256/index.html">Cibercriminosos controlaram o ASUS Live Update por cinco meses</a></li>
<li><a href="../pt445258/index.html">Como excluir com seguranÃ§a seus dados do seu smartphone Android antes de vendÃª-los</a></li>
<li><a href="../pt445260/index.html">Os robÃ´s se reconhecerÃ£o verdadeiramente? Os cientistas estÃ£o caminhando nessa direÃ§Ã£o.</a></li>
<li><a href="../pt445262/index.html">GeekUniversity Abre Recrutamento no Departamento de Big Data Analytics</a></li>
<li><a href="../pt445264/index.html">PrÃ©-carregamento, prÃ©-busca e outras tags</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>