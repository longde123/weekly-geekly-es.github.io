<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß§ ü§µüèø üë®üèΩ‚Äçüéì Trik puluhan dengan shell Linux yang bisa menghemat waktu Anda üîô üò∏ üÜì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Pertama-tama, Anda dapat membaca artikel ini dalam bahasa Rusia di sini . 
 Suatu malam, saya sedang membaca Menguasai ekspresi reguler oleh Jeffrey...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trik puluhan dengan shell Linux yang bisa menghemat waktu Anda</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444890/"><div style="text-align:center;"><img width="90%" src="https://habrastorage.org/webt/fs/43/05/fs4305wjukd5umg71ochqeqxxek.png"></div><br><br><ul><li>  <i>Pertama-tama, Anda dapat membaca artikel ini dalam bahasa Rusia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .</i> </li></ul><br>  Suatu malam, saya sedang membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menguasai ekspresi reguler oleh Jeffrey Friedl</a> , saya menyadari bahwa bahkan jika Anda memiliki semua dokumentasi dan banyak pengalaman, mungkin ada banyak trik yang dikembangkan oleh orang yang berbeda dan dipenjara untuk diri mereka sendiri.  Semua orang berbeda.  Dan teknik yang jelas bagi orang-orang tertentu mungkin tidak jelas bagi orang lain dan terlihat seperti semacam sihir aneh bagi orang ketiga.  Ngomong-ngomong, saya sudah menggambarkan beberapa momen seperti itu di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini (dalam bahasa Rusia)</a> . <br><br>  Untuk administrator atau pengguna, baris perintah tidak hanya alat yang dapat melakukan segalanya, tetapi juga alat yang sangat khusus yang dapat dikembangkan selamanya.  Baru-baru ini ada artikel yang diterjemahkan tentang beberapa trik yang berguna di CLI.  Tetapi saya merasa bahwa penerjemah tidak memiliki pengalaman yang cukup dengan CLI dan tidak mengikuti trik yang dijelaskan, begitu banyak hal penting yang bisa terlewatkan atau disalahpahami. <br><br>  Di bawah cut - selusin trik di Linux shell dari pengalaman pribadi saya. <br><a name="habracut"></a><br>  Catatan: Semua skrip dan contoh dalam artikel itu secara khusus disederhanakan sebanyak mungkin - jadi mungkin Anda dapat menemukan beberapa trik yang terlihat sama sekali tidak berguna - mungkin inilah alasannya.  Tetapi bagaimanapun juga, bagikan pendapat Anda dalam komentar! <br><br><h4>  1. Pisahkan string dengan ekspansi variabel </h4><br>  Orang sering menggunakan <b>cut</b> atau <b>awk</b> hanya untuk mengurangi bagian dari string dengan pola atau dengan pemisah. <br>  Juga, banyak orang menggunakan operasi bash substring menggunakan $ {VARIABLE: start_position: length}, yang bekerja sangat cepat. <br><br>  Tapi bash menyediakan cara ampuh untuk memanipulasi dengan string teks menggunakan #, ##,% dan %% - itu disebut <i>ekspansi variabel bash</i> . <br>  Dengan menggunakan sintaks ini, Anda dapat memotong yang diperlukan oleh pola tanpa menjalankan perintah eksternal, sehingga akan bekerja sangat cepat. <br><br>  Contoh di bawah ini menunjukkan cara mendapatkan kolom ketiga (shell) dari string di mana nilai dipisahkan oleh titik dua "username: homedir: shell" menggunakan <b>cut</b> atau menggunakan ekspansi variabel (kami menggunakan perintah <u>*:</u> mask dan perintah ##, yang berarti: cut semua karakter ke kiri hingga titik dua terakhir ditemukan): <br><br><pre><code class="bash hljs">$ STRING=<span class="hljs-string"><span class="hljs-string">"username:homedir:shell"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STRING</span></span></span><span class="hljs-string">"</span></span>|cut -d <span class="hljs-string"><span class="hljs-string">":"</span></span> -f 3 shell $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${STRING##*:}</span></span></span><span class="hljs-string">"</span></span> shell</code> </pre> <br>  Opsi kedua tidak memulai proses anak ( <b>potong</b> ), dan tidak menggunakan pipa sama sekali, yang seharusnya bekerja lebih cepat.  Dan jika Anda menggunakan subsistem bash di windows, di mana pipa hampir tidak bergerak, perbedaan kecepatan akan menjadi <u>signifikan</u> . <br><br>  Mari kita lihat contoh di Ubuntu - jalankan perintah kami dalam satu lingkaran sebanyak 1000 kali <br><br><pre> <code class="bash hljs">$ cat test.sh <span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash STRING="Name:Date:Shell" echo "using cut" time for A in {1..1000} do cut -d ":" -f 3 &gt; /dev/null &lt;&lt;&lt;"$STRING" done echo "using ##" time for A in {1..1000} do echo "${STRING##*:}" &gt; /dev/null done</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Hasil</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ./test.sh using cut real 0m0.950s user 0m0.012s sys 0m0.232s using <span class="hljs-comment"><span class="hljs-comment">## real 0m0.011s user 0m0.008s sys 0m0.004s</span></span></code> </pre></div></div><br>  Perbedaannya adalah beberapa lusin kali! <br><br>  Tentu saja, contoh di atas terlalu buatan.  Dalam contoh nyata kita tidak akan bekerja dengan string statis, kita ingin membaca file nyata.  Dan untuk perintah ' <b>cut</b> ', kita hanya mengarahkan / etc / passwd ke sana.  Dalam kasus ##, kita harus membuat loop dan membaca file menggunakan perintah ' <b>baca</b> ' internal.  Jadi siapa yang akan memenangkan kasus ini? <br><br><pre> <code class="bash hljs">$ cat test.sh <span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash echo "using cut" time for count in {1..1000} do cut -d ":" -f 7 &lt;/etc/passwd &gt; /dev/null done echo "using ##" time for count in {1..1000} do while read do echo "${REPLY##*:}" &gt; /dev/null done &lt;/etc/passwd done</span></span></code> </pre><div class="spoiler">  <b class="spoiler_title">Hasil</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ./test.sh $ ./test.sh using cut real 0m0.827s user 0m0.004s sys 0m0.208s using <span class="hljs-comment"><span class="hljs-comment">## real 0m0.613s user 0m0.436s sys 0m0.172s</span></span></code> </pre>  Tidak ada komentar =) </div></div><br>  Beberapa contoh lagi: <br><br>  Ekstrak nilai setelah karakter yang sama: <br><br><pre> <code class="bash hljs">$ VAR=<span class="hljs-string"><span class="hljs-string">"myClassName = helloClass"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">${VAR##*= }</span></span> helloClass</code> </pre><br>  Ekstrak teks dalam tanda kurung: <br><br><pre> <code class="bash hljs">$ VAR=<span class="hljs-string"><span class="hljs-string">"Hello my friend (enemy)"</span></span> $ TEMP=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${VAR##*\(}</span></span></span><span class="hljs-string">"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${TEMP%\)}</span></span></span><span class="hljs-string">"</span></span> enemy</code> </pre><br><h4>  2. Bash pelengkapan otomatis dengan tab </h4><br>  paket bash-completion adalah bagian dari hampir setiap distribusi Linux.  Anda dapat mengaktifkannya di /etc/bash.bashrc atau /etc/profile.d/bash_completion.sh, tetapi biasanya sudah diaktifkan secara default.  Secara umum, autocomplete adalah salah satu momen nyaman pertama di shell Linux yang pertama kali ditemui oleh pendatang baru. <br><br>  Tetapi fakta bahwa tidak semua orang menggunakan semua fitur bash-completion, dan menurut saya sama sekali sia-sia.  Misalnya tidak semua orang tahu, bahwa pelengkapan otomatis berfungsi tidak hanya dengan nama file, tetapi juga dengan alias, nama variabel, nama fungsi, dan untuk beberapa perintah bahkan dengan argumen.  Jika Anda menggali skrip pelengkapan otomatis, yang sebenarnya merupakan skrip shell, Anda bahkan dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menambahkan pelengkapan otomatis</a> untuk aplikasi atau skrip Anda sendiri. <br>  Tapi mari kita kembali ke alias. <br><br>  Anda tidak perlu mengedit variabel PATH atau membuat file di direktori yang ditentukan untuk menjalankan alias.  Anda hanya perlu menambahkannya ke skrip profil atau startup dan menjalankannya dari mana saja. <br><br>  Biasanya kami menggunakan huruf kecil untuk file dan direktori di * nix, jadi bisa sangat nyaman untuk membuat alias huruf besar - dalam hal ini bash-completion akan <s>menebak</s> perintah Anda hampir dengan satu huruf: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> TAsteriskLog=<span class="hljs-string"><span class="hljs-string">"tail -f /var/log/asteriks.log"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> TMailLog=<span class="hljs-string"><span class="hljs-string">"tail -f /var/log/mail.log"</span></span> $ TA[tab]steriksLog $ TM[tab]ailLog</code> </pre> <br><h4>  3. Bash pelengkapan otomatis dengan tab - bagian 2 </h4><br>  Untuk kasus yang lebih rumit, mungkin Anda ingin meletakkan skrip pribadi Anda ke $ HOME / bin. <br>  Tapi kami memiliki fungsi di bash. <br><br>  Fungsi tidak memerlukan path atau file yang terpisah.  Dan (perhatian) bash-completion bekerja dengan fungsi juga. <br><br>  Mari kita buat fungsi LastLogin di <b>.profile</b> (jangan lupa memuat ulang .profile): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> LastLogin { STRING=$(last | head -n 1 | tr -s <span class="hljs-string"><span class="hljs-string">" "</span></span> <span class="hljs-string"><span class="hljs-string">" "</span></span>) USER=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STRING</span></span></span><span class="hljs-string">"</span></span>|cut -d <span class="hljs-string"><span class="hljs-string">" "</span></span> -f 1) IP=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STRING</span></span></span><span class="hljs-string">"</span></span>|cut -d <span class="hljs-string"><span class="hljs-string">" "</span></span> -f 3) SHELL=$( grep <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$USER</span></span></span><span class="hljs-string">"</span></span> /etc/passwd | cut -d <span class="hljs-string"><span class="hljs-string">":"</span></span> -f 7) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"User: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$USER</span></span></span><span class="hljs-string">, IP: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$IP</span></span></span><span class="hljs-string">, SHELL=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SHELL</span></span></span><span class="hljs-string">"</span></span> }</code> </pre> <br>  <i>(Sebenarnya tidak ada yang penting apa fungsi ini lakukan, itu hanya contoh skrip yang dapat kita tempatkan ke skrip terpisah atau bahkan ke alias, tetapi fungsi bisa lebih baik)</i> . <br><br>  Di konsol (harap dicatat bahwa nama fungsi memiliki huruf besar pertama untuk mempercepat penyelesaian-bash): <br><br><pre> <code class="bash hljs">$ L[tab]astLogin User: saboteur, IP: 10.0.2.2, SHELL=/bin/bash</code> </pre> <br><h4>  4.1.  Data sensitif </h4><br>  Jika Anda meletakkan spasi di depan perintah apa pun di konsol, itu tidak akan muncul di riwayat perintah, jadi jika Anda perlu memasukkan kata sandi teks pada perintah, itu adalah cara yang baik untuk menggunakan fitur ini - lihat contoh di bawah ini, <i>echo "halo 2 "</i> tidak akan muncul dalam riwayat: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span> hello $ <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> 2 2011 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span> 2012 <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> 2 $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"my password secretmegakey"</span></span> <span class="hljs-comment"><span class="hljs-comment"># there are two spaces before 'echo' my password secretmegakey $ history 2 2011 echo "hello" 2012 history 2</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Itu opsional</b> <div class="spoiler_text">  Biasanya diaktifkan secara default, tetapi Anda dapat mengonfigurasi perilaku ini dalam variabel berikut: <br><br>  export HISTCONTROL = ignoreboth </div></div><br><br><h4>  4.2.  Data sensitif dalam argumen baris perintah </h4><br>  Anda ingin menyimpan beberapa skrip shell di git untuk membagikannya di server, atau mungkin itu adalah bagian dari skrip startup aplikasi.  Dan Anda ingin skrip ini akan terhubung ke database atau melakukan hal lain yang memerlukan kredensial. <br><br>  Tentu saja itu ide buruk untuk menyimpan kredensial dalam skrip itu sendiri, karena git tidak aman. <br><br>  Biasanya Anda dapat menggunakan variabel, yang sudah ditentukan pada lingkungan target, dan skrip Anda tidak akan berisi kata sandi itu sendiri. <br><br>  Misalnya, Anda dapat membuat skrip kecil di setiap lingkungan dengan 700 izin dan menyebutnya dengan menggunakan perintah <b>sumber</b> dari skrip utama: <br><br><pre> <code class="bash hljs">secret.sh PASSWORD=LOVESEXGOD</code> </pre><br><pre> <code class="bash hljs">myapp.sh <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> ~/secret.sh sqlplus -l user/<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$PASSWORD</span></span></span><span class="hljs-string">"</span></span>@database:port/sid @mysqfile.sql</code> </pre> <br>  Tapi itu tidak aman. <br><br>  Jika orang lain dapat masuk ke host Anda, ia bisa menjalankan perintah <b>ps</b> dan melihat proses sqlplus Anda dengan seluruh argumen baris perintah termasuk kata sandi.  Jadi, alat yang aman biasanya harus dapat membaca kata sandi / kunci / data sensitif langsung dari file. <br><br>  Misalnya - <b>ssh</b> aman bahkan tidak memiliki opsi untuk memberikan kata sandi di baris perintah.  Tapi dia bisa membaca kunci ssh dari file (dan Anda dapat mengatur izin aman pada file kunci ssh). <br><br>  Dan wget yang tidak aman memiliki opsi "--password" yang memungkinkan Anda memberikan kata sandi di baris perintah.  Dan sepanjang waktu wget akan berjalan, semua orang dapat menjalankan perintah ps dan melihat kata sandi yang Anda berikan. <br><br>  Selain itu, jika Anda memiliki banyak data sensitif, dan Anda ingin mengontrolnya dari git, satu-satunya cara adalah enkripsi.  Jadi, Anda menempatkan ke setiap lingkungan target hanya kata sandi utama, dan semua data lain yang dapat Anda enkripsi dan masukkan ke git.  Dan Anda dapat bekerja dengan data terenkripsi dari baris perintah, menggunakan antarmuka CLI openssl.  Ini adalah contoh untuk mengenkripsi dan mendekripsi dari baris perintah: <br><br>  File secret.key berisi kunci utama - satu baris: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"secretpassword"</span></span> &gt; secret.key; chmod 600 secret.key</code> </pre> <br>  Mari kita gunakan aes-256-cbc untuk mengenkripsi string: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"string_to_encrypt"</span></span> | openssl enc -pass file:secret.key -e -aes-256-cbc -a U2FsdGVkX194R0GmFKCL/krYCugS655yLhf8aQyKNcUnBs30AE5lHN5MXPjjSFML</code> </pre> <br>  Anda dapat meletakkan string terenkripsi ini ke file konfigurasi apa pun yang disimpan di git, atau tempat lain - tanpa secret.key hampir tidak mungkin untuk mendekripsi. <br>  Untuk mendekripsi jalankan perintah yang sama cukup ganti -e dengan -d: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'U2FsdGVkX194R0GmFKCL/krYCugS655yLhf8aQyKNcUnBs30AE5lHN5MXPjjSFML'</span></span> | openssl enc -pass file:secret.key -d -aes-256-cbc -a string_to_encrypt</code> </pre> <br><h4>  5. Perintah grep </h4><br>  Semua harus tahu perintah grep.  Dan bersikap ramah dengan ekspresi reguler.  Dan seringkali Anda dapat menulis sesuatu seperti: <br><br><pre> <code class="bash hljs">tail -f application.log | grep -i error</code> </pre> <br>  Atau bahkan seperti ini: <br><br><pre> <code class="bash hljs">tail -f application.log | grep -i -P <span class="hljs-string"><span class="hljs-string">"(error|warning|failure)"</span></span></code> </pre> <br>  Tetapi jangan lupa bahwa grep memiliki banyak pilihan yang bagus.  Misalnya -v, yang mengembalikan pencarian Anda dan menampilkan semua pesan kecuali "info": <br><br><pre> <code class="bash hljs">tail -f application.log | grep -v -i <span class="hljs-string"><span class="hljs-string">"info"</span></span></code> </pre> <br>  Barang tambahan: <br><br>  Opsi -P sangat berguna, karena secara default grep menggunakan "ekspresi reguler dasar:", dan -P memungkinkan PCRE yang bahkan tidak tahu tentang pengelompokan. <br>  -Saya mengabaikan kasus. <br>  - line parses buffer-line segera daripada menunggu untuk mencapai standar buffer 4k (berguna untuk tail -f | grep). <br><br>  Jika Anda tahu ekspresi reguler dengan baik, dengan --only-matching / -o Anda benar-benar dapat melakukan hal-hal hebat dengan memotong teks.  Bandingkan saja dua perintah berikutnya untuk mengekstrak shell myuser: <br><br><pre> <code class="bash hljs">$ grep myuser /etc/passwd| cut -d <span class="hljs-string"><span class="hljs-string">":"</span></span> -f 7 $ grep -Po <span class="hljs-string"><span class="hljs-string">"^myuser(:.*){5}:\K.*"</span></span> /etc/passwd</code> </pre> <br>  Perintah kedua terlihat lebih terkompilasi, tetapi hanya menjalankan <b>grep</b> daripada <b>grep</b> dan <b>cut</b> , sehingga akan memakan waktu lebih sedikit untuk eksekusi. <br><br><h4>  6. Cara mengurangi ukuran file log </h4><br>  Di * nix, jika Anda menghapus file log, yang saat ini digunakan oleh aplikasi, Anda tidak bisa menghapus semua log, Anda dapat mencegah aplikasi untuk menulis log baru sampai restart. <br><br>  Karena deskriptor file tidak membuka nama file, tetapi struktur iNode, dan aplikasi akan terus menulis ke deskriptor file ke file, yang tidak memiliki entri direktori, dan file tersebut akan dihapus secara otomatis setelah aplikasi dihentikan oleh sistem file ( <i>aplikasi Anda dapat buka dan tutup file log setiap kali ingin menulis sesuatu untuk menghindari masalah seperti itu, tetapi ini memengaruhi kinerja</i> ). <br><br>  Jadi, cara menghapus file log tanpa menghapusnya: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> &gt; application.log</code> </pre> <br>  Atau kita bisa menggunakan perintah truncate: <br><br><pre> <code class="bash hljs">truncate --size=1M application.log</code> </pre> <br>  Sebutkan, perintah <b>terpotong itu</b> akan menghapus sisa file, sehingga Anda akan kehilangan peristiwa log terbaru.  Lihat contoh lain cara menyimpan 1000 baris terakhir: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(tail -n 1000 application.log)</span></span></span><span class="hljs-string">"</span></span> &gt; application.log</code> </pre> <br>  <i>PS Di Linux kami memiliki rotatelog layanan standar.</i>  <i>Anda dapat menambahkan log ke truncate / rotate otomatis atau menggunakan pustaka log yang ada yang dapat melakukannya untuk Anda (seperti log4j di java).</i> <br><br><h4>  7. <b>Watch</b> memperhatikan Anda! </h4><br>  Ada situasi ketika Anda sedang menunggu beberapa acara selesai.  Misalnya, ketika pengguna lain masuk ke shell (Anda terus-menerus mengeksekusi perintah <b>siapa</b> ), atau seseorang harus menyalin file ke mesin Anda menggunakan scp atau ftp dan Anda sedang menunggu penyelesaiannya (berulang puluhan kali). <br><br>  Dalam kasus seperti itu, Anda dapat menggunakan <br><br><pre> <code class="bash hljs">watch &lt;<span class="hljs-built_in"><span class="hljs-built_in">command</span></span>&gt;</code> </pre> <br>  Secara default, akan dieksekusi setiap 2 detik dengan pra-hapus layar sampai Ctrl + C ditekan.  Anda dapat mengkonfigurasi seberapa sering harus dieksekusi. <br><br>  Ini sangat berguna ketika Anda ingin menonton log langsung. <br><br><h4>  8. Urutan bash </h4><br>  Ada konstruk yang sangat berguna untuk membuat rentang.  Sebagai contoh, bukannya sesuatu seperti ini: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> srv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 1 2 3 4 5; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"server</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${srv}</span></span></span><span class="hljs-string">"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">done</span></span> server1 server2 server3 server4 server5</code> </pre> <br>  Anda dapat menulis yang berikut ini: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> srv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> server{1..5}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$srv</span></span></span><span class="hljs-string">"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">done</span></span> server1 server2 server3 server4 server5</code> </pre> <br>  Anda juga dapat menggunakan perintah <b>seq</b> untuk menghasilkan rentang yang diformat.  Sebagai contoh, kita dapat menggunakan <b>seq</b> untuk membuat nilai whitch akan secara otomatis disesuaikan dengan lebar (00, 01 bukannya 0, 1): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> srv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $(seq -w 5 10); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"server</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${srv}</span></span></span><span class="hljs-string">"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">done</span></span> server05 server06 server07 server08 server09 server10</code> </pre> <br>  Contoh lain dengan substitusi perintah - ganti nama file.  Untuk mendapatkan nama file tanpa ekstensi, kami menggunakan perintah ' <b>basename</b> ': <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> *.txt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> name=$(basename <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$file</span></span></span><span class="hljs-string">"</span></span> .txt);mv <span class="hljs-variable"><span class="hljs-variable">$name</span></span>{.txt,.lst}; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Juga lebih singkat dengan '%': <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> *.txt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> mv <span class="hljs-variable"><span class="hljs-variable">${file%.txt}</span></span>{.txt,.lst}; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  PS Sebenarnya untuk mengganti nama file Anda dapat mencoba alat ' <b>rename</b> ' yang memiliki banyak pilihan. <br><br>  Contoh lain - mari buat struktur untuk proyek java baru: <br><br><pre> <code class="bash hljs">mkdir -p project/src/{main,<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>}/{java,resources}</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Hasil</b> <div class="spoiler_text"><pre> <code class="python hljs">project/ !--- src/ |--- main/ | |-- java/ | !-- resources/ !--- test/ |-- java/ !-- resources/</code> </pre> </div></div><br><h4>  9. ekor, banyak file, banyak pengguna ... </h4><br>  Saya telah menyebutkan <b>multitail</b> untuk membaca file dan menonton beberapa log langsung.  Tapi itu tidak disediakan secara default, dan izin untuk menginstal sesuatu tidak selalu tersedia. <br><br>  Tetapi ekor standar dapat melakukannya juga: <br><br><pre> <code class="bash hljs">tail -f /var/logs/*.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span></code> </pre> <br>  Ingat juga tentang pengguna, yang menggunakan alias 'tail -f' untuk menonton log aplikasi. <br>  Beberapa pengguna dapat menonton file log secara bersamaan menggunakan 'tail -f'.  Beberapa dari mereka tidak terlalu akurat dengan sesi mereka.  Mereka bisa meninggalkan 'tail -f' di latar belakang untuk beberapa alasan dan melupakannya. <br><br>  Jika aplikasi di-restart, ada proses 'tail -f' yang sedang berjalan yang menonton file log yang tidak ada dapat digantung selama beberapa hari atau bahkan berbulan-bulan. <br><br>  Biasanya itu bukan masalah besar, tapi tidak rapi. <br><br>  Jika Anda menggunakan alias untuk menonton log, Anda dapat memodifikasi alias ini dengan opsi --pid: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> TFapplog=<span class="hljs-string"><span class="hljs-string">'tail -f --pid=$(cat /opt/app/tmp/app.pid) /opt/app/logs/app.log'</span></span></code> </pre> <br>  Dalam hal itu, semua <b>ekor</b> akan secara otomatis dihentikan ketika aplikasi target akan dimulai ulang. <br><br><h4>  10. Buat file dengan ukuran yang ditentukan </h4><br>  <b>dd</b> adalah salah satu alat paling populer untuk bekerja dengan data blok dan biner.  Misalnya buat file 1 MB diisi dengan nol akan: <br><br><pre> <code class="bash hljs">dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/zero of=out.txt bs=1M count=10</code> </pre> <br>  Tapi saya sarankan menggunakan <b>fallocate</b> : <br><br><pre> <code class="bash hljs">fallocate -l 10M file.txt</code> </pre> <br>  Pada sistem file, yang mendukung fungsi alokasi (xfs, ext4, Btrfs ...), <b>fallocate</b> akan dieksekusi secara instan, tidak seperti alat dd.  Selain itu, mengalokasikan berarti alokasi blok nyata, bukan membuat file cadangan. <br><br><h4>  11. xargs </h4><br>  Banyak orang tahu perintah <b>xargs</b> populer.  Tetapi tidak semua dari mereka menggunakan dua opsi berikut, yang dapat sangat meningkatkan skrip Anda. <br><br>  Pertama - Anda bisa mendapatkan daftar argumen yang sangat panjang untuk diproses, dan bisa melebihi panjang baris perintah (secara default ~ 4 kb). <br><br>  Tetapi Anda dapat membatasi eksekusi menggunakan opsi -n, sehingga <b>xargs</b> akan menjalankan perintah beberapa kali, mengirimkan sejumlah argumen pada suatu waktu: <br><br><pre> <code class="bash hljs">$ <span class="hljs-comment"><span class="hljs-comment"># lets print 5 arguments and send them to echo with xargs: $ echo 1 2 3 4 5 | xargs echo 1 2 3 4 5 $ # now let's repeat, but limit argument processing by 3 per execution $ echo 1 2 3 4 5 | xargs -n 3 echo 1 2 3 4 5</span></span></code> </pre> <br>  Maju terus.  Memproses daftar panjang bisa memakan banyak waktu, karena berjalan dalam satu utas.  Tetapi jika kita memiliki beberapa inti, kita dapat memberi tahu <b>xargs</b> untuk berjalan secara paralel: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 1 2 3 4 5 6 7 8 9 10| xargs -n 2 -P 3 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span></code> </pre> <br>  Pada contoh di atas, kami memberi tahu <b>xargs</b> untuk memproses daftar dalam 3 utas;  setiap utas akan mengambil dan memproses 2 argumen per eksekusi.  Jika Anda tidak tahu berapa banyak inti yang Anda miliki, mari optimalkan ini menggunakan " <b>nproc</b> ": <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 1 2 3 4 5 6 7 8 9 10 | xargs -n 2 -P $(nproc) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span></code> </pre> <br><h4>  12. tidur?  sementara  baca! </h4><br>  Beberapa saat Anda perlu menunggu beberapa detik.  Atau tunggu input pengguna dengan baca: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -p <span class="hljs-string"><span class="hljs-string">"Press any key to continue "</span></span> -n 1</code> </pre> <br>  Tetapi Anda bisa menambahkan opsi batas waktu untuk <b>membaca</b> perintah, dan skrip Anda akan dijeda untuk jumlah detik tertentu, tetapi dalam hal eksekusi interaktif, pengguna dapat dengan mudah melewati menunggu. <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -p <span class="hljs-string"><span class="hljs-string">"Press any key to continue (auto continue in 30 seconds) "</span></span> -t 30 -n 1</code> </pre> <br>  Jadi Anda bisa melupakan perintah tidur. <br><br>  Saya curiga tidak semua trik saya terlihat menarik, tetapi bagi saya sepertinya selusin adalah angka yang baik untuk diisi. <br><br>  Saat ini saya mengucapkan selamat tinggal, dan saya akan berterima kasih untuk berpartisipasi dalam survei. <br><br>  Tentu saja bebas untuk membahas hal di atas dan membagikan trik keren Anda di komentar! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444890/">https://habr.com/ru/post/id444890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444880/index.html">Interpretasi multi-dunia dari mekanika kuantum</a></li>
<li><a href="../id444882/index.html">Bank mulai memblokir akun freelance</a></li>
<li><a href="../id444884/index.html">Groovy meninggalkan C√©dric Champeau</a></li>
<li><a href="../id444886/index.html">Membalikkan aplikasi rekayasa setelah kebingungan</a></li>
<li><a href="../id444888/index.html">Bahasa Inggris dan TI: Burung hantu Inggris di globe Rusia?</a></li>
<li><a href="../id444892/index.html">Penipu AS Mendapatkan Jutaan Dolar sebagai Dukungan Teknologi Microsoft</a></li>
<li><a href="../id444894/index.html">Zabbix 4.2 dirilis</a></li>
<li><a href="../id444896/index.html">Daur Ulang Hard Drive sebagai Sampah Elektronik - Solusi Sebagian dari iNEMI</a></li>
<li><a href="../id444898/index.html">Bagaimana memilih modem broadband untuk kendaraan udara tak berawak (UAV) atau robotika</a></li>
<li><a href="../id444900/index.html">Formulir validasi dalam Vue.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>