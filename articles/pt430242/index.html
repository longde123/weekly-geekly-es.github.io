<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•Ö üë®üèæ‚Äçüé§ üó®Ô∏è OpenSceneGraph: N√≥s do Grupo, N√≥s da Transforma√ß√£o e N√≥s do Switch üë©üèΩ‚Äç‚öïÔ∏è üî¢ ü§ûüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 Quando um ponto, linha ou pol√≠gono complexo √© desenhado em um mundo tridimensional, o resultado final ser√° exibido em uma tela plana e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: N√≥s do Grupo, N√≥s da Transforma√ß√£o e N√≥s do Switch</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430242/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="imagem"><br><h1>  1. Introdu√ß√£o </h1><br>  Quando um ponto, linha ou pol√≠gono complexo √© desenhado em um mundo tridimensional, o resultado final ser√° exibido em uma tela plana e bidimensional.  Assim, objetos tridimensionais passam por um determinado caminho de transforma√ß√£o, transformando-se em um conjunto de pixels exibidos em uma janela bidimensional. <br><br>  O desenvolvimento de ferramentas de software que implementam gr√°ficos tridimensionais chegou, independentemente de qual voc√™ escolher, aproximadamente ao mesmo conceito de descri√ß√µes matem√°ticas e algor√≠tmicas das transforma√ß√µes acima.  Ideologicamente, APIs gr√°ficas "limpas", como o OpenGL, e mecanismos de jogos legais, como Unity e Unreal, usam mecanismos semelhantes para descrever a transforma√ß√£o de uma cena tridimensional.  OpenSceneGraph n√£o √© excep√ß√£o. <br><br>  Neste artigo, revisaremos os mecanismos para agrupar e transformar objetos tridimensionais no OSG. <br><a name="habracut"></a><br><h1>  1. Matriz modelo, matriz de exibi√ß√£o e matriz de proje√ß√£o </h1><br>  Tr√™s matrizes b√°sicas envolvidas na transforma√ß√£o de coordenadas est√£o envolvidas na transforma√ß√£o entre diferentes sistemas de coordenadas.  Freq√ºentemente, em termos de OpenGL, eles s√£o chamados de <em>matriz</em> <em>modelo</em> <em>, matriz de exibi√ß√£o</em> e <em>matriz de proje√ß√£o</em> . <br><br>  A matriz do modelo √© usada para descrever a localiza√ß√£o do objeto no mundo 3D.  Ele converte v√©rtices do <em>sistema de coordenadas local do objeto</em> para o <em>sistema de coordenadas</em> do <em>mundo</em> .  A prop√≥sito, todos os sistemas de coordenadas no OSG s√£o <em>destros</em> . <br><br>  O pr√≥ximo passo √© a transforma√ß√£o das coordenadas do mundo em um espa√ßo de visualiza√ß√£o, realizado usando a matriz de visualiza√ß√£o.  Suponha que tenhamos uma c√¢mera localizada na origem do sistema de coordenadas do mundo.  A matriz inversa √† matriz de transforma√ß√£o da c√¢mera √© realmente usada como uma matriz de visualiza√ß√£o.  Em um sistema de coordenadas destro, o OpenGL, por padr√£o, sempre define uma c√¢mera localizada no ponto (0, 0, 0) do sistema de coordenadas global e direcionada ao longo da dire√ß√£o negativa do eixo Z. <br><br>  Noto que no OpenGL a matriz do modelo e a matriz da vista n√£o s√£o separadas.  No entanto, a matriz de visualiza√ß√£o de modelo √© determinada l√°, que converte as coordenadas locais do objeto nas coordenadas do espa√ßo de visualiza√ß√£o.  Essa matriz, de fato, √© o produto da matriz do modelo e da matriz do formul√°rio.  Assim, a transforma√ß√£o de um v√©rtice V de coordenadas locais em um espa√ßo da forma pode ser escrita condicionalmente como o produto <br><br><pre><code class="plaintext hljs">Ve = V * modelViewMatrix</code> </pre> <br>  A pr√≥xima tarefa importante √© determinar como os objetos 3D ser√£o projetados no plano da tela e calcular a chamada <em>pir√¢mide de recorte</em> - uma √°rea do espa√ßo que cont√©m objetos a serem exibidos na tela.  A matriz de proje√ß√£o √© usada para especificar a pir√¢mide de recorte definida no espa√ßo mundial por seis planos: esquerdo, direito, inferior, superior, pr√≥ximo e distante.  O OpenGL fornece a fun√ß√£o gluPerapective (), que permite especificar uma pir√¢mide de recorte e uma maneira de projetar um mundo tridimensional em um plano. <br><br>  O sistema de coordenadas obtido ap√≥s as transforma√ß√µes acima √© chamado de <em>sistema de coordenadas normalizadas do dispositivo</em> , possui um intervalo de coordenadas de -1 a 1 em cada eixo e √© canhoto.  E, como √∫ltimo passo, os dados recebidos s√£o projetados na porta de exibi√ß√£o (janela de visualiza√ß√£o) da janela, definida pelo ret√¢ngulo da √°rea do cliente da janela.  Depois disso, o mundo 3D aparece na nossa tela 2D.  O valor final das coordenadas da tela dos v√©rtices Vs pode ser expresso pela seguinte transforma√ß√£o <br><br><pre> <code class="plaintext hljs">Vs = V * modelViewMatrix * projectionMatrix * windowMatrix</code> </pre><br>  ou <br><br><pre> <code class="plaintext hljs">Vs = V * MVPW</code> </pre><br>  em que MVPW √© a matriz de transforma√ß√£o equivalente igual ao produto de tr√™s matrizes: matrizes de visualiza√ß√£o de modelo, matrizes de proje√ß√£o e matrizes de janela. <br><br>  Vs nessa situa√ß√£o √© um vetor tridimensional que determina a posi√ß√£o de um pixel 2D com um valor de profundidade.  Invertendo a opera√ß√£o de transforma√ß√£o de coordenadas, obtemos uma linha no espa√ßo tridimensional.  Portanto, um ponto 2D pode ser considerado como dois pontos - um no pr√≥ximo (Zs = 0) e outro no plano de recorte distante (Zs = 1).  As coordenadas desses pontos no espa√ßo tridimensional <br><br><pre> <code class="plaintext hljs">V0 = (Xs, Ys, 0) * invMVPW V1 = (Xs, Ys, 1) * invMVPW</code> </pre><br>  onde invMVPW √© o inverso do MVPW. <br><br>  Em todos os exemplos discutidos at√© o momento, criamos um √∫nico objeto tridimensional nas cenas.  Nestes exemplos, as coordenadas locais do objeto sempre coincidiam com as coordenadas globais globais.  Agora √© hora de falar sobre ferramentas que permitem colocar muitos objetos na cena e mudar sua posi√ß√£o no espa√ßo. <br><br><h1>  2. N√≥s do grupo </h1><br>  A classe osg :: Group √© o chamado <em>n√≥</em> do <em>grupo</em> de um gr√°fico de cena no OSG.  Pode ter qualquer n√∫mero de n√≥s filhos, incluindo n√≥s de folha geom√©trica ou outros n√≥s de grupo.  Esses s√£o os n√≥s mais usados ‚Äã‚Äãcom ampla funcionalidade. <br><br>  A classe osg :: Group √© derivada da classe osg :: Node e, consequentemente, herda da classe osg :: Referenced.  osg :: Group cont√©m uma lista de n√≥s filhos, em que cada n√≥ filho √© controlado por um ponteiro inteligente.  Isso garante que n√£o haja vazamentos de mem√≥ria ao fazer cascata em um galho de uma √°rvore de cena.  Esta classe fornece ao desenvolvedor v√°rios m√©todos p√∫blicos. <br><ol><li>  addChild () - acrescenta o n√≥ ao final da lista de n√≥s filhos.  Por outro lado, existe o m√©todo insertChild (), que coloca o n√≥ filho em uma posi√ß√£o espec√≠fica na lista, especificado por um √≠ndice inteiro ou um ponteiro para o n√≥, passado como par√¢metro. <br></li><li>  removeChild () e removeChildren () - remova um √∫nico n√≥ ou grupo de n√≥s. <br></li><li>  getChild () - obtendo um ponteiro para um n√≥ pelo seu √≠ndice na lista <br></li><li>  getNumChildren () - obtendo o n√∫mero de n√≥s filhos anexados a este grupo. <br></li></ol><br><h2>  Gerenciamento do n√≥ pai </h2><br>  Como j√° sabemos, a classe osg :: Group gerencia grupos de seus objetos filhos, entre os quais podem haver inst√¢ncias osg :: Geode que controlam a geometria dos objetos de cena.  Ambas as classes t√™m uma interface para gerenciar n√≥s-pai. <br><br>  O OSG permite que os n√≥s da cena tenham v√°rios n√≥s principais (falaremos sobre isso mais tarde).  Enquanto isso, veremos os m√©todos definidos em osg :: Node que s√£o usados ‚Äã‚Äãpara manipular n√≥s-pai: <br><ol><li>  getParent () - retorna um ponteiro do tipo osg :: Group que cont√©m uma lista de n√≥s pais. <br></li><li>  getNumParants () - retorna o n√∫mero de n√≥s pais. <br></li><li>  getParentalNodePath () - retorna todos os caminhos poss√≠veis para o n√≥ raiz da cena a partir do n√≥ atual.  Retorna uma lista de vari√°veis ‚Äã‚Äãdo tipo osg :: NodePath. <br></li></ol><br>  osg :: NodePath √© um vetor std :: de ponteiros para n√≥s de cena. <br><br><img src="https://habrastorage.org/webt/hx/nb/nk/hxnbnknku1ayvk06j3ank2mug9k.png"><br><br>  Por exemplo, para a cena mostrada na figura, o seguinte c√≥digo <br><br><pre> <code class="cpp hljs">osg::NodePath &amp;nodePath = child3-&gt;getParentalNodePaths()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nodePath.size(); ++i) { osg::Node *node = nodePath[i]; <span class="hljs-comment"><span class="hljs-comment">// -    }</span></span></code> </pre><br>  retornar√° n√≥s Raiz, Filho1, Filho2. <br><br>  Voc√™ n√£o deve usar mecanismos de gerenciamento de mem√≥ria para referenciar n√≥s-pai.  Quando um n√≥ pai √© exclu√≠do, todos os n√≥s filhos s√£o exclu√≠dos automaticamente, o que pode levar a uma falha no aplicativo. <br><br><h1>  3. Adicionando v√°rios modelos √† √°rvore de cenas </h1><br>  Ilustramos o mecanismo para usar grupos com o exemplo a seguir. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de grupo completo</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Group&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc, (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cow.osg"); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(model1.get()); root-&gt;addChild(model2.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Fundamentalmente, o exemplo difere de todos os anteriores porque carregamos dois modelos tridimensionais e, para adicion√°-los √† cena, criamos um n√≥ raiz do grupo e adicionamos nossos modelos a ele como n√≥s filhos <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(model1.get()); root-&gt;addChild(model2.get());</code> </pre><br><img src="https://habrastorage.org/webt/gu/yg/gx/guyggxstfydtvlfbosbe-ara3jm.png"><br><br>  Como resultado, temos uma cena composta por dois modelos - um avi√£o e uma vaca-espelho engra√ßada.  A prop√≥sito, uma vaca espelhada n√£o ser√° espelhada, a menos que voc√™ copie sua textura do OpenSceneGraph-Data / Images / reflect.rgb para o diret√≥rio data / Images do nosso projeto. <br><br>  A classe osg :: Group pode aceitar qualquer tipo de n√≥ como filho, incluindo n√≥s desse tipo.  Pelo contr√°rio, a classe osg :: Geode n√£o cont√©m nenhum n√≥ filho - √© um n√≥ terminal que cont√©m a geometria do objeto de cena.  Esse fato √© conveniente quando se pergunta se o n√≥ √© do tipo osg :: Group ou outro tipo de derivado de osg :: Node.  Vejamos um pequeno exemplo. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; model = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osg::Group *&gt;(osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>));</code> </pre><br>  O valor retornado pela fun√ß√£o osgDB :: readNodeFile () √© sempre do tipo osg :: Node *, mas pode ser convertido em seu descendente osg :: Group *.  Se o n√≥ do modelo Cessna for um n√≥ de grupo, a convers√£o ser√° bem-sucedida; caso contr√°rio, a convers√£o retornar√° NULL. <br><br>  Voc√™ tamb√©m pode executar o mesmo truque que funciona na maioria dos compiladores <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      osg::ref_ptr&lt;osg::Group&gt; group = ...; //     osg::Node* node1 = dynamic_cast&lt;osg::Node*&gt;( group.get() ); //      osg::Node* node2 = group.get();</span></span></code> </pre><br>  Em locais de c√≥digo com desempenho cr√≠tico, √© melhor usar m√©todos de convers√£o especiais <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"cessna.osg"</span></span>); osg::Group* convModel1 = model-&gt;asGroup(); <span class="hljs-comment"><span class="hljs-comment">//   osg::Geode* convModel2 = model-&gt;asGeode(); //  NULL.</span></span></code> </pre><br><h1>  4. N√≥s de transforma√ß√£o </h1><br>  N√≥s Osg :: Group n√£o podem fazer nenhuma transforma√ß√£o, exceto a capacidade de ir para seus n√≥s filhos.  O OSG fornece a classe osg :: Transform para o movimento da geometria espacial.  Essa classe √© sucessora da classe osg :: Group, mas tamb√©m √© abstrata - na pr√°tica, seus herdeiros s√£o usados, os quais implementam v√°rias transforma√ß√µes espaciais da geometria.  Ao percorrer o gr√°fico de cena, o n√≥ osg :: Transform adiciona sua transforma√ß√£o √† matriz de transforma√ß√£o atual do OpenGL.  Isso √© equivalente √† multiplica√ß√£o das matrizes de transforma√ß√£o OpenGL pelo comando glMultMatrix () <br><br><img src="https://habrastorage.org/webt/sj/f7/ql/sjf7qlofwivlimwfljauwnll9nw.png"><br><br>  Este exemplo de gr√°fico de cena pode ser traduzido no seguinte c√≥digo OpenGL <br><br><pre> <code class="cpp hljs">glPushMatrix(); glMultMatrix( matrixOfTransform1 ); renderGeode1(); glPushMatrix(); glMultMatrix( matrixOfTransform2 ); renderGeode2(); glPopMatrix(); glPopMatrix();</code> </pre><br>  Podemos dizer que a posi√ß√£o de Geode1 √© definida no sistema de coordenadas Transform1, e a posi√ß√£o de Geode2 √© definida no sistema de coordenadas Transform2, deslocada em rela√ß√£o √† Transform1.  Ao mesmo tempo, o posicionamento em coordenadas absolutas pode ser ativado no OSG, o que levar√° ao comportamento do objeto, equivalente ao resultado do comando OpenGL glGlobalMatrix () <br><br><pre> <code class="cpp hljs">transformNode-&gt;setReferenceFrame( osg::Transform::ABSOLUTE_RF );</code> </pre><br>  Voc√™ pode voltar ao modo de posicionamento relativo <br><br><pre> <code class="cpp hljs">transformNode-&gt;setReferenceFrame( osg::Transform::RELATIVE_RF );</code> </pre><br><h1>  5. O conceito de matriz de transforma√ß√£o de coordenadas </h1><br>  O tipo osg :: Matrix √© um tipo OSG b√°sico n√£o controlado por ponteiros inteligentes.  Ele fornece uma interface para opera√ß√µes em matrizes 4x4 que descrevem a transforma√ß√£o de coordenadas, como mover, girar, dimensionar e calcular proje√ß√µes.  A matriz pode ser especificada explicitamente. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   44 osg::Matrix mat(1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f );</span></span></code> </pre><br>  A classe osg :: Matrix fornece os seguintes m√©todos p√∫blicos: <br><br><ol><li>  postMult () e operator * () - a multiplica√ß√£o correta da matriz atual pela matriz ou pelo vetor passado como par√¢metro.  O m√©todo preMult () executa a multiplica√ß√£o √† esquerda. <br></li><li>  makeTranslate (), makeRotate () e makeScale () - redefine a matriz atual e crie uma matriz 4x4 que descreva o movimento, a rota√ß√£o e a escala.  suas vers√µes est√°ticas translate (), rotate () e scale () podem ser usadas para criar um objeto de matriz com par√¢metros espec√≠ficos. <br></li><li>  invert () - calcula o inverso da matriz atual.  Sua vers√£o est√°tica de inverse () pega uma matriz como par√¢metro e retorna uma nova matriz inversa √† determinada. <br></li></ol><br>  OSG entende matrizes como matrizes de strings e vetores como strings, portanto, para aplicar uma transforma√ß√£o de matriz em um vetor, fa√ßa isso <br><br><pre> <code class="cpp hljs">osg::Matrix mat = ‚Ä¶; osg::Vec3 vec = ‚Ä¶; osg::Vec3 resultVec = vec * mat;</code> </pre><br>  A ordem das opera√ß√µes da matriz √© f√°cil de entender, observando como as matrizes s√£o multiplicadas para obter uma convers√£o equivalente <br><br><pre> <code class="cpp hljs">osg::Matrix mat1 = osg::Matrix::scale(sx, sy, sz); osg::Matrix mat2 = osg::Matrix::translate(x, y, z); osg::Matrix resultMat = mat1 * mat2;</code> </pre><br>  O desenvolvedor deve ler o processo de transforma√ß√£o da esquerda para a direita.  Ou seja, no fragmento de c√≥digo descrito, o vetor primeiro escala e depois seu movimento. <br><br>  osg :: Matrixf cont√©m elementos do tipo float. <br><br><h1>  6. Usando a classe osg :: MatrixTransform </h1><br>  Aplicamos o conhecimento te√≥rico adquirido na pr√°tica, carregando dois modelos de aeronaves em diferentes pontos da cena. <br><br><div class="spoiler">  <b class="spoiler_title">Texto completo do exemplo de transforma√ß√£o</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = new osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::translate(-25.0, 0.0, 0.0)); transform1-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = new osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(25.0, 0.0, 0.0)); transform2-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  O exemplo √© realmente bastante trivial.  Carregando o modelo do avi√£o a partir do arquivo <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>);</code> </pre><br>  Crie um n√≥ de transforma√ß√£o <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform;</code> </pre><br>  Definimos o modelo para mov√™-lo ao longo das 25 unidades do eixo X para a esquerda como matriz de transforma√ß√£o <br><br><pre> <code class="cpp hljs">transform1-&gt;setMatrix(osg::Matrix::translate(<span class="hljs-number"><span class="hljs-number">-25.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>));</code> </pre><br>  Definimos nosso modelo para o n√≥ de transforma√ß√£o como um n√≥ filho <br><br><pre> <code class="cpp hljs">transform1-&gt;addChild(model.get());</code> </pre><br>  Fazemos o mesmo com a segunda transforma√ß√£o, mas como matriz, definimos o movimento para a direita em 25 unidades <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(<span class="hljs-number"><span class="hljs-number">25.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); transform2-&gt;addChild(model.get());</code> </pre><br>  Criamos um n√≥ raiz e, como n√≥s de transforma√ß√£o, definimos n√≥s de transforma√ß√£o transform1 e transform2 <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get());</code> </pre><br>  Crie um visualizador e passe o n√≥ raiz para ele como dados da cena <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.setSceneData(root.get());</code> </pre><br>  A execu√ß√£o do programa fornece uma imagem <br><br><img src="https://habrastorage.org/webt/tb/3q/xn/tb3qxnvgrcobwa0w7sz13k2njq8.png"><br><br>  A estrutura do gr√°fico de cena neste exemplo √© a seguinte. <br><br><img src="https://habrastorage.org/webt/pp/ig/xg/ppigxg36m3wph0idp1bwyln57tq.png"><br><br>  N√£o devemos ficar confusos pelo fato de os n√≥s de transforma√ß√£o (Filho 1.1 e Filho 1.2) se referirem ao mesmo objeto filho do modelo de avi√£o (Filho 2).  Esse √© um mecanismo OSG comum, quando um n√≥ filho de um gr√°fico de cena pode ter v√°rios n√≥s pais.  Portanto, n√£o precisamos armazenar duas inst√¢ncias do modelo em nossa mem√≥ria para obter dois planos id√™nticos em cena.  Esse mecanismo permite alocar mem√≥ria de maneira muito eficiente no aplicativo.  O modelo n√£o ser√° exclu√≠do da mem√≥ria at√© que seja referido como filho, pelo menos um n√≥. <br><br>  Em sua a√ß√£o, a classe osg :: MatrixTransform √© equivalente aos comandos OpenGL glMultMatrix () e glLoadMatrix (), implementa todos os tipos de transforma√ß√µes espaciais, mas √© dif√≠cil de usar devido √† necessidade de calcular a matriz de transforma√ß√£o. <br><br>  A classe osg :: PositionAttitudeTransform funciona como as fun√ß√µes OpenGL glTranslate (), glScale (), glRotate ().  Ele fornece m√©todos p√∫blicos para converter n√≥s filhos: <br><br><ol><li>  setPosition () - move o n√≥ para um determinado ponto no espa√ßo especificado pelo par√¢metro osg :: Vec3 <br></li><li>  setScale () - dimensiona o objeto ao longo dos eixos de coordenadas.  Os fatores de escala ao longo dos eixos correspondentes s√£o definidos por um par√¢metro do tipo osg :: Vec3 <br></li><li>  setAttitude () - define a orienta√ß√£o espacial do objeto.  Como par√¢metro, usa o quaternion de convers√£o de rota√ß√£o osg :: Quat, cujo construtor possui v√°rias sobrecargas que permitem especificar o quaternion diretamente (no sentido dos componentes) e, por exemplo, atrav√©s dos √¢ngulos de Euler osg :: Quat (xAngle, osg :: X_AXIS, yAngle, osg :: Y_AXIS, zAngle, osg :: Z_AXIS) (os √¢ngulos s√£o dados em radianos!) <br></li></ol><br><br><h1>  7. N√≥s do comutador </h1><br>  Considere outra classe - osg :: Switch, que permite exibir ou pular a renderiza√ß√£o de um n√≥ de cena, dependendo de alguma condi√ß√£o l√≥gica.  √â um descendente da classe osg :: Group e atribui algum valor l√≥gico a cada um de seus filhos.  Possui v√°rios m√©todos p√∫blicos √∫teis: <br><ol><li>  O addChild () sobrecarregado, como um segundo par√¢metro, utiliza uma chave l√≥gica que indica se deve ou n√£o exibir este n√≥. <br></li><li>  setValue () - define a chave de visibilidade / invisibilidade.  Leva o √≠ndice do n√≥ filho de seu interesse e o valor da chave desejada.  Assim, getValue () permite que voc√™ obtenha o valor atual da chave pelo √≠ndice do n√≥ de seu interesse. <br></li><li>  setNewChildDefaultValue () - define o valor padr√£o para a chave de visibilidade de todos os novos objetos adicionados como filhos. <br></li></ol><br>  Considere a aplica√ß√£o desta classe com um exemplo. <br><br><div class="spoiler">  <b class="spoiler_title">Troca de exemplo completo</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;osg::Switch&gt; root = new osg::Switch; root-&gt;addChild(model1.get(), false); root-&gt;addChild(model2.get(), true); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  O exemplo √© trivial - carregamos dois modelos: uma cessna convencional e uma cessna com o efeito de um motor em chamas <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessnafire.osg"</span></span>);</code> </pre><br>  No entanto, criamos osg :: Switch como o n√≥ raiz, o que nos permite, ao adicionar modelos a ele como n√≥s filhos, definir a chave de visibilidade para cada um deles <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Switch&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Switch; root-&gt;addChild(model1.get(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); root-&gt;addChild(model2.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  Ou seja, model1 n√£o ser√° renderizado e model2 ser√°, o que observaremos executando o programa <br><br><img src="https://habrastorage.org/webt/ne/ql/xu/neqlxu8zkqzvsusyzeoaqow8urg.png"><br><br>  Ao trocar os valores das teclas, veremos a imagem oposta <br><br><pre> <code class="cpp hljs">root-&gt;addChild(model1.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); root-&gt;addChild(model2.get(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/fs/ae/z4/fsaez4jingyv1u3lx9-4ihsr3zq.png"><br><br>  Armando ambas as teclas, veremos dois modelos ao mesmo tempo <br><br><pre> <code class="cpp hljs">root-&gt;addChild(model1.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); root-&gt;addChild(model2.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/vl/7j/za/vl7jzamish8ype6md3lljfnqsp0.png"><br><br>  Voc√™ pode ativar a visibilidade e a invisibilidade de um n√≥, filho de osg :: Switch, em movimento, usando o m√©todo setValue () <br><br><pre> <code class="cpp hljs">switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><h1>  Conclus√£o </h1><br>  Neste tutorial, examinamos todas as principais classes de n√≥s intermedi√°rios usadas no OpenSceeneGraph.  Assim, lan√ßamos mais um tijolo b√°sico na base do conhecimento sobre o dispositivo desse mecanismo gr√°fico indubitavelmente interessante.  Os exemplos discutidos no artigo, como antes, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">est√£o dispon√≠veis no meu reposit√≥rio no Github</a> . <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para continuar ...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430242/">https://habr.com/ru/post/pt430242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430230/index.html">Como manter seu lugar em uma startup em crescimento</a></li>
<li><a href="../pt430232/index.html">Gera√ß√£o de chamada fechada em jogos: "√Ä beira da derrota" ou "Quase venceu"</a></li>
<li><a href="../pt430236/index.html">NASA anuncia v√¥o da lua nova</a></li>
<li><a href="../pt430238/index.html">Outro dsl no Kotlin ou como imprimi PDF de reagir</a></li>
<li><a href="../pt430240/index.html">Vulnerabilidade de n√∫mero pseudo aleat√≥rio em Bitcoin</a></li>
<li><a href="../pt430244/index.html">A SpaceX recebeu permiss√£o para implantar uma rede de sat√©lites com 11943 sat√©lites</a></li>
<li><a href="../pt430246/index.html">Mudan√ßa para o socialismo austr√≠aco</a></li>
<li><a href="../pt430252/index.html">Inimigo por dentro: como entrei no redding</a></li>
<li><a href="../pt430256/index.html">Configura√ß√£o de aplicativos - metadados de configura√ß√£o de primavera</a></li>
<li><a href="../pt430258/index.html">N√£o aos aterros sanit√°rios com res√≠duos perigosos - coloque uma fazenda de vermicin√≠feros sob a janela</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>