<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏾 🌁 🔼 [CppCon 2018] Herb Sutter: vers un C ++ plus simple et plus puissant 👩🏻‍🔬 🍡 📢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans son discours à CppCon 2018, Herb Sutter a présenté au public ses réalisations dans deux directions. Tout d'abord, c'est le contrôle de la durée d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[CppCon 2018] Herb Sutter: vers un C ++ plus simple et plus puissant</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425873/"><iframe width="560" height="315" src="https://www.youtube.com/embed/80BZxujhY38" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> Dans son discours à CppCon 2018, Herb Sutter a présenté au public ses réalisations dans deux directions.  Tout d'abord, c'est le <strong>contrôle de la durée de vie des</strong> variables (Lifetime), qui permet de détecter des classes entières de bugs lors de la compilation.  Deuxièmement, il s'agit d'une proposition mise à jour sur les <strong>métaclasses</strong> , qui permettra d'éviter la duplication de code, décrivant une fois le comportement d'une catégorie de classe, puis la connectant à des classes spécifiques avec une seule ligne. </p><a name="habracut"></a><br><h2 id="predislovie-bolshe--prosche">  Avant-propos: plus = plus facile?! </h2><br><p>  Des accusations C ++ sont entendues que la norme se développe insensément et sans pitié.  Mais même les conservateurs les plus ardents ne soutiendront pas que de nouvelles constructions comme range-for (cycle de collecte) et auto (au moins pour les itérateurs) rendent le code plus simple.  Vous pouvez développer des critères approximatifs que (au moins un, idéalement tous) les nouvelles extensions linguistiques doivent satisfaire afin de simplifier le code dans la pratique: </p><br><ol><li>  Réduisez, simplifiez le code, supprimez le code en double (plage pour, auto, lambda, métaclasses) </li><li>  Rendre le code sûr plus facile à écrire, éviter les erreurs et les cas spéciaux (pointeurs intelligents, durée de vie) </li><li>  Remplacer complètement les anciennes fonctionnalités moins fonctionnelles (typedef → utilisation) </li></ol><br><p>  Herb Sutter identifie le «C ++ moderne» - un sous-ensemble de fonctionnalités qui sont conformes aux normes de codage modernes (telles que les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">directives de base C ++</a> ), et considère le standard complet comme un «mode de compatibilité» que tout le monde n'a pas besoin de connaître.  En conséquence, si le "C ++ moderne" ne se développe pas, alors tout va bien. </p><br><h2 id="proverki-vremeni-zhizni-peremennyh-lifetime">  Vérification de la durée de vie des variables (durée de vie) </h2><br><p>  Le nouveau groupe de vérification à vie est désormais disponible dans le cadre du Core Guidelines Checker pour Clang et Visual C ++.  Le but n'est pas d'atteindre une rigueur et une précision absolues, comme dans Rust, mais d'effectuer des vérifications simples et rapides dans les fonctions individuelles. </p><br><h3 id="osnovnye-principy-proverki">  Principes de base de la vérification </h3><br><p>  Du point de vue de l'analyse de la durée de vie, les types sont divisés en 3 catégories: </p><br><ul><li>  La valeur est ce à quoi un pointeur peut pointer. </li><li> Pointeur - fait référence à la valeur, mais ne contrôle pas sa durée de vie.  Peut être suspendu (pointeur suspendu).  Exemples: <code>T*</code> , <code>T&amp;</code> , itérateurs, <code>std::observer_ptr&lt;T&gt;</code> , <code>std::string_view</code> , <code>gsl::span&lt;T&gt;</code> </li><li>  Propriétaire - contrôle la durée de vie de la valeur.  Peut généralement supprimer sa valeur avant la date prévue.  Exemples: <code>std::unique_ptr&lt;T&gt;</code> , <code>std::shared_ptr&lt;T&gt;</code> , <code>std::vector&lt;T&gt;</code> , <code>std::string</code> , <code>gsl::owner&lt;T*&gt;</code> </li></ul><br><p>  Un pointeur peut se trouver dans l'un des états suivants: </p><br><ul><li>  Pointez sur une valeur stockée sur la pile </li><li>  Pointez sur une valeur contenue "à l'intérieur" par un propriétaire </li><li>  Être vide (null) </li><li>  Accrochez (invalide) </li></ul><br><h3 id="ukazateli-i-znacheniya">  Pointeurs et valeurs </h3><br><p>  Pour chaque pointeur <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.259ex" height="1.817ex" viewBox="-38.5 -520.7 542 782.1" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-70" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> p </script>  est suivi <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi><mi>s</mi><mi>e</mi><mi>t</mi><mo stretchy=&quot;false&quot;>(</mo><mi>p</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.251ex" height="2.66ex" viewBox="-38.5 -832 3122 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex; margin-left: -0.089ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-70" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-73" x="503" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-65" x="973" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-74" x="1439" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMAIN-28" x="1801" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-70" x="2190" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMAIN-29" x="2694" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi><mi>s</mi><mi>e</mi><mi>t</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-2"> pset (p) </script>  - l'ensemble des valeurs auxquelles il peut indiquer.  Lors de la suppression d'une valeur, son occurrence dans tous <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi><mi>s</mi><mi>e</mi><mi>t</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.272ex" height="2.298ex" viewBox="-38.5 -728.2 1839.5 989.6" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-70" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-73" x="503" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-65" x="973" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-74" x="1439" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi><mi>s</mi><mi>e</mi><mi>t</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> pset </script>  remplacé par <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>i</mi><mi>n</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>d</mi><mi>e</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.35ex" height="2.057ex" viewBox="0 -780.1 3595 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-69" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-6E" x="345" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-76" x="946" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-61" x="1431" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-6C" x="1961" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-69" x="2259" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-64" x="2605" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-65" x="3128" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi><mi>n</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>d</mi><mi>e</mi></math></span></span><script type="math/tex" id="MathJax-Element-4"> invalide </script>  .  Lors de l'accès à une valeur de pointeur <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.259ex" height="1.817ex" viewBox="-38.5 -520.7 542 782.1" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-70" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi></math></span></span><script type="math/tex" id="MathJax-Element-5"> p </script>  tel que <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>i</mi><mi>n</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>d</mi><mi>e</mi><mo>&amp;#x2208;</mo><mi>p</mi><mi>s</mi><mi>e</mi><mi>t</mi><mo stretchy=&quot;false&quot;>(</mo><mi>p</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.352ex" height="2.66ex" viewBox="0 -832 7901.6 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-69" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-6E" x="345" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-76" x="946" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-61" x="1431" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-6C" x="1961" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-69" x="2259" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-64" x="2605" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-65" x="3128" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMAIN-2208" x="3872" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-70" x="4818" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-73" x="5321" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-65" x="5791" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-74" x="6257" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMAIN-28" x="6619" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-70" x="7008" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMAIN-29" x="7512" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi><mi>n</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>d</mi><mi>e</mi><mo>∈</mo><mi>p</mi><mi>s</mi><mi>e</mi><mi>t</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-6"> invalide ∈ pset (p) </script>  émettre une erreur. </p><br><pre> <code class="cpp hljs">string_view s; <span class="hljs-comment"><span class="hljs-comment">// pset(s) = {null} { char a[100]; s = a; // pset(s) = {a} cout &lt;&lt; s[0]; // OK } // pset(s) = {invalid} cout &lt;&lt; s[0]; // ERROR: invalid ∈ pset(s)</span></span></code> </pre> <br><p>  À l'aide d'annotations, vous pouvez configurer les opérations qui seront considérées comme des opérations d'accès à la valeur.  Par défaut: <code>*</code> , <code>-&gt;</code> , <code>[]</code> , <code>begin()</code> , <code>end()</code> . </p><br><p>  Veuillez noter que l'avertissement n'est émis qu'au moment de l' <em>accès</em> à l'index invalide.  Si la valeur est supprimée, mais que personne n'accède à ce pointeur, tout est en ordre. </p><br><h3 id="ukazateli-i-vladelcy">  Panneaux et propriétaires </h3><br><p>  Si pointeur <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.259ex" height="1.817ex" viewBox="-38.5 -520.7 542 782.1" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-70" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi></math></span></span><script type="math/tex" id="MathJax-Element-7"> p </script>  indique une valeur contenue dans le propriétaire <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>o</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.128ex" height="1.455ex" viewBox="0 -520.7 485.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-6F" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>o</mi></math></span></span><script type="math/tex" id="MathJax-Element-8"> o </script>  alors ça <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi><mi>s</mi><mi>e</mi><mi>t</mi><mo stretchy=&quot;false&quot;>(</mo><mi>p</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msup><mi>o</mi><mo>&amp;#x2032;</mo></msup></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.162ex" height="2.66ex" viewBox="-38.5 -832 5236.4 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex; margin-left: -0.089ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-70" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-73" x="503" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-65" x="973" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-74" x="1439" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMAIN-28" x="1801" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-70" x="2190" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMAIN-29" x="2694" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMAIN-3D" x="3361" y="0"></use><g transform="translate(4417,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-6F" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMAIN-2032" x="686" y="513"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi><mi>s</mi><mi>e</mi><mi>t</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mrow class="MJX-TeXAtom-ORD"><msup><mi>o</mi><mo>′</mo></msup></mrow></math></span></span><script type="math/tex" id="MathJax-Element-9"> pset (p) = {o '} </script>  . </p><br><p>  Les méthodes et fonctions qui prennent les propriétaires, sont divisées en: </p><br><ul><li>  Opérations d'accès à la valeur propriétaire.  Par défaut: <code>*</code> , <code>-&gt;</code> , <code>[]</code> , <code>begin()</code> , <code>end()</code> </li><li>  Opérations d'accès au propriétaire lui-même, pointeurs <code>v.clear()</code> , comme <code>v.clear()</code> .  Par défaut, ce sont toutes les autres opérations non const </li><li>  Opérations d'accès au propriétaire lui-même, pointeurs non invalidants, tels que <code>v.empty()</code> .  Par défaut, ce sont toutes des opérations const. </li></ul><br><p>  Annonce d'un ancien propriétaire de contenu <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>i</mi><mi>n</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>d</mi><mi>e</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.35ex" height="2.057ex" viewBox="0 -780.1 3595 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-69" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-6E" x="345" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-76" x="946" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-61" x="1431" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-6C" x="1961" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-69" x="2259" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-64" x="2605" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhhCZFxYEk2r3xB_5wI-JyWblEV2NA#MJMATHI-65" x="3128" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi><mi>n</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>d</mi><mi>e</mi></math></span></span><script type="math/tex" id="MathJax-Element-10"> invalide </script>  lors de la révocation du Propriétaire ou lors de l'application d'opérations invalidantes. </p><br><p>  Ces règles suffisent pour détecter de nombreux bogues typiques dans le code C ++: </p><br><pre> <code class="cpp hljs">string_view s; <span class="hljs-comment"><span class="hljs-comment">// pset(s) = {null} string name = "foo"; s = name; // pset(s) = {name'} cout &lt;&lt; s[0]; // OK name = "bar"; // pset(s) = {invalid} cout &lt;&lt; s[0]; // ERROR</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v = get_ints(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* p = &amp;v[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// pset(p) = {v'} v.push_back(42); // pset(p) = {invalid} cout &lt;&lt; *p; // ERROR</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view s = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>s; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; s[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// ERROR // :       std::string_view s = "foo"s // pset(s) = {"foo"s '} ; // pset(s) = {invalid}</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v = get_ints(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = v.begin(); i != v.end(); ++i) { <span class="hljs-comment"><span class="hljs-comment">// pset(i) = {v'} if (*i == 2) { v.erase(i); // pset(i) = {invalid} } // pset(i) = {v', invalid} } // ERROR: ++i for (auto i = v.begin(); i != v.end(); ) { if (*i == 2) i = v.erase(i); // OK else ++i; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; get_data(); <span class="hljs-comment"><span class="hljs-comment">//   ,  get_data() != nullopt for (int value : *get_data()) // ERROR cout &lt;&lt; value; // *get_data() —     for (int value : std::vector&lt;int&gt;(*get_data())) // OK cout &lt;&lt; value;</span></span></code> </pre> <br><h3 id="otslezhivanie-vremeni-zhizni-parametrov-funkciy">  Suivi de la durée de vie des paramètres de fonction </h3><br><p>  Lorsque nous commençons à traiter des fonctions en C ++ qui renvoient des pointeurs, nous ne pouvons que deviner la relation entre la durée de vie des paramètres et la valeur de retour.  Si une fonction accepte et renvoie des pointeurs du même type, alors une hypothèse est faite que la fonction "obtient" la valeur de retour à partir d'un des paramètres d'entrée: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* q)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">*</span></span>; <span class="hljs-comment"><span class="hljs-comment">// pset(ret) = {p', q'} auto g(std::string&amp; s) -&gt; char*; // pset(ret) = {s'}</span></span></code> </pre> <br><p>  Les fonctions suspectes sont facilement détectées et ne produisent le résultat de nulle part: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::reference_wrapper&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; get_data() { <span class="hljs-comment"><span class="hljs-comment">//    int i = 3; return {i}; // pset(ret) = {i'} } // pset(ret) = {invalid}</span></span></code> </pre> <br><p>  Puisqu'il est possible de passer une valeur temporaire aux paramètres <code>const T&amp;</code> , ils ne sont pas pris en compte, sauf si le résultat n'est nulle part ailleurs à prendre: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; y)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// pset(ret) = {x', y'} //    const T&amp;- //        auto x = 10, y = 2; auto&amp; bad = min(x, y + 1); // pset(bad) = {x, temp} // pset(bad) = {x, invalid} cout &lt;&lt; bad; // ERROR</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> K = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> V = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> V&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_or_default</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;K, V&gt;&amp; m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> K&amp; key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> V&amp; def)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// pset(ret) = {m', key', def'} std::map&lt;K, V&gt; map; K key = "foo"; const V&amp; s = find_or_default(map, key, "none"); // pset(s) = {map', key', temp} ⇒ pset(s) = {map', key', invalid} cout &lt;&lt; s; // ERROR</span></span></code> </pre> <br><p>  On pense également que si une fonction accepte un pointeur (au lieu d'une référence), alors il peut être nullptr, et ce pointeur ne peut pas être utilisé avant de le comparer avec nullptr. </p><br><h3 id="zaklyuchenie-po-kontrolyu-vremeni-zhizni">  Conclusion sur le contrôle de la durée de vie </h3><br><p>  Je répète que Lifetime n'est pas encore une proposition pour la norme C ++, mais une tentative audacieuse d'implémenter des vérifications de durée de vie en C ++, où, contrairement à Rust, par exemple, il n'y a jamais eu d'annotations correspondantes.  Au début, il y aura beaucoup de faux positifs, mais au fil du temps, l'heuristique s'améliorera. </p><br><h3 id="voprosy-iz-zala">  Questions du public </h3><br><p>  <strong>Les vérifications de groupe à vie fournissent-elles une garantie mathématiquement précise de l'absence de pointeurs pendants?</strong> </p><br><p>  Théoriquement, il serait possible (dans le nouveau code) de bloquer un tas d'annotations sur les classes et les fonctions, et en retour le compilateur donnerait de telles garanties.  Mais ces vérifications ont été développées selon le principe 80:20, c'est-à-dire que vous pouvez détecter la plupart des erreurs en utilisant un petit nombre de règles et en appliquant un minimum d'annotations. </p><br><h2 id="metaklassy">  Métaclasses </h2><br><p>  La métaclasse complète en quelque sorte le code de la classe à laquelle elle est appliquée et sert également de nom à un groupe de classes qui remplissent certaines conditions.  Par exemple, comme illustré ci-dessous, la métaclasse d' <code>interface</code> rendra toutes les fonctions publiques et purement virtuelles pour vous. </p><br><p>  L'année dernière, Herb Sutter a réalisé son premier projet de métaclasse ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voir ici</a> ).  Depuis lors, la syntaxe actuellement proposée a changé. </p><br><p>  Pour commencer, la syntaxe d'utilisation des métaclasses a changé: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  interface Shape { int area() const; void scale_by(double factor); }; //  class(interface) Shape { … }</span></span></code> </pre> <br><p>  Il est devenu plus long, mais il existe maintenant une syntaxe naturelle pour appliquer plusieurs métaclasses à la fois: <code>class(meta1, meta2)</code> . </p><br><h3 id="opisanie-metaklassa">  Description de la métaclasse </h3><br><p>  Auparavant, une métaclasse était un ensemble de règles pour modifier une classe.  Maintenant, une métaclasse est une fonction constexpr qui prend une ancienne classe (déclarée dans le code) et en crée une nouvelle. </p><br><p>  À savoir, la fonction prend un paramètre - des méta-informations sur l'ancienne classe (le type de paramètre dépend de l'implémentation), crée des éléments de classe (fragments), puis les ajoute au corps de la nouvelle classe à l'aide de l'instruction <code>__generate</code> . </p><br><p>  Les fragments peuvent être générés à l'aide des constructions <code>__fragment</code> , <code>__inject</code> , <code>idexpr(…)</code> .  L'orateur a préféré ne pas se concentrer sur son objectif, car cette partie sera encore modifiée avant d'être soumise au comité de normalisation.  Les noms eux-mêmes sont garantis d'être changés, un double soulignement a été ajouté spécifiquement pour clarifier cela.  Le rapport met l'accent sur des exemples qui vont plus loin. </p><br><h3 id="interface">  interface </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T source)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// source    //     .     //  ~X,  X —   . __generate __fragment struct X { virtual ~X noexcept {} }; //    static_assert, compiler.require   //   constexpr-. //      . compiler.require(source.variables().empty(), "interfaces may not contain data members"); // member_functions(), ,  tuple&lt;…&gt;,   for... for... (auto f : source.member_functions()) { // ,   —   / compiler.require(!f.is_copy() &amp;&amp; !f.is_move(), "interfaces may not copy or move; consider a virtual clone()"); //   public   if (!f.has_default_access()) f.make_public(); // (1) // ,       protected/private compiler.require(f.is_public(), "interface functions must be public"); //     f.make_pure_virtual(); // (2) //   f     __generate f; } }</span></span></code> </pre> <br><p>  Vous pourriez penser que sur les lignes (1) et (2) nous modifions la classe d'origine, mais non.  Veuillez noter que nous parcourons les fonctions de la classe d'origine avec la copie, modifions ces fonctions, puis les insérons dans une nouvelle classe. </p><br><p>  Application de métaclasse: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scale_by</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> factor)</span></span></span></span>; }; <span class="hljs-comment"><span class="hljs-comment">//  : class Shape { public: virtual ~Shape noexcept {} public: virtual int area() const = 0; public: virtual void scale_by(double factor) = 0; };</span></span></code> </pre> <br><h3 id="otladka-myuteksa">  Débogage Mutex </h3><br><p>  Supposons que nous ayons des données non thread-safe protégées par un mutex.  Le débogage peut être facilité si, dans un assembly de débogage, à chaque appel, il est vérifié si le processus en cours a verrouillé ce mutex.  Pour ce faire, une simple classe TestableMutex a été écrite: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestableMutex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m.lock(); id = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ id = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id{}; m.unlock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_held</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex m; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id&gt; id; };</code> </pre> <br><p>  De plus, dans notre classe MyData, nous aimerions que chaque domaine public comme </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v;</code> </pre> <br><p>  Remplacez par + getter: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; v() { assert(m_.is_held()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v_; }</code> </pre> <br><p>  Pour les fonctions, vous pouvez également effectuer des transformations similaires. </p><br><p>  Ces tâches sont résolues à l'aide de macros et de la génération de code.  Herb Sutter a déclaré la guerre aux macros: elles sont dangereuses, ignorent la sémantique, les espaces de noms, etc.  A quoi ressemble la solution sur les métaclasses: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">guarded_with_mutex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ __generate __fragment <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> {</span></span> TestableMutex m_; <span class="hljs-comment"><span class="hljs-comment">// lock, unlock } } template &lt;typename T, typename U&gt; constexpr void guarded_member(T type, U name) { auto field = …; __generate field; auto getter = …; __generate getter; } template &lt;typename T&gt; constexpr void guarded(T source) { guarded_with_mutex(); for... (auto o : source.member_variables()) { guarded_member(o.type(), o.name()); } }</span></span></code> </pre> <br><p>  Comment l'utiliser: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">guarded</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; Widget* w; }; MyData&amp; x = findData(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); xv().clear(); <span class="hljs-comment"><span class="hljs-comment">// assertion failed: m_.is_held()</span></span></code> </pre> <br><h3 id="actor">  acteur </h3><br><p>  Eh bien, même si nous avons protégé un objet avec un mutex, maintenant tout est thread-safe, il n'y a aucune prétention à l'exactitude.  Mais si un objet est souvent accessible par de nombreux threads en parallèle, le mutex sera surchargé, et il y aura une surcharge importante pour le prendre. </p><br><p>  La solution fondamentale au problème des mutex buggy est le concept d'acteurs, lorsqu'un objet a une file d'attente de demande, tous les appels à l'objet sont mis en file d'attente et exécutés les uns après les autres dans un thread spécial. </p><br><p>  Laissez la classe Active contenir une implémentation de tout cela - en fait, un pool / exécuteur de threads avec un seul thread.  Eh bien, les métaclasses aideront à se débarrasser du code en double et à mettre en file d'attente toutes les opérations: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">active</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImageFilter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ImageFilter(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(Buffer*)&gt; w) : work(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(w)) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Buffer* b)</span></span></span><span class="hljs-function"> </span></span>{ work(b); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(Buffer*)&gt; work; } <span class="hljs-comment"><span class="hljs-comment">//  : class ImageFilter { public: ImageFilter(std::function&lt;void(Buffer*)&gt; w) : work(std::move(w)) {} void apply(Buffer* b) { a.send([=] { work(b); }).join(); } private: std::function&lt;void(Buffer*)&gt; work; Active a; //   ,     work }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">active</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">log</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::fstream f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(…)</span></span></span><span class="hljs-function"> </span></span>{ f &lt;&lt; …; } };</code> </pre> <br><h3 id="property">  propriété </h3><br><p>  Il existe des propriétés dans presque tous les langages de programmation modernes, et quiconque ne les a tout simplement pas implémentés sur la base de C ++: Qt, C ++ / CLI, toutes sortes de macros laides.  Cependant, ils ne seront jamais ajoutés à la norme C ++, car ils sont eux-mêmes considérés comme des fonctionnalités trop étroites, et il y avait toujours l'espoir qu'une proposition les implémenterait comme un cas spécial.  Eh bien, ils peuvent être implémentés sur des métaclasses! </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  class X { public: class(property&lt;int&gt;) WidthClass { } width; }; //  class X { public: class WidthClass { int value; int get() const; void set(const int&amp; v); void set(int&amp;&amp; v); public: WidthClass(); WidthClass(const int&amp; v); WidthClass&amp; operator=(const int&amp; v); operator int() const; //   move! WidthClass(int&amp;&amp; v); WidthClass&amp; operator=(int&amp;&amp; v); } width; };</span></span></code> </pre> <br><p>  Vous pouvez définir votre propre getter et setter: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class">&lt;int&gt;) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonthClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> month; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> month; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m)</span></span></span><span class="hljs-function"> </span></span>{ assert(m &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; m &lt; <span class="hljs-number"><span class="hljs-number">13</span></span>); month = m; } } month; }; Date date; date.month = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-comment"><span class="hljs-comment">// assertion failed</span></span></code> </pre> <br><p>  Idéalement, je veux écrire la <code>property int month { … }</code> , mais même une telle implémentation remplacera le zoo des extensions C ++ inventant des propriétés. </p><br><h3 id="zaklyuchenie-po-metaklassam">  Conclusion de la métaclasse </h3><br><p>  Les métaclasses sont une grande nouveauté pour un langage déjà complexe.  Est-ce que ça vaut le coup?  Voici certains de leurs avantages: </p><br><ul><li>  Laissez les programmeurs exprimer plus clairement leurs intentions (je veux écrire un acteur) </li><li>  Réduisez la duplication de code et simplifiez le développement et la maintenance du code qui suit certains modèles </li><li>  Élimine certains groupes d'erreurs courantes (il suffira de s'occuper de toutes les subtilités une fois) </li><li>  Permet de se débarrasser des macros?  (Herb Sutter est très belliqueux) </li></ul><br><h3 id="voprosy-iz-zala-1">  Questions du public </h3><br><p>  <strong>Comment déboguer des métaclasses?</strong> </p><br><p>  Au moins pour Clang, il existe une fonction intrinsèque qui, si elle est appelée, affichera le contenu réel de la classe au moment de la compilation, c'est-à-dire ce qui est obtenu après l'application de toutes les métaclasses. </p><br><p>  <strong>On disait qu'il était capable de déclarer des non-membres comme swap et hash dans les métaclasses.</strong>  <strong>Où est-elle partie?</strong> </p><br><p>  La syntaxe sera développée davantage. </p><br><p>  <strong>Pourquoi avons-nous besoin de métaclasses si des concepts ont déjà été adoptés pour la normalisation?</strong> </p><br><p>  Ce sont des choses différentes.  Des métaclasses sont nécessaires pour définir des parties d'une classe, et les concepts vérifient si une classe correspond à un certain modèle à l'aide d'exemples de classe.  En fait, les métaclasses et les concepts fonctionnent bien ensemble.  Par exemple, vous pouvez définir le concept d'un itérateur et la métaclasse d'un «itérateur typique» qui définit certaines opérations redondantes à travers le reste. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425873/">https://habr.com/ru/post/fr425873/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425859/index.html">Les opérateurs régionaux s'opposent à l'annulation de l'itinérance</a></li>
<li><a href="../fr425861/index.html">Testez-vous: pouvez-vous protéger l'entreprise contre les cyberattaques?</a></li>
<li><a href="../fr425867/index.html">Tests de performances des services Web dans le cadre de l'intégration continue. Expérience Yandex</a></li>
<li><a href="../fr425869/index.html">iFixit: Apple n'a pas encore activé le blocage des MacBooks remis à neuf</a></li>
<li><a href="../fr425871/index.html">Ekaterinbourg, 11 octobre - Atlassian rencontre le docker</a></li>
<li><a href="../fr425875/index.html">Mise à niveau de la matrice des ordinateurs portables TN-> IPS ou comment obtenir un ordinateur portable plus avancé à partir d'un ordinateur portable économique</a></li>
<li><a href="../fr425877/index.html">Le PDG d'Apple affirme que les puces d'espionnage chinoises dans les serveurs Supermicro sont de la fiction</a></li>
<li><a href="../fr425879/index.html">Ce que Google a montré lors de sa présentation</a></li>
<li><a href="../fr425881/index.html">Tout ce que vous devez savoir sur l'alignement dans Flexbox</a></li>
<li><a href="../fr425883/index.html">À plein temps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>