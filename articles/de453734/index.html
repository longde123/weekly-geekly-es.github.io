<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🚀 💊 🌠 Einführung in Helm 3 🏄 🤷🏽 ⌨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis perev. : Der 16. Mai dieses Jahres ist ein wichtiger Meilenstein in der Entwicklung des Paketmanagers für Kubernetes - Helm. An diesem Tag wur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in Helm 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/453734/"><img src="https://habrastorage.org/webt/bb/nh/vx/bbnhvxg0izlu9z_txy0y-ntmeje.png"><br><br>  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Der 16. Mai dieses Jahres ist ein wichtiger Meilenstein in der Entwicklung des Paketmanagers für Kubernetes - Helm.</i>  <i>An diesem Tag wurde die erste Alpha-Version der zukünftigen Hauptversion des Projekts vorgestellt - 3.0.</i>  <i>Ihre Freilassung wird bedeutende und lang erwartete Veränderungen für Helm bringen, auf die viele in der Kubernetes-Community große Hoffnungen haben.</i>  <i>Wir selbst behandeln diese, indem wir Helm aktiv für die Bereitstellung von Anwendungen verwenden: Wir haben es in unser Tool zur Implementierung von CI / CD <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werf integriert</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">leisten</a> von Zeit zu Zeit einen praktikablen Beitrag zur Entwicklung von Upstream.</i>  <i>Diese Übersetzung enthält 7 Notizen aus dem offiziellen Helm-Blog, die zeitlich auf die erste Alpha-Version von Helm 3 abgestimmt sind und über die Geschichte des Projekts und die Hauptmerkmale von Helm 3 berichten. Ihr Autor ist Matt "bacongobbler" Fisher, ein Microsoft-Mitarbeiter und einer der wichtigsten Helm-Betreuer.</i> <a name="habracut"></a><br><br>  Am 15. Oktober 2015 wurde das Projekt geboren, das heute als Helm bekannt ist.  Nur ein Jahr nach ihrer Gründung schloss sich die Helm-Community Kubernetes an und arbeitete aktiv an Helm 2. Im Juni 2018 trat Helm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CNCF</a> als Inkubationsprojekt bei.  Schneller Vorlauf in die Gegenwart - und jetzt ist die erste Alpha-Version des neuen Helm 3 auf dem Weg <i>(diese Veröffentlichung <a href="">fand bereits</a> Mitte Mai statt - ca. übersetzt)</i> . <br><br>  In diesem Artikel werde ich darüber sprechen, wie alles begann, wie wir zum gegenwärtigen Stadium gekommen sind, einige einzigartige Funktionen vorstellen, die in der ersten Alpha-Version von Helm 3 verfügbar sind, und erklären, wie wir uns weiterentwickeln wollen. <br><br>  Zusammenfassung: <br><br><ul><li>  Geschichte der Erschaffung von Helm; </li><li>  sanfter Abschied von Tiller; </li><li>  Diagramm-Repositorys; </li><li>  Release-Management; </li><li>  Änderungen der Diagrammabhängigkeiten; </li><li>  Bibliotheksdiagramme; </li><li>  was weiter? </li></ul><br><h2>  Geschichte von Helm </h2><br><h3>  Geburt </h3><br>  Helm 1 begann als Open Source-Projekt von Deis.  Wir waren ein kleines Startup, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das</a> im Frühjahr 2017 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von</a> Microsoft übernommen wurde.  Unser anderes Open Source-Projekt, ebenfalls Deis genannt, verfügte über ein <code>deisctl</code> Tool, mit dem (unter anderem) die Deis-Plattform im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fleet-Cluster</a> installiert und betrieben wurde.  Die Flotte war zu dieser Zeit eine der ersten Plattformen für die Container-Orchestrierung. <br><br>  Mitte 2015 beschlossen wir, den Kurs zu ändern und Deis (damals in Deis Workflow umbenannt) von Fleet nach Kubernetes zu übertragen.  Einer der ersten, der das <code>deisctl</code> Installationstool neu gestaltet hat.  Wir haben damit Deis Workflow in einem Flottencluster installiert und verwaltet. <br><br>  Helm 1 wurde nach dem Vorbild bekannter Paketmanager wie Homebrew, apt und yum erstellt.  Die Hauptaufgabe bestand darin, Aufgaben wie das Packen und Installieren von Anwendungen in Kubernetes zu vereinfachen.  Helm wurde 2015 auf der KubeCon-Konferenz in San Francisco offiziell vorgestellt. <br><br>  Unser erster Versuch mit Helm hat funktioniert, aber es gab ernsthafte Einschränkungen.  Er nahm eine Reihe von Kubernetes-Manifesten, die mit Generatoren aromatisiert waren, als <i>Front-Materie-</i> YAML-Blöcke und lud die Ergebnisse auf Kubernetes hoch. <br><br>  <i>* <b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Ab der ersten Version von Helm wurde die YAML-Syntax ausgewählt, um Kubernetes-Ressourcen zu beschreiben, und Jinja-Vorlagen und Python-Skripte wurden beim Schreiben von Konfigurationen unterstützt.</i>  <i>Wir haben mehr darüber und über das Gerät der ersten Version von Helm im Kapitel „Eine kurze Geschichte von Helm“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Materials geschrieben</a> .</i> <br><br>  Um beispielsweise ein Feld in einer YAML-Datei zu ersetzen, mussten Sie dem Manifest das folgende Konstrukt hinzufügen: <br><br><pre> <code class="plaintext hljs">#helm:generate sed -i -es|ubuntu-debootstrap|fluffy-bunny| my/pod.yaml</code> </pre> <br>  Es ist cool, dass es heute Template-Engines gibt, nicht wahr? <br><br>  Aus vielen Gründen erforderte dieses frühe Kubernetes-Installationsprogramm eine fest codierte Liste von Manifestdateien und führte nur eine kleine feste Folge von Ereignissen aus.  Es war so schwer zu bedienen, dass es dem Forschungs- und Entwicklungsteam von Deis Workflow schwer fiel, sein Produkt auf diese Plattform zu übertragen - die Saat der Idee war jedoch bereits gelegt.  Unser erster Versuch war eine großartige Gelegenheit zum Lernen: Wir stellten fest, dass wir wirklich leidenschaftlich daran interessiert waren, pragmatische Tools zu entwickeln, die alltägliche Probleme für unsere Benutzer lösen. <br><br>  Basierend auf den Erfahrungen mit Fehlern in der Vergangenheit haben wir begonnen, Helm 2 zu entwickeln. <br><br><h3>  Schöpfungshelm 2 </h3><br>  Ende 2015 hat uns das Google-Team kontaktiert.  Sie arbeiteten an einem ähnlichen Tool für Kubernetes.  Deployment Manager für Kubernetes war der Port des vorhandenen Tools, das für die Google Cloud Platform verwendet wurde.  "Würden wir", fragten sie, "ein paar Tage damit verbringen, die Ähnlichkeiten und Unterschiede zu diskutieren?" <br><br>  Im Januar 2016 trafen sich die Teams von Helm und Deployment Manager in Seattle, um Ideen auszutauschen.  Die Verhandlungen endeten mit einem ehrgeizigen Plan: Beide Projekte zu Helm 2 zu kombinieren. Zusammen mit Deis und Google schlossen sich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mitarbeiter</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SkippBox</a> <i>(jetzt Teil von Bitnami - ca. Transl.)</i> Dem Entwicklungsteam an und wir begannen mit der Arbeit an Helm 2. <br><br>  Wir wollten die Benutzerfreundlichkeit von Helm beibehalten, aber Folgendes hinzufügen: <br><br><ul><li>  Diagrammvorlagen zur Anpassung; </li><li>  Intracluster-Management für Teams; </li><li>  Erstklassiges Diagramm-Repository </li><li>  stabiles Paketformat mit der Fähigkeit zu signieren; </li><li>  Starkes Engagement für die semantische Versionierung und die Aufrechterhaltung der Abwärtskompatibilität zwischen Versionen. </li></ul><br>  Um diese Ziele zu erreichen, wurde dem Helm-Ökosystem ein zweites Element hinzugefügt.  Diese Intracluster-Komponente wurde Tiller genannt und war an der Installation von Helm-Diagrammen und deren Verwaltung beteiligt. <br><br>  Seit der Veröffentlichung von Helm 2 im Jahr 2016 hat Kubernetes eine Reihe wichtiger Innovationen erhalten.  Die rollenbasierte Zugriffskontrolle ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RBAC</a> ) wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eingeführt</a> , die schließlich die attributbasierte Zugriffskontrolle (ABAC) ersetzte.  Es wurden neue Arten von Ressourcen eingeführt (die Bereitstellungen befanden sich zu diesem Zeitpunkt noch im Beta-Status).  Benutzerdefinierte Ressourcendefinitionen (ursprünglich als Third Party Resources oder TPRs bezeichnet) wurden erfunden.  Und vor allem ist eine Reihe von Best Practices erschienen. <br><br>  Inmitten all dieser Änderungen diente Helm den Kubernetes-Benutzern weiterhin treu.  Nach drei Jahren und vielen Neuzugängen wurde klar, dass es an der Zeit war, wesentliche Änderungen an der Codebasis vorzunehmen, damit Helm weiterhin den wachsenden Anforderungen eines sich entwickelnden Ökosystems gerecht werden konnte. <br><br><h2>  Sanfter Abschied von Tiller </h2><br>  Während der Entwicklung von Helm 2 haben wir Tiller im Rahmen unserer Integration mit dem Deployment Manager von Google eingeführt.  Tiller spielte eine wichtige Rolle für Teams, die in einem gemeinsamen Cluster arbeiten: Verschiedene Spezialisten, die die Infrastruktur betreiben, konnten mit denselben Releases interagieren. <br><br>  Da die rollenbasierte Zugriffssteuerung (RBAC) in Kubernetes 1.6 standardmäßig aktiviert war, wurde die Arbeit mit Tiller in der Produktion schwieriger.  Aufgrund der Vielzahl möglicher Sicherheitsrichtlinien bestand unsere Position darin, standardmäßig Berechtigungen vorzuschlagen.  Dies ermöglichte es Anfängern, mit Helm und Kubernetes zu experimentieren, ohne zuerst in die Sicherheitseinstellungen eintauchen zu müssen.  Leider könnte diese zulässige Konfiguration dem Benutzer einen übermäßig großen Bereich von Berechtigungen verleihen, die er nicht benötigt.  Die Ingenieure von DevOps und SRE mussten zusätzliche Betriebsschritte erlernen, indem sie Tiller in einem mandantenfähigen Cluster installierten. <br><br>  Nachdem wir erfahren hatten, wie Community-Mitglieder Helm in bestimmten Situationen verwenden, stellten wir fest, dass das Release-Management-System von Tiller nicht auf eine Intra-Cluster-Komponente angewiesen sein musste, um den Status aufrechtzuerhalten oder als zentraler Hub mit Release-Informationen zu fungieren.  Stattdessen könnten wir einfach Informationen vom Kubernetes-API-Server abrufen, ein clientseitiges Diagramm erstellen und den Installationsdatensatz in Kubernetes speichern. <br><br>  Die Hauptaufgabe von Tiller konnte ohne Tiller ausgeführt werden, daher war eine unserer ersten Entscheidungen in Bezug auf Helm 3 die vollständige Ablehnung von Tiller. <br><br>  Mit Tillers Abgang wurde das Helm-Sicherheitsmodell radikal vereinfacht.  Helm 3 unterstützt jetzt alle modernen Sicherheits-, Identifikations- und Autorisierungsmethoden der heutigen Kubernetes.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helmberechtigungen</a> werden mithilfe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der kubeconfig-Datei ermittelt</a> .  Clusteradministratoren können Benutzerrechte mit jeder Granularitätsstufe einschränken.  Releases werden weiterhin im Cluster gespeichert, der Rest der Helm-Funktionalität bleibt erhalten. <br><br><h2>  Diagramm-Repositorys </h2><br>  Auf hoher Ebene ist das Diagramm-Repository ein Ort, an dem Sie Diagramme speichern und freigeben können.  Der Helm-Client packt die Diagramme und sendet sie an das Repository.  Einfach ausgedrückt ist das Diagramm-Repository ein primitiver HTTP-Server mit einer index.yaml-Datei und einigen gepackten Diagrammen. <br><br>  Obwohl die Diagramm-Repository-API einige Vorteile bietet, die die grundlegendsten Anforderungen für das Repository erfüllen, weist sie auch mehrere Nachteile auf: <br><br><ul><li>  Diagramm-Repositorys sind mit den meisten in einer Produktionsumgebung erforderlichen Sicherheitsimplementierungen schlecht kompatibel.  Eine Standard-API für die Authentifizierung und Autorisierung ist in Produktionsszenarien von entscheidender Bedeutung. </li><li>  Die Tools von Helm zur Verfolgung des Ursprungs des Diagramms, die zum Signieren, Überprüfen der Integrität und des Ursprungs des Diagramms verwendet werden, sind ein optionaler Bestandteil des Veröffentlichungsprozesses des Diagramms. </li><li>  In Mehrbenutzerszenarien kann dasselbe Diagramm von einem anderen Benutzer geladen werden, wodurch sich der zum Speichern desselben Inhalts erforderliche Speicherplatz verdoppelt.  Zur Lösung dieses Problems wurden intelligentere Repositories entwickelt, die jedoch nicht Teil der formalen Spezifikation sind. </li><li>  Die Verwendung einer einzelnen Indexdatei zum Suchen, Speichern von Metadaten und Abrufen von Diagrammen erschwerte die Entwicklung sicherer Mehrbenutzerimplementierungen. </li></ul><br>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker Distribution-</a> Projekt (auch als Docker Registry v2 bezeichnet) ist der Nachfolger der Docker Registry und fungiert als eine Reihe von Tools zum Verpacken, Senden, Speichern und Bereitstellen von Docker-Images.  Viele große Cloud-Dienste bieten verteilungsbasierte Produkte an.  Dank dieser erhöhten Aufmerksamkeit hat das Distributionsprojekt von langjährigen Verbesserungen, Best Practices in Bezug auf Sicherheit und Tests unter „Kampfbedingungen“ profitiert, die es zu einem der erfolgreichsten unbesungenen Helden der Open Source-Welt gemacht haben. <br><br>  Aber wussten Sie, dass das Distributionsprojekt darauf ausgelegt war, jede Form von Inhalten zu verbreiten, nicht nur Containerbilder? <br><br>  Dank der Bemühungen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open Container Initiative</a> (oder OCI) können Helmdiagramme auf jeder Verteilungsinstanz platziert werden.  Bisher ist dieser Prozess experimentell.  Die Arbeit an der Unterstützung von Anmeldungen und anderen Funktionen, die für einen vollwertigen Helm 3 erforderlich sind, ist noch nicht abgeschlossen, aber wir freuen uns sehr, aus den Entdeckungen der OCI- und Distribution-Teams im Laufe der Jahre zu lernen.  Und dank ihrer Betreuung und Führung lernen wir, wie ein hoch zugänglicher Dienst in großem Maßstab funktioniert. <br><br>  Eine detailliertere Beschreibung einiger anstehender Änderungen an den Helm-Charts-Repositorys finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  Release-Management </h2><br>  In Helm 3 wird der Status einer Anwendung innerhalb eines Clusters von mehreren Objekten überwacht: <br><br><ul><li>  Objekt freigeben - stellt eine Instanz der Anwendung dar; </li><li>  Versionsgeheimnis freigeben - repräsentiert den gewünschten Status der Anwendung zu einem bestimmten Zeitpunkt (z. B. die Freigabe einer neuen Version). </li></ul><br>  Durch Aufrufen von <code>helm install</code> werden ein Release-Objekt und ein Release-Versionsgeheimnis erstellt.  Das Aufrufen des <code>helm upgrade</code> erfordert ein Release-Objekt (das geändert werden kann) und erstellt ein neues Release-Versionsgeheimnis mit neuen Werten und einem vorbereiteten Manifest. <br><br>  Das Release-Objekt enthält Release-Informationen, wobei Release eine bestimmte Installation eines benannten Diagramms und von Werten ist.  Dieses Objekt beschreibt die Metadaten der obersten Ebene zur Version.  Das Release-Objekt bleibt während des gesamten Lebenszyklus der Anwendung erhalten und fungiert als Eigentümer aller Geheimnisse der Release-Version sowie aller Objekte, die direkt vom Helm-Diagramm erstellt werden. <br><br>  Das Versionsversionsgeheimnis verknüpft ein Release mit einer Reihe von Revisionen (Installation, Updates, Rollbacks, Deinstallation). <br><br>  In Helm 2 waren die Überarbeitungen äußerst konsistent.  Der <code>helm install</code> erstellt, das nachfolgende Upgrade Upgrade Version 2 und so weiter.  Release und Release-Versionsgeheimnis wurden zu einem einzigen Objekt zusammengefasst, das als Revision bezeichnet wird.  Revisionen wurden im selben Namespace wie Tiller gespeichert, was bedeutete, dass jede Version in Bezug auf den Namespace „global“ war.  Infolgedessen konnte nur eine Instanz des Namens verwendet werden. <br><br>  In Helm 3 ist jede Version einem oder mehreren Versionsversionsgeheimnissen zugeordnet.  Das Release-Objekt beschreibt immer das aktuelle Release, das in Kubernetes bereitgestellt wird.  Jedes Release-Versionsgeheimnis beschreibt nur eine Version dieser Version.  Ein Upgrade erstellt beispielsweise ein neues Geheimnis der Release-Version und ändert das Release-Objekt so, dass es auf diese neue Version verweist.  Im Falle eines Rollbacks können Sie die Geheimnisse der vorherigen Release-Version verwenden, um das Release auf den vorherigen Status zurückzusetzen. <br><br>  Nach dem Verlassen von Tiller speichert Helm 3 Release-Daten mit dem Release in einem einzigen Namespace.  Mit einer solchen Änderung können Sie ein Diagramm mit demselben Versionsnamen in einem anderen Namespace installieren und die Daten zwischen Cluster-Updates / Neustarts in etcd speichern.  Beispielsweise können Sie Wordpress im Namespace "foo" und dann im Namespace "bar" installieren. Beide Versionen können als "wordpress" bezeichnet werden. <br><br><h2>  Änderungen der Diagrammabhängigkeit </h2><br>  Diagramme, die (unter Verwendung des <code>helm package</code> ) für die Verwendung mit Helm 2 gepackt wurden, können mit Helm 3 installiert werden. Der Workflow für die Diagrammentwicklung wurde jedoch vollständig überarbeitet. Daher müssen einige Änderungen vorgenommen werden, um die Entwicklung von Diagrammen mit Helm 3 fortzusetzen. Insbesondere hat sich das Managementsystem geändert Diagrammabhängigkeiten. <br><br>  Das System zur Verwaltung von Diagrammabhängigkeiten wurde von <code>requirements.yaml</code> und <code>requirements.lock</code> zu <code>Chart.yaml</code> und <code>Chart.lock</code> .  Dies bedeutet, dass Diagramme, die den Befehl <code>helm dependency</code> eine gewisse Konfiguration erfordern, um in Helm 3 zu funktionieren. <br><br>  Schauen wir uns ein Beispiel an.  Fügen Sie dem Diagramm in Helm 2 eine Abhängigkeit hinzu und sehen Sie, was sich ändert, wenn Sie zu Helm 3 wechseln. <br><br>  In Helm 2 <code>requirements.yaml</code> sah yaml so aus: <br><br><pre> <code class="plaintext hljs">dependencies: - name: mariadb version: 5.xx repository: https://kubernetes-charts.storage.googleapis.com/ condition: mariadb.enabled tags: - database</code> </pre> <br>  In Helm 3 wird dieselbe Abhängigkeit in Ihrer <code>Chart.yaml</code> : <br><br><pre> <code class="plaintext hljs">dependencies: - name: mariadb version: 5.xx repository: https://kubernetes-charts.storage.googleapis.com/ condition: mariadb.enabled tags: - database</code> </pre> <br>  Die <code>charts/</code> werden weiterhin geladen und im Verzeichnis chart <code>charts/</code> abgelegt, sodass die Unterdiagramme im Verzeichnis chart <code>charts/</code> unverändert weiter funktionieren. <br><br><h2>  Einführung in Bibliotheksdiagramme </h2><br>  Helm 3 unterstützt eine Diagrammklasse namens <i>Bibliotheksdiagramm</i> .  Dieses Diagramm wird von anderen Diagrammen verwendet, erstellt jedoch keine eigenen Release-Artefakte.  Bibliotheksdiagrammvorlagen können nur <code>define</code> Elemente deklarieren.  Andere Inhalte werden einfach ignoriert.  Auf diese Weise können Benutzer Codefragmente wiederverwenden und freigeben, die in vielen Diagrammen verwendet werden können, wodurch Doppelarbeit vermieden und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DRY-</a> Prinzip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eingehalten</a> wird. <br><br>  Bibliotheksdiagramme werden im Abschnitt " <code>dependencies</code> " der Datei " <code>Chart.yaml</code> .  Installation und Verwaltung unterscheiden sich nicht von anderen Diagrammen. <br><br><pre> <code class="plaintext hljs">dependencies: - name: mylib version: 1.xx repository: quay.io</code> </pre> <br>  Wir freuen uns auf die Anwendungsfälle, die diese Komponente für Diagrammentwickler öffnen wird, sowie auf die Best Practices, die sich aus Bibliotheksdiagrammen ergeben können. <br><br><h2>  Was weiter? </h2><br>  Helm 3.0.0-alpha.1 - die Basis, auf der wir mit der Erstellung einer neuen Version von Helm beginnen.  In dem Artikel habe ich einige interessante Merkmale von Helm 3 beschrieben. Viele von ihnen befinden sich noch in einem frühen Entwicklungsstadium, und dies ist normal.  Die Essenz der Alpha-Version besteht darin, die Idee zu testen, Feedback von den ersten Benutzern zu sammeln und unsere Annahmen zu bestätigen. <br><br>  Sobald die Alpha-Version veröffentlicht ist <i>(denken Sie daran, dass dies <a href="">bereits geschehen ist</a> - ca. übersetzt)</i> , werden wir von der Community Patches für Helm 3 erhalten.  Es ist notwendig, eine solide Grundlage zu schaffen, auf der Sie neue Funktionen entwickeln und übernehmen können, und die Benutzer können sich in den Prozess involviert fühlen, Tickets öffnen und Korrekturen vornehmen. <br><br>  In dem Artikel habe ich versucht, einige ernsthafte Verbesserungen hervorzuheben, die in Helm 3 erscheinen werden, aber diese Liste ist keineswegs vollständig.  Der vollständige Plan für Helm 3 umfasst Innovationen wie verbesserte Aktualisierungsstrategien, eine tiefere Integration in OCI-Register und die Verwendung von JSON-Schemata zur Überprüfung von Diagrammwerten.  Wir planen auch, die Codebasis zu löschen und die Teile davon zu aktualisieren, die in den letzten drei Jahren vernachlässigt wurden. <br><br>  Wenn Sie das Gefühl haben, dass wir etwas verpasst haben, freuen wir uns über Ihre Gedanken! <br><br>  Nehmen Sie an der Diskussion in unseren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slack-Kanälen teil</a> : <br><br><ul><li>  <code>#helm-users</code> für Fragen und einfache Kommunikation mit der Community; </li><li>  <code>#helm-dev</code> , um Pull-Anfragen, Code und Fehler zu besprechen. </li></ul><br>  Sie können auch donnerstags um 19:30 Uhr MSK in unseren wöchentlichen öffentlichen Entwickleranrufen chatten.  Die Meetings sind der Erörterung der Aufgaben gewidmet, an denen wichtige Entwickler und die Community arbeiten, sowie der Diskussionsthemen für die Woche.  Jeder kann an dem Meeting teilnehmen.  Der Link ist im <code>#helm-dev</code> Slack-Kanal verfügbar. <br><br><h2>  PS vom Übersetzer </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paketmanager für Kubernetes - Helm: Vergangenheit, Gegenwart, Zukunft</a> "; </li><li>  "Ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nüchterner Blick auf Helm 2:" Das ist es ... "</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine praktische Einführung in den Paketmanager für Kubernetes - Helm</a> "; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tipps und Tricks von Kubernetes: Übertragen von Ressourcen in einem Cluster auf Helm 2</a> “; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übe mit dapp.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2. Bereitstellen von Docker-Images in Kubernetes mit Helm</a> . " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453734/">https://habr.com/ru/post/de453734/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453720/index.html">Feinheiten von Lambda-Ausdrücken in C #</a></li>
<li><a href="../de453722/index.html">Über die Erforschung instationärer Prozesse</a></li>
<li><a href="../de453728/index.html">Schlacht der Hyperstars</a></li>
<li><a href="../de453730/index.html">Moderne Zahnmedizin: gleichzeitige Zahnimplantation und Streckung des Kieferknochens durch die Augen des technischen Direktors</a></li>
<li><a href="../de453732/index.html">Ich komme aus Moreinis. Schräge Ansichten oder Respekt?</a></li>
<li><a href="../de453742/index.html">Memcached Plugin: NoSQL in MySQL</a></li>
<li><a href="../de453744/index.html">Wir untersuchen das Prinzip der Pseudoklasse: not () am Beispiel der Aufgabe „Hervorheben der aktiven Zeile einer Tabelle in reinem CSS“.</a></li>
<li><a href="../de453748/index.html">Prototyping eines Handyspiels, wo man anfängt und wie man es macht. Teil 3 (endgültig)</a></li>
<li><a href="../de453750/index.html">Über den jüngsten Cyberangriff in Baltimore</a></li>
<li><a href="../de453756/index.html">Probleme der aktuellen Methodik zur Ermittlung aktueller Bedrohungen durch die FSTEC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>