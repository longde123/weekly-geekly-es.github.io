<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”™ ğŸ§ ğŸ¤” Bagaimana dan mengapa kami melakukan pengakuan tengara di Cloud Mail.ru ğŸ§ ğŸ‡ ğŸŒƒ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dengan munculnya kamera berkualitas tinggi di telepon seluler, kami memotret semakin sering, merekam video dari momen-momen penting dan cerah dalam hi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana dan mengapa kami melakukan pengakuan tengara di Cloud Mail.ru</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/451542/"><img src="https://habrastorage.org/getpro/habr/post_images/a5d/eeb/615/a5deeb615e9a57fb482a1a5464ab6fcc.png"><br><br>  Dengan munculnya kamera berkualitas tinggi di telepon seluler, kami memotret semakin sering, merekam video dari momen-momen penting dan cerah dalam hidup kita.  Banyak dari kita memiliki arsip foto sejak puluhan tahun dan ribuan foto, yang semakin sulit dinavigasi.  Ingat berapa lama waktu yang dibutuhkan untuk menemukan foto yang tepat beberapa tahun yang lalu. <br><br>  Salah satu tujuan Mail.ru Cloud adalah untuk menyediakan akses dan pencarian paling nyaman di arsip foto dan video Anda.  Untuk melakukan ini, kami, tim visi mesin Mail.ru, telah menciptakan dan menerapkan sistem pemrosesan foto pintar: pencarian berdasarkan objek, adegan, wajah, dll. Teknologi mencolok lainnya adalah pengenalan pemandangan.  Dan hari ini saya akan berbicara tentang bagaimana kami menyelesaikan masalah ini dengan bantuan Deep Learning. <br><a name="habracut"></a><br>  Bayangkan situasinya: Anda pergi berlibur dan membawa banyak foto.  Dan dalam percakapan dengan teman-teman, mereka meminta Anda untuk menunjukkan bagaimana Anda mengunjungi istana, kastil, piramida, kuil, danau, air terjun, gunung, dll.  Anda mulai dengan gulir menelusuri folder dengan foto, mencoba menemukan yang tepat.  Kemungkinan besar, Anda tidak menemukannya di antara ratusan gambar, dan mengatakan bahwa Anda akan ditampilkan nanti. <br><br>  Kami mengatasi masalah ini dengan mengelompokkan foto khusus ke dalam album.  Ini membuatnya mudah untuk menemukan gambar yang tepat hanya dalam beberapa klik.  Sekarang kami memiliki album di wajah, pada objek dan adegan, serta pada atraksi. <br><br>  Foto dengan tengara penting karena sering menampilkan momen penting dalam hidup kita (misalnya, perjalanan).  Ini bisa berupa foto di latar belakang beberapa struktur arsitektur atau sudut alam yang tidak tersentuh manusia.  Oleh karena itu, kita perlu menemukan foto-foto ini dan memberi pengguna akses yang mudah dan cepat ke foto-foto itu. <br><br><h1>  Pengenalan fitur </h1><br>  Tetapi ada nuansa: Anda tidak bisa hanya mengambil dan melatih beberapa model untuk mengenali pemandangan, ada banyak kesulitan. <br><br><ul><li>  Pertama, kita tidak bisa dengan jelas menggambarkan apa itu "landmark".  Kami tidak bisa mengatakan mengapa satu bangunan adalah landmark, dan berdiri di sebelahnya bukan.  Ini bukan konsep formal, yang mempersulit perumusan masalah pengakuan. <br></li><li>  Kedua, pemandangannya sangat beragam.  Ini bisa berupa bangunan bersejarah atau budaya - kuil, istana, istana.  Ini bisa menjadi monumen yang paling beragam.  Ini bisa menjadi benda alami - danau, ngarai, air terjun.  Dan satu model harus dapat menemukan semua atraksi ini. <br></li><li>  Ketiga, ada sangat sedikit gambar dengan pemandangan, menurut perhitungan kami, mereka hanya ditemukan di 1-3% dari foto pengguna.  Oleh karena itu, kami tidak dapat membiarkan diri kami kesalahan dalam pengakuan, karena jika kami menunjukkan foto kepada seseorang tanpa minat, itu akan segera terlihat dan akan menyebabkan kebingungan dan reaksi negatif.  Atau, sebaliknya, kami menunjukkan orang itu foto dengan tengara di New York, dan dia belum pernah ke Amerika.  Jadi model pengakuan harus memiliki FPR yang rendah (false positive rate). <br></li><li>  Keempat, sekitar 50% pengguna, atau bahkan lebih, mematikan penyimpanan informasi geografis saat memotret.  Kita perlu mempertimbangkan ini dan menentukan tempat hanya dari gambar.  Sebagian besar layanan yang saat ini entah bagaimana berhasil bekerja dengan tempat-tempat menarik melakukan ini berkat geodata.  Persyaratan awal kami lebih ketat. <br></li></ul><br>  Saya akan tunjukkan sekarang dengan contoh. <br><br>  Berikut adalah benda-benda serupa, tiga katedral Gothic Prancis.  Di sebelah kiri adalah Katedral Amiens, di tengah-tengah Katedral Reims, di sebelah kanan adalah Notre Dame de Paris. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd4/da6/7f7/bd4da67f77caa21c8afdd344e1e1a05a.png"><br><br>  Bahkan seseorang perlu waktu untuk melihatnya dan memahami bahwa ini adalah katedral yang berbeda, dan mesin itu juga harus dapat mengatasinya, dan lebih cepat daripada seseorang. <br><br>  Dan ini adalah contoh kesulitan lain: tiga foto pada slide adalah Notre Dame de Paris, diambil dari sudut yang berbeda.  Foto-foto itu ternyata sangat berbeda, tetapi semuanya perlu dikenali dan ditemukan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/837/0a4/f9b/8370a4f9b8785814cd4cc7368770aac2.png"><br><br>  Benda-benda alami sama sekali berbeda dari benda-benda arsitektur.  Di sebelah kiri adalah Kaisarea di Israel, di sebelah kanan adalah Taman Inggris di Munich. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/55d/632/245/55d632245cf529e935e25a78de40f020.png"><br><br>  Dalam foto-foto ini ada beberapa detail karakteristik yang modelnya dapat â€œtangkapâ€. <br><br><h1>  Metode kami </h1><br>  Metode kami sepenuhnya didasarkan pada jaringan saraf convolutional yang mendalam.  Sebagai pendekatan untuk belajar, mereka memilih apa yang disebut belajar kurikulum - belajar dalam beberapa tahap.  Agar dapat bekerja lebih efisien baik dengan keberadaan geodata maupun dengan tidak adanya geodata, kami membuat inferensi khusus (kesimpulan).  Saya akan memberi tahu Anda tentang masing-masing tahap secara lebih rinci. <br><br><h1>  Datacet </h1><br>  Bahan bakar untuk pembelajaran mesin adalah data.  Dan pertama-tama, kami perlu mengumpulkan dataset untuk pelatihan model. <br><br>  Kami membagi dunia menjadi 4 wilayah, yang masing-masing digunakan pada berbagai tahap pelatihan.  Kemudian, negara diambil di setiap daerah, untuk setiap negara disusun daftar kota dan database foto-foto atraksi mereka disusun.  Contoh data disajikan di bawah ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f6/e54/629/3f6e546299616e59efd6a1a1464b9b65.png"><br><br>  Pertama, kami mencoba untuk melatih model kami di pangkalan yang dihasilkan.  Hasilnya buruk.  Mereka mulai menganalisis, dan ternyata datanya sangat "kotor."  Setiap objek wisata memiliki sejumlah besar sampah.  Apa yang harus dilakukan  Secara manual meninjau seluruh jumlah data yang besar itu mahal, suram, dan tidak terlalu pintar.  Oleh karena itu, kami melakukan pembersihan pangkalan secara otomatis, di mana pemrosesan manual hanya digunakan pada satu langkah: untuk setiap daya tarik, kami secara manual memilih 3-5 foto referensi yang secara akurat mengandung daya tarik yang diinginkan dalam perspektif yang kurang lebih benar.  Ternyata cukup cepat, karena volume data referensi tersebut relatif kecil dibandingkan dengan keseluruhan database.  Kemudian, pembersihan otomatis berdasarkan jaringan saraf convolutional yang dalam sudah dilakukan. <br><br>  Selanjutnya saya akan menggunakan istilah "embedding", dimana saya akan mengerti yang berikut.  Kami memiliki jaringan saraf convolutional, kami melatihnya untuk klasifikasi, memotong lapisan klasifikasi terakhir, mengambil beberapa gambar, melewati jaringan dan mendapat vektor numerik pada output.  Saya akan menyebutnya embedding. <br><br>  Seperti yang saya katakan, pelatihan kami dilakukan dalam beberapa tahap, sesuai dengan bagian dari basis data kami.  Oleh karena itu, pertama-tama kita mengambil jaringan saraf dari tahap sebelumnya, atau jaringan inisialisasi. <br><br>  Kami akan menjalankan foto-foto pemandangan melalui jaringan dan mendapatkan beberapa embeddings.  Sekarang Anda dapat membersihkan alasnya.  Kami mengambil semua gambar dari dataset untuk objek wisata ini, dan kami juga mengarahkan setiap gambar melalui jaringan.  Kami mendapatkan banyak embeddings dan untuk masing-masing kami mempertimbangkan jarak ke embedding standar.  Lalu kami menghitung jarak rata-rata, dan jika lebih dari ambang tertentu, yang merupakan parameter algoritma, maka kami menganggap bahwa ini bukan objek wisata.  Jika jarak rata-rata kurang dari ambang, maka kami meninggalkan foto ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/305/300/a87/305300a8734289229c57e0d1876fa74e.png"><br><br>  Hasilnya, kami mendapat basis data yang berisi lebih dari 11 ribu objek wisata dari lebih dari 500 kota di 70 negara di dunia - lebih dari 2,3 juta foto.  Sekarang saatnya untuk mengingat bahwa sebagian besar foto tidak mengandung atraksi sama sekali.  Informasi ini perlu dibagikan dengan model kami.  Karena itu, kami menambahkan 900 ribu foto tanpa pemandangan ke database kami, dan melatih model kami pada dataset yang dihasilkan. <br><br>  Untuk mengukur kualitas pelatihan, kami memperkenalkan tes offline.  Berdasarkan fakta bahwa pemandangan hanya ditemukan di sekitar 1-3% dari foto, kami secara manual menyusun satu set foto yang menunjukkan pemandangan.  Ini adalah foto yang berbeda dan cukup kompleks dengan sejumlah besar objek yang diambil dari sudut yang berbeda, sehingga pengujiannya sesulit mungkin untuk model.  Dengan prinsip yang sama, kami memilih 11 ribu foto tanpa pemandangan, yang juga cukup rumit, dan kami mencoba menemukan objek yang sangat mirip dengan pemandangan yang tersedia di database kami. <br><br>  Untuk menilai kualitas pelatihan, kami mengukur akurasi model kami dari foto dengan dan tanpa pemandangan.  Ini adalah dua metrik utama kami. <br><br><h1>  Pendekatan yang ada </h1><br>  Hanya ada sedikit informasi tentang pengenalan penglihatan dalam literatur ilmiah.  Sebagian besar solusi didasarkan pada fitur-fitur lokal.  Idenya adalah bahwa kita memiliki gambar permintaan tertentu dan gambar dari database.  Dalam foto-foto ini kami menemukan tanda-tanda lokal - poin utama, dan membandingkannya.  Jika jumlah pertandingan cukup besar, kami pikir kami telah menemukan tempat menarik. <br><br>  Sampai saat ini, metode terbaik adalah metode yang diusulkan Google, DELF (fitur lokal mendalam), di mana perbandingan fitur lokal dikombinasikan dengan pembelajaran mendalam.  Dengan menjalankan gambar input melalui jaringan konvolusi, kami mendapatkan beberapa tanda DELF. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e17/a2d/803/e17a2d803135ba5a7821842f035b1cf8.png"><br><br>  Bagaimana pengakuan atraksi?  Kami memiliki basis data foto dan gambar input, dan kami ingin memahami apakah ada objek wisata di sana atau tidak.  Kami menjalankan semua gambar melalui DELF, kami mendapatkan tanda-tanda yang sesuai untuk basis dan untuk gambar input.  Kemudian kami melakukan pencarian menggunakan metode tetangga terdekat dan pada output kami mendapatkan gambar kandidat dengan tanda.  Kami membandingkan tanda-tanda ini dengan bantuan verifikasi geometrik: jika mereka berhasil lulus, maka kami percaya bahwa ada hal yang menarik dalam gambar. <br><br><h1>  Jaringan Saraf Konvolusional </h1><br>  Untuk Deep Learning, pra-pelatihan sangat penting.  Oleh karena itu, kami mengambil basis adegan dan pra-terlatih di atasnya jaringan saraf kami.  Kenapa begitu?  Adegan adalah objek kompleks yang mencakup sejumlah besar objek lain.  Dan daya tarik adalah kasus khusus dari pemandangan itu.  Model pra-pelatihan atas dasar seperti itu, kami dapat memberikan model gagasan tentang beberapa fitur tingkat rendah yang kemudian dapat digeneralisasi untuk keberhasilan pengakuan objek wisata. <br><br>  Sebagai model, kami menggunakan jaringan saraf dari keluarga jaringan Residual.  Fitur utama mereka adalah bahwa mereka menggunakan blok residual, yang mencakup koneksi lewati, yang memungkinkan sinyal untuk melewati bebas tanpa masuk ke lapisan dengan bobot.  Dengan arsitektur ini, Anda dapat secara kualitatif melatih jaringan yang dalam dan menangani efek gradient blur, yang sangat penting saat belajar. <br><br>  Model kami adalah Wide ResNet 50-2, modifikasi dari ResNet 50, di mana jumlah konvolusi dalam blok bottleneck internal menjadi dua kali lipat. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/008/a1f/544/008a1f544843103423b5bcdb4c8b1fe5.png"><br><br>  Jaringannya sangat efisien.  Kami melakukan tes pada database adegan kami dan inilah yang kami dapatkan: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Model <br></th><th>  1 err teratas <br></th><th>  5 err teratas <br></th></tr><tr><td>  ResNet-50 <br></td><td>  46,1% <br></td><td>  15,7% <br></td></tr><tr><td>  ResNet-200 <br></td><td>  42,6% <br></td><td>  12,9% <br></td></tr><tr><td>  SE-ResNext-101 <br></td><td>  42% <br></td><td>  12,1% <br></td></tr><tr><td>  WRN-50-2 (cepat!) <br></td><td>  41,8% <br></td><td>  11,8% <br></td></tr></tbody></table></div><br>  Wide ResNet ternyata hampir dua kali lebih cepat dari jaringan ResNet 200 yang agak besar. Dan kecepatan operasi sangat penting untuk operasi.  Berdasarkan totalitas dari keadaan ini, kami mengambil Wide ResNet 50-2 sebagai jaringan saraf utama kami. <br><br><h2>  Pelatihan </h2><br>  Untuk melatih jaringan, kita perlu kehilangan (loss function).  Untuk memilihnya, kami memutuskan untuk menggunakan pendekatan pembelajaran metrik: jaringan saraf dilatih sehingga perwakilan dari kelas yang sama ditarik bersama dalam satu cluster.  Pada saat yang sama, klaster untuk kelas yang berbeda harus terpisah sejauh mungkin.  Untuk atraksi, kami menggunakan Center loss, yang mengumpulkan poin dari kelas yang sama ke pusat tertentu.  Fitur penting dari pendekatan ini adalah tidak memerlukan pengambilan sampel negatif, yang pada tahap akhir pelatihan merupakan prosedur yang agak sulit. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/27a/ed1/cfb/27aed1cfbe8d7cffa90bc1a96b578eff.png"><br><br>  Biarkan saya mengingatkan Anda bahwa kami memiliki n kelas atraksi dan kelas "bukan atraksi" lainnya, Center loss tidak digunakan untuk itu.  Maksud kami, tengara adalah satu dan objek yang sama, dan ada struktur di dalamnya, oleh karena itu disarankan untuk mempertimbangkan pusatnya.  Tapi bukan daya tarik wisata yang bisa apa saja, dan menganggap pusat baginya tidak masuk akal. <br><br>  Lalu kami menggabungkan semuanya dan mendapatkan model untuk pelatihan.  Ini terdiri dari tiga bagian utama: <br><br><ul><li>  Jaringan saraf convolutional Wide ResNet 50-2, pra-dilatih berdasarkan adegan; <br></li><li>  Bagian penyisipan yang terdiri dari lapisan yang terhubung penuh dan lapisan norma Batch; <br></li><li>  Klasifikasi, yang merupakan lapisan yang sepenuhnya terhubung, diikuti oleh sepasang kerugian Softmax dan kerugian Tengah. <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/6dd/7bf/338/6dd7bf33835ea1d84565a04c5ff1e281.jpg"><br><br>  Seperti yang Anda ingat, basis kami dibagi menjadi 4 bagian berdasarkan wilayah dunia.  Kami menggunakan 4 bagian ini sebagai bagian dari paradigma pembelajaran kurikulum.  Pada setiap tahap, kami memiliki dataset saat ini, kami menambahkan bagian lain dunia ke dalamnya dan kami mendapatkan dataset pelatihan baru. <br><br>  Model ini terdiri dari tiga bagian, dan untuk masing-masing kami menggunakan tingkat pembelajaran kami sendiri dalam pelatihan.  Ini diperlukan agar jaringan tidak hanya dapat mempelajari pemandangan dari bagian baru dari dataset yang kami tambahkan, tetapi juga agar tidak melupakan data yang telah dipelajari.  Setelah banyak percobaan, pendekatan ini ternyata menjadi yang paling efektif. <br><br>  Jadi, kami melatih modelnya.  Anda perlu memahami cara kerjanya.  Mari kita gunakan peta aktivasi kelas untuk melihat bagian mana dari gambar yang paling responsif terhadap jaringan saraf kita.  Pada gambar di bawah ini, di baris pertama, gambar input, dan di baris kedua mereka ditumpangkan peta aktivasi kelas dari grid, yang kami latih pada langkah sebelumnya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5aa/4aa/264/5aa4aa26413082931c28f1a393a64b95.png"><br><br>  Peta panas menunjukkan bagian gambar yang lebih diperhatikan jaringan.  Dari peta aktivasi kelas dapat dilihat bahwa jaringan saraf kita telah berhasil mempelajari konsep tarik-menarik. <br><br><h2>  Kesimpulan </h2><br>  Sekarang Anda perlu entah bagaimana menggunakan pengetahuan ini untuk mendapatkan hasilnya.  Karena kami menggunakan Center loss untuk pelatihan, tampaknya cukup logis untuk menyimpulkan juga menghitung tserotoid untuk atraksi. <br><br>  Untuk ini, kami mengambil bagian dari gambar dari set pelatihan untuk beberapa jenis atraksi, misalnya, untuk Penunggang Kuda Perunggu.  Kami menjalankannya melalui jaringan, mendapatkan embeddings, rata-rata dan mendapatkan centroid. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c49/b0f/69e/c49b0f69e33581f30c05985a98702f6f.png"><br><br>  Tetapi muncul pertanyaan: berapa banyak centroid untuk satu daya tarik yang masuk akal untuk dihitung?  Pada awalnya, jawabannya tampak jelas dan logis: satu centroid.  Tapi ini ternyata tidak begitu.  Pada awalnya, kami juga memutuskan untuk membuat satu centroid dan mendapatkan hasil yang cukup bagus.  Jadi mengapa Anda perlu mengambil beberapa centroid? <br><br>  Pertama, data kami tidak sepenuhnya bersih.  Meskipun kami membersihkan dataset, kami hanya membuang sampah saja.  Dan kita dapat memiliki gambar yang tidak dapat dianggap sampah, tetapi yang memperburuk hasilnya. <br><br>  Sebagai contoh, saya memiliki kelas landmark Istana Musim Dingin.  Saya ingin menghitung centroid untuknya.  Tetapi set termasuk sejumlah foto dengan Palace Square dan lengkungan Gedung Staf Umum.  Jika kita mempertimbangkan centroid di semua gambar, hasilnya tidak terlalu stabil.  Penting untuk mengelompokkan embeddings mereka, yang diperoleh dari grid biasa, hanya mengambil centroid yang bertanggung jawab untuk Winter Palace, dan menghitung rata-rata berdasarkan data ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/000/7b7/8ef/0007b78efb3d15296bab0ebef0cf4dfb.png"><br><br>  Kedua, foto dapat diambil dari berbagai sudut. <br><br>  Saya akan mengutip menara lonceng Belfort di Bruges sebagai ilustrasi perilaku ini.  Dua centroid dihitung untuknya.  Di baris atas gambar adalah foto-foto yang lebih dekat ke centroid pertama, dan di baris kedua - yang lebih dekat ke centroid kedua: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d13/5f4/105/d135f4105f2823a612e458f946e25221.png"><br><br>  Centroid pertama bertanggung jawab atas foto-foto close-up yang lebih "pintar" yang diambil dari Bruges Market Square.  Dan centroid kedua bertanggung jawab atas foto yang diambil dari jauh, dari jalan-jalan yang berdekatan. <br><br>  Ternyata dengan menghitung beberapa centroid per kelas dari suatu tempat menarik, kita dapat menampilkan sudut berbeda dari tempat menarik ini dalam inferensi. <br><br>  Jadi, bagaimana kita menemukan set ini untuk menghitung centroid?  Kami menerapkan pengelompokan hierarkis ke kumpulan data untuk setiap tempat menarik - tautan lengkap.  Dengan bantuannya, kami menemukan kluster yang valid untuk menghitung centroid.  Yang kami maksudkan adalah cluster yang, sebagai hasil pengelompokan, mengandung setidaknya 50 foto.  Cluster yang tersisa dibuang.  Hasilnya, ternyata sekitar 20% pemandangan memiliki lebih dari satu centroid. <br><br>  Sekarang inferensi.  Kami menghitungnya dalam dua tahap: pertama, kami menjalankan gambar input melalui jaringan saraf convolutional kami dan mendapatkan embedding, dan kemudian menggunakan produk skalar yang kami bandingkan dengan embedding dengan centroid.  Jika gambar berisi geodata, maka kami membatasi pencarian untuk centroid, yang terkait dengan objek wisata yang terletak di kotak 1 per 1 km dari lokasi pemotretan.  Ini memungkinkan Anda untuk mencari lebih tepat, memilih ambang yang lebih rendah untuk perbandingan selanjutnya.  Jika jarak yang diperoleh lebih besar dari ambang, yang merupakan parameter algoritma, maka kita mengatakan bahwa di foto ada titik menarik dengan nilai maksimum dari produk skalar.  Jika kurang, maka ini bukan objek wisata. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d01/75c/5a5/d0175c5a5142647bf9446f7d65df0509.png"><br><br>  Misalkan foto tersebut mengandung tengara.  Jika kami memiliki geodata, maka kami menggunakannya dan menampilkan jawabannya.  Jika tidak ada geodata, maka kami melakukan pemeriksaan tambahan.  Ketika kami membersihkan dataset, kami membuat satu set gambar referensi untuk setiap kelas atraksi.  Bagi mereka, kita bisa menghitung embeddings, dan kemudian kita menghitung jarak rata-rata dari mereka ke embedding gambar permintaan.  Jika lebih dari ambang tertentu, maka verifikasi dilewati, kami menyertakan metadata dan menampilkan hasilnya.  Penting untuk dicatat bahwa kita dapat melakukan prosedur semacam itu untuk beberapa objek wisata yang ditemukan dalam gambar. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/14b/ffe/04f/14bffe04fe6ca1b3d09876432e319e53.png"><br><br><h1>  Hasil tes </h1><br>  Kami membandingkan model kami dengan DELF, di mana kami mengambil parameter yang menunjukkan hasil terbaik pada pengujian kami.  Hasilnya hampir sama. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Model <br></th><th>  Pemandangan <br></th><th>  Tidak ada atraksi <br></th></tr><tr><td>  Kami <br></td><td>  80% <br></td><td>  99% <br></td></tr><tr><td>  Delf <br></td><td>  80,1% <br></td><td>  99% <br></td></tr></tbody></table></div><br>       :  ( 100 ),   87 %     ,  .      :  85,3 %.      46 %,     â€”          . <br><br><div class="scrollable-table"><table><tbody><tr><th>  <br></th><th>  <br></th><th>     <br></th></tr><tr><td>  <br></td><td> 85,3 % <br></td><td> 87 % <br></td></tr><tr><td>  <br></td><td> 46 % <br></td><td> 13 % <br></td></tr></tbody></table></div><br>    /B-   .          10 %,       3 %,       13 %. <br><br>       DELF.  GPU DELF  7  ,    7  ,      1 .  CPU DELF             .      CPU   15  .        ,     . <br><br><h1> :    </h1><br>               .  . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72c/df4/52e/72cdf452e2105c18f8e4375a1b69d497.png"><br><br>   ,        .   Â«Â», Â«Â», Â«Â».      ,    .      ,        . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec6/7f8/929/ec67f892964ee568754a86cd48e16b51.png"><br><br>   :   , ,   .       Instagram      ,      ,    â€”     . <br><br><h1>  </h1><br>      . <br><br><ol><li>   .      ,      .           . <br></li><li>        deep metric learning,        . <br></li><li>       curriculum learning â€”   .      .  inference    ,           . <br></li></ol><br>  ,   â€”    .     ,     ,    .         -   .      ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451542/">https://habr.com/ru/post/id451542/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451528/index.html">â€œDan begitulahâ€: penyedia cloud tidak menyetujui data pribadi</a></li>
<li><a href="../id451532/index.html">Berita dari dunia OpenStreetMap No. 459 (30/4/2019 - 06/05/2019)</a></li>
<li><a href="../id451534/index.html">12 prinsip animasi dalam pengembangan video game</a></li>
<li><a href="../id451538/index.html">Panduan Penskalaan Paralel Redshift Amazon dan Hasil Uji</a></li>
<li><a href="../id451540/index.html">Berapa Banyak Pengembang yang Perlu Membuat Layanan Seperti Airbnb</a></li>
<li><a href="../id451552/index.html">Kami membangun saluran penjualan jaringan gadget DO-RA</a></li>
<li><a href="../id451556/index.html">Flutter: pelokalan aplikasi menggunakan Android Studio</a></li>
<li><a href="../id451558/index.html">Suatu hari dalam kehidupan otomatisasi QA</a></li>
<li><a href="../id451560/index.html">Pelanggan yang terhormat, itu sebabnya perubahan ini butuh waktu lama.</a></li>
<li><a href="../id451562/index.html">Bagaimana cara melarikan diri dari sekte?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>